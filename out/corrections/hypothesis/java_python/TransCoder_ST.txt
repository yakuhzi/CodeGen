========================SOURCE============================    ==========================REF=============================    =========================HYPO=============================	  ==========================OUT=============================
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_AREA_SQUARE					      PROGRAM_AREA_SQUARE					    PROGRAM_AREA_SQUARE						  PROGRAM_AREA_SQUARE
--							      --							    --								  --
static int areaSquare ( int side ) {			      def areaSquare ( side ) :					    def area_square ( side ) :					  success : None
  int area = side * side ;				      	  area = side * side					    	area = side * side					  
  return area ;						      	  return area						    	return area						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TURN_OFF_THE_RIGHTMOST_SET_BIT				      TURN_OFF_THE_RIGHTMOST_SET_BIT				    TURN_OFF_THE_RIGHTMOST_SET_BIT				  TURN_OFF_THE_RIGHTMOST_SET_BIT
--							      --							    --								  --
static int fun ( int n ) {				      def fun ( n ) :						    def fun ( n ) :						  success : identical to gold
  return n & ( n - 1 ) ;				      	  return n & ( n - 1 )					    	return n & ( n - 1 )					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			      MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			    MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			  MAXIMUM_POINTS_INTERSECTION_N_CIRCLES
--							      --							    --								  --
static int intersection ( int n ) {			      def intersection ( n ) :					    def intersection ( n ) :					  success : identical to gold
  return n * ( n - 1 ) ;				      	  return n * ( n - 1 )					    	return n * ( n - 1 )					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEXAGONAL_NUMBER					      HEXAGONAL_NUMBER						    HEXAGONAL_NUMBER						  HEXAGONAL_NUMBER
--							      --							    --								  --
int hexagonalNum ( int n ) {				      def hexagonalNum ( n ) :					    def hexagonalNum ( n ) :					  success : identical to gold
  return n * ( 2 * n - 1 ) ;				      	  return n * ( 2 * n - 1 )				    	return n * ( 2 * n - 1 )				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CASSINIS_IDENTITY					      CASSINIS_IDENTITY						    CASSINIS_IDENTITY						  CASSINIS_IDENTITY
--							      --							    --								  --
static int cassini ( int n ) {				      def cassini ( n ) :					    def cassini ( n ) :						  success : None
  return ( n & 1 ) != 0 ? - 1 : 1 ;			      	  return - 1 if ( n & 1 ) else 1			    	return ( - 1 if n & 1 else 1 )				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ADD_1_TO_A_GIVEN_NUMBER_1				      ADD_1_TO_A_GIVEN_NUMBER_1					    ADD_1_TO_A_GIVEN_NUMBER_1					  ADD_1_TO_A_GIVEN_NUMBER_1
--							      --							    --								  --
static int addOne ( int x ) {				      def addOne ( x ) :					    def add_one ( x ) :						  success : None
  return ( - ( ~ x ) ) ;				      	  return ( - ( ~ x ) )					    	return ( - ( ~ x ) )					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_TWO_HALVES_SORTED				      SORT_ARRAY_TWO_HALVES_SORTED				    SORT_ARRAY_TWO_HALVES_SORTED				  SORT_ARRAY_TWO_HALVES_SORTED
--							      --							    --								  --
static void mergeTwoHalf ( int [ ] A , int n ) {	      def mergeTwoHalf ( A , n ) :				    def merge_two_half ( A , n ) :				  success : None
  Arrays . sort ( A ) ;					      	  A.sort ( )						    	A.sort ( )						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
AREA_SQUARE_CIRCUMSCRIBED_CIRCLE			      AREA_SQUARE_CIRCUMSCRIBED_CIRCLE				    AREA_SQUARE_CIRCUMSCRIBED_CIRCLE				  AREA_SQUARE_CIRCUMSCRIBED_CIRCLE
--							      --							    --								  --
static int find_Area ( int r ) {			      def find_Area ( r ) :					    def find_area ( r ) :					  success : None
  return ( 2 * r * r ) ;				      	  return ( 2 * r * r )					    	return ( 2 * r * r )					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			      FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			    FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			  FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT
--							      --							    --								  --
static boolean check ( int n ) {			      def check ( n ) :						    def check ( n ) :						  success : identical to gold
  return 1162261467 % n == 0 ;				      	  return 1162261467 % n == 0				    	return 1162261467 % n == 0				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD			      CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD			    CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD				  CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD
--							      --							    --								  --
public static boolean isEven ( int n ) {		      def isEven ( n ) :					    def is_even ( n ) :						  success : None
  return ( n % 2 == 0 ) ;				      	  return ( n % 2 == 0 )					    	return ( n % 2 == 0 )					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_PENTAGONAL_NUMBER					      NTH_PENTAGONAL_NUMBER					    NTH_PENTAGONAL_NUMBER					  NTH_PENTAGONAL_NUMBER
--							      --							    --								  --
int pentagonalNum ( int n ) {				      def pentagonalNum ( n ) :					    def pentagonalNum ( n ) :					  success : identical to gold
  return ( 3 * n * n - n ) / 2 ;			      	  return ( 3 * n * n - n ) / 2				    	return ( 3 * n * n - n ) / 2				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_CIRCUMFERENCE_CIRCLE			      PROGRAM_FIND_CIRCUMFERENCE_CIRCLE				    PROGRAM_FIND_CIRCUMFERENCE_CIRCLE				  PROGRAM_FIND_CIRCUMFERENCE_CIRCLE
--							      --							    --								  --
static double circumference ( double r ) {		      def circumference ( r ) :					    def circumference ( r ) :					  script_not_found : None
  double PI = 3.1415 ;					      	  return ( 2 * PI * r )					    	PI = 3.1415						  
  double cir = 2 * PI * r ;				      								    	cir = 2 * PI * r					  
  return cir ;						      								    	return cir						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TRIANGULAR_MATCHSTICK_NUMBER				      TRIANGULAR_MATCHSTICK_NUMBER				    TRIANGULAR_MATCHSTICK_NUMBER				  TRIANGULAR_MATCHSTICK_NUMBER
--							      --							    --								  --
public static int numberOfSticks ( int x ) {		      def numberOfSticks ( x ) :				    def number_of_sticks ( x ) :				  success : None
  return ( 3 * x * ( x + 1 ) ) / 2 ;			      	  return ( 3 * x * ( x + 1 ) ) / 2			    	return ( 3 * x * ( x + 1 ) ) / 2			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_BINOMIAL_COEFFICIENTS_1				      SUM_BINOMIAL_COEFFICIENTS_1				    SUM_BINOMIAL_COEFFICIENTS_1					  SUM_BINOMIAL_COEFFICIENTS_1
--							      --							    --								  --
static int binomialCoeffSum ( int n ) {			      def binomialCoeffSum ( n ) :				    def binomial_coeff_sum ( n ) :				  success : None
  return ( 1 << n ) ;					      	  return ( 1 << n )					    	return ( 1 << n )					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			      C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			    C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			  C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1
--							      --							    --								  --
static int largest ( int [ ] arr , int n ) {		      def largest ( arr , n ) :					    def largest ( arr , n ) :					  failure : #Results: 3, 10
  Arrays . sort ( arr ) ;				      	  return max ( arr )					    	arr.sort ( )						  
  return arr [ n - 1 ] ;				      								    	return arr [ n - 1 ]					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE
--							      --							    --								  --
int Circumference ( int a ) {				      def Circumference ( a ) :					    def Circumference ( a ) :					  success : None
  return 4 * a ;					      	  return ( 4 * a )					    	return 4 * a						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GCD_ELEMENTS_GIVEN_RANGE				      GCD_ELEMENTS_GIVEN_RANGE					    GCD_ELEMENTS_GIVEN_RANGE					  GCD_ELEMENTS_GIVEN_RANGE
--							      --							    --								  --
static int rangeGCD ( int n , int m ) {			      def rangeGCD ( n , m ) :					    def range_gcd ( n , m ) :					  success : None
  return ( n == m ) ? n : 1 ;				      	  return n if ( n == m ) else 1				    	return ( n if n == m else 1 )				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HYPERCUBE_GRAPH						      HYPERCUBE_GRAPH						    HYPERCUBE_GRAPH						  HYPERCUBE_GRAPH
--							      --							    --								  --
static int power ( int n ) {				      def power ( n ) :						    def power ( n ) :						  success : identical to gold
  if ( n == 1 ) return 2 ;				      	  if n == 1 :						    	if n == 1 :						  
  return 2 * power ( n - 1 ) ;				      	      return 2						    	    return 2						  
}							      	  return 2 * power ( n - 1 )				    	return 2 * power ( n - 1 )				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		      COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		    COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		  COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW
--							      --							    --								  --
static int compute_average ( int a , int b ) {		      def compute_average ( a , b ) :				    def compute_average ( a , b ) :				  failure : #Results: 3, 10
  return ( a + b ) / 2 ;				      	  return floor ( ( a + b ) / 2 )			    	return ( a + b ) / 2					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1			      PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1			    PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1				  PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1
--							      --							    --								  --
static int summingSeries ( long n ) {			      def summingSeries ( n ) :					    def summing_series ( n ) :					  success : None
  return ( int ) Math . pow ( n , 2 ) ;			      	  return math.pow ( n , 2 )				    	return int ( math.pow ( n , 2 ) )			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_AN_INTEGER_WITH_3_5				      MULTIPLY_AN_INTEGER_WITH_3_5				    MULTIPLY_AN_INTEGER_WITH_3_5				  MULTIPLY_AN_INTEGER_WITH_3_5
--							      --							    --								  --
static int multiplyWith3Point5 ( int x ) {		      def multiplyWith3Point5 ( x ) :				    def multiply_with_3_point5 ( x ) :				  success : None
  return ( x << 1 ) + x + ( x >> 1 ) ;			      	  return ( x << 1 ) + x + ( x >> 1 )			    	return ( x << 1 ) + x + ( x >> 1 )			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			      CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			    CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			  CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1
--							      --							    --								  --
public static boolean isEven ( int n ) {		      def isEven ( n ) :					    def is_even ( n ) :						  success : None
  if ( ( n & 1 ) == 0 ) return true ;			      	  return ( not ( n & 1 ) )				    	if ( n & 1 ) == 0 :					  
  else return false ;					      								    	    return True						  
}							      								    	else :							  
							      								    	    return False					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FACTORIAL_NUMBER				      C_PROGRAM_FACTORIAL_NUMBER				    C_PROGRAM_FACTORIAL_NUMBER					  C_PROGRAM_FACTORIAL_NUMBER
--							      --							    --								  --
static int factorial ( int n ) {			      def factorial ( n ) :					    def factorial ( n ) :					  success : None
  if ( n == 0 ) return 1 ;				      	  return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 	if not n :						  
  return n * factorial ( n - 1 ) ;			      								    	    return 1						  
}							      								    	return n * factorial ( n - 1 )				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_SLOPE_LINE					      PROGRAM_FIND_SLOPE_LINE					    PROGRAM_FIND_SLOPE_LINE					  PROGRAM_FIND_SLOPE_LINE
--							      --							    --								  --
static float slope ( float x1 , float y1 , float x2 , float y def slope ( x1 , y1 , x2 , y2 ) :				    def slope ( x1 , y1 , x2 , y2 ) :				  success : None
  return ( y2 - y1 ) / ( x2 - x1 ) ;			      	  return ( float ) ( y2 - y1 ) / ( x2 - x1 )		    	return ( y2 - y1 ) / ( x2 - x1 )			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		      COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		    COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		  COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER
--							      --							    --								  --
static int getModulo ( int n , int d ) {		      def getModulo ( n , d ) :					    def get_modulo ( n , d ) :					  success : None
  return ( n & ( d - 1 ) ) ;				      	  return ( n & ( d - 1 ) )				    	return ( n & ( d - 1 ) )				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS		      DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS		    DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS			  DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS
--							      --							    --								  --
static boolean oppositeSigns ( int x , int y ) {	      def oppositeSigns ( x , y ) :				    def opposite_signs ( x , y ) :				  success : None
  return ( ( x ^ y ) < 0 ) ;				      	  return ( ( x ^ y ) < 0 )				    	return ( ( x ^ y ) < 0 )				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES		      HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES			    HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES			  HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES
--							      --							    --								  --
static int height ( int N ) {				      def height ( N ) :					    def height ( N ) :						  success : None
  return ( int ) Math . ceil ( Math . log ( N + 1 ) / Math .  	  return math.ceil ( math.log2 ( N + 1 ) ) - 1		    	return int ( math.ceil ( math.log ( N + 1 ) / math.log (  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_TWO_NIBBLES_BYTE					      SWAP_TWO_NIBBLES_BYTE					    SWAP_TWO_NIBBLES_BYTE					  SWAP_TWO_NIBBLES_BYTE
--							      --							    --								  --
static int swapNibbles ( int x ) {			      def swapNibbles ( x ) :					    def swap_nibbles ( x ) :					  success : None
  return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ;	      	  return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )	    	return ( ( x & 0x0F ) << 4 ) | ( x & 0xF0 ) >> 4	  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_FACTORIAL_OF_A_NUMBER			      PROGRAM_FOR_FACTORIAL_OF_A_NUMBER				    PROGRAM_FOR_FACTORIAL_OF_A_NUMBER				  PROGRAM_FOR_FACTORIAL_OF_A_NUMBER
--							      --							    --								  --
static int factorial ( int n ) {			      def factorial ( n ) :					    def factorial ( n ) :					  success : None
  if ( n == 0 ) return 1 ;				      	  return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 	if not n :						  
  return n * factorial ( n - 1 ) ;			      								    	    return 1						  
}							      								    	return n * factorial ( n - 1 )				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SUBSTRINGS_STRING				      NUMBER_SUBSTRINGS_STRING					    NUMBER_SUBSTRINGS_STRING					  NUMBER_SUBSTRINGS_STRING
--							      --							    --								  --
static int countNonEmptySubstr ( String str ) {		      def countNonEmptySubstr ( str ) :				    def count_non_empty_substr ( str ) :			  success : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  return n * ( n + 1 ) / 2 ;				      	  return int ( n * ( n + 1 ) / 2 )			    	return n * ( n + 1 ) / 2				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_TERM_SERIES_2_12_36_80_150				      N_TH_TERM_SERIES_2_12_36_80_150				    N_TH_TERM_SERIES_2_12_36_80_150				  N_TH_TERM_SERIES_2_12_36_80_150
--							      --							    --								  --
public static int nthTerm ( int n ) {			      def nthTerm ( n ) :					    def nth_term ( n ) :					  success : None
  return ( n * n ) + ( n * n * n ) ;			      	  return ( n * n ) + ( n * n * n )			    	return ( n * n ) + ( n * n * n )			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR    PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR    PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR	  PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR
--							      --							    --								  --
static int getRemainder ( int num , int divisor ) {	      def getRemainder ( num , divisor ) :			    def get_remainder ( num , divisor ) :			  success : None
  return ( num - divisor * ( num / divisor ) ) ;	      	  return ( num - divisor * ( num // divisor ) )		    	return ( num - divisor * ( num // divisor ) )		  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			      PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			    PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			  PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES
--							      --							    --								  --
static int findMaximumPieces ( int n ) {		      def findMaximumPieces ( n ) :				    def find_maximum_pieces ( n ) :				  success : None
  return 1 + n * ( n + 1 ) / 2 ;			      	  return int ( 1 + n * ( n + 1 ) / 2 )			    	return 1 + n * ( n + 1 ) / 2				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_INCREASING_SUBSEQUENCE				      LONGEST_INCREASING_SUBSEQUENCE				    LONGEST_INCREASING_SUBSEQUENCE				  LONGEST_INCREASING_SUBSEQUENCE
--							      --							    --								  --
static int lis ( int arr [ ] , int n ) {		      def lis ( arr ) :						    def lis ( arr , n ) :					  script_not_found : None
  max_ref = 1 ;						      	  global maximum					    	global max_ref						  
  _lis ( arr , n ) ;					      	  n = len ( arr )					    	max_ref = 1						  
  return max_ref ;					      	  maximum = 1						    	_lis ( arr , n )					  
}							      	  _lis ( arr , n )					    	return max_ref						  
							      	  return maximum					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			      BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			    BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			  BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS
--							      --							    --								  --
public static int gcd ( int a , int b ) {		      def gcd ( a , b ) :					    def gcd ( a , b ) :						  failure : #Results: 3, 10
  if ( a == 0 ) return b ;				      	  if a == 0 :						    	if not a :						  
  return gcd ( b % a , a ) ;				      	      return b						    	    return b						  
}							      	  return gcd ( b % a , a )				    	return int ( b % a )					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_RECTANGLES_NM_GRID				      NUMBER_RECTANGLES_NM_GRID					    NUMBER_RECTANGLES_NM_GRID					  NUMBER_RECTANGLES_NM_GRID
--							      --							    --								  --
public static long rectCount ( int n , int m ) {	      def rectCount ( n , m ) :					    def rectcount ( n , m ) :					  success : None
  return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;	      	  return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4		    	return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4		  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1		      FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1		    FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1			  FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1
--							      --							    --								  --
static int evenbinomialCoeffSum ( int n ) {		      def evenbinomialCoeffSum ( n ) :				    def evenbinomial_coeff_sum ( n ) :				  success : None
  return ( 1 << ( n - 1 ) ) ;				      	  return ( 1 << ( n - 1 ) )				    	return ( 1 << ( n - 1 ) )				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BREAK_NUMBER_THREE_PARTS_1				      BREAK_NUMBER_THREE_PARTS_1				    BREAK_NUMBER_THREE_PARTS_1					  BREAK_NUMBER_THREE_PARTS_1
--							      --							    --								  --
static long count_of_ways ( long n ) {			      def count_of_ways ( n ) :					    def count_of_ways ( n ) :					  success : None
  long count = 0 ;					      	  count = 0						    	count = 0						  
  count = ( n + 1 ) * ( n + 2 ) / 2 ;			      	  count = ( n + 1 ) * ( n + 2 ) // 2			    	count = ( n + 1 ) * ( n + 2 ) / 2			  
  return count ;					      	  return count						    	return count						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10
--							      --							    --								  --
static boolean isMultipleOf10 ( int n ) {		      def isMultipleOf10 ( n ) :				    def is_multiple_of_10 ( n ) :				  success : None
  if ( n % 15 == 0 ) return true ;			      	  return ( n % 15 == 0 )				    	if n % 15 == 0 :					  
  return false ;					      								    	    return True						  
}							      								    	return False						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_AREA_OCTAGON				      PROGRAM_CALCULATE_AREA_OCTAGON				    PROGRAM_CALCULATE_AREA_OCTAGON				  PROGRAM_CALCULATE_AREA_OCTAGON
--							      --							    --								  --
static double areaOctagon ( double side ) {		      def areaOctagon ( side ) :				    def area_octagon ( side ) :					  success : None
  return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * s 	  return ( 2 * ( 1 + ( math.sqrt ( 2 ) ) ) * side * side )  	return float ( 2 * ( 1 + math.sqrt ( 2 ) ) * side * side  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS_2					      SUM_PAIRWISE_PRODUCTS_2					    SUM_PAIRWISE_PRODUCTS_2					  SUM_PAIRWISE_PRODUCTS_2
--							      --							    --								  --
static int findSum ( int n ) {				      def findSum ( n ) :					    def find_sum ( n ) :					  success : None
  return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ;     	  return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24	    	return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24	  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STACK_SET_3_REVERSE_STRING_USING_STACK			      STACK_SET_3_REVERSE_STRING_USING_STACK			    STACK_SET_3_REVERSE_STRING_USING_STACK			  STACK_SET_3_REVERSE_STRING_USING_STACK
--							      --							    --								  --
static void reverse ( char str [ ] ) {			      def reverse ( string ) :					    def reverse ( str ) :					  error : Traceback (most recent call last):   File
  int n = str . length , i ;				      	  string = string [ : : - 1 ]				    	n , i = len ( str ) , 0					  "dump/transcoder_st/eval/java_python/online_st/206
  for ( i = 0 ;						      	  return string						    	for i in range ( n // 2 ) :				  68770/eval_scripts/java_sa-python_sa.test/STACK_SE
  i < n / 2 ;						      								    	    swap ( str , i , n - i - 1 )			  T_3_REVERSE_STRING_USING_STACK.py", line 43, in <m
  i ++ ) {						      								    								  odule>     if f_filled(*parameters_set) == f_gold(
    swap ( str , i , n - i - 1 ) ;			      								    								  *parameters_set):   File "dump/transcoder_st/eval/
  }							      								    								  java_python/online_st/20668770/eval_scripts/java_s
}							      								    								  a-python_sa.test/STACK_SET_3_REVERSE_STRING_USING_
							      								    								  STACK.py", line 25, in f_filled     swap ( str , i
							      								    								   , n - i - 1 ) NameError: name 'swap' is not defin
							      								    								  ed
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_CONTAIN_1_N_VALUES				      SORT_ARRAY_CONTAIN_1_N_VALUES				    SORT_ARRAY_CONTAIN_1_N_VALUES				  SORT_ARRAY_CONTAIN_1_N_VALUES
--							      --							    --								  --
static void sortit ( int [ ] arr , int n ) {		      def sortit ( arr , n ) :					    def sortit ( arr , n ) :					  success : identical to gold
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      arr [ i ] = i + 1					    	    arr [ i ] = i + 1					  
  i ++ ) {						      								    								  
    arr [ i ] = i + 1 ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1			      PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1			    PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1				  PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1
--							      --							    --								  --
static int factorial ( int n ) {			      def factorial ( n ) :					    def factorial ( n ) :					  error : Traceback (most recent call last):   File
  int res = 1 , i ;					      	  return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 	res , i = 1 , i						  "dump/transcoder_st/eval/java_python/online_st/206
  for ( i = 2 ;						      								    	for i in range ( 2 , n + 1 ) :				  68770/eval_scripts/java_sa-python_sa.test/PROGRAM_
  i <= n ;						      								    	    res *= i						  FOR_FACTORIAL_OF_A_NUMBER_1.py", line 43, in <modu
  i ++ ) res *= i ;					      								    	return res						  le>	  if f_filled(*parameters_set) == f_gold(*pa
  return res ;						      								    								  rameters_set):   File "dump/transcoder_st/eval/jav
}							      								    								  a_python/online_st/20668770/eval_scripts/java_sa-p
							      								    								  ython_sa.test/PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1.
							      								    								  py", line 22, in f_filled	res , i = 1 , i Unbo
							      								    								  undLocalError: local variable 'i' referenced befor
							      								    								  e assignment
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			      PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			    PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			  PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON
--							      --							    --								  --
static double surface_area_octahedron ( double side ) {	      def surface_area_octahedron ( side ) :			    def surface_area_octahedron ( side ) :			  success : None
  return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ;    	  return ( 2 * ( math.sqrt ( 3 ) ) * ( side * side ) )	    	return ( 2 * ( math.sqrt ( 3 ) ) * ( side ** 2 ) )	  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	      PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	    PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	  PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM
--							      --							    --								  --
static int Resources ( int process , int need ) {	      def Resources ( process , need ) :			    def Resources ( process , need ) :				  success : identical to gold
  int minResources = 0 ;				      	  minResources = 0					    	minResources = 0					  
  minResources = process * ( need - 1 ) + 1 ;		      	  minResources = process * ( need - 1 ) + 1		    	minResources = process * ( need - 1 ) + 1		  
  return minResources ;					      	  return minResources					    	return minResources					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_VOLUME_ELLIPSOID			      PROGRAM_CALCULATE_VOLUME_ELLIPSOID			    PROGRAM_CALCULATE_VOLUME_ELLIPSOID				  PROGRAM_CALCULATE_VOLUME_ELLIPSOID
--							      --							    --								  --
public static float volumeOfEllipsoid ( float r1 , float r2 , def volumeOfEllipsoid ( r1 , r2 , r3 ) :			    def volume_of_ellipsoid ( r1 , r2 , r3 ) :			  success : None
  float pi = ( float ) 3.14 ;				      	  return 1.33 * math.pi * r1 * r2 * r3			    	pi = float ( 3.14 )					  
  return ( float ) 1.33 * pi * r1 * r2 * r3 ;		      								    	return float ( 1.33 ) * pi * r1 * r2 * r3		  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		      PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		    PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		  PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP
--							      --							    --								  --
static double procal ( int n ) {			      def procal ( n ) :					    def procal ( n ) :						  success : identical to gold
  return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;	      	  return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 )		    	return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 )		  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_VOLUME_OCTAHEDRON			      PROGRAM_CALCULATE_VOLUME_OCTAHEDRON			    PROGRAM_CALCULATE_VOLUME_OCTAHEDRON				  PROGRAM_CALCULATE_VOLUME_OCTAHEDRON
--							      --							    --								  --
static double vol_of_octahedron ( double side ) {	      def vol_of_octahedron ( side ) :				    def vol_of_octahedron ( side ) :				  success : identical to gold
  return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) 	  return ( ( side * side * side ) * ( math.sqrt ( 2 ) / 3 ) 	return ( ( side * side * side ) * ( math.sqrt ( 2 ) / 3 ) 
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_2				      COUNT_SET_BITS_IN_AN_INTEGER_2				    COUNT_SET_BITS_IN_AN_INTEGER_2				  COUNT_SET_BITS_IN_AN_INTEGER_2
--							      --							    --								  --
static int countSetBits ( int n ) {			      def countSetBits ( n ) :					    def count_set_bits ( n ) :					  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  while ( n > 0 ) {					      	  while ( n ) :						    	while n > 0 :						  
    n &= ( n - 1 ) ;					      	      n &= ( n - 1 )					    	    n &= ( n - 1 )					  
    count ++ ;						      	      count += 1					    	    count += 1						  
  }							      	  return count						    	return count						  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1     SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1	    SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1	  SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1
--							      --							    --								  --
static long calculateSum ( int n ) {			      def calculateSum ( n ) :					    def calculate_sum ( n ) :					  success : None
  long sum = 0 ;					      	  sum = 0						    	sum = 0							  
  sum = 1 << n ;					      	  sum = 1 << n						    	sum = 1 << n						  
  return ( sum - 1 ) ;					      	  return ( sum - 1 )					    	return ( sum - 1 )					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW
--							      --							    --								  --
static boolean isPowerOfTwo ( int x ) {			      def isPowerOfTwo ( x ) :					    def is_power_of_two ( x ) :					  success : None
  return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ;		      	  return ( x and ( not ( x & ( x - 1 ) ) ) )		    	return x is not None and ( ( x & ( x - 1 ) ) == 0 )	  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT     PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT	    PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT	  PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT
--							      --							    --								  --
static int assignValue ( int a , int b , int x ) {	      def assignValue ( a , b , x ) :				    def assign_value ( a , b , x ) :				  script_not_found : None
  int arr [ ] = {					      	  arr = [ a , b ]					    	arr = [ a , b ]						  
    a , b }						      	  return ( arr [ x ] )					    	return ( arr [ x ] )					  
    ;							      								    								  
    return ( arr [ x ] ) ;				      								    								  
  }							      								    								  
  -							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY		      KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY		    KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY			  KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY
--							      --							    --								  --
public static int kthSmallest ( Integer [ ] arr , int k ) {   def kthSmallest ( arr , n , k ) :				    def kth_smallest ( arr = None , k = 0 ) :			  script_not_found : None
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  return arr [ k - 1 ] ;				      	  return arr [ k - 1 ]					    	return arr [ k - 1 ]					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE      DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE	    DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE
--							      --							    --								  --
static int lis ( int arr [ ] , int n ) {		      def lis ( arr ) :						    def lis ( arr , n ) :					  script_not_found : None
  max_ref = 1 ;						      	  global maximum					    	global max_ref						  
  _lis ( arr , n ) ;					      	  n = len ( arr )					    	max_ref = 1						  
  return max_ref ;					      	  maximum = 1						    	_lis ( arr , n )					  
}							      	  _lis ( arr , n )					    	return max_ref						  
							      	  return maximum					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS		      SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS			    SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS			  SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS
--							      --							    --								  --
static double sumOfSeries ( int n ) {			      def sumOfSeries ( n ) :					    def sum_of_series ( n ) :					  success : None
  return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ;      	  return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) )	    	return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) )		  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_3				      COUNT_SET_BITS_IN_AN_INTEGER_3				    COUNT_SET_BITS_IN_AN_INTEGER_3				  COUNT_SET_BITS_IN_AN_INTEGER_3
--							      --							    --								  --
public static int countSetBits ( int n ) {		      def countSetBits ( n ) :					    def count_set_bits ( n ) :					  success : None
  if ( n == 0 ) return 0 ;				      	  if ( n == 0 ) :					    	if not n :						  
  else return 1 + countSetBits ( n & ( n - 1 ) ) ;	      	      return 0						    	    return 0						  
}							      	  else :						    	else :							  
							      	      return 1 + countSetBits ( n & ( n - 1 ) )		    	    return 1 + count_set_bits ( n & ( n - 1 ) )		  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		      C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		    C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		  C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES
--							      --							    --								  --
static String repeat ( String s , int n ) {		      def repeat ( s , n ) :					    def repeat ( s , n ) :					  success : identical to gold
  String s1 = s ;					      	  s1 = s						    	s1 = s							  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i < n ;						      	      s += s1						    	    s += s1						  
  i ++ ) s += s1 ;					      	  return s						    	return s						  
  return s ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_1				      COUNT_SET_BITS_IN_AN_INTEGER_1				    COUNT_SET_BITS_IN_AN_INTEGER_1				  COUNT_SET_BITS_IN_AN_INTEGER_1
--							      --							    --								  --
public static int countSetBits ( int n ) {		      def countSetBits ( n ) :					    def count_set_bits ( n ) :					  success : None
  if ( n == 0 ) return 0 ;				      	  if ( n == 0 ) :					    	if not n :						  
  else return ( n & 1 ) + countSetBits ( n >> 1 ) ;	      	      return 0						    	    return 0						  
}							      	  else :						    	else :							  
							      	      return ( n & 1 ) + countSetBits ( n >> 1 )	    	    return ( n & 1 ) + count_set_bits ( n >> 1 )	  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1		      BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1			    BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1			  BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1
--							      --							    --								  --
static void bin ( Integer n ) {				      def bin ( n ) :						    def bin ( n = None ) :					  script_not_found : None
  if ( n > 1 ) bin ( n >> 1 ) ;				      	  if ( n > 1 ) :					    	if n > 1 :						  
  System . out . printf ( "%d" , n & 1 ) ;		      	      bin ( n >> 1 )					    	    bin ( n >> 1 )					  
}							      	  print ( n & 1 , end = "" )				    	print ( "%d" % ( n & 1 ) )				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_PALINDROME_SUBSTRING_SET_1			      LONGEST_PALINDROME_SUBSTRING_SET_1			    LONGEST_PALINDROME_SUBSTRING_SET_1				  LONGEST_PALINDROME_SUBSTRING_SET_1
--							      --							    --								  --
static void printSubStr ( String str , int low , int high ) { def printSubStr ( st , low , high ) :			    def printSubStr ( str , low , high ) :			  script_not_found : None
  System . out . println ( str . substring ( low , high + 1 ) 	  sys.stdout.write ( st [ low : high + 1 ] )		    	print ( str [ low : high + 1 ] )			  
}							      	  sys.stdout.flush ( )					    								  
							      	  return ''						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING      COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING	    COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING	  COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING
--							      --							    --								  --
static int getAbs ( int n ) {				      def getAbs ( n ) :					    def get_abs ( n ) :						  script_not_found : None
  int mask = n >> ( SIZE_INT * CHAR_BIT - 1 ) ;		      	  mask = n >> ( SIZE_INT * CHARBIT - 1 )		    	mask = n >> ( SIZE_INT * CHAR_BIT - 1 )			  
  return ( ( n + mask ) ^ mask ) ;			      	  return ( ( n + mask ) ^ mask )			    	return ( ( n + mask ) ^ mask )				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS
--							      --							    --								  --
static int maxSquare ( int b , int m ) {		      def maxSquare ( b , m ) :					    def max_square ( b , m ) :					  failure : #Results: 0, 10
  return ( b / m - 1 ) * ( b / m ) / 2 ;		      	  return ( b / m - 1 ) * ( b / m ) / 2			    	return ( b // m - 1 ) * ( b // m ) / 2			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I
--							      --							    --								  --
static float getArea ( int a ) {			      def getArea ( a ) :					    def get_area ( a ) :					  success : None
  float area = ( float ) ( Math . PI * a * a ) / 4 ;	      	  area = ( math.pi * a * a ) / 4			    	area = float ( math.pi * a * a ) / 4			  
  return area ;						      	  return area						    	return area						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY		      MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY			    MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY			  MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY
--							      --							    --								  --
static int minSum ( int [ ] A , int n ) {		      def minSum ( A ) :					    def min_sum ( A , n ) :					  script_not_found : None
  int min_val = Arrays . stream ( A ) . min ( ) . getAsInt (  	  min_val = min ( A ) ;					    	min_val = min ( A )					  
  return ( min_val * ( n - 1 ) ) ;			      	  return min_val * ( len ( A ) - 1 )			    	return ( min_val * ( n - 1 ) )				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	      COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	    COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	  COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1
--							      --							    --								  --
static int countStr ( int n ) {				      def countStr ( n ) :					    def count_str ( n ) :					  success : None
  return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ;      	  return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) ) 	return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 )	  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		      HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		    HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		  HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER
--							      --							    --								  --
static int turnOffK ( int n , int k ) {			      def turnOffK ( n , k ) :					    def turn_off_k ( n , k ) :					  success : None
  if ( k <= 0 ) return n ;				      	  if ( k <= 0 ) :					    	if k <= 0 :						  
  return ( n & ~ ( 1 << ( k - 1 ) ) ) ;			      	      return n						    	    return n						  
}							      	  return ( n & ~ ( 1 << ( k - 1 ) ) )			    	return ( n & ~ ( 1 << ( k - 1 ) ) )			  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			      FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			    FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			  FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X
--							      --							    --								  --
static long yMod ( long y , long x ) {			      def yMod ( y , x ) :					    def y_mod ( y , x ) :					  success : None
  if ( ( Math . log ( y ) / Math . log ( 2 ) ) < x ) return y 	  return ( y % pow ( 2 , x ) )				    	if ( math.log ( y ) / math.log ( 2 ) ) < x :		  
  if ( x > 63 ) return y ;				      								    	    return y						  
  return ( y % ( 1 << ( int ) x ) ) ;			      								    	if x > 63 :						  
}							      								    	    return y						  
							      								    	return ( y % ( 1 << int ( x ) ) )			  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LINEAR_SEARCH						      LINEAR_SEARCH						    LINEAR_SEARCH						  LINEAR_SEARCH
--							      --							    --								  --
public static int search ( int arr [ ] , int x ) {	      def search ( arr , n , x ) :				    def search ( arr , x ) :					  script_not_found : None
  int n = arr . length ;				      	  for i in range ( 0 , n ) :				    	n = len ( arr )						  
  for ( int i = 0 ;					      	      if ( arr [ i ] == x ) :				    	for i in range ( n ) :					  
  i < n ;						      		  return i					    	    if arr [ i ] == x :					  
  i ++ ) {						      	  return - 1						    		return i					  
    if ( arr [ i ] == x ) return i ;			      								    	return - 1						  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES		      MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES		    MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES			  MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES
--							      --							    --								  --
static int fib ( int n ) {				      def fib ( n ) :						    def fib ( n ) :						  script_not_found : None
  if ( n <= 1 ) return n ;				      	  if ( n <= 1 ) :					    	if n <= 1 :						  
  return fib ( n - 1 ) + fib ( n - 2 ) ;		      	      return n						    	    return n						  
}							      	  return fib ( n - 1 ) + fib ( n - 2 )			    	return fib ( n - 1 ) + fib ( n - 2 )			  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_TRIPLET_SUM_ARRAY_1				      MAXIMUM_TRIPLET_SUM_ARRAY_1				    MAXIMUM_TRIPLET_SUM_ARRAY_1					  MAXIMUM_TRIPLET_SUM_ARRAY_1
--							      --							    --								  --
static int maxTripletSum ( int arr [ ] , int n ) {	      def maxTripletSum ( arr , n ) :				    def max_triplet_sum ( arr , n ) :				  success : None
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ;      	  return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] )  	return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ]	  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_INPUT_INTEGER_STRING			      PROGRAM_CHECK_INPUT_INTEGER_STRING			    PROGRAM_CHECK_INPUT_INTEGER_STRING				  PROGRAM_CHECK_INPUT_INTEGER_STRING
--							      --							    --								  --
static boolean isNumber ( String s ) {			      def isNumber ( s ) :					    def is_number ( s ) :					  success : None
  for ( int i = 0 ;					      	  for i in range ( len ( s ) ) :			    	for c in s :						  
  i < s . length ( ) ;					      	      if s [ i ].isdigit ( ) != True :			    	    if c.isdigit ( ) == False :				  
  i ++ ) if ( Character . isDigit ( s . charAt ( i ) ) == fal 		  return False					    		return False					  
  return true ;						      	  return True						    	return True						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_DIVISORS_1_N_1					      SUM_DIVISORS_1_N_1					    SUM_DIVISORS_1_N_1						  SUM_DIVISORS_1_N_1
--							      --							    --								  --
static int divisorSum ( int n ) {			      def divisorSum ( n ) :					    def divisor_sum ( n ) :					  success : None
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	      sum += int ( n / i ) * i				    	    sum += ( n // i ) * i				  
  ++ i ) sum += ( n / i ) * i ;				      	  return int ( sum )					    	return sum						  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ADD_1_TO_A_GIVEN_NUMBER					      ADD_1_TO_A_GIVEN_NUMBER					    ADD_1_TO_A_GIVEN_NUMBER					  ADD_1_TO_A_GIVEN_NUMBER
--							      --							    --								  --
static int addOne ( int x ) {				      def addOne ( x ) :					    def add_one ( x ) :						  success : None
  int m = 1 ;						      	  m = 1							    	m = 1							  
  while ( ( int ) ( x & m ) >= 1 ) {			      	  while ( x & m ) :					    	while int ( x & m ) >= 1 :				  
    x = x ^ m ;						      	      x = x ^ m						    	    x = x ^ m						  
    m <<= 1 ;						      	      m <<= 1						    	    m <<= 1						  
  }							      	  x = x ^ m						    	x = x ^ m						  
  x = x ^ m ;						      	  return x						    	return x						  
  return x ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPETITIVE_ELEMENT_1_N_1				      FIND_REPETITIVE_ELEMENT_1_N_1				    FIND_REPETITIVE_ELEMENT_1_N_1				  FIND_REPETITIVE_ELEMENT_1_N_1
--							      --							    --								  --
static int findRepeating ( int [ ] arr , int n ) {	      def findRepeating ( arr , n ) :				    def find_repeating ( arr , n ) :				  failure : #Results: 0, 10
  int sum = 0 ;						      	  return sum ( arr ) - ( ( ( n - 1 ) * n ) // 2 )	    	sum = 0							  
  for ( int i = 0 ;					      								    	for i in range ( n ) :					  
  i < n ;						      								    	    sum += arr [ i ]					  
  i ++ ) sum += arr [ i ] ;				      								    	return sum - ( ( ( n - 1 ) * n ) / 2 )			  
  return sum - ( ( ( n - 1 ) * n ) / 2 ) ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER		      FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER			    FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER			  FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER
--							      --							    --								  --
static int findSum ( int N , int K ) {			      def findSum ( N , K ) :					    def find_sum ( N , K ) :					  success : None
  int ans = 0 ;						      	  ans = 0						    	ans = 0							  
  for ( int i = 1 ;					      	  for i in range ( 1 , N + 1 ) :			    	for i in range ( 1 , N + 1 ) :				  
  i <= N ;						      	      ans += ( i % K )					    	    ans += ( i % K )					  
  i ++ ) ans += ( i % K ) ;				      	  return ans						    	return ans						  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIME_NUMBERS						      PRIME_NUMBERS						    PRIME_NUMBERS						  PRIME_NUMBERS
--							      --							    --								  --
static boolean isPrime ( int n ) {			      def isPrime ( n ) :					    def is_prime ( n ) :					  success : None
  if ( n <= 1 ) return false ;				      	  if ( n <= 1 ) :					    	if n <= 1 :						  
  for ( int i = 2 ;					      	      return False					    	    return False					  
  i < n ;						      	  for i in range ( 2 , n ) :				    	for i in range ( 2 , n ) :				  
  i ++ ) if ( n % i == 0 ) return false ;		      	      if ( n % i == 0 ) :				    	    if n % i == 0 :					  
  return true ;						      		  return False					    		return False					  
}							      	  return True						    	return True						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE
--							      --							    --								  --
static boolean isPossible ( String str , int n ) {	      def isPossible ( str , n ) :				    def is_possible ( str , n ) :				  success : None
  int len = str . length ( ) ;				      	  l = len ( str )					    	len ( str )						  
  if ( len >= n ) return true ;				      	  if ( l >= n ) :					    	if len ( str ) >= n :					  
  return false ;					      	      return True					    	    return True						  
}							      	  return False						    	return False						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		      FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		    FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		  FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2
--							      --							    --								  --
int getOddOccurrence ( int ar [ ] , int ar_size ) {	      def getOddOccurrence ( arr ) :				    def get_odd_occurrence ( ar , ar_size ) :			  script_not_found : None
  int i ;						      	  res = 0						    	global res						  
  int res = 0 ;						      	  for element in arr :					    	res = 0							  
  for ( i = 0 ;						      	      res = res ^ element				    	for i in range ( ar_size ) :				  
  i < ar_size ;						      	  return res						    	    res = res ^ ar [ i ]				  
  i ++ ) {						      								    	return res						  
    res = res ^ ar [ i ] ;				      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			      PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			    PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			  PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON
--							      --							    --								  --
static float findArea ( float a ) {			      def findArea ( a ) :					    def find_area ( a ) :					  success : None
  float area ;						      	  area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a  	global area						  
  area = ( float ) ( Math . sqrt ( 5 * ( 5 + 2 * ( Math . sqr 	  return area						    	area = float ( math.sqrt ( 5 * ( 5 + 2 * ( math.sqrt ( 5  
  return area ;						      								    	return area						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		      POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		    POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		  POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1
--							      --							    --								  --
static void printArray ( int [ ] a , int n ) {		      def printArray ( a , n ) :				    def printArray ( a , n ) :					  script_not_found : None
  for ( int i = 0 ;					      	  for i in a :						    	for i in range ( n ) :					  
  i < n ;						      	      print ( i , end = " " )				    	    print ( a [ i ] , end = ' ' )			  
  i ++ ) System . out . print ( a [ i ] + " " ) ;	      	  print ( )						    	print ( )						  
  System . out . println ( ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_EVEN_LENGTH_PALINDROME				      NTH_EVEN_LENGTH_PALINDROME				    NTH_EVEN_LENGTH_PALINDROME					  NTH_EVEN_LENGTH_PALINDROME
--							      --							    --								  --
static String evenlength ( String n ) {			      def evenlength ( n ) :					    def evenlength ( n ) :					  success : identical to gold
  String res = n ;					      	  res = n						    	res = n							  
  for ( int j = n . length ( ) - 1 ;			      	  for j in range ( len ( n ) - 1 , - 1 , - 1 ) :	    	for j in range ( len ( n ) - 1 , - 1 , - 1 ) :		  
  j >= 0 ;						      	      res += n [ j ]					    	    res += n [ j ]					  
  -- j ) res += n . charAt ( j ) ;			      	  return res						    	return res						  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_CONWAY_SEQUENCE					      NEWMAN_CONWAY_SEQUENCE					    NEWMAN_CONWAY_SEQUENCE					  NEWMAN_CONWAY_SEQUENCE
--							      --							    --								  --
static int sequence ( int n ) {				      def sequence ( n ) :					    def sequence ( n ) :					  script_not_found : None
  if ( n == 1 || n == 2 ) return 1 ;			      	  if n == 1 or n == 2 :					    	if n == 1 or n == 2 :					  
  else return sequence ( sequence ( n - 1 ) ) + sequence ( n  	      return 1						    	    return 1						  
}							      	  else :						    	else :							  
							      	      return sequence ( sequence ( n - 1 ) ) + sequence ( n 	    return sequence ( sequence ( n - 1 ) ) + sequence ( n 
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2_1					      NEXT_POWER_OF_2_1						    NEXT_POWER_OF_2_1						  NEXT_POWER_OF_2_1
--							      --							    --								  --
static int nextPowerOf2 ( int n ) {			      def nextPowerOf2 ( n ) :					    def next_pow2 ( n ) :					  success : None
  int p = 1 ;						      	  p = 1							    	p = 1							  
  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;	      	  if ( n and not ( n & ( n - 1 ) ) ) :			    	if n > 0 and ( n & ( n - 1 ) ) == 0 :			  
  while ( p < n ) p <<= 1 ;				      	      return n						    	    return n						  
  return p ;						      	  while ( p < n ) :					    	while p < n :						  
}							      	      p <<= 1						    	    p <<= 1						  
							      	  return p						    	return p						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2
--							      --							    --								  --
static boolean isPowerOfFour ( int n ) {		      def isPowerOfFour ( n ) :					    def is_power_of_four ( n ) :				  success : None
  return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAA 	  return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not (  	return n is not None and ( ( n & ( n - 1 ) ) == 0 ) and ( 
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_SHANKS_WILLIAMS_PRIME				      NEWMAN_SHANKS_WILLIAMS_PRIME				    NEWMAN_SHANKS_WILLIAMS_PRIME				  NEWMAN_SHANKS_WILLIAMS_PRIME
--							      --							    --								  --
static int nswp ( int n ) {				      def nswp ( n ) :						    def nswp ( n ) :						  script_not_found : None
  if ( n == 0 || n == 1 ) return 1 ;			      	  if n == 0 or n == 1 :					    	if not n or not n :					  
  return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ;		      	      return 1						    	    return 1						  
}							      	  return 2 * nswp ( n - 1 ) + nswp ( n - 2 )		    	return 2 * nswp ( n - 1 ) + nswp ( n - 2 )		  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			      COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			    COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			  COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER
--							      --							    --								  --
static int findTrailingZeros ( int n ) {		      def findTrailingZeros ( n ) :				    def find_trailing_zeros ( n ) :				  error : Traceback (most recent call last):   File
  int count = 0 ;					      	  count = 0						    	count = 0						  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int i = 5 ;					      	  i = 5							    	for i in range ( 5 , n // i + 1 , 5 ) :			  68770/eval_scripts/java_sa-python_sa.test/COUNT_TR
  n / i >= 1 ;						      	  while ( n / i >= 1 ) :				    	    count += n // i					  AILING_ZEROES_FACTORIAL_NUMBER.py", line 48, in <m
  i *= 5 ) count += n / i ;				      	      count += int ( n / i )				    	return count						  odule>     if f_filled(*parameters_set) == f_gold(
  return count ;					      	      i *= 5						    								  *parameters_set):   File "dump/transcoder_st/eval/
}							      	  return int ( count )					    								  java_python/online_st/20668770/eval_scripts/java_s
							      								    								  a-python_sa.test/COUNT_TRAILING_ZEROES_FACTORIAL_N
							      								    								  UMBER.py", line 28, in f_filled     for i in range
							      								    								   ( 5 , n // i + 1 , 5 ) : UnboundLocalError: local
							      								    								   variable 'i' referenced before assignment
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		      COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		    COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		  COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ
--							      --							    --								  --
public static int find ( int n , int k ) {		      def find ( n , k ) :					    def find ( n , k ) :					  success : None
  if ( n + 1 >= k ) return ( k - 1 ) ;			      	  if ( n + 1 >= k ) :					    	if n + 1 >= k :						  
  else return ( 2 * n + 1 - k ) ;			      	      return ( k - 1 )					    	    return ( k - 1 )					  
}							      	  else :						    	else :							  
							      	      return ( 2 * n + 1 - k )				    	    return ( 2 * n + 1 - k )				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEONARDO_NUMBER						      LEONARDO_NUMBER						    LEONARDO_NUMBER						  LEONARDO_NUMBER
--							      --							    --								  --
static int leonardo ( int n ) {				      def leonardo ( n ) :					    def leonardo ( n ) :					  script_not_found : None
  if ( n == 0 || n == 1 ) return 1 ;			      	  if ( n == 0 or n == 1 ) :				    	if not n or not n :					  
  return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ;    	      return 1						    	    return 1						  
}							      	  return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 )    	return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 )	  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		      FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		    FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		  FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1
--							      --							    --								  --
double countSquares ( int a , int b ) {			      def CountSquares ( a , b ) :				    def count_squares ( a , b ) :				  script_not_found : None
  return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( 	  return ( math.floor ( math.sqrt ( b ) ) - math.ceil ( mat 	return ( math.floor ( math.sqrt ( b ) ) - math.ceil ( mat 
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTS_PATHS_POINT_REACH_ORIGIN				      COUNTS_PATHS_POINT_REACH_ORIGIN				    COUNTS_PATHS_POINT_REACH_ORIGIN				  COUNTS_PATHS_POINT_REACH_ORIGIN
--							      --							    --								  --
static int countPaths ( int n , int m ) {		      def countPaths ( n , m ) :				    def count_paths ( n , m ) :					  script_not_found : None
  if ( n == 0 || m == 0 ) return 1 ;			      	  if ( n == 0 or m == 0 ) :				    	if not n or not m :					  
  return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1  	      return 1						    	    return 1						  
}							      	  return ( countPaths ( n - 1 , m ) + countPaths ( n , m -  	return ( count_paths ( n - 1 , m ) + count_paths ( n , m  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2_2					      NEXT_POWER_OF_2_2						    NEXT_POWER_OF_2_2						  NEXT_POWER_OF_2_2
--							      --							    --								  --
static int nextPowerOf2 ( int n ) {			      def nextPowerOf2 ( n ) :					    def next_pow2 ( n ) :					  success : None
  n -- ;						      	  n -= 1						    	n -= 1							  
  n |= n >> 1 ;						      	  n |= n >> 1						    	n |= n >> 1						  
  n |= n >> 2 ;						      	  n |= n >> 2						    	n |= n >> 2						  
  n |= n >> 4 ;						      	  n |= n >> 4						    	n |= n >> 4						  
  n |= n >> 8 ;						      	  n |= n >> 8						    	n |= n >> 8						  
  n |= n >> 16 ;					      	  n |= n >> 16						    	n |= n >> 16						  
  n ++ ;						      	  n += 1						    	n += 1							  
  return n ;						      	  return n						    	return n						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_VOLUME_DODECAHEDRON				      CALCULATE_VOLUME_DODECAHEDRON				    CALCULATE_VOLUME_DODECAHEDRON				  CALCULATE_VOLUME_DODECAHEDRON
--							      --							    --								  --
static double vol_of_dodecahedron ( int side ) {	      def vol_of_dodecahedron ( side ) :			    def vol_of_dodecahedron ( side ) :				  success : identical to gold
  return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( 	  return ( ( ( 15 + ( 7 * ( math.sqrt ( 5 ) ) ) ) / 4 ) * ( 	return ( ( ( 15 + ( 7 * ( math.sqrt ( 5 ) ) ) ) / 4 ) * ( 
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2     GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2	    GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2	  GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2
--							      --							    --								  --
static int Largestpower ( int n , int p ) {		      def largestPower ( n , p ) :				    def Largestpower ( n , p ) :				  script_not_found : None
  int ans = 0 ;						      	  x = 0							    	ans = 0							  
  while ( n > 0 ) {					      	  while n :						    	while n > 0 :						  
    n /= p ;						      	      n /= p						    	    n //= p						  
    ans += n ;						      	      x += n						    	    ans += n						  
  }							      	  return x						    	return ans						  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		      CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		    CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		  CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN
--							      --							    --								  --
public static int checkValidity ( int a , int b , int c ) {   def checkValidity ( a , b , c ) :				    def check_validity ( a , b , c ) :				  success : None
  if ( a + b <= c || a + c <= b || b + c <= a ) return 0 ;    	  if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) :   	if a + b <= c or a + c <= b or b + c <= a :		  
  else return 1 ;					      	      return False					    	    return 0						  
}							      	  else :						    	else :							  
							      	      return True					    	    return 1						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_POWER_PRIME_NUMBER_P_N_1			      FINDING_POWER_PRIME_NUMBER_P_N_1				    FINDING_POWER_PRIME_NUMBER_P_N_1				  FINDING_POWER_PRIME_NUMBER_P_N_1
--							      --							    --								  --
static int PowerOFPINnfactorial ( int n , int p ) {	      def PowerOFPINnfactorial ( n , p ) :			    def PowerOFPINnfactorial ( n , p ) :			  success : None
  int ans = 0 ;						      	  ans = 0						    	ans = 0							  
  int temp = p ;					      	  temp = p						    	temp = p						  
  while ( temp <= n ) {					      	  while ( temp <= n ) :					    	while temp <= n :					  
    ans += n / temp ;					      	      ans += n / temp					    	    ans += n // temp					  
    temp = temp * p ;					      	      temp = temp * p					    	    temp = temp * p					  
  }							      	  return int ( ans )					    	return ans						  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2
--							      --							    --								  --
static int find_extra_element_index ( int [ ] arrA , int [ ]  def find_extra_element_index ( arrA , arrB ) :		    def find_extra_element_index ( arr_a , arr_b ) :		  script_not_found : None
  int extra_element = sum ( arrA ) - sum ( arrB ) ;	      	  extra_element = sum ( arrA ) - sum ( arrB )		    	extra_element = sum ( arr_a ) - sum ( arr_b )		  
  return indexOf ( arrA , extra_element ) ;		      	  return arrA.index ( extra_element )			    	return int ( arr_a [ extra_element ] )			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MISSING_NUMBER					      FIND_THE_MISSING_NUMBER					    FIND_THE_MISSING_NUMBER					  FIND_THE_MISSING_NUMBER
--							      --							    --								  --
static int getMissingNo ( int a [ ] , int n ) {		      def getMissingNo ( A ) :					    def get_missing_no ( a , n ) :				  script_not_found : None
  int i , total ;					      	  n = len ( A )						    	global total						  
  total = ( n + 1 ) * ( n + 2 ) / 2 ;			      	  total = ( n + 1 ) * ( n + 2 ) / 2			    	total = ( n + 1 ) * ( n + 2 ) / 2			  
  for ( i = 0 ;						      	  sum_of_A = sum ( A )					    	for i in range ( n ) :					  
  i < n ;						      	  return total - sum_of_A				    	    total -= a [ i ]					  
  i ++ ) total -= a [ i ] ;				      								    	return total						  
  return total ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LAST_INDEX_CHARACTER_STRING			      FIND_LAST_INDEX_CHARACTER_STRING				    FIND_LAST_INDEX_CHARACTER_STRING				  FIND_LAST_INDEX_CHARACTER_STRING
--							      --							    --								  --
static int findLastIndex ( String str , Character x ) {	      def findLastIndex ( str , x ) :				    def find_last_index ( str , x ) :				  script_not_found : None
  int index = - 1 ;					      	  index = - 1						    	index = - 1						  
  for ( int i = 0 ;					      	  for i in range ( 0 , len ( str ) ) :			    	for i in range ( len ( str ) ) :			  
  i < str . length ( ) ;				      	      if str [ i ] == x :				    	    if str [ i ] == x :					  
  i ++ ) if ( str . charAt ( i ) == x ) index = i ;	      		  index = i					    		index = i					  
  return index ;					      	  return index						    	return index						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LAST_INDEX_CHARACTER_STRING_1			      FIND_LAST_INDEX_CHARACTER_STRING_1			    FIND_LAST_INDEX_CHARACTER_STRING_1				  FIND_LAST_INDEX_CHARACTER_STRING_1
--							      --							    --								  --
static int findLastIndex ( String str , Character x ) {	      def findLastIndex ( str , x ) :				    def find_last_index ( str , x ) :				  script_not_found : None
  for ( int i = str . length ( ) - 1 ;			      	  for i in range ( len ( str ) - 1 , - 1 , - 1 ) :	    	for i in range ( len ( str ) - 1 , - 1 , - 1 ) :	  
  i >= 0 ;						      	      if ( str [ i ] == x ) :				    	    if str [ i ] == x :					  
  i -- ) if ( str . charAt ( i ) == x ) return i ;	      		  return i					    		return i					  
  return - 1 ;						      	  return - 1						    	return - 1						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MISSING_NUMBER_1				      FIND_THE_MISSING_NUMBER_1					    FIND_THE_MISSING_NUMBER_1					  FIND_THE_MISSING_NUMBER_1
--							      --							    --								  --
static int getMissingNo ( int a [ ] , int n ) {		      def getMissingNo ( a , n ) :				    def get_missing_no ( a , n ) :				  success : None
  int total = 1 ;					      	  i , total = 0 , 1					    	total = 1						  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 2 ) :			    	for i in range ( 2 , ( n + 1 ) + 1 ) :			  
  i <= ( n + 1 ) ;					      	      total += i					    	    total += i						  
  i ++ ) {						      	      total -= a [ i - 2 ]				    	    total -= a [ i - 2 ]				  
    total += i ;					      	  return total						    	return total						  
    total -= a [ i - 2 ] ;				      								    								  
  }							      								    								  
  return total ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	      MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	    MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	  MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS
--							      --							    --								  --
static int cost ( int [ ] a , int n ) {			      def cost ( a , n ) :					    def cost ( a , n ) :					  success : None
  int min = a [ 0 ] ;					      	  return ( ( n - 1 ) * min ( a ) )			    	min = a [ 0 ]						  
  for ( int i = 1 ;					      								    	for i in a [ 1 : ] :					  
  i < a . length ;					      								    	    if i < min :					  
  i ++ ) {						      								    		min = i						  
    if ( a [ i ] < min ) min = a [ i ] ;		      								    	return ( n - 1 ) * min					  
  }							      								    								  
  return ( n - 1 ) * min ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			      C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			    C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			  C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY
--							      --							    --								  --
static int largest ( ) {				      def largest ( arr , n ) :					    def largest ( ) :						  script_not_found : None
  int i ;						      	  max = arr [ 0 ]					    	global arr						  
  int max = arr [ 0 ] ;					      	  for i in range ( 1 , n ) :				    	max = arr [ 0 ]						  
  for ( i = 1 ;						      	      if arr [ i ] > max :				    	for i in range ( 1 , len ( arr ) ) :			  
  i < arr . length ;					      		  max = arr [ i ]				    	    if arr [ i ] > max :				  
  i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;	      	  return max						    		max = arr [ i ]					  
  return max ;						      								    	return max						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP   HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP   HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP	  HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP
--							      --							    --								  --
static void printNos ( int n ) {			      def printNos ( n ) :					    def print_nos ( n ) :					  script_not_found : None
  if ( n > 0 ) {					      	  if n > 0 :						    	if n > 0 :						  
    printNos ( n - 1 ) ;				      	      printNos ( n - 1 )				    	    print_nos ( n - 1 )					  
    System . out . print ( n + " " ) ;			      	      print ( n , end = ' ' )				    	    print ( n , end = ' ' )				  
  }							      								    	return							  
  return ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX
--							      --							    --								  --
static int numberOfPaths ( int m , int n ) {		      def numberOfPaths ( m , n ) :				    def numberOfPaths ( m , n ) :				  script_not_found : None
  if ( m == 1 || n == 1 ) return 1 ;			      	  if ( m == 1 or n == 1 ) :				    	if m == 1 or n == 1 :					  
  return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n  	      return 1						    	    return 1						  
}							      	  return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m ,  	return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m ,  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1		      MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1			    MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1			  MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1
--							      --							    --								  --
static int maxvolume ( int s ) {			      def maxvolume ( s ) :					    def maxvolume ( s ) :					  failure : #Results: 9, 10
  int length = s / 3 ;					      	  length = int ( s / 3 )				    	length = s // 3						  
  s -= length ;						      	  s -= length						    	s -= length						  
  int breadth = s / 2 ;					      	  breadth = s / 2					    	breadth = s // 2					  
  int height = s - breadth ;				      	  height = s - breadth					    	height = s - breadth					  
  return length * breadth * height ;			      	  return int ( length * breadth * height )		    	return length * breadth * height			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY		      FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY			    FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY			  FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY
--							      --							    --								  --
static void findLarger ( int arr [ ] , int n ) {	      def findLarger ( arr , n ) :				    def find_larger ( arr , n ) :				  script_not_found : None
  Arrays . sort ( arr ) ;				      	  x = sorted ( arr )					    	arr.sort ( )						  
  for ( int i = n - 1 ;					      	  for i in range ( n / 2 , n ) :			    	for i in range ( n - 1 , n // 2 , - 1 ) :		  
  i >= n / 2 ;						      	      print ( x [ i ] ) ,				    	    print ( arr [ i ] , end = ' ' )			  
  i -- ) System . out . print ( arr [ i ] + " " ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GAME_REPLACING_ARRAY_ELEMENTS				      GAME_REPLACING_ARRAY_ELEMENTS				    GAME_REPLACING_ARRAY_ELEMENTS				  GAME_REPLACING_ARRAY_ELEMENTS
--							      --							    --								  --
public static int playGame ( int arr [ ] ) {		      def playGame ( arr , n ) :				    def play_game ( arr ) :					  script_not_found : None
  HashSet < Integer > set = new HashSet < > ( ) ;	      	  s = set ( )						    	arr = set ( arr )					  
  for ( int i : arr ) set . add ( i ) ;			      	  for i in range ( n ) :				    	return ( 1 if len ( arr ) % 2 == 0 else 2 )		  
  return ( set . size ( ) % 2 == 0 ) ? 1 : 2 ;		      	      s.add ( arr [ i ] )				    								  
}							      	  return 1 if len ( s ) % 2 == 0 else 2			    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY	      QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY		    QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY		  QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY
--							      --							    --								  --
static void leftRotate ( int arr [ ] , int n , int k ) {      def leftRotate ( arr , n , k ) :				    def left_rotate ( arr , n , k ) :				  script_not_found : None
  for ( int i = k ;					      	  for i in range ( k , k + n ) :			    	for i in range ( k , k + n ) :				  
  i < k + n ;						      	      print ( str ( arr [ i % n ] ) , end = " " )	    	    print ( arr [ i % n ] , end = ' ' )			  
  i ++ ) System . out . print ( arr [ i % n ] + " " ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HORNERS_METHOD_POLYNOMIAL_EVALUATION			      HORNERS_METHOD_POLYNOMIAL_EVALUATION			    HORNERS_METHOD_POLYNOMIAL_EVALUATION			  HORNERS_METHOD_POLYNOMIAL_EVALUATION
--							      --							    --								  --
static int horner ( int poly [ ] , int n , int x ) {	      def horner ( poly , n , x ) :				    def horner ( poly , n , x ) :				  success : identical to gold
  int result = poly [ 0 ] ;				      	  result = poly [ 0 ]					    	result = poly [ 0 ]					  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i < n ;						      	      result = result * x + poly [ i ]			    	    result = result * x + poly [ i ]			  
  i ++ ) result = result * x + poly [ i ] ;		      	  return result						    	return result						  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS					      SUM_PAIRWISE_PRODUCTS					    SUM_PAIRWISE_PRODUCTS					  SUM_PAIRWISE_PRODUCTS
--							      --							    --								  --
static int findSum ( int n ) {				      def findSum ( n ) :					    def find_sum ( n ) :					  success : None
  int sum = 0 ;						      	  sm = 0						    	sum = 0							  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	      for j in range ( i , n + 1 ) :			    	    for j in range ( i , n + 1 ) :			  
  i ++ ) for ( int j = i ;				      		  sm = sm + i * j				    		sum = sum + i * j				  
  j <= n ;						      	  return sm						    	return sum						  
  j ++ ) sum = sum + i * j ;				      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DOUBLE_FACTORIAL_1					      DOUBLE_FACTORIAL_1					    DOUBLE_FACTORIAL_1						  DOUBLE_FACTORIAL_1
--							      --							    --								  --
static int doublefactorial ( int n ) {			      def doublefactorial ( n ) :				    def doublefactorial ( n ) :					  success : None
  int res = 1 ;						      	  res = 1						    	res = 1							  
  for ( int i = n ;					      	  for i in range ( n , - 1 , - 2 ) :			    	for i in range ( n , - 1 , - 2 ) :			  
  i >= 0 ;						      	      if ( i == 0 or i == 1 ) :				    	    if i == 0 or i == 1 :				  
  i = i - 2 ) {						      		  return res					    		return res					  
    if ( i == 0 || i == 1 ) return res ;		      	      else :						    	    else :						  
    else res *= i ;					      		  res *= i					    		res *= i					  
  }							      								    	return res						  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSION						      RECURSION							    RECURSION							  RECURSION
--							      --							    --								  --
static void printFun ( int test ) {			      def printFun ( test ) :					    def print_fun ( test ) :					  script_not_found : None
  if ( test < 1 ) return ;				      	  if ( test < 1 ) :					    	if test < 1 :						  
  else {						      	      return						    	    return						  
    System . out . printf ( "%d " , test ) ;		      	  else :						    	else :							  
    printFun ( test - 1 ) ;				      	      print ( test , end = " " )			    	    print ( test , end = ' ' )				  
    System . out . printf ( "%d " , test ) ;		      	      printFun ( test - 1 )				    	    print_fun ( test - 1 )				  
    return ;						      	      print ( test , end = " " )			    	    print ( test , end = ' ' )				  
  }							      	      return						    	    return						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_EFFICIENTLY_CALCULATE_EX			      PROGRAM_TO_EFFICIENTLY_CALCULATE_EX			    PROGRAM_TO_EFFICIENTLY_CALCULATE_EX				  PROGRAM_TO_EFFICIENTLY_CALCULATE_EX
--							      --							    --								  --
static float exponential ( int n , float x ) {		      def exponential ( n , x ) :				    def exponential ( n , x ) :					  script_not_found : None
  float sum = 1 ;					      	  sum = 1.0						    	sum = 1							  
  for ( int i = n - 1 ;					      	  for i in range ( n , 0 , - 1 ) :			    	for i in range ( n - 1 , 0 , - 1 ) :			  
  i > 0 ;						      	      sum = 1 + x * sum / i				    	    sum = 1 + x * sum / i				  
  -- i ) sum = 1 + x * sum / i ;			      	  print ( "e^x =" , sum )				    	return sum						  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_ROOT_OF_A_PERFECT_SQUARE				      SQUARE_ROOT_OF_A_PERFECT_SQUARE				    SQUARE_ROOT_OF_A_PERFECT_SQUARE				  SQUARE_ROOT_OF_A_PERFECT_SQUARE
--							      --							    --								  --
static float squareRoot ( float n ) {			      def squareRoot ( n ) :					    def square_root ( n ) :					  success : None
  float x = n ;						      	  x = n							    	x = n							  
  float y = 1 ;						      	  y = 1							    	y = 1							  
  double e = 0.000001 ;					      	  e = 0.000001						    	e = 0.000001						  
  while ( x - y > e ) {					      	  while ( x - y > e ) :					    	while x - y > e :					  
    x = ( x + y ) / 2 ;					      	      x = ( x + y ) / 2					    	    x = ( x + y ) / 2					  
    y = n / x ;						      	      y = n / x						    	    y = n / x						  
  }							      	  return x						    	return x						  
  return x ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N			      FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N			    FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N				  FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N
--							      --							    --								  --
static void printFactorialNums ( int n ) {		      def printFactorialNums ( n ) :				    def print_factorial ( n ) :					  script_not_found : None
  int fact = 1 ;					      	  fact = 1						    	fact = 1						  
  int x = 2 ;						      	  x = 2							    	x = 2							  
  while ( fact <= n ) {					      	  while fact <= n :					    	while fact <= n :					  
    System . out . print ( fact + " " ) ;		      	      print ( fact , end = " " )			    	    print ( fact , end = ' ' )				  
    fact = fact * x ;					      	      fact = fact * x					    	    fact = fact * x					  
    x ++ ;						      	      x += 1						    	    x += 1						  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_20				      CHECK_LARGE_NUMBER_DIVISIBLE_20				    CHECK_LARGE_NUMBER_DIVISIBLE_20				  CHECK_LARGE_NUMBER_DIVISIBLE_20
--							      --							    --								  --
static Boolean divisibleBy20 ( String num ) {		      def divisibleBy20 ( num ) :				    def divisible_by_20 ( num ) :				  script_not_found : None
  int lastTwoDigits = Integer . parseInt ( num . substring (  	  lastTwoDigits = int ( num [ - 2 : ] )			    	last_two_digits = int ( num [ - 2 : len ( num ) ] )	  
  return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4  	  return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 = 	return ( ( last_two_digits % 5 == 0 ) and ( last_two_digi 
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_ROOT_OF_AN_INTEGER				      SQUARE_ROOT_OF_AN_INTEGER					    SQUARE_ROOT_OF_AN_INTEGER					  SQUARE_ROOT_OF_AN_INTEGER
--							      --							    --								  --
static int floorSqrt ( int x ) {			      def floorSqrt ( x ) :					    def floor_sqrt ( x ) :					  success : None
  if ( x == 0 || x == 1 ) return x ;			      	  if ( x == 0 or x == 1 ) :				    	if not x or not x :					  
  int i = 1 , result = 1 ;				      	      return x						    	    return x						  
  while ( result <= x ) {				      	  i = 1 result = 1					    	i , result = 1 , 1					  
    i ++ ;						      	  while ( result <= x ) :				    	while result <= x :					  
    result = i * i ;					      	      i += 1						    	    i += 1						  
  }							      	      result = i * i					    	    result = i * i					  
  return i - 1 ;					      	  return i - 1						    	return i - 1						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING		      HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING			    HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING			  HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING
--							      --							    --								  --
static int search ( int arr [ ] , int n , int x ) {	      def search ( arr , x ) :					    def search ( arr , n , x ) :				  script_not_found : None
  for ( int i = 0 ;					      	  n = len ( arr )					    	for i in range ( n ) :					  
  i < n ;						      	  for j in range ( 0 , n ) :				    	    if arr [ i ] == x :					  
  i ++ ) {						      	      if ( x == arr [ j ] ) :				    		return i					  
    if ( arr [ i ] == x ) return i ;			      		  return j					    	return - 1						  
  }							      	  return - 1						    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			      MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			    MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			  MULTIPLICATIVE_INVERSE_UNDER_MODULO_M
--							      --							    --								  --
static int modInverse ( int a , int m ) {		      def modInverse ( a , m ) :				    def mod_inverse ( a , m ) :					  script_not_found : None
  a = a % m ;						      	  a = a % m						    	a = a % m						  
  for ( int x = 1 ;					      	  for x in range ( 1 , m ) :				    	for x in range ( 1 , m ) :				  
  x < m ;						      	      if ( ( a * x ) % m == 1 ) :			    	    if ( a * x ) % m == 1 :				  
  x ++ ) if ( ( a * x ) % m == 1 ) return x ;		      		  return x					    		return x					  
  return 1 ;						      	  return 1						    	return 1						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		      PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		    PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		  PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING
--							      --							    --								  --
public static int count ( String s , char c ) {		      def count ( s , c ) :					    def count ( s , c ) :					  failure : #Results: 0, 10
  int res = 0 ;						      	  res = 0						    	res = 0							  
  for ( int i = 0 ;					      	  for i in range ( len ( s ) ) :			    	for c in s :						  
  i < s . length ( ) ;					      	      if ( s [ i ] == c ) :				    	    if c == c :						  
  i ++ ) {						      		  res = res + 1					    		res += 1					  
    if ( s . charAt ( i ) == c ) res ++ ;		      	  return res						    	return res						  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SERIES_12_32_52_2N_12				      SUM_SERIES_12_32_52_2N_12					    SUM_SERIES_12_32_52_2N_12					  SUM_SERIES_12_32_52_2N_12
--							      --							    --								  --
static int sumOfSeries ( int n ) {			      def sumOfSeries ( n ) :					    def sum_of_series ( n ) :					  success : None
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	      sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 )		    	    sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 )		  
  i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ;	      	  return sum						    	return sum						  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2						      NEXT_POWER_OF_2						    NEXT_POWER_OF_2						  NEXT_POWER_OF_2
--							      --							    --								  --
static int nextPowerOf2 ( int n ) {			      def nextPowerOf2 ( n ) :					    def next_pow2 ( n ) :					  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;	      	  if ( n and not ( n & ( n - 1 ) ) ) :			    	if n > 0 and ( n & ( n - 1 ) ) == 0 :			  
  while ( n != 0 ) {					      	      return n						    	    return n						  
    n >>= 1 ;						      	  while ( n != 0 ) :					    	while n != 0 :						  
    count += 1 ;					      	      n >>= 1						    	    n >>= 1						  
  }							      	      count += 1					    	    count += 1						  
  return 1 << count ;					      	  return 1 << count					    	return 1 << count					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		      CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		    CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		  CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER
--							      --							    --								  --
public static boolean isPower ( int x , int y ) {	      def isPower ( x , y ) :					    def is_power ( x , y ) :					  success : None
  if ( x == 1 ) return ( y == 1 ) ;			      	  if ( x == 1 ) :					    	if x == 1 :						  
  int pow = 1 ;						      	      return ( y == 1 )					    	    return ( y == 1 )					  
  while ( pow < y ) pow = pow * x ;			      	  pow = 1						    	pow = 1							  
  return ( pow == y ) ;					      	  while ( pow < y ) :					    	while pow < y :						  
}							      	      pow = pow * x					    	    pow = pow * x					  
							      	  return ( pow == y )					    	return ( pow == y )					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUICK_WAY_CHECK_CHARACTERS_STRING			      QUICK_WAY_CHECK_CHARACTERS_STRING				    QUICK_WAY_CHECK_CHARACTERS_STRING				  QUICK_WAY_CHECK_CHARACTERS_STRING
--							      --							    --								  --
static boolean allCharactersSame ( String s ) {		      def allCharactersSame ( s ) :				    def allCharactersSame ( s ) :				  success : None
  int n = s . length ( ) ;				      	  n = len ( s )						    	n = len ( s )						  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for c in s [ 1 : n ] :					  
  i < n ;						      	      if s [ i ] != s [ 0 ] :				    	    if c != s [ 0 ] :					  
  i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return f 		  return False					    		return False					  
  return true ;						      	  return True						    	return True						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER		      FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER		    FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER			  FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER
--							      --							    --								  --
static void center ( int x1 , int x2 , int y1 , int y2 ) {    def center ( x1 , x2 , y1 , y2 ) :			    def center ( x1 , x2 , y1 , y2 ) :				  script_not_found : None
  System . out . print ( ( float ) ( x1 + x2 ) / 2 + ", " + ( 	  print ( int ( ( x1 + x2 ) / 2 ) , end = "" )		    	print ( float ( x1 + x2 ) / 2 , float ( y1 + y2 ) / 2 )	  
}							      	  print ( "," , int ( ( y1 + y2 ) / 2 ) )		    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS			      SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS			    SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS				  SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS
--							      --							    --								  --
public static int kthgroupsum ( int k ) {		      def kthgroupsum ( k ) :					    def kthgroupsum ( k ) :					  timeout : None
  int cur = ( k * ( k - 1 ) ) + 1 ;			      	  cur = int ( ( k * ( k - 1 ) ) + 1 )			    	cur = ( k * ( k - 1 ) ) + 1				  
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  while ( k -- > 0 ) {					      	  while k :						    	while k > 0 :						  
    sum += cur ;					      	      sum += cur					    	    sum += cur						  
    cur += 2 ;						      	      cur += 2						    	    cur += 2						  
  }							      	      k = k - 1						    	return sum						  
  return sum ;						      	  return sum						    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME
--							      --							    --								  --
static int getSum ( int n ) {				      def getSum ( n ) :					    def get_sum ( n ) :						  success : None
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  while ( n != 0 ) {					      	  while ( n != 0 ) :					    	while n != 0 :						  
    sum = sum + n % 10 ;				      	      sum = sum + int ( n % 10 )			    	    sum = sum + n % 10					  
    n = n / 10 ;					      	      n = int ( n / 10 )				    	    n = n // 10						  
  }							      	  return sum						    	return sum						  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		      SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		    SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		  SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX
--							      --							    --								  --
static int spiralDiaSum ( int n ) {			      def spiralDiaSum ( n ) :					    def spiral_dia_sum ( n ) :					  script_not_found : None
  if ( n == 1 ) return 1 ;				      	  if n == 1 :						    	if n == 1 :						  
  return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; 	      return 1						    	    return 1						  
}							      	  return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) 	return ( 4 * n * n - 6 * n + 6 + spiral_dia_sum ( n - 2 ) 
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_IS_DIVISIBLE_BY_29_OR_NOT			      NUMBER_IS_DIVISIBLE_BY_29_OR_NOT				    NUMBER_IS_DIVISIBLE_BY_29_OR_NOT				  NUMBER_IS_DIVISIBLE_BY_29_OR_NOT
--							      --							    --								  --
static boolean isDivisible ( long n ) {			      def isDivisible ( n ) :					    def is_difficult ( n ) :					  timeout : None
  while ( n / 100 > 0 ) {				      	  while ( int ( n / 100 ) ) :				    	while n / 100 > 0 :					  
    int last_digit = ( int ) n % 10 ;			      	      last_digit = int ( n % 10 )			    	    last_digit = int ( n ) % 10				  
    n /= 10 ;						      	      n = int ( n / 10 )				    	    n //= 10						  
    n += last_digit * 3 ;				      	      n += last_digit * 3				    	    n += last_digit * 3					  
  }							      	  return ( n % 29 == 0 )				    	return ( n % 29 == 0 )					  
  return ( n % 29 == 0 ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY    COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY    COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY	  COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY
--							      --							    --								  --
static int countOccurrences ( int arr [ ] , int n , int x ) { def countOccurrences ( arr , n , x ) :			    def count_occurrences ( arr , n , x ) :			  success : None
  int res = 0 ;						      	  res = 0						    	res = 0							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if x == arr [ i ] :				    	    if x == arr [ i ] :					  
  i ++ ) if ( x == arr [ i ] ) res ++ ;			      		  res += 1					    		res += 1					  
  return res ;						      	  return res						    	return res						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSITION_OF_RIGHTMOST_SET_BIT_2				      POSITION_OF_RIGHTMOST_SET_BIT_2				    POSITION_OF_RIGHTMOST_SET_BIT_2				  POSITION_OF_RIGHTMOST_SET_BIT_2
--							      --							    --								  --
static int Right_most_setbit ( int num ) {		      def Right_most_setbit ( num ) :				    def Right_most_setbit ( num ) :				  script_not_found : None
  int pos = 1 ;						      	  pos = 1						    	pos = 1							  
  for ( int i = 0 ;					      	  for i in range ( INT_SIZE ) :				    	for i in range ( INT_SIZE ) :				  
  i < INT_SIZE ;					      	      if not ( num & ( 1 << i ) ) :			    	    if ( num & ( 1 << i ) ) == 0 :			  
  i ++ ) {						      		  pos += 1					    		pos += 1					  
    if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ;		      	      else :						    	    else :						  
    else break ;					      		  break						    		break						  
  }							      	  return pos						    	return pos						  
  return pos ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1	      SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1		    SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1		  SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1
--							      --							    --								  --
static int nextPowerOf2 ( int n ) {			      def nextPowerOf2 ( n ) :					    def next_pow2 ( n ) :					  success : None
  int p = 1 ;						      	  p = 1							    	p = 1							  
  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;	      	  if ( n and not ( n & ( n - 1 ) ) ) :			    	if n > 0 and ( n & ( n - 1 ) ) == 0 :			  
  while ( p < n ) p <<= 1 ;				      	      return n						    	    return n						  
  return p ;						      	  while ( p < n ) :					    	while p < n :						  
}							      	      p <<= 1						    	    p <<= 1						  
							      	  return p						    	return p						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3
--							      --							    --								  --
static int numberOfPaths ( int m , int n ) {		      def numberOfPaths ( m , n ) :				    def numberOfPaths ( m , n ) :				  script_not_found : None
  int path = 1 ;					      	  for i in range ( n , ( m + n - 1 ) ) :		    	path = 1						  
  for ( int i = n ;					      	      path *= i						    	for i in range ( n , ( m + n - 1 ) ) :			  
  i < ( m + n - 1 ) ;					      	      path //= ( i - n + 1 )				    	    path *= i						  
  i ++ ) {						      	  return path						    	    path //= ( i - n + 1 )				  
    path *= i ;						      								    	return path						  
    path /= ( i - n + 1 ) ;				      								    								  
  }							      								    								  
  return path ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS	      ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS		    ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS		  ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS
--							      --							    --								  --
static int search ( int arr [ ] , int n , int x ) {	      def search ( arr , n , x ) :				    def search ( arr , n , x ) :				  success : None
  int i ;						      	  i = 0							    	for i in range ( n ) :					  
  for ( i = 0 ;						      	  for i in range ( i , n ) :				    	    if arr [ i ] == x :					  
  i < n ;						      	      if ( arr [ i ] == x ) :				    		return i					  
  i ++ ) {						      		  return i					    	return - 1						  
    if ( arr [ i ] == x ) {				      	  return - 1						    								  
      return i ;					      								    								  
    }							      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION      CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION	    CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION	  CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION
--							      --							    --								  --
static boolean isPerfectSquare ( int n ) {		      def isPerfectSquare ( n ) :				    def is_perfect_square ( n ) :				  error : Traceback (most recent call last):   File
  for ( int sum = 0 , i = 1 ;				      	  i = 1							    	for sum , i in zip ( [ 0 ] , [ 1 ] * n , [ 2 ] * n ) :	  "dump/transcoder_st/eval/java_python/online_st/206
  sum < n ;						      	  the_sum = 0						    	    sum += i						  68770/eval_scripts/java_sa-python_sa.test/CHECK_NU
  i += 2 ) {						      	  while the_sum < n :					    	    if sum == n :					  MBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION.p
    sum += i ;						      	      the_sum += i					    		return True					  y", line 51, in <module>     if f_filled(*paramete
    if ( sum == n ) return true ;			      	      if the_sum == n :					    	return False						  rs_set) == f_gold(*parameters_set):	File "dump/t
  }							      		  return True					    								  ranscoder_st/eval/java_python/online_st/20668770/e
  return false ;					      	      i += 2						    								  val_scripts/java_sa-python_sa.test/CHECK_NUMBER_IS
}							      	  return False						    								  _PERFECT_SQUARE_USING_ADDITIONSUBTRACTION.py", lin
							      								    								  e 29, in f_filled	for sum , i in zip ( [ 0 ] ,
							      								    								   [ 1 ] * n , [ 2 ] * n ) : ValueError: too many va
							      								    								  lues to unpack (expected 2)
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_NTH_CATALAN_NUMBER				      PROGRAM_NTH_CATALAN_NUMBER				    PROGRAM_NTH_CATALAN_NUMBER					  PROGRAM_NTH_CATALAN_NUMBER
--							      --							    --								  --
int catalan ( int n ) {					      def catalan ( n ) :					    def catalan ( n ) :						  script_not_found : None
  int res = 0 ;						      	  if n <= 1 :						    	res = 0							  
  if ( n <= 1 ) {					      	      return 1						    	if n <= 1 :						  
    return 1 ;						      	  res = 0						    	    return 1						  
  }							      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      res += catalan ( i ) * catalan ( n - i - 1 )	    	    res += catalan ( i ) * catalan ( n - i - 1 )	  
  i < n ;						      	  return res						    	return res						  
  i ++ ) {						      								    								  
    res += catalan ( i ) * catalan ( n - i - 1 ) ;	      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			      PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			    PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			  PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX
--							      --							    --								  --
static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) {     def transpose ( A , B ) :					    def transpose ( A , B ) :					  script_not_found : None
  int i , j ;						      	  for i in range ( N ) :				    	global N						  
  for ( i = 0 ;						      	      for j in range ( N ) :				    	for i in range ( N ) :					  
  i < N ;						      		  B [ i ] [ j ] = A [ j ] [ i ]			    	    for j in range ( N ) :				  
  i ++ ) for ( j = 0 ;					      								    		B [ i ] [ j ] = A [ j ] [ i ]			  
  j < N ;						      								    								  
  j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE    FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE    FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE	  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE
--							      --							    --								  --
static char first ( String str ) {			      def first ( str ) :					    def first ( x ) :						  success : None
  for ( int i = 0 ;					      	  for i in range ( 0 , len ( str ) ) :			    	for c in x :						  
  i < str . length ( ) ;				      	      if ( str [ i ].istitle ( ) ) :			    	    if c.isupper ( ) :					  
  i ++ ) if ( Character . isUpperCase ( str . charAt ( i ) )  		  return str [ i ]				    		return c					  
  return 0 ;						      	  return 0						    	return 0						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			      C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			    C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			  C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE
--							      --							    --								  --
static void rotate ( ) {				      def rotate ( arr , n ) :					    def rotate ( ) :						  script_not_found : None
  int x = arr [ arr . length - 1 ] , i ;		      	  x = arr [ n - 1 ]					    	x , i = arr [ - 1 ] , i					  
  for ( i = arr . length - 1 ;				      	  for i in range ( n - 1 , 0 , - 1 ) :			    	for i in range ( len ( arr ) - 1 , 0 , - 1 ) :		  
  i > 0 ;						      	      arr [ i ] = arr [ i - 1 ]				    	    arr [ i ] = arr [ i - 1 ]				  
  i -- ) arr [ i ] = arr [ i - 1 ] ;			      	  arr [ 0 ] = x						    	arr [ 0 ] = x						  
  arr [ 0 ] = x ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_EVEN_FIBONACCI_NUMBER				      NTH_EVEN_FIBONACCI_NUMBER					    NTH_EVEN_FIBONACCI_NUMBER					  NTH_EVEN_FIBONACCI_NUMBER
--							      --							    --								  --
static long evenFib ( int n ) {				      def evenFib ( n ) :					    def even_fib ( n ) :					  script_not_found : None
  if ( n < 1 ) return n ;				      	  if ( n < 1 ) :					    	if n < 1 :						  
  if ( n == 1 ) return 2 ;				      	      return n						    	    return n						  
  return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;  	  if ( n == 1 ) :					    	if n == 1 :						  
}							      	      return 2						    	    return 2						  
							      	  return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) )  	return ( ( 4 * even_fib ( n - 1 ) ) + even_fib ( n - 2 )  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY		      K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY			    K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY			  K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY
--							      --							    --								  --
public static void kLargest ( Integer [ ] arr , int k ) {     def kLargest ( arr , k ) :				    def k_largest ( arr = None , k = None ) :			  script_not_found : None
  Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;    	  arr.sort ( reverse = True )				    	arr.sort ( reverse = True )				  
  for ( int i = 0 ;					      	  for i in range ( k ) :				    	for i in range ( k ) :					  
  i < k ;						      	      print ( arr [ i ] , end = " " )			    	    print ( arr [ i ] , end = ' ' )			  
  i ++ ) System . out . print ( arr [ i ] + " " ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	      FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	    FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	  FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN
--							      --							    --								  --
static double compute ( int a , int b ) {		      def compute ( a , b ) :					    def compute ( a , b ) :					  success : None
  double AM , GM , HM ;					      	  AM = ( a + b ) / 2					    	global AM , GM , HM					  
  AM = ( a + b ) / 2 ;					      	  GM = math.sqrt ( a * b )				    	AM = ( a + b ) / 2					  
  GM = Math . sqrt ( a * b ) ;				      	  HM = ( GM * GM ) / AM					    	GM = math.sqrt ( a * b )				  
  HM = ( GM * GM ) / AM ;				      	  return HM						    	HM = ( GM * GM ) / AM					  
  return HM ;						      								    	return HM						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES			      SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES			    SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES				  SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES
--							      --							    --								  --
static int findS ( int s ) {				      def findS ( s ) :						    def find_s ( s ) :						  failure : #Results: 9, 10
  int sum = 0 ;						      	  _sum = 0						    	sum = 0							  
  for ( int n = 1 ;					      	  n = 1							    	for n in range ( 1 , s ) :				  
  sum < s ;						      	  while ( _sum < s ) :					    	    sum += n * n					  
  n ++ ) {						      	      _sum += n * n					    	    if sum == s :					  
    sum += n * n ;					      	      n += 1						    		return n					  
    if ( sum == s ) return n ;				      	  n -= 1						    	return - 1						  
  }							      	  if _sum == s :					    								  
  return - 1 ;						      	      return n						    								  
}							      	  return - 1						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TRIANGULAR_NUMBERS					      TRIANGULAR_NUMBERS					    TRIANGULAR_NUMBERS						  TRIANGULAR_NUMBERS
--							      --							    --								  --
static boolean isTriangular ( int num ) {		      def isTriangular ( num ) :				    def is_triangular ( num ) :					  success : None
  if ( num < 0 ) return false ;				      	  if ( num < 0 ) :					    	if num < 0 :						  
  int sum = 0 ;						      	      return False					    	    return False					  
  for ( int n = 1 ;					      	  sum , n = 0 , 1					    	sum = 0							  
  sum <= num ;						      	  while ( sum <= num ) :				    	for n in range ( 1 , num + 1 ) :			  
  n ++ ) {						      	      sum = sum + n					    	    sum = sum + n					  
    sum = sum + n ;					      	      if ( sum == num ) :				    	    if sum == num :					  
    if ( sum == num ) return true ;			      		  return True					    		return True					  
  }							      	      n += 1						    	return False						  
  return false ;					      	  return False						    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2	      SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2		    SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2		  SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2
--							      --							    --								  --
static int nextPowerOf2 ( int n ) {			      def nextPowerOf2 ( n ) :					    def next_pow2 ( n ) :					  success : None
  n -- ;						      	  n -= 1						    	n -= 1							  
  n |= n >> 1 ;						      	  n |= n >> 1						    	n |= n >> 1						  
  n |= n >> 2 ;						      	  n |= n >> 2						    	n |= n >> 2						  
  n |= n >> 4 ;						      	  n |= n >> 4						    	n |= n >> 4						  
  n |= n >> 8 ;						      	  n |= n >> 8						    	n |= n >> 8						  
  n |= n >> 16 ;					      	  n |= n >> 16						    	n |= n >> 16						  
  n ++ ;						      	  n += 1						    	n += 1							  
  return n ;						      	  return n						    	return n						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_POWER_PRIME_NUMBER_P_N				      FINDING_POWER_PRIME_NUMBER_P_N				    FINDING_POWER_PRIME_NUMBER_P_N				  FINDING_POWER_PRIME_NUMBER_P_N
--							      --							    --								  --
static int PowerOFPINnfactorial ( int n , int p ) {	      def PowerOFPINnfactorial ( n , p ) :			    def PowerOFPINnfactorial ( n , p ) :			  failure : #Results: 2, 10
  int ans = 0 ;						      	  ans = 0						    	ans = 0							  
  for ( int i = 1 ;					      	  temp = p						    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	  while ( temp <= n ) :					    	    count , temp = 0 , i				  
  i ++ ) {						      	      ans += n / temp					    	    while temp % p == 0 :				  
    int count = 0 , temp = i ;				      	      temp = temp * p					    		count += 1					  
    while ( temp % p == 0 ) {				      	  return ans						    		temp = temp // p				  
      count ++ ;					      								    	    ans += count					  
      temp = temp / p ;					      								    	return ans						  
    }							      								    								  
    ans += count ;					      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REVERSE_A_STRING_USING_RECURSION			      REVERSE_A_STRING_USING_RECURSION				    REVERSE_A_STRING_USING_RECURSION				  REVERSE_A_STRING_USING_RECURSION
--							      --							    --								  --
void reverse ( String str ) {				      def reverse ( string ) :					    def reverse ( str ) :					  script_not_found : None
  if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System  	  if len ( string ) == 0 :				    	if ( str is None ) or ( len ( str ) <= 1 ) :		  
  else {						      	      return						    	    print ( str )					  
    System . out . print ( str . charAt ( str . length ( ) -  	  temp = string [ 0 ]					    	else :							  
    reverse ( str . substring ( 0 , str . length ( ) - 1 ) )  	  reverse ( string [ 1 : ] )				    	    print ( str [ - 1 ] , end = ' ' )			  
  }							      	  print ( temp , end = '' )				    	    reverse ( str [ : - 1 ] )				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT		  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT
--							      --							    --								  --
static int isPowerOfFour ( int n ) {			      def isPowerOfFour ( n ) :					    def is_power_of_four ( n ) :				  success : None
  if ( n == 0 ) return 0 ;				      	  if ( n == 0 ) :					    	if not n :						  
  while ( n != 1 ) {					      	      return False					    	    return 0						  
    if ( n % 4 != 0 ) return 0 ;			      	  while ( n != 1 ) :					    	while n != 1 :						  
    n = n / 4 ;						      	      if ( n % 4 != 0 ) :				    	    if n % 4 :						  
  }							      		  return False					    		return 0					  
  return 1 ;						      	      n = n // 4					    	    n = n // 4						  
}							      	  return True						    	return 1						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW
--							      --							    --								  --
static boolean isPowerOfTwo ( int n ) {			      def isPowerOfTwo ( n ) :					    def is_power_of_two ( n ) :					  success : None
  if ( n == 0 ) return false ;				      	  if ( n == 0 ) :					    	if not n :						  
  while ( n != 1 ) {					      	      return False					    	    return False					  
    if ( n % 2 != 0 ) return false ;			      	  while ( n != 1 ) :					    	while n != 1 :						  
    n = n / 2 ;						      	      if ( n % 2 != 0 ) :				    	    if n % 2 :						  
  }							      		  return False					    		return False					  
  return true ;						      	      n = n // 2					    	    n = n // 2						  
}							      	  return True						    	return True						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIBONACCI_MODULO_P					      FIBONACCI_MODULO_P					    FIBONACCI_MODULO_P						  FIBONACCI_MODULO_P
--							      --							    --								  --
static int findMinZero ( int p ) {			      def findMinZero ( p ) :					    def find_min_zero ( p ) :					  success : None
  int first = 1 , second = 1 , number = 2 , next = 1 ;	      	  first = 1						    	first , second , number , next = 1 , 1 , 2 , 1		  
  while ( next > 0 ) {					      	  second = 1						    	while next > 0 :					  
    next = ( first + second ) % p ;			      	  number = 2						    	    next = ( first + second ) % p			  
    first = second ;					      	  next = 1						    	    first = second					  
    second = next ;					      	  while ( next ) :					    	    second = next					  
    number ++ ;						      	      next = ( first + second ) % p			    	    number += 1						  
  }							      	      first = second					    	return number						  
  return number ;					      	      second = next					    								  
}							      	      number = number + 1				    								  
							      	  return number						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY    FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY    FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY	  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY
--							      --							    --								  --
static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n )  def findExtra ( arr1 , arr2 , n ) :			    def find_extra ( arr1 , arr2 , n ) :			  success : None
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( arr1 [ i ] != arr2 [ i ] ) :			    	    if arr1 [ i ] != arr2 [ i ] :			  
  i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ;	      		  return i					    		return i					  
  return n ;						      	  return n						    	return n						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1			      NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1			    NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1				  NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1
--							      --							    --								  --
public static int countDigits ( int a , int b ) {	      def countDigits ( a , b ) :				    def count_digits ( a , b ) :				  success : None
  if ( a == 0 || b == 0 ) return 1 ;			      	  if ( a == 0 or b == 0 ) :				    	if not a or not b :					  
  return ( int ) Math . floor ( Math . log10 ( Math . abs ( a 	      return 1						    	    return 1						  
}							      	  return math.floor ( math.log10 ( abs ( a ) ) + math.log10 	return int ( math.floor ( math.log10 ( abs ( a ) ) + math 
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		      CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		    CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		  CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1
--							      --							    --								  --
static boolean isPower ( int x , int y ) {		      def isPower ( x , y ) :					    def is_power ( x , y ) :					  error : Traceback (most recent call last):   File
  int res1 = ( int ) Math . log ( y ) / ( int ) Math . log (  	  res1 = math.log ( y ) / math.log ( x )		    	res1 = int ( math.log ( y ) ) / int ( math.log ( x ) )	  "dump/transcoder_st/eval/java_python/online_st/206
  double res2 = Math . log ( y ) / Math . log ( x ) ;	      	  res2 = math.log ( y ) / math.log ( x )		    	res2 = math.log ( y ) / math.log ( x )			  68770/eval_scripts/java_sa-python_sa.test/CHECK_IF
  return ( res1 == res2 ) ;				      	  return 1 if ( res1 == res2 ) else 0			    	return ( res1 == res2 )					  _A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1.py", line 4
}							      								    								  6, in <module>     if f_filled(*parameters_set) ==
							      								    								   f_gold(*parameters_set):   File "dump/transcoder_
							      								    								  st/eval/java_python/online_st/20668770/eval_script
							      								    								  s/java_sa-python_sa.test/CHECK_IF_A_NUMBER_IS_POWE
							      								    								  R_OF_ANOTHER_NUMBER_1.py", line 26, in f_filled
							      								    								    res1 = int ( math.log ( y ) ) / int ( math.log (
							      								    								   x ) ) ZeroDivisionError: division by zero
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	      SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	    SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	  SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS
--							      --							    --								  --
static int smallest ( int x , int y , int z ) {		      def smallest ( x , y , z ) :				    def smallest ( x , y , z ) :				  success : None
  int c = 0 ;						      	  c = 0							    	c = 0							  
  while ( x != 0 && y != 0 && z != 0 ) {		      	  while ( x and y and z ) :				    	while x != 0 and y != 0 and z != 0 :			  
    x -- ;						      	      x = x - 1						    	    x -= 1						  
    y -- ;						      	      y = y - 1						    	    y -= 1						  
    z -- ;						      	      z = z - 1						    	    z -= 1						  
    c ++ ;						      	      c = c + 1						    	    c += 1						  
  }							      	  return c						    	return c						  
  return c ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARED_TRIANGULAR_NUMBER_SUM_CUBES			      SQUARED_TRIANGULAR_NUMBER_SUM_CUBES			    SQUARED_TRIANGULAR_NUMBER_SUM_CUBES				  SQUARED_TRIANGULAR_NUMBER_SUM_CUBES
--							      --							    --								  --
static int findS ( int s ) {				      def findS ( s ) :						    def find_s ( s ) :						  success : None
  int sum = 0 ;						      	  _sum = 0						    	sum = 0							  
  for ( int n = 1 ;					      	  n = 1							    	for n in range ( 1 , s ) :				  
  sum < s ;						      	  while ( _sum < s ) :					    	    sum += n * n * n					  
  n ++ ) {						      	      _sum += n * n * n					    	    if sum == s :					  
    sum += n * n * n ;					      	      n += 1						    		return n					  
    if ( sum == s ) return n ;				      	  n -= 1						    	return - 1						  
  }							      	  if _sum == s :					    								  
  return - 1 ;						      	      return n						    								  
}							      	  return - 1						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT
--							      --							    --								  --
static boolean check ( String str ) {			      def check ( st ) :					    def check ( data ) :					  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( st )					    	n = len ( data )					  
  int digitSum = 0 ;					      	  digitSum = 0						    	digital_sum = 0						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for c in data :						  
  i < n ;						      	      digitSum = digitSum + ( int ) ( st [ i ] )	    	    digital_sum += ord ( c ) - ord ( '0' )		  
  i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ;	      	  return ( digitSum % 9 == 0 )				    	return ( digital_sum % 9 == 0 )				  
  return ( digitSum % 9 == 0 ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DIGITS_PRODUCT_TWO_NUMBERS			      NUMBER_DIGITS_PRODUCT_TWO_NUMBERS				    NUMBER_DIGITS_PRODUCT_TWO_NUMBERS				  NUMBER_DIGITS_PRODUCT_TWO_NUMBERS
--							      --							    --								  --
static int countDigits ( int a , int b ) {		      def countDigits ( a , b ) :				    def count_digits ( a , b ) :				  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  int p = Math . abs ( a * b ) ;			      	  p = abs ( a * b )					    	p = abs ( a * b )					  
  if ( p == 0 ) return 1 ;				      	  if ( p == 0 ) :					    	if not p :						  
  while ( p > 0 ) {					      	      return 1						    	    return 1						  
    count ++ ;						      	  while ( p > 0 ) :					    	while p > 0 :						  
    p = p / 10 ;					      	      count = count + 1					    	    count += 1						  
  }							      	      p = p // 10					    	    p = p // 10						  
  return count ;					      	  return count						    	return count						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE		      NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE			    NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE			  NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE
--							      --							    --								  --
static int answer_query ( int a [ ] , int n , int l , int r ) def answer_query ( a , n , l , r ) :			    def answer_query ( a , n , l , r ) :			  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int i = l ;					      	  for i in range ( l , r ) :				    	for i in range ( l , r ) :				  
  i < r ;						      	      if ( a [ i ] == a [ i + 1 ] ) :			    	    if a [ i ] == a [ i + 1 ] :				  
  i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ;	      		  count += 1					    		count += 1					  
  return count ;					      	  return count						    	return count						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE	      SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE		    SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE		  SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE
--							      --							    --								  --
static void swap ( int [ ] xp , int [ ] yp ) {		      def swap ( xp , yp ) :					    def swap ( xp , yp ) :					  success : identical to gold
  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;			      	  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]			    	xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]				  
  yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;			      	  yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]			    	yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]				  
  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;			      	  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]			    	xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		      RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		    RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		  RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS
--							      --							    --								  --
public static int findFrequency ( int arr [ ] , int n , int l def findFrequency ( arr , n , left , right , element ) :	    def find_frequency ( arr , n , left , right , element ) :	  script_not_found : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int i = left - 1 ;				      	  for i in range ( left - 1 , right ) :			    	for i in range ( left - 1 , right ) :			  
  i < right ;						      	      if ( arr [ i ] == element ) :			    	    if arr [ i ] == element :				  
  ++ i ) if ( arr [ i ] == element ) ++ count ;		      		  count += 1					    		count += 1					  
  return count ;					      	  return count						    	return count						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA
--							      --							    --								  --
static String lexsmallest ( String a [ ] , int n ) {	      def lexSmallest ( a , n ) :				    def lexsmallest ( a , n ) :					  script_not_found : None
  sort ( a , n ) ;					      	  a.sort ( reverse = True )				    	a.sort ( n )						  
  String answer = "" ;					      	  answer = ""						    	answer = ""						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      answer += a [ i ]					    	    answer += a [ i ]					  
  i ++ ) answer += a [ i ] ;				      	  return answer						    	return answer						  
  return answer ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	      MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	    MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	  MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N
--							      --							    --								  --
static int minSum ( int n ) {				      def minSum ( n ) :					    def min_sum ( n ) :						  success : None
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  while ( n > 0 ) {					      	  while ( n > 0 ) :					    	while n > 0 :						  
    sum += ( n % 10 ) ;					      	      sum += ( n % 10 )					    	    sum += ( n % 10 )					  
    n /= 10 ;						      	      n //= 10						    	    n //= 10						  
  }							      	  if ( sum == 1 ) :					    	if sum == 1 :						  
  if ( sum == 1 ) return 10 ;				      	      return 10						    	    return 10						  
  return sum ;						      	  return sum						    	return sum						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		      FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		    FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		  FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO
--							      --							    --								  --
static int fib ( int n ) {				      def fib ( n ) :						    def fib ( n ) :						  script_not_found : None
  if ( n < 6 ) return f [ n ] ;				      	  if n < 6 :						    	if n < 6 :						  
  int t = 5 ;						      	      return f [ n ]					    	    return f [ n ]					  
  int fn = 5 ;						      	  t = 5							    	t = 5							  
  while ( t < n ) {					      	  fn = 5						    	fn = 5							  
    fn = ( int ) Math . round ( fn * PHI ) ;		      	  while t < n :						    	while t < n :						  
    t ++ ;						      	      fn = round ( fn * PHI )				    	    fn = int ( round ( fn * PHI ) )			  
  }							      	      t += 1						    	    t += 1						  
  return fn ;						      	  return fn						    	return fn						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE     CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE	    CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE	  CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE
--							      --							    --								  --
static boolean check ( int degree [ ] , int n ) {	      def check ( degree , n ) :				    def check ( degree , n ) :					  success : None
  int deg_sum = 0 ;					      	  deg_sum = sum ( degree )				    	deg_sum = 0						  
  for ( int i = 0 ;					      	  if ( 2 * ( n - 1 ) == deg_sum ) :			    	for i in range ( n ) :					  
  i < n ;						      	      return True					    	    deg_sum += degree [ i ]				  
  i ++ ) {						      	  else :						    	return ( 2 * ( n - 1 ) == deg_sum )			  
    deg_sum += degree [ i ] ;				      	      return False					    								  
  }							      								    								  
  return ( 2 * ( n - 1 ) == deg_sum ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS   EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS   EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS	  EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS
--							      --							    --								  --
static boolean squareRootExists ( int n , int p ) {	      def squareRootExists ( n , p ) :				    def square_root_exists ( n , p ) :				  success : None
  n = n % p ;						      	  n = n % p						    	n = n % p						  
  for ( int x = 2 ;					      	  for x in range ( 2 , p , 1 ) :			    	for x in range ( 2 , p ) :				  
  x < p ;						      	      if ( ( x * x ) % p == n ) :			    	    if ( x * x ) % p == n :				  
  x ++ ) if ( ( x * x ) % p == n ) return true ;	      		  return True					    		return True					  
  return false ;					      	  return False						    	return False						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		      COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		    COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		  COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX
--							      --							    --								  --
static int count ( int n , int x ) {			      def count ( n , x ) :					    def count ( n , x ) :					  success : None
  int count = 0 ;					      	  cnt = 0						    	count = 0						  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= n && i <= x ;					      	      if i <= x :					    	    if x // i <= n and x % i == 0 :			  
  i ++ ) {						      		  if x // i <= n and x % i == 0 :		    		count += 1					  
    if ( x / i <= n && x % i == 0 ) count ++ ;		      		      cnt += 1					    	return count						  
  }							      	  return cnt						    								  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1     SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1	    SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1	  SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1
--							      --							    --								  --
static int smallest ( int x , int y , int z ) {		      def smallest ( x , y , z ) :				    def smallest ( x , y , z ) :				  failure : #Results: 0, 10
  if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ;   	  if ( not ( y / x ) ) :				    	if ( y / x ) != 1 :					  
  return ( ( x / z ) != 1 ) ? x : z ;			      	      return y if ( not ( y / z ) ) else z		    	    return ( y if ( y / z ) != 1 else z )		  
}							      	  return x if ( not ( x / z ) ) else z			    	return ( x if ( x / z ) != 1 else z )			  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		      DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		    DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		  DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT
--							      --							    --								  --
static int binomialCoeff ( int n , int k ) {		      def binomialCoeff ( n , k ) :				    def binomial_coeff ( n , k ) :				  script_not_found : None
  if ( k == 0 || k == n ) return 1 ;			      	  if k == 0 or k == n :					    	if not k or k == n :					  
  return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n  	      return 1						    	    return 1						  
}							      	  return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff (  	return binomial_coeff ( n - 1 , k - 1 ) + binomial_coeff  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS		      SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS			    SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS			  SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS
--							      --							    --								  --
static int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) def sumBetweenTwoKth ( arr , n , k1 , k2 ) :		    def sum_between_two_th ( arr , k1 , k2 ) :			  script_not_found : None
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  int result = 0 ;					      	  result = 0						    	result = 0						  
  for ( int i = k1 ;					      	  for i in range ( k1 , k2 - 1 ) :			    	for i in range ( k1 , k2 - 1 ) :			  
  i < k2 - 1 ;						      	      result += arr [ i ]				    	    result += arr [ i ]					  
  i ++ ) result += arr [ i ] ;				      	  return result						    	return result						  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION_2			      PROGRAM_DECIMAL_BINARY_CONVERSION_2			    PROGRAM_DECIMAL_BINARY_CONVERSION_2				  PROGRAM_DECIMAL_BINARY_CONVERSION_2
--							      --							    --								  --
static int decimalToBinary ( int N ) {			      def decimalToBinary ( N ) :				    def decimal_to_binary ( N ) :				  success : None
  int B_Number = 0 ;					      	  B_Number = 0						    	B_number = 0						  
  int cnt = 0 ;						      	  cnt = 0						    	cnt = 0							  
  while ( N != 0 ) {					      	  while ( N != 0 ) :					    	while N != 0 :						  
    int rem = N % 2 ;					      	      rem = N % 2					    	    rem = N % 2						  
    double c = Math . pow ( 10 , cnt ) ;		      	      c = pow ( 10 , cnt )				    	    c = pow ( 10 , cnt )				  
    B_Number += rem * c ;				      	      B_Number += rem * c				    	    B_number += rem * c					  
    N /= 2 ;						      	      N //= 2						    	    N //= 2						  
    cnt ++ ;						      	      cnt += 1						    	    cnt += 1						  
  }							      	  return B_Number					    	return B_number						  
  return B_Number ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHANGE_BITS_CAN_MADE_ONE_FLIP_1				      CHANGE_BITS_CAN_MADE_ONE_FLIP_1				    CHANGE_BITS_CAN_MADE_ONE_FLIP_1				  CHANGE_BITS_CAN_MADE_ONE_FLIP_1
--							      --							    --								  --
static boolean isOneFlip ( String str ) {		      def isOneFlip ( str ) :					    def is_one_flip ( data ) :					  script_not_found : None
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( data )					  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for c in data :						  
  i < n ;						      	      sum += int ( str [ i ] ) - int ( '0' )		    	    sum += ord ( c ) - ord ( '0' )			  
  i ++ ) sum += str . charAt ( i ) - '0' ;		      	  return ( sum == n - 1 or sum == 1 )			    	return ( sum == n - 1 or sum == 1 )			  
  return ( sum == n - 1 || sum == 1 ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2
--							      --							    --								  --
static void recursiveReverse ( char [ ] str , int i ) {	      def recursiveReverse ( str , i = 0 ) :			    def recursive_reverse ( str , i ) :				  script_not_found : None
  int n = str . length ;				      	  n = len ( str )					    	n = len ( str )						  
  if ( i == n / 2 ) return ;				      	  if i == n // 2 :					    	if i == n // 2 :					  
  swap ( str , i , n - i - 1 ) ;			      	      return						    	    return						  
  recursiveReverse ( str , i + 1 ) ;			      	  str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ 	swap ( str , i , n - i - 1 )				  
}							      	  recursiveReverse ( str , i + 1 )			    	recursive_reverse ( str , i + 1 )			  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	      TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	    TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	  TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1
--							      --							    --								  --
static long countNonDecreasing ( int n ) {		      def countNonDecreasing ( n ) :				    def count_non_decreasing ( n ) :				  success : None
  int N = 10 ;						      	  N = 10						    	N = 10							  
  long count = 1 ;					      	  count = 1						    	count = 1						  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	      count = int ( count * ( N + i - 1 ) )		    	    count *= ( N + i - 1 )				  
  i ++ ) {						      	      count = int ( count / i )				    	    count //= i						  
    count *= ( N + i - 1 ) ;				      	  return count						    	return count						  
    count /= i ;					      								    								  
  }							      								    								  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_STRING_ROTATION_PALINDROME			      CHECK_GIVEN_STRING_ROTATION_PALINDROME			    CHECK_GIVEN_STRING_ROTATION_PALINDROME			  CHECK_GIVEN_STRING_ROTATION_PALINDROME
--							      --							    --								  --
static boolean isPalindrome ( String str ) {		      def isPalindrome ( string ) :				    def is_palindrome ( str ) :					  timeout : None
  int l = 0 ;						      	  l = 0							    	l = 0							  
  int h = str . length ( ) - 1 ;			      	  h = len ( string ) - 1				    	h = len ( str ) - 1					  
  while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt  	  while h > l :						    	while h > l :						  
  return true ;						      	      l += 1						    	    if str [ l ] != str [ h ] :				  
}							      	      h -= 1						    		h -= 1						  
							      	      if string [ l - 1 ] != string [ h + 1 ] :		    	return False						  
							      		  return False					    								  
							      	  return True						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1     GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1	    GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1	  GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1
--							      --							    --								  --
int countSubStr ( char str [ ] , int n ) {		      def countSubStr ( st , n ) :				    def count_sub_str ( str , n ) :				  script_not_found : None
  int m = 0 ;						      	  m = 0							    	m = 0							  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( st [ i ] == '1' ) :				    	    if str [ i ] == '1' :				  
  i ++ ) {						      		  m = m + 1					    		m += 1						  
    if ( str [ i ] == '1' ) m ++ ;			      	  return m * ( m - 1 ) // 2				    	return m * ( m - 1 ) / 2				  
  }							      								    								  
  return m * ( m - 1 ) / 2 ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2   SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2   SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2	  SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2
--							      --							    --								  --
static int findSum ( int n ) {				      def findSum ( n ) :					    def find_sum ( n ) :					  success : None
  n -- ;						      	  n -= 1						    	n -= 1							  
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  sum += ( n * ( n + 1 ) ) / 2 ;			      	  sum += ( n * ( n + 1 ) ) / 2				    	sum += ( n * ( n + 1 ) ) / 2				  
  sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;	      	  sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6		    	sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6		  
  return sum ;						      	  return int ( sum )					    	return sum						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION_1			      PROGRAM_DECIMAL_BINARY_CONVERSION_1			    PROGRAM_DECIMAL_BINARY_CONVERSION_1				  PROGRAM_DECIMAL_BINARY_CONVERSION_1
--							      --							    --								  --
public void decToBinary ( int n ) {			      def decToBinary ( n ) :					    def dec_to_binary ( n ) :					  script_not_found : None
  for ( int i = 31 ;					      	  for i in range ( 31 , - 1 , - 1 ) :			    	for i in range ( 31 , - 1 , - 1 ) :			  
  i >= 0 ;						      	      k = n >> i					    	    k = n >> i						  
  i -- ) {						      	      if ( k & 1 ) :					    	    if ( k & 1 ) > 0 :					  
    int k = n >> i ;					      		  print ( "1" , end = "" )			    		print ( '1' , end = ' ' )			  
    if ( ( k & 1 ) > 0 ) System . out . print ( "1" ) ;	      	      else :						    	    else :						  
    else System . out . print ( "0" ) ;			      		  print ( "0" , end = "" )			    		print ( '0' , end = ' ' )			  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING		      QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING		    QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING			  QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING
--							      --							    --								  --
static void query ( String s , int i , int j ) {	      def query ( s , i , j ) :					    def query ( s , i , j ) :					  script_not_found : None
  int n = s . length ( ) ;				      	  n = len ( s )						    	n = len ( s )						  
  i %= n ;						      	  i %= n						    	i %= n							  
  j %= n ;						      	  j %= n						    	j %= n							  
  if ( s . charAt ( i ) == s . charAt ( j ) ) System . out .  	  print ( "Yes" ) if s [ i ] == s [ j ] else print ( "No" ) 	if s [ i ] == s [ j ] :					  
  else System . out . println ( "No" ) ;		      								    	    print ( "Yes" )					  
}							      								    	else :							  
							      								    	    print ( "No" )					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_9_USING_BITWISE_OPERATORS			      DIVISIBILITY_9_USING_BITWISE_OPERATORS			    DIVISIBILITY_9_USING_BITWISE_OPERATORS			  DIVISIBILITY_9_USING_BITWISE_OPERATORS
--							      --							    --								  --
static boolean isDivBy9 ( int n ) {			      def isDivBy9 ( n ) :					    def is_div_by_9 ( n ) :					  failure : #Results: 1, 10
  if ( n == 0 || n == 9 ) return true ;			      	  if ( n == 0 or n == 9 ) :				    	if not n or n == 9 :					  
  if ( n < 9 ) return false ;				      	      return True					    	    return True						  
  return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )  	  if ( n < 9 ) :					    	if n < 9 :						  
}							      	      return False					    	    return False					  
							      	  return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 )  	return bool ( int ( n >> 3 ) - int ( n & 7 ) )		  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTING_INVERSIONS					      COUNTING_INVERSIONS					    COUNTING_INVERSIONS						  COUNTING_INVERSIONS
--							      --							    --								  --
static int getInvCount ( int n ) {			      def getInvCount ( arr , n ) :				    def get_inv_count ( n ) :					  script_not_found : None
  int inv_count = 0 ;					      	  inv_count = 0						    	inv_count = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) for ( int j = i + 1 ;				      		  if ( arr [ i ] > arr [ j ] ) :		    		if arr [ i ] > arr [ j ] :			  
  j < n ;						      		      inv_count += 1				    		    inv_count += 1				  
  j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ;	      	  return inv_count					    	return inv_count					  
  return inv_count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_DIVISIBILITY_BINARY_STRING_2K			      CHECK_DIVISIBILITY_BINARY_STRING_2K			    CHECK_DIVISIBILITY_BINARY_STRING_2K				  CHECK_DIVISIBILITY_BINARY_STRING_2K
--							      --							    --								  --
static boolean isDivisible ( String str , int k ) {	      def isDivisible ( str , k ) :				    def is_divisible ( str , k ) :				  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  int c = 0 ;						      	  c = 0							    	c = 0							  
  for ( int i = 0 ;					      	  for i in range ( 0 , k ) :				    	for i in range ( k ) :					  
  i < k ;						      	      if ( str [ n - i - 1 ] == '0' ) :			    	    if str [ n - i - 1 ] == '0' :			  
  i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ;      		  c += 1					    		c += 1						  
  return ( c == k ) ;					      	  return ( c == k )					    	return ( c == k )					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	      PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	    PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	  PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1
--							      --							    --								  --
static void printSquares ( int n ) {			      def printSquares ( n ) :					    def print_squares ( n ) :					  script_not_found : None
  int square = 0 , odd = 1 ;				      	  square = 0						    	square , odd = 0 , 1					  
  for ( int x = 0 ;					      	  odd = 1						    	for x in range ( n ) :					  
  x < n ;						      	  for x in range ( 0 , n ) :				    	    print ( square , end = ' ' )			  
  x ++ ) {						      	      print ( square , end = " " )			    	    square = square + odd				  
    System . out . print ( square + " " ) ;		      	      square = square + odd				    	    odd = odd + 2					  
    square = square + odd ;				      	      odd = odd + 2					    								  
    odd = odd + 2 ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM	      RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM		    RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM		  RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM
--							      --							    --								  --
static int breakSum ( int n ) {				      def breakSum ( n ) :					    def break_sum ( n ) :					  success : None
  if ( n == 0 || n == 1 ) return n ;			      	  if ( n == 0 or n == 1 ) :				    	if not n or n == 1 :					  
  return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 	      return n						    	    return n						  
}							      	  return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 )  	return max ( ( break_sum ( n // 2 ) + break_sum ( n // 3  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_ROTATIONS_REQUIRED_GET_STRING			      MINIMUM_ROTATIONS_REQUIRED_GET_STRING			    MINIMUM_ROTATIONS_REQUIRED_GET_STRING			  MINIMUM_ROTATIONS_REQUIRED_GET_STRING
--							      --							    --								  --
static int findRotations ( String str ) {		      def findRotations ( str ) :				    def find_rotations ( str ) :				  success : None
  String tmp = str + str ;				      	  tmp = str + str					    	tmp = str + str						  
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	      substring = tmp [ i : n ]				    	    substring = tmp [ i : len ( str ) ]			  
  i ++ ) {						      	      if ( str == substring ) :				    	    if str == substring :				  
    String substring = tmp . substring ( i , str . length ( ) 		  return i					    		return i					  
    if ( str == substring ) return i ;			      	  return n						    	return n						  
  }							      								    								  
  return n ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_1				      DYNAMIC_PROGRAMMING_SET_1					    DYNAMIC_PROGRAMMING_SET_1					  DYNAMIC_PROGRAMMING_SET_1
--							      --							    --								  --
int fib ( int n ) {					      def fib ( n , lookup ) :					    def fib ( n ) :						  script_not_found : None
  if ( lookup [ n ] == NIL ) {				      	  if n == 0 or n == 1 :					    	if not lookup [ n ] :					  
    if ( n <= 1 ) lookup [ n ] = n ;			      	      lookup [ n ] = n					    	    if n <= 1 :						  
    else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ;	      	  if lookup [ n ] is None :				    		lookup [ n ] = n				  
  }							      	      lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , 	    else :						  
  return lookup [ n ] ;					      	  return lookup [ n ]					    		lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 )	  
}							      								    	return lookup [ n ]					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE	      SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE		    SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE		  SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE
--							      --							    --								  --
static int selectRandom ( int x ) {			      def selectRandom ( x ) :					    def select_random ( x ) :					  error : Traceback (most recent call last):   File
  count ++ ;						      	  res = 0						    	global count						  "dump/transcoder_st/eval/java_python/online_st/206
  if ( count == 1 ) res = x ;				      	  count = 0						    	count += 1						  68770/eval_scripts/java_sa-python_sa.test/SELECT_A
  else {						      	  count += 1						    	if count == 1 :						  _RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE.py", line
    Random r = new Random ( ) ;				      	  if ( count == 1 ) :					    	    res = x						   58, in <module>     if f_filled(*parameters_set)
    int i = r . nextInt ( count ) ;			      	      res = x						    	else :							  == f_gold(*parameters_set):	File "dump/transcode
    if ( i == count - 1 ) res = x ;			      	  else :						    	    r = random.Random ( )				  r_st/eval/java_python/online_st/20668770/eval_scri
  }							      	      i = random.randrange ( count )			    	    i = r.randrange ( count )				  pts/java_sa-python_sa.test/SELECT_A_RANDOM_NUMBER_
  return res ;						      	      if ( i == count - 1 ) :				    	    if i == count - 1 :					  FROM_STREAM_WITH_O1_SPACE.py", line 32, in f_fille
}							      		  res = x					    		res = x						  d	count += 1 NameError: name 'count' is not de
							      	  return res						    	return res						  fined
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_INTEGER_OVERFLOW_MULTIPLICATION			      CHECK_INTEGER_OVERFLOW_MULTIPLICATION			    CHECK_INTEGER_OVERFLOW_MULTIPLICATION			  CHECK_INTEGER_OVERFLOW_MULTIPLICATION
--							      --							    --								  --
static Boolean isOverflow ( long a , long b ) {		      def isOverflow ( a , b ) :				    def is_overflow ( a , b ) :					  failure : 37 999999999 39 92 14 19 14 88 #Results:
  if ( a == 0 || b == 0 ) return false ;		      	  if ( a == 0 or b == 0 ) :				    	if not a or not b :					   8, 10
  long result = a * b ;					      	      return False					    	    return False					  
  if ( a == result / b ) return false ;			      	  result = a * b					    	result = a * b						  
  else return true ;					      	  if ( result >= 9223372036854775807 or result <= - 9223372 	if a == result // b :					  
}							      	      result = 0					    	    return False					  
							      	  if ( a == ( result // b ) ) :				    	else :							  
							      	      print ( result // b )				    	    return True						  
							      	      return False					    								  
							      	  else :						    								  
							      	      return True					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2		      N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2			    N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2			  N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2
--							      --							    --								  --
public static int findNth ( int n ) {			      def findNth ( n ) :					    def find_nth ( n ) :					  success : None
  int nthElement = 19 + ( n - 1 ) * 9 ;			      	  nthElement = 19 + ( n - 1 ) * 9			    	nth_element = 19 + ( n - 1 ) * 9			  
  int outliersCount = ( int ) Math . log10 ( nthElement ) - 1 	  outliersCount = int ( math.log10 ( nthElement ) ) - 1	    	outliers_count = int ( math.log10 ( nth_element ) ) - 1	  
  nthElement += 9 * outliersCount ;			      	  nthElement += 9 * outliersCount			    	nth_element += 9 * outliers_count			  
  return nthElement ;					      	  return nthElement					    	return nth_element					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		      PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		    PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		  PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11
--							      --							    --								  --
static int remainder ( String str ) {			      def remainder ( st ) :					    def remainder ( data ) :					  script_not_found : None
  int len = str . length ( ) ;				      	  ln = len ( st )					    	data = list ( data )					  
  int num , rem = 0 ;					      	  rem = 0						    	num , rem = 0 , 0					  
  for ( int i = 0 ;					      	  for i in range ( 0 , ln ) :				    	for c in data :						  
  i < len ;						      	      num = rem * 10 + ( int ) ( st [ i ] )		    	    num = rem * 10 + ( ord ( c ) - ord ( '0' ) )	  
  i ++ ) {						      	      rem = num % 11					    	    rem = num % 11					  
    num = rem * 10 + ( str . charAt ( i ) - '0' ) ;	      	  return rem						    	return rem						  
    rem = num % 11 ;					      								    								  
  }							      								    								  
  return rem ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ARC_LENGTH_ANGLE					      ARC_LENGTH_ANGLE						    ARC_LENGTH_ANGLE						  ARC_LENGTH_ANGLE
--							      --							    --								  --
static double arcLength ( double diameter , double angle ) {  def arcLength ( diameter , angle ) :			    def arcLength ( diameter , angle ) :			  script_not_found : None
  double pi = 22.0 / 7.0 ;				      	  if angle >= 360 :					    	pi = 22.0 / 7.0						  
  double arc ;						      	      print ( "Angle cannot be formed" )		    	if angle >= 360 :					  
  if ( angle >= 360 ) {					      	      return 0						    	    print ( "Angle cannot" , "be formed" )		  
    System . out . println ( "Angle cannot" + " be formed" )  	  else :						    	    return 0						  
    return 0 ;						      	      arc = ( 3.142857142857143 * diameter ) * ( angle / 36 	else :							  
  }							      	      return arc					    	    arc = ( pi * diameter ) * ( angle / 360.0 )		  
  else {						      								    	    return arc						  
    arc = ( pi * diameter ) * ( angle / 360.0 ) ;	      								    								  
    return arc ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	      NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	    NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	  NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES
--							      --							    --								  --
static int countRect ( int n ) {			      def countRect ( n ) :					    def count_rect ( n ) :					  error : Traceback (most recent call last):   File
  int ans = 0 ;						      	  ans = 0						    	ans = 0							  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int length = 1 ;				      	  for length in range ( 1 , int ( math.sqrt ( n ) ) + 1 ) : 	for length in range ( 1 , math.sqrt ( n ) + 1 ) :	  68770/eval_scripts/java_sa-python_sa.test/NUMBER_U
  length <= Math . sqrt ( n ) ;				      	      height = length					    	    for height in range ( length , n + 1 ) :		  NIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES.py",
  ++ length ) for ( int height = length ;		      	      while ( height * length <= n ) :			    		ans += 1					  line 52, in <module>	   if f_filled(*parameters_s
  height * length <= n ;				      		  ans += 1					    	return ans						  et) == f_gold(*parameters_set):   File "dump/trans
  ++ height ) ans ++ ;					      		  height += 1					    								  coder_st/eval/java_python/online_st/20668770/eval_
  return ans ;						      	  return ans						    								  scripts/java_sa-python_sa.test/NUMBER_UNIQUE_RECTA
}							      								    								  NGLES_FORMED_USING_N_UNIT_SQUARES.py", line 31, in
							      								    								   f_filled	for length in range ( 1 , math.sqrt
							      								    								  ( n ) + 1 ) : TypeError: 'float' object cannot be
							      								    								  interpreted as an integer
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	      FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	    FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	  FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X
--							      --							    --								  --
static int firstFactorialDivisibleNumber ( int x ) {	      def firstFactorialDivisibleNumber ( x ) :			    def first_factorial_divisible_number ( x ) :		  success : None
  int i = 1 ;						      	  i = 1							    	i = 1							  
  int fact = 1 ;					      	  fact = 1						    	fact = 1						  
  for ( i = 1 ;						      	  for i in range ( 1 , x ) :				    	for i in range ( 1 , x ) :				  
  i < x ;						      	      fact = fact * i					    	    fact = fact * i					  
  i ++ ) {						      	      if ( fact % x == 0 ) :				    	    if fact % x == 0 :					  
    fact = fact * i ;					      		  break						    		break						  
    if ( fact % x == 0 ) break ;			      	  return i						    	return i						  
  }							      								    								  
  return i ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			      PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			    PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			  PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS
--							      --							    --								  --
static double gcd ( double a , double b ) {		      def gcd ( a , b ) :					    def gcd ( a , b ) :						  script_not_found : None
  if ( a < b ) return gcd ( b , a ) ;			      	  if ( a < b ) :					    	if a < b :						  
  if ( Math . abs ( b ) < 0.001 ) return a ;		      	      return gcd ( b , a )				    	    return math.gcd ( b , a )				  
  else return ( gcd ( b , a - Math . floor ( a / b ) * b ) )  	  if ( abs ( b ) < 0.001 ) :				    	if abs ( b ) < 0.001 :					  
}							      	      return a						    	    return a						  
							      	  else :						    	else :							  
							      	      return ( gcd ( b , a - math.floor ( a / b ) * b ) )   	    return ( math.gcd ( b , a - math.floor ( a / b ) * b  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_PROGRAM_PRIME_NUMBER				      RECURSIVE_PROGRAM_PRIME_NUMBER				    RECURSIVE_PROGRAM_PRIME_NUMBER				  RECURSIVE_PROGRAM_PRIME_NUMBER
--							      --							    --								  --
static boolean isPrime ( int n , int i ) {		      def isPrime ( n , i = 2 ) :				    def is_prime ( n , i ) :					  script_not_found : None
  if ( n <= 2 ) return ( n == 2 ) ? true : false ;	      	  if ( n <= 2 ) :					    	if n <= 2 :						  
  if ( n % i == 0 ) return false ;			      	      return True if ( n == 2 ) else False		    	    return ( True if n == 2 else False )		  
  if ( i * i > n ) return true ;			      	  if ( n % i == 0 ) :					    	if n % i == 0 :						  
  return isPrime ( n , i + 1 ) ;			      	      return False					    	    return False					  
}							      	  if ( i * i > n ) :					    	if i * i > n :						  
							      	      return true					    	    return True						  
							      	  return isPrime ( n , i + 1 )				    	return is_prime ( n , i + 1 )				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			      COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			    COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			  COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY
--							      --							    --								  --
static int countPairs ( int arr [ ] , int n ) {		      def countPairs ( arr , n ) :				    def count_pairs ( arr , n ) :				  success : None
  int ans = 0 ;						      	  ans = 0						    	ans = 0							  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) for ( int j = i + 1 ;				      		  if ( arr [ i ] == arr [ j ] ) :		    		if arr [ i ] == arr [ j ] :			  
  j < n ;						      		      ans += 1					    		    ans += 1					  
  j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ;		      	  return ans						    	return ans						  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE	      QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE		    QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE		  QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE
--							      --							    --								  --
static int countInRange ( int arr [ ] , int n , int x , int y def countInRange ( arr , n , x , y ) :			    def count_in_range ( arr , n , x , y ) :			  success : None
  int count = 0 ;					      	  count = 0 ;						    	count = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( arr [ i ] >= x and arr [ i ] <= y ) :	    	    if arr [ i ] >= x and arr [ i ] <= y :		  
  i ++ ) {						      		  count += 1					    		count += 1					  
    if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ;	      	  return count						    	return count						  
  }							      								    								  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC		      PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC			    PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC			  PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC
--							      --							    --								  --
static boolean isSymmetric ( int mat [ ] [ ] , int N ) {      def isSymmetric ( mat , N ) :				    def isSymmetric ( mat , N ) :				  success : None
  for ( int i = 0 ;					      	  for i in range ( N ) :				    	for i in range ( N ) :					  
  i < N ;						      	      for j in range ( N ) :				    	    for j in range ( N ) :				  
  i ++ ) for ( int j = 0 ;				      		  if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) :	    		if mat [ i ] [ j ] != mat [ j ] [ i ] :		  
  j < N ;						      		      return False				    		    return False				  
  j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return fal 	  return True						    	return True						  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	      ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	    ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	  ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX
--							      --							    --								  --
static int countCommon ( int mat [ ] [ ] , int n ) {	      def countCommon ( mat , n ) :				    def count_common ( mat , n ) :				  failure : #Results: 6, 10
  int res = 0 ;						      	  res = 0						    	res = 0							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] :	    	    if mat [ i ] == mat [ i ] [ n - i - 1 ] :		  
  i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) re 		  res = res + 1					    		res += 1					  
  return res ;						      	  return res						    	return res						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1
--							      --							    --								  --
static char first ( String str , int i ) {		      def first ( str , i ) :					    def first ( str , i ) :					  script_not_found : None
  if ( str . charAt ( i ) == '\0' ) return 0 ;		      	  if ( str [ i ] == '\0' ) :				    	if not str [ i ] :					  
  if ( Character . isUpperCase ( str . charAt ( i ) ) ) retur 	      return 0						    	    return 0						  
  return first ( str , i + 1 ) ;			      	  if ( str [ i ].isupper ( ) ) :			    	if str [ i ].isupper ( ) :				  
}							      	      return str [ i ]					    	    return str [ i ]					  
							      	  return first ( str , i + 1 )				    	return first ( str , i + 1 )				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			      FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			    FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			  FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2
--							      --							    --								  --
static int singleNumber ( int a [ ] , int n ) {		      def singleNumber ( nums ) :				    def single_number ( a , n ) :				  script_not_found : None
  HashSet < Integer > s = new HashSet < Integer > ( ) ;	      	  return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2    	s = set ( )						  
  for ( int i : a ) {					      								    	for i in a :						  
    s . add ( i ) ;					      								    	    s.add ( i )						  
  }							      								    	arr_sum = 0						  
  int arr_sum = 0 ;					      								    	for i in a :						  
  for ( int i : a ) {					      								    	    arr_sum += i					  
    arr_sum += i ;					      								    	set_sum = 0						  
  }							      								    	for i in s :						  
  int set_sum = 0 ;					      								    	    set_sum += i					  
  for ( int i : s ) {					      								    	return ( 3 * set_sum - arr_sum ) / 2			  
    set_sum += i ;					      								    								  
  }							      								    								  
  return ( 3 * set_sum - arr_sum ) / 2 ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS_1					      SUM_PAIRWISE_PRODUCTS_1					    SUM_PAIRWISE_PRODUCTS_1					  SUM_PAIRWISE_PRODUCTS_1
--							      --							    --								  --
static int findSum ( int n ) {				      def findSum ( n ) :					    def find_sum ( n ) :					  success : None
  int multiTerms = n * ( n + 1 ) / 2 ;			      	  multiTerms = n * ( n + 1 ) // 2			    	multi_terms = n * ( n + 1 ) // 2			  
  int sum = multiTerms ;				      	  sm = multiTerms					    	sum = multi_terms					  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	      multiTerms = multiTerms - ( i - 1 )		    	    multi_terms = multi_terms - ( i - 1 )		  
  i ++ ) {						      	      sm = sm + multiTerms * i				    	    sum = sum + multi_terms * i				  
    multiTerms = multiTerms - ( i - 1 ) ;		      	  return sm						    	return sum						  
    sum = sum + multiTerms * i ;			      								    								  
  }							      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1   DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1   DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1	  DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1
--							      --							    --								  --
static int maxProd ( int n ) {				      def maxProd ( n ) :					    def max_prod ( n ) :					  success : None
  if ( n == 2 || n == 3 ) return ( n - 1 ) ;		      	  if ( n == 2 or n == 3 ) :				    	if n == 2 or n == 3 :					  
  int res = 1 ;						      	      return ( n - 1 )					    	    return ( n - 1 )					  
  while ( n > 4 ) {					      	  res = 1						    	res = 1							  
    n -= 3 ;						      	  while ( n > 4 ) :					    	while n > 4 :						  
    res *= 3 ;						      	      n -= 3						    	    n -= 3						  
  }							      	      res *= 3						    	    res *= 3						  
  return ( n * res ) ;					      	  return ( n * res )					    	return ( n * res )					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_OCTAL_DECIMAL_CONVERSION			      PROGRAM_OCTAL_DECIMAL_CONVERSION				    PROGRAM_OCTAL_DECIMAL_CONVERSION				  PROGRAM_OCTAL_DECIMAL_CONVERSION
--							      --							    --								  --
static int octalToDecimal ( int n ) {			      def octalToDecimal ( n ) :				    def octal_to_decimal ( n ) :				  success : None
  int num = n ;						      	  num = n						    	num = n							  
  int dec_value = 0 ;					      	  dec_value = 0						    	dec_value = 0						  
  int base = 1 ;					      	  base = 1						    	base = 1						  
  int temp = num ;					      	  temp = num						    	temp = num						  
  while ( temp > 0 ) {					      	  while ( temp ) :					    	while temp > 0 :					  
    int last_digit = temp % 10 ;			      	      last_digit = temp % 10				    	    last_digit = temp % 10				  
    temp = temp / 10 ;					      	      temp = int ( temp / 10 )				    	    temp = temp // 10					  
    dec_value += last_digit * base ;			      	      dec_value += last_digit * base			    	    dec_value += last_digit * base			  
    base = base * 8 ;					      	      base = base * 8					    	    base = base * 8					  
  }							      	  return dec_value					    	return dec_value					  
  return dec_value ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			      MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			    MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			  MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS
--							      --							    --								  --
static int minTime ( int [ ] arr , int n , int m ) {	      def minTime ( arr , n , m ) :				    def min_time ( arr , n , m ) :				  script_not_found : None
  int t = 0 ;						      	  t = 0							    	t = 0							  
  while ( true ) {					      	  while ( 1 ) :						    	while True :						  
    int items = 0 ;					      	      items = 0						    	    items = 0						  
    for ( int i = 0 ;					      	      for i in range ( n ) :				    	    for i in range ( n ) :				  
    i < n ;						      		  items += ( t // arr [ i ] )			    		items += ( t // arr [ i ] )			  
    i ++ ) items += ( t / arr [ i ] ) ;			      	      if ( items >= m ) :				    	    if items >= m :					  
    if ( items >= m ) return t ;			      		  return t					    		return t					  
    t ++ ;						      	      t += 1						    	    t += 1						  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING	      PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING	    PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING		  PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING
--							      --							    --								  --
static void printSquares ( int n ) {			      def printSquares ( n ) :					    def print_squares ( n ) :					  script_not_found : None
  int square = 0 , prev_x = 0 ;				      	  square = 0 ; prev_x = 0 ;				    	square , prev_x = 0 , 0					  
  for ( int x = 0 ;					      	  for x in range ( 0 , n ) :				    	for x in range ( n ) :					  
  x < n ;						      	      square = ( square + x + prev_x )			    	    square = ( square + x + prev_x )			  
  x ++ ) {						      	      print ( square , end = " " )			    	    print ( square , end = ' ' )			  
    square = ( square + x + prev_x ) ;			      	      prev_x = x					    	    prev_x = x						  
    System . out . print ( square + " " ) ;		      								    								  
    prev_x = x ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_STRING_START_END_GEEKS			      PROGRAM_FIND_STRING_START_END_GEEKS			    PROGRAM_FIND_STRING_START_END_GEEKS				  PROGRAM_FIND_STRING_START_END_GEEKS
--							      --							    --								  --
static boolean isCornerPresent ( String str , String corner ) def isCornerPresent ( str , corner ) :			    def is_corner_present ( data , corner ) :			  success : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( data )					  
  int cl = corner . length ( ) ;			      	  cl = len ( corner )					    	cl = len ( corner )					  
  if ( n < cl ) return false ;				      	  if ( n < cl ) :					    	if n < cl :						  
  return ( str . substring ( 0 , cl ) . equals ( corner ) &&  	      return False					    	    return False					  
}							      	  return ( ( str [ : cl ] == corner ) and ( str [ n - cl :  	return ( data [ : cl ] == corner and data [ n - cl : n ]  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_ADDITION_TWO_MATRICES				      C_PROGRAM_ADDITION_TWO_MATRICES				    C_PROGRAM_ADDITION_TWO_MATRICES				  C_PROGRAM_ADDITION_TWO_MATRICES
--							      --							    --								  --
static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ def add ( A , B , C ) :					    def add ( A , B , C ) :					  script_not_found : None
  int i , j ;						      	  for i in range ( N ) :				    	global N						  
  for ( i = 0 ;						      	      for j in range ( N ) :				    	for i in range ( N ) :					  
  i < N ;						      		  C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ]	    	    for j in range ( N ) :				  
  i ++ ) for ( j = 0 ;					      								    		C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ]	  
  j < N ;						      								    								  
  j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3		      COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3		    COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3			  COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3
--							      --							    --								  --
public static int findStep ( int n ) {			      def findStep ( n ) :					    def find_step ( n ) :					  script_not_found : None
  if ( n == 1 || n == 0 ) return 1 ;			      	  if ( n == 1 or n == 0 ) :				    	if n == 1 or n == 0 :					  
  else if ( n == 2 ) return 2 ;				      	      return 1						    	    return 1						  
  else return findStep ( n - 3 ) + findStep ( n - 2 ) + findS 	  elif ( n == 2 ) :					    	elif n == 2 :						  
}							      	      return 2						    	    return 2						  
							      	  else :						    	else :							  
							      	      return findStep ( n - 3 ) + findStep ( n - 2 ) + find 	    return find_step ( n - 3 ) + find_step ( n - 2 ) + fi 
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES			      POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES			    POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES				  POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES
--							      --							    --								  --
static boolean isPossibleTriangle ( int [ ] arr , int N ) {   def isPossibleTriangle ( arr , N ) :			    def is_possible_triangle ( arr , N ) :			  failure : #Results: 7, 10
  if ( N < 3 ) return false ;				      	  if N < 3 :						    	if N < 3 :						  
  Arrays . sort ( arr ) ;				      	      return False					    	    return False					  
  for ( int i = 0 ;					      	  arr.sort ( )						    	arr.sort ( )						  
  i < N - 2 ;						      	  for i in range ( N - 2 ) :				    	for i in range ( N - 2 ) :				  
  i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) ret 	      if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] :	    	    if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] :	  
  return false ;					      		  return True					    		return True					  
}							      								    	return False						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2		      MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2		    MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2			  MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2
--							      --							    --								  --
public static int middleOfThree ( int a , int b , int c ) {   def middleOfThree ( a , b , c ) :				    def middle_of_three ( a , b , c ) :				  failure : #Results: 4, 10
  int x = a - b ;					      	  x = a - b						    	x = a - b						  
  int y = b - c ;					      	  y = b - c						    	y = b - c						  
  int z = a - c ;					      	  z = a - c						    	z = a - c						  
  if ( x * y > 0 ) return b ;				      	  if x * y > 0 :					    	if x * y > 0 :						  
  else if ( x * z > 0 ) return c ;			      	      return b						    	    return b						  
  else return a ;					      	  elif ( x * z > 0 ) :					    	elif x * z > 0 :					  
}							      	      return						    	    return c						  
							      	  else :						    	else :							  
							      	      return a						    	    return a						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPETITIVE_ELEMENT_1_N_1_1				      FIND_REPETITIVE_ELEMENT_1_N_1_1				    FIND_REPETITIVE_ELEMENT_1_N_1_1				  FIND_REPETITIVE_ELEMENT_1_N_1_1
--							      --							    --								  --
static int findRepeating ( int arr [ ] , int n ) {	      def findRepeating ( arr , n ) :				    def find_repeating ( arr , n ) :				  script_not_found : None
  HashSet < Integer > s = new HashSet < Integer > ( ) ;	      	  s = set ( )						    	s = set ( )						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if arr [ i ] in s :				    	    if arr [ i ] in s :					  
  i ++ ) {						      		  return arr [ i ]				    		return arr [ i ]				  
    if ( s . contains ( arr [ i ] ) ) return arr [ i ] ;      	      s.add ( arr [ i ] )				    	    s.add ( arr [ i ] )					  
    s . add ( arr [ i ] ) ;				      	  rteurn - 1						    	return - 1						  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		      MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		    MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		  MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET
--							      --							    --								  --
static double minRevolutions ( double r , int x1 , int y1 , i def minRevolutions ( r , x1 , y1 , x2 , y2 ) :		    def min_revolutions ( r , x1 , y1 , x2 , y2 ) :		  script_not_found : None
  double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - 	  d = math.sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * 	d = math.sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 )	  
  return Math . ceil ( d / ( 2 * r ) ) ;		      	  return math.ceil ( d // ( 2 * r ) )			    	return math.ceil ( d / ( 2 * r ) )			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AREA_QUADRILATERAL				      MAXIMUM_AREA_QUADRILATERAL				    MAXIMUM_AREA_QUADRILATERAL					  MAXIMUM_AREA_QUADRILATERAL
--							      --							    --								  --
static double maxArea ( double a , double b , double c , doub def maxArea ( a , b , c , d ) :				    def max_area ( a , b , c , d ) :				  script_not_found : None
  double semiperimeter = ( a + b + c + d ) / 2 ;	      	  semiperimeter = ( a + b + c + d ) / 2			    	semiperimeter = ( a + b + c + d ) / 2			  
  return Math . sqrt ( ( semiperimeter - a ) * ( semiperimete 	  return math.sqrt ( ( semiperimeter - a ) * ( semiperimete 	return math.sqrt ( ( semiperimeter - a ) * ( semiperimete 
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON
--							      --							    --								  --
public static boolean checkcircle ( int r , int R , int r1 ,  def checkcircle ( r , R , r1 , x1 , y1 ) :		    def checkcircle ( r , R , r1 , x1 , y1 ) :			  success : identical to gold
  int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ;	      	  dis = int ( math.sqrt ( x1 * x1 + y1 * y1 ) )		    	dis = int ( math.sqrt ( x1 * x1 + y1 * y1 ) )		  
  return ( dis - r1 >= R && dis + r1 <= r ) ;		      	  return ( dis - r1 >= R and dis + r1 <= r )		    	return ( dis - r1 >= R and dis + r1 <= r )		  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX		      PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX		    PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX			  PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX
--							      --							    --								  --
static boolean isDiagonalMatrix ( int mat [ ] [ ] ) {	      def isDiagonalMatrix ( mat ) :				    def is_diagonal_matrix ( mat ) :				  script_not_found : None
  for ( int i = 0 ;					      	  for i in range ( 0 , N ) :				    	for i in range ( N ) :					  
  i < N ;						      	      for j in range ( 0 , N ) :			    	    for j in range ( N ) :				  
  i ++ ) for ( int j = 0 ;				      		  if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) :  		if ( i != j ) and ( mat [ i ] [ j ] != 0 ) :	  
  j < N ;						      		      return False				    		    return False				  
  j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return 	  return True						    	return True						  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	      MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	    MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	  MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED
--							      --							    --								  --
static int minValue ( int A [ ] , int B [ ] , int n ) {	      def minValue ( A , B , n ) :				    def min_value ( A , B , n ) :				  success : None
  Arrays . sort ( A ) ;					      	  sorted ( A )						    	A.sort ( )						  
  Arrays . sort ( B ) ;					      	  sorted ( B )						    	B.sort ( )						  
  int result = 0 ;					      	  result = 0						    	result = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      result += ( A [ i ] * B [ n - i - 1 ] )		    	    result += ( A [ i ] * B [ n - i - 1 ] )		  
  i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ;	      	  return result						    	return result						  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MODULUS_TWO_FLOAT_DOUBLE_NUMBERS			      MODULUS_TWO_FLOAT_DOUBLE_NUMBERS				    MODULUS_TWO_FLOAT_DOUBLE_NUMBERS				  MODULUS_TWO_FLOAT_DOUBLE_NUMBERS
--							      --							    --								  --
static double findMod ( double a , double b ) {		      def findMod ( a , b ) :					    def find_mod ( a , b ) :					  success : None
  if ( a < 0 ) a = - a ;				      	  if ( a < 0 ) :					    	if a < 0 :						  
  if ( b < 0 ) b = - b ;				      	      a = - a						    	    a = - a						  
  double mod = a ;					      	  if ( b < 0 ) :					    	if b < 0 :						  
  while ( mod >= b ) mod = mod - b ;			      	      b = - b						    	    b = - b						  
  if ( a < 0 ) return - mod ;				      	  mod = a						    	mod = a							  
  return mod ;						      	  while ( mod >= b ) :					    	while mod >= b :					  
}							      	      mod = mod - b					    	    mod = mod - b					  
							      	  if ( a < 0 ) :					    	if a < 0 :						  
							      	      return - mod					    	    return - mod					  
							      	  return mod						    	return mod						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	      PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	    PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	  PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1
--							      --							    --								  --
static boolean arraySortedOrNot ( int arr [ ] , int n ) {     def arraySortedOrNot ( arr , n ) :			    def array_sorted_or_not ( arr , n ) :			  success : None
  if ( n == 0 || n == 1 ) return true ;			      	  if ( n == 0 or n == 1 ) :				    	if not n or n == 1 :					  
  for ( int i = 1 ;					      	      return True					    	    return True						  
  i < n ;						      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ;      	      if ( arr [ i - 1 ] > arr [ i ] ) :		    	    if arr [ i - 1 ] > arr [ i ] :			  
  return true ;						      		  return False					    		return False					  
}							      	  return True						    	return True						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_SUBTRACTION_MATICES				      C_PROGRAM_SUBTRACTION_MATICES				    C_PROGRAM_SUBTRACTION_MATICES				  C_PROGRAM_SUBTRACTION_MATICES
--							      --							    --								  --
static void multiply ( int A [ ] [ ] , int B [ ] [ ] , int C  def multiply ( A , B , C ) :				    def multiply ( A , B , C ) :				  script_not_found : None
  int i , j ;						      	  for i in range ( N ) :				    	global N						  
  for ( i = 0 ;						      	      for j in range ( N ) :				    	for i in range ( N ) :					  
  i < N ;						      		  C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]	    	    for j in range ( N ) :				  
  i ++ ) for ( j = 0 ;					      								    		C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]	  
  j < N ;						      								    								  
  j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	      MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	    MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	  MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1
--							      --							    --								  --
static int minimumflip ( int mat [ ] [ ] , int n ) {	      def minimumflip ( mat , n ) :				    def minimumflip ( mat , n ) :				  success : identical to gold
  int flip = 0 ;					      	  flip = 0						    	flip = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i ) :				    	    for j in range ( i ) :				  
  i ++ ) for ( int j = 0 ;				      		  if mat [ i ] [ j ] != mat [ j ] [ i ] :	    		if mat [ i ] [ j ] != mat [ j ] [ i ] :		  
  j < i ;						      		      flip += 1					    		    flip += 1					  
  j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ;  	  return flip						    	return flip						  
  return flip ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1		      FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1		    FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1			  FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1
--							      --							    --								  --
static double sumNodes ( int l ) {			      def sumNodes ( l ) :					    def sum_nodes ( l ) :					  success : None
  double leafNodeCount = Math . pow ( 2 , l - 1 ) ;	      	  leafNodeCount = math.pow ( 2 , l - 1 )		    	leaf_node_count = pow ( 2 , l - 1 )			  
  double sumLastLevel = 0 ;				      	  sumLastLevel = 0					    	sum_last_level = 0					  
  sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) /  	  sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 )  	sum_last_level = ( leaf_node_count * ( leaf_node_count +  
  double sum = sumLastLevel * l ;			      	  sum = sumLastLevel * l				    	sum = sum_last_level * l				  
  return sum ;						      	  return int ( sum )					    	return sum						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			      NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			    NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			  NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES
--							      --							    --								  --
public static int findPosition ( int k , int n ) {	      def findPosition ( k , n ) :				    def find_position ( k , n ) :				  success : None
  long f1 = 0 , f2 = 1 , f3 ;				      	  f1 = 0						    	f1 , f2 , f3 = 0 , 1 , 3				  
  int i = 2 ;						      	  f2 = 1						    	i = 2							  
  while ( i != 0 ) {					      	  i = 2							    	while i != 0 :						  
    f3 = f1 + f2 ;					      	  while i != 0 :					    	    f3 = f1 + f2					  
    f1 = f2 ;						      	      f3 = f1 + f2					    	    f1 = f2						  
    f2 = f3 ;						      	      f1 = f2						    	    f2 = f3						  
    if ( f2 % k == 0 ) {				      	      f2 = f3						    	    if f2 % k == 0 :					  
      return n * i ;					      	      if f2 % k == 0 :					    		return n * i					  
    }							      		  return n * i					    	    i += 1						  
    i ++ ;						      	      i += 1						    	return 0						  
  }							      	  return						    								  
  return 0 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		      FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		    FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		  FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME
--							      --							    --								  --
static int findIndex ( int n ) {			      def findIndex ( n ) :					    def find_index ( n ) :					  success : None
  if ( n <= 1 ) return n ;				      	  if ( n <= 1 ) :					    	if n <= 1 :						  
  int a = 0 , b = 1 , c = 1 ;				      	      return n						    	    return n						  
  int res = 1 ;						      	  a = 0							    	a , b , c = 0 , 1 , 1					  
  while ( c < n ) {					      	  b = 1							    	res = 1							  
    c = a + b ;						      	  c = 1							    	while c < n :						  
    res ++ ;						      	  res = 1						    	    c = a + b						  
    a = b ;						      	  while ( c < n ) :					    	    res += 1						  
    b = c ;						      	      c = a + b						    	    a = b						  
  }							      	      res = res + 1					    	    b = c						  
  return res ;						      	      a = b						    	return res						  
}							      	      b = c						    								  
							      	  return res						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PAPER_CUT_MINIMUM_NUMBER_SQUARES			      PAPER_CUT_MINIMUM_NUMBER_SQUARES				    PAPER_CUT_MINIMUM_NUMBER_SQUARES				  PAPER_CUT_MINIMUM_NUMBER_SQUARES
--							      --							    --								  --
static int minimumSquare ( int a , int b ) {		      def minimumSquare ( a , b ) :				    def minimum_square ( a , b ) :				  error : Traceback (most recent call last):   File
  int result = 0 , rem = 0 ;				      	  result = 0						    	result , rem = 0 , 0					  "dump/transcoder_st/eval/java_python/online_st/206
  if ( a < b ) swap ( a , b ) ;				      	  rem = 0						    	if a < b :						  68770/eval_scripts/java_sa-python_sa.test/PAPER_CU
  while ( b > 0 ) {					      	  if ( a < b ) :					    	    swap ( a , b )					  T_MINIMUM_NUMBER_SQUARES.py", line 57, in <module>
    result += a / b ;					      	      a , b = b , a					    	while b > 0 :						       if f_filled(*parameters_set) == f_gold(*param
    rem = a % b ;					      	  while ( b > 0 ) :					    	    result += a // b					  eters_set):	File "dump/transcoder_st/eval/java_p
    a = b ;						      	      result += int ( a / b )				    	    rem = a % b						  ython/online_st/20668770/eval_scripts/java_sa-pyth
    b = rem ;						      	      rem = int ( a % b )				    	    a = b						  on_sa.test/PAPER_CUT_MINIMUM_NUMBER_SQUARES.py", l
  }							      	      a = b						    	    b = rem						  ine 33, in f_filled	  swap ( a , b ) NameError:
  return result ;					      	      b = rem						    	return result						  name 'swap' is not defined
}							      	  return result						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				      CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				    CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				  CONSTRUCT_ARRAY_PAIR_SUM_ARRAY
--							      --							    --								  --
static void constructArr ( int arr [ ] , int pair [ ] , int n def constructArr ( arr , pair , n ) :			    def construct_arr ( arr , pair , n ) :			  script_not_found : None
  arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) /  	  arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] )  	arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] )  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i < n ;						      	      arr [ i ] = pair [ i - 1 ] - arr [ 0 ]		    	    arr [ i ] = pair [ i - 1 ] - arr [ 0 ]		  
  i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN
--							      --							    --								  --
static int findMaximum ( int arr [ ] , int low , int high ) { def findMaximum ( arr , low , high ) :			    def findMaximum ( arr , low , high ) :			  failure : #Results: 7, 10
  int max = arr [ low ] ;				      	  max = arr [ low ]					    	max = arr [ low ]					  
  int i ;						      	  i = low						    	i = 0							  
  for ( i = low ;					      	  for i in range ( high + 1 ) :				    	for i in range ( low , high + 1 ) :			  
  i <= high ;						      	      if arr [ i ] > max :				    	    if arr [ i ] > max :				  
  i ++ ) {						      		  max = arr [ i ]				    		max = arr [ i ]					  
    if ( arr [ i ] > max ) max = arr [ i ] ;		      	  return max						    	return max						  
  }							      								    								  
  return max ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	      MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	    MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	  MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY
--							      --							    --								  --
static int minimum_cost ( int a [ ] , int n ) {		      def minimum_cost ( a , n ) :				    def minimum_cost ( a , n ) :				  success : identical to gold
  int mn = Integer . MAX_VALUE ;			      	  mn = sys.maxsize					    	mn = sys.maxsize					  
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      mn = min ( a [ i ] , mn )				    	    mn = min ( a [ i ] , mn )				  
  i ++ ) {						      	      sum += a [ i ]					    	    sum += a [ i ]					  
    mn = Math . min ( a [ i ] , mn ) ;			      	  return mn * ( sum - mn )				    	return mn * ( sum - mn )				  
    sum += a [ i ] ;					      								    								  
  }							      								    								  
  return mn * ( sum - mn ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS
--							      --							    --								  --
static String decToBin ( int n ) {			      def decToBin ( n ) :					    def dec_to_bin ( n ) :					  success : None
  if ( n == 0 ) return "0" ;				      	  if ( n == 0 ) :					    	if not n :						  
  String bin = "" ;					      	      return "0"					    	    return '0'						  
  while ( n > 0 ) {					      	  bin = ""						    	bin = ''						  
    bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ;	      	  while ( n > 0 ) :					    	while n > 0 :						  
    n >>= 1 ;						      	      if ( n & 1 == 0 ) :				    	    bin = ( ( '0' if n & 1 == 0 else '1' ) + bin )	  
  }							      		  bin = '0' + bin				    	    n >>= 1						  
  return bin ;						      	      else :						    	return bin						  
}							      		  bin = '1' + bin				    								  
							      	      n = n >> 1					    								  
							      	  return bin						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	      CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	    CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	  CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT
--							      --							    --								  --
static boolean isInorder ( int [ ] arr , int n ) {	      def isInorder ( arr , n ) :				    def isInorder ( arr , n ) :					  success : None
  if ( n == 0 || n == 1 ) {				      	  if ( n == 0 or n == 1 ) :				    	if n == 0 or n == 1 :					  
    return true ;					      	      return True					    	    return True						  
  }							      	  for i in range ( 1 , n , 1 ) :			    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      	      if ( arr [ i - 1 ] > arr [ i ] ) :		    	    if arr [ i - 1 ] > arr [ i ] :			  
  i < n ;						      		  return False					    		return False					  
  i ++ ) {						      	  return True						    	return True						  
    if ( arr [ i - 1 ] > arr [ i ] ) {			      								    								  
      return false ;					      								    								  
    }							      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHUFFLE_A_DECK_OF_CARDS_3				      SHUFFLE_A_DECK_OF_CARDS_3					    SHUFFLE_A_DECK_OF_CARDS_3					  SHUFFLE_A_DECK_OF_CARDS_3
--							      --							    --								  --
public static void shuffle ( int card [ ] , int n ) {	      def shuffle ( card , n ) :				    def shuffle ( card , n ) :					  script_not_found : None
  Random rand = new Random ( ) ;			      	  for i in range ( n ) :				    	np.random.seed ( 0 )					  
  for ( int i = 0 ;					      	      r = i + ( random.randint ( 0 , 55 ) % ( 52 - i ) )    	for i in range ( n ) :					  
  i < n ;						      	      tmp = card [ i ]					    	    r = i + np.random.randint ( 52 - i )		  
  i ++ ) {						      	      card [ i ] = card [ r ]				    	    temp = card [ r ]					  
    int r = i + rand . nextInt ( 52 - i ) ;		      	      card [ r ] = tmp					    	    card [ r ] = card [ i ]				  
    int temp = card [ r ] ;				      								    	    card [ i ] = temp					  
    card [ r ] = card [ i ] ;				      								    								  
    card [ i ] = temp ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MIRROR_IMAGE_POINT_2_D_PLANE			      FIND_MIRROR_IMAGE_POINT_2_D_PLANE				    FIND_MIRROR_IMAGE_POINT_2_D_PLANE				  FIND_MIRROR_IMAGE_POINT_2_D_PLANE
--							      --							    --								  --
static pair mirrorImage ( double a , double b , double c , do def mirrorImage ( a , b , c , x1 , y1 ) :			    def mirror_image ( a , b , c , x1 , y1 ) :			  success : None
  double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * 	  temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b )  	temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b )  
  double x = temp * a + x1 ;				      	  x = temp * a + x1					    	x = temp * a + x1					  
  double y = temp * b + y1 ;				      	  y = temp * b + y1					    	y = temp * b + y1					  
  return new pair ( x , y ) ;				      	  return ( x , y )					    	return x , y						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1		      COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1			    COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1			  COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1
--							      --							    --								  --
static int numberOfWays ( int x ) {			      def numberOfWays ( x ) :					    def number_of_ways ( x ) :					  script_not_found : None
  int dp [ ] = new int [ x + 1 ] ;			      	  if x == 0 or x == 1 :					    	dp = np.zeros ( x + 1 )					  
  dp [ 0 ] = dp [ 1 ] = 1 ;				      	      return 1						    	dp [ 0 ] = dp [ 1 ] = 1					  
  for ( int i = 2 ;					      	  else :						    	for i in range ( 2 , x + 1 ) :				  
  i <= x ;						      	      return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberO 	    dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ]	  
  i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; 								    	return dp [ x ]						  
  return dp [ x ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEONARDO_NUMBER_1					      LEONARDO_NUMBER_1						    LEONARDO_NUMBER_1						  LEONARDO_NUMBER_1
--							      --							    --								  --
static int leonardo ( int n ) {				      def leonardo ( n ) :					    def leonardo ( n ) :					  success : None
  int dp [ ] = new int [ n + 1 ] ;			      	  dp = [ ]						    	dp = [ 0 ] * ( n + 1 )					  
  dp [ 0 ] = dp [ 1 ] = 1 ;				      	  dp.append ( 1 )					    	dp [ 0 ] = dp [ 1 ] = 1					  
  for ( int i = 2 ;					      	  dp.append ( 1 )					    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	  for i in range ( 2 , n + 1 ) :			    	    dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1		  
  i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ;	      	      dp.append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 )	    	return dp [ n ]						  
  return dp [ n ] ;					      	  return dp [ n ]					    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B			      COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B				    COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B				  COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B
--							      --							    --								  --
static int CountPairs ( int n ) {			      def CountPairs ( n ) :					    def CountPairs ( n ) :					  failure : #Results: 0, 10
  int k = n ;						      	  k = n							    	k = n							  
  int imin = 1 ;					      	  imin = 1						    	imin = 1						  
  int ans = 0 ;						      	  ans = 0						    	ans = 0							  
  while ( imin <= n ) {					      	  while ( imin <= n ) :					    	while imin <= n :					  
    int imax = n / k ;					      	      imax = n / k					    	    imax = n // k					  
    ans += k * ( imax - imin + 1 ) ;			      	      ans += k * ( imax - imin + 1 )			    	    ans += k * ( imax - imin + 1 )			  
    imin = imax + 1 ;					      	      imin = imax + 1					    	    imin = imax + 1					  
    k = n / imin ;					      	      k = n / imin					    	    k = n // imin					  
  }							      	  return ans						    	return ans						  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION     DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION	    DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION	  DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION
--							      --							    --								  --
static int lastPosition ( int n , int m , int k ) {	      def lastPosition ( n , m , k ) :				    def last_position ( n , m , k ) :				  success : None
  if ( m <= n - k + 1 ) return m + k - 1 ;		      	  if ( m <= n - k + 1 ) :				    	if m <= n - k + 1 :					  
  m = m - ( n - k + 1 ) ;				      	      return m + k - 1					    	    return m + k - 1					  
  return ( m % n == 0 ) ? n : ( m % n ) ;		      	  m = m - ( n - k + 1 )					    	m = m - ( n - k + 1 )					  
}							      	  if ( m % n == 0 ) :					    	return ( n if m % n == 0 else ( m % n ) )		  
							      	      return n						    								  
							      	  else :						    								  
							      	      return m % n					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_DIGIT_RAISED_POWER_B				      K_TH_DIGIT_RAISED_POWER_B					    K_TH_DIGIT_RAISED_POWER_B					  K_TH_DIGIT_RAISED_POWER_B
--							      --							    --								  --
public static int kthdigit ( int a , int b , int k ) {	      def kthdigit ( a , b , k ) :				    def kthdigit ( a , b , k ) :				  failure : #Results: 1, 10
  int p = ( int ) Math . pow ( a , b ) ;		      	  p = a ** b						    	p = int ( math.pow ( a , b ) )				  
  int count = 0 ;					      	  count = 0						    	count = 0						  
  while ( p > 0 && count < k ) {			      	  while ( p > 0 and count < k ) :			    	while p > 0 and count < k :				  
    int rem = p % 10 ;					      	      rem = p % 10					    	    rem = p % 10					  
    count ++ ;						      	      count = count + 1					    	    count += 1						  
    if ( count == k ) return rem ;			      	      if ( count == k ) :				    	    if count == k :					  
    p = p / 10 ;					      		  return rem					    		return rem					  
  }							      	      p = p / 10					    	    p = p // 10						  
  return 0 ;						      								    	return 0						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPLIT_ARRAY_ADD_FIRST_PART_END				      SPLIT_ARRAY_ADD_FIRST_PART_END				    SPLIT_ARRAY_ADD_FIRST_PART_END				  SPLIT_ARRAY_ADD_FIRST_PART_END
--							      --							    --								  --
public static void splitArr ( int arr [ ] , int n , int k ) { def splitArr ( arr , n , k ) :				    def split_arr ( arr , n , k ) :				  success : None
  for ( int i = 0 ;					      	  for i in range ( 0 , k ) :				    	for i in range ( k ) :					  
  i < k ;						      	      x = arr [ 0 ]					    	    x = arr [ 0 ]					  
  i ++ ) {						      	      for j in range ( 0 , n - 1 ) :			    	    for j in range ( n - 1 ) :				  
    int x = arr [ 0 ] ;					      		  arr [ j ] = arr [ j + 1 ]			    		arr [ j ] = arr [ j + 1 ]			  
    for ( int j = 0 ;					      	      arr [ n - 1 ] = x					    	    arr [ n - 1 ] = x					  
    j < n - 1 ;						      								    								  
    ++ j ) arr [ j ] = arr [ j + 1 ] ;			      								    								  
    arr [ n - 1 ] = x ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ROTATE_MATRIX_180_DEGREE				      ROTATE_MATRIX_180_DEGREE					    ROTATE_MATRIX_180_DEGREE					  ROTATE_MATRIX_180_DEGREE
--							      --							    --								  --
static void rotateMatrix ( int mat [ ] [ ] ) {		      def rotateMatrix ( mat ) :				    def rotate_matrix ( mat ) :					  script_not_found : None
  for ( int i = N - 1 ;					      	  i = N - 1						    	for i in range ( N - 1 , - 1 , - 1 ) :			  
  i >= 0 ;						      	  while ( i >= 0 ) :					    	    for j in range ( N - 1 , - 1 , - 1 ) :		  
  i -- ) {						      	      j = N - 1						    		print ( mat [ i ] [ j ] , end = ' ' )		  
    for ( int j = N - 1 ;				      	      while ( j >= 0 ) :				    	    print ( )						  
    j >= 0 ;						      		  print ( mat [ i ] [ j ] , end = " " )		    								  
    j -- ) System . out . print ( mat [ i ] [ j ] + " " ) ;   		  j = j - 1					    								  
    System . out . println ( ) ;			      	      print ( )						    								  
  }							      	      i = i - 1						    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA
--							      --							    --								  --
static int russianPeasant ( int a , int b ) {		      def russianPeasant ( a , b ) :				    def russianPeasant ( a , b ) :				  success : None
  int res = 0 ;						      	  res = 0						    	res = 0							  
  while ( b > 0 ) {					      	  while ( b > 0 ) :					    	while b > 0 :						  
    if ( ( b & 1 ) != 0 ) res = res + a ;		      	      if ( b & 1 ) :					    	    if b & 1 :						  
    a = a << 1 ;					      		  res = res + a					    		res = res + a					  
    b = b >> 1 ;					      	      a = a << 1					    	    a = a << 1						  
  }							      	      b = b >> 1					    	    b = b >> 1						  
  return res ;						      	  return res						    	return res						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DIGITS_FACTORIAL_SET_1				      COUNT_DIGITS_FACTORIAL_SET_1				    COUNT_DIGITS_FACTORIAL_SET_1				  COUNT_DIGITS_FACTORIAL_SET_1
--							      --							    --								  --
static int findDigits ( int n ) {			      def findDigits ( n ) :					    def find_digits ( n ) :					  success : None
  if ( n < 0 ) return 0 ;				      	  if ( n < 0 ) :					    	if n < 0 :						  
  if ( n <= 1 ) return 1 ;				      	      return 0						    	    return 0						  
  double digits = 0 ;					      	  if ( n <= 1 ) :					    	if n <= 1 :						  
  for ( int i = 2 ;					      	      return 1						    	    return 1						  
  i <= n ;						      	  digits = 0						    	digits = 0						  
  i ++ ) digits += Math . log10 ( i ) ;			      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
  return ( int ) ( Math . floor ( digits ) ) + 1 ;	      	      digits += math.log10 ( i )			    	    digits += math.log10 ( i )				  
}							      	  return math.floor ( digits ) + 1			    	return int ( math.floor ( digits ) ) + 1		  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX		      SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX			    SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX			  SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX
--							      --							    --								  --
static void swapDiagonal ( int matrix [ ] [ ] ) {	      def swapDiagonal ( matrix ) :				    def swap_diagonal ( matrix ) :				  script_not_found : None
  for ( int i = 0 ;					      	  for i in range ( N ) :				    	for i in range ( N ) :					  
  i < N ;						      	      matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = \   	    temp = matrix [ i ] [ i ]				  
  i ++ ) {						      		  matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ]   	    matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ]	  
    int temp = matrix [ i ] [ i ] ;			      								    	    matrix [ i ] [ N - i - 1 ] = temp			  
    matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] ;	      								    								  
    matrix [ i ] [ N - i - 1 ] = temp ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MARKOV_MATRIX						      MARKOV_MATRIX						    MARKOV_MATRIX						  MARKOV_MATRIX
--							      --							    --								  --
static boolean checkMarkov ( double m [ ] [ ] ) {	      def checkMarkov ( m ) :					    def check_markov ( m ) :					  error : Traceback (most recent call last):   File
  for ( int i = 0 ;					      	  for i in range ( 0 , len ( m ) ) :			    	for i in range ( len ( m ) ) :				  "dump/transcoder_st/eval/java_python/online_st/206
  i < m . length ;					      	      sm = 0						    	    sum = 0						  68770/eval_scripts/java_sa-python_sa.test/MARKOV_M
  i ++ ) {						      	      for j in range ( 0 , len ( m [ i ] ) ) :		    	    for j in m [ i ] :					  ATRIX.py", line 52, in <module>     if f_filled(*p
    double sum = 0 ;					      		  sm = sm + m [ i ] [ j ]			    		sum = sum + m [ i ] [ j ]			  arameters_set) == f_gold(*parameters_set):   File
    for ( int j = 0 ;					      	      if ( sm != 1 ) :					    	    if sum != 1 :					  "dump/transcoder_st/eval/java_python/online_st/206
    j < m [ i ] . length ;				      		  return False					    		return False					  68770/eval_scripts/java_sa-python_sa.test/MARKOV_M
    j ++ ) sum = sum + m [ i ] [ j ] ;			      	  return True						    	return True						  ATRIX.py", line 31, in f_filled     sum = sum + m
    if ( sum != 1 ) return false ;			      								    								  [ i ] [ j ] TypeError: list indices must be intege
  }							      								    								  rs or slices, not float
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN
--							      --							    --								  --
static int search ( int arr [ ] , int n , int x ) {	      def search ( arr , n , x ) :				    def search ( arr , n , x ) :				  success : None
  int i = 0 ;						      	  i = 0							    	i = 0							  
  while ( i <= n - 1 ) {				      	  while ( i <= n - 1 ) :				    	while i <= n - 1 :					  
    if ( arr [ i ] == x ) return i ;			      	      if ( arr [ i ] == x ) :				    	    if arr [ i ] == x :					  
    i += Math . abs ( arr [ i ] - x ) ;			      		  return i					    		return i					  
  }							      	      i += abs ( arr [ i ] - x )			    	    i += abs ( arr [ i ] - x )				  
  return - 1 ;						      	  return - 1						    	return - 1						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS	      MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS		    MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS		  MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS
--							      --							    --								  --
static long findMinSum ( long a [ ] , long b [ ] , long n ) { def findMinSum ( a , b , n ) :				    def find_min_sum ( a , b , n ) :				  script_not_found : None
  Arrays . sort ( a ) ;					      	  a.sort ( )						    	a.sort ( )						  
  Arrays . sort ( b ) ;					      	  b.sort ( )						    	b.sort ( )						  
  long sum = 0 ;					      	  sum = 0						    	sum = 0							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      sum = sum + abs ( a [ i ] - b [ i ] )		    	    sum = sum + abs ( a [ i ] - b [ i ] )		  
  i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ;	      	  return sum						    	return sum						  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER   MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER   MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER	  MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER
--							      --							    --								  --
static int maxPrefix ( String s , String t ) {		      def maxPrefix ( s , t ) :					    def max_prefix ( s , t ) :					  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int i = 0 ;					      	  for i in range ( 0 , len ( t ) ) :			    	for c in t :						  
  i < t . length ( ) ;					      	      if ( count == len ( s ) ) :			    	    if count == len ( t ) :				  
  i ++ ) {						      		  break						    		break						  
    if ( count == t . length ( ) ) break ;		      	      if ( t [ i ] == s [ count ] ) :			    	    if c == s [ count ] :				  
    if ( t . charAt ( i ) == s . charAt ( count ) ) count ++  		  count = count + 1				    		count += 1					  
  }							      	  return count						    	return count						  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			      PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			    PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			  PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2
--							      --							    --								  --
static void transpose ( int A [ ] [ ] ) {		      def transpose ( A ) :					    def transpose ( A ) :					  script_not_found : None
  for ( int i = 0 ;					      	  for i in range ( N ) :				    	for i in range ( N ) :					  
  i < N ;						      	      for j in range ( i + 1 , N ) :			    	    for j in range ( i + 1 , N ) :			  
  i ++ ) for ( int j = i + 1 ;				      		  A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A 		temp = A [ i ] [ j ]				  
  j < N ;						      								    		A [ i ] [ j ] = A [ j ] [ i ]			  
  j ++ ) {						      								    		A [ j ] [ i ] = temp				  
    int temp = A [ i ] [ j ] ;				      								    								  
    A [ i ] [ j ] = A [ j ] [ i ] ;			      								    								  
    A [ j ] [ i ] = temp ;				      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_DIFFERENCE_PAIR_1				      FIND_MINIMUM_DIFFERENCE_PAIR_1				    FIND_MINIMUM_DIFFERENCE_PAIR_1				  FIND_MINIMUM_DIFFERENCE_PAIR_1
--							      --							    --								  --
static int findMinDiff ( int [ ] arr , int n ) {	      def findMinDiff ( arr , n ) :				    def find_min_diff ( arr , n ) :				  failure : #Results: 9, 10
  Arrays . sort ( arr ) ;				      	  arr = sorted ( arr )					    	arr.sort ( )						  
  int diff = Integer . MAX_VALUE ;			      	  diff = 10 ** 20					    	diff = sys.maxsize					  
  for ( int i = 0 ;					      	  for i in range ( n - 1 ) :				    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      if arr [ i + 1 ] - arr [ i ] < diff :		    	    if arr [ i + 1 ] - arr [ i ] < diff :		  
  i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ 		  diff = arr [ i + 1 ] - arr [ i ]		    		diff = arr [ i + 1 ] - arr [ i ]		  
  return diff ;						      	  return diff						    	return diff						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		      FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		    FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		  FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS
--							      --							    --								  --
static int countSquares ( int a , int b ) {		      def CountSquares ( a , b ) :				    def count_squares ( a , b ) :				  script_not_found : None
  int cnt = 0 ;						      	  cnt = 0						    	cnt = 0							  
  for ( int i = a ;					      	  for i in range ( a , b + 1 ) :			    	for i in range ( a , b + 1 ) :				  
  i <= b ;						      	      j = 1 ;						    	    for j in range ( 1 , i + 1 ) :			  
  i ++ ) for ( int j = 1 ;				      	      while j * j <= i :				    		if j * j == i :					  
  j * j <= i ;						      		  if j * j == i :				    		    cnt += 1					  
  j ++ ) if ( j * j == i ) cnt ++ ;			      		      cnt = cnt + 1				    	return cnt						  
  return cnt ;						      		  j = j + 1					    								  
}							      	      i = i + 1						    								  
							      	  return cnt						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BREAK_NUMBER_THREE_PARTS				      BREAK_NUMBER_THREE_PARTS					    BREAK_NUMBER_THREE_PARTS					  BREAK_NUMBER_THREE_PARTS
--							      --							    --								  --
static long count_of_ways ( long n ) {			      def count_of_ways ( n ) :					    def count_of_ways ( n ) :					  success : None
  long count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n + 1 ) :			    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      for j in range ( 0 , n + 1 ) :			    	    for j in range ( 0 , n + 1 ) :			  
  i ++ ) for ( int j = 0 ;				      		  for k in range ( 0 , n + 1 ) :		    		for k in range ( 0 , n + 1 ) :			  
  j <= n ;						      		      if ( i + j + k == n ) :			    		    if i + j + k == n :				  
  j ++ ) for ( int k = 0 ;				      			  count = count + 1			    			count += 1				  
  k <= n ;						      	  return count						    	return count						  
  k ++ ) if ( i + j + k == n ) count ++ ;		      								    								  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			      HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			    HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			  HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN
--							      --							    --								  --
static int findHeight ( int [ ] parent , int n ) {	      def findHeight ( parent , n ) :				    def find_height ( parent , n ) :				  script_not_found : None
  int res = 0 ;						      	  res = 0						    	res = 0							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      p = i						    	    p , current = i , 1					  
  i ++ ) {						      	      current = 1					    	    while parent [ p ] != - 1 :				  
    int p = i , current = 1 ;				      	      while ( parent [ p ] != - 1 ) :			    		current += 1					  
    while ( parent [ p ] != - 1 ) {			      		  current += 1					    		p = parent [ p ]				  
      current ++ ;					      		  p = parent [ p ]				    	    res = max ( res , current )				  
      p = parent [ p ] ;				      	      res = max ( res , current )			    	return res						  
    }							      	  return res						    								  
    res = Math . max ( res , current ) ;		      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FRIENDS_PAIRING_PROBLEM_2				      FRIENDS_PAIRING_PROBLEM_2					    FRIENDS_PAIRING_PROBLEM_2					  FRIENDS_PAIRING_PROBLEM_2
--							      --							    --								  --
static int countFriendsPairings ( int n ) {		      def countFriendsPairings ( n ) :				    def count_friend_pairings ( n ) :				  success : None
  int a = 1 , b = 2 , c = 0 ;				      	  a , b , c = 1 , 2 , 0					    	a , b , c = 1 , 2 , 0					  
  if ( n <= 2 ) {					      	  if ( n <= 2 ) :					    	if n <= 2 :						  
    return n ;						      	      return n						    	    return n						  
  }							      	  for i in range ( 3 , n + 1 ) :			    	for i in range ( 3 , n + 1 ) :				  
  for ( int i = 3 ;					      	      c = b + ( i - 1 ) * a				    	    c = b + ( i - 1 ) * a				  
  i <= n ;						      	      a = b						    	    a = b						  
  i ++ ) {						      	      b = c						    	    b = c						  
    c = b + ( i - 1 ) * a ;				      	  return c						    	return c						  
    a = b ;						      								    								  
    b = c ;						      								    								  
  }							      								    								  
  return c ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS
--							      --							    --								  --
static int numofsubset ( int arr [ ] , int n ) {	      def numofsubset ( arr , n ) :				    def numofsubset ( arr , n ) :				  success : None
  Arrays . sort ( arr ) ;				      	  x = sorted ( arr )					    	arr.sort ( )						  
  int count = 1 ;					      	  count = 1						    	count = 1						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n - 1 ) :			    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      if ( x [ i ] + 1 != x [ i + 1 ] ) :		    	    if arr [ i ] + 1 != arr [ i + 1 ] :			  
  i ++ ) {						      		  count = count + 1				    		count += 1					  
    if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ;	      	  return count						    	return count						  
  }							      								    								  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS		      PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS		    PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS			  PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS
--							      --							    --								  --
static void printFibonacciNumbers ( int n ) {		      def printFibonacciNumbers ( n ) :				    def print_fibonacci_numbers ( n ) :				  script_not_found : None
  int f1 = 0 , f2 = 1 , i ;				      	  f1 = 0						    	f1 , f2 , i = 0 , 1 , i					  
  if ( n < 1 ) return ;					      	  f2 = 1						    	if n < 1 :						  
  for ( i = 1 ;						      	  if ( n < 1 ) :					    	    return						  
  i <= n ;						      	      return						    	for i in range ( 1 , n + 1 ) :				  
  i ++ ) {						      	  for x in range ( 0 , n ) :				    	    print ( f2 , end = ' ' )				  
    System . out . print ( f2 + " " ) ;			      	      print ( f2 , end = " " )				    	    next = f1 + f2					  
    int next = f1 + f2 ;				      	      next = f1 + f2					    	    f1 = f2						  
    f1 = f2 ;						      	      f1 = f2						    	    f2 = next						  
    f2 = next ;						      	      f2 = next						    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1	      EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1		    EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1		  EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1
--							      --							    --								  --
static long exponentiation ( long base , long exp ) {	      def exponentiation ( bas , exp ) :			    def exponentiation ( base , exp ) :				  script_not_found : None
  long t = 1L ;						      	  t = 1							    	t = 1							  
  while ( exp > 0 ) {					      	  while ( exp > 0 ) :					    	while exp > 0 :						  
    if ( exp % 2 != 0 ) t = ( t * base ) % N ;		      	      if ( exp % 2 != 0 ) :				    	    if exp % 2 :					  
    base = ( base * base ) % N ;			      		  t = ( t * bas ) % N				    		t = ( t * base ) % N				  
    exp /= 2 ;						      	      bas = ( bas * bas ) % N				    	    base = ( base * base ) % N				  
  }							      	      exp = int ( exp / 2 )				    	    exp //= 2						  
  return t % N ;					      	  return t % N						    	return t % N						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y
--							      --							    --								  --
static int countSolutions ( int n ) {			      def countSolutions ( n ) :				    def count_solutions ( n ) :					  error : Traceback (most recent call last):   File
  int res = 0 ;						      	  res = 0						    	res = 0							  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int x = 0 ;					      	  x = 0							    	for x in range ( 0 , n ) :				  68770/eval_scripts/java_sa-python_sa.test/COUNT_DI
  x * x < n ;						      	  while ( x * x < n ) :					    	    for y in range ( 0 , x * x + y * y ) :		  STINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_X
  x ++ ) for ( int y = 0 ;				      	      y = 0						    		res += 1					  X_YY_N_2.py", line 52, in <module>	 if f_filled
  x * x + y * y < n ;					      	      while ( x * x + y * y < n ) :			    	return res						  (*parameters_set) == f_gold(*parameters_set):	  Fi
  y ++ ) res ++ ;					      		  res = res + 1					    								  le "dump/transcoder_st/eval/java_python/online_st/
  return res ;						      		  y = y + 1					    								  20668770/eval_scripts/java_sa-python_sa.test/COUNT
}							      	      x = x + 1						    								  _DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALIT
							      	  return res						    								  Y_XX_YY_N_2.py", line 32, in f_filled	    for y in
							      								    								   range ( 0 , x * x + y * y ) : UnboundLocalError:
							      								    								  local variable 'y' referenced before assignment
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHUFFLE_A_GIVEN_ARRAY					      SHUFFLE_A_GIVEN_ARRAY					    SHUFFLE_A_GIVEN_ARRAY					  SHUFFLE_A_GIVEN_ARRAY
--							      --							    --								  --
static void randomize ( int arr [ ] , int n ) {		      def randomize ( arr , n ) :				    def randomize ( arr , n ) :					  error : Traceback (most recent call last):   File
  Random r = new Random ( ) ;				      	  for i in range ( n - 1 , 0 , - 1 ) :			    	r = random.Random ( )					  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int i = n - 1 ;					      	      j = random.randint ( 0 , i + 1 )			    	for i in range ( n - 1 , 0 , - 1 ) :			  68770/eval_scripts/java_sa-python_sa.test/SHUFFLE_
  i > 0 ;						      	      arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]	    	    j = r.randint ( i + 1 , n )				  A_GIVEN_ARRAY.py", line 51, in <module>     if f_f
  i -- ) {						      	  return arr						    	    temp = arr [ i ]					  illed(*parameters_set) == f_gold(*parameters_set):
    int j = r . nextInt ( i + 1 ) ;			      								    	    arr [ i ] = arr [ j ]				     File "dump/transcoder_st/eval/java_python/onlin
    int temp = arr [ i ] ;				      								    	    arr [ j ] = temp					  e_st/20668770/eval_scripts/java_sa-python_sa.test/
    arr [ i ] = arr [ j ] ;				      								    	print ( ''.join ( arr ) )				  SHUFFLE_A_GIVEN_ARRAY.py", line 33, in f_filled
    arr [ j ] = temp ;					      								    								    print ( ''.join ( arr ) ) TypeError: sequence it
  }							      								    								  em 0: expected str instance, int found
  System . out . println ( Arrays . toString ( arr ) ) ;      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_BY_7					      DIVISIBILITY_BY_7						    DIVISIBILITY_BY_7						  DIVISIBILITY_BY_7
--							      --							    --								  --
static boolean isDivisibleBy7 ( int num ) {		      def isDivisibleBy7 ( num ) :				    def is_divisible_by_7 ( num ) :				  failure : #Results: 7, 10
  if ( num < 0 ) return isDivisibleBy7 ( - num ) ;	      	  if num < 0 :						    	if num < 0 :						  
  if ( num == 0 || num == 7 ) return true ;		      	      return isDivisibleBy7 ( - num )			    	    return is_divisible_by_7 ( - num )			  
  if ( num < 10 ) return false ;			      	  if ( num == 0 or num == 7 ) :				    	if num == 0 or num == 7 :				  
  return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 1 	      return True					    	    return True						  
}							      	  if ( num < 10 ) :					    	if num < 10 :						  
							      	      return False					    	    return False					  
							      	  return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 	return is_divisible_by_7 ( num // 10 - 2 * ( num - num // 
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO		      MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO		    MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO			  MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO
--							      --							    --								  --
static long moduloMultiplication ( long a , long b , long mod def moduloMultiplication ( a , b , mod ) :		    def modulo_multiplication ( a , b , mod ) :			  success : None
  long res = 0 ;					      	  res = 0 ;						    	res = 0							  
  a %= mod ;						      	  a = a % mod ;						    	a %= mod						  
  while ( b > 0 ) {					      	  while ( b ) :						    	while b > 0 :						  
    if ( ( b & 1 ) > 0 ) {				      	      if ( b & 1 ) :					    	    if b & 1 :						  
      res = ( res + a ) % mod ;				      		  res = ( res + a ) % mod ;			    		res = ( res + a ) % mod				  
    }							      	      a = ( 2 * a ) % mod ;				    	    a = ( 2 * a ) % mod					  
    a = ( 2 * a ) % mod ;				      	      b >>= 1 ;						    	    b >>= 1						  
    b >>= 1 ;						      	  return res ;						    	return res						  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			      DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			    DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			  DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM
--							      --							    --								  --
static void maximizecube ( int l , int b , int h ) {	      def maximizecube ( l , b , h ) :				    def maximizecube ( l , b , h ) :				  script_not_found : None
  int side = gcd ( l , gcd ( b , h ) ) ;		      	  side = gcd ( l , gcd ( b , h ) )			    	side = gcd ( l , gcd ( b , h ) )			  
  int num = l / side ;					      	  num = int ( l / side )				    	num = l // side						  
  num = ( num * b / side ) ;				      	  num = int ( num * b / side )				    	num = ( num * b // side )				  
  num = ( num * h / side ) ;				      	  num = int ( num * h / side )				    	num = ( num * h // side )				  
  System . out . println ( side + " " + num ) ;		      	  print ( side , num )					    	print ( side , num )					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	      RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	    RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	  RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY
--							      --							    --								  --
static int recSearch ( int arr [ ] , int l , int r , int x )  def recSearch ( arr , l , r , x ) :			    def recSearch ( arr , l , r , x ) :				  success : identical to gold
  if ( r < l ) return - 1 ;				      	  if r < l :						    	if r < l :						  
  if ( arr [ l ] == x ) return l ;			      	      return - 1					    	    return - 1						  
  if ( arr [ r ] == x ) return r ;			      	  if arr [ l ] == x :					    	if arr [ l ] == x :					  
  return recSearch ( arr , l + 1 , r - 1 , x ) ;	      	      return l						    	    return l						  
}							      	  if arr [ r ] == x :					    	if arr [ r ] == x :					  
							      	      return r						    	    return r						  
							      	  return recSearch ( arr , l + 1 , r - 1 , x )		    	return recSearch ( arr , l + 1 , r - 1 , x )		  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1
--							      --							    --								  --
static void reverseStr ( String str ) {			      def reverseStr ( str ) :					    def reverse_str ( str ) :					  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  char [ ] ch = str . toCharArray ( ) ;			      	  i , j = 0 , n - 1					    	ch = list ( str )					  
  char temp ;						      	  while i < j :						    	temp = None						  
  for ( int i = 0 , j = n - 1 ;				      	      str [ i ] , str [ j ] = str [ j ] , str [ i ]	    	for i , j in zip ( range ( n - 1 , n ) , range ( n - 1 ,  
  i < j ;						      	      i += 1						    	    temp = ch [ i ]					  
  i ++ , j -- ) {					      	      j -= 1						    	    ch [ i ] = ch [ j ]					  
    temp = ch [ i ] ;					      								    	    ch [ j ] = temp					  
    ch [ i ] = ch [ j ] ;				      								    	print ( ch )						  
    ch [ j ] = temp ;					      								    								  
  }							      								    								  
  System . out . println ( ch ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERIAN_NUMBER						      EULERIAN_NUMBER						    EULERIAN_NUMBER						  EULERIAN_NUMBER
--							      --							    --								  --
public static int eulerian ( int n , int m ) {		      def eulerian ( n , m ) :					    def eulerian ( n , m ) :					  script_not_found : None
  if ( m >= n || n == 0 ) return 0 ;			      	  if ( m >= n or n == 0 ) :				    	if m >= n or not n :					  
  if ( m == 0 ) return 1 ;				      	      return 0						    	    return 0						  
  return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * 	  if ( m == 0 ) :					    	if not m :						  
}							      	      return 1						    	    return 1						  
							      	  return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 	return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) 
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION		      LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION			    LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION			  LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION
--							      --							    --								  --
static String minLexRotation ( String str ) {		      def minLexRotation ( str_ ) :				    def min_lex_rotation ( str ) :				  success : None
  int n = str . length ( ) ;				      	  n = len ( str_ )					    	n = len ( str )						  
  String arr [ ] = new String [ n ] ;			      	  arr = [ 0 ] * n					    	arr = [ ]						  
  String concat = str + str ;				      	  concat = str_ + str_					    	concat = str + str					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      arr [ i ] = concat [ i : n + i ]			    	    arr.append ( concat [ i : i + n ] )			  
  i ++ ) {						      	  arr.sort ( )						    	arr.sort ( )						  
    arr [ i ] = concat . substring ( i , i + n ) ;	      	  return arr [ 0 ]					    	return arr [ 0 ]					  
  }							      								    								  
  Arrays . sort ( arr ) ;				      								    								  
  return arr [ 0 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K	      PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K		    PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K		  PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K
--							      --							    --								  --
static boolean isPossible ( Integer a [ ] , int b [ ] , int n def isPossible ( a , b , n , k ) :			    def is_possible ( a = None , b = None , n = None , k = None ) failure : #Results: 9, 10
  Arrays . sort ( a , Collections . reverseOrder ( ) ) ;      	  a.sort ( reverse = True )				    	a = sorted ( a , reverse = True )			  
  Arrays . sort ( b ) ;					      	  b.sort ( )						    	b = sorted ( b , reverse = True )			  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( a [ i ] + b [ i ] < k ) :			    	    if a [ i ] + b [ i ] < k :				  
  i ++ ) if ( a [ i ] + b [ i ] < k ) return false ;	      		  return False					    		return False					  
  return true ;						      	  return True						    	return True						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		      FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		    FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		  FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1
--							      --							    --								  --
static int maxProduct ( int arr [ ] , int n ) {		      def maxProduct ( arr , n ) :				    def max_product ( arr , n ) :				  success : None
  if ( n < 3 ) {					      	  if n < 3 :						    	if n < 3 :						  
    return - 1 ;					      	      return - 1					    	    return - 1						  
  }							      	  arr.sort ( )						    	arr.sort ( )						  
  Arrays . sort ( arr ) ;				      	  return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr  	return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr  
  return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHANGE_BITS_CAN_MADE_ONE_FLIP				      CHANGE_BITS_CAN_MADE_ONE_FLIP				    CHANGE_BITS_CAN_MADE_ONE_FLIP				  CHANGE_BITS_CAN_MADE_ONE_FLIP
--							      --							    --								  --
static boolean canMakeAllSame ( String str ) {		      def canMakeAllSame ( str ) :				    def canMakeAllSame ( data ) :				  success : None
  int zeros = 0 , ones = 0 ;				      	  zeros = 0						    	zeros , ones = 0 , 0					  
  for ( int i = 0 ;					      	  ones = 0						    	for ch in data :					  
  i < str . length ( ) ;				      	  for i in range ( 0 , len ( str ) ) :			    	    if ch == '0' :					  
  i ++ ) {						      	      ch = str [ i ]					    		zeros += 1					  
    char ch = str . charAt ( i ) ;			      	      if ( ch == '0' ) :				    	    else :						  
    if ( ch == '0' ) ++ zeros ;				      		  zeros = zeros + 1				    		ones += 1					  
    else ++ ones ;					      	      else :						    	return ( zeros == 1 or ones == 1 )			  
  }							      		  ones = ones + 1				    								  
  return ( zeros == 1 || ones == 1 ) ;			      	  return ( zeros == 1 or ones == 1 )			    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS		      MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS			    MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS			  MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS
--							      --							    --								  --
public static int middleOfThree ( int a , int b , int c ) {   def middleOfThree ( a , b , c ) :				    def middle_of_three ( a , b , c ) :				  success : None
  if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ;  	  if ( ( a < b and b < c ) or ( c < b and b < a ) ) :	    	if ( a < b and b < c ) or ( c < b and b < a ) :		  
  else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return 	      return b						    	    return b						  
  else return c ;					      	  if ( ( b < a and a < c ) or ( c < a and a < b ) ) :	    	elif ( b < a and a < c ) or ( c < a and a < b ) :	  
}							      	      return a						    	    return a						  
							      	  else :						    	else :							  
							      	      return c						    	    return c						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_BINARY_DECIMAL_CONVERSION_1			      PROGRAM_BINARY_DECIMAL_CONVERSION_1			    PROGRAM_BINARY_DECIMAL_CONVERSION_1				  PROGRAM_BINARY_DECIMAL_CONVERSION_1
--							      --							    --								  --
static int binaryToDecimal ( String n ) {		      def binaryToDecimal ( n ) :				    def binary_to_decimal ( n ) :				  success : None
  String num = n ;					      	  num = n						    	num = n							  
  int dec_value = 0 ;					      	  dec_value = 0						    	dec_value = 0						  
  int base = 1 ;					      	  base1 = 1						    	base = 1						  
  int len = num . length ( ) ;				      	  len1 = len ( num )					    	num = list ( num )					  
  for ( int i = len - 1 ;				      	  for i in range ( len1 - 1 , - 1 , - 1 ) :		    	for i in range ( len ( num ) - 1 , - 1 , - 1 ) :	  
  i >= 0 ;						      	      if ( num [ i ] == '1' ) :				    	    if num [ i ] == '1' :				  
  i -- ) {						      		  dec_value += base1				    		dec_value += base				  
    if ( num . charAt ( i ) == '1' ) dec_value += base ;      	      base1 = base1 * 2					    	    base = base * 2					  
    base = base * 2 ;					      	  return dec_value					    	return dec_value					  
  }							      								    								  
  return dec_value ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_XOR_VALUE_PAIR					      MINIMUM_XOR_VALUE_PAIR					    MINIMUM_XOR_VALUE_PAIR					  MINIMUM_XOR_VALUE_PAIR
--							      --							    --								  --
static int minXOR ( int arr [ ] , int n ) {		      def minXOR ( arr , n ) :					    def minXOR ( arr , n ) :					  failure : #Results: 8, 10
  int min_xor = Integer . MAX_VALUE ;			      	  arr.sort ( )						    	minXOR = sys.maxsize					  
  for ( int i = 0 ;					      	  min_xor = 999999					    	for i in range ( n ) :					  
  i < n ;						      	  val = 0						    	    for j in range ( i + 1 , n ) :			  
  i ++ ) for ( int j = i + 1 ;				      	  for i in range ( 0 , n - 1 ) :			    		minXOR = min ( minXOR , arr [ i ] ^ arr [ j ] )	  
  j < n ;						      	      for j in range ( i + 1 , n - 1 ) :		    	return minXOR						  
  j ++ ) min_xor = Math . min ( min_xor , arr [ i ] ^ arr [ j 		  val = arr [ i ] ^ arr [ j ]			    								  
  return min_xor ;					      		  min_xor = min ( min_xor , val )		    								  
}							      	  return min_xor					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		      HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		    HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		  HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION
--							      --							    --								  --
static long mulmod ( long a , long b , long mod ) {	      def mulmod ( a , b , mod ) :				    def mulmod ( a , b , mod ) :				  success : None
  long res = 0 ;					      	  res = 0						    	res = 0							  
  a = a % mod ;						      	  a = a % mod						    	a = a % mod						  
  while ( b > 0 ) {					      	  while ( b > 0 ) :					    	while b > 0 :						  
    if ( b % 2 == 1 ) {					      	      if ( b % 2 == 1 ) :				    	    if b % 2 == 1 :					  
      res = ( res + a ) % mod ;				      		  res = ( res + a ) % mod			    		res = ( res + a ) % mod				  
    }							      	      a = ( a * 2 ) % mod				    	    a = ( a * 2 ) % mod					  
    a = ( a * 2 ) % mod ;				      	      b //= 2						    	    b //= 2						  
    b /= 2 ;						      	  return res % mod					    	return res % mod					  
  }							      								    								  
  return res % mod ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE			  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE
--							      --							    --								  --
public static String recursiveReverse ( char [ ] str ) {      def recursiveReverse ( str ) :				    def recursive_reverse ( data ) :				  error : Traceback (most recent call last):   File
  Stack < Character > st = new Stack < > ( ) ;		      	  stack = [ ]						    	st = [ ]						  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int i = 0 ;					      	  for i in range ( len ( str ) ) :			    	for c in data :						  68770/eval_scripts/java_sa-python_sa.test/PROGRAM_
  i < str . length ;					      	      stack.append ( str [ i ] )			    	    st.append ( c )					  REVERSE_STRING_ITERATIVE_RECURSIVE.py", line 62, i
  i ++ ) st . push ( str [ i ] ) ;			      	  for i in range ( len ( str ) ) :			    	for c in data :						  n <module>	 f_filled(*(filled_function_param[i]
  for ( int i = 0 ;					      	      str [ i ] = stack.pop ( )				    	    data [ c ] = st [ - 1 ]				  ))   File "dump/transcoder_st/eval/java_python/onl
  i < str . length ;					      								    	    st.pop ( )						  ine_st/20668770/eval_scripts/java_sa-python_sa.tes
  i ++ ) {						      								    	return ''.join ( data )					  t/PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE.py",
    str [ i ] = st . peek ( ) ;				      								    								  line 30, in f_filled	   data [ c ] = st [ - 1 ] T
    st . pop ( ) ;					      								    								  ypeError: list indices must be integers or slices,
  }							      								    								   not str
  return String . valueOf ( str ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_NON_FIBONACCI_NUMBER				      NTH_NON_FIBONACCI_NUMBER					    NTH_NON_FIBONACCI_NUMBER					  NTH_NON_FIBONACCI_NUMBER
--							      --							    --								  --
static int nonFibonacci ( int n ) {			      def nonFibonacci ( n ) :					    def non_fibonacci ( n ) :					  success : None
  int prevPrev = 1 , prev = 2 , curr = 3 ;		      	  prevPrev = 1						    	prev_prev , prev , curr = 1 , 2 , 3			  
  while ( n > 0 ) {					      	  prev = 2						    	while n > 0 :						  
    prevPrev = prev ;					      	  curr = 3						    	    prev_prev = prev					  
    prev = curr ;					      	  while n > 0 :						    	    prev = curr						  
    curr = prevPrev + prev ;				      	      prevPrev = prev					    	    curr = prev_prev + prev				  
    n = n - ( curr - prev - 1 ) ;			      	      prev = curr					    	    n = n - ( curr - prev - 1 )				  
  }							      	      curr = prevPrev + prev				    	n = n + ( curr - prev - 1 )				  
  n = n + ( curr - prev - 1 ) ;				      	      n = n - ( curr - prev - 1 )			    	return prev + n						  
  return prev + n ;					      	  n = n + ( curr - prev - 1 )				    								  
}							      	  return prev + n					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_
--							      --							    --								  --
static int multiply ( int x , int y ) {			      def multiply ( x , y ) :					    def multiply ( x , y ) :					  success : None
  if ( y == 0 ) return 0 ;				      	  if ( y == 0 ) :					    	if not y :						  
  if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ;	      	      return 0						    	    return 0						  
  if ( y < 0 ) return - multiply ( x , - y ) ;		      	  if ( y > 0 ) :					    	if y > 0 :						  
  return - 1 ;						      	      return ( x + multiply ( x , y - 1 ) )		    	    return ( x + multiply ( x , y - 1 ) )		  
}							      	  if ( y < 0 ) :					    	if y < 0 :						  
							      	      return - multiply ( x , - y )			    	    return - multiply ( x , - y )			  
							      								    	return - 1						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NON_REPEATING_ELEMENT					      NON_REPEATING_ELEMENT					    NON_REPEATING_ELEMENT					  NON_REPEATING_ELEMENT
--							      --							    --								  --
static int firstNonRepeating ( int arr [ ] , int n ) {	      def firstNonRepeating ( arr , n ) :			    def first_non_repeating ( arr , n ) :			  failure : #Results: 3, 10
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      j = 0						    	    j = 0						  
  i ++ ) {						      	      while ( j < n ) :					    	    for j in range ( n ) :				  
    int j ;						      		  if ( i != j and arr [ i ] == arr [ j ] ) :	    		if i != j and arr [ i ] == arr [ j ] :		  
    for ( j = 0 ;					      		      break					    		    break					  
    j < n ;						      		  j += 1					    	    if j == n :						  
    j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ;    	      if ( j == n ) :					    		return arr [ i ]				  
    if ( j == n ) return arr [ i ] ;			      		  return arr [ i ]				    	return - 1						  
  }							      	  return - 1						    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	      COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	    COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	  COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS
--							      --							    --								  --
static int countSubstringWithEqualEnds ( String s ) {	      def countSubstringWithEqualEnds ( s ) :			    def count_substring_with_equal_ends ( s ) :			  success : None
  int result = 0 ;					      	  result = 0						    	result = 0						  
  int n = s . length ( ) ;				      	  n = len ( s )						    	n = len ( s )						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i , n ) :			    	    for j in range ( i , n ) :				  
  i ++ ) for ( int j = i ;				      		  if ( s [ i ] == s [ j ] ) :			    		if s [ i ] == s [ j ] :				  
  j < n ;						      		      result = result + 1			    		    result += 1					  
  j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result + 	  return result						    	return result						  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EQUILIBRIUM_INDEX_OF_AN_ARRAY_1				      EQUILIBRIUM_INDEX_OF_AN_ARRAY_1				    EQUILIBRIUM_INDEX_OF_AN_ARRAY_1				  EQUILIBRIUM_INDEX_OF_AN_ARRAY_1
--							      --							    --								  --
int equilibrium ( int arr [ ] , int n ) {		      def equilibrium ( arr ) :					    def equilibrium ( arr , n ) :				  script_not_found : None
  int sum = 0 ;						      	  total_sum = sum ( arr )				    	sum = 0							  
  int leftsum = 0 ;					      	  leftsum = 0						    	leftsum = 0						  
  for ( int i = 0 ;					      	  for i , num in enumerate ( arr ) :			    	for i in range ( n ) :					  
  i < n ;						      	      total_sum -= num					    	    sum += arr [ i ]					  
  ++ i ) sum += arr [ i ] ;				      	      if leftsum == total_sum :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      		  return i					    	    sum -= arr [ i ]					  
  i < n ;						      	      leftsum += num					    	    if leftsum == sum :					  
  ++ i ) {						      	  return - 1						    		return i					  
    sum -= arr [ i ] ;					      								    	    leftsum += arr [ i ]				  
    if ( leftsum == sum ) return i ;			      								    	return - 1						  
    leftsum += arr [ i ] ;				      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI
--							      --							    --								  --
static int countNegative ( int M [ ] [ ] , int n , int m ) {  def countNegative ( M , n , m ) :				    def count_negative ( M , n , m ) :				  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( m ) :				    	    for j in range ( m ) :				  
  i ++ ) {						      		  if M [ i ] [ j ] < 0 :			    		if M [ i ] [ j ] < 0 :				  
    for ( int j = 0 ;					      		      count += 1				    		    count += 1					  
    j < m ;						      		  else :					    		else :						  
    j ++ ) {						      		      break					    		    break					  
      if ( M [ i ] [ j ] < 0 ) count += 1 ;		      	  return count						    	return count						  
      else break ;					      								    								  
    }							      								    								  
  }							      								    								  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND
--							      --							    --								  --
static int countSeq ( int n ) {				      def countSeq ( n ) :					    def count_seq ( n ) :					  failure : #Results: 5, 10
  int nCr = 1 , res = 1 ;				      	  nCr = 1						    	n_cr , res = 1 , 1					  
  for ( int r = 1 ;					      	  res = 1						    	for r in range ( 1 , n + 1 ) :				  
  r <= n ;						      	  for r in range ( 1 , n + 1 ) :			    	    n_cr = ( n_cr * ( n + 1 - r ) ) // r		  
  r ++ ) {						      	      nCr = ( nCr * ( n + 1 - r ) ) / r ;		    	    res += n_cr * n_cr					  
    nCr = ( nCr * ( n + 1 - r ) ) / r ;			      	      res += nCr * nCr ;				    	return res						  
    res += nCr * nCr ;					      	  return res ;						    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		      PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		    PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		  PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES
--							      --							    --								  --
static boolean isPrime ( int p ) {			      def isPrime ( p ) :					    def is_prime ( p ) :					  failure : #Results: 9, 10
  double checkNumber = Math . pow ( 2 , p ) - 1 ;	      	  checkNumber = 2 ** p - 1				    	check_number = pow ( 2 , p ) - 1			  
  double nextval = 4 % checkNumber ;			      	  nextval = 4 % checkNumber				    	nextval = 4 % check_number				  
  for ( int i = 1 ;					      	  for i in range ( 1 , p - 1 ) :			    	for i in range ( 1 , p - 1 ) :				  
  i < p - 1 ;						      	      nextval = ( nextval * nextval - 2 ) % checkNumber	    	    nextval = ( nextval * nextval - 2 ) % check_number	  
  i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;  	  if ( nextval == 0 ) : return True			    	return ( nextval == 0 )					  
  return ( nextval == 0 ) ;				      	  else : return False					    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_XOR_VALUE_PAIR_1				      MINIMUM_XOR_VALUE_PAIR_1					    MINIMUM_XOR_VALUE_PAIR_1					  MINIMUM_XOR_VALUE_PAIR_1
--							      --							    --								  --
static int minXOR ( int arr [ ] , int n ) {		      def minXOR ( arr , n ) :					    def minXOR ( arr , n ) :					  success : None
  Arrays . parallelSort ( arr ) ;			      	  arr.sort ( )						    	arr.sort ( )						  
  int minXor = Integer . MAX_VALUE ;			      	  minXor = int ( sys.float_info.max )			    	minXor = sys.maxsize					  
  int val = 0 ;						      	  val = 0						    	val = 0							  
  for ( int i = 0 ;					      	  for i in range ( 0 , n - 1 ) :			    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      val = arr [ i ] ^ arr [ i + 1 ]			    	    val = arr [ i ] ^ arr [ i + 1 ]			  
  i ++ ) {						      	      minXor = min ( minXor , val )			    	    minXor = min ( minXor , val )			  
    val = arr [ i ] ^ arr [ i + 1 ] ;			      	  return minXor						    	return minXor						  
    minXor = Math . min ( minXor , val ) ;		      								    								  
  }							      								    								  
  return minXor ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BINARY_SEARCH_1						      BINARY_SEARCH_1						    BINARY_SEARCH_1						  BINARY_SEARCH_1
--							      --							    --								  --
int binarySearch ( int arr [ ] , int x ) {		      def binarySearch ( arr , l , r , x ) :			    def binary_search ( arr , x ) :				  script_not_found : None
  int l = 0 , r = arr . length - 1 ;			      	  while l <= r :					    	l , r = 0 , len ( arr ) - 1				  
  while ( l <= r ) {					      	      mid = l + ( r - l ) // 2				    	while l <= r :						  
    int m = l + ( r - l ) / 2 ;				      	      if arr [ mid ] == x :				    	    m = l + ( r - l ) // 2				  
    if ( arr [ m ] == x ) return m ;			      		  return mid					    	    if arr [ m ] == x :					  
    if ( arr [ m ] < x ) l = m + 1 ;			      	      elif arr [ mid ] < x :				    		return m					  
    else r = m - 1 ;					      		  l = mid + 1					    	    if arr [ m ] < x :					  
  }							      	      else :						    		l = m + 1					  
  return - 1 ;						      		  r = mid - 1					    	    else :						  
}							      	  return - 1						    		r = m - 1					  
							      								    	return - 1						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		      NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		    NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		  NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N
--							      --							    --								  --
static int countIntegralSolutions ( int n ) {		      def countIntegralSolutions ( n ) :			    def count_integral_solutions ( n ) :			  success : None
  int result = 0 ;					      	  result = 0						    	result = 0						  
  for ( int i = 0 ;					      	  for i in range ( n + 1 ) :				    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      for j in range ( n + 1 ) :			    	    for j in range ( 0 , n - i + 1 ) :			  
  i ++ ) for ( int j = 0 ;				      		  for k in range ( n + 1 ) :			    		for k in range ( 0 , ( n - i - j ) + 1 ) :	  
  j <= n - i ;						      		      if i + j + k == n :			    		    if i + j + k == n :				  
  j ++ ) for ( int k = 0 ;				      			  result += 1				    			result += 1				  
  k <= ( n - i - j ) ;					      	  return result						    	return result						  
  k ++ ) if ( i + j + k == n ) result ++ ;		      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC	      MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC	    MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC		  MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC
--							      --							    --								  --
static int power ( int x , int y , int p ) {		      def power ( x , y , p ) :					    def power ( x , y , p ) :					  success : None
  int res = 1 ;						      	  res = 1						    	res = 1							  
  x = x % p ;						      	  x = x % p						    	x = x % p						  
  while ( y > 0 ) {					      	  while ( y > 0 ) :					    	while y > 0 :						  
    if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ;	      	      if ( ( y & 1 ) == 1 ) :				    	    if ( y & 1 ) == 1 :					  
    y = y >> 1 ;					      		  res = ( res * x ) % p				    		res = ( res * x ) % p				  
    x = ( x * x ) % p ;					      	      y = y >> 1					    	    y = y >> 1						  
  }							      	      x = ( x * x ) % p					    	    x = ( x * x ) % p					  
  return res ;						      	  return res						    	return res						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_PERIMETER_N_BLOCKS				      MINIMUM_PERIMETER_N_BLOCKS				    MINIMUM_PERIMETER_N_BLOCKS					  MINIMUM_PERIMETER_N_BLOCKS
--							      --							    --								  --
public static long minPerimeter ( int n ) {		      def minPerimeter ( n ) :					    def min_perimeter ( n ) :					  failure : #Results: 0, 10
  int l = ( int ) Math . sqrt ( n ) ;			      	  l = math.sqrt ( n )					    	l = int ( math.sqrt ( n ) )				  
  int sq = l * l ;					      	  sq = l * l						    	sq = l * l						  
  if ( sq == n ) return l * 4 ;				      	  if ( sq == n ) :					    	if sq == n :						  
  else {						      	      return l * 4					    	    return l * 4					  
    long row = n / l ;					      	  else :						    	else :							  
    long perimeter = 2 * ( l + row ) ;			      	      row = n / l					    	    row = n // l					  
    if ( n % l != 0 ) perimeter += 2 ;			      	      perimeter = 2 * ( l + row )			    	    perimeter = 2 * ( l + row )				  
    return perimeter ;					      	      if ( n % l != 0 ) :				    	    if n % l != 0 :					  
  }							      		  perimeter += 2				    		perimeter += 2					  
}							      	      return perimeter					    	    return perimeter					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2
--							      --							    --								  --
static int numberOfPaths ( int m , int n ) {		      def numberOfPaths ( p , q ) :				    def numberOfPaths ( m , n ) :				  success : None
  int [ ] dp = new int [ n ] ;				      	  dp = [ 1 for i in range ( q ) ]			    	dp = [ 0 ] * n						  
  dp [ 0 ] = 1 ;					      	  for i in range ( p - 1 ) :				    	dp [ 0 ] = 1						  
  for ( int i = 0 ;					      	      for j in range ( 1 , q ) :			    	for i in range ( m ) :					  
  i < m ;						      		  dp [ j ] += dp [ j - 1 ]			    	    for j in range ( 1 , n ) :				  
  i ++ ) {						      	  return dp [ q - 1 ]					    		dp [ j ] += dp [ j - 1 ]			  
    for ( int j = 1 ;					      								    	return dp [ n - 1 ]					  
    j < n ;						      								    								  
    j ++ ) {						      								    								  
      dp [ j ] += dp [ j - 1 ] ;			      								    								  
    }							      								    								  
  }							      								    								  
  return dp [ n - 1 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1
--							      --							    --								  --
static int isPowerOfFour ( int n ) {			      def isPowerOfFour ( n ) :					    def is_power_of_four ( n ) :				  failure : #Results: 5, 10
  int count = 0 ;					      	  count = 0						    	count = 0						  
  int x = n & ( n - 1 ) ;				      	  if ( n and ( not ( n & ( n - 1 ) ) ) ) :		    	x = n & ( n - 1 )					  
  if ( n > 0 && x == 0 ) {				      	      while ( n > 1 ) :					    	if n > 0 and x == 0 :					  
    while ( n > 1 ) {					      		  n >>= 1					    	    while n > 1 :					  
      n >>= 1 ;						      		  count += 1					    		n >>= 1						  
      count += 1 ;					      	      if ( count % 2 == 0 ) :				    		count += 1					  
    }							      		  return True					    	    return ( 1 if count % 2 == 0 else 0 )		  
    return ( count % 2 == 0 ) ? 1 : 0 ;			      	      else :						    	return 0						  
  }							      		  return False					    								  
  return 0 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE
--							      --							    --								  --
static void subArray ( int n ) {			      def subArray ( arr , n ) :				    def sub_array ( n ) :					  script_not_found : None
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i , n ) :			    	    for j in range ( i , n ) :				  
  i ++ ) {						      		  for k in range ( i , j + 1 ) :		    		for k in range ( i , j + 1 ) :			  
    for ( int j = i ;					      		      print ( arr [ k ] , end = "" )		    		    print ( arr [ k ] , end = ' ' )		  
    j < n ;						      		  print ( "\n" , end = "" )			    								  
    j ++ ) {						      								    								  
      for ( int k = i ;					      								    								  
      k <= j ;						      								    								  
      k ++ ) System . out . print ( arr [ k ] + " " ) ;	      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DIVISIBLE_PAIRS_ARRAY				      COUNT_DIVISIBLE_PAIRS_ARRAY				    COUNT_DIVISIBLE_PAIRS_ARRAY					  COUNT_DIVISIBLE_PAIRS_ARRAY
--							      --							    --								  --
static int countDivisibles ( int arr [ ] , int n ) {	      def countDivisibles ( arr , n ) :				    def count_divisibles ( arr , n ) :				  script_not_found : None
  int res = 0 ;						      	  res = 0						    	res = 0							  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) for ( int j = i + 1 ;				      		  if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % ar 		if arr [ i ] % arr [ j ] == 0 or arr [ j ] % arr  
  j < n ;						      		      res += 1					    		    res += 1					  
  j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ 	  return res						    	return res						  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_WAYS_BREAK_STRING_BRACKET_FORM			      PRINT_WAYS_BREAK_STRING_BRACKET_FORM			    PRINT_WAYS_BREAK_STRING_BRACKET_FORM			  PRINT_WAYS_BREAK_STRING_BRACKET_FORM
--							      --							    --								  --
static void findCombinations ( String str , int index , Strin def findCombinations ( string , index , out ) :		    def findCombinations ( str , index , out ) :		  script_not_found : None
  if ( index == str . length ( ) ) System . out . println ( o 	  if index == len ( string ) :				    	if index == len ( str ) :				  
  for ( int i = index ;					      	      print ( out )					    	    print ( out )					  
  i < str . length ( ) ;				      	  for i in range ( index , len ( string ) , 1 ) :	    	for i in range ( index , len ( str ) ) :		  
  i ++ ) findCombinations ( str , i + 1 , out + "(" + str . s 	      findCombinations ( string , i + 1 , out + "(" + strin 	    findCombinations ( str , i + 1 , out + '(' + str [ in 
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION			      PROGRAM_DECIMAL_BINARY_CONVERSION				    PROGRAM_DECIMAL_BINARY_CONVERSION				  PROGRAM_DECIMAL_BINARY_CONVERSION
--							      --							    --								  --
static void decToBinary ( int n ) {			      def decToBinary ( n ) :					    def dec_to_binary ( n ) :					  script_not_found : None
  int [ ] binaryNum = new int [ 32 ] ;			      	  binaryNum = [ 0 ] * n					    	binary_num = [ 0 ] * 32					  
  int i = 0 ;						      	  i = 0							    	i = 0							  
  while ( n > 0 ) {					      	  while ( n > 0 ) :					    	while n > 0 :						  
    binaryNum [ i ] = n % 2 ;				      	      binaryNum [ i ] = n % 2				    	    binary_num [ i ] = n % 2				  
    n = n / 2 ;						      	      n = int ( n / 2 )					    	    n = n // 2						  
    i ++ ;						      	      i += 1						    	    i += 1						  
  }							      	  for j in range ( i - 1 , - 1 , - 1 ) :		    	for j in range ( i - 1 , - 1 , - 1 ) :			  
  for ( int j = i - 1 ;					      	      print ( binaryNum [ j ] , end = "" )		    	    print ( binary_num [ j ] , end = ' ' )		  
  j >= 0 ;						      								    								  
  j -- ) System . out . print ( binaryNum [ j ] ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		      PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		    PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		  PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2
--							      --							    --								  --
static void printDistinct ( int arr [ ] ) {		      def printDistinct ( arr , n ) :				    def printDistinct ( arr ) :					  script_not_found : None
  HashSet < Integer > set = new HashSet < > ( ) ;	      	  s = dict ( )						    	seen = set ( )						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( len ( arr ) ) :			  
  i < arr . length ;					      	      if ( arr [ i ] not in s.keys ( ) ) :		    	    if arr [ i ] not in seen :				  
  i ++ ) {						      		  s [ arr [ i ] ] = arr [ i ]			    		seen.add ( arr [ i ] )				  
    if ( ! set . contains ( arr [ i ] ) ) {		      		  print ( arr [ i ] , end = " " )		    		print ( arr [ i ] , end = ' ' )			  
      set . add ( arr [ i ] ) ;				      								    								  
      System . out . print ( arr [ i ] + " " ) ;	      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION
--							      --							    --								  --
public static int nearestSmallerEqFib ( int n ) {	      def nearestSmallerEqFib ( n ) :				    def nearest_smaller_eq_fib ( n ) :				  success : None
  if ( n == 0 || n == 1 ) return n ;			      	  if ( n == 0 or n == 1 ) :				    	if not n or n == 1 :					  
  int f1 = 0 , f2 = 1 , f3 = 1 ;			      	      return n						    	    return n						  
  while ( f3 <= n ) {					      	  f1 , f2 , f3 = 0 , 1 , 1				    	f1 , f2 , f3 = 0 , 1 , 1				  
    f1 = f2 ;						      	  while ( f3 <= n ) :					    	while f3 <= n :						  
    f2 = f3 ;						      	      f1 = f2 ;						    	    f1 = f2						  
    f3 = f1 + f2 ;					      	      f2 = f3 ;						    	    f2 = f3						  
  }							      	      f3 = f1 + f2 ;					    	    f3 = f1 + f2					  
  return f2 ;						      	  return f2 ;						    	return f2						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM   DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM   DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM	  DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM
--							      --							    --								  --
static int maxTasks ( int high [ ] , int low [ ] , int n ) {  def maxTasks ( high , low , n ) :				    def max_tasks ( high , low , n ) :				  success : None
  if ( n <= 0 ) return 0 ;				      	  if ( n <= 0 ) :					    	if n <= 0 :						  
  return Math . max ( high [ n - 1 ] + maxTasks ( high , low  	      return 0						    	    return 0						  
}							      	  return max ( high [ n - 1 ] + maxTasks ( high , low , ( n 	return max ( high [ n - 1 ] + max_tasks ( high , low , (  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_CONWAY_SEQUENCE_1				      NEWMAN_CONWAY_SEQUENCE_1					    NEWMAN_CONWAY_SEQUENCE_1					  NEWMAN_CONWAY_SEQUENCE_1
--							      --							    --								  --
static int sequence ( int n ) {				      def sequence ( n ) :					    def sequence ( n ) :					  script_not_found : None
  int f [ ] = new int [ n + 1 ] ;			      	  f = array.array ( 'i' , [ 0 , 1 , 1 ] )		    	f = [ 0 ] * ( n + 1 )					  
  f [ 0 ] = 0 ;						      	  for i in range ( 3 , n + 1 ) :			    	f [ 0 ] = 0						  
  f [ 1 ] = 1 ;						      	      r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]	    	f [ 1 ] = 1						  
  f [ 2 ] = 1 ;						      	      f.append ( r ) ;					    	f [ 2 ] = 1						  
  int i ;						      	  return r						    	i = 0							  
  for ( i = 3 ;						      								    	for i in range ( 3 , n + 1 ) :				  
  i <= n ;						      								    	    f [ i ] = f [ i - 1 ] + f [ i - f [ i - 1 ] ]	  
  i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]  								    	return f [ n ]						  
  return f [ n ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_GAMES_PLAYED_WINNER				      MAXIMUM_GAMES_PLAYED_WINNER				    MAXIMUM_GAMES_PLAYED_WINNER					  MAXIMUM_GAMES_PLAYED_WINNER
--							      --							    --								  --
static int maxGameByWinner ( int N ) {			      def maxGameByWinner ( N ) :				    def max_game_by_winner ( N ) :				  error : Traceback (most recent call last):   File
  int [ ] dp = new int [ N ] ;				      	  dp = [ 0 for i in range ( N ) ]			    	dp = [ 1 ] * N						  "dump/transcoder_st/eval/java_python/online_st/206
  dp [ 0 ] = 1 ;					      	  dp [ 0 ] = 1						    	dp [ 0 ] = 1						  68770/eval_scripts/java_sa-python_sa.test/MAXIMUM_
  dp [ 1 ] = 2 ;					      	  dp [ 1 ] = 2						    	dp [ 1 ] = 2						  GAMES_PLAYED_WINNER.py", line 54, in <module>
  int i = 2 ;						      	  i = 1							    	i = 2							  if f_filled(*parameters_set) == f_gold(*parameters
  do {							      	  while dp [ i ] <= N :					    	while True :						  _set):   File "dump/transcoder_st/eval/java_python
    dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ;		      	      i = i + 1						    	    dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]		  /online_st/20668770/eval_scripts/java_sa-python_sa
  }							      	      dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]		    	    i += 1						  .test/MAXIMUM_GAMES_PLAYED_WINNER.py", line 34, in
  while ( dp [ i ++ ] <= N ) ;				      	  return ( i - 1 )					    	return ( i - 2 )					   f_filled	dp [ i ] = dp [ i - 1 ] + dp [ i - 2
  return ( i - 2 ) ;					      								    								   ] IndexError: list assignment index out of range
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_OPERATIONS_MAKE_STRINGAB_FREE			      COUNT_OPERATIONS_MAKE_STRINGAB_FREE			    COUNT_OPERATIONS_MAKE_STRINGAB_FREE				  COUNT_OPERATIONS_MAKE_STRINGAB_FREE
--							      --							    --								  --
static int abFree ( char [ ] s ) {			      def abFree ( s ) :					    def abFree ( s ) :						  success : None
  int b_count = 0 ;					      	  b_count = 0						    	b_count = 0						  
  int res = 0 ;						      	  res = 0						    	res = 0							  
  for ( int i = 0 ;					      	  for i in range ( len ( s ) ) :			    	for i in range ( len ( s ) ) :				  
  i < s . length ;					      	      if s [ ~ i ] == 'a' :				    	    if s [ - i - 1 ] == 'a' :				  
  i ++ ) {						      		  res = ( res + b_count )			    		res = ( res + b_count )				  
    if ( s [ s . length - i - 1 ] == 'a' ) {		      		  b_count = ( b_count * 2 )			    		b_count = ( b_count * 2 )			  
      res = ( res + b_count ) ;				      	      else :						    	    else :						  
      b_count = ( b_count * 2 ) ;			      		  b_count += 1					    		b_count += 1					  
    }							      	  return res						    	return res						  
    else {						      								    								  
      b_count += 1 ;					      								    								  
    }							      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING	      CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING		    CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING		  CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING
--							      --							    --								  --
static int findSum ( String str ) {			      def findSum ( str1 ) :					    def find_sum ( data ) :					  script_not_found : None
  String temp = "" ;					      	  temp = ""						    	temp = ""						  
  int sum = 0 ;						      	  Sum = 0						    	sum = 0							  
  for ( int i = 0 ;					      	  for ch in str1 :					    	for ch in data :					  
  i < str . length ( ) ;				      	      if ( ch.isdigit ( ) ) :				    	    if ch.isdigit ( ) :					  
  i ++ ) {						      		  temp += ch					    		temp += ch					  
    char ch = str . charAt ( i ) ;			      	      else :						    	    else :						  
    if ( Character . isDigit ( ch ) ) temp += ch ;	      		  Sum += int ( temp )				    		sum += int ( temp )				  
    else {						      		  temp = "0"					    		temp = "0"					  
      sum += Integer . parseInt ( temp ) ;		      	  return Sum + int ( temp )				    	return sum + int ( temp )				  
      temp = "0" ;					      								    								  
    }							      								    								  
  }							      								    								  
  return sum + Integer . parseInt ( temp ) ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY		      PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY		    PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY			  PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY
--							      --							    --								  --
static void printDistinct ( int arr [ ] , int n ) {	      def printDistinct ( arr , n ) :				    def printDistinct ( arr , n ) :				  script_not_found : None
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      d = 0						    	    for j in range ( i ) :				  
  i ++ ) {						      	      for j in range ( 0 , i ) :			    		if arr [ i ] == arr [ j ] :			  
    int j ;						      		  if ( arr [ i ] == arr [ j ] ) :		    		    break					  
    for ( j = 0 ;					      		      d = 1					    	    if i == j :						  
    j < i ;						      		      break					    		print ( arr [ i ] , end = ' ' )			  
    j ++ ) if ( arr [ i ] == arr [ j ] ) break ;	      	      if ( d == 0 ) :					    								  
    if ( i == j ) System . out . print ( arr [ i ] + " " ) ;  		  print ( arr [ i ] )				    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		      FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		    FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		  FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS
--							      --							    --								  --
static void findElements ( int arr [ ] , int n ) {	      def findElements ( arr , n ) :				    def find_elements ( arr , n ) :				  script_not_found : None
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      count = 0						    	    count = 0						  
  i ++ ) {						      	      for j in range ( 0 , n ) :			    	    for j in range ( n ) :				  
    int count = 0 ;					      		  if arr [ j ] > arr [ i ] :			    		if arr [ j ] > arr [ i ] :			  
    for ( int j = 0 ;					      		      count = count + 1				    		    count += 1					  
    j < n ;						      	      if count >= 2 :					    	    if count >= 2 :					  
    j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ;	      		  print ( arr [ i ] , end = " " )		    		print ( arr [ i ] , end = ' ' )			  
    if ( count >= 2 ) System . out . print ( arr [ i ] + " "  								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_PRINT_IDENTITY_MATRIX_1				      PROGRAM_PRINT_IDENTITY_MATRIX_1				    PROGRAM_PRINT_IDENTITY_MATRIX_1				  PROGRAM_PRINT_IDENTITY_MATRIX_1
--							      --							    --								  --
static boolean isIdentity ( int mat [ ] [ ] , int N ) {	      def isIdentity ( mat , N ) :				    def is_identity ( mat , N ) :				  success : None
  for ( int row = 0 ;					      	  for row in range ( N ) :				    	for row in range ( N ) :				  
  row < N ;						      	      for col in range ( N ) :				    	    for col in range ( N ) :				  
  row ++ ) {						      		  if ( row == col and mat [ row ] [ col ] != 1 ) :  		if row == col and mat [ row ] [ col ] != 1 :	  
    for ( int col = 0 ;					      		      return False				    		    return False				  
    col < N ;						      		  elif ( row != col and mat [ row ] [ col ] != 0 )  		elif row != col and mat [ row ] [ col ] != 0 :	  
    col ++ ) {						      		      return False				    		    return False				  
      if ( row == col && mat [ row ] [ col ] != 1 ) return fa 	  return True						    	return True						  
      else if ( row != col && mat [ row ] [ col ] != 0 ) retu 								    								  
    }							      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		      SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		    SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		  SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1
--							      --							    --								  --
static int insertSorted ( int arr [ ] , int n , int key , int def insertSorted ( arr , n , key , capacity ) :		    def insert_sorted ( arr , n , key , capacity ) :		  success : None
  if ( n >= capacity ) return n ;			      	  if ( n >= capacity ) :				    	if n >= capacity :					  
  int i ;						      	      return n						    	    return n						  
  for ( i = n - 1 ;					      	  i = n - 1						    	i = 0							  
  ( i >= 0 && arr [ i ] > key ) ;			      	  while i >= 0 and arr [ i ] > key :			    	for i in range ( n - 1 , ( n - 1 ) , - 1 ) :		  
  i -- ) arr [ i + 1 ] = arr [ i ] ;			      	      arr [ i + 1 ] = arr [ i ]				    	    arr [ i + 1 ] = arr [ i ]				  
  arr [ i + 1 ] = key ;					      	      i -= 1						    	arr [ i + 1 ] = key					  
  return ( n + 1 ) ;					      	  arr [ i + 1 ] = key					    	return ( n + 1 )					  
}							      	  return ( n + 1 )					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY		      MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY		    MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY			  MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY
--							      --							    --								  --
static int solve ( int arr [ ] , int n ) {		      def solve ( arr , n ) :					    def solve ( arr , n ) :					  success : None
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  int a = 0 , b = 0 ;					      	  a = 0 b = 0						    	a , b = 0 , 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( i % 2 != 0 ) :				    	    if i % 2 :						  
  i ++ ) {						      		  a = a * 10 + arr [ i ]			    		a = a * 10 + arr [ i ]				  
    if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ;		      	      else :						    	    else :						  
    else b = b * 10 + arr [ i ] ;			      		  b = b * 10 + arr [ i ]			    		b = b * 10 + arr [ i ]				  
  }							      	  return a + b						    	return a + b						  
  return a + b ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_FACTORS_NUMBER					      SUM_FACTORS_NUMBER					    SUM_FACTORS_NUMBER						  SUM_FACTORS_NUMBER
--							      --							    --								  --
static int divSum ( int n ) {				      def divSum ( n ) :					    def div_sum ( n ) :						  error : Traceback (most recent call last):   File
  int result = 0 ;					      	  result = 0						    	result = 0						  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int i = 2 ;					      	  for i in range ( 2 , ( int ) ( math.sqrt ( n ) ) + 1 ) :  	for i in range ( 2 , math.sqrt ( n ) + 1 ) :		  68770/eval_scripts/java_sa-python_sa.test/SUM_FACT
  i <= Math . sqrt ( n ) ;				      	      if ( n % i == 0 ) :				    	    if n % i == 0 :					  ORS_NUMBER.py", line 56, in <module>	   if f_fill
  i ++ ) {						      		  if ( i == ( n / i ) ) :			    		if i == ( n // i ) :				  ed(*parameters_set) == f_gold(*parameters_set):
    if ( n % i == 0 ) {					      		      result = result + i			    		    result += i					  File "dump/transcoder_st/eval/java_python/online_s
      if ( i == ( n / i ) ) result += i ;		      		  else :					    		else :						  t/20668770/eval_scripts/java_sa-python_sa.test/SUM
      else result += ( i + n / i ) ;			      		      result = result + ( i + n // i )		    		    result += ( i + n // i )			  _FACTORS_NUMBER.py", line 32, in f_filled	for
    }							      	  return ( result + n + 1 )				    	return ( result + n + 1 )				  i in range ( 2 , math.sqrt ( n ) + 1 ) : TypeError
  }							      								    								  : 'float' object cannot be interpreted as an integ
  return ( result + n + 1 ) ;				      								    								  er
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	      WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	    WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	  WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS
--							      --							    --								  --
static int countWays ( int n ) {			      def CountWays ( n ) :					    def count_ways ( n ) :					  script_not_found : None
  int table [ ] = new int [ n + 1 ] ;			      	  table = [ 0 ] * ( n + 1 )				    	table = [ 0 ] * ( n + 1 )				  
  Arrays . fill ( table , 0 ) ;				      	  table [ 0 ] = 1					    	table [ 0 ] = 1						  
  table [ 0 ] = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      	      for j in range ( i , n + 1 ) :			    	    for j in range ( i , n + 1 ) :			  
  i < n ;						      		  table [ j ] += table [ j - i ]		    		table [ j ] += table [ j - i ]			  
  i ++ ) for ( int j = i ;				      	  return table [ n ]					    	return table [ n ]					  
  j <= n ;						      								    								  
  j ++ ) table [ j ] += table [ j - i ] ;		      								    								  
  return table [ n ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_STRING_BINARY_SEQUENCE				      CONVERT_STRING_BINARY_SEQUENCE				    CONVERT_STRING_BINARY_SEQUENCE				  CONVERT_STRING_BINARY_SEQUENCE
--							      --							    --								  --
static void strToBinary ( String s ) {			      def strToBinary ( s ) :					    def strToBinary ( s ) :					  script_not_found : None
  int n = s . length ( ) ;				      	  bin_conv = [ ]					    	n = len ( s )						  
  for ( int i = 0 ;					      	  for c in s :						    	for i in range ( n ) :					  
  i < n ;						      	      ascii_val = ord ( c )				    	    val = ord ( s [ i ] )				  
  i ++ ) {						      	      binary_val = bin ( ascii_val )			    	    bin = ""						  
    int val = Integer . valueOf ( s . charAt ( i ) ) ;	      	      bin_conv.append ( binary_val [ 2 : ] )		    	    while val > 0 :					  
    String bin = "" ;					      	  return ( ' '.join ( bin_conv ) )			    		if val % 2 == 1 :				  
    while ( val > 0 ) {					      								    		    bin += '1'					  
      if ( val % 2 == 1 ) {				      								    		else :						  
	bin += '1' ;					      								    		    bin += '0'					  
      }							      								    		val //= 2					  
      else bin += '0' ;					      								    	    bin = reverse ( bin )				  
      val /= 2 ;					      								    	    print ( bin , end = ' ' )				  
    }							      								    								  
    bin = reverse ( bin ) ;				      								    								  
    System . out . print ( bin + " " ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS	      MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS	    MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS		  MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS
--							      --							    --								  --
public static int minProduct ( int [ ] arr , int n , int k )  def minProduct ( arr , n , k ) :				    def min_product ( arr , n , k ) :				  script_not_found : None
  PriorityQueue < Integer > pq = new PriorityQueue < > ( ) ;  	  heapq.heapify ( arr )					    	pq = [ ]						  
  for ( int i = 0 ;					      	  count = 0						    	for i in range ( n ) :					  
  i < n ;						      	  ans = 1						    	    pq.append ( arr [ i ] )				  
  i ++ ) pq . add ( arr [ i ] ) ;			      	  while ( arr ) and count < k :				    	count , ans = 0 , 1					  
  int count = 0 , ans = 1 ;				      	      x = heapq.heappop ( arr )				    	while pq is None and count < k :			  
  while ( pq . isEmpty ( ) == false && count < k ) {	      	      ans = ans * x					    	    ans = ans * pq.pop ( )				  
    ans = ans * pq . element ( ) ;			      	      count = count + 1					    	    pq.append ( 1 )					  
    pq . remove ( ) ;					      	  return ans						    	    count += 1						  
    count ++ ;						      								    	return ans						  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		      CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		    CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		  CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION
--							      --							    --								  --
static int findMinX ( int num [ ] , int rem [ ] , int k ) {   def findMinX ( num , rem , k ) :				    def find_min_x ( num , rem , k ) :				  script_not_found : None
  int x = 1 ;						      	  x = 1							    	x = 1							  
  while ( true ) {					      	  while ( True ) :					    	while True :						  
    int j ;						      	      j = 0						    	    j = 0						  
    for ( j = 0 ;					      	      while ( j < k ) :					    	    for j in range ( k ) :				  
    j < k ;						      		  if ( x % num [ j ] != rem [ j ] ) :		    		if x % num [ j ] != rem [ j ] :			  
    j ++ ) if ( x % num [ j ] != rem [ j ] ) break ;	      		      break					    		    break					  
    if ( j == k ) return x ;				      		  j += 1					    	    if j == k :						  
    x ++ ;						      	      if ( j == k ) :					    		return x					  
  }							      		  return x					    	    x += 1						  
}							      	      x += 1						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		      FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		    FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		  FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY
--							      --							    --								  --
static int maxSubarrayXOR ( int arr [ ] , int n ) {	      def maxSubarrayXOR ( arr , n ) :				    def max_subarray_xor ( arr , n ) :				  success : None
  int ans = Integer . MIN_VALUE ;			      	  ans = - 2147483648					    	ans = 0							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      curr_xor = 0					    	    curr_xor = 0					  
  i ++ ) {						      	      for j in range ( i , n ) :			    	    for j in range ( i , n ) :				  
    int curr_xor = 0 ;					      		  curr_xor = curr_xor ^ arr [ j ]		    		curr_xor = curr_xor ^ arr [ j ]			  
    for ( int j = i ;					      		  ans = max ( ans , curr_xor )			    		ans = max ( ans , curr_xor )			  
    j < n ;						      	  return ans						    	return ans						  
    j ++ ) {						      								    								  
      curr_xor = curr_xor ^ arr [ j ] ;			      								    								  
      ans = Math . max ( ans , curr_xor ) ;		      								    								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			      SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			    SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			  SUM_MANHATTAN_DISTANCES_PAIRS_POINTS
--							      --							    --								  --
static int distancesum ( int x [ ] , int y [ ] , int n ) {    def distancesum ( x , y , n ) :				    def distancesum ( x , y , n ) :				  success : identical to gold
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) for ( int j = i + 1 ;				      		  sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i  		sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i  
  j < n ;						      	  return sum						    	return sum						  
  j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . a 								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI
--							      --							    --								  --
static int countNegative ( int M [ ] [ ] , int n , int m ) {  def countNegative ( M , n , m ) :				    def count_negative ( M , n , m ) :				  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  int i = 0 ;						      	  i = 0							    	i = 0							  
  int j = m - 1 ;					      	  j = m - 1						    	j = m - 1						  
  while ( j >= 0 && i < n ) {				      	  while j >= 0 and i < n :				    	while j >= 0 and i < n :				  
    if ( M [ i ] [ j ] < 0 ) {				      	      if M [ i ] [ j ] < 0 :				    	    if M [ i ] [ j ] < 0 :				  
      count += j + 1 ;					      		  count += ( j + 1 )				    		count += j + 1					  
      i += 1 ;						      		  i += 1					    		i += 1						  
    }							      	      else :						    	    else :						  
    else j -= 1 ;					      		  j -= 1					    		j -= 1						  
  }							      	  return count						    	return count						  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LOWER_CASE_UPPER_CASE_INTERESTING_FACT			      LOWER_CASE_UPPER_CASE_INTERESTING_FACT			    LOWER_CASE_UPPER_CASE_INTERESTING_FACT			  LOWER_CASE_UPPER_CASE_INTERESTING_FACT
--							      --							    --								  --
static String to_upper ( char [ ] in ) {		      def to_upper ( string ) :					    def to_upper ( inp ) :					  script_not_found : None
  for ( int i = 0 ;					      	  for i in range ( len ( string ) ) :			    	for i in range ( len ( inp ) ) :			  
  i < in . length ;					      	      if ( 'a' <= string [ i ] <= 'z' ) :		    	    if 'a' <= inp [ i ] & inp [ i ] <= 'z' :		  
  i ++ ) {						      		  string = ( string [ 0 : i ] + chr ( ord ( string  		inp [ i ] = chr ( ord ( inp [ i ] ) - ord ( 'a' ) 
    if ( 'a' <= in [ i ] & in [ i ] <= 'z' ) {		      	  return string						    	return ''.join ( inp )					  
      in [ i ] = ( char ) ( in [ i ] - 'a' + 'A' ) ;	      								    								  
    }							      								    								  
  }							      								    								  
  return String . valueOf ( in ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_DIFFERENCE_EQUAL_K				      COUNT_PAIRS_DIFFERENCE_EQUAL_K				    COUNT_PAIRS_DIFFERENCE_EQUAL_K				  COUNT_PAIRS_DIFFERENCE_EQUAL_K
--							      --							    --								  --
static int countPairsWithDiffK ( int arr [ ] , int n , int k  def countPairsWithDiffK ( arr , n , k ) :			    def count_pairs_with_diff_k ( arr , n , k ) :		  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) {						      		  if arr [ i ] - arr [ j ] == k or arr [ j ] - arr  		if arr [ i ] - arr [ j ] == k or arr [ j ] - arr  
    for ( int j = i + 1 ;				      		      count += 1				    		    count += 1					  
    j < n ;						      	  return count						    	return count						  
    j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr 								    								  
  }							      								    								  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_BITS_IN_A_GIVEN_NUMBER				      SWAP_BITS_IN_A_GIVEN_NUMBER				    SWAP_BITS_IN_A_GIVEN_NUMBER					  SWAP_BITS_IN_A_GIVEN_NUMBER
--							      --							    --								  --
static int swapBits ( int x , int p1 , int p2 , int n ) {     def swapBits ( x , p1 , p2 , n ) :			    def swap_bits ( x , p1 , p2 , n ) :				  success : None
  int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ;		      	  set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )		    	set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )			  
  int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ;		      	  set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )		    	set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )			  
  int xor = ( set1 ^ set2 ) ;				      	  xor = ( set1 ^ set2 )					    	xor = ( set1 ^ set2 )					  
  xor = ( xor << p1 ) | ( xor << p2 ) ;			      	  xor = ( xor << p1 ) | ( xor << p2 )			    	xor = ( xor << p1 ) | ( xor << p2 )			  
  int result = x ^ xor ;				      	  result = x ^ xor					    	result = x ^ xor					  
  return result ;					      	  return result						    	return result						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1		      MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1		    MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1			  MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1
--							      --							    --								  --
public static int middleOfThree ( int a , int b , int c ) {   def middleOfThree ( a , b , c ) :				    def middle_of_three ( a , b , c ) :				  success : None
  if ( a > b ) {					      	  if a > b :						    	if a > b :						  
    if ( b > c ) return b ;				      	      if ( b > c ) :					    	    if b > c :						  
    else if ( a > c ) return c ;			      		  return b					    		return b					  
    else return a ;					      	      elif ( a > c ) :					    	    elif a > c :					  
  }							      		  return c					    		return c					  
  else {						      	      else :						    	    else :						  
    if ( a > c ) return a ;				      		  return a					    		return a					  
    else if ( b > c ) return c ;			      	  else :						    	else :							  
    else return b ;					      	      if ( a > c ) :					    	    if a > c :						  
  }							      		  return a					    		return a					  
}							      	      elif ( b > c ) :					    	    elif b > c :					  
							      		  return c					    		return c					  
							      	      else :						    	    else :						  
							      		  return b					    		return b					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			      FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			    FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			  FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM
--							      --							    --								  --
static int maxLen ( int arr [ ] , int n ) {		      def maxLen ( arr ) :					    def max_len ( arr , n ) :					  script_not_found : None
  int max_len = 0 ;					      	  max_len = 0						    	max_len = 0						  
  for ( int i = 0 ;					      	  for i in range ( len ( arr ) ) :			    	for i in range ( n ) :					  
  i < n ;						      	      curr_sum = 0					    	    curr_sum = 0					  
  i ++ ) {						      	      for j in range ( i , len ( arr ) ) :		    	    for j in range ( i , n ) :				  
    int curr_sum = 0 ;					      		  curr_sum += arr [ j ]				    		curr_sum += arr [ j ]				  
    for ( int j = i ;					      		  if curr_sum == 0 :				    		if curr_sum == 0 :				  
    j < n ;						      		      max_len = max ( max_len , j - i + 1 )	    		    max_len = max ( max_len , j - i + 1 )	  
    j ++ ) {						      	  return max_len					    	return max_len						  
      curr_sum += arr [ j ] ;				      								    								  
      if ( curr_sum == 0 ) max_len = Math . max ( max_len , j 								    								  
    }							      								    								  
  }							      								    								  
  return max_len ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN			      N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN			    N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN			  N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN
--							      --							    --								  --
public static int findNth ( int n ) {			      def findNth ( n ) :					    def find_nth ( n ) :					  failure : #Results: 0, 10
  int count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int curr = 1 ;					      	  for curr in itertools.count ( ) :			    	for curr in range ( 1 ) :				  
  ;							      	      sum = 0						    	    sum = 0						  
  curr ++ ) {						      	      x = curr						    	    for x in range ( curr , 0 , - 1 ) :			  
    int sum = 0 ;					      	      while ( x ) :					    		sum = sum + x % 10				  
    for ( int x = curr ;				      		  sum = sum + x % 10				    	    if sum == 10 :					  
    x > 0 ;						      		  x = x // 10					    		count += 1					  
    x = x / 10 ) sum = sum + x % 10 ;			      	      if ( sum == 10 ) :				    	    if count == n :					  
    if ( sum == 10 ) count ++ ;				      		  count = count + 1				    		return curr					  
    if ( count == n ) return curr ;			      	      if ( count == n ) :				    								  
  }							      		  return curr					    								  
}							      	  return - 1						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BUBBLE_SORT						      BUBBLE_SORT						    BUBBLE_SORT							  BUBBLE_SORT
--							      --							    --								  --
void bubbleSort ( int arr [ ] ) {			      def bubbleSort ( arr ) :					    def bubbleSort ( arr ) :					  script_not_found : None
  int n = arr . length ;				      	  n = len ( arr )					    	n = len ( arr )						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      for j in range ( 0 , n - i - 1 ) :		    	    for j in range ( n - i - 1 ) :			  
  i ++ ) for ( int j = 0 ;				      		  if arr [ j ] > arr [ j + 1 ] :		    		if arr [ j ] > arr [ j + 1 ] :			  
  j < n - i - 1 ;					      		      arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , a 		    temp = arr [ j ]				  
  j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) {		      								    		    arr [ j ] = arr [ j + 1 ]			  
    int temp = arr [ j ] ;				      								    		    arr [ j + 1 ] = temp			  
    arr [ j ] = arr [ j + 1 ] ;				      								    								  
    arr [ j + 1 ] = temp ;				      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_DIFFERENCE_PAIR				      FIND_MINIMUM_DIFFERENCE_PAIR				    FIND_MINIMUM_DIFFERENCE_PAIR				  FIND_MINIMUM_DIFFERENCE_PAIR
--							      --							    --								  --
static int findMinDiff ( int [ ] arr , int n ) {	      def findMinDiff ( arr , n ) :				    def find_min_diff ( arr , n ) :				  success : None
  int diff = Integer . MAX_VALUE ;			      	  diff = 10 ** 20					    	diff = sys.maxsize					  
  for ( int i = 0 ;					      	  for i in range ( n - 1 ) :				    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) for ( int j = i + 1 ;				      		  if abs ( arr [ i ] - arr [ j ] ) < diff :	    		if abs ( ( arr [ i ] - arr [ j ] ) ) < diff :	  
  j < n ;						      		      diff = abs ( arr [ i ] - arr [ j ] )	    		    diff = abs ( ( arr [ i ] - arr [ j ] ) )	  
  j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff 	  return diff						    	return diff						  
  return diff ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	      FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	    FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	  FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE
--							      --							    --								  --
static int minRadius ( int k , int [ ] x , int [ ] y , int n  def minRadius ( k , x , y , n ) :				    def min_radius ( k , x , y , n ) :				  script_not_found : None
  int [ ] dis = new int [ n ] ;				      	  dis = [ 0 ] * n					    	dis = [ 0 ] * n						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ]	    	    dis [ i ] = x [ i ] ** 2 + y [ i ] ** 2		  
  i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ;  	  dis.sort ( )						    	dis.sort ( )						  
  Arrays . sort ( dis ) ;				      	  return dis [ k - 1 ]					    	return dis [ k - 1 ]					  
  return dis [ k - 1 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7	      FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7		    FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7		  FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7
--							      --							    --								  --
static int findpos ( String n ) {			      def findpos ( n ) :					    def findpos ( n ) :						  success : None
  int k = 0 , pos = 0 , i = 0 ;				      	  i = 0							    	k , pos , i = 0 , 0 , 0					  
  while ( k != n . length ( ) ) {			      	  j = len ( n )						    	while k != len ( n ) :					  
    switch ( n . charAt ( i ) ) {			      	  pos = 0						    	    if n [ i ] == '4' :					  
      case '4' : pos = pos * 2 + 1 ;			      	  while ( i < j ) :					    		pos = pos * 2 + 1				  
      break ;						      	      if ( n [ i ] == '4' ) :				    	    elif n [ i ] == '7' :				  
      case '7' : pos = pos * 2 + 2 ;			      		  pos = pos * 2 + 1				    		pos = pos * 2 + 2				  
      break ;						      	      if ( n [ i ] == '7' ) :				    	    i += 1						  
    }							      		  pos = pos * 2 + 2				    	    k += 1						  
    i ++ ;						      	      i = i + 1						    	return pos						  
    k ++ ;						      	  return pos						    								  
  }							      								    								  
  return pos ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_FIRST_MISSING_NUMBER				      FIND_THE_FIRST_MISSING_NUMBER				    FIND_THE_FIRST_MISSING_NUMBER				  FIND_THE_FIRST_MISSING_NUMBER
--							      --							    --								  --
int findFirstMissing ( int array [ ] , int start , int end )  def findFirstMissing ( array , start , end ) :		    def find_first_missing ( array , start , end ) :		  success : None
  if ( start > end ) return end + 1 ;			      	  if ( start > end ) :					    	if start > end :					  
  if ( start != array [ start ] ) return start ;	      	      return end + 1					    	    return end + 1					  
  int mid = ( start + end ) / 2 ;			      	  if ( start != array [ start ] ) :			    	if start != array [ start ] :				  
  if ( array [ mid ] == mid ) return findFirstMissing ( array 	      return start					    	    return start					  
  return findFirstMissing ( array , start , mid ) ;	      	  mid = int ( ( start + end ) / 2 )			    	mid = ( start + end ) // 2				  
}							      	  if ( array [ mid ] == mid ) :				    	if array [ mid ] == mid :				  
							      	      return findFirstMissing ( array , mid + 1 , end )	    	    return find_first_missing ( array , mid + 1 , end )	  
							      	  return findFirstMissing ( array , start , mid )	    	return find_first_missing ( array , start , mid )	  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY   CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY   CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY	  CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY
--							      --							    --								  --
static boolean checkIsAP ( int arr [ ] , int n ) {	      def checkIsAP ( arr , n ) :				    def check_is_ap ( arr , n ) :				  success : None
  if ( n == 1 ) return true ;				      	  if ( n == 1 ) : return True				    	if n == 1 :						  
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	    return True						  
  int d = arr [ 1 ] - arr [ 0 ] ;			      	  d = arr [ 1 ] - arr [ 0 ]				    	arr.sort ( )						  
  for ( int i = 2 ;					      	  for i in range ( 2 , n ) :				    	d = arr [ 1 ] - arr [ 0 ]				  
  i < n ;						      	      if ( arr [ i ] - arr [ i - 1 ] != d ) :		    	for i in range ( 2 , n ) :				  
  i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; 		  return False					    	    if arr [ i ] - arr [ i - 1 ] != d :			  
  return true ;						      	  return True						    		return False					  
}							      								    	return True						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_INSERTION_SORT				      RECURSIVE_INSERTION_SORT					    RECURSIVE_INSERTION_SORT					  RECURSIVE_INSERTION_SORT
--							      --							    --								  --
static void insertionSortRecursive ( int arr [ ] , int n ) {  def insertionSortRecursive ( arr , n ) :			    def insertionSortRecursive ( arr , n ) :			  success : None
  if ( n <= 1 ) return ;				      	  if n <= 1 :						    	if n <= 1 :						  
  insertionSortRecursive ( arr , n - 1 ) ;		      	      return						    	    return						  
  int last = arr [ n - 1 ] ;				      	  insertionSortRecursive ( arr , n - 1 )		    	insertionSortRecursive ( arr , n - 1 )			  
  int j = n - 2 ;					      	  last = arr [ n - 1 ]					    	last = arr [ n - 1 ]					  
  while ( j >= 0 && arr [ j ] > last ) {		      	  j = n - 2						    	j = n - 2						  
    arr [ j + 1 ] = arr [ j ] ;				      	  while ( j >= 0 and arr [ j ] > last ) :		    	while j >= 0 and arr [ j ] > last :			  
    j -- ;						      	      arr [ j + 1 ] = arr [ j ]				    	    arr [ j + 1 ] = arr [ j ]				  
  }							      	      j = j - 1						    	    j -= 1						  
  arr [ j + 1 ] = last ;				      	  arr [ j + 1 ] = last					    	arr [ j + 1 ] = last					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES		      AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES		    AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES		  AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES
--							      --							    --								  --
public static double polygonArea ( double X [ ] , double Y [  def polygonArea ( X , Y , n ) :				    def polygon_area ( X , Y , n ) :				  script_not_found : None
  double area = 0.0 ;					      	  area = 0.0						    	area = 0.0						  
  int j = n - 1 ;					      	  j = n - 1						    	j = n - 1						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) 	    area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) 
  i ++ ) {						      	      j = i						    	    j = i						  
    area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;   	  return int ( abs ( area / 2.0 ) )			    	return abs ( area / 2.0 )				  
    j = i ;						      								    								  
  }							      								    								  
  return Math . abs ( area / 2.0 ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES  FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES  FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES  FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES
--							      --							    --								  --
static int countSol ( int coeff [ ] , int start , int end , i def countSol ( coeff , start , end , rhs ) :		    def count_sol ( coeff , start , end , rhs ) :		  script_not_found : None
  if ( rhs == 0 ) return 1 ;				      	  if ( rhs == 0 ) :					    	if not rhs :						  
  int result = 0 ;					      	      return 1						    	    return 1						  
  for ( int i = start ;					      	  result = 0						    	result = 0						  
  i <= end ;						      	  for i in range ( start , end + 1 ) :			    	for i in range ( start , end + 1 ) :			  
  i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff 	      if ( coeff [ i ] <= rhs ) :			    	    if coeff [ i ] <= rhs :				  
  return result ;					      		  result += countSol ( coeff , i , end , rhs - coef 		result += count_sol ( coeff , i , end , rhs - coe 
}							      	  return result						    	return result						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FRIENDS_PAIRING_PROBLEM					      FRIENDS_PAIRING_PROBLEM					    FRIENDS_PAIRING_PROBLEM					  FRIENDS_PAIRING_PROBLEM
--							      --							    --								  --
static int countFriendsPairings ( int n ) {		      def countFriendsPairings ( n ) :				    def count_friend_pairings ( n ) :				  success : None
  int dp [ ] = new int [ n + 1 ] ;			      	  dp = [ 0 for i in range ( n + 1 ) ]			    	dp = [ 0 ] * ( n + 1 )					  
  for ( int i = 0 ;					      	  for i in range ( n + 1 ) :				    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      if ( i <= 2 ) :					    	    if i <= 2 :						  
  i ++ ) {						      		  dp [ i ] = i					    		dp [ i ] = i					  
    if ( i <= 2 ) dp [ i ] = i ;			      	      else :						    	    else :						  
    else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; 		  dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2  		dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2  
  }							      	  return dp [ n ]					    	return dp [ n ]						  
  return dp [ n ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION		      DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION			    DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION			  DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION
--							      --							    --								  --
static boolean distributingBalls ( long k , long n , String s def distributingBalls ( k , n , string ) :		    def distributing_balls ( k , n , data ) :			  script_not_found : None
  int [ ] a = new int [ MAX_CHAR ] ;			      	  a = [ 0 ] * MAX_CHAR					    	a = [ 0 ] * MAX_CHAR					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for c in data :						  
  i < n ;						      	      a [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1	    	    a [ ord ( c ) - ord ( 'a' ) ] += 1			  
  i ++ ) {						      	  for i in range ( MAX_CHAR ) :				    	for c in a :						  
    a [ str . charAt ( i ) - 'a' ] ++ ;			      	      if ( a [ i ] > k ) :				    	    if c > k :						  
  }							      		  return False					    		return False					  
  for ( int i = 0 ;					      	  return True						    	return True						  
  i < MAX_CHAR ;					      								    								  
  i ++ ) if ( a [ i ] > k ) return false ;		      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS   GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS   GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS	  GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS
--							      --							    --								  --
static void generate ( int ones , int zeroes , String str , i def generate ( ones , zeroes , str , len1 ) :		    def generate ( ones , zeroes , data , len_ ) :		  script_not_found : None
  if ( len == str . length ( ) ) {			      	  if ( len1 == len ( str ) ) :				    	if len_ == len ( data ) :				  
    System . out . print ( str + " " ) ;		      	      print ( str , end = " " )				    	    print ( data , end = ' ' )				  
    return ;						      	      return						    	    return						  
  }							      	  generate ( ones + 1 , zeroes , str + "1" , len1 )	    	generate ( ones + 1 , zeroes , data + '1' , len_ )	  
  generate ( ones + 1 , zeroes , str + "1" , len ) ;	      	  if ( ones > zeroes ) :				    	if ones > zeroes :					  
  if ( ones > zeroes ) {				      	      generate ( ones , zeroes + 1 , str + "0" , len1 )	    	    generate ( ones , zeroes + 1 , data + '0' , len_ )	  
    generate ( ones , zeroes + 1 , str + "0" , len ) ;	      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X   COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X   COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X	  COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X
--							      --							    --								  --
static int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , def countPairs ( arr1 , arr2 , m , n , x ) :		    def count_pairs ( arr1 , arr2 , m , n , x ) :		  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int i = 0 ;					      	  for i in range ( m ) :				    	for i in range ( m ) :					  
  i < m ;						      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
  i ++ ) for ( int j = 0 ;				      		  if arr1 [ i ] + arr2 [ j ] == x :		    		if ( arr1 [ i ] + arr2 [ j ] ) == x :		  
  j < n ;						      		      count = count + 1				    		    count += 1					  
  j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ;   	  return count						    	return count						  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		      FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		    FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		  FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES
--							      --							    --								  --
static int getOddOccurrence ( int arr [ ] , int arr_size ) {  def getOddOccurrence ( arr , arr_size ) :			    def get_odd_occurrence ( arr , arr_size ) :			  success : None
  int i ;						      	  for i in range ( 0 , arr_size ) :			    	for i in range ( arr_size ) :				  
  for ( i = 0 ;						      	      count = 0						    	    count = 0						  
  i < arr_size ;					      	      for j in range ( 0 , arr_size ) :			    	    for j in range ( arr_size ) :			  
  i ++ ) {						      		  if arr [ i ] == arr [ j ] :			    		if arr [ i ] == arr [ j ] :			  
    int count = 0 ;					      		      count += 1				    		    count += 1					  
    for ( int j = 0 ;					      	      if ( count % 2 != 0 ) :				    	    if count % 2 :					  
    j < arr_size ;					      		  return arr [ i ]				    		return arr [ i ]				  
    j ++ ) {						      	  return - 1						    	return - 1						  
      if ( arr [ i ] == arr [ j ] ) count ++ ;		      								    								  
    }							      								    								  
    if ( count % 2 != 0 ) return arr [ i ] ;		      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N  MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N  MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N  MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N
--							      --							    --								  --
static int getMinSquares ( int n ) {			      def getMinSquares ( n ) :					    def get_min_squares ( n ) :					  script_not_found : None
  if ( n <= 3 ) return n ;				      	  if n <= 3 :						    	if n <= 3 :						  
  int res = n ;						      	      return n ;					    	    return n						  
  for ( int x = 1 ;					      	  res = n						    	res = n							  
  x <= n ;						      	  for x in range ( 1 , n + 1 ) :			    	for x in range ( 1 , n + 1 ) :				  
  x ++ ) {						      	      temp = x * x ;					    	    temp = x * x					  
    int temp = x * x ;					      	      if temp > n :					    	    if temp > n :					  
    if ( temp > n ) break ;				      		  break						    		break						  
    else res = Math . min ( res , 1 + getMinSquares ( n - tem 	      else :						    	    else :						  
  }							      		  res = min ( res , 1 + getMinSquares ( n - temp )  		res = min ( res , 1 + get_min_squares ( n - temp  
  return res ;						      	  return res ;						    	return res						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI
--							      --							    --								  --
static boolean isLucky ( int n ) {			      def isLucky ( n ) :					    def is_lucky ( n ) :					  failure : #Results: 5, 10
  boolean arr [ ] = new boolean [ 10 ] ;		      	  ar = [ 0 ] * 10					    	arr = [ False for i in range ( 10 ) ]			  
  for ( int i = 0 ;					      	  while ( n > 0 ) :					    	while n > 0 :						  
  i < 10 ;						      	      digit = math.floor ( n % 10 )			    	    digit = n % 10					  
  i ++ ) arr [ i ] = false ;				      	      if ( ar [ digit ] ) :				    	    if arr [ digit ] :					  
  while ( n > 0 ) {					      		  return 0					    		return False					  
    int digit = n % 10 ;				      	      ar [ digit ] = 1					    	    arr [ digit ] = True				  
    if ( arr [ digit ] ) return false ;			      	      n = n / 10					    	    n = n // 10						  
    arr [ digit ] = true ;				      	  return 1						    	return True						  
    n = n / 10 ;					      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SINK_NODES_GRAPH					      NUMBER_SINK_NODES_GRAPH					    NUMBER_SINK_NODES_GRAPH					  NUMBER_SINK_NODES_GRAPH
--							      --							    --								  --
static int countSink ( int n , int m , int edgeFrom [ ] , int def countSink ( n , m , edgeFrom , edgeTo ) :		    def count_sink ( n , m , edge_from , edge_to ) :		  script_not_found : None
  int [ ] mark = new int [ n + 1 ] ;			      	  mark = [ 0 ] * ( n + 1 )				    	mark = np.zeros ( n + 1 )				  
  for ( int i = 0 ;					      	  for i in range ( m ) :				    	for i in range ( m ) :					  
  i < m ;						      	      mark [ edgeFrom [ i ] ] = 1			    	    mark [ edge_from [ i ] ] = 1			  
  i ++ ) mark [ edgeFrom [ i ] ] = 1 ;			      	  count = 0						    	count = 0						  
  int count = 0 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  for ( int i = 1 ;					      	      if ( not mark [ i ] ) :				    	    if mark [ i ] == 0 :				  
  i <= n ;						      		  count += 1					    		count += 1					  
  i ++ ) if ( mark [ i ] == 0 ) count ++ ;		      	  return count						    	return count						  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND	      GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND	    GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND	  GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND
--							      --							    --								  --
static boolean isSubSequence ( String str1 , String str2 , in def isSubSequence ( string1 , string2 , m , n ) :		    def is_subsequence ( str1 , str2 , m , n ) :		  script_not_found : None
  if ( m == 0 ) return true ;				      	  if m == 0 : return True				    	if not m :						  
  if ( n == 0 ) return false ;				      	  if n == 0 : return False				    	    return True						  
  if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) r 	  if string1 [ m - 1 ] == string2 [ n - 1 ] :		    	if not n :						  
  return isSubSequence ( str1 , str2 , m , n - 1 ) ;	      	      return isSubSequence ( string1 , string2 , m - 1 , n  	    return False					  
}							      	  return isSubSequence ( string1 , string2 , m , n - 1 )    	if str1 [ m - 1 ] == str2 [ n - 1 ] :			  
							      								    	    return is_subsequence ( str1 , str2 , m - 1 , n - 1 ) 
							      								    	return is_subsequence ( str1 , str2 , m , n - 1 )	  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			      CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			    CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			  CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT
--							      --							    --								  --
public static boolean areEqual ( int arr1 [ ] , int arr2 [ ]  def areEqual ( arr1 , arr2 , n , m ) :			    def are_equal ( arr1 , arr2 ) :				  script_not_found : None
  int n = arr1 . length ;				      	  if ( n != m ) :					    	n = len ( arr1 )					  
  int m = arr2 . length ;				      	      return False ;					    	m = len ( arr2 )					  
  if ( n != m ) return false ;				      	  arr1.sort ( ) ;					    	if n != m :						  
  Arrays . sort ( arr1 ) ;				      	  arr2.sort ( ) ;					    	    return False					  
  Arrays . sort ( arr2 ) ;				      	  for i in range ( 0 , n - 1 ) :			    	arr1.sort ( )						  
  for ( int i = 0 ;					      	      if ( arr1 [ i ] != arr2 [ i ] ) :			    	arr2.sort ( )						  
  i < n ;						      		  return False ;				    	for i in range ( n ) :					  
  i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ;	      	  return True ;						    	    if arr1 [ i ] != arr2 [ i ] :			  
  return true ;						      								    		return False					  
}							      								    	return True						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS		      MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS			    MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS			  MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS
--							      --							    --								  --
public static int subset ( int ar [ ] , int n ) {	      def subset ( ar , n ) :					    def subset ( ar , n ) :					  success : None
  int res = 0 ;						      	  res = 0						    	res = 0							  
  Arrays . sort ( ar ) ;				      	  ar.sort ( )						    	ar.sort ( )						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      count = 1						    	    count = 1						  
  i ++ ) {						      	      for i in range ( n - 1 ) :			    	    for i in range ( n - 1 ) :				  
    int count = 1 ;					      		  if ar [ i ] == ar [ i + 1 ] :			    		if ar [ i ] == ar [ i + 1 ] :			  
    for ( ;						      		      count += 1				    		    count += 1					  
    i < n - 1 ;						      		  else :					    		else :						  
    i ++ ) {						      		      break					    		    break					  
      if ( ar [ i ] == ar [ i + 1 ] ) count ++ ;	      	      res = max ( res , count )				    	    res = max ( res , count )				  
      else break ;					      	  return res						    	return res						  
    }							      								    								  
    res = Math . max ( res , count ) ;			      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE
--							      --							    --								  --
static int search ( int arr [ ] , int n , int x ) {	      def search ( arr , n , x ) :				    def search ( arr , n , x ) :				  success : None
  int i = 0 ;						      	  i = 0							    	i = 0							  
  while ( i < n ) {					      	  while ( i < n ) :					    	while i < n :						  
    if ( arr [ i ] == x ) return i ;			      	      if ( arr [ i ] == x ) :				    	    if arr [ i ] == x :					  
    i = i + Math . abs ( arr [ i ] - x ) ;		      		  return i					    		return i					  
  }							      	      i = i + abs ( arr [ i ] - x )			    	    i = i + abs ( arr [ i ] - x )			  
  System . out . println ( "number is not" + " present!" ) ;  	  print ( "number is not present!" )			    	print ( "number is not" , "present!" )			  
  return - 1 ;						      	  return - 1						    	return - 1						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_THAT_APPEARS_ONCE			      FIND_THE_ELEMENT_THAT_APPEARS_ONCE			    FIND_THE_ELEMENT_THAT_APPEARS_ONCE				  FIND_THE_ELEMENT_THAT_APPEARS_ONCE
--							      --							    --								  --
static int getSingle ( int arr [ ] , int n ) {		      def getSingle ( arr , n ) :				    def get_single ( arr , n ) :				  success : None
  int ones = 0 , twos = 0 ;				      	  ones = 0						    	ones , twos = 0 , 0					  
  int common_bit_mask ;					      	  twos = 0						    	common_bit_mask = 0					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      twos = twos | ( ones & arr [ i ] )		    	    twos = twos | ( ones & arr [ i ] )			  
  i ++ ) {						      	      ones = ones ^ arr [ i ]				    	    ones = ones ^ arr [ i ]				  
    twos = twos | ( ones & arr [ i ] ) ;		      	      common_bit_mask = ~ ( ones & twos )		    	    common_bit_mask = ~ ( ones & twos )			  
    ones = ones ^ arr [ i ] ;				      	      ones &= common_bit_mask				    	    ones &= common_bit_mask				  
    common_bit_mask = ~ ( ones & twos ) ;		      	      twos &= common_bit_mask				    	    twos &= common_bit_mask				  
    ones &= common_bit_mask ;				      	  return ones						    	return ones						  
    twos &= common_bit_mask ;				      								    								  
  }							      								    								  
  return ones ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ONE_EXTRA_CHARACTER_STRING_1			      FIND_ONE_EXTRA_CHARACTER_STRING_1				    FIND_ONE_EXTRA_CHARACTER_STRING_1				  FIND_ONE_EXTRA_CHARACTER_STRING_1
--							      --							    --								  --
static char findExtraCharcter ( String strA , String strB ) { def findExtraCharcter ( strA , strB ) :			    def find_extra_charcter ( str_a , str_b ) :			  success : None
  int res = 0 , i ;					      	  res = 0						    	res , i = 0 , 0						  
  for ( i = 0 ;						      	  for i in range ( 0 , len ( strA ) ) :			    	for c in str_a :					  
  i < strA . length ( ) ;				      	      res = res ^ ( ord ) ( strA [ i ] )		    	    res ^= ord ( c )					  
  i ++ ) {						      	  for i in range ( 0 , len ( strB ) ) :			    	for c in str_b :					  
    res ^= strA . charAt ( i ) ;			      	      res = res ^ ( ord ) ( strB [ i ] )		    	    res ^= ord ( c )					  
  }							      	  return ( ( chr ) ( res ) ) ;				    	return ( chr ( res ) )					  
  for ( i = 0 ;						      								    								  
  i < strB . length ( ) ;				      								    								  
  i ++ ) {						      								    								  
    res ^= strB . charAt ( i ) ;			      								    								  
  }							      								    								  
  return ( ( char ) ( res ) ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1		      PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1		    PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1		  PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1
--							      --							    --								  --
static void printDistinct ( int arr [ ] , int n ) {	      def printDistinct ( arr , n ) :				    def printDistinct ( arr , n ) :				  script_not_found : None
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) :	    	    while i < n - 1 and arr [ i ] == arr [ i + 1 ] :	  
  i ++ ) {						      		  while ( i < n - 1 and ( arr [ i ] == arr [ i + 1  		i += 1						  
    while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ;  		      i += 1					    	    print ( arr [ i ] , end = ' ' )			  
    System . out . print ( arr [ i ] + " " ) ;		      	      else :						    								  
  }							      		  print ( arr [ i ] , end = " " )		    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B		      FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B		    FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B		  FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B
--							      --							    --								  --
static int computeLastDigit ( long A , long B ) {	      def computeLastDigit ( A , B ) :				    def compute_last_digit ( A , B ) :				  success : None
  int variable = 1 ;					      	  variable = 1						    	variable = 1						  
  if ( A == B ) return 1 ;				      	  if ( A == B ) :					    	if A == B :						  
  else if ( ( B - A ) >= 5 ) return 0 ;			      	      return 1						    	    return 1						  
  else {						      	  elif ( ( B - A ) >= 5 ) :				    	elif ( B - A ) >= 5 :					  
    for ( long i = A + 1 ;				      	      return 0						    	    return 0						  
    i <= B ;						      	  else :						    	else :							  
    i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10  	      for i in range ( A + 1 , B + 1 ) :		    	    for i in range ( A + 1 , B + 1 ) :			  
    return variable % 10 ;				      		  variable = ( variable * ( i % 10 ) ) % 10	    		variable = int ( variable * ( i % 10 ) ) % 10	  
  }							      	      return variable % 10				    	    return variable % 10				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCHING_ARRAY_ADJACENT_DIFFER_K			      SEARCHING_ARRAY_ADJACENT_DIFFER_K				    SEARCHING_ARRAY_ADJACENT_DIFFER_K				  SEARCHING_ARRAY_ADJACENT_DIFFER_K
--							      --							    --								  --
static int search ( int arr [ ] , int n , int x , int k ) {   def search ( arr , n , x , k ) :				    def search ( arr , n , x , k ) :				  error : Traceback (most recent call last):   File
  int i = 0 ;						      	  i = 0							    	i = 0							  "dump/transcoder_st/eval/java_python/online_st/206
  while ( i < n ) {					      	  while ( i < n ) :					    	while i < n :						  68770/eval_scripts/java_sa-python_sa.test/SEARCHIN
    if ( arr [ i ] == x ) return i ;			      	      if ( arr [ i ] == x ) :				    	    if arr [ i ] == x :					  G_ARRAY_ADJACENT_DIFFER_K.py", line 52, in <module
    i = i + Math . max ( 1 , Math . abs ( arr [ i ] - x ) / k 		  return i					    		return i					  >	if f_filled(*parameters_set) == f_gold(*para
  }							      	      i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) ) 	    i = i + max ( 1 , abs ( arr [ i ] - x ) / k )	  meters_set):	 File "dump/transcoder_st/eval/java_
  System . out . println ( "number is " + "not present!" ) ;  	  print ( "number is not present!" )			    	print ( "number is %d not present!" % ( n ) )		  python/online_st/20668770/eval_scripts/java_sa-pyt
  return - 1 ;						      	  return - 1						    	return - 1						  hon_sa.test/SEARCHING_ARRAY_ADJACENT_DIFFER_K.py",
}							      								    								   line 30, in f_filled	    if arr [ i ] == x : Type
							      								    								  Error: list indices must be integers or slices, no
							      								    								  t float
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL	      MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL	    MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL		  MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL
--							      --							    --								  --
static int minOps ( int arr [ ] , int n , int k ) {	      def minOps ( arr , n , k ) :				    def min_ops ( arr , n , k ) :				  success : None
  Arrays . sort ( arr ) ;				      	  max1 = max ( arr )					    	arr.sort ( )						  
  int max = arr [ arr . length - 1 ] ;			      	  res = 0						    	max = arr [ - 1 ]					  
  int res = 0 ;						      	  for i in range ( 0 , n ) :				    	res = 0							  
  for ( int i = 0 ;					      	      if ( ( max1 - arr [ i ] ) % k != 0 ) :		    	for i in range ( n ) :					  
  i < n ;						      		  return - 1					    	    if ( max - arr [ i ] ) % k != 0 :			  
  i ++ ) {						      	      else :						    		return - 1					  
    if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ;	      		  res += ( max1 - arr [ i ] ) / k		    	    else :						  
    else res += ( max - arr [ i ] ) / k ;		      	  return int ( res )					    		res += ( max - arr [ i ] ) // k			  
  }							      								    	return res						  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX	      COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX	    COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX	  COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX
--							      --							    --								  --
static int countZeroes ( int mat [ ] [ ] ) {		      def countZeroes ( mat ) :					    def count_zeroes ( mat ) :					  script_not_found : None
  int row = N - 1 , col = 0 ;				      	  N = 5 ;						    	row , col = N - 1 , 0					  
  int count = 0 ;					      	  row = N - 1 ;						    	count = 0						  
  while ( col < N ) {					      	  col = 0 ;						    	while col < N :						  
    while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) retur 	  count = 0 ;						    	    while mat [ row ] [ col ] > 0 :			  
    count += ( row + 1 ) ;				      	  while ( col < N ) :					    		if -- row < 0 :					  
    col ++ ;						      	      while ( mat [ row ] [ col ] ) :			    		    return count				  
  }							      		  if ( row < 0 ) :				    		count += ( row + 1 )				  
  return count ;					      		      return count ;				    		col += 1					  
}							      		  row = row - 1 ;				    	return count						  
							      	      count = count + ( row + 1 ) ;			    								  
							      	      col = col + 1 ;					    								  
							      	  return count ;					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_CONSECUTIVE_DUPLICATES_STRING			      REMOVE_CONSECUTIVE_DUPLICATES_STRING			    REMOVE_CONSECUTIVE_DUPLICATES_STRING			  REMOVE_CONSECUTIVE_DUPLICATES_STRING
--							      --							    --								  --
static void removeDuplicates ( char [ ] S ) {		      def removeDuplicates ( S ) :				    def remove_duplicates ( S ) :				  success : None
  int n = S . length ;					      	  n = len ( S )						    	n = len ( S )						  
  if ( n < 2 ) {					      	  if ( n < 2 ) :					    	if n < 2 :						  
    return ;						      	      return						    	    return						  
  }							      	  j = 0							    	j = 0							  
  int j = 0 ;						      	  for i in range ( n ) :				    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      	      if ( S [ j ] != S [ i ] ) :			    	    if S [ j ] != S [ i ] :				  
  i < n ;						      		  j += 1					    		j += 1						  
  i ++ ) {						      		  S [ j ] = S [ i ]				    		S [ j ] = S [ i ]				  
    if ( S [ j ] != S [ i ] ) {				      	  j += 1						    	print ( S [ : j + 1 ] )					  
      j ++ ;						      	  S = S [ : j ]						    								  
      S [ j ] = S [ i ] ;				      	  return S						    								  
    }							      								    								  
  }							      								    								  
  System . out . println ( Arrays . copyOfRange ( S , 0 , j + 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS	      COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS	    COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS		  COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS
--							      --							    --								  --
static int countPairs ( String str ) {			      def countPairs ( str1 ) :					    def count_pairs ( str ) :					  error : Traceback (most recent call last):   File
  int result = 0 ;					      	  result = 0 ;						    	result = 0						  "dump/transcoder_st/eval/java_python/online_st/206
  int n = str . length ( ) ;				      	  n = len ( str1 )					    	n = len ( str )						  68770/eval_scripts/java_sa-python_sa.test/COUNT_CH
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  ARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS.py", li
  i < n ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  ne 52, in <module>	 if f_filled(*parameters_set
  i ++ ) for ( int j = i + 1 ;				      		  if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ]  		if abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) == f_gold(*parameters_set):	  File "dump/transco
  j < n ;						      		      result += 1 ;				    		    result += 1					  der_st/eval/java_python/online_st/20668770/eval_sc
  j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt  	  return result ;					    	return result						  ripts/java_sa-python_sa.test/COUNT_CHARACTERS_STRI
  return result ;					      								    								  NG_DISTANCE_ENGLISH_ALPHABETS.py", line 32, in f_f
}							      								    								  illed	    if abs ( str [ i ] - str [ j ] ) == abs
							      								    								  ( i - j ) : TypeError: unsupported operand type(s)
							      								    								   for -: 'str' and 'str'
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO	      WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO	    WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO	  WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO
--							      --							    --								  --
static int xorZero ( String s ) {			      def xorZero ( str ) :					    def xor_zero ( s ) :					  success : None
  int one_count = 0 , zero_count = 0 ;			      	  one_count = 0						    	one_count , zero_count = 0 , 0				  
  char [ ] str = s . toCharArray ( ) ;			      	  zero_count = 0					    	s = list ( s )						  
  int n = str . length ;				      	  n = len ( str )					    	n = len ( s )						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n , 1 ) :			    	for c in s :						  
  i < n ;						      	      if ( str [ i ] == '1' ) :				    	    if c == '1' :					  
  i ++ ) if ( str [ i ] == '1' ) one_count ++ ;		      		  one_count += 1				    		one_count += 1					  
  else zero_count ++ ;					      	      else :						    	    else :						  
  if ( one_count % 2 == 0 ) return zero_count ;		      		  zero_count += 1				    		zero_count += 1					  
  return one_count ;					      	  if ( one_count % 2 == 0 ) :				    	if one_count % 2 == 0 :					  
}							      	      return zero_count					    	    return zero_count					  
							      	  return one_count					    	return one_count					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT			      CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT			    CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT			  CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT
--							      --							    --								  --
public static boolean isAnBn ( String s ) {		      def isAnBn ( str ) :					    def is_an_bn ( s ) :					  success : None
  int l = s . length ( ) ;				      	  n = len ( str )					    	l = len ( s )						  
  if ( l % 2 == 1 ) {					      	  for i in range ( n ) :				    	if l % 2 == 1 :						  
    return false ;					      	      if ( str [ i ] != 'a' ) :				    	    return False					  
  }							      		  break						    	i = 0							  
  int i = 0 ;						      	  if ( i * 2 != n ) :					    	j = l - 1						  
  int j = l - 1 ;					      	      return False					    	while i < j :						  
  while ( i < j ) {					      	  for j in range ( i , n ) :				    	    if s [ i ] != 'a' or s [ j ] != 'b' :		  
    if ( s . charAt ( i ) != 'a' || s . charAt ( j ) != 'b' ) 	      if ( str [ j ] != 'b' ) :				    		return False					  
      return false ;					      		  return False					    	    i += 1						  
    }							      	  return True						    	    j -= 1						  
    i ++ ;						      								    	return True						  
    j -- ;						      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N			      COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N			    COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N			  COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N
--							      --							    --								  --
static int countOfBinaryNumberLessThanN ( int N ) {	      def countOfBinaryNumberLessThanN ( N ) :			    def count_of_binary_number_lt_n ( N ) :			  script_not_found : None
  Queue < Integer > q = new LinkedList < > ( ) ;	      	  q = deque ( )						    	q = [ 1 ]						  
  q . add ( 1 ) ;					      	  q.append ( 1 )					    	cnt = 0							  
  int cnt = 0 ;						      	  cnt = 0						    	while q :						  
  int t ;						      	  while ( q ) :						    	    t = q [ - 1 ]					  
  while ( q . size ( ) > 0 ) {				      	      t = q.popleft ( )					    	    q.pop ( )						  
    t = q . peek ( ) ;					      	      if ( t <= N ) :					    	    if t <= N :						  
    q . remove ( ) ;					      		  cnt = cnt + 1					    		cnt += 1					  
    if ( t <= N ) {					      		  q.append ( t * 10 )				    		q.append ( t * 10 )				  
      cnt ++ ;						      		  q.append ( t * 10 + 1 )			    		q.append ( t * 10 + 1 )				  
      q . add ( t * 10 ) ;				      	  return cnt						    	return cnt						  
      q . add ( t * 10 + 1 ) ;				      								    								  
    }							      								    								  
  }							      								    								  
  return cnt ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FRIENDS_PAIRING_PROBLEM_1				      FRIENDS_PAIRING_PROBLEM_1					    FRIENDS_PAIRING_PROBLEM_1					  FRIENDS_PAIRING_PROBLEM_1
--							      --							    --								  --
static int countFriendsPairings ( int n ) {		      def countFriendsPairings ( n ) :				    def count_friend_pairings ( n ) :				  script_not_found : None
  if ( dp [ n ] != - 1 ) return dp [ n ] ;		      	  dp = [ - 1 ] * 100					    	if n in dp :						  
  if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 	  if ( dp [ n ] != - 1 ) :				    	    return dp [ n ]					  
  else return dp [ n ] = n ;				      	      return dp [ n ]					    	if n > 2 :						  
}							      	  if ( n > 2 ) :					    	    return dp [ n ] = count_friend_pairings ( n - 1 ) + ( 
							      	      dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 	else :							  
							      	      return dp [ n ]					    	    return dp [ n ] = n					  
							      	  else :						    								  
							      	      dp [ n ] = n					    								  
							      	      return dp [ n ]					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BINARY_SEARCH						      BINARY_SEARCH						    BINARY_SEARCH						  BINARY_SEARCH
--							      --							    --								  --
int binarySearch ( int arr [ ] , int l , int r , int x ) {    def binarySearch ( arr , l , r , x ) :			    def binary_search ( arr , l , r , x ) :			  success : None
  if ( r >= l ) {					      	  if r >= l :						    	if r >= l :						  
    int mid = l + ( r - l ) / 2 ;			      	      mid = l + ( r - l ) // 2				    	    mid = l + ( r - l ) // 2				  
    if ( arr [ mid ] == x ) return mid ;		      	      if arr [ mid ] == x :				    	    if arr [ mid ] == x :				  
    if ( arr [ mid ] > x ) return binarySearch ( arr , l , mi 		  return mid					    		return mid					  
    return binarySearch ( arr , mid + 1 , r , x ) ;	      	      elif arr [ mid ] > x :				    	    if arr [ mid ] > x :				  
  }							      		  return binarySearch ( arr , l , mid - 1 , x )	    		return binary_search ( arr , l , mid - 1 , x )	  
  return - 1 ;						      	      else :						    	    return binary_search ( arr , mid + 1 , r , x )	  
}							      		  return binarySearch ( arr , mid + 1 , r , x )	    	return - 1						  
							      	  else :						    								  
							      	      return - 1					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1		      FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1		    FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1		  FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1
--							      --							    --								  --
static void findMissing ( int a [ ] , int b [ ] , int n , int def findMissing ( a , b , n , m ) :			    def find_missing ( a , b , n , m ) :			  script_not_found : None
  HashSet < Integer > s = new HashSet < > ( ) ;		      	  s = dict ( )						    	s = set ( )						  
  for ( int i = 0 ;					      	  for i in range ( m ) :				    	for i in range ( m ) :					  
  i < m ;						      	      s [ b [ i ] ] = 1					    	    s.add ( b [ i ] )					  
  i ++ ) s . add ( b [ i ] ) ;				      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      if a [ i ] not in s.keys ( ) :			    	    if a [ i ] not in s :				  
  i < n ;						      		  print ( a [ i ] , end = " " )			    		print ( a [ i ] , end = ' ' )			  
  i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . pri 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL		      MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL			    MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL			  MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL
--							      --							    --								  --
static void moveSpaceInFront ( char str [ ] ) {		      def moveSpaceInFront ( s ) :				    def moveSpaceInFront ( str ) :				  script_not_found : None
  int i = str . length - 1 ;				      	  i = len ( s ) - 1					    	i = len ( str ) - 1					  
  for ( int j = i ;					      	  for j in range ( i , - 1 , - 1 ) :			    	for j in range ( i , - 1 , - 1 ) :			  
  j >= 0 ;						      	      if ( s [ j ] != ' ' ) :				    	    if str [ j ] != ' ' :				  
  j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ] ;   		  s = s [ : i ] + s [ j ] + s [ i + 1 : ]	    		str [ i ] = str [ j ]				  
  while ( i >= 0 ) str [ i -- ] = ' ' ;			      		  i -= 1					    	while i >= 0 :						  
}							      	  while ( i >= 0 ) :					    	    str [ i ] = ' '					  
							      	      s = s [ : i ] + ' ' + s [ i + 1 : ]		    								  
							      	      i -= 1						    								  
							      	  return s						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_GREATER_ELEMENT					      NEXT_GREATER_ELEMENT					    NEXT_GREATER_ELEMENT					  NEXT_GREATER_ELEMENT
--							      --							    --								  --
static void printNGE ( int arr [ ] , int n ) {		      def printNGE ( arr ) :					    def print_nge ( arr , n ) :					  script_not_found : None
  int next , i , j ;					      	  for i in range ( 0 , len ( arr ) , 1 ) :		    	global next , i , j					  
  for ( i = 0 ;						      	      next = - 1					    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , len ( arr ) , 1 ) :	    	    next = - 1						  
  i ++ ) {						      		  if arr [ i ] < arr [ j ] :			    	    for j in range ( i + 1 , n ) :			  
    next = - 1 ;					      		      next = arr [ j ]				    		if arr [ i ] < arr [ j ] :			  
    for ( j = i + 1 ;					      		      break					    		    next = arr [ j ]				  
    j < n ;						      	      print ( str ( arr [ i ] ) + " -- " + str ( next ) )   		    break					  
    j ++ ) {						      								    	    print ( '%d -- %d' % ( arr [ i ] , next ) )		  
      if ( arr [ i ] < arr [ j ] ) {			      								    								  
	next = arr [ j ] ;				      								    								  
	break ;						      								    								  
      }							      								    								  
    }							      								    								  
    System . out . println ( arr [ i ] + " -- " + next ) ;    								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN
--							      --							    --								  --
static boolean checkDuplicatesWithinK ( int arr [ ] , int k ) def checkDuplicatesWithinK ( arr , n , k ) :		    def check_duplicates_within_k ( arr , k ) :			  script_not_found : None
  HashSet < Integer > set = new HashSet < > ( ) ;	      	  myset = [ ]						    	seen = set ( )						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( len ( arr ) ) :			  
  i < arr . length ;					      	      if arr [ i ] in myset :				    	    if arr [ i ] in seen :				  
  i ++ ) {						      		  return True					    		return True					  
    if ( set . contains ( arr [ i ] ) ) return true ;	      	      myset.append ( arr [ i ] )			    	    seen.add ( arr [ i ] )				  
    set . add ( arr [ i ] ) ;				      	      if ( i >= k ) :					    	    if i >= k :						  
    if ( i >= k ) set . remove ( arr [ i - k ] ) ;	      		  myset.remove ( arr [ i - k ] )		    		seen.discard ( arr [ i - k ] )			  
  }							      	  return False						    	return False						  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LAST_NON_ZERO_DIGIT_FACTORIAL				      LAST_NON_ZERO_DIGIT_FACTORIAL				    LAST_NON_ZERO_DIGIT_FACTORIAL				  LAST_NON_ZERO_DIGIT_FACTORIAL
--							      --							    --								  --
static int lastNon0Digit ( int n ) {			      def lastNon0Digit ( n ) :					    def last_non0_digit ( n ) :					  script_not_found : None
  if ( n < 10 ) return dig [ n ] ;			      	  if ( n < 10 ) :					    	if n < 10 :						  
  if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Di 	      return dig [ n ]					    	    return dig [ n ]					  
  else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ]  	  if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) :		    	if ( ( n // 10 ) % 10 ) % 2 == 0 :			  
}							      	      return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10  	    return ( 6 * last_non0_digit ( n // 5 ) * dig [ n % 1 
							      	  else :						    	else :							  
							      	      return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10  	    return ( 4 * last_non0_digit ( n // 5 ) * dig [ n % 1 
							      	  return 0						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY		    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY
--							      --							    --								  --
void printRepeating ( int arr [ ] , int size ) {	      def printRepeating ( arr , size ) :			    def print_repeating ( arr , size ) :			  script_not_found : None
  int i , j ;						      	  print ( "Repeating elements are " , end = '' )	    	global i , j						  
  System . out . println ( "Repeated Elements are :" ) ;      	  for i in range ( 0 , size ) :				    	print ( "Repeated Elements are :" )			  
  for ( i = 0 ;						      	      for j in range ( i + 1 , size ) :			    	for i in range ( size ) :				  
  i < size ;						      		  if arr [ i ] == arr [ j ] :			    	    for j in range ( i + 1 , size ) :			  
  i ++ ) {						      		      print ( arr [ i ] , end = ' ' )		    		if arr [ i ] == arr [ j ] :			  
    for ( j = i + 1 ;					      								    		    print ( arr [ i ] , end = " " )		  
    j < size ;						      								    								  
    j ++ ) {						      								    								  
      if ( arr [ i ] == arr [ j ] ) System . out . print ( ar 								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY		      MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY		    MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY		  MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY
--							      --							    --								  --
static int maxDistance ( int [ ] arr , int n ) {	      def maxDistance ( arr , n ) :				    def max_distance ( arr , n ) :				  success : None
  HashMap < Integer , Integer > map = new HashMap < > ( ) ;   	  mp = { }						    	d = { }							  
  int max_dist = 0 ;					      	  maxDict = 0						    	max_dist = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if arr [ i ] not in mp.keys ( ) :			    	    if arr [ i ] not in d :				  
  i ++ ) {						      		  mp [ arr [ i ] ] = i				    		d [ arr [ i ] ] = i				  
    if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr  	      else :						    	    else :						  
    else max_dist = Math . max ( max_dist , i - map . get ( a 		  maxDict = max ( maxDict , i - mp [ arr [ i ] ] )  		max_dist = max ( max_dist , i - d [ arr [ i ] ] ) 
  }							      	  return maxDict					    	return max_dist						  
  return max_dist ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EVEN_FIBONACCI_NUMBERS_SUM				      EVEN_FIBONACCI_NUMBERS_SUM				    EVEN_FIBONACCI_NUMBERS_SUM					  EVEN_FIBONACCI_NUMBERS_SUM
--							      --							    --								  --
static int evenFibSum ( int limit ) {			      def evenFibSum ( limit ) :				    def even_fib_sum ( limit ) :				  success : None
  if ( limit < 2 ) return 0 ;				      	  if ( limit < 2 ) :					    	if limit < 2 :						  
  long ef1 = 0 , ef2 = 2 ;				      	      return 0						    	    return 0						  
  long sum = ef1 + ef2 ;				      	  ef1 = 0						    	ef1 , ef2 = 0 , 2					  
  while ( ef2 <= limit ) {				      	  ef2 = 2						    	sum = ef1 + ef2						  
    long ef3 = 4 * ef2 + ef1 ;				      	  sm = ef1 + ef2					    	while ef2 <= limit :					  
    if ( ef3 > limit ) break ;				      	  while ( ef2 <= limit ) :				    	    ef3 = 4 * ef2 + ef1					  
    ef1 = ef2 ;						      	      ef3 = 4 * ef2 + ef1				    	    if ef3 > limit :					  
    ef2 = ef3 ;						      	      if ( ef3 > limit ) :				    		break						  
    sum += ef2 ;					      		  break						    	    ef1 , ef2 = ef2 , ef3				  
  }							      	      ef1 = ef2						    	    sum += ef2						  
  return ( int ) sum ;					      	      ef2 = ef3						    	return int ( sum )					  
}							      	      sm = sm + ef2					    								  
							      	  return sm						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED	      WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED	    WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED		  WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED
--							      --							    --								  --
static int countWays ( int N ) {			      def countWays ( arr , m , N ) :				    def count_ways ( N ) :					  script_not_found : None
  int count [ ] = new int [ N + 1 ] ;			      	  count = [ 0 for i in range ( N + 1 ) ]		    	count = [ 0 ] * ( N + 1 )				  
  count [ 0 ] = 1 ;					      	  count [ 0 ] = 1					    	count [ 0 ] = 1						  
  for ( int i = 1 ;					      	  for i in range ( 1 , N + 1 ) :			    	for i in range ( 1 , N + 1 ) :				  
  i <= N ;						      	      for j in range ( m ) :				    	    for j in range ( len ( arr ) ) :			  
  i ++ ) for ( int j = 0 ;				      		  if ( i >= arr [ j ] ) :			    		if i >= arr [ j ] :				  
  j < arr . length ;					      		      count [ i ] += count [ i - arr [ j ] ]	    		    count [ i ] += count [ i - arr [ j ] ]	  
  j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr 	  return count [ N ]					    	return count [ N ]					  
  return count [ N ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT
--							      --							    --								  --
static boolean check ( String str ) {			      def check ( st ) :					    def check ( data ) :					  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( st )					    	n = len ( data )					  
  if ( n == 0 ) return false ;				      	  if ( n == 0 ) :					    	if n == 0 :						  
  if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 4 ==  	      return False					    	    return False					  
  int last = str . charAt ( n - 1 ) - '0' ;		      	  if ( n == 1 ) :					    	if n == 1 :						  
  int second_last = str . charAt ( n - 2 ) - '0' ;	      	      return ( ( st [ 0 ] - '0' ) % 4 == 0 )		    	    return ( ( data [ 0 ] - '0' ) % 4 == 0 )		  
  return ( ( second_last * 10 + last ) % 4 == 0 ) ;	      	  last = ( int ) ( st [ n - 1 ] )			    	last = data [ n - 1 ] - '0'				  
}							      	  second_last = ( int ) ( st [ n - 2 ] )		    	second_last = data [ n - 2 ] - '0'			  
							      	  return ( ( second_last * 10 + last ) % 4 == 0 )	    	return ( ( second_last * 10 + last ) % 4 == 0 )		  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GNOME_SORT_A_STUPID_ONE					      GNOME_SORT_A_STUPID_ONE					    GNOME_SORT_A_STUPID_ONE					  GNOME_SORT_A_STUPID_ONE
--							      --							    --								  --
static void gnomeSort ( int arr [ ] , int n ) {		      def gnomeSort ( arr , n ) :				    def gnomeSort ( arr , n ) :					  failure : #Results: 0, 10
  int index = 0 ;					      	  index = 0						    	index = 0						  
  while ( index < n ) {					      	  while index < n :					    	while index < n :					  
    if ( index == 0 ) index ++ ;			      	      if index == 0 :					    	    if not index :					  
    if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ;      		  index = index + 1				    		index += 1					  
    else {						      	      if arr [ index ] >= arr [ index - 1 ] :		    	    if arr [ index ] >= arr [ index - 1 ] :		  
      int temp = 0 ;					      		  index = index + 1				    		index += 1					  
      temp = arr [ index ] ;				      	      else :						    	    else :						  
      arr [ index ] = arr [ index - 1 ] ;		      		  arr [ index ] , arr [ index - 1 ] = arr [ index - 		temp = 0					  
      arr [ index - 1 ] = temp ;			      		  index = index - 1				    		temp = arr [ index ]				  
      index -- ;					      	  return arr						    		arr [ index ] = arr [ index - 1 ]		  
    }							      								    		arr [ index - 1 ] = temp			  
  }							      								    		index -= 1					  
  return ;						      								    	return							  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1      HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1	    HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1	  HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1
--							      --							    --								  --
static boolean isHeap ( int arr [ ] , int n ) {		      def isHeap ( arr , n ) :					    def is_heap ( arr , n ) :					  success : None
  for ( int i = 0 ;					      	  for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) :	    	for i in range ( 0 , ( n - 2 ) // 2 + 1 ) :		  
  i <= ( n - 2 ) / 2 ;					      	      if arr [ 2 * i + 1 ] > arr [ i ] :		    	    if arr [ 2 * i + 1 ] > arr [ i ] :			  
  i ++ ) {						      		  return False					    		return False					  
    if ( arr [ 2 * i + 1 ] > arr [ i ] ) {		      	      if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ]  	    if 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] :  
      return false ;					      		  return False					    		return False					  
    }							      	  return True						    	return True						  
    if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) {   								    								  
      return false ;					      								    								  
    }							      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION    SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION    SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION	  SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION
--							      --							    --								  --
static void printSorted ( int a , int b , int c ) {	      def printSorted ( a , b , c ) :				    def printSorted ( a , b , c ) :				  script_not_found : None
  int get_max = Math . max ( a , Math . max ( b , c ) ) ;     	  get_max = max ( a , max ( b , c ) )			    	getMax = max ( a , max ( b , c ) )			  
  int get_min = - Math . max ( - a , Math . max ( - b , - c ) 	  get_min = - max ( - a , max ( - b , - c ) )		    	getMin = - max ( - a , max ( - b , - c ) )		  
  int get_mid = ( a + b + c ) - ( get_max + get_min ) ;	      	  get_mid = ( a + b + c ) - ( get_max + get_min )	    	getMid = ( a + b + c ) - ( getMax + getMin )		  
  System . out . print ( get_min + " " + get_mid + " " + get_ 	  print ( get_min , " " , get_mid , " " , get_max )	    	print ( getMin , getMid , getMax )			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY		      FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY			    FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY			  FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY
--							      --							    --								  --
static int findGreatest ( int [ ] arr , int n ) {	      def findGreatest ( arr , n ) :				    def find_greatest ( arr , n ) :				  success : None
  int result = - 1 ;					      	  result = - 1						    	result = - 1						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( n - 1 ) :			    	    for j in range ( n - 1 ) :				  
  i ++ ) for ( int j = 0 ;				      		  for k in range ( j + 1 , n ) :		    		for k in range ( j + 1 , n ) :			  
  j < n - 1 ;						      		      if ( arr [ j ] * arr [ k ] == arr [ i ] ) :   		    if arr [ j ] * arr [ k ] == arr [ i ] :	  
  j ++ ) for ( int k = j + 1 ;				      			  result = max ( result , arr [ i ] )	    			result = max ( result , arr [ i ] )	  
  k < n ;						      	  return result						    	return result						  
  k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = M 								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_PAIRS_ARRAY_XOR_0_1				      FIND_NUMBER_PAIRS_ARRAY_XOR_0_1				    FIND_NUMBER_PAIRS_ARRAY_XOR_0_1				  FIND_NUMBER_PAIRS_ARRAY_XOR_0_1
--							      --							    --								  --
static int calculate ( int a [ ] , int n ) {		      def calculate ( a ) :					    def calculate ( a , n ) :					  script_not_found : None
  int maximum = Arrays . stream ( a ) . max ( ) . getAsInt (  	  maximum = max ( a )					    	maximum = np.max ( a )					  
  int frequency [ ] = new int [ maximum + 1 ] ;		      	  frequency = [ 0 for x in range ( maximum + 1 ) ]	    	frequency = np.zeros ( maximum + 1 )			  
  for ( int i = 0 ;					      	  for i in a :						    	for i in range ( n ) :					  
  i < n ;						      	      frequency [ i ] += 1				    	    frequency [ a [ i ] ] += 1				  
  i ++ ) {						      	  answer = 0						    	answer = 0						  
    frequency [ a [ i ] ] += 1 ;			      	  for i in frequency :					    	for i in range ( ( maximum ) + 1 ) :			  
  }							      	      answer = answer + i * ( i - 1 ) // 2		    	    answer = answer + frequency [ i ] * ( frequency [ i ] 
  int answer = 0 ;					      	  return answer						    	return answer // 2					  
  for ( int i = 0 ;					      								    								  
  i < ( maximum ) + 1 ;					      								    								  
  i ++ ) {						      								    								  
    answer = answer + frequency [ i ] * ( frequency [ i ] - 1 								    								  
  }							      								    								  
  return answer / 2 ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION		      EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION		    EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION		  EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION
--							      --							    --								  --
static long exponentiation ( long base , long exp ) {	      def exponentiation ( bas , exp ) :			    def exponentiation ( base , exp ) :				  script_not_found : None
  if ( exp == 0 ) return 1 ;				      	  if ( exp == 0 ) :					    	if not exp :						  
  if ( exp == 1 ) return base % N ;			      	      return 1						    	    return 1						  
  long t = exponentiation ( base , exp / 2 ) ;		      	  if ( exp == 1 ) :					    	if exp == 1 :						  
  t = ( t * t ) % N ;					      	      return bas % N					    	    return base % N					  
  if ( exp % 2 == 0 ) return t ;			      	  t = exponentiation ( bas , int ( exp / 2 ) )		    	t = exponentiation ( base , exp // 2 )			  
  else return ( ( base % N ) * t ) % N ;		      	  t = ( t * t ) % N					    	t = ( t * t ) % N					  
}							      	  if ( exp % 2 == 0 ) :					    	if exp % 2 == 0 :					  
							      	      return t						    	    return t						  
							      	  else :						    	else :							  
							      	      return ( ( bas % N ) * t ) % N			    	    return ( ( base % N ) * t ) % N			  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE    CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE    CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE	  CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE
--							      --							    --								  --
static String printSequence ( String arr [ ] , String input ) def printSequence ( arr , input ) :			    def print_sequence ( arr , input ) :			  script_not_found : None
  String output = "" ;					      	  n = len ( input )					    	output = ""						  
  int n = input . length ( ) ;				      	  output = ""						    	n = len ( input )					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( input [ i ] == ' ' ) :			    	    if input [ i ] == " " :				  
  i ++ ) {						      		  output = output + "0"				    		output = output + "0"				  
    if ( input . charAt ( i ) == ' ' ) output = output + "0"  	      else :						    	    else :						  
    else {						      		  position = ord ( input [ i ] ) - ord ( 'A' )	    		position = ord ( input [ i ] ) - ord ( "A" )	  
      int position = input . charAt ( i ) - 'A' ;	      		  output = output + arr [ position ]		    		output = output + arr [ position ]		  
      output = output + arr [ position ] ;		      	  return output						    	return output						  
    }							      								    								  
  }							      								    								  
  return output ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LARGEST_PRIME_FACTOR_NUMBER			      FIND_LARGEST_PRIME_FACTOR_NUMBER				    FIND_LARGEST_PRIME_FACTOR_NUMBER				  FIND_LARGEST_PRIME_FACTOR_NUMBER
--							      --							    --								  --
static long maxPrimeFactors ( long n ) {		      def maxPrimeFactors ( n ) :				    def max_prime_factors ( n ) :				  error : Traceback (most recent call last):   File
  long maxPrime = - 1 ;					      	  maxPrime = - 1					    	max_prime = - 1						  "dump/transcoder_st/eval/java_python/online_st/206
  while ( n % 2 == 0 ) {				      	  while n % 2 == 0 :					    	while n % 2 == 0 :					  68770/eval_scripts/java_sa-python_sa.test/FIND_LAR
    maxPrime = 2 ;					      	      maxPrime = 2					    	    max_prime = 2					  GEST_PRIME_FACTOR_NUMBER.py", line 62, in <module>
    n >>= 1 ;						      	      n >>= 1						    	    n >>= 1						       if f_filled(*parameters_set) == f_gold(*param
  }							      	  for i in range ( 3 , int ( math.sqrt ( n ) ) + 1 , 2 ) :  	for i in range ( 3 , math.sqrt ( n ) + 1 , 2 ) :	  eters_set):	File "dump/transcoder_st/eval/java_p
  for ( int i = 3 ;					      	      while n % i == 0 :				    	    while n % i == 0 :					  ython/online_st/20668770/eval_scripts/java_sa-pyth
  i <= Math . sqrt ( n ) ;				      		  maxPrime = i					    		max_prime = i					  on_sa.test/FIND_LARGEST_PRIME_FACTOR_NUMBER.py", l
  i += 2 ) {						      		  n = n / i					    		n = n // i					  ine 38, in f_filled	  for i in range ( 3 , math.
    while ( n % i == 0 ) {				      	  if n > 2 :						    	if n > 2 :						  sqrt ( n ) + 1 , 2 ) : TypeError: 'float' object c
      maxPrime = i ;					      	      maxPrime = n					    	    max_prime = n					  annot be interpreted as an integer
      n = n / i ;					      	  return int ( maxPrime )				    	return max_prime					  
    }							      								    								  
  }							      								    								  
  if ( n > 2 ) maxPrime = n ;				      								    								  
  return maxPrime ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY		      MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY		    MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY		  MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY
--							      --							    --								  --
static int maxSum ( int arr [ ] , int n ) {		      def maxSum ( arr , n ) :					    def max_sum ( arr , n ) :					  success : None
  int res = Integer . MIN_VALUE ;			      	  res = - sys.maxsize					    	res = 0							  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      curr_sum = 0					    	    curr_sum = 0					  
  i ++ ) {						      	      for j in range ( 0 , n ) :			    	    for j in range ( n ) :				  
    int curr_sum = 0 ;					      		  index = int ( ( i + j ) % n )			    		index = ( i + j ) % n				  
    for ( int j = 0 ;					      		  curr_sum += j * arr [ index ]			    		curr_sum += j * arr [ index ]			  
    j < n ;						      	      res = max ( res , curr_sum )			    	    res = max ( res , curr_sum )			  
    j ++ ) {						      	  return res						    	return res						  
      int index = ( i + j ) % n ;			      								    								  
      curr_sum += j * arr [ index ] ;			      								    								  
    }							      								    								  
    res = Math . max ( res , curr_sum ) ;		      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I
--							      --							    --								  --
static void squareRoot ( int n , int p ) {		      def squareRoot ( n , p ) :				    def square_root ( n , p ) :					  script_not_found : None
  n = n % p ;						      	  n = n % p						    	n = n % p						  
  for ( int x = 2 ;					      	  for x in range ( 2 , p ) :				    	for x in range ( 2 , p ) :				  
  x < p ;						      	      if ( ( x * x ) % p == n ) :			    	    if ( x * x ) % p == n :				  
  x ++ ) {						      		  print ( "Square root is " , x )		    		print ( "Square %d root is %d" % ( "root" , x ) ) 
    if ( ( x * x ) % p == n ) {				      		  return					    		return						  
      System . out . println ( "Square " + "root is " + x ) ; 	  print ( "Square root doesn't exist" )			    	print ( "Square root %d doesn't exist" % ( "square root"  
      return ;						      								    								  
    }							      								    								  
  }							      								    								  
  System . out . println ( "Square root " + "doesn't exist" ) 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S			      REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S			    REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S			  REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S
--							      --							    --								  --
static String replace ( String s , char c1 , char c2 ) {      def replace ( s , c1 , c2 ) :				    def replace ( s , c1 , c2 ) :				  success : None
  int l = s . length ( ) ;				      	  l = len ( s )						    	l = len ( s )						  
  char [ ] arr = s . toCharArray ( ) ;			      	  for i in range ( l ) :				    	arr = list ( s )					  
  for ( int i = 0 ;					      	      if ( s [ i ] == c1 ) :				    	for i in range ( l ) :					  
  i < l ;						      		  s = s [ 0 : i ] + c2 + s [ i + 1 : ]		    	    if arr [ i ] == c1 :				  
  i ++ ) {						      	      elif ( s [ i ] == c2 ) :				    		arr [ i ] = c2					  
    if ( arr [ i ] == c1 ) arr [ i ] = c2 ;		      		  s = s [ 0 : i ] + c1 + s [ i + 1 : ]		    	    elif arr [ i ] == c2 :				  
    else if ( arr [ i ] == c2 ) arr [ i ] = c1 ;	      	  return s						    		arr [ i ] = c1					  
  }							      								    	return ''.join ( arr )					  
  return String . valueOf ( arr ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES
--							      --							    --								  --
static String firstLetterWord ( String str ) {		      def firstLetterWord ( str ) :				    def first_letter_word ( data ) :				  success : None
  String result = "" ;					      	  result = ""						    	result = ""						  
  boolean v = true ;					      	  v = True						    	v = True						  
  for ( int i = 0 ;					      	  for i in range ( len ( str ) ) :			    	for c in data :						  
  i < str . length ( ) ;				      	      if ( str [ i ] == ' ' ) :				    	    if c == " " :					  
  i ++ ) {						      		  v = True					    		v = True					  
    if ( str . charAt ( i ) == ' ' ) {			      	      elif ( str [ i ] != ' ' and v == True ) :		    	    elif c != " " and v == True :			  
      v = true ;					      		  result += ( str [ i ] )			    		result += ( c )					  
    }							      		  v = False					    		v = False					  
    else if ( str . charAt ( i ) != ' ' && v == true ) {      	  return result						    	return result						  
      result += ( str . charAt ( i ) ) ;		      								    								  
      v = false ;					      								    								  
    }							      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1		      MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1		    MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1			  MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1
--							      --							    --								  --
static int subset ( int arr [ ] , int n ) {		      def subset ( arr , n ) :					    def subset ( arr , n ) :					  script_not_found : None
  HashMap < Integer , Integer > mp = new HashMap < > ( ) ;    	  mp = { i : 0 for i in range ( 10 ) }			    	mp = { }						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      mp [ arr [ i ] ] += 1				    	    mp [ arr [ i ] ] = 1 if not mp.get ( arr [ i ] ) else 
  i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == nul 	  res = 0						    	res = 0							  
  int res = 0 ;						      	  for key , value in mp.items ( ) :			    	for key , value in mp.items ( ) :			  
  for ( Map . Entry < Integer , Integer > entry : mp . entryS 	      res = max ( res , value )				    	    res = max ( res , value )				  
  return res ;						      	  return res						    	return res						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK			      MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK			    MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK			  MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK
--							      --							    --								  --
static int minRotation ( int input , int unlock_code ) {      def minRotation ( input , unlock_code ) :			    def min_rotation ( input , unlockCode ) :			  error : Traceback (most recent call last):   File
  int rotation = 0 ;					      	  rotation = 0						    	rotation = 0						  "dump/transcoder_st/eval/java_python/online_st/206
  int input_digit , code_digit ;			      	  while ( input > 0 or unlock_code > 0 ) :		    	inputDigit , codeDigit = 0 , 0 , 0			  68770/eval_scripts/java_sa-python_sa.test/MINIMUM_
  while ( input > 0 || unlock_code > 0 ) {		      	      input_digit = input % 10				    	while input > 0 or unlockCode > 0 :			  ROTATIONS_UNLOCK_CIRCULAR_LOCK.py", line 55, in <m
    input_digit = input % 10 ;				      	      code_digit = unlock_code % 10			    	    inputDigit = input % 10				  odule>     if f_filled(*parameters_set) == f_gold(
    code_digit = unlock_code % 10 ;			      	      rotation += min ( abs ( input_digit - code_digit ) ,  	    codeDigit = unlockCode % 10				  *parameters_set):   File "dump/transcoder_st/eval/
    rotation += Math . min ( Math . abs ( input_digit - code_ 	      input = int ( input / 10 )			    	    rotation += min ( abs ( inputDigit - codeDigit ) , 10 java_python/online_st/20668770/eval_scripts/java_s
    input /= 10 ;					      	      unlock_code = int ( unlock_code / 10 )		    	    input //= 10					  a-python_sa.test/MINIMUM_ROTATIONS_UNLOCK_CIRCULAR
    unlock_code /= 10 ;					      	  return rotation					    	    unlockCode //= 10					  _LOCK.py", line 30, in f_filled     inputDigit , c
  }							      								    	return rotation						  odeDigit = 0 , 0 , 0 ValueError: too many values t
  return rotation ;					      								    								  o unpack (expected 2)
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_ARRAY_MAJORITY_ELEMENT				      CHECK_ARRAY_MAJORITY_ELEMENT				    CHECK_ARRAY_MAJORITY_ELEMENT				  CHECK_ARRAY_MAJORITY_ELEMENT
--							      --							    --								  --
static boolean isMajority ( int a [ ] , int n ) {	      def isMajority ( a ) :					    def is_majority ( a , n ) :					  script_not_found : None
  HashMap < Integer , Integer > mp = new HashMap < Integer ,  	  mp = { }						    	mp = { }						  
  for ( int i = 0 ;					      	  for i in a :						    	for i in range ( n ) :					  
  i < n ;						      	      if i in mp : mp [ i ] += 1			    	    if a [ i ] in mp :					  
  i ++ ) if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i 	      else : mp [ i ] = 1				    		mp [ a [ i ] ] = mp [ a [ i ] ] + 1		  
  else mp . put ( a [ i ] , 1 ) ;			      	  for x in mp :						    	    else :						  
  for ( Map . Entry < Integer , Integer > x : mp . entrySet ( 	      if mp [ x ] >= len ( a ) // 2 :			    		mp [ a [ i ] ] = 1				  
  return false ;					      		  return True					    	for x , y in mp.items ( ) :				  
}							      	  return False						    	    if y >= n // 2 :					  
							      								    		return True					  
							      								    	return False						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING	      CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING	    CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING	  CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING
--							      --							    --								  --
static int calcMaxValue ( String str ) {		      def calcMaxValue ( str ) :				    def calc_max_value ( data ) :				  success : None
  int res = str . charAt ( 0 ) - '0' ;			      	  res = ord ( str [ 0 ] ) - 48				    	res = ord ( data [ 0 ] ) - ord ( '0' )			  
  for ( int i = 1 ;					      	  for i in range ( 1 , len ( str ) ) :			    	for c in data [ 1 : ] :					  
  i < str . length ( ) ;				      	      if ( str [ i ] == '0' or str [ i ] == '1' or res < 2  	    if c in [ '0' , '1' ] or res < 2 :			  
  i ++ ) {						      		  res += ord ( str [ i ] ) - 48			    		res += ord ( c ) - ord ( '0' )			  
    if ( str . charAt ( i ) == '0' || str . charAt ( i ) == ' 	      else :						    	    else :						  
    else res *= ( str . charAt ( i ) - '0' ) ;		      		  res *= ord ( str [ i ] ) - 48			    		res *= ord ( c ) - ord ( '0' )			  
  }							      	  return res						    	return res						  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT	      NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT	    NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT	  NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT
--							      --							    --								  --
static int sumEqualProduct ( int a [ ] , int n ) {	      def sumEqualProduct ( a , n ) :				    def sum_equal_product ( a , n ) :				  success : None
  int zero = 0 , two = 0 ;				      	  zero = 0						    	zero , two = 0 , 0					  
  for ( int i = 0 ;					      	  two = 0						    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( n ) :				    	    if a [ i ] == 0 :					  
  i ++ ) {						      	      if a [ i ] == 0 :					    		zero += 1					  
    if ( a [ i ] == 0 ) {				      		  zero += 1					    	    if a [ i ] == 2 :					  
      zero ++ ;						      	      if a [ i ] == 2 :					    		two += 1					  
    }							      		  two += 1					    	cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) 
    if ( a [ i ] == 2 ) {				      	  cnt = ( zero * ( zero - 1 ) ) // 2 + \		    	return cnt						  
      two ++ ;						      	      ( two * ( two - 1 ) ) // 2			    								  
    }							      	  return cnt						    								  
  }							      								    								  
  int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) 								    								  
  return cnt ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES		      ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES			    ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES			  ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES
--							      --							    --								  --
static int winner ( int a [ ] , int n , int k ) {	      def winner ( a , n , k ) :				    def winner ( a , n , k ) :					  success : None
  if ( k >= n - 1 ) return n ;				      	  if k >= n - 1 :					    	if k >= n - 1 :						  
  int best = 0 , times = 0 ;				      	      return n						    	    return n						  
  for ( int i = 0 ;					      	  best = 0						    	best , times = 0 , 0					  
  i < n ;						      	  times = 0						    	for i in range ( n ) :					  
  i ++ ) {						      	  for i in range ( n ) :				    	    if a [ i ] > best :					  
    if ( a [ i ] > best ) {				      	      if a [ i ] > best :				    		best = a [ i ]					  
      best = a [ i ] ;					      		  best = a [ i ]				    		if i == 1 :					  
      if ( i == 1 ) times = 1 ;				      		  if i == True :				    		    times = 1					  
    }							      		      times = 1					    	    else :						  
    else times += 1 ;					      	      else :						    		times += 1					  
    if ( times >= k ) return best ;			      		  times += 1					    	    if times >= k :					  
  }							      	      if times >= k :					    		return best					  
  return best ;						      		  return best					    	return best						  
}							      	  return best						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1			      MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1			    MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1			  MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1
--							      --							    --								  --
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] ,  def maxSumPairWithDifferenceLessThanK ( arr , N , k ) :	    def max_sum_pair_with_difference_lt_k ( arr , N , k ) :	  failure : #Results: 0, 10
  int maxSum = 0 ;					      	  maxSum = 0						    	max_sum = 0						  
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  for ( int i = N - 1 ;					      	  i = N - 1						    	for i in range ( N - 1 , 0 , - 1 ) :			  
  i > 0 ;						      	  while ( i >= 0 ) :					    	    if arr [ i ] - arr [ i - 1 ] < k :			  
  -- i ) {						      	      if ( arr [ i ] - arr [ i - 1 ] < k ) :		    		max_sum += arr [ i ]				  
    if ( arr [ i ] - arr [ i - 1 ] < k ) {		      		  maxSum += arr [ i ]				    		max_sum += arr [ i - 1 ]			  
      maxSum += arr [ i ] ;				      		  maxSum += arr [ i - 1 ]			    		del i						  
      maxSum += arr [ i - 1 ] ;				      		  i -= 1					    	return max_sum						  
      -- i ;						      	      i -= 1						    								  
    }							      	  return maxSum						    								  
  }							      								    								  
  return maxSum ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1	      RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1	    RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1		  RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1
--							      --							    --								  --
static int breakSum ( int n ) {				      def breakSum ( n ) :					    def break_sum ( n ) :					  success : None
  int dp [ ] = new int [ n + 1 ] ;			      	  dp = [ 0 ] * ( n + 1 )				    	dp = [ 0 ] * ( n + 1 )					  
  dp [ 0 ] = 0 ;					      	  dp [ 0 ] = 0						    	dp [ 0 ] = 0						  
  dp [ 1 ] = 1 ;					      	  dp [ 1 ] = 1						    	dp [ 1 ] = 1						  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	      dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i  	    dp [ i ] = max ( dp [ i // 2 ] + dp [ i // 3 ] + dp [ 
  i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ]  	  return dp [ n ]					    	return dp [ n ]						  
  return dp [ n ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING
--							      --							    --								  --
static void twoWaySort ( int arr [ ] , int n ) {	      def twoWaySort ( arr , n ) :				    def two_way_sort ( arr , n ) :				  success : None
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( arr [ i ] & 1 ) :				    	    if arr [ i ] & 1 :					  
  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;     		  arr [ i ] *= - 1				    		arr [ i ] *= - 1				  
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( arr [ i ] & 1 ) :				    	    if arr [ i ] & 1 :					  
  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;     		  arr [ i ] *= - 1				    		arr [ i ] *= - 1				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1			      FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1			    FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1			  FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1
--							      --							    --								  --
static int getSingle ( int arr [ ] , int n ) {		      def getSingle ( arr , n ) :				    def get_single ( arr , n ) :				  script_not_found : None
  int result = 0 ;					      	  result = 0						    	result = 0						  
  int x , sum ;						      	  for i in range ( 0 , INT_SIZE ) :			    	x , sum = 0 , 0						  
  for ( int i = 0 ;					      	      sm = 0						    	for i in range ( INT_SIZE ) :				  
  i < INT_SIZE ;					      	      x = ( 1 << i )					    	    sum = 0						  
  i ++ ) {						      	      for j in range ( 0 , n ) :			    	    x = ( 1 << i )					  
    sum = 0 ;						      		  if ( arr [ j ] & x ) :			    	    for j in range ( n ) :				  
    x = ( 1 << i ) ;					      		      sm = sm + 1				    		if arr [ j ] & x == 0 :				  
    for ( int j = 0 ;					      	      if ( sm % 3 ) :					    		    sum += 1					  
    j < n ;						      		  result = result | x				    	    if ( sum % 3 ) == 0 :				  
    j ++ ) {						      	  return result						    		result |= x					  
      if ( ( arr [ j ] & x ) == 0 ) sum ++ ;		      								    	return result						  
    }							      								    								  
    if ( ( sum % 3 ) == 0 ) result |= x ;		      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIAGONALLY_DOMINANT_MATRIX				      DIAGONALLY_DOMINANT_MATRIX				    DIAGONALLY_DOMINANT_MATRIX					  DIAGONALLY_DOMINANT_MATRIX
--							      --							    --								  --
static boolean isDDM ( int m [ ] [ ] , int n ) {	      def isDDM ( m , n ) :					    def is_ddm ( m , n ) :					  success : None
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      sum = 0						    	    sum = 0						  
  i ++ ) {						      	      for j in range ( 0 , n ) :			    	    for j in range ( n ) :				  
    int sum = 0 ;					      		  sum = sum + abs ( m [ i ] [ j ] )		    		sum += abs ( m [ i ] [ j ] )			  
    for ( int j = 0 ;					      	      sum = sum - abs ( m [ i ] [ i ] )			    	    sum -= abs ( m [ i ] [ i ] )			  
    j < n ;						      	      if ( abs ( m [ i ] [ i ] ) < sum ) :		    	    if abs ( m [ i ] [ i ] ) < sum :			  
    j ++ ) sum += Math . abs ( m [ i ] [ j ] ) ;	      		  return False					    		return False					  
    sum -= Math . abs ( m [ i ] [ i ] ) ;		      	  return True						    	return True						  
    if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false ;  								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES
--							      --							    --								  --
static int countNum ( int [ ] arr , int n ) {		      def countNum ( arr , n ) :				    def count_num ( arr , n ) :					  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n - 1 ) :			    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr  	    if arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [  
  i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr  		  count += arr [ i + 1 ] - arr [ i ] - 1	    		count += arr [ i + 1 ] - arr [ i ] - 1		  
  return count ;					      	  return count						    	return count						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE
--							      --							    --								  --
static void printSubsequences ( int n ) {		      def printSubsequences ( arr , n ) :			    def printSubsequences ( n ) :				  script_not_found : None
  int opsize = ( int ) Math . pow ( 2 , n ) ;		      	  opsize = math.pow ( 2 , n )				    	opsize = int ( math.pow ( 2 , n ) )			  
  for ( int counter = 1 ;				      	  for counter in range ( 1 , ( int ) ( opsize ) ) :	    	for counter in range ( 1 , opsize ) :			  
  counter < opsize ;					      	      for j in range ( 0 , n ) :			    	    for j in range ( n ) :				  
  counter ++ ) {					      		  if ( counter & ( 1 << j ) ) :			    		if int ( counter ) == j :			  
    for ( int j = 0 ;					      		      print ( arr [ j ] , end = " " )		    		    print ( str ( j ) , end = ' ' )		  
    j < n ;						      	      print ( )						    	    print ( )						  
    j ++ ) {						      								    								  
      if ( BigInteger . valueOf ( counter ) . testBit ( j ) ) 								    								  
    }							      								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPETITIVE_ELEMENT_1_N_1_3				      FIND_REPETITIVE_ELEMENT_1_N_1_3				    FIND_REPETITIVE_ELEMENT_1_N_1_3				  FIND_REPETITIVE_ELEMENT_1_N_1_3
--							      --							    --								  --
static int findRepeating ( int arr [ ] , int n ) {	      def findRepeating ( arr , n ) :				    def find_repeating ( arr , n ) :				  script_not_found : None
  int missingElement = 0 ;				      	  missingElement = 0					    	missing_element = 0					  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      element = arr [ abs ( arr [ i ] ) ]		    	    element = arr [ abs ( arr [ i ] ) ]			  
  i ++ ) {						      	      if ( element < 0 ) :				    	    if element < 0 :					  
    int element = arr [ Math . abs ( arr [ i ] ) ] ;	      		  missingElement = arr [ i ]			    		missing_element = i				  
    if ( element < 0 ) {				      		  break						    		break						  
      missingElement = arr [ i ] ;			      	      arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) 	    arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) 
      break ;						      	  return abs ( missingElement )				    	return abs ( missing_element )				  
    }							      								    								  
    arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( a 								    								  
  }							      								    								  
  return Math . abs ( missingElement ) ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_BALANCED_BINARY_TREES_HEIGHT_H			      COUNT_BALANCED_BINARY_TREES_HEIGHT_H			    COUNT_BALANCED_BINARY_TREES_HEIGHT_H			  COUNT_BALANCED_BINARY_TREES_HEIGHT_H
--							      --							    --								  --
public static long countBT ( int h ) {			      def countBT ( h ) :					    def count_bt ( h ) :					  error : Traceback (most recent call last):   File
  long [ ] dp = new long [ h + 1 ] ;			      	  MOD = 1000000007					    	dp = [ 0 ] * ( h + 1 )					  "dump/transcoder_st/eval/java_python/online_st/206
  dp [ 0 ] = 1 ;					      	  dp = [ 0 for i in range ( h + 1 ) ]			    	dp [ 0 ] = 1						  68770/eval_scripts/java_sa-python_sa.test/COUNT_BA
  dp [ 1 ] = 1 ;					      	  dp [ 0 ] = 1						    	dp [ 1 ] = 1						  LANCED_BINARY_TREES_HEIGHT_H.py", line 51, in <mod
  for ( int i = 2 ;					      	  dp [ 1 ] = 1						    	for i in range ( 2 , h + 1 ) :				  ule>	   if f_filled(*parameters_set) == f_gold(*p
  i <= h ;						      	  for i in range ( 2 , h + 1 ) :			    	    dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) %  arameters_set):   File "dump/transcoder_st/eval/ja
  ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % 	      dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) %  	return dp [ h ]						  va_python/online_st/20668770/eval_scripts/java_sa-
  return dp [ h ] ;					      	  return dp [ h ]					    								  python_sa.test/COUNT_BALANCED_BINARY_TREES_HEIGHT_
}							      								    								  H.py", line 32, in f_filled	  dp [ i ] = ( dp [
							      								    								  i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i -
							      								    								  1 ] ) % MOD ) % MOD NameError: name 'MOD' is not d
							      								    								  efined
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP   GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP   GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP	  GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP
--							      --							    --								  --
static boolean isMinHeap ( int [ ] level ) {		      def isMinHeap ( level , n ) :				    def is_min_heap ( level ) :					  script_not_found : None
  int n = level . length - 1 ;				      	  for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) :	    	n = len ( level ) - 1					  
  for ( int i = ( n / 2 - 1 ) ;				      	      if level [ i ] > level [ 2 * i + 1 ] :		    	for i in range ( ( n // 2 - 1 ) , - 1 , - 1 ) :		  
  i >= 0 ;						      		  return False					    	    if level [ i ] > level [ 2 * i + 1 ] :		  
  i -- ) {						      	      if 2 * i + 2 < n :				    		return False					  
    if ( level [ i ] > level [ 2 * i + 1 ] ) return false ;   		  if level [ i ] > level [ 2 * i + 2 ] :	    	    if 2 * i + 2 < n :					  
    if ( 2 * i + 2 < n ) {				      		      return False				    		if level [ i ] > level [ 2 * i + 2 ] :		  
      if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; 	  return True						    		    return False				  
    }							      								    	return True						  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBSEQUENCE_GCD_GREATER_1			      LARGEST_SUBSEQUENCE_GCD_GREATER_1				    LARGEST_SUBSEQUENCE_GCD_GREATER_1				  LARGEST_SUBSEQUENCE_GCD_GREATER_1
--							      --							    --								  --
static int largestGCDSubsequence ( int arr [ ] , int n ) {    def largestGCDSubsequence ( arr , n ) :			    def largestGCDSubsequence ( arr , n ) :			  success : None
  int ans = 0 ;						      	  ans = 0						    	ans = 0							  
  int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( 	  maxele = max ( arr )					    	maxele = max ( arr )					  
  ;							      	  for i in range ( 2 , maxele + 1 ) :			    	for i in range ( 2 , maxele + 1 ) :			  
  for ( int i = 2 ;					      	      count = 0						    	    count = 0						  
  i <= maxele ;						      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
  ++ i ) {						      		  if ( arr [ j ] % i == 0 ) :			    		if arr [ j ] % i == 0 :				  
    int count = 0 ;					      		      count += 1				    		    count += 1					  
    for ( int j = 0 ;					      	      ans = max ( ans , count )				    	    ans = max ( ans , count )				  
    j < n ;						      	  return ans						    	return ans						  
    ++ j ) {						      								    								  
      if ( arr [ j ] % i == 0 ) ++ count ;		      								    								  
    }							      								    								  
    ans = Math . max ( ans , count ) ;			      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PATTERNS_101_GIVEN_STRING				      FIND_PATTERNS_101_GIVEN_STRING				    FIND_PATTERNS_101_GIVEN_STRING				  FIND_PATTERNS_101_GIVEN_STRING
--							      --							    --								  --
static int patternCount ( String str ) {		      def patternCount ( str ) :				    def pattern_count ( data ) :				  script_not_found : None
  char last = str . charAt ( 0 ) ;			      	  last = str [ 0 ]					    	last = data [ 0 ]					  
  int i = 1 , counter = 0 ;				      	  i = 1 counter = 0					    	i , counter = 1 , 0					  
  while ( i < str . length ( ) ) {			      	  while ( i < len ( str ) ) :				    	while i < len ( data ) :				  
    if ( str . charAt ( i ) == '0' && last == '1' ) {	      	      if ( str [ i ] == '0' and last == '1' ) :		    	    if data [ i ] == '0' and last == '1' :		  
      while ( str . charAt ( i ) == '0' ) i ++ ;	      		  while ( str [ i ] == '0' ) :			    		while data [ i ] == '0' :			  
      if ( str . charAt ( i ) == '1' ) counter ++ ;	      		      i += 1					    		    i += 1					  
    }							      		      if ( str [ i ] == '1' ) :			    		if data [ i ] == '1' :				  
    last = str . charAt ( i ) ;				      			  counter += 1				    		    counter += 1				  
    i ++ ;						      	      last = str [ i ]					    	    last = data [ i ]					  
  }							      	      i += 1						    	    i += 1						  
  return counter ;					      	  return counter					    	return counter						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_ FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_ FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_ FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_
--							      --							    --								  --
static int countSol ( int coeff [ ] , int n , int rhs ) {     def countSol ( coeff , n , rhs ) :			    def count_sol ( coeff , n , rhs ) :				  script_not_found : None
  int dp [ ] = new int [ rhs + 1 ] ;			      	  dp = [ 0 for i in range ( rhs + 1 ) ]			    	dp = [ 0 ] * ( rhs + 1 )				  
  Arrays . fill ( dp , 0 ) ;				      	  dp [ 0 ] = 1						    	dp [ 0 ] = 1						  
  dp [ 0 ] = 1 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      for j in range ( coeff [ i ] , rhs + 1 ) :	    	    for j in range ( coeff [ i ] , rhs + 1 ) :		  
  i < n ;						      		  dp [ j ] += dp [ j - coeff [ i ] ]		    		dp [ j ] += dp [ j - coeff [ i ] ]		  
  i ++ ) for ( int j = coeff [ i ] ;			      	  return dp [ rhs ]					    	return dp [ rhs ]					  
  j <= rhs ;						      								    								  
  j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ;		      								    								  
  return dp [ rhs ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES		      PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES		    PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES			  PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES
--							      --							    --								  --
static void fib ( int n ) {				      def fib ( n ) :						    def fib ( n ) :						  script_not_found : None
  int a = 0 , b = 1 , c ;				      	  a = 0							    	a , b , c = 0 , 1 , 0					  
  if ( n >= 0 ) System . out . print ( a + " " ) ;	      	  b = 1							    	if n >= 0 :						  
  if ( n >= 1 ) System . out . print ( b + " " ) ;	      	  if ( n >= 0 ) :					    	    print ( a , end = ' ' )				  
  for ( int i = 2 ;					      	      print ( a , end = ' ' )				    	if n >= 1 :						  
  i <= n ;						      	  if ( n >= 1 ) :					    	    print ( b , end = ' ' )				  
  i ++ ) {						      	      print ( b , end = ' ' )				    	for i in range ( 2 , n + 1 ) :				  
    c = a + b ;						      	  for i in range ( 2 , n + 1 ) :			    	    c = a + b						  
    System . out . print ( c + " " ) ;			      	      c = a + b						    	    print ( c , end = ' ' )				  
    a = b ;						      	      print ( c , end = ' ' )				    	    a = b						  
    b = c ;						      	      a = b						    	    b = c						  
  }							      	      b = c						    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER
--							      --							    --								  --
static boolean flipsPossible ( int [ ] a , int n ) {	      def flipsPossible ( a , n ) :				    def flips_possible ( a , n ) :				  success : None
  int count_odd = 0 , count_even = 0 ;			      	  count_odd = 0 count_even = 0				    	count_odd , count_even = 0 , 0				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( a [ i ] & 1 ) :				    	    if a [ i ] & 1 == 1 :				  
  i ++ ) {						      		  count_odd += 1				    		count_odd += 1					  
    if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ;		      	      else :						    	    else :						  
    else count_even ++ ;				      		  count_even += 1				    		count_even += 1					  
  }							      	  if ( count_odd % 2 and count_even % 2 ) :		    	if count_odd % 2 == 1 and count_even % 2 == 1 :		  
  if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return fal 	      return False					    	    return False					  
  else return true ;					      	  else :						    	else :							  
}							      	      return True					    	    return True						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_ROOT_NUMBER					      N_TH_ROOT_NUMBER						    N_TH_ROOT_NUMBER						  N_TH_ROOT_NUMBER
--							      --							    --								  --
static double nthRoot ( int A , int N ) {		      def nthRoot ( A , N ) :					    def nth_root ( A , N ) :					  script_not_found : None
  double xPre = Math . random ( ) % 10 ;		      	  xPre = random.randint ( 1 , 101 ) % 10		    	x_pre = random.random ( ) % 10				  
  double eps = 0.001 ;					      	  eps = 0.001						    	eps = 0.001						  
  double delX = 2147483647 ;				      	  delX = 2147483647					    	del_x = 2147483647					  
  double xK = 0.0 ;					      	  xK = 0.0						    	x_k = 0.0						  
  while ( delX > eps ) {				      	  while ( delX > eps ) :				    	while del_x > eps :					  
    xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( x 	      xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 )  	    x_k = ( ( N - 1.0 ) * x_pre + float ( A ) / pow ( x_p 
    delX = Math . abs ( xK - xPre ) ;			      	      delX = abs ( xK - xPre )				    	    del_x = abs ( x_k - x_pre )				  
    xPre = xK ;						      	      xPre = xK						    	    x_pre = x_k						  
  }							      	  return xK						    	return x_k						  
  return xK ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY		      COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY			    COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY			  COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY
--							      --							    --								  --
static int countPairs ( int arr [ ] , int n ) {		      def countPairs ( arr , n ) :				    def count_pairs ( arr , n ) :				  success : None
  int result = 0 ;					      	  result = 0 ;						    	result = 0						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) {						      		  product = arr [ i ] * arr [ j ] ;		    		product = arr [ i ] * arr [ j ]			  
    for ( int j = i + 1 ;				      		  for k in range ( 0 , n ) :			    		for k in range ( n ) :				  
    j < n ;						      		      if ( arr [ k ] == product ) :		    		    if arr [ k ] == product :			  
    j ++ ) {						      			  result = result + 1 ;			    			result += 1				  
      int product = arr [ i ] * arr [ j ] ;		      			  break ;				    			break					  
      for ( int k = 0 ;					      	  return result ;					    	return result						  
      k < n ;						      								    								  
      k ++ ) {						      								    								  
	if ( arr [ k ] == product ) {			      								    								  
	  result ++ ;					      								    								  
	  break ;					      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SERIES_23_45_67_89_UPTO_N_TERMS			      SUM_SERIES_23_45_67_89_UPTO_N_TERMS			    SUM_SERIES_23_45_67_89_UPTO_N_TERMS				  SUM_SERIES_23_45_67_89_UPTO_N_TERMS
--							      --							    --								  --
static double seriesSum ( int n ) {			      def seriesSum ( n ) :					    def series_sum ( n ) :					  failure : #Results: 0, 10
  int i = 1 ;						      	  i = 1							    	i = 1							  
  double res = 0.0 ;					      	  res = 0.0						    	res = 0.0						  
  boolean sign = true ;					      	  sign = True						    	sign = True						  
  while ( n > 0 ) {					      	  while ( n > 0 ) :					    	while n > 0 :						  
    n -- ;						      	      n = n - 1						    	    n -= 1						  
    if ( sign ) {					      	      if ( sign ) :					    	    if sign :						  
      sign = ! sign ;					      		  sign = False					    		sign = not sign					  
      res = res + ( double ) ++ i / ++ i ;		      		  res = res + ( i + 1 ) / ( i + 2 )		    		res = res + float ( i )				  
    }							      		  i = i + 2					    		i += 1						  
    else {						      	      else :						    		i += 1						  
      sign = ! sign ;					      		  sign = True					    	    else :						  
      res = res - ( double ) ++ i / ++ i ;		      		  res = res - ( i + 1 ) / ( i + 2 )		    		sign = not sign					  
    }							      		  i = i + 2					    		res = res - float ( i )				  
  }							      	  return res						    		i += 1						  
  return res ;						      								    		i += 1						  
}							      								    	return res						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_ELEMENT_ROW_MATRIX				      FIND_MAXIMUM_ELEMENT_ROW_MATRIX				    FIND_MAXIMUM_ELEMENT_ROW_MATRIX				  FIND_MAXIMUM_ELEMENT_ROW_MATRIX
--							      --							    --								  --
public static void maxelement ( int no_of_rows , int [ ] [ ]  def maxelement ( arr ) :					    def maxelement ( no_of_rows , arr ) :			  script_not_found : None
  int i = 0 ;						      	  no_of_rows = len ( arr )				    	i = 0							  
  int max = 0 ;						      	  no_of_column = len ( arr [ 0 ] )			    	max = 0							  
  int [ ] result = new int [ no_of_rows ] ;		      	  for i in range ( no_of_rows ) :			    	result = [ ]						  
  while ( i < no_of_rows ) {				      	      max1 = 0						    	while i < no_of_rows :					  
    for ( int j = 0 ;					      	      for j in range ( no_of_column ) :			    	    for j in range ( len ( arr [ i ] ) ) :		  
    j < arr [ i ] . length ;				      		  if arr [ i ] [ j ] > max1 :			    		if arr [ i ] [ j ] > max :			  
    j ++ ) {						      		      max1 = arr [ i ] [ j ]			    		    max = arr [ i ] [ j ]			  
      if ( arr [ i ] [ j ] > max ) {			      	      print ( max1 )					    	    result.append ( max )				  
	max = arr [ i ] [ j ] ;				      								    	    max = 0						  
      }							      								    	    i += 1						  
    }							      								    	print_array ( result )					  
    result [ i ] = max ;				      								    								  
    max = 0 ;						      								    								  
    i ++ ;						      								    								  
  }							      								    								  
  printArray ( result ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_X_Y_SATISFYING_AX_N				      FIND_X_Y_SATISFYING_AX_N					    FIND_X_Y_SATISFYING_AX_N					  FIND_X_Y_SATISFYING_AX_N
--							      --							    --								  --
static void solution ( int a , int b , int n ) {	      def solution ( a , b , n ) :				    def solution ( a , b , n ) :				  script_not_found : None
  for ( int i = 0 ;					      	  i = 0							    	for i in range ( 0 , a + n + 1 ) :			  
  i * a <= n ;						      	  while i * a <= n :					    	    if ( n - ( i * a ) ) % b == 0 :			  
  i ++ ) {						      	      if ( n - ( i * a ) ) % b == 0 :			    		print ( "x = %d, y = %d" % ( i , ( n - ( i * a )  
    if ( ( n - ( i * a ) ) % b == 0 ) {			      		  print ( "x = " , i , ", y = " , int ( ( n - ( i * 		return						  
      System . out . println ( "x = " + i + ", y = " + ( n -  		  return 0					    	print ( "No solution" )					  
      return ;						      	      i = i + 1						    								  
    }							      	  print ( "No solution" )				    								  
  }							      								    								  
  System . out . println ( "No solution" ) ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1      SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1	    SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1	  SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1
--							      --							    --								  --
static int findSum ( int n ) {				      def findSum ( n ) :					    def find_sum ( n ) :					  failure : #Results: 0, 10
  int ans = 0 , temp = 0 , num ;			      	  ans = 0 temp = 0					    	ans , temp , num = 0 , 0 , 0				  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= n && temp < n ;					      	      if temp < n :					    	    temp = i - 1					  
  i ++ ) {						      		  temp = i - 1					    	    num = 1						  
    temp = i - 1 ;					      		  num = 1					    	    while temp < n :					  
    num = 1 ;						      		  while temp < n :				    		if temp + i <= n :				  
    while ( temp < n ) {				      		      if temp + i <= n :			    		    ans += ( i * num )				  
      if ( temp + i <= n ) ans += ( i * num ) ;		      			  ans += i * num			    		else :						  
      else ans += ( ( n - temp ) * num ) ;		      		      else :					    		    ans += ( ( n - temp ) * num )		  
      temp += i ;					      			  ans += ( n - temp ) * num		    		temp += i					  
      num ++ ;						      		      temp += i					    		num += 1					  
    }							      		      num += 1					    	return ans						  
  }							      	  return ans						    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1	      PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1	    PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1	  PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1
--							      --							    --								  --
static boolean isPrime ( int n ) {			      def isPrime ( n ) :					    def is_prime ( n ) :					  failure : #Results: 9, 10
  if ( n <= 1 ) return false ;				      	  if ( n <= 1 ) :					    	if n <= 1 :						  
  if ( n <= 3 ) return true ;				      	      return False					    	    return False					  
  if ( n % 2 == 0 || n % 3 == 0 ) return false ;	      	  if ( n <= 3 ) :					    	if n <= 3 :						  
  for ( int i = 5 ;					      	      return True					    	    return True						  
  i * i <= n ;						      	  if ( n % 2 == 0 or n % 3 == 0 ) :			    	if n % 2 == 0 or n % 3 == 0 :				  
  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return  	      return False					    	    return False					  
  return true ;						      	  i = 5							    	for i in range ( 5 , n * 2 + 6 ) :			  
}							      	  while ( i * i <= n ) :				    	    if n % i == 0 or n % ( i + 2 ) == 0 :		  
							      	      if ( n % i == 0 or n % ( i + 2 ) == 0 ) :		    		return False					  
							      		  return False					    	return True						  
							      	      i = i + 6						    								  
							      	  return True						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_FUNCTIONS					      RECURSIVE_FUNCTIONS					    RECURSIVE_FUNCTIONS						  RECURSIVE_FUNCTIONS
--							      --							    --								  --
static void tower ( int n , char sourcePole , char destinatio def tower ( n , sourcePole , destinationPole , auxiliaryPole  def tower ( n , source_pole , destination_pole , auxiliary_po script_not_found : None
  if ( 0 == n ) return ;				      	  if ( 0 == n ) :					    	if 0 == n :						  
  tower ( n - 1 , sourcePole , auxiliaryPole , destinationPol 	      return						    	    return						  
  System . out . printf ( "Move the disk %d from %c to %c\n"  	  tower ( n - 1 , sourcePole , auxiliaryPole , destinationP 	tower ( n - 1 , source_pole , auxiliary_pole , destinatio 
  tower ( n - 1 , auxiliaryPole , destinationPole , sourcePol 	  print ( "Move the disk" , sourcePole , "from" , sourcePol 	sys.stdout.write ( 'Move the disk %d from %c to %c\n' % ( 
}							      	  tower ( n - 1 , auxiliaryPole , destinationPole , sourceP 	tower ( n - 1 , auxiliary_pole , destination_pole , sourc 
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT			      CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT			    CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT			  CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT
--							      --							    --								  --
static int circle ( int x1 , int y1 , int x2 , int y2 , int r def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) :		    def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) :		  success : None
  int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 	  distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - 	dist_sq = ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2		  
  int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ;		      	  radSumSq = ( r1 + r2 ) * ( r1 + r2 )			    	rad_sq = ( r1 + r2 ) ** 2				  
  if ( distSq == radSumSq ) return 1 ;			      	  if ( distSq == radSumSq ) :				    	if dist_sq == rad_sq :					  
  else if ( distSq > radSumSq ) return - 1 ;		      	      return 1						    	    return 1						  
  else return 0 ;					      	  elif ( distSq > radSumSq ) :				    	elif dist_sq > rad_sq :					  
}							      	      return - 1					    	    return - 1						  
							      	  else :						    	else :							  
							      	      return 0						    	    return 0						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER		      NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER		    NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER		  NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER
--							      --							    --								  --
static int minimumBox ( int [ ] arr , int n ) {		      def minimumBox ( arr , n ) :				    def minimumBox ( arr , n ) :				  failure : #Results: 0, 10
  Queue < Integer > q = new LinkedList < > ( ) ;	      	  q = collections.deque ( [ ] )				    	q = [ ]							  
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  q . add ( arr [ 0 ] ) ;				      	  q.append ( arr [ 0 ] )				    	q.append ( arr [ 0 ] )					  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i < n ;						      	      now = q [ 0 ]					    	    now = q.pop ( )					  
  i ++ ) {						      	      if ( arr [ i ] >= 2 * now ) :			    	    if arr [ i ] >= 2 * now :				  
    int now = q . element ( ) ;				      		  q.popleft ( )					    		q.append ( now )				  
    if ( arr [ i ] >= 2 * now ) q . remove ( ) ;	      	      q.append ( arr [ i ] )				    	    q.append ( arr [ i ] )				  
    q . add ( arr [ i ] ) ;				      	  return len ( q )					    	return len ( q )					  
  }							      								    								  
  return q . size ( ) ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1		      PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1		    PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1		  PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1
--							      --							    --								  --
static void fib ( int n ) {				      def fib ( n ) :						    def fib ( n ) :						  script_not_found : None
  int a = 0 , b = 1 ;					      	  a = 0							    	a , b = 0 , 1						  
  if ( n >= 0 ) System . out . print ( a + " " ) ;	      	  b = 1							    	if n >= 0 :						  
  if ( n >= 1 ) System . out . print ( b + " " ) ;	      	  if ( n >= 0 ) :					    	    print ( a , end = ' ' )				  
  for ( int i = 2 ;					      	      print ( a , end = ' ' )				    	if n >= 1 :						  
  i <= n ;						      	  if ( n >= 1 ) :					    	    print ( b , end = ' ' )				  
  i ++ ) {						      	      print ( b , end = ' ' )				    	for i in range ( 2 , n + 1 ) :				  
    System . out . print ( a + b + " " ) ;		      	  for i in range ( 2 , n + 1 ) :			    	    print ( a + b , end = ' ' )				  
    b = a + b ;						      	      print ( a + b , end = ' ' )			    	    b = a + b						  
    a = b - a ;						      	      b = a + b						    	    a = b - a						  
  }							      	      a = b - a						    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_DIFFERENCE_EQUAL_K_1			      COUNT_PAIRS_DIFFERENCE_EQUAL_K_1				    COUNT_PAIRS_DIFFERENCE_EQUAL_K_1				  COUNT_PAIRS_DIFFERENCE_EQUAL_K_1
--							      --							    --								  --
static int countPairsWithDiffK ( int arr [ ] , int n , int k  def countPairsWithDiffK ( arr , n , k ) :			    def count_pairs_with_diff_k ( arr , n , k ) :		  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  int l = 0 ;						      	  l = 0							    	l = 0							  
  int r = 0 ;						      	  r = 0							    	r = 0							  
  while ( r < n ) {					      	  while r < n :						    	while r < n :						  
    if ( arr [ r ] - arr [ l ] == k ) {			      	      if arr [ r ] - arr [ l ] == k :			    	    if arr [ r ] - arr [ l ] == k :			  
      count ++ ;					      		  count += 1					    		count += 1					  
      l ++ ;						      		  l += 1					    		l += 1						  
      r ++ ;						      		  r += 1					    		r += 1						  
    }							      	      elif arr [ r ] - arr [ l ] > k :			    	    elif arr [ r ] - arr [ l ] > k :			  
    else if ( arr [ r ] - arr [ l ] > k ) l ++ ;	      		  l += 1					    		l += 1						  
    else r ++ ;						      	      else :						    	    else :						  
  }							      		  r += 1					    		r += 1						  
  return count ;					      	  return count						    	return count						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_WAVE_FORM_2_1				      SORT_ARRAY_WAVE_FORM_2_1					    SORT_ARRAY_WAVE_FORM_2_1					  SORT_ARRAY_WAVE_FORM_2_1
--							      --							    --								  --
void sortInWave ( int arr [ ] , int n ) {		      def sortInWave ( arr , n ) :				    def sort_in_wave ( arr , n ) :				  error : Traceback (most recent call last):   File
  for ( int i = 0 ;					      	  for i in range ( 0 , n , 2 ) :			    	for i in range ( 0 , n , 2 ) :				  "dump/transcoder_st/eval/java_python/online_st/206
  i < n ;						      	      if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) :	    	    if i > 0 and arr [ i - 1 ] > arr [ i ] :		  68770/eval_scripts/java_sa-python_sa.test/SORT_ARR
  i += 2 ) {						      		  arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ 		swap ( arr , i - 1 , i )			  AY_WAVE_FORM_2_1.py", line 60, in <module>	 f_f
    if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( arr , i  	      if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) :	    	    if i < n - 1 and arr [ i ] < arr [ i + 1 ] :	  illed(*(filled_function_param[i]))   File "dump/tr
    if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( arr  		  arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ 		swap ( arr , i , i + 1 )			  anscoder_st/eval/java_python/online_st/20668770/ev
  }							      								    								  al_scripts/java_sa-python_sa.test/SORT_ARRAY_WAVE_
}							      								    								  FORM_2_1.py", line 30, in f_filled	 swap ( arr
							      								    								  , i , i + 1 ) NameError: name 'swap' is not define
							      								    								  d
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_COMMON_SUBSEQUENCE				      LONGEST_COMMON_SUBSEQUENCE				    LONGEST_COMMON_SUBSEQUENCE					  LONGEST_COMMON_SUBSEQUENCE
--							      --							    --								  --
int lcs ( char [ ] X , char [ ] Y , int m , int n ) {	      def lcs ( X , Y , m , n ) :				    def lcs ( X , Y , m , n ) :					  script_not_found : None
  if ( m == 0 || n == 0 ) return 0 ;			      	  if m == 0 or n == 0 :					    	if m == 0 or n == 0 :					  
  if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y ,  	      return 0 ;					    	    return 0						  
  else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , 	  elif X [ m - 1 ] == Y [ n - 1 ] :			    	if X [ m - 1 ] == Y [ n - 1 ] :				  
}							      	      return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;	    	    return 1 + lcs ( X , Y , m - 1 , n - 1 )		  
							      	  else :						    	else :							  
							      	      return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y  	    return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS    REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS    REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS	  REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS
--							      --							    --								  --
public static void psuedoBinary ( int n ) {		      def psuedoBinary ( n ) :					    def psuedo_binary ( n ) :					  script_not_found : None
  while ( n != 0 ) {					      	  while ( n > 0 ) :					    	while n != 0 :						  
    int temp = n , m = 0 , p = 1 ;			      	      temp = n						    	    temp , m , p = n , 0 , 1				  
    while ( temp != 0 ) {				      	      m = 0						    	    while temp != 0 :					  
      int rem = temp % 10 ;				      	      p = 1						    		rem = temp % 10					  
      temp = temp / 10 ;				      	      while ( temp ) :					    		temp = temp // 10				  
      if ( rem != 0 ) m += p ;				      		  rem = temp % 10				    		if rem != 0 :					  
      p *= 10 ;						      		  temp = int ( temp / 10 )			    		    m += p					  
    }							      		  if ( rem != 0 ) :				    		p *= 10						  
    System . out . print ( m + " " ) ;			      		      m += p					    	    print ( m , end = ' ' )				  
    n = n - m ;						      		  p *= 10					    	    n = n - m						  
  }							      	      print ( m , end = " " )				    	print ( ' ' )						  
  System . out . println ( " " ) ;			      	      n = n - m						    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NON_REPEATING_ELEMENT_1					      NON_REPEATING_ELEMENT_1					    NON_REPEATING_ELEMENT_1					  NON_REPEATING_ELEMENT_1
--							      --							    --								  --
static int firstNonRepeating ( int arr [ ] , int n ) {	      def firstNonRepeating ( arr , n ) :			    def first_non_repeating ( arr , n ) :			  script_not_found : None
  Map < Integer , Integer > m = new HashMap < > ( ) ;	      	  mp = defaultdict ( lambda : 0 )			    	m = { }							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      mp [ arr [ i ] ] += 1				    	    if arr [ i ] in m :					  
  i ++ ) {						      	  for i in range ( n ) :				    		m [ arr [ i ] ] = m [ arr [ i ] ] + 1		  
    if ( m . containsKey ( arr [ i ] ) ) {		      	      if mp [ arr [ i ] ] == 1 :			    	    else :						  
      m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ;     		  return arr [ i ]				    		m [ arr [ i ] ] = 1				  
    }							      	  return - 1						    	for i in range ( n ) :					  
    else {						      								    	    if m [ arr [ i ] ] == 1 :				  
      m . put ( arr [ i ] , 1 ) ;			      								    		return arr [ i ]				  
    }							      								    	return - 1						  
  }							      								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ; 								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1	      COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1	    COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1	  COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1
--							      --							    --								  --
static int countPairs ( String str ) {			      def countPairs ( str1 ) :					    def count_pairs ( str ) :					  script_not_found : None
  int result = 0 ;					      	  result = 0 ;						    	result = 0						  
  int n = str . length ( ) ;				      	  n = len ( str1 )					    	n = len ( str )						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( 1 , MAX_CHAR + 1 ) :		    	    for j in range ( 1 , ( n + 1 ) ) :			  
  i ++ ) for ( int j = 1 ;				      		  if ( ( i + j ) < n ) :			    		if ( abs ( str [ i + j ] - str [ i ] ) == j ) :	  
  ( i + j ) < n && j <= MAX_CHAR ;			      		      if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( s 		    result += 1					  
  j ++ ) if ( ( Math . abs ( str . charAt ( i + j ) - str . c 			  result += 1 ;				    	return result						  
  return result ;					      	  return result						    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S		      FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S		    FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S		  FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S
--							      --							    --								  --
static void findMax ( int arr [ ] [ ] ) {		      def findMax ( arr ) :					    def find_max ( arr ) :					  script_not_found : None
  int row = 0 , i , j ;					      	  row = 0						    	row , i , j = 0 , 0 , 0					  
  for ( i = 0 , j = N - 1 ;				      	  j = N - 1						    	for i , j in enumerate ( arr ) :			  
  i < N ;						      	  for i in range ( 0 , N ) :				    	    while j >= 0 and arr [ i ] [ j ] == 1 :		  
  i ++ ) {						      	      while ( arr [ i ] [ j ] == 1 and j >= 0 ) :	    		row = i						  
    while ( j >= 0 && arr [ i ] [ j ] == 1 ) {		      		  row = i					    		j -= 1						  
      row = i ;						      		  j -= 1					    	print ( "Row number = %d" % ( row + 1 ) , end = "" )	  
      j -- ;						      	  print ( "Row number = " , row + 1 , ", MaxCount = " , N - 	print ( ", MaxCount = %d" % ( N - 1 - j ) , end = "" )	  
    }							      								    								  
  }							      								    								  
  System . out . print ( "Row number = " + ( row + 1 ) ) ;    								    								  
  System . out . print ( ", MaxCount = " + ( N - 1 - j ) ) ;  								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY		      SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY		    SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY			  SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY
--							      --							    --								  --
static int binarySearch ( int arr [ ] , int low , int high ,  def binarySearch ( arr , low , high , key ) :		    def binary_search ( arr , low , high , key ) :		  success : None
  if ( high < low ) return - 1 ;			      	  if ( high < low ) :					    	if high < low :						  
  int mid = ( low + high ) / 2 ;			      	      return - 1					    	    return - 1						  
  if ( key == arr [ mid ] ) return mid ;		      	  mid = ( low + high ) / 2				    	mid = ( low + high ) // 2				  
  if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid  	  if ( key == arr [ int ( mid ) ] ) :			    	if key == arr [ mid ] :					  
  return binarySearch ( arr , low , ( mid - 1 ) , key ) ;     	      return mid					    	    return mid						  
}							      	  if ( key > arr [ int ( mid ) ] ) :			    	if key > arr [ mid ] :					  
							      	      return binarySearch ( arr , ( mid + 1 ) , high , key  	    return binary_search ( arr , ( mid + 1 ) , high , key 
							      	  return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) 	return binary_search ( arr , low , ( mid - 1 ) , key )	  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_TRIPLET_SUM_ARRAY				      MAXIMUM_TRIPLET_SUM_ARRAY					    MAXIMUM_TRIPLET_SUM_ARRAY					  MAXIMUM_TRIPLET_SUM_ARRAY
--							      --							    --								  --
static int maxTripletSum ( int arr [ ] , int n ) {	      def maxTripletSum ( arr , n ) :				    def max_triplet_sum ( arr , n ) :				  success : None
  int sum = - 1000000 ;					      	  sm = - 1000000					    	sum = - 1000000						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) for ( int j = i + 1 ;				      		  for k in range ( j + 1 , n ) :		    		for k in range ( j + 1 , n ) :			  
  j < n ;						      		      if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] 		    if sum < arr [ i ] + arr [ j ] + arr [ k ] :  
  j ++ ) for ( int k = j + 1 ;				      			  sm = arr [ i ] + arr [ j ] + arr [ k ]    			sum = arr [ i ] + arr [ j ] + arr [ k ]	  
  k < n ;						      	  return sm						    	return sum						  
  k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = 								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX			      CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX			    CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX				  CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX
--							      --							    --								  --
static boolean areSumSame ( int a [ ] [ ] , int n , int m ) { def areSumSame ( a , n , m ) :				    def are_sum_same ( a , n , m ) :				  success : None
  int sum1 = 0 , sum2 = 0 ;				      	  sum1 = 0						    	sum1 , sum2 = 0 , 0					  
  for ( int i = 0 ;					      	  sum2 = 0						    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( 0 , n ) :				    	    sum1 = sum2 = 0					  
  i ++ ) {						      	      sum1 = 0						    	    for j in range ( m ) :				  
    sum1 = 0 ;						      	      sum2 = 0						    		sum1 += a [ i ] [ j ]				  
    sum2 = 0 ;						      	      for j in range ( 0 , m ) :			    		sum2 += a [ j ] [ i ]				  
    for ( int j = 0 ;					      		  sum1 += a [ i ] [ j ]				    	    if sum1 == sum2 :					  
    j < m ;						      		  sum2 += a [ j ] [ i ]				    		return True					  
    j ++ ) {						      	      if ( sum1 == sum2 ) :				    	return False						  
      sum1 += a [ i ] [ j ] ;				      		  return 1					    								  
      sum2 += a [ j ] [ i ] ;				      	  return 0						    								  
    }							      								    								  
    if ( sum1 == sum2 ) return true ;			      								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATE_PYTHAGOREAN_TRIPLETS				      GENERATE_PYTHAGOREAN_TRIPLETS				    GENERATE_PYTHAGOREAN_TRIPLETS				  GENERATE_PYTHAGOREAN_TRIPLETS
--							      --							    --								  --
static void pythagoreanTriplets ( int limit ) {		      def pythagoreanTriplets ( limits ) :			    def pythagorean_triplets ( limit ) :			  script_not_found : None
  int a , b , c = 0 ;					      	  c , m = 0 , 2						    	a , b , c = 0 , 0 , 0					  
  int m = 2 ;						      	  while c < limits :					    	m = 2							  
  while ( c < limit ) {					      	      for n in range ( 1 , m ) :			    	while c < limit :					  
    for ( int n = 1 ;					      		  a = m * m - n * n				    	    for n in range ( 1 , m ) :				  
    n < m ;						      		  b = 2 * m * n					    		a = m * m - n * n				  
    ++ n ) {						      		  c = m * m + n * n				    		b = 2 * m * n					  
      a = m * m - n * n ;				      		  if c > limits :				    		c = m * m + n * n				  
      b = 2 * m * n ;					      		      break					    		if c > limit :					  
      c = m * m + n * n ;				      		  print ( a , b , c )				    		    break					  
      if ( c > limit ) break ;				      	      m = m + 1						    		print ( a , b , c )				  
      System . out . println ( a + " " + b + " " + c ) ;      								    	    m += 1						  
    }							      								    								  
    m ++ ;						      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE		      CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE		    CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE		  CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE
--							      --							    --								  --
static void convertOpposite ( StringBuffer str ) {	      def convertOpposite ( str ) :				    def convert_opposite ( str ) :				  script_not_found : None
  int ln = str . length ( ) ;				      	  ln = len ( str )					    	ln = len ( str )					  
  for ( int i = 0 ;					      	  for i in range ( ln ) :				    	for i in range ( ln ) :					  
  i < ln ;						      	      if str [ i ] >= 'a' and str [ i ] <= 'z' :	    	    c = str [ i ]					  
  i ++ ) {						      		  str [ i ] = chr ( ord ( str [ i ] ) - 32 )	    	    if c.islower ( ) :					  
    Character c = str . charAt ( i ) ;			      	      elif str [ i ] >= 'A' and str [ i ] <= 'Z' :	    		str [ i ] = c.upper ( ) + ''			  
    if ( Character . isLowerCase ( c ) ) str . replace ( i ,  		  str [ i ] = chr ( ord ( str [ i ] ) + 32 )	    	    else :						  
    else str . replace ( i , i + 1 , Character . toLowerCase  								    		str [ i ] = c.lower ( ) + ''			  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N		      COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N		    COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N		  COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N
--							      --							    --								  --
static int countSetBits ( int n ) {			      def countSetBits ( n ) :					    def count_set_bits ( n ) :					  success : None
  int i = 0 ;						      	  i = 0							    	i = 0							  
  int ans = 0 ;						      	  ans = 0						    	ans = 0							  
  while ( ( 1 << i ) <= n ) {				      	  while ( ( 1 << i ) <= n ) :				    	while ( 1 << i ) <= n :					  
    boolean k = false ;					      	      k = 0						    	    k = False						  
    int change = 1 << i ;				      	      change = 1 << i					    	    change = 1 << i					  
    for ( int j = 0 ;					      	      for j in range ( 0 , n + 1 ) :			    	    for j in range ( 0 , n + 1 ) :			  
    j <= n ;						      		  ans += k					    		if k == True :					  
    j ++ ) {						      		  if change == 1 :				    		    ans += 1					  
      if ( k == true ) ans += 1 ;			      		      k = not k					    		else :						  
      else ans += 0 ;					      		      change = 1 << i				    		    ans += 0					  
      if ( change == 1 ) {				      		  else :					    		if change == 1 :				  
	k = ! k ;					      		      change -= 1				    		    k = not k					  
	change = 1 << i ;				      	      i += 1						    		    change = 1 << i				  
      }							      	  return ans						    		else :						  
      else {						      								    		    change -= 1					  
	change -- ;					      								    	    i += 1						  
      }							      								    	return ans						  
    }							      								    								  
    i ++ ;						      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIRROR_CHARACTERS_STRING				      MIRROR_CHARACTERS_STRING					    MIRROR_CHARACTERS_STRING					  MIRROR_CHARACTERS_STRING
--							      --							    --								  --
static String compute ( String str , int n ) {		      def compute ( st , n ) :					    def compute ( data , n ) :					  script_not_found : None
  String reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ;     	  reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba"	    	reverse_alphabet = 'zyxwvutsrqponmlkjihgfedcba'		  
  int l = str . length ( ) ;				      	  l = len ( st )					    	l = len ( data )					  
  String answer = "" ;					      	  answer = ""						    	answer = ""						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for c in data [ n : ] :					  
  i < n ;						      	      answer = answer + st [ i ]			    	    answer = answer + c					  
  i ++ ) answer = answer + str . charAt ( i ) ;		      	  for i in range ( n , l ) :				    	for c in data [ n : l ] :				  
  for ( int i = n ;					      	      answer = ( answer + reverseAlphabet [ ord ( st [ i ]  	    answer = answer + reverse_alphabet [ ord ( c ) - ord  
  i < l ;						      	  return answer						    	return answer						  
  i ++ ) answer = answer + reverseAlphabet . charAt ( str . c 								    								  
  return answer ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N		      FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N		    FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N			  FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N
--							      --							    --								  --
static int findRepeatingElement ( int arr [ ] , int low , int def findRepeatingElement ( arr , low , high ) :		    def find_repeating_element ( arr , low , high ) :		  script_not_found : None
  if ( low > high ) return - 1 ;			      	  if low > high :					    	if low > high :						  
  int mid = ( low + high ) / 2 ;			      	      return - 1					    	    return - 1						  
  if ( arr [ mid ] != mid + 1 ) {			      	  mid = ( low + high ) / 2				    	mid = ( low + high ) // 2				  
    if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return m 	  if ( arr [ mid ] != mid + 1 ) :			    	if arr [ mid ] != mid + 1 :				  
    return findRepeatingElement ( arr , low , mid - 1 ) ;     	      if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) :   	    if mid > 0 and arr [ mid ] == arr [ mid - 1 ] :	  
  }							      		  return mid					    		return mid					  
  return findRepeatingElement ( arr , mid + 1 , high ) ;      	      return findRepeatingElement ( arr , low , mid - 1 )   	    return find_repeating_element ( arr , low , mid - 1 ) 
}							      	  return findRepeatingElement ( arr , mid + 1 , high )	    	return find_repeating_element ( arr , mid + 1 , high )	  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM			      REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM			    REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM			  REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM
--							      --							    --								  --
static void rearrange ( int [ ] arr , int n ) {		      def rearrange ( arr , n ) :				    def rearrange ( arr , n ) :					  failure : #Results: 0, 10
  int temp [ ] = new int [ n ] ;			      	  temp = n * [ None ]					    	temp = [ ]						  
  int small = 0 , large = n - 1 ;			      	  small , large = 0 , n - 1				    	small , large = 0 , n - 1				  
  boolean flag = true ;					      	  flag = True						    	flag = True						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if flag is True :					    	    if flag :						  
  i ++ ) {						      		  temp [ i ] = arr [ large ]			    		temp.append ( arr [ large ] )			  
    if ( flag ) temp [ i ] = arr [ large -- ] ;		      		  large -= 1					    		large -= 1					  
    else temp [ i ] = arr [ small ++ ] ;		      	      else :						    	    else :						  
    flag = ! flag ;					      		  temp [ i ] = arr [ small ]			    		temp.append ( arr [ small ] )			  
  }							      		  small += 1					    		small += 1					  
  arr = temp . clone ( ) ;				      	      flag = bool ( 1 - flag )				    	    flag = not flag					  
}							      	  for i in range ( n ) :				    	arr = temp [ : ]					  
							      	      arr [ i ] = temp [ i ]				    								  
							      	  return arr						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY		      MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY		    MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY		  MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY
--							      --							    --								  --
static int findArea ( Integer arr [ ] , int n ) {	      def findArea ( arr , n ) :				    def find_area ( arr = None , n = None ) :			  error : Traceback (most recent call last):   File
  Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;    	  arr.sort ( reverse = True )				    	arr.sort ( reverse = True )				  "dump/transcoder_st/eval/java_python/online_st/206
  int [ ] dimension = {					      	  dimension = [ 0 , 0 ]					    	dimension = [ 0 , 0 ]					  68770/eval_scripts/java_sa-python_sa.test/MAXIMUM_
    0 , 0 }						      	  i = 0							    	for i , j in enumerate ( arr ) :			  AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY.py", line
    ;							      	  j = 0							    	    if arr [ i ] == arr [ i + 1 ] :			  56, in <module>     if f_filled(*parameters_set) =
    for ( int i = 0 , j = 0 ;				      	  while ( i < n - 1 and j < 2 ) :			    		dimension [ j ] = i				  = f_gold(*parameters_set):   File "dump/transcoder
    i < n - 1 && j < 2 ;				      	      if ( arr [ i ] == arr [ i + 1 ] ) :		    	    i += 1						  _st/eval/java_python/online_st/20668770/eval_scrip
    i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ 		  dimension [ j ] = arr [ i ]			    	return ( dimension [ 0 ] * dimension [ 1 ] )		  ts/java_sa-python_sa.test/MAXIMUM_AREA_RECTANGLE_P
    return ( dimension [ 0 ] * dimension [ 1 ] ) ;	      		  j += 1					    								  ICKING_FOUR_SIDES_ARRAY.py", line 36, in f_filled
  }							      		  i += 1					    								      dimension [ j ] = i IndexError: list assignmen
							      	      i += 1						    								  t index out of range
							      	  return ( dimension [ 0 ] * dimension [ 1 ] )		    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM			      DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM			    DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM			  DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM
--							      --							    --								  --
static boolean isSubsetSum ( int set [ ] , int n , int sum )  def isSubsetSum ( set , n , sum ) :			    def is_subset_sum ( set , n , sum ) :			  script_not_found : None
  if ( sum == 0 ) return true ;				      	  if ( sum == 0 ) :					    	if not sum :						  
  if ( n == 0 && sum != 0 ) return false ;		      	      return True					    	    return True						  
  if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 	  if ( n == 0 and sum != 0 ) :				    	if not n and sum :					  
  return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( s 	      return False					    	    return False					  
}							      	  if ( set [ n - 1 ] > sum ) :				    	if set [ n - 1 ] > sum :				  
							      	      return isSubsetSum ( set , n - 1 , sum )		    	    return is_subset_sum ( set , n - 1 , sum )		  
							      	  return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( 	return is_subset_sum ( set , n - 1 , sum ) or is_subset_s 
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	      DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	    DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	  DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1
--							      --							    --								  --
static boolean checkCount ( int arr [ ] , int n , int k ) {   def checkCount ( arr , n , k ) :				    def check_count ( arr , n , k ) :				  script_not_found : None
  HashMap < Integer , Integer > hash = new HashMap < > ( ) ;  	  mp = defaultdict ( lambda : 0 )			    	hash = { }						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      mp [ arr [ i ] ] += 1				    	    if arr [ i ] not in hash :				  
  i ++ ) {						      	  for key , values in mp.items ( ) :			    		hash [ arr [ i ] ] = 0				  
    if ( ! hash . containsKey ( arr [ i ] ) ) hash . put ( ar 	      if values > 2 * k :				    	    hash [ arr [ i ] ] = hash [ arr [ i ] ] + 1		  
    hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; 		  return False					    	for x in hash.items ( ) :				  
  }							      	  return True						    	    if int ( x ) > 2 * k :				  
  for ( Map . Entry x : hash . entrySet ( ) ) if ( ( int ) x  								    		return False					  
  return true ;						      								    	return True						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_GFG_SUBSEQUENCES_GIVEN_STRING			      COUNT_GFG_SUBSEQUENCES_GIVEN_STRING			    COUNT_GFG_SUBSEQUENCES_GIVEN_STRING				  COUNT_GFG_SUBSEQUENCES_GIVEN_STRING
--							      --							    --								  --
static void countSubsequence ( String s , int n ) {	      def countSubsequence ( s , n ) :				    def count_subsequence ( s , n ) :				  script_not_found : None
  int cntG = 0 , cntF = 0 , result = 0 , C = 0 ;	      	  cntG = 0						    	cntG , cntF , result , C = 0 , 0 , 0 , 0		  
  for ( int i = 0 ;					      	  cntF = 0						    	for i in range ( n ) :					  
  i < n ;						      	  result = 0						    	    if s [ i ] == 'G' :					  
  i ++ ) {						      	  C = 0							    		cntG += 1					  
    switch ( s . charAt ( i ) ) {			      	  for i in range ( n ) :				    		result += C					  
      case 'G' : cntG ++ ;				      	      if ( s [ i ] == 'G' ) :				    	    elif s [ i ] == 'F' :				  
      result += C ;					      		  cntG += 1					    		cntF += 1					  
      break ;						      		  result += C					    		C += cntG					  
      case 'F' : cntF ++ ;				      		  continue					    	    else :						  
      C += cntG ;					      	      if ( s [ i ] == 'F' ) :				    		continue					  
      break ;						      		  cntF += 1					    	print ( result )					  
      default : continue ;				      		  C += cntG					    								  
    }							      		  continue					    								  
  }							      	      else :						    								  
  System . out . println ( result ) ;			      		  continue					    								  
}							      	  print ( result )					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING	      MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING		    MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING		  MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING
--							      --							    --								  --
static int maxDP ( int n ) {				      def maxDP ( n ) :						    def max_dp ( n ) :						  success : None
  int res [ ] = new int [ n + 1 ] ;			      	  res = list ( )					    	res = [ 0 ] * ( n + 1 )					  
  res [ 0 ] = 0 ;					      	  res.append ( 0 )					    	res [ 0 ] = 0						  
  res [ 1 ] = 1 ;					      	  res.append ( 1 )					    	res [ 1 ] = 1						  
  for ( int i = 2 ;					      	  i = 2							    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	  while i < n + 1 :					    	    res [ i ] = max ( i , ( res [ i // 2 ] + res [ i // 3 
  i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ 	      res.append ( max ( i , ( res [ int ( i / 2 ) ] + res  	return res [ n ]					  
  return res [ n ] ;					      	      i = i + 1						    								  
}							      	  return res [ n ]					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_COMMON_SUPERSEQUENCE				      SHORTEST_COMMON_SUPERSEQUENCE				    SHORTEST_COMMON_SUPERSEQUENCE				  SHORTEST_COMMON_SUPERSEQUENCE
--							      --							    --								  --
static int superSeq ( String X , String Y , int m , int n ) { def superSeq ( X , Y , m , n ) :				    def superSeq ( X , Y , m , n ) :				  script_not_found : None
  if ( m == 0 ) return n ;				      	  if ( not m ) : return n				    	if not m :						  
  if ( n == 0 ) return m ;				      	  if ( not n ) : return m				    	    return n						  
  if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return  	  if ( X [ m - 1 ] == Y [ n - 1 ] ) :			    	if not n :						  
  return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , su 	      return 1 + superSeq ( X , Y , m - 1 , n - 1 )	    	    return m						  
}							      	  return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSe 	if X [ m - 1 ] == Y [ n - 1 ] :				  
							      								    	    return 1 + superSeq ( X , Y , m - 1 , n - 1 )	  
							      								    	return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSe 
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE		      FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE		    FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE		  FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE
--							      --							    --								  --
static int minCoins ( int coins [ ] , int m , int V ) {	      def minCoins ( coins , m , V ) :				    def min_coins ( coins , m , V ) :				  script_not_found : None
  if ( V == 0 ) return 0 ;				      	  if ( V == 0 ) :					    	if not V :						  
  int res = Integer . MAX_VALUE ;			      	      return 0						    	    return 0						  
  for ( int i = 0 ;					      	  res = sys.maxsize					    	res = sys.maxsize					  
  i < m ;						      	  for i in range ( 0 , m ) :				    	for i in range ( m ) :					  
  i ++ ) {						      	      if ( coins [ i ] <= V ) :				    	    if coins [ i ] <= V :				  
    if ( coins [ i ] <= V ) {				      		  sub_res = minCoins ( coins , m , V - coins [ i ]  		sub_res = min_coins ( coins , m , V - coins [ i ] 
      int sub_res = minCoins ( coins , m , V - coins [ i ] )  		  if ( sub_res != sys.maxsize and sub_res + 1 < res 		if sub_res != sys.maxsize and sub_res + 1 < res : 
      if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < re 		      res = sub_res + 1				    		    res = sub_res + 1				  
    }							      	  return res						    	return res						  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1		      UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1		    UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1		  UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1
--							      --							    --								  --
static void printIntersection ( int arr1 [ ] , int arr2 [ ] , def printIntersection ( arr1 , arr2 , m , n ) :		    def print_intersection ( arr1 , arr2 , m , n ) :		  script_not_found : None
  int i = 0 , j = 0 ;					      	  i , j = 0 , 0						    	i , j = 0 , 0						  
  while ( i < m && j < n ) {				      	  while i < m and j < n :				    	while i < m and j < n :					  
    if ( arr1 [ i ] < arr2 [ j ] ) i ++ ;		      	      if arr1 [ i ] < arr2 [ j ] :			    	    if arr1 [ i ] < arr2 [ j ] :			  
    else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ;		      		  i += 1					    		i += 1						  
    else {						      	      elif arr2 [ j ] < arr1 [ i ] :			    	    elif arr2 [ j ] < arr1 [ i ] :			  
      System . out . print ( arr2 [ j ++ ] + " " ) ;	      		  j += 1					    		j += 1						  
      i ++ ;						      	      else :						    	    else :						  
    }							      		  print ( arr2 [ j ] )				    		print ( arr2 [ j ] , end = ' ' )		  
  }							      		  j += 1					    		i += 1						  
}							      		  i += 1					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1 COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1 COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1 COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1
--							      --							    --								  --
static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , def countPairs ( arr1 , arr2 , m , n , x ) :		    def count_pairs ( arr1 , arr2 , m , n , x ) :		  success : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  HashSet < Integer > us = new HashSet < Integer > ( ) ;      	  us = set ( )						    	us = set ( )						  
  for ( int i = 0 ;					      	  for i in range ( m ) :				    	for i in range ( m ) :					  
  i < m ;						      	      us.add ( arr1 [ i ] )				    	    us.add ( arr1 [ i ] )				  
  i ++ ) us . add ( arr1 [ i ] ) ;			      	  for j in range ( n ) :				    	for j in range ( n ) :					  
  for ( int j = 0 ;					      	      if x - arr2 [ j ] in us :				    	    if x - arr2 [ j ] in us :				  
  j < n ;						      		  count += 1					    		count += 1					  
  j ++ ) if ( us . contains ( x - arr2 [ j ] ) ) count ++ ;   	  return count						    	return count						  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS	      POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS	    POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS	  POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS
--							      --							    --								  --
static boolean isPresent ( String s , String q ) {	      def isPresent ( s , q ) :					    def isPresent ( s , q ) :					  script_not_found : None
  int [ ] freq = new int [ MAX_CHAR ] ;			      	  freq = [ 0 ] * MAX_CHAR				    	freq = [ 0 ] * MAX_CHAR					  
  for ( int i = 0 ;					      	  for i in range ( 0 , len ( s ) ) :			    	for c in s :						  
  i < s . length ( ) ;					      	      freq [ ord ( s [ i ] ) ] += 1			    	    freq [ ord ( c ) ] += 1				  
  i ++ ) freq [ s . charAt ( i ) ] ++ ;			      	  for i in range ( 0 , len ( q ) ) :			    	for c in q :						  
  for ( int i = 0 ;					      	      freq [ ord ( q [ i ] ) ] -= 1			    	    freq [ ord ( c ) ] -= 1				  
  i < q . length ( ) ;					      	      if ( freq [ ord ( q [ i ] ) ] < 0 ) :		    	    if freq [ ord ( c ) ] < 0 :				  
  i ++ ) {						      		  return False					    		return False					  
    freq [ q . charAt ( i ) ] -- ;			      	  return True						    	return True						  
    if ( freq [ q . charAt ( i ) ] < 0 ) return false ;	      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE			      PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE			    PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE			  PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE
--							      --							    --								  --
static String censor ( String text , String word ) {	      def censor ( text , word ) :				    def censor ( text , word ) :				  failure : #Results: 0, 10
  String [ ] word_list = text . split ( "\\s+" ) ;	      	  word_list = text.split ( )				    	word_list = text.split ( ' ' )				  
  String result = "" ;					      	  result = ''						    	result = ""						  
  String stars = "" ;					      	  stars = '*' * len ( word )				    	stars = ""						  
  for ( int i = 0 ;					      	  count = 0						    	for i in range ( len ( word ) ) :			  
  i < word . length ( ) ;				      	  index = 0						    	    stars += "*"					  
  i ++ ) stars += '*' ;					      	  for i in word_list :					    	index = 0						  
  int index = 0 ;					      	      if i == word :					    	for i in word_list :					  
  for ( String i : word_list ) {			      		  word_list [ index ] = stars			    	    if i == word :					  
    if ( i . compareTo ( word ) == 0 ) word_list [ index ] =  	      index += 1					    		word_list [ index ] = stars			  
    index ++ ;						      	  result = ' '.join ( word_list )			    	    index += 1						  
  }							      	  return result						    	for i in word_list :					  
  for ( String i : word_list ) result += i + ' ' ;	      								    	    result += i + " "					  
  return result ;					      								    	return result						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT
--							      --							    --								  --
static boolean check ( String str ) {			      def check ( st ) :					    def check ( data ) :					  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( st )					    	n = len ( data )					  
  int oddDigSum = 0 , evenDigSum = 0 ;			      	  oddDigSum = 0						    	odddigit_sum , evendigit_sum = 0 , 0			  
  for ( int i = 0 ;					      	  evenDigSum = 0					    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( 0 , n ) :				    	    if i % 2 == 0 :					  
  i ++ ) {						      	      if ( i % 2 == 0 ) :				    		odddigit_sum += ord ( data [ i ] ) - ord ( '0' )  
    if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' 		  oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) )  	    else :						  
    else evenDigSum += ( str . charAt ( i ) - '0' ) ;	      	      else :						    		evendigit_sum += ord ( data [ i ] ) - ord ( '0' ) 
  }							      		  evenDigSum = evenDigSum + ( ( int ) ( st [ i ] )  	return ( ( odddigit_sum - evendigit_sum ) % 11 == 0 )	  
  return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ;	      	  return ( ( oddDigSum - evenDigSum ) % 11 == 0 )	    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES		      NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES		    NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES		  NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES
--							      --							    --								  --
static int countOccurrences ( String s , int K ) {	      def countOccurrences ( s , K ) :				    def count_occurrences ( s , K ) :				  success : None
  int n = s . length ( ) ;				      	  n = len ( s )						    	n = len ( s )						  
  int C = 0 , c1 = 0 , c2 = 0 ;				      	  c1 = 0						    	C , c1 , c2 = 0 , 0 , 0					  
  for ( int i = 0 ;					      	  c2 = 0						    	for c in s :						  
  i < n ;						      	  C = 0							    	    if c == 'a' :					  
  i ++ ) {						      	  for i in range ( n ) :				    		c1 += 1						  
    if ( s . charAt ( i ) == 'a' ) c1 ++ ;		      	      if s [ i ] == 'a' :				    	    if c == 'b' :					  
    if ( s . charAt ( i ) == 'b' ) {			      		  c1 += 1					    		c2 += 1						  
      c2 ++ ;						      	      if s [ i ] == 'b' :				    		C += c1						  
      C += c1 ;						      		  c2 += 1					    	return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2		  
    }							      		  C += c1					    								  
  }							      	  return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2	    								  
  return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1	    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1
--							      --							    --								  --
void printRepeating ( int arr [ ] , int size ) {	      def printRepeating ( arr , size ) :			    def print_repeating ( arr , size ) :			  script_not_found : None
  int count [ ] = new int [ size ] ;			      	  count = [ 0 ] * size					    	count = [ 0 ] * size					  
  int i ;						      	  print ( " Repeating elements are " , end = "" )	    	i = 0							  
  System . out . println ( "Repeated elements are : " ) ;     	  for i in range ( 0 , size ) :				    	print ( "Repeated elements are : " )			  
  for ( i = 0 ;						      	      if ( count [ arr [ i ] ] == 1 ) :			    	for i in range ( size ) :				  
  i < size ;						      		  print ( arr [ i ] , end = " " )		    	    if count [ arr [ i ] ] == 1 :			  
  i ++ ) {						      	      else :						    		print ( arr [ i ] , end = ' ' )			  
    if ( count [ arr [ i ] ] == 1 ) System . out . print ( ar 		  count [ arr [ i ] ] = count [ arr [ i ] ] + 1	    	    else :						  
    else count [ arr [ i ] ] ++ ;			      								    		count [ arr [ i ] ] += 1			  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1	      COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1	    COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1	  COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1
--							      --							    --								  --
static int countSubstringWithEqualEnds ( String s ) {	      def countSubstringWithEqualEnds ( s ) :			    def count_substring_with_equal_ends ( s ) :			  script_not_found : None
  int result = 0 ;					      	  result = 0						    	result = 0						  
  int n = s . length ( ) ;				      	  n = len ( s )						    	n = len ( s )						  
  int [ ] count = new int [ MAX_CHAR ] ;		      	  count = [ 0 ] * MAX_CHAR				    	count = [ 0 ] * MAX_CHAR				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for c in s :						  
  i < n ;						      	      count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1	    	    count [ ord ( c ) - ord ( 'a' ) ] += 1		  
  i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ;		      	  for i in range ( MAX_CHAR ) :				    	for c in s :						  
  for ( int i = 0 ;					      	      result += ( count [ i ] * ( count [ i ] + 1 ) / 2 )   	    result += ( count [ c ] * ( count [ c ] + 1 ) / 2 )	  
  i < MAX_CHAR ;					      	  return result						    	return result						  
  i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 )  								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEGREGATE_EVEN_ODD_NUMBERS_SET_3			      SEGREGATE_EVEN_ODD_NUMBERS_SET_3				    SEGREGATE_EVEN_ODD_NUMBERS_SET_3				  SEGREGATE_EVEN_ODD_NUMBERS_SET_3
--							      --							    --								  --
static void arrayEvenAndOdd ( int arr [ ] , int n ) {	      def arrayEvenAndOdd ( arr , n ) :				    def array_even_and_odd ( arr , n ) :			  success : None
  int i = - 1 , j = 0 ;					      	  i = - 1						    	i , j = - 1 , 0						  
  while ( j != n ) {					      	  j = 0							    	while j != n :						  
    if ( arr [ j ] % 2 == 0 ) {				      	  while ( j != n ) :					    	    if arr [ j ] % 2 == 0 :				  
      i ++ ;						      	      if ( arr [ j ] % 2 == 0 ) :			    		i += 1						  
      int temp = arr [ i ] ;				      		  i = i + 1					    		temp = arr [ i ]				  
      arr [ i ] = arr [ j ] ;				      		  arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]	    		arr [ i ] = arr [ j ]				  
      arr [ j ] = temp ;				      	      j = j + 1						    		arr [ j ] = temp				  
    }							      	  for i in arr :					    	    j += 1						  
    j ++ ;						      	      print ( str ( i ) + " " , end = '' )		    	for k in range ( n ) :					  
  }							      								    	    print ( arr [ k ] , end = ' ' )			  
  for ( int k = 0 ;					      								    								  
  k < n ;						      								    								  
  k ++ ) System . out . print ( arr [ k ] + " " ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE	      REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE	    REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE		  REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE
--							      --							    --								  --
static String reversingString ( char [ ] str , int start , in def reversingString ( str , start , end ) :		    def reversingString ( str , start , end ) :			  script_not_found : None
  while ( start < end ) {				      	  while ( start < end ) :				    	while start < end :					  
    str [ start ] ^= str [ end ] ;			      	      str = ( str [ : start ] + chr ( ord ( str [ start ] ) 	    str [ start ] ^= str [ end ]			  
    str [ end ] ^= str [ start ] ;			      	      str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ 	    str [ end ] ^= str [ start ]			  
    str [ start ] ^= str [ end ] ;			      	      str = ( str [ : start ] + chr ( ord ( str [ start ] ) 	    str [ start ] ^= str [ end ]			  
    ++ start ;						      	      start += 1					    	    start += 1						  
    -- end ;						      	      end -= 1						    	    end -= 1						  
  }							      	  return str						    	return str						  
  return String . valueOf ( str ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING	      RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING	    RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING	  RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING
--							      --							    --								  --
static char getMaxOccuringChar ( String str ) {		      def getMaxOccuringChar ( str ) :				    def get_max_occuring_char ( data ) :			  script_not_found : None
  int count [ ] = new int [ ASCII_SIZE ] ;		      	  count = [ 0 ] * ASCII_SIZE				    	count = [ 0 ] * ASCII_SIZE				  
  int len = str . length ( ) ;				      	  max = - 1						    	data = list ( data )					  
  for ( int i = 0 ;					      	  c = ''						    	for c in data :						  
  i < len ;						      	  for i in str :					    	    count [ ord ( c ) ] += 1				  
  i ++ ) count [ str . charAt ( i ) ] ++ ;		      	      count [ ord ( i ) ] += 1 ;			    	max = - 1						  
  int max = - 1 ;					      	  for i in str :					    	result = ' '						  
  char result = ' ' ;					      	      if max < count [ ord ( i ) ] :			    	for c in data :						  
  for ( int i = 0 ;					      		  max = count [ ord ( i ) ]			    	    if max < count [ ord ( c ) ] :			  
  i < len ;						      		  c = i						    		max = count [ ord ( c ) ]			  
  i ++ ) {						      	  return c						    		result = c					  
    if ( max < count [ str . charAt ( i ) ] ) {		      								    	return result						  
      max = count [ str . charAt ( i ) ] ;		      								    								  
      result = str . charAt ( i ) ;			      								    								  
    }							      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_1S_SORTED_BINARY_ARRAY				      COUNT_1S_SORTED_BINARY_ARRAY				    COUNT_1S_SORTED_BINARY_ARRAY				  COUNT_1S_SORTED_BINARY_ARRAY
--							      --							    --								  --
int countOnes ( bool arr [ ] , int low , int high ) {	      def countOnes ( arr , low , high ) :			    def count_ones ( arr , low , high ) :			  script_not_found : None
  if ( high >= low ) {					      	  if high >= low :					    	if high >= low :					  
    int mid = low + ( high - low ) / 2 ;		      	      mid = low + ( high - low ) / 2			    	    mid = low + ( high - low ) // 2			  
    if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ m 	      if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( ar 	    if ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr  
    if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid +  		  return mid + 1				    		return mid + 1					  
    return countOnes ( arr , low , ( mid - 1 ) ) ;	      	      if arr [ mid ] == 1 :				    	    if arr [ mid ] == 1 :				  
  }							      		  return countOnes ( arr , ( mid + 1 ) , high )	    		return count_ones ( arr , ( mid + 1 ) , high )	  
  return 0 ;						      	      return countOnes ( arr , low , mid - 1 )		    	    return count_ones ( arr , low , ( mid - 1 ) )	  
}							      	  return 0						    	return 0						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C
--							      --							    --								  --
static void fitOrNotFit ( int R , int r , int x , int y , int def fitOrNotFit ( R , r , x , y , rad ) :			    def fit_or_not_fit ( R , r , x , y , rad ) :		  script_not_found : None
  double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . po 	  val = math.sqrt ( math.pow ( x , 2 ) + math.pow ( y , 2 ) 	val = math.sqrt ( math.pow ( x , 2 ) + math.pow ( y , 2 ) 
  if ( val + rad <= R && val - rad >= R - r ) System . out .  	  if ( val + rad <= R and val - rad >= R - r ) :	    	if val + rad <= R and val - rad >= R - r :		  
  else System . out . println ( "Doesn't Fit" ) ;	      	      print ( "Fits\n" )				    	    print ( "Fits" )					  
}							      	  else :						    	else :							  
							      	      print ( "Doesn't Fit" )				    	    print ( "Doesn't Fit" )				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EQUILIBRIUM_INDEX_OF_AN_ARRAY				      EQUILIBRIUM_INDEX_OF_AN_ARRAY				    EQUILIBRIUM_INDEX_OF_AN_ARRAY				  EQUILIBRIUM_INDEX_OF_AN_ARRAY
--							      --							    --								  --
int equilibrium ( int arr [ ] , int n ) {		      def equilibrium ( arr ) :					    def equilibrium ( arr , n ) :				  script_not_found : None
  int i , j ;						      	  leftsum = 0						    	global leftsum , rightsum				  
  int leftsum , rightsum ;				      	  rightsum = 0						    	for i in range ( n ) :					  
  for ( i = 0 ;						      	  n = len ( arr )					    	    leftsum = 0						  
  i < n ;						      	  for i in range ( n ) :				    	    for j in range ( i ) :				  
  ++ i ) {						      	      leftsum = 0					    		leftsum += arr [ j ]				  
    leftsum = 0 ;					      	      rightsum = 0					    	    rightsum = 0					  
    for ( j = 0 ;					      	      for j in range ( i ) :				    	    for j in range ( i + 1 , n ) :			  
    j < i ;						      		  leftsum += arr [ j ]				    		rightsum += arr [ j ]				  
    j ++ ) leftsum += arr [ j ] ;			      	      for j in range ( i + 1 , n ) :			    	    if leftsum == rightsum :				  
    rightsum = 0 ;					      		  rightsum += arr [ j ]				    		return i					  
    for ( j = i + 1 ;					      	      if leftsum == rightsum :				    	return - 1						  
    j < n ;						      		  return i					    								  
    j ++ ) rightsum += arr [ j ] ;			      	  return - 1						    								  
    if ( leftsum == rightsum ) return i ;		      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX		      MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX		    MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX		  MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX
--							      --							    --								  --
static int maxDecimalValue ( int mat [ ] [ ] , int i , int j  def maxDecimalValue ( mat , i , j , p ) :			    def max_decimal_value ( mat , i , j , p ) :			  script_not_found : None
  if ( i >= N || j >= N ) {				      	  if i >= N or j >= N :					    	if i >= N or j >= N :					  
    return 0 ;						      	      return 0						    	    return 0						  
  }							      	  result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1  	result = max ( max_decimal_value ( mat , i , j + 1 , p +  
  int result = Math . max ( maxDecimalValue ( mat , i , j + 1 	  if mat [ i ] [ j ] == 1 :				    	if mat [ i ] [ j ] == 1 :				  
  if ( mat [ i ] [ j ] == 1 ) {				      	      return pow ( 2 , p ) + result			    	    return int ( pow ( 2 , p ) + result )		  
    return ( int ) ( Math . pow ( 2 , p ) + result ) ;	      	  else :						    	else :							  
  }							      	      return result					    	    return result					  
  else {						      								    								  
    return result ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP	      HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP	    HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP	  HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP
--							      --							    --								  --
static boolean isHeap ( int arr [ ] , int i , int n ) {	      def isHeap ( arr , i , n ) :				    def is_heap ( arr , i , n ) :				  success : None
  if ( i > ( n - 2 ) / 2 ) {				      	  if i > int ( ( n - 2 ) / 2 ) :			    	if i > ( n - 2 ) // 2 :					  
    return true ;					      	      return True					    	    return True						  
  }							      	  if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr  	if arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [  
  if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 	      return True					    	    return True						  
    return true ;					      	  return False						    	return False						  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION	      DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION	    DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION	  DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION
--							      --							    --								  --
static int MatrixChainOrder ( int p [ ] , int i , int j ) {   def MatrixChainOrder ( p , i , j ) :			    def MatrixChainOrder ( p , i , j ) :			  script_not_found : None
  if ( i == j ) return 0 ;				      	  if i == j :						    	if i == j :						  
  int min = Integer . MAX_VALUE ;			      	      return 0						    	    return 0						  
  for ( int k = i ;					      	  _min = sys.maxsize					    	min = sys.maxsize					  
  k < j ;						      	  for k in range ( i , j ) :				    	for k in range ( i , j ) :				  
  k ++ ) {						      	      count = ( MatrixChainOrder ( p , i , k ) + MatrixChai 	    count = MatrixChainOrder ( p , i , k ) + MatrixChainO 
    int count = MatrixChainOrder ( p , i , k ) + MatrixChainO 	      if count < _min :					    	    if count < min :					  
    if ( count < min ) min = count ;			      		  _min = count					    		min = count					  
  }							      	  return _min						    	return min						  
  return min ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_FIBONACCI_NUMBERS					      SUM_FIBONACCI_NUMBERS					    SUM_FIBONACCI_NUMBERS					  SUM_FIBONACCI_NUMBERS
--							      --							    --								  --
static int calculateSum ( int n ) {			      def calculateSum ( n ) :					    def calculate_sum ( n ) :					  success : None
  if ( n <= 0 ) return 0 ;				      	  if ( n <= 0 ) :					    	if n <= 0 :						  
  int fibo [ ] = new int [ n + 1 ] ;			      	      return 0						    	    return 0						  
  fibo [ 0 ] = 0 ;					      	  fibo = [ 0 ] * ( n + 1 )				    	fibo = [ 0 ] * ( n + 1 )				  
  fibo [ 1 ] = 1 ;					      	  fibo [ 1 ] = 1					    	fibo [ 0 ] = 0						  
  int sum = fibo [ 0 ] + fibo [ 1 ] ;			      	  sm = fibo [ 0 ] + fibo [ 1 ]				    	fibo [ 1 ] = 1						  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 1 ) :			    	sum = fibo [ 0 ] + fibo [ 1 ]				  
  i <= n ;						      	      fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ]	    	for i in range ( 2 , n + 1 ) :				  
  i ++ ) {						      	      sm = sm + fibo [ i ]				    	    fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ]	  
    fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;	      	  return sm						    	    sum += fibo [ i ]					  
    sum += fibo [ i ] ;					      								    	return sum						  
  }							      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I
--							      --							    --								  --
static int countDer ( int n ) {				      def countDer ( n ) :					    def count_der ( n ) :					  success : None
  int der [ ] = new int [ n + 1 ] ;			      	  der = [ 0 for i in range ( n + 1 ) ]			    	der = [ 1 ] * ( n + 1 )					  
  der [ 0 ] = 1 ;					      	  der [ 0 ] = 1						    	der [ 0 ] = 1						  
  der [ 1 ] = 0 ;					      	  der [ 1 ] = 0						    	der [ 1 ] = 0						  
  der [ 2 ] = 1 ;					      	  der [ 2 ] = 1						    	der [ 2 ] = 1						  
  for ( int i = 3 ;					      	  for i in range ( 3 , n + 1 ) :			    	for i in range ( 3 , n + 1 ) :				  
  i <= n ;						      	      der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 	    der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 
  ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i -  	  return der [ n ]					    	return der [ n ]					  
  return der [ n ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_STRINGS_WITH_CONSECUTIVE_1S			      COUNT_STRINGS_WITH_CONSECUTIVE_1S				    COUNT_STRINGS_WITH_CONSECUTIVE_1S				  COUNT_STRINGS_WITH_CONSECUTIVE_1S
--							      --							    --								  --
static int countStrings ( int n ) {			      def countStrings ( n ) :					    def count_strings ( n ) :					  success : None
  int a [ ] = new int [ n ] , b [ ] = new int [ n ] ;	      	  a = [ 0 ] * n						    	a , b = [ 0 ] * n , [ 0 ] * n				  
  a [ 0 ] = b [ 0 ] = 1 ;				      	  b = [ 0 ] * n						    	a [ 0 ] , b [ 0 ] = 1 , 1				  
  for ( int i = 1 ;					      	  a [ 0 ] = b [ 0 ] = 1					    	for i in range ( 1 , n ) :				  
  i < n ;						      	  for i in range ( 1 , n ) :				    	    a [ i ] = a [ i - 1 ] + b [ i - 1 ]			  
  i ++ ) {						      	      a [ i ] = a [ i - 1 ] + b [ i - 1 ]		    	    b [ i ] = a [ i - 1 ]				  
    a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;		      	      b [ i ] = a [ i - 1 ]				    	from math import pow					  
    b [ i ] = a [ i - 1 ] ;				      	  return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]		    	return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]		  
  }							      								    								  
  from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ;  								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAYS_DISTINCT_ELEMENTS				      SUBARRAYS_DISTINCT_ELEMENTS				    SUBARRAYS_DISTINCT_ELEMENTS					  SUBARRAYS_DISTINCT_ELEMENTS
--							      --							    --								  --
public static int sumoflength ( int [ ] arr , int n ) {	      def sumoflength ( arr , n ) :				    def sumoflength ( arr , n ) :				  error : Traceback (most recent call last):   File
  Set < Integer > s = new HashSet < > ( ) ;		      	  s = [ ]						    	s = set ( )						  "dump/transcoder_st/eval/java_python/online_st/206
  int j = 0 , ans = 0 ;					      	  j = 0							    	j , ans = 0 , 0						  68770/eval_scripts/java_sa-python_sa.test/SUBARRAY
  for ( int i = 0 ;					      	  ans = 0						    	for i in range ( n ) :					  S_DISTINCT_ELEMENTS.py", line 57, in <module>
  i < n ;						      	  for i in range ( n ) :				    	    while j < n and arr [ j ] not in s :		  if f_filled(*parameters_set) == f_gold(*parameters
  i ++ ) {						      	      while ( j < n and ( arr [ j ] not in s ) ) :	    		s.add ( arr [ i ] )				  _set):   File "dump/transcoder_st/eval/java_python
    while ( j < n && ! s . contains ( arr [ j ] ) ) {	      		  s.append ( arr [ j ] )			    		j += 1						  /online_st/20668770/eval_scripts/java_sa-python_sa
      s . add ( arr [ i ] ) ;				      		  j += 1					    	    ans += ( ( j - i ) * ( j - i + 1 ) ) / 2		  .test/SUBARRAYS_DISTINCT_ELEMENTS.py", line 38, in
      j ++ ;						      	      ans += ( ( j - i ) * ( j - i + 1 ) ) // 2		    	    s.remove ( arr [ i ] )				   f_filled	s.remove ( arr [ i ] ) KeyError: 4
    }							      	      s.remove ( arr [ i ] )				    	return ans						  
    ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;		      	  return ans						    								  
    s . remove ( arr [ i ] ) ;				      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL
--							      --							    --								  --
public static int nobleInteger ( int arr [ ] ) {	      def nobleInteger ( arr ) :				    def noble_integer ( arr ) :					  script_not_found : None
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  int n = arr . length ;				      	  n = len ( arr )					    	n = len ( arr )						  
  for ( int i = 0 ;					      	  for i in range ( n - 1 ) :				    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      if arr [ i ] == arr [ i + 1 ] :			    	    if arr [ i ] == arr [ i + 1 ] :			  
  i ++ ) {						      		  continue					    		continue					  
    if ( arr [ i ] == arr [ i + 1 ] ) continue ;	      	      if arr [ i ] == n - i - 1 :			    	    if arr [ i ] == n - i - 1 :				  
    if ( arr [ i ] == n - i - 1 ) return arr [ i ] ;	      		  return arr [ i ]				    		return arr [ i ]				  
  }							      	  if arr [ n - 1 ] == 0 :				    	if not arr [ n - 1 ] :					  
  if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ;	      	      return arr [ n - 1 ]				    	    return arr [ n - 1 ]				  
  return - 1 ;						      	  return - 1						    	return - 1						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S	      COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S	    COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S		  COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S
--							      --							    --								  --
static int countStrings ( int n ) {			      def countStrings ( n ) :					    def count_strings ( n ) :					  success : None
  int a [ ] = new int [ n ] ;				      	  a = [ 0 for i in range ( n ) ]			    	a = [ 0 ] * n						  
  int b [ ] = new int [ n ] ;				      	  b = [ 0 for i in range ( n ) ]			    	b = [ 0 ] * n						  
  a [ 0 ] = b [ 0 ] = 1 ;				      	  a [ 0 ] = b [ 0 ] = 1					    	a [ 0 ] = b [ 0 ] = 1					  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i < n ;						      	      a [ i ] = a [ i - 1 ] + b [ i - 1 ]		    	    a [ i ] = a [ i - 1 ] + b [ i - 1 ]			  
  i ++ ) {						      	      b [ i ] = a [ i - 1 ]				    	    b [ i ] = a [ i - 1 ]				  
    a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;		      	  return a [ n - 1 ] + b [ n - 1 ]			    	return a [ n - 1 ] + b [ n - 1 ]			  
    b [ i ] = a [ i - 1 ] ;				      								    								  
  }							      								    								  
  return a [ n - 1 ] + b [ n - 1 ] ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE	      DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE	    DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE
--							      --							    --								  --
int lcs ( char [ ] X , char [ ] Y , int m , int n ) {	      def lcs ( X , Y , m , n ) :				    def lcs ( X , Y , m , n ) :					  script_not_found : None
  if ( m == 0 || n == 0 ) return 0 ;			      	  if m == 0 or n == 0 :					    	if m == 0 or n == 0 :					  
  if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y ,  	      return 0 ;					    	    return 0						  
  else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , 	  elif X [ m - 1 ] == Y [ n - 1 ] :			    	if X [ m - 1 ] == Y [ n - 1 ] :				  
}							      	      return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;	    	    return 1 + lcs ( X , Y , m - 1 , n - 1 )		  
							      	  else :						    	else :							  
							      	      return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y  	    return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROBABILITY_REACHING_POINT_2_3_STEPS_TIME		      PROBABILITY_REACHING_POINT_2_3_STEPS_TIME			    PROBABILITY_REACHING_POINT_2_3_STEPS_TIME			  PROBABILITY_REACHING_POINT_2_3_STEPS_TIME
--							      --							    --								  --
static float find_prob ( int N , float P ) {		      def find_prob ( N , P ) :					    def find_prob ( N , P ) :					  script_not_found : None
  double dp [ ] = new double [ N + 1 ] ;		      	  dp = [ 0 ] * ( n + 1 )				    	dp = np.zeros ( N + 1 )					  
  dp [ 0 ] = 1 ;					      	  dp [ 0 ] = 1						    	dp [ 0 ] = 1						  
  dp [ 1 ] = 0 ;					      	  dp [ 1 ] = 0						    	dp [ 1 ] = 0						  
  dp [ 2 ] = P ;					      	  dp [ 2 ] = P						    	dp [ 2 ] = P						  
  dp [ 3 ] = 1 - P ;					      	  dp [ 3 ] = 1 - P					    	dp [ 3 ] = 1 - P					  
  for ( int i = 4 ;					      	  for i in range ( 4 , N + 1 ) :			    	for i in range ( 4 , N + 1 ) :				  
  i <= N ;						      	      dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i  	    dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i  
  ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i 	  return dp [ N ]					    	return ( float ( dp [ N ] ) )				  
  return ( ( float ) ( dp [ N ] ) ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE
--							      --							    --								  --
static int find ( int a [ ] , int b [ ] , int k , int n1 , in def find ( a , b , k , n1 , n2 ) :			    def find ( a , b , k , n1 , n2 ) :				  success : None
  LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ;   	  s = set ( )						    	s = [ ]							  
  for ( int i = 0 ;					      	  for i in range ( n2 ) :				    	for i in range ( n2 ) :					  
  i < n2 ;						      	      s.add ( b [ i ] )					    	    s.append ( b [ i ] )				  
  i ++ ) s . add ( b [ i ] ) ;				      	  missing = 0						    	missing = 0						  
  int missing = 0 ;					      	  for i in range ( n1 ) :				    	for i in range ( n1 ) :					  
  for ( int i = 0 ;					      	      if a [ i ] not in s :				    	    if a [ i ] not in s :				  
  i < n1 ;						      		  missing += 1					    		missing += 1					  
  i ++ ) {						      	      if missing == k :					    	    if missing == k :					  
    if ( ! s . contains ( a [ i ] ) ) missing ++ ;	      		  return a [ i ]				    		return a [ i ]					  
    if ( missing == k ) return a [ i ] ;		      	  return - 1						    	return - 1						  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG
--							      --							    --								  --
static void generate ( Set < String > st , String s ) {	      def generate ( st , s ) :					    def generate ( st , s ) :					  script_not_found : None
  if ( s . length ( ) == 0 ) {				      	  if len ( s ) == 0 :					    	if len ( s ) == 0 :					  
    return ;						      	      return						    	    return						  
  }							      	  if s not in st :					    	if s not in st :					  
  if ( ! st . contains ( s ) ) {			      	      st.add ( s )					    	    st.add ( s )					  
    st . add ( s ) ;					      	      for i in range ( len ( s ) ) :			    	    for i in range ( len ( s ) ) :			  
    for ( int i = 0 ;					      		  t = list ( s ).copy ( )			    		t = s [ : i ] + t [ i + 1 : ]			  
    i < s . length ( ) ;				      		  t.remove ( s [ i ] )				    		generate ( st , t )				  
    i ++ ) {						      		  t = ''.join ( t )				    	return							  
      String t = s ;					      		  generate ( st , t )				    								  
      t = t . substring ( 0 , i ) + t . substring ( i + 1 ) ; 	  return						    								  
      generate ( st , t ) ;				      								    								  
    }							      								    								  
  }							      								    								  
  return ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI
--							      --							    --								  --
boolean canRepresentBST ( int pre [ ] , int n ) {	      def canRepresentBST ( pre ) :				    def can_representBST ( pre , n ) :				  script_not_found : None
  Stack < Integer > s = new Stack < Integer > ( ) ;	      	  s = [ ]						    	s = [ ]							  
  int root = Integer . MIN_VALUE ;			      	  root = INT_MIN					    	root = None						  
  for ( int i = 0 ;					      	  for value in pre :					    	for i in range ( n ) :					  
  i < n ;						      	      if value < root :					    	    if pre [ i ] < root :				  
  i ++ ) {						      		  return False					    		return False					  
    if ( pre [ i ] < root ) {				      	      while ( len ( s ) > 0 and s [ - 1 ] < value ) :	    	    while not s and s [ - 1 ] < pre [ i ] :		  
      return false ;					      		  root = s.pop ( )				    		root = s [ - 1 ]				  
    }							      	      s.append ( value )				    		s.pop ( )					  
    while ( ! s . empty ( ) && s . peek ( ) < pre [ i ] ) {   	  return True						    	    s.append ( pre [ i ] )				  
      root = s . peek ( ) ;				      								    	return True						  
      s . pop ( ) ;					      								    								  
    }							      								    								  
    s . push ( pre [ i ] ) ;				      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_NEXT_STRING				      LEXICOGRAPHICALLY_NEXT_STRING				    LEXICOGRAPHICALLY_NEXT_STRING				  LEXICOGRAPHICALLY_NEXT_STRING
--							      --							    --								  --
public static String nextWord ( String str ) {		      def nextWord ( s ) :					    def next_word ( str ) :					  failure : #Results: 5, 10
  if ( str == "" ) return "a" ;				      	  if ( s == " " ) :					    	if not str :						  
  int i = str . length ( ) - 1 ;			      	      return "a"					    	    return 'a'						  
  while ( str . charAt ( i ) == 'z' && i >= 0 ) i -- ;	      	  i = len ( s ) - 1					    	i = len ( str ) - 1					  
  if ( i == - 1 ) str = str + 'a' ;			      	  while ( s [ i ] == 'z' and i >= 0 ) :			    	while str [ i ] == 'z' and i >= 0 :			  
  else str = str . substring ( 0 , i ) + ( char ) ( ( int ) ( 	      i -= 1						    	    i -= 1						  
  return str ;						      	  if ( i == - 1 ) :					    	if i == - 1 :						  
}							      	      s = s + 'a'					    	    str = str + 'a'					  
							      	  else :						    	else :							  
							      	      s = s.replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) 	    str = str [ : i ] + chr ( ord ( str [ i ] ) + 1 ) + s 
							      	  return s						    	return str						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CAESAR_CIPHER						      CAESAR_CIPHER						    CAESAR_CIPHER						  CAESAR_CIPHER
--							      --							    --								  --
public static StringBuffer encrypt ( String text , int s ) {  def encrypt ( text , s ) :				    def encrypt ( text , s ) :					  success : None
  StringBuffer result = new StringBuffer ( ) ;		      	  result = ""						    	result = ''						  
  for ( int i = 0 ;					      	  for i in range ( len ( text ) ) :			    	for c in text :						  
  i < text . length ( ) ;				      	      char = text [ i ]					    	    if c.isupper ( ) :					  
  i ++ ) {						      	      if ( char.isupper ( ) ) :				    		ch = chr ( ( ord ( c ) + s - 65 ) % 26 + 65 )	  
    if ( Character . isUpperCase ( text . charAt ( i ) ) ) {  		  result += chr ( ( ord ( char ) + s - 65 ) % 26 +  		result += ch					  
      char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s  	      else :						    	    else :						  
      result . append ( ch ) ;				      		  result += chr ( ( ord ( char ) + s - 97 ) % 26 +  		ch = chr ( ( ord ( c ) + s - 97 ) % 26 + 97 )	  
    }							      	  return result						    		result += ch					  
    else {						      								    	return result						  
      char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s  								    								  
      result . append ( ch ) ;				      								    								  
    }							      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE			      FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE			    FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE				  FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE
--							      --							    --								  --
static String Dragon_Curve_Sequence ( int n ) {		      def Dragon_Curve_Sequence ( n ) :				    def Dragon_Curve_Sequence ( n ) :				  script_not_found : None
  String s = "1" ;					      	  s = "1"						    	s = '1'							  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	      temp = "1"					    	    temp = '1'						  
  i ++ ) {						      	      prev = '1'					    	    prev , zero , one = '1' , '0' , '1'			  
    String temp = "1" ;					      	      zero = '0'					    	    for c in s :					  
    char prev = '1' , zero = '0' , one = '1' ;		      	      one = '1'						    		temp += c					  
    for ( int j = 0 ;					      	      for j in range ( len ( s ) ) :			    		if prev == '0' :				  
    j < s . length ( ) ;				      		  temp += s [ j ]				    		    temp += one					  
    j ++ ) {						      		  if ( prev == '0' ) :				    		    prev = one					  
      temp += s . charAt ( j ) ;			      		      temp += one				    		else :						  
      if ( prev == '0' ) {				      		      prev = one				    		    temp += zero				  
	temp += one ;					      		  else :					    		    prev = zero					  
	prev = one ;					      		      temp += zero				    	    s = temp						  
      }							      		      prev = zero				    	return s						  
      else {						      	      s = temp						    								  
	temp += zero ;					      	  return s						    								  
	prev = zero ;					      								    								  
      }							      								    								  
    }							      								    								  
    s = temp ;						      								    								  
  }							      								    								  
  return s ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1		      PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1		    PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1		  PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1
--							      --							    --								  --
static boolean isScalarMatrix ( int mat [ ] [ ] ) {	      def isScalarMatrix ( mat ) :				    def is_scalar_matrix ( mat ) :				  script_not_found : None
  for ( int i = 0 ;					      	  for i in range ( 0 , N ) :				    	for i in range ( N ) :					  
  i < N ;						      	      for j in range ( 0 , N ) :			    	    for j in range ( N ) :				  
  i ++ ) for ( int j = 0 ;				      		  if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) :  		if ( i != j ) and ( mat [ i ] [ j ] != 0 ) :	  
  j < N ;						      		      return False				    		    return False				  
  j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return 	  for i in range ( 0 , N - 1 ) :			    	    for i in range ( N - 1 ) :				  
  for ( int i = 0 ;					      	      if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) :   		if mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] :	  
  i < N - 1 ;						      		  return False					    		    return False				  
  i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) re 	  return True						    	return True						  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_TRIANGLES_POSSIBLE			      FIND_NUMBER_OF_TRIANGLES_POSSIBLE				    FIND_NUMBER_OF_TRIANGLES_POSSIBLE				  FIND_NUMBER_OF_TRIANGLES_POSSIBLE
--							      --							    --								  --
static int findNumberOfTriangles ( int arr [ ] ) {	      def findnumberofTriangles ( arr ) :			    def find_number_of_triangles ( arr ) :			  script_not_found : None
  int n = arr . length ;				      	  n = len ( arr )					    	n = len ( arr )						  
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  int count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n - 2 ) :			    	for i in range ( n - 2 ) :				  
  i < n - 2 ;						      	      k = i + 2						    	    k = i + 2						  
  ++ i ) {						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
    int k = i + 2 ;					      		  while ( k < n and arr [ i ] + arr [ j ] > arr [ k 		while k < n and arr [ i ] + arr [ j ] > arr [ k ] 
    for ( int j = i + 1 ;				      		      k += 1					    		    k += 1					  
    j < n ;						      		  if ( k > j ) :				    		if k > j :					  
    ++ j ) {						      		      count += k - j - 1			    		    count += k - j - 1				  
      while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ 	  return count						    	return count						  
      if ( k > j ) count += k - j - 1 ;			      								    								  
    }							      								    								  
  }							      								    								  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS		      NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS		    NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS		  NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS
--							      --							    --								  --
static int snoob ( int x ) {				      def snoob ( x ) :						    def snoob ( x ) :						  success : None
  int rightOne , nextHigherOneBit , rightOnesPattern , next = 	  next = 0						    	global next_higher_one_bit , right_ones_pattern , next	  
  if ( x > 0 ) {					      	  if ( x ) :						    	if x > 0 :						  
    rightOne = x & - x ;				      	      rightOne = x & - ( x )				    	    right_one = x & - x					  
    nextHigherOneBit = x + rightOne ;			      	      nextHigherOneBit = x + int ( rightOne )		    	    next_higher_one_bit = x + right_one			  
    rightOnesPattern = x ^ nextHigherOneBit ;		      	      rightOnesPattern = x ^ int ( nextHigherOneBit )	    	    right_ones_pattern = x ^ next_higher_one_bit	  
    rightOnesPattern = ( rightOnesPattern ) / rightOne ;      	      rightOnesPattern = ( int ( rightOnesPattern ) / int ( 	    right_ones_pattern = ( right_ones_pattern ) // right_ 
    rightOnesPattern >>= 2 ;				      	      rightOnesPattern = int ( rightOnesPattern ) >> 2	    	    right_ones_pattern >>= 2				  
    next = nextHigherOneBit | rightOnesPattern ;	      	      next = nextHigherOneBit | rightOnesPattern	    	    next = next_higher_one_bit | right_ones_pattern	  
  }							      	  return next						    	return next						  
  return next ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUPER_PRIME						      SUPER_PRIME						    SUPER_PRIME							  SUPER_PRIME
--							      --							    --								  --
static void SieveOfEratosthenes ( int n , boolean isPrime [ ] def SieveOfEratosthenes ( n , isPrime ) :			    def SieveOfEratosthenes ( n , isPrime ) :			  script_not_found : None
  isPrime [ 0 ] = isPrime [ 1 ] = false ;		      	  isPrime [ 0 ] = isPrime [ 1 ] = False			    	isPrime [ 0 ] = isPrime [ 1 ] = False			  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	      isPrime [ i ] = True				    	    isPrime [ i ] = True				  
  i ++ ) isPrime [ i ] = true ;				      	  for p in range ( 2 , n + 1 ) :			    	for p in range ( 2 , p * n + 1 ) :			  
  for ( int p = 2 ;					      	      if ( p * p <= n and isPrime [ p ] == True ) :	    	    if isPrime [ p ] == True :				  
  p * p <= n ;						      		  for i in range ( p * 2 , n + 1 , p ) :	    		for i in range ( p * 2 , n + 1 , p ) :		  
  p ++ ) {						      		      isPrime [ i ] = False			    		    isPrime [ i ] = False			  
    if ( isPrime [ p ] == true ) {			      		      p += 1					    								  
      for ( int i = p * 2 ;				      								    								  
      i <= n ;						      								    								  
      i += p ) isPrime [ i ] = false ;			      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1	      SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1	    SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1		  SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1
--							      --							    --								  --
static int KnapSack ( int val [ ] , int wt [ ] , int n , int  def KnapSack ( val , wt , n , W ) :			    def KnapSack ( val , wt , n , W ) :				  script_not_found : None
  int [ ] dp = new int [ W + 1 ] ;			      	  dp = [ 0 ] * ( W + 1 )				    	dp = [ 0 ] * ( W + 1 )					  
  Arrays . fill ( dp , 0 ) ;				      	  for i in range ( n ) :				    	dp [ 0 ] = 0						  
  for ( int i = 0 ;					      	      for j in range ( W , wt [ i ] , - 1 ) :		    	for i in range ( n ) :					  
  i < n ;						      		  dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j -  	    for j in range ( W , wt [ i ] - 1 , - 1 ) :		  
  i ++ ) for ( int j = W ;				      	  return dp [ W ]					    		dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j -  
  j >= wt [ i ] ;					      								    	return dp [ W ]						  
  j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [  								    								  
  return dp [ W ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS		      POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS		    POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS		  POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS
--							      --							    --								  --
static void rearrange ( int a [ ] , int size ) {	      def rearrange ( a , size ) :				    def rearrange ( a , size ) :				  success : None
  int positive = 0 , negative = 1 , temp ;		      	  positive = 0						    	positive , negative , temp = 0 , 1 , 1			  
  while ( true ) {					      	  negative = 1						    	while True :						  
    while ( positive < size && a [ positive ] >= 0 ) positive 	  while ( True ) :					    	    while positive < size and a [ positive ] >= 0 :	  
    while ( negative < size && a [ negative ] <= 0 ) negative 	      while ( positive < size and a [ positive ] >= 0 ) :   		positive += 2					  
    if ( positive < size && negative < size ) {		      		  positive = positive + 2			    	    while negative < size and a [ negative ] <= 0 :	  
      temp = a [ positive ] ;				      	      while ( negative < size and a [ negative ] <= 0 ) :   		negative += 2					  
      a [ positive ] = a [ negative ] ;			      		  negative = negative + 2			    	    if positive < size and negative < size :		  
      a [ negative ] = temp ;				      	      if ( positive < size and negative < size ) :	    		temp = a [ positive ]				  
    }							      		  temp = a [ positive ]				    		a [ positive ] = a [ negative ]			  
    else break ;					      		  a [ positive ] = a [ negative ]		    		a [ negative ] = temp				  
  }							      		  a [ negative ] = temp				    	    else :						  
}							      	      else :						    		break						  
							      		  break						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY		      FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY		    FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY			  FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY
--							      --							    --								  --
static int maxProduct ( int [ ] arr , int n ) {		      def maxProduct ( arr , n ) :				    def max_product ( arr , n ) :				  error : Traceback (most recent call last):   File
  if ( n < 3 ) return - 1 ;				      	  if n < 3 :						    	if n < 3 :						  "dump/transcoder_st/eval/java_python/online_st/206
  int max_product = Integer . MIN_VALUE ;		      	      return - 1					    	    return - 1						  68770/eval_scripts/java_sa-python_sa.test/FIND_MAX
  for ( int i = 0 ;					      	  max_product = - ( sys.maxsize - 1 )			    	max_product = sys.maxint				  IMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY.py", line 56, i
  i < n - 2 ;						      	  for i in range ( 0 , n - 2 ) :			    	for i in range ( n - 2 ) :				  n <module>	 if f_filled(*parameters_set) == f_g
  i ++ ) for ( int j = i + 1 ;				      	      for j in range ( i + 1 , n - 1 ) :		    	    for j in range ( i + 1 , n - 1 ) :			  old(*parameters_set):	  File "dump/transcoder_st/e
  j < n - 1 ;						      		  for k in range ( j + 1 , n ) :		    		for k in range ( j + 1 , n ) :			  val/java_python/online_st/20668770/eval_scripts/ja
  j ++ ) for ( int k = j + 1 ;				      		      max_product = max ( max_product , arr [ i ] * 		    max_product = max ( max_product , arr [ i ] * va_sa-python_sa.test/FIND_MAXIMUM_PRODUCT_OF_A_TRI
  k < n ;						      	  return max_product					    	return max_product					  PLET_IN_ARRAY.py", line 33, in f_filled     f_fill
  k ++ ) max_product = Math . max ( max_product , arr [ i ] * 								    								  ed = sys.maxint AttributeError: module 'sys' has n
  return max_product ;					      								    								  o attribute 'maxint'
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1		      REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1		    REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1		  REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1
--							      --							    --								  --
static void reorder ( ) {				      def reorder ( arr , index , n ) :				    def reorder ( ) :						  script_not_found : None
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( len ( arr ) ) :			  
  i < arr . length ;					      	      while ( index [ i ] != i ) :			    	    while index [ i ] != i :				  
  i ++ ) {						      		  oldTargetI = index [ index [ i ] ]		    		old_target_i = index [ index [ i ] ]		  
    while ( index [ i ] != i ) {			      		  oldTargetE = arr [ index [ i ] ]		    		old_target_e = chr ( arr [ index [ i ] ] )	  
      int oldTargetI = index [ index [ i ] ] ;		      		  arr [ index [ i ] ] = arr [ i ]		    		arr [ index [ i ] ] = arr [ i ]			  
      char oldTargetE = ( char ) arr [ index [ i ] ] ;	      		  index [ index [ i ] ] = index [ i ]		    		index [ index [ i ] ] = index [ i ]		  
      arr [ index [ i ] ] = arr [ i ] ;			      		  index [ i ] = oldTargetI			    		index [ i ] = old_target_i			  
      index [ index [ i ] ] = index [ i ] ;		      		  arr [ i ] = oldTargetE			    		arr [ i ] = old_target_e			  
      index [ i ] = oldTargetI ;			      								    								  
      arr [ i ] = oldTargetE ;				      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1		      MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1		    MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1		  MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1
--							      --							    --								  --
static int maxDiff ( int [ ] arr , int n ) {		      def maxDiff ( arr , n ) :					    def max_diff ( arr , n ) :					  script_not_found : None
  int result = 0 ;					      	  result = 0						    	result = 0						  
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  for ( int i = 0 ;					      	  for i in range ( n - 1 ) :				    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) :   	    if arr [ i ] != arr [ i + 1 ] :			  
  i ++ ) {						      		  result += abs ( arr [ i ] )			    		result += abs ( arr [ i ] )			  
    if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs (  	      else :						    	    else :						  
    else i ++ ;						      		  pass						    		i += 1						  
  }							      	  if ( arr [ n - 2 ] != arr [ n - 1 ] ) :		    	if arr [ n - 2 ] != arr [ n - 1 ] :			  
  if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs  	      result += abs ( arr [ n - 1 ] )			    	    result += abs ( arr [ n - 1 ] )			  
  return result ;					      	  return result						    	return result						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS			      LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS			    LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS				  LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS
--							      --							    --								  --
static int longestCommonSum ( int n ) {			      def longestCommonSum ( arr1 , arr2 , n ) :		    def longest_common_sum ( n ) :				  script_not_found : None
  int maxLen = 0 ;					      	  maxLen = 0						    	max_len = 0						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      sum1 = 0						    	    sum1 , sum2 = 0 , 0					  
  i ++ ) {						      	      sum2 = 0						    	    for j in range ( i , n ) :				  
    int sum1 = 0 , sum2 = 0 ;				      	      for j in range ( i , n ) :			    		sum1 += arr1 [ j ]				  
    for ( int j = i ;					      		  sum1 += arr1 [ j ]				    		sum2 += arr2 [ j ]				  
    j < n ;						      		  sum2 += arr2 [ j ]				    		if sum1 == sum2 :				  
    j ++ ) {						      		  if ( sum1 == sum2 ) :				    		    len_ = j - i + 1				  
      sum1 += arr1 [ j ] ;				      		      len = j - i + 1				    		    if len_ > max_len :				  
      sum2 += arr2 [ j ] ;				      		      if ( len > maxLen ) :			    			max_len = len_				  
      if ( sum1 == sum2 ) {				      			  maxLen = len				    	return max_len						  
	int len = j - i + 1 ;				      	  return maxLen						    								  
	if ( len > maxLen ) maxLen = len ;		      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return maxLen ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE		      DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE		    DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE		  DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE
--							      --							    --								  --
static int eggDrop ( int n , int k ) {			      def eggDrop ( n , k ) :					    def eggDrop ( n , k ) :					  script_not_found : None
  if ( k == 1 || k == 0 ) return k ;			      	  if ( k == 1 or k == 0 ) :				    	if k == 1 or k == 0 :					  
  if ( n == 1 ) return k ;				      	      return k						    	    return k						  
  int min = Integer . MAX_VALUE ;			      	  if ( n == 1 ) :					    	if n == 1 :						  
  int x , res ;						      	      return k						    	    return k						  
  for ( x = 1 ;						      	  min = sys.maxsize					    	min = sys.maxsize					  
  x <= k ;						      	  for x in range ( 1 , k + 1 ) :			    	x , res = 0 , 0						  
  x ++ ) {						      	      res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , 	for x in range ( 1 , k + 1 ) :				  
    res = Math . max ( eggDrop ( n - 1 , x - 1 ) , eggDrop (  	      if ( res < min ) :				    	    res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , 
    if ( res < min ) min = res ;			      		  min = res					    	    if res < min :					  
  }							      	  return min + 1					    		min = res					  
  return min + 1 ;					      								    	return min + 1						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1			      LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1			    LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1			  LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1
--							      --							    --								  --
static int maxLength ( String s , int n ) {		      def maxLength ( s , n ) :					    def max_length ( s , n ) :					  script_not_found : None
  int invalidOpenBraces = 0 ;				      	  invalidOpenBraces = 0					    	invalid_open_braces = 0					  
  int invalidCloseBraces = 0 ;				      	  invalidCloseBraces = 0				    	invalid_close_braces = 0				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( s [ i ] == '(' ) :				    	    if s [ i ] == '(' :					  
  i ++ ) {						      		  invalidOpenBraces += 1			    		invalid_open_braces += 1			  
    if ( s . charAt ( i ) == '(' ) {			      	      else :						    	    else :						  
      invalidOpenBraces ++ ;				      		  if ( invalidOpenBraces == 0 ) :		    		if invalid_open_braces == 0 :			  
    }							      		      invalidCloseBraces += 1			    		    invalid_close_braces += 1			  
    else {						      		  else :					    		else :						  
      if ( invalidOpenBraces == 0 ) {			      		      invalidOpenBraces -= 1			    		    invalid_open_braces -= 1			  
	invalidCloseBraces ++ ;				      	  return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) 	return ( n - ( invalid_open_braces + invalid_close_braces 
      }							      								    								  
      else {						      								    								  
	invalidOpenBraces -- ;				      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1		      COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1		    COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1			  COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1
--							      --							    --								  --
static int countPairs ( int arr [ ] , int n ) {		      def countPairs ( arr , n ) :				    def count_pairs ( arr , n ) :				  success : None
  int result = 0 ;					      	  result = 0						    	result = 0						  
  HashSet < Integer > Hash = new HashSet < > ( ) ;	      	  Hash = set ( )					    	Hash = set ( )						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      Hash.add ( arr [ i ] )				    	    Hash.add ( arr [ i ] )				  
  i ++ ) {						      	  for i in range ( n ) :				    	for i in range ( n ) :					  
    Hash . add ( arr [ i ] ) ;				      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  }							      		  product = arr [ i ] * arr [ j ]		    		product = arr [ i ] * arr [ j ]			  
  for ( int i = 0 ;					      		  if product in ( Hash ) :			    		if product in Hash :				  
  i < n ;						      		      result += 1				    		    result += 1					  
  i ++ ) {						      	  return result						    	return result						  
    for ( int j = i + 1 ;				      								    								  
    j < n ;						      								    								  
    j ++ ) {						      								    								  
      int product = arr [ i ] * arr [ j ] ;		      								    								  
      if ( Hash . contains ( product ) ) {		      								    								  
	result ++ ;					      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM		      SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM		    SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM			  SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM
--							      --							    --								  --
void computeLPSArray ( String pat , int M , int lps [ ] ) {   def computeLPSArray ( pat , M , lps ) :			    def compute_lps_array ( pat , M , lps ) :			  script_not_found : None
  int len = 0 ;						      	  len = 0						    	data = 0						  
  int i = 1 ;						      	  lps [ 0 ]						    	i = 1							  
  lps [ 0 ] = 0 ;					      	  i = 1							    	lps [ 0 ] = 0						  
  while ( i < M ) {					      	  while i < M :						    	while i < M :						  
    if ( pat . charAt ( i ) == pat . charAt ( len ) ) {	      	      if pat [ i ] == pat [ len ] :			    	    if pat [ i ] == pat [ len ( pat ) ] :		  
      len ++ ;						      		  len += 1					    		data += 1					  
      lps [ i ] = len ;					      		  lps [ i ] = len				    		lps [ i ] = len ( pat )				  
      i ++ ;						      		  i += 1					    		i += 1						  
    }							      	      else :						    	    else :						  
    else {						      		  if len != 0 :					    		if data != 0 :					  
      if ( len != 0 ) {					      		      len = lps [ len - 1 ]			    		    data = lps [ - 1 ]				  
	len = lps [ len - 1 ] ;				      		  else :					    		else :						  
      }							      		      lps [ i ] = 0				    		    lps [ i ] = len ( pat )			  
      else {						      		      i += 1					    		    i += 1					  
	lps [ i ] = len ;				      								    								  
	i ++ ;						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1			      MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1			    MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1			  MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1
--							      --							    --								  --
public static int calculateEnergy ( int mat [ ] [ ] , int n ) def calculateEnergy ( mat , n ) :				    def calculate_energy ( mat , n ) :				  error : Traceback (most recent call last):   File
  int i_des , j_des , q ;				      	  tot_energy = 0					    	i_des , j_des , q = 0 , 0 , 0 , 0			  "dump/transcoder_st/eval/java_python/online_st/206
  int tot_energy = 0 ;					      	  for i in range ( n ) :				    	tot_energy = 0						  68770/eval_scripts/java_sa-python_sa.test/MINIMUM_
  for ( int i = 0 ;					      	      for j in range ( n ) :				    	for i in range ( n ) :					  COST_SORT_MATRIX_NUMBERS_0_N2_1.py", line 55, in <
  i < n ;						      		  q = mat [ i ] [ j ] // n			    	    for j in range ( n ) :				  module>     if f_filled(*parameters_set) == f_gold
  i ++ ) {						      		  i_des = q					    		q = mat [ i ] [ j ] // n			  (*parameters_set):   File "dump/transcoder_st/eval
    for ( int j = 0 ;					      		  j_des = mat [ i ] [ j ] - ( n * q )		    		i_des = q					  /java_python/online_st/20668770/eval_scripts/java_
    j < n ;						      		  tot_energy += ( abs ( i_des - i ) + abs ( j_des - 		j_des = mat [ i ] [ j ] - ( n * q )		  sa-python_sa.test/MINIMUM_COST_SORT_MATRIX_NUMBERS
    j ++ ) {						      	  return tot_energy					    		tot_energy += abs ( i_des - i ) + abs ( j_des - j _0_N2_1.py", line 29, in f_filled	i_des , j_de
      q = mat [ i ] [ j ] / n ;				      								    	return tot_energy					  s , q = 0 , 0 , 0 , 0 ValueError: too many values
      i_des = q ;					      								    								  to unpack (expected 3)
      j_des = mat [ i ] [ j ] - ( n * q ) ;		      								    								  
      tot_energy += Math . abs ( i_des - i ) + Math . abs ( j 								    								  
    }							      								    								  
  }							      								    								  
  return tot_energy ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FLOOR_IN_A_SORTED_ARRAY					      FLOOR_IN_A_SORTED_ARRAY					    FLOOR_IN_A_SORTED_ARRAY					  FLOOR_IN_A_SORTED_ARRAY
--							      --							    --								  --
static int floorSearch ( int arr [ ] , int n , int x ) {      def floorSearch ( arr , low , high , x ) :		    def floor_search ( arr , n , x ) :				  script_not_found : None
  if ( x >= arr [ n - 1 ] ) return n - 1 ;		      	  if ( low > high ) :					    	if x >= arr [ n - 1 ] :					  
  if ( x < arr [ 0 ] ) return - 1 ;			      	      return - 1					    	    return n - 1					  
  for ( int i = 1 ;					      	  if ( x >= arr [ high ] ) :				    	if x < arr [ 0 ] :					  
  i < n ;						      	      return high					    	    return - 1						  
  i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ;	      	  mid = int ( ( low + high ) / 2 )			    	for i in range ( 1 , n ) :				  
  return - 1 ;						      	  if ( arr [ mid ] == x ) :				    	    if arr [ i ] > x :					  
}							      	      return mid					    		return ( i - 1 )				  
							      	  if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] 	return - 1						  
							      	      return mid - 1					    								  
							      	  if ( x < arr [ mid ] ) :				    								  
							      	      return floorSearch ( arr , low , mid - 1 , x )	    								  
							      	  return floorSearch ( arr , mid + 1 , high , x )	    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY		      MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY		    MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY			  MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY
--							      --							    --								  --
public static int minOperation ( int arr [ ] , int n ) {      def minOperation ( arr , n ) :				    def min_operation ( arr , n ) :				  script_not_found : None
  HashMap < Integer , Integer > hash = new HashMap < Integer  	  Hash = defaultdict ( lambda : 0 )			    	hash = { }						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      Hash [ arr [ i ] ] += 1				    	    if arr [ i ] in hash :				  
  i ++ ) if ( hash . containsKey ( arr [ i ] ) ) hash . put ( 	  max_count = 0						    		hash [ arr [ i ] ] = hash [ arr [ i ] ] + 1	  
  else hash . put ( arr [ i ] , 1 ) ;			      	  for i in Hash :					    	    else :						  
  int max_count = 0 ;					      	      if max_count < Hash [ i ] :			    		hash [ arr [ i ] ] = 1				  
  Set < Integer > s = hash . keySet ( ) ;		      		  max_count = Hash [ i ]			    	max_count = 0						  
  for ( int i : s ) if ( max_count < hash . get ( i ) ) max_c 	  return n - max_count					    	s = hash.keys ( )					  
  return ( n - max_count ) ;				      								    	for i in s :						  
}							      								    	    if max_count < hash [ i ] :				  
							      								    		max_count = hash [ i ]				  
							      								    	return ( n - max_count )				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1	      MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1		    MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1		  MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1
--							      --							    --								  --
static char maxRepeating ( String str ) {		      def maxRepeating ( str ) :				    def max_repeating ( str ) :					  success : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  int count = 0 ;					      	  count = 0						    	count = 0						  
  char res = str . charAt ( 0 ) ;			      	  res = str [ 0 ]					    	res = str [ 0 ]						  
  int cur_count = 1 ;					      	  cur_count = 1						    	cur_count = 1						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) :	    	    if i < n - 1 and str [ i ] == str [ i + 1 ] :	  
  i ++ ) {						      		  cur_count += 1				    		cur_count += 1					  
    if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i  	      else :						    	    else :						  
    else {						      		  if cur_count > count :			    		if cur_count > count :				  
      if ( cur_count > count ) {			      		      count = cur_count				    		    count = cur_count				  
	count = cur_count ;				      		      res = str [ i ]				    		    res = str [ i ]				  
	res = str . charAt ( i ) ;			      		  cur_count = 1					    		cur_count = 1					  
      }							      	  return res						    	return res						  
      cur_count = 1 ;					      								    								  
    }							      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ARRANGEMENT_QUEUE_GIVEN_TIME			      FIND_ARRANGEMENT_QUEUE_GIVEN_TIME				    FIND_ARRANGEMENT_QUEUE_GIVEN_TIME				  FIND_ARRANGEMENT_QUEUE_GIVEN_TIME
--							      --							    --								  --
static void solve ( int n , int t , char s [ ] ) {	      def solve ( n , t , p ) :					    def solve ( n , t , s ) :					  script_not_found : None
  for ( int i = 0 ;					      	  s = list ( p )					    	for i in range ( t ) :					  
  i < t ;						      	  for i in range ( 0 , t ) :				    	    for j in range ( n - 1 ) :				  
  i ++ ) for ( int j = 0 ;				      	      for j in range ( 0 , n - 1 ) :			    		if s [ j ] == 'B' and s [ j + 1 ] == 'G' :	  
  j < n - 1 ;						      		  if ( s [ j ] == 'B' and s [ j + 1 ] == 'G' ) :    		    temp = s [ j ]				  
  j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) {	      		      temp = s [ j ]				    		    s [ j ] = s [ j + 1 ]			  
    char temp = s [ j ] ;				      		      s [ j ] = s [ j + 1 ]			    		    s [ j + 1 ] = temp				  
    s [ j ] = s [ j + 1 ] ;				      		      s [ j + 1 ] = temp			    		    j += 1					  
    s [ j + 1 ] = temp ;				      		      j = j + 1					    	print ( s , end = '' )					  
    j ++ ;						      	  print ( ''.join ( s ) )				    								  
  }							      								    								  
  System . out . print ( s ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING		      SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING		    SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING		  SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING
--							      --							    --								  --
static int sumAtKthLevel ( String tree , int k ) {	      def sumAtKthLevel ( tree , k ) :				    def sum_at_kth_level ( tree , k ) :				  success : None
  int level = - 1 ;					      	  level = - 1						    	level = - 1						  
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  int n = tree . length ( ) ;				      	  n = len ( tree )					    	n = len ( tree )					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for c in tree :						  
  i < n ;						      	      if ( tree [ i ] == '(' ) :			    	    if c == '(' :					  
  i ++ ) {						      		  level += 1					    		level += 1					  
    if ( tree . charAt ( i ) == '(' ) level ++ ;	      	      elif ( tree [ i ] == ')' ) :			    	    elif c == ')' :					  
    else if ( tree . charAt ( i ) == ')' ) level -- ;	      		  level -= 1					    		level -= 1					  
    else {						      	      else :						    	    else :						  
      if ( level == k ) sum += ( tree . charAt ( i ) - '0' )  		  if ( level == k ) :				    		if level == k :					  
    }							      		      sum += ( ord ( tree [ i ] ) - ord ( '0' ) )   		    sum += ord ( c ) - ord ( '0' )		  
  }							      	  return sum						    	return sum						  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT		      FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT			    FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT			  FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT
--							      --							    --								  --
static boolean findDuplicateparenthesis ( String s ) {	      def findDuplicateparenthesis ( string ) :			    def findDuplicateparenthesis ( s ) :			  success : None
  Stack < Character > Stack = new Stack < > ( ) ;	      	  Stack = [ ]						    	Stack = [ ]						  
  char [ ] str = s . toCharArray ( ) ;			      	  for ch in string :					    	s = list ( s )						  
  for ( char ch : str ) {				      	      if ch == ')' :					    	for ch in s :						  
    if ( ch == ')' ) {					      		  top = Stack.pop ( )				    	    if ch == ')' :					  
      char top = Stack . peek ( ) ;			      		  elementsInside = 0				    		top = Stack [ - 1 ]				  
      Stack . pop ( ) ;					      		  while top != '(' :				    		Stack.pop ( )					  
      int elementsInside = 0 ;				      		      elementsInside += 1			    		elementsInside = 0				  
      while ( top != '(' ) {				      		      top = Stack.pop ( )			    		while top != '(' :				  
	elementsInside ++ ;				      		  if elementsInside < 1 :			    		    elementsInside += 1				  
	top = Stack . peek ( ) ;			      		      return True				    		    top = Stack [ - 1 ]				  
	Stack . pop ( ) ;				      	      else :						    		    Stack.pop ( )				  
      }							      		  Stack.append ( ch )				    		if elementsInside < 1 :				  
      if ( elementsInside < 1 ) {			      	  return False						    		    return True					  
	return true ;					      								    	    else :						  
      }							      								    		Stack.append ( ch )				  
    }							      								    	return False						  
    else {						      								    								  
      Stack . push ( ch ) ;				      								    								  
    }							      								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MIDDLE_ROW_COLUMN_MATRIX				      SUM_MIDDLE_ROW_COLUMN_MATRIX				    SUM_MIDDLE_ROW_COLUMN_MATRIX				  SUM_MIDDLE_ROW_COLUMN_MATRIX
--							      --							    --								  --
static void middlesum ( int mat [ ] [ ] , int n ) {	      def middlesum ( mat , n ) :				    def middlesum ( mat , n ) :					  success : None
  int row_sum = 0 , col_sum = 0 ;			      	  row_sum = 0						    	row_sum , col_sum = 0 , 0				  
  for ( int i = 0 ;					      	  col_sum = 0						    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( n ) :				    	    row_sum += mat [ n // 2 ] [ i ]			  
  i ++ ) row_sum += mat [ n / 2 ] [ i ] ;		      	      row_sum += mat [ n // 2 ] [ i ]			    	print ( "Sum of middle row = %d" % row_sum )		  
  System . out . println ( "Sum of middle row = " + row_sum ) 	  print ( "Sum of middle row = " , row_sum )		    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	    col_sum += mat [ i ] [ n // 2 ]			  
  i < n ;						      	      col_sum += mat [ i ] [ n // 2 ]			    	print ( "Sum of middle column = %d" % col_sum )		  
  i ++ ) col_sum += mat [ i ] [ n / 2 ] ;		      	  print ( "Sum of middle column = " , col_sum )		    								  
  System . out . println ( "Sum of middle column = " + col_su 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES	      COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES		    COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES		  COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES
--							      --							    --								  --
public static int countarray ( int n , int k , int x ) {      def countarray ( n , k , x ) :				    def countarray ( n , k , x ) :				  success : None
  int [ ] dp = new int [ 109 ] ;			      	  dp = list ( )						    	dp = [ 0 ] * 109					  
  dp [ 0 ] = 0 ;					      	  dp.append ( 0 )					    	dp [ 0 ] = 0						  
  dp [ 1 ] = 1 ;					      	  dp.append ( 1 )					    	dp [ 1 ] = 1						  
  for ( int i = 2 ;					      	  i = 2							    	for i in range ( 2 , n ) :				  
  i < n ;						      	  while i < n :						    	    dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp  
  i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp 	      dp.append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp 	return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 
  return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) 	      i = i + 1						    								  
}							      	  return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER	      WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER	    WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER	  WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER
--							      --							    --								  --
static int countWays ( String s ) {			      def countWays ( s ) :					    def count_ways ( s ) :					  script_not_found : None
  int count [ ] = new int [ 26 ] ;			      	  count = [ 0 ] * 26					    	count = [ 0 ] * 26					  
  for ( int i = 0 ;					      	  for x in s :						    	for c in s :						  
  i < s . length ( ) ;					      	      count [ ord ( x ) - ord ( 'a' ) ] = ( count [ ord ( x 	    count [ ord ( c ) - ord ( 'a' ) ] += 1		  
  i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ;		      	  count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] = 1		    	count [ ord ( 'a' ) ] = 1				  
  count [ s . charAt ( 0 ) - 'a' ] = 1 ;		      	  ans = 1						    	ans = 1							  
  int ans = 1 ;						      	  for i in range ( 26 ) :				    	for i in range ( 26 ) :					  
  for ( int i = 0 ;					      	      if ( count [ i ] != 0 ) :				    	    if count [ i ] != 0 :				  
  i < 26 ;						      		  ans *= count [ i ]				    		ans *= count [ i ]				  
  ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ;	      	  return ans						    	return ans						  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND		      EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND		    EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND		  EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND
--							      --							    --								  --
public static int calculateSum ( String arr [ ] , int n ) {   def calculateSum ( arr , n ) :				    def calculate_sum ( arr , n ) :				  script_not_found : None
  if ( n == 0 ) return 0 ;				      	  if ( n == 0 ) :					    	if not n :						  
  String s = arr [ 0 ] ;				      	      return 0						    	    return 0						  
  int value = Integer . parseInt ( s ) ;		      	  s = arr [ 0 ]						    	s = arr [ 0 ]						  
  int sum = value ;					      	  value = int ( s )					    	value = int ( s )					  
  for ( int i = 2 ;					      	  sum = value						    	sum = value						  
  i < n ;						      	  for i in range ( 2 , n , 2 ) :			    	for i in range ( 2 , n , i + 2 ) :			  
  i = i + 2 ) {						      	      s = arr [ i ]					    	    s = arr [ i ]					  
    s = arr [ i ] ;					      	      value = int ( s )					    	    value = int ( s )					  
    value = Integer . parseInt ( s ) ;			      	      operation = arr [ i - 1 ] [ 0 ]			    	    operation = arr [ i - 1 ] [ 0 ]			  
    char operation = arr [ i - 1 ] . charAt ( 0 ) ;	      	      if ( operation == '+' ) :				    	    if operation == '+' :				  
    if ( operation == '+' ) sum += value ;		      		  sum += value					    		sum += value					  
    else sum -= value ;					      	      else :						    	    else :						  
  }							      		  sum -= value					    		sum -= value					  
  return sum ;						      	  return sum						    	return sum						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y
--							      --							    --								  --
static int countSolutions ( int n ) {			      def countSolutions ( n ) :				    def count_solutions ( n ) :					  failure : #Results: 0, 10
  int x = 0 , yCount , res = 0 ;			      	  x = 0							    	x , y_count , res = 0 , 0 , 0				  
  for ( yCount = 0 ;					      	  res = 0						    	for y_count in range ( 0 , n ) :			  
  yCount * yCount < n ;					      	  yCount = 0						    	    while y_count != 0 :				  
  yCount ++ ) ;						      	  while ( yCount * yCount < n ) :			    		res += y_count					  
  while ( yCount != 0 ) {				      	      yCount = yCount + 1				    		x += 1						  
    res += yCount ;					      	  while ( yCount != 0 ) :				    		while y_count != 0 and ( x * x + ( y_count - 1 )  
    x ++ ;						      	      res = res + yCount				    		    y_count -= 1				  
    while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCoun 	      x = x + 1						    	return res						  
  }							      	      while ( yCount != 0 and ( x * x + ( yCount - 1 ) * (  								  
  return res ;						      		  yCount = yCount - 1				    								  
}							      	  return res						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU
--							      --							    --								  --
static int nCrModp ( int n , int r , int p ) {		      def nCrModp ( n , r , p ) :				    def nCrModp ( n , r , p ) :					  success : None
  int C [ ] = new int [ r + 1 ] ;			      	  C = [ 0 for i in range ( r + 1 ) ]			    	C = [ 0 ] * ( r + 1 )					  
  Arrays . fill ( C , 0 ) ;				      	  C [ 0 ] = 1						    	C [ 0 ] = 1						  
  C [ 0 ] = 1 ;						      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  for ( int i = 1 ;					      	      for j in range ( min ( i , r ) , 0 , - 1 ) :	    	    for j in range ( min ( i , r ) , 0 , - 1 ) :	  
  i <= n ;						      		  C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p	    		C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p		  
  i ++ ) {						      	  return C [ r ]					    	return C [ r ]						  
    for ( int j = Math . min ( i , r ) ;		      								    								  
    j > 0 ;						      								    								  
    j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ;	      								    								  
  }							      								    								  
  return C [ r ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE   MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE   MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE	  MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE
--							      --							    --								  --
static int findMinRooms ( String slots [ ] , int n , int m )  def findMinRooms ( slots , n , m ) :			    def find_min_rooms ( slots , n , m ) :			  script_not_found : None
  int counts [ ] = new int [ m ] ;			      	  counts = [ 0 ] * m					    	counts = [ 0 for i in range ( m ) ]			  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < m ;						      	      for j in range ( m ) :				    	    for j in range ( m ) :				  
  i ++ ) counts [ i ] = 0 ;				      		  if ( slots [ i ] [ j ] == '1' ) :		    		if slots [ i ] [ j ] == '1' :			  
  for ( int i = 0 ;					      		      counts [ j ] += 1				    		    counts [ j ] += 1				  
  i < n ;						      	  return max ( counts )					    	max = - 1						  
  i ++ ) for ( int j = 0 ;				      								    	for i in range ( m ) :					  
  j < m ;						      								    	    if max < counts [ i ] :				  
  j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j  								    		max = counts [ i ]				  
  int max = - 1 ;					      								    	return max						  
  for ( int i = 0 ;					      								    								  
  i < m ;						      								    								  
  i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ;	      								    								  
  return max ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DELETE_CONSECUTIVE_WORDS_SEQUENCE_1			      DELETE_CONSECUTIVE_WORDS_SEQUENCE_1			    DELETE_CONSECUTIVE_WORDS_SEQUENCE_1				  DELETE_CONSECUTIVE_WORDS_SEQUENCE_1
--							      --							    --								  --
static int removeConsecutiveSame ( Vector < String > v ) {    def removeConsecutiveSame ( v ) :				    def remove_consecutive_same ( v ) :				  script_not_found : None
  Stack < String > st = new Stack < > ( ) ;		      	  st = [ ]						    	st = [ ]						  
  for ( int i = 0 ;					      	  for i in range ( len ( v ) ) :			    	for i in v :						  
  i < v . size ( ) ;					      	      if ( len ( st ) == 0 ) :				    	    if not st :						  
  i ++ ) {						      		  st.append ( v [ i ] )				    		st.append ( i )					  
    if ( st . empty ( ) ) st . push ( v . get ( i ) ) ;	      	      else :						    	    else :						  
    else {						      		  Str = st [ - 1 ]				    		x = st [ - 1 ]					  
      String str = st . peek ( ) ;			      		  if ( Str == v [ i ] ) :			    		if x == i :					  
      if ( str . equals ( v . get ( i ) ) ) st . pop ( ) ;    		      st.pop ( )				    		    st.pop ( )					  
      else st . push ( v . get ( i ) ) ;		      		  else :					    		else :						  
    }							      		      st.append ( v [ i ] )			    		    st.append ( i )				  
  }							      	  return len ( st )					    	return len ( st )					  
  return st . size ( ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS		      FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS		    FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS		  FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS
--							      --							    --								  --
int minDist ( int arr [ ] , int n , int x , int y ) {	      def minDist ( arr , n , x , y ) :				    def min_dist ( arr , n , x , y ) :				  failure : #Results: 2, 10
  int i , j ;						      	  min_dist = 99999999					    	i , j = 0 , 0						  
  int min_dist = Integer . MAX_VALUE ;			      	  for i in range ( n ) :				    	min_dist = sys.maxsize					  
  for ( i = 0 ;						      	      for j in range ( i + 1 , n ) :			    	for i in range ( n ) :					  
  i < n ;						      		  if ( x == arr [ i ] and y == arr [ j ] or y == ar 	    for j in range ( i + 1 , n ) :			  
  i ++ ) {						      		      min_dist = abs ( i - j )			    		if ( x == arr [ i ] and y == arr [ j ] or y == ar 
    for ( j = i + 1 ;					      	      return min_dist					    		    min_dist = abs ( i - j )			  
    j < n ;						      								    	return min_dist						  
    j ++ ) {						      								    								  
      if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i 								    								  
    }							      								    								  
  }							      								    								  
  return min_dist ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS     SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS	    SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS	  SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS
--							      --							    --								  --
static int findSum ( int n ) {				      def findSum ( n ) :					    def find_sum ( n ) :					  success : None
  int [ ] [ ] arr = new int [ n ] [ n ] ;		      	  arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] 	arr = np.zeros ( ( n , n ) )				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
  i ++ ) for ( int j = 0 ;				      		  arr [ i ] [ j ] = abs ( i - j )		    		arr [ i ] [ j ] = abs ( i - j )			  
  j < n ;						      	  sum = 0						    	sum = 0							  
  j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ;	      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  int sum = 0 ;						      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
  for ( int i = 0 ;					      		  sum += arr [ i ] [ j ]			    		sum += arr [ i ] [ j ]				  
  i < n ;						      	  return sum						    	return sum						  
  i ++ ) for ( int j = 0 ;				      								    								  
  j < n ;						      								    								  
  j ++ ) sum += arr [ i ] [ j ] ;			      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE		      ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE		    ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE		  ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE
--							      --							    --								  --
static int solveQuery ( int start , int end , int arr [ ] ) { def solveQuery ( start , end , arr ) :			    def solve_query ( start , end , arr ) :			  success : None
  Map < Integer , Integer > mp = new HashMap < > ( ) ;	      	  frequency = dict ( )					    	mp = { }						  
  for ( int i = start ;					      	  for i in range ( start , end + 1 ) :			    	for i in range ( start , end + 1 ) :			  
  i <= end ;						      	      if arr [ i ] in frequency.keys ( ) :		    	    mp [ arr [ i ] ] = 1 if mp.get ( arr [ i ] ) is None  
  i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == nul 		  frequency [ arr [ i ] ] += 1			    	count = 0						  
  int count = 0 ;					      	      else :						    	for key , value in mp.items ( ) :			  
  for ( Map . Entry < Integer , Integer > entry : mp . entryS 		  frequency [ arr [ i ] ] = 1			    	    if key == value :					  
  return count ;					      	  count = 0						    		count += 1					  
}							      	  for x in frequency :					    	return count						  
							      	      if x == frequency [ x ] :				    								  
							      		  count += 1					    								  
							      	  return count						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KNAPSACK_PROBLEM					      KNAPSACK_PROBLEM						    KNAPSACK_PROBLEM						  KNAPSACK_PROBLEM
--							      --							    --								  --
static int knapSack ( int W , int wt [ ] , int val [ ] , int  def knapSack ( W , wt , val , n ) :			    def knapSack ( W , wt , val , n ) :				  script_not_found : None
  if ( n == 0 || W == 0 ) return 0 ;			      	  if n == 0 or W == 0 :					    	if n == 0 or W == 0 :					  
  if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n  	      return 0						    	    return 0						  
  else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 	  if ( wt [ n - 1 ] > W ) :				    	if wt [ n - 1 ] > W :					  
}							      	      return knapSack ( W , wt , val , n - 1 )		    	    return knapSack ( W , wt , val , n - 1 )		  
							      	  else :						    	else :							  
							      	      return max ( val [ n - 1 ] + knapSack ( W - wt [ n -  	    return max ( val [ n - 1 ] + knapSack ( W - wt [ n -  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS			      NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS			    NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS			  NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS
--							      --							    --								  --
static int numberOfPermWithKInversion ( int N , int K ) {     def numberOfPermWithKInversion ( N , K ) :		    def number_of_perm_with_k_inversion ( N , K ) :		  script_not_found : None
  if ( N == 0 ) return 0 ;				      	  if ( N == 0 ) : return 0				    	if N == 0 :						  
  if ( K == 0 ) return 1 ;				      	  if ( K == 0 ) : return 1				    	    return 0						  
  if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ;      	  if ( memo [ N ] [ K ] != 0 ) :			    	if K == 0 :						  
  int sum = 0 ;						      	      return memo [ N ] [ K ]				    	    return 1						  
  for ( int i = 0 ;					      	  sum = 0						    	if K in memo [ N ] :					  
  i <= K ;						      	  for i in range ( K + 1 ) :				    	    return memo [ N ] [ K ]				  
  i ++ ) {						      	      if ( i <= N - 1 ) :				    	sum = 0							  
    if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 		  sum += numberOfPermWithKInversion ( N - 1 , K - i 	for i in range ( 0 , K + 1 ) :				  
  }							      	  memo [ N ] [ K ] = sum				    	    if i <= N - 1 :					  
  memo [ N ] [ K ] = sum ;				      	  return sum						    		sum += number_of_perm_with_k_inversion ( N - 1 ,  
  return sum ;						      								    	memo [ N ] [ K ] = sum					  
}							      								    	return sum						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS			      K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS			    K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS			  K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS
--							      --							    --								  --
static void KMaxCombinations ( int A [ ] , int B [ ] , int N  def KMaxCombinations ( A , B , N , K ) :			    def KMaxCombinations ( A , B , N , K ) :			  script_not_found : None
  PriorityQueue < Integer > pq = new PriorityQueue < Integer  	  pq = PriorityQueue ( )				    	pq = [ 0 ] * len ( list ( A ) )				  
  for ( int i = 0 ;					      	  for i in range ( 0 , N ) :				    	for i in range ( N ) :					  
  i < N ;						      	      for j in range ( 0 , N ) :			    	    for j in range ( N ) :				  
  i ++ ) for ( int j = 0 ;				      		  a = A [ i ] + B [ j ]				    		pq [ i ] = A [ i ] + B [ j ]			  
  j < N ;						      		  pq.put ( ( - a , a ) )			    	count = 0						  
  j ++ ) pq . add ( A [ i ] + B [ j ] ) ;		      	  count = 0						    	while count < K :					  
  int count = 0 ;					      	  while ( count < K ) :					    	    print ( pq [ - 1 ] )				  
  while ( count < K ) {					      	      print ( pq.get ( ) [ 1 ] )			    	    pq.pop ( )						  
    System . out . println ( pq . peek ( ) ) ;		      	      count = count + 1					    	    count += 1						  
    pq . remove ( ) ;					      								    								  
    count ++ ;						      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_BONACCI_NUMBERS_1					      N_BONACCI_NUMBERS_1					    N_BONACCI_NUMBERS_1						  N_BONACCI_NUMBERS_1
--							      --							    --								  --
static void bonacciseries ( int n , int m ) {		      def bonacciseries ( n , m ) :				    def bonacciseries ( n , m ) :				  script_not_found : None
  int a [ ] = new int [ m ] ;				      	  a = [ 0 for i in range ( m ) ]			    	a = [ 0 ] * m						  
  for ( int i = 0 ;					      	  a [ n - 1 ] = 1					    	for i in range ( m ) :					  
  i < m ;						      	  a [ n ] = 1						    	    a [ i ] = 0						  
  i ++ ) a [ i ] = 0 ;					      	  for i in range ( n + 1 , m ) :			    	a [ n - 1 ] = 1						  
  a [ n - 1 ] = 1 ;					      	      a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ]	    	a [ n ] = 1						  
  a [ n ] = 1 ;						      	  for i in range ( 0 , m ) :				    	for i in range ( n + 1 , m ) :				  
  for ( int i = n + 1 ;					      	      print ( a [ i ] , end = " " )			    	    a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ]		  
  i < m ;						      								    	for i in range ( m ) :					  
  i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ;	      								    	    print ( a [ i ] , end = ' ' )			  
  for ( int i = 0 ;					      								    								  
  i < m ;						      								    								  
  i ++ ) System . out . print ( a [ i ] + " " ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE			      PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE			    PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE			  PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE
--							      --							    --								  --
public static void sequence ( int n ) {			      def sequence ( n ) :					    def sequence ( n ) :					  script_not_found : None
  int f [ ] = new int [ n + 1 ] ;			      	  f = [ 0 , 1 , 1 ]					    	f = [ 0 ] * ( n + 1 )					  
  f [ 0 ] = 0 ;						      	  print ( f [ 1 ] , end = " " ) ,			    	f [ 0 ] = 0						  
  f [ 1 ] = 1 ;						      	  print ( f [ 2 ] , end = " " ) ,			    	f [ 1 ] = 1						  
  f [ 2 ] = 1 ;						      	  for i in range ( 3 , n + 1 ) :			    	f [ 2 ] = 1						  
  System . out . print ( f [ 1 ] + " " + f [ 2 ] + " " ) ;    	      f.append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]  	print ( f [ 1 ] , f [ 2 ] , end = ' ' )			  
  for ( int i = 3 ;					      	      print ( f [ i ] , end = " " ) ,			    	for i in range ( 3 , n + 1 ) :				  
  i <= n ;						      								    	    f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]	  
  i ++ ) {						      								    	    print ( f [ i ] , end = ' ' )			  
    f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;     								    								  
    System . out . print ( f [ i ] + " " ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION     MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION	    MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION	  MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION
--							      --							    --								  --
static int maxSubArraySumRepeated ( int a [ ] , int n , int k def maxSubArraySumRepeated ( a , n , k ) :		    def max_sub_array_sum_repeated ( a , n , k ) :		  failure : #Results: 8, 10
  int max_so_far = 0 ;					      	  max_so_far = - 2147483648				    	max_so_far = 0						  
  int INT_MIN , max_ending_here = 0 ;			      	  max_ending_here = 0					    	INT_MIN , max_ending_here = 0 , 0			  
  for ( int i = 0 ;					      	  for i in range ( n * k ) :				    	for i in range ( n * k ) :				  
  i < n * k ;						      	      max_ending_here = max_ending_here + a [ i % n ]	    	    max_ending_here = max_ending_here + a [ i % n ]	  
  i ++ ) {						      	      if ( max_so_far < max_ending_here ) :		    	    if max_so_far < max_ending_here :			  
    max_ending_here = max_ending_here + a [ i % n ] ;	      		  max_so_far = max_ending_here			    		max_so_far = max_ending_here			  
    if ( max_so_far < max_ending_here ) max_so_far = max_endi 	      if ( max_ending_here < 0 ) :			    	    if max_ending_here < 0 :				  
    if ( max_ending_here < 0 ) max_ending_here = 0 ;	      		  max_ending_here = 0				    		max_ending_here = 0				  
  }							      	  return max_so_far					    	return max_so_far					  
  return max_so_far ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL
--							      --							    --								  --
public static int findMinimumAngle ( int arr [ ] , int n ) {  def findMinimumAngle ( arr , n ) :			    def find_minimum_angle ( arr , n ) :			  success : None
  int l = 0 , sum = 0 , ans = 360 ;			      	  l = 0							    	l , sum , ans = 0 , 0 , 360				  
  for ( int i = 0 ;					      	  _sum = 0						    	for i in range ( n ) :					  
  i < n ;						      	  ans = 360						    	    sum += arr [ i ]					  
  i ++ ) {						      	  for i in range ( n ) :				    	    while sum >= 180 :					  
    sum += arr [ i ] ;					      	      _sum += arr [ i ]					    		ans = min ( ans , 2 * abs ( 180 - sum ) )	  
    while ( sum >= 180 ) {				      	      while _sum >= 180 :				    		sum -= arr [ l ]				  
      ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) 		  ans = min ( ans , 2 * abs ( 180 - _sum ) )	    		l += 1						  
      sum -= arr [ l ] ;				      		  _sum -= arr [ l ]				    	    ans = min ( ans , 2 * abs ( 180 - sum ) )		  
      l ++ ;						      		  l += 1					    	return ans						  
    }							      	      ans = min ( ans , 2 * abs ( 180 - _sum ) )	    								  
    ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; 	  return ans						    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORTING_USING_TRIVIAL_HASH_FUNCTION			      SORTING_USING_TRIVIAL_HASH_FUNCTION			    SORTING_USING_TRIVIAL_HASH_FUNCTION				  SORTING_USING_TRIVIAL_HASH_FUNCTION
--							      --							    --								  --
static void sortUsingHash ( int a [ ] , int n ) {	      def sortUsingHash ( a , n ) :				    def sort_using_hash ( a , n ) :				  script_not_found : None
  int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ;  	  Max = max ( a )					    	max = np.max ( a )					  
  int hash [ ] = new int [ max + 1 ] ;			      	  Hash = [ 0 ] * ( Max + 1 )				    	hash = [ 0 ] * ( max + 1 )				  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      Hash [ a [ i ] ] += 1				    	    hash [ a [ i ] ] += 1				  
  i ++ ) hash [ a [ i ] ] += 1 ;			      	  for i in range ( 0 , Max + 1 ) :			    	for i in range ( 0 , max + 1 ) :			  
  for ( int i = 0 ;					      	      if Hash [ i ] != 0 :				    	    if hash [ i ] != 0 :				  
  i <= max ;						      		  for j in range ( 0 , Hash [ i ] ) :		    		for j in range ( hash [ i ] ) :			  
  i ++ ) {						      		      print ( i , end = " " )			    		    print ( i , end = ' ' )			  
    if ( hash [ i ] != 0 ) {				      								    								  
      for ( int j = 0 ;					      								    								  
      j < hash [ i ] ;					      								    								  
      j ++ ) {						      								    								  
	System . out . print ( i + " " ) ;		      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING		      FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING		    FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING		  FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING
--							      --							    --								  --
static int count ( String a , String b , int m , int n ) {    def count ( a , b , m , n ) :				    def count ( a , b , m , n ) :				  script_not_found : None
  if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ;	      	  if ( ( m == 0 and n == 0 ) or n == 0 ) :		    	if ( m == 0 and n == 0 ) or n == 0 :			  
  if ( m == 0 ) return 0 ;				      	      return 1						    	    return 1						  
  if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return  	  if ( m == 0 ) :					    	if m == 0 :						  
  else return count ( a , b , m - 1 , n ) ;		      	      return 0						    	    return 0						  
}							      	  if ( a [ m - 1 ] == b [ n - 1 ] ) :			    	if a [ m - 1 ] == b [ n - 1 ] :				  
							      	      return ( count ( a , b , m - 1 , n - 1 ) + count ( a  	    return count ( a , b , m - 1 , n - 1 ) + count ( a ,  
							      	  else :						    	else :							  
							      	      return count ( a , b , m - 1 , n )		    	    return count ( a , b , m - 1 , n )			  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS	      COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS		    COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS		  COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS
--							      --							    --								  --
static int countWords ( String str [ ] , int n ) {	      def countWords ( stri , n ) :				    def count_words ( str , n ) :				  error : Traceback (most recent call last):   File
  HashMap < String , Integer > m = new HashMap < > ( ) ;      	  m = dict ( )						    	m = { }							  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  68770/eval_scripts/java_sa-python_sa.test/COUNT_WO
  i < n ;						      	      m [ stri [ i ] ] = m.get ( stri [ i ] , 0 ) + 1	    	    if str [ i ] in m :					  RDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS.py", line
  i ++ ) {						      	  res = 0						    		get = m [ str [ i ] ]				   58, in <module>     if f_filled(*parameters_set)
    if ( m . containsKey ( str [ i ] ) ) {		      	  for i in m.values ( ) :				    		m [ str [ i ] ] = get + 1			  == f_gold(*parameters_set):	File "dump/transcode
      int get = m . get ( str [ i ] ) ;			      	      if i == 2 :					    	    else :						  r_st/eval/java_python/online_st/20668770/eval_scri
      m . put ( str [ i ] , get + 1 ) ;			      		  res += 1					    		m [ str [ i ] ] = 1				  pts/java_sa-python_sa.test/COUNT_WORDS_APPEAR_EXAC
    }							      	  return res						    	res = 0							  TLY_TWO_TIMES_ARRAY_WORDS.py", line 38, in f_fille
    else {						      								    	for it in m.items ( ) :					  d	if len ( str [ it ] ) == 2 : TypeError: list
      m . put ( str [ i ] , 1 ) ;			      								    	    if len ( str [ it ] ) == 2 :			   indices must be integers or slices, not tuple
    }							      								    		res += 1					  
  }							      								    	return res						  
  int res = 0 ;						      								    								  
  for ( Map . Entry < String , Integer > it : m . entrySet (  								    								  
    if ( it . getValue ( ) == 2 ) res ++ ;		      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU
--							      --							    --								  --
static boolean canMakeStr2 ( String str1 , String str2 ) {    def canMakeStr2 ( s1 , s2 ) :				    def canMakeStr2 ( str1 , str2 ) :				  script_not_found : None
  int [ ] count = new int [ MAX ] ;			      	  count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) }    	count = [ 0 ] * MAX					  
  char [ ] str3 = str1 . toCharArray ( ) ;		      	  for i in range ( len ( s1 ) ) :			    	str3 = list ( str1 )					  
  for ( int i = 0 ;					      	      count [ s1 [ i ] ] += 1				    	for i in range ( len ( str3 ) ) :			  
  i < str3 . length ;					      	  for i in range ( len ( s2 ) ) :			    	    count [ str3 [ i ] ] += 1				  
  i ++ ) count [ str3 [ i ] ] ++ ;			      	      if count [ s2 [ i ] ] == 0 :			    	str4 = list ( str2 )					  
  char [ ] str4 = str2 . toCharArray ( ) ;		      		  return False					    	for i in range ( len ( str4 ) ) :			  
  for ( int i = 0 ;					      	      count [ s2 [ i ] ] -= 1				    	    if count [ str4 [ i ] ] == 0 :			  
  i < str4 . length ;					      	  return True						    		return False					  
  i ++ ) {						      								    	    count [ str4 [ i ] ] -= 1				  
    if ( count [ str4 [ i ] ] == 0 ) return false ;	      								    	return True						  
    count [ str4 [ i ] ] -- ;				      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1			      SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1			    SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1			  SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1
--							      --							    --								  --
static int sortedAfterSwap ( int [ ] A , int [ ] B , int n )  def sortedAfterSwap ( A , B , n ) :			    def sorted_after_swap ( A , B , n ) :			  script_not_found : None
  int t = 0 ;						      	  for i in range ( 0 , n - 1 ) :			    	t = 0							  
  for ( int i = 0 ;					      	      if B [ i ] :					    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      		  if A [ i ] != i + 1 :				    	    if B [ i ] != 0 :					  
  i ++ ) {						      		      A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] 		if A [ i ] != i + 1 :				  
    if ( B [ i ] != 0 ) {				      	  for i in range ( n ) :				    		    t = A [ i ]					  
      if ( A [ i ] != i + 1 ) t = A [ i ] ;		      	      if A [ i ] != i + 1 :				    		A [ i ] = A [ i + 1 ]				  
      A [ i ] = A [ i + 1 ] ;				      		  return False					    		A [ i + 1 ] = t					  
      A [ i + 1 ] = t ;					      	  return True						    	for i in range ( n ) :					  
    }							      								    	    if A [ i ] != i + 1 :				  
  }							      								    		return 0					  
  for ( int i = 0 ;					      								    	return 1						  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    if ( A [ i ] != i + 1 ) return 0 ;			      								    								  
  }							      								    								  
  return 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTISTAGE_GRAPH_SHORTEST_PATH				      MULTISTAGE_GRAPH_SHORTEST_PATH				    MULTISTAGE_GRAPH_SHORTEST_PATH				  MULTISTAGE_GRAPH_SHORTEST_PATH
--							      --							    --								  --
public static int shortestDist ( int [ ] [ ] graph ) {	      def shortestDist ( graph ) :				    def shortest_dist ( graph ) :				  script_not_found : None
  int [ ] dist = new int [ N ] ;			      	  global INF						    	dist = [ 0 ] * N					  
  dist [ N - 1 ] = 0 ;					      	  dist = [ 0 ] * N					    	dist [ N - 1 ] = 0					  
  for ( int i = N - 2 ;					      	  dist [ N - 1 ] = 0					    	for i in range ( N - 2 , - 1 , - 1 ) :			  
  i >= 0 ;						      	  for i in range ( N - 2 , - 1 , - 1 ) :		    	    dist [ i ] = INF					  
  i -- ) {						      	      dist [ i ] = INF					    	    for j in range ( i , N ) :				  
    dist [ i ] = INF ;					      	      for j in range ( N ) :				    		if graph [ i ] [ j ] == INF :			  
    for ( int j = i ;					      		  if graph [ i ] [ j ] == INF :			    		    continue					  
    j < N ;						      		      continue					    		dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] 
    j ++ ) {						      		  dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] 	return dist [ 0 ]					  
      if ( graph [ i ] [ j ] == INF ) {			      	  return dist [ 0 ]					    								  
	continue ;					      								    								  
      }							      								    								  
      dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j  								    								  
    }							      								    								  
  }							      								    								  
  return dist [ 0 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME		      COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME			    COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME			  COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME
--							      --							    --								  --
static int count ( int n ) {				      def count ( n ) :						    def count ( n ) :						  success : None
  int table [ ] = new int [ n + 1 ] , i ;		      	  table = [ 0 for i in range ( n + 1 ) ]		    	table , i = [ 0 ] * ( n + 1 ) , 0			  
  Arrays . fill ( table , 0 ) ;				      	  table [ 0 ] = 1					    	table [ 0 ] = 1						  
  table [ 0 ] = 1 ;					      	  for i in range ( 3 , n + 1 ) :			    	for i in range ( 3 , n + 1 ) :				  
  for ( i = 3 ;						      	      table [ i ] += table [ i - 3 ]			    	    table [ i ] += table [ i - 3 ]			  
  i <= n ;						      	  for i in range ( 5 , n + 1 ) :			    	for i in range ( 5 , n + 1 ) :				  
  i ++ ) table [ i ] += table [ i - 3 ] ;		      	      table [ i ] += table [ i - 5 ]			    	    table [ i ] += table [ i - 5 ]			  
  for ( i = 5 ;						      	  for i in range ( 10 , n + 1 ) :			    	for i in range ( 10 , n + 1 ) :				  
  i <= n ;						      	      table [ i ] += table [ i - 10 ]			    	    table [ i ] += table [ i - 10 ]			  
  i ++ ) table [ i ] += table [ i - 5 ] ;		      	  return table [ n ]					    	return table [ n ]					  
  for ( i = 10 ;					      								    								  
  i <= n ;						      								    								  
  i ++ ) table [ i ] += table [ i - 10 ] ;		      								    								  
  return table [ n ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1			      FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1			    FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1				  FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1
--							      --							    --								  --
static void CountTriangles ( int [ ] A ) {		      def CountTriangles ( A ) :				    def CountTriangles ( A ) :					  script_not_found : None
  int n = A . length ;					      	  n = len ( A )						    	n = len ( A )						  
  Arrays . sort ( A ) ;					      	  A.sort ( )						    	A.sort ( )						  
  int count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int i = n - 1 ;					      	  for i in range ( n - 1 , 0 , - 1 ) :			    	for i in range ( n - 1 , 1 , - 1 ) :			  
  i >= 1 ;						      	      l = 0						    	    l , r = 0 , i - 1					  
  i -- ) {						      	      r = i - 1						    	    while l < r :					  
    int l = 0 , r = i - 1 ;				      	      while ( l < r ) :					    		if A [ l ] + A [ r ] > A [ i ] :		  
    while ( l < r ) {					      		  if ( A [ l ] + A [ r ] > A [ i ] ) :		    		    count += r - l				  
      if ( A [ l ] + A [ r ] > A [ i ] ) {		      		      count += r - l				    		    r -= 1					  
	count += r - l ;				      		      r -= 1					    		else :						  
	r -- ;						      		  else :					    		    l += 1					  
      }							      		      l += 1					    	sys.stdout.write ( "No of possible solutions: %d\n" % cou 
      else {						      	  print ( "No of possible solutions: " , count )	    								  
	l ++ ;						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  System . out . print ( "No of possible solutions: " + count 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS	      GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS		    GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS		  GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS
--							      --							    --								  --
static void findMin ( int V ) {				      def findMin ( V ) :					    def find_min ( V ) :					  script_not_found : None
  Vector < Integer > ans = new Vector < > ( ) ;		      	  deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ]    	ans = [ ]						  
  for ( int i = n - 1 ;					      	  n = len ( deno )					    	for i in range ( n - 1 , - 1 , - 1 ) :			  
  i >= 0 ;						      	  ans = [ ]						    	    while V >= deno [ i ] :				  
  i -- ) {						      	  i = n - 1						    		V -= deno [ i ]					  
    while ( V >= deno [ i ] ) {				      	  while ( i >= 0 ) :					    		ans.append ( deno [ i ] )			  
      V -= deno [ i ] ;					      	      while ( V >= deno [ i ] ) :			    	for i in ans :						  
      ans . add ( deno [ i ] ) ;			      		  V -= deno [ i ]				    	    print ( " " , i , end = " " )			  
    }							      		  ans.append ( deno [ i ] )			    								  
  }							      	      i -= 1						    								  
  for ( int i = 0 ;					      	  for i in range ( len ( ans ) ) :			    								  
  i < ans . size ( ) ;					      	      print ( ans [ i ] , end = " " )			    								  
  i ++ ) {						      								    								  
    System . out . print ( " " + ans . elementAt ( i ) ) ;    								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY  DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY  DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY  DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY
--							      --							    --								  --
static int findDiff ( int arr [ ] , int n ) {		      def findDiff ( arr , n ) :				    def find_diff ( arr , n ) :					  success : None
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  int count = 0 , max_count = 0 , min_count = n ;	      	  count = 0 max_count = 0 min_count = n			    	count , max_count , min_count = 0 , 0 , n		  
  for ( int i = 0 ;					      	  for i in range ( 0 , ( n - 1 ) ) :			    	for i in range ( ( n - 1 ) ) :				  
  i < ( n - 1 ) ;					      	      if arr [ i ] == arr [ i + 1 ] :			    	    if arr [ i ] == arr [ i + 1 ] :			  
  i ++ ) {						      		  count += 1					    		count += 1					  
    if ( arr [ i ] == arr [ i + 1 ] ) {			      		  continue					    		continue					  
      count += 1 ;					      	      else :						    	    else :						  
      continue ;					      		  max_count = max ( max_count , count )		    		max_count = max ( max_count , count )		  
    }							      		  min_count = min ( min_count , count )		    		min_count = min ( min_count , count )		  
    else {						      		  count = 0					    		count = 0					  
      max_count = Math . max ( max_count , count ) ;	      	  return max_count - min_count				    	return ( max_count - min_count )			  
      min_count = Math . min ( min_count , count ) ;	      								    								  
      count = 0 ;					      								    								  
    }							      								    								  
  }							      								    								  
  return ( max_count - min_count ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE			      CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE			    CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE			  CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE
--							      --							    --								  --
boolean areConsecutive ( int arr [ ] , int n ) {	      def areConsecutive ( arr , n ) :				    def are_consecutive ( arr , n ) :				  error : Traceback (most recent call last):   File
  if ( n < 1 ) return false ;				      	  if ( n < 1 ) :					    	if n < 1 :						  "dump/transcoder_st/eval/java_python/online_st/206
  int min = getMin ( arr , n ) ;			      	      return False					    	    return False					  68770/eval_scripts/java_sa-python_sa.test/CHECK_IF
  int max = getMax ( arr , n ) ;			      	  Min = min ( arr )					    	min = min ( arr , n )					  _ARRAY_ELEMENTS_ARE_CONSECUTIVE.py", line 63, in <
  if ( max - min + 1 == n ) {				      	  Max = max ( arr )					    	max = max ( arr , n )					  module>     if f_filled(*parameters_set) == f_gold
    boolean visited [ ] = new boolean [ n ] ;		      	  if ( Max - Min + 1 == n ) :				    	if max - min + 1 == n :					  (*parameters_set):   File "dump/transcoder_st/eval
    int i ;						      	      visited = [ False for i in range ( n ) ]		    	    visited = [ False ] * n				  /java_python/online_st/20668770/eval_scripts/java_
    for ( i = 0 ;					      	      for i in range ( n ) :				    	    i = 0						  sa-python_sa.test/CHECK_IF_ARRAY_ELEMENTS_ARE_CONS
    i < n ;						      		  if ( visited [ arr [ i ] - Min ] != False ) :	    	    for i in range ( n ) :				  ECUTIVE.py", line 35, in f_filled	min = min (
    i ++ ) {						      		      return False				    		if visited [ arr [ i ] - min ] :		  arr , n ) UnboundLocalError: local variable 'min'
      if ( visited [ arr [ i ] - min ] != false ) return fals 		  visited [ arr [ i ] - Min ] = True		    		    return False				  referenced before assignment
      visited [ arr [ i ] - min ] = true ;		      	      return True					    		visited [ arr [ i ] - min ] = True		  
    }							      	  return False						    	    return True						  
    return true ;					      								    	return False						  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_AREA_TRIANGLE				      C_PROGRAM_FIND_AREA_TRIANGLE				    C_PROGRAM_FIND_AREA_TRIANGLE				  C_PROGRAM_FIND_AREA_TRIANGLE
--							      --							    --								  --
static float findArea ( float a , float b , float c ) {	      def findArea ( a , b , c ) :				    def find_area ( a , b , c ) :				  script_not_found : None
  if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <=  	  if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c 	if a < 0 or b < 0 or c < 0 or ( a + b <= c ) or a + c <=  
    System . out . println ( "Not a valid triangle" ) ;	      	      print ( 'Not a valid trianglen' )			    	    print ( "Not a valid triangle" )			  
    System . exit ( 0 ) ;				      	      return						    	    sys.exit ( )					  
  }							      	  s = ( a + b + c ) / 2					    	s = ( a + b + c ) / 2					  
  float s = ( a + b + c ) / 2 ;				      	  area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5   	return float ( math.sqrt ( s * ( s - a ) * ( s - b ) * (  
  return ( float ) Math . sqrt ( s * ( s - a ) * ( s - b ) *  	  print ( 'Area of a traingle is %f' % area )		    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2	      PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2		    PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2		  PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2
--							      --							    --								  --
static void printSubsequences ( String s ) {		      def printSubsequences ( str ) :				    def printSubsequences ( s ) :				  script_not_found : None
  char [ ] str = s . toCharArray ( ) ;			      	  n = len ( str )					    	s = list ( s )						  
  int n = str . length ;				      	  opsize = int ( pow ( 2 , n - 1 ) )			    	n = len ( s )						  
  int opsize = ( int ) ( Math . pow ( 2 , n - 1 ) ) ;	      	  for counter in range ( opsize ) :			    	opsize = int ( pow ( 2 , n - 1 ) )			  
  for ( int counter = 0 ;				      	      for j in range ( n ) :				    	for counter in range ( opsize ) :			  
  counter < opsize ;					      		  print ( str [ j ] , end = "" )		    	    for j in range ( n ) :				  
  counter ++ ) {					      		  if ( counter & ( 1 << j ) ) :			    		print ( s [ j ] , end = ' ' )			  
    for ( int j = 0 ;					      		      print ( "" , end = "" )			    		if ( counter & ( 1 << j ) ) > 0 :		  
    j < n ;						      	      print ( "\n" , end = "" )				    		    print ( ' ' , end = ' ' )			  
    j ++ ) {						      								    	    print ( )						  
      System . out . print ( str [ j ] ) ;		      								    								  
      if ( ( counter & ( 1 << j ) ) > 0 ) System . out . prin 								    								  
    }							      								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FREQUENCY_ELEMENT_UNSORTED_ARRAY_1			      FREQUENCY_ELEMENT_UNSORTED_ARRAY_1			    FREQUENCY_ELEMENT_UNSORTED_ARRAY_1				  FREQUENCY_ELEMENT_UNSORTED_ARRAY_1
--							      --							    --								  --
static void countFreq ( int a [ ] , int n ) {		      def countFreq ( a , n ) :					    def count_freq ( a , n ) :					  script_not_found : None
  int hm [ ] = new int [ n ] ;				      	  hm = dict ( )						    	hm = [ 0 ] * n						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      hm [ a [ i ] ] = hm.get ( a [ i ] , 0 ) + 1	    	    hm [ a [ i ] ] += 1					  
  i ++ ) hm [ a [ i ] ] ++ ;				      	  cumul = 0						    	cumul = 0						  
  int cumul = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      cumul += hm [ a [ i ] ]				    	    cumul += hm [ a [ i ] ]				  
  i < n ;						      	      if ( hm [ a [ i ] ] > 0 ) :			    	    if hm [ a [ i ] ] != 0 :				  
  i ++ ) {						      		  print ( a [ i ] , "->" , cumul )		    		print ( '%d->%d' % ( a [ i ] , cumul ) )	  
    cumul += hm [ a [ i ] ] ;				      	      hm [ a [ i ] ] = 0				    	    hm [ a [ i ] ] = 0					  
    if ( hm [ a [ i ] ] != 0 ) {			      								    								  
      System . out . println ( a [ i ] + "->" + cumul ) ;     								    								  
    }							      								    								  
    hm [ a [ i ] ] = 0 ;				      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE	      COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE		    COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE		  COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE
--							      --							    --								  --
static int countIslands ( int mat [ ] [ ] , int m , int n ) { def countIslands ( mat ) :				    def count_islands ( mat , m , n ) :				  script_not_found : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int i = 0 ;					      	  for i in range ( 0 , M ) :				    	for i in range ( m ) :					  
  i < m ;						      	      for j in range ( 0 , N ) :			    	    for j in range ( n ) :				  
  i ++ ) {						      		  if ( mat [ i ] [ j ] == 'X' ) :		    		if mat [ i ] [ j ] == 'X' :			  
    for ( int j = 0 ;					      		      if ( ( i == 0 or mat [ i - 1 ] [ j ] == 'O' ) 		    if ( i == 0 or mat [ i - 1 ] [ j ] == 'O' ) a 
    j < n ;						      			  count = count + 1			    			count += 1				  
    j ++ ) {						      	  return count						    	return count						  
      if ( mat [ i ] [ j ] == 'X' ) {			      								    								  
	if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j  								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_PRIME_FACTOR_GIVEN_NUMBER				      K_TH_PRIME_FACTOR_GIVEN_NUMBER				    K_TH_PRIME_FACTOR_GIVEN_NUMBER				  K_TH_PRIME_FACTOR_GIVEN_NUMBER
--							      --							    --								  --
static int kPrimeFactor ( int n , int k ) {		      def kPrimeFactor ( n , k ) :				    def kPrimeFactor ( n , k ) :				  error : Traceback (most recent call last):   File
  while ( n % 2 == 0 ) {				      	  while ( n % 2 == 0 ) :				    	while n % 2 == 0 :					  "dump/transcoder_st/eval/java_python/online_st/206
    k -- ;						      	      k = k - 1						    	    k -= 1						  68770/eval_scripts/java_sa-python_sa.test/K_TH_PRI
    n = n / 2 ;						      	      n = n / 2						    	    n = n // 2						  ME_FACTOR_GIVEN_NUMBER.py", line 70, in <module>
    if ( k == 0 ) return 2 ;				      	      if ( k == 0 ) :					    	    if not k :						     if f_filled(*parameters_set) == f_gold(*paramet
  }							      		  return 2					    		return 2					  ers_set):   File "dump/transcoder_st/eval/java_pyt
  for ( int i = 3 ;					      	  i = 3							    	for i in range ( 3 , math.sqrt ( n ) + 1 , 2 ) :	  hon/online_st/20668770/eval_scripts/java_sa-python
  i <= Math . sqrt ( n ) ;				      	  while i <= math.sqrt ( n ) :				    	    while n % i == 0 :					  _sa.test/K_TH_PRIME_FACTOR_GIVEN_NUMBER.py", line
  i = i + 2 ) {						      	      while ( n % i == 0 ) :				    		if k == 1 :					  44, in f_filled     for i in range ( 3 , math.sqrt
    while ( n % i == 0 ) {				      		  if ( k == 1 ) :				    		    return i					   ( n ) + 1 , 2 ) : TypeError: 'float' object canno
      if ( k == 1 ) return i ;				      		      return i					    		k -= 1						  t be interpreted as an integer
      k -- ;						      		  k = k - 1					    		n = n // i					  
      n = n / i ;					      		  n = n / i					    	if n > 2 and k == 1 :					  
    }							      	      i = i + 2						    	    return n						  
  }							      	  if ( n > 2 and k == 1 ) :				    	return - 1						  
  if ( n > 2 && k == 1 ) return n ;			      	      return n						    								  
  return - 1 ;						      	  return - 1						    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES		      FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES		    FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES		  FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES
--							      --							    --								  --
static int findSDSFunc ( int n ) {			      def findSDSFunc ( n ) :					    def find_sds_func ( n ) :					  success : None
  int DP [ ] = new int [ n + 1 ] ;			      	  DP = [ 0 ] * ( n + 1 )				    	DP = [ 0 ] * ( n + 1 )					  
  DP [ 0 ] = 0 ;					      	  DP [ 0 ] = 0						    	DP [ 0 ] = 0						  
  DP [ 1 ] = 1 ;					      	  DP [ 1 ] = 1						    	DP [ 1 ] = 1						  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	      if ( int ( i % 2 ) == 0 ) :			    	    if i % 2 == 0 :					  
  i ++ ) {						      		  DP [ i ] = DP [ int ( i / 2 ) ]		    		DP [ i ] = DP [ i // 2 ]			  
    if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ;		      	      else :						    	    else :						  
    else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 		  DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [  		DP [ i ] = DP [ ( i - 1 ) // 2 ] + DP [ ( i + 1 ) 
  }							      	  return DP [ n ]					    	return DP [ n ]						  
  return DP [ n ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TILING_WITH_DOMINOES					      TILING_WITH_DOMINOES					    TILING_WITH_DOMINOES					  TILING_WITH_DOMINOES
--							      --							    --								  --
static int countWays ( int n ) {			      def countWays ( n ) :					    def count_ways ( n ) :					  success : None
  int [ ] A = new int [ n + 1 ] ;			      	  A = [ 0 ] * ( n + 1 )					    	A = [ 0 ] * ( n + 1 )					  
  int [ ] B = new int [ n + 1 ] ;			      	  B = [ 0 ] * ( n + 1 )					    	B = [ 0 ] * ( n + 1 )					  
  A [ 0 ] = 1 ;						      	  A [ 0 ] = 1						    	A [ 0 ] = 1						  
  A [ 1 ] = 0 ;						      	  A [ 1 ] = 0						    	A [ 1 ] = 0						  
  B [ 0 ] = 0 ;						      	  B [ 0 ] = 0						    	B [ 0 ] = 0						  
  B [ 1 ] = 1 ;						      	  B [ 1 ] = 1						    	B [ 1 ] = 1						  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	      A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ]		    	    A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ]		  
  i ++ ) {						      	      B [ i ] = A [ i - 1 ] + B [ i - 2 ]		    	    B [ i ] = A [ i - 1 ] + B [ i - 2 ]			  
    A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ;		      	  return A [ n ]					    	return A [ n ]						  
    B [ i ] = A [ i - 1 ] + B [ i - 2 ] ;		      								    								  
  }							      								    								  
  return A [ n ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS     RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS	    RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS	  RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS
--							      --							    --								  --
static int countSubstrs ( String str , int i , int j , int n  def countSubstrs ( str , i , j , n ) :			    def count_strs ( str , i , j , n ) :			  script_not_found : None
  if ( n == 1 ) return 1 ;				      	  if ( n == 1 ) :					    	if n == 1 :						  
  if ( n <= 0 ) return 0 ;				      	      return 1						    	    return 1						  
  int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countS 	  if ( n <= 0 ) :					    	if n <= 0 :						  
  if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ;    	      return 0						    	    return 0						  
  return res ;						      	  res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countS 	res = count_strs ( str , i + 1 , j , n - 1 ) + count_strs 
}							      	  if ( str [ i ] == str [ j ] ) :			    	if str [ i ] == str [ j ] :				  
							      	      res += 1						    	    res += 1						  
							      	  return res						    	return res						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3	    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3
--							      --							    --								  --
void printRepeating ( int arr [ ] , int size ) {	      def printRepeating ( arr , size ) :			    def print_repeating ( arr , size ) :			  script_not_found : None
  int i ;						      	  print ( " The repeating elements are" , end = " " )	    	global i						  
  System . out . println ( "The repeating elements are : " )  	  for i in range ( 0 , size ) :				    	print ( "The repeating elements are : " )		  
  for ( i = 0 ;						      	      if ( arr [ abs ( arr [ i ] ) ] > 0 ) :		    	for i in range ( size ) :				  
  i < size ;						      		  arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( 	    if arr [ abs ( arr [ i ] ) ] > 0 :			  
  i ++ ) {						      	      else :						    		arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i 
    if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math .  		  print ( abs ( arr [ i ] ) , end = " " )	    	    else :						  
    else System . out . print ( Math . abs ( arr [ i ] ) + "  								    		print ( abs ( arr [ i ] ) , end = " " )		  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECAMANS_SEQUENCE_1					      RECAMANS_SEQUENCE_1					    RECAMANS_SEQUENCE_1						  RECAMANS_SEQUENCE_1
--							      --							    --								  --
static void recaman ( int n ) {				      def recaman ( n ) :					    def recaman ( n ) :						  script_not_found : None
  if ( n <= 0 ) return ;				      	  if ( n <= 0 ) :					    	if n <= 0 :						  
  System . out . printf ( "%d, " , 0 ) ;		      	      return						    	    return						  
  HashSet < Integer > s = new HashSet < Integer > ( ) ;	      	  print ( 0 , "," , end = '' )				    	print ( 0 , end = "" )					  
  s . add ( 0 ) ;					      	  s = set ( [ ] )					    	s = set ( )						  
  int prev = 0 ;					      	  s.add ( 0 )						    	s.add ( 0 )						  
  for ( int i = 1 ;					      	  prev = 0						    	prev = 0						  
  i < n ;						      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i ++ ) {						      	      curr = prev - i					    	    curr = prev - i					  
    int curr = prev - i ;				      	      if ( curr < 0 or curr in s ) :			    	    if curr < 0 or curr in s :				  
    if ( curr < 0 || s . contains ( curr ) ) curr = prev + i  		  curr = prev + i				    		curr = prev + i					  
    s . add ( curr ) ;					      	      s.add ( curr )					    	    s.add ( curr )					  
    System . out . printf ( "%d, " , curr ) ;		      	      print ( curr , "," , end = '' )			    	    print ( curr , end = "" )				  
    prev = curr ;					      	      prev = curr					    	    prev = curr						  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAJORITY_ELEMENT					      MAJORITY_ELEMENT						    MAJORITY_ELEMENT						  MAJORITY_ELEMENT
--							      --							    --								  --
static void findMajority ( int arr [ ] , int n ) {	      def findMajority ( arr , n ) :				    def find_majority ( arr , n ) :				  script_not_found : None
  int maxCount = 0 ;					      	  maxCount = 0 ;					    	max_count = 0						  
  int index = - 1 ;					      	  index = - 1						    	index = - 1						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      count = 0						    	    count = 0						  
  i ++ ) {						      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
    int count = 0 ;					      		  if ( arr [ i ] == arr [ j ] ) :		    		if arr [ i ] == arr [ j ] :			  
    for ( int j = 0 ;					      		      count += 1				    		    count += 1					  
    j < n ;						      	      if ( count > maxCount ) :				    	    if count > max_count :				  
    j ++ ) {						      		  maxCount = count				    		max_count = count				  
      if ( arr [ i ] == arr [ j ] ) count ++ ;		      		  index = i					    		index = i					  
    }							      	  if ( maxCount > n // 2 ) :				    	if max_count > n // 2 :					  
    if ( count > maxCount ) {				      	      print ( arr [ index ] )				    	    print ( arr [ index ] )				  
      maxCount = count ;				      	  else :						    	else :							  
      index = i ;					      	      print ( "No Majority Element" )			    	    print ( 'No Majority Element' )			  
    }							      								    								  
  }							      								    								  
  if ( maxCount > n / 2 ) System . out . println ( arr [ inde 								    								  
  else System . out . println ( "No Majority Element" ) ;     								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_ODD_FACTORS_NUMBER				      FIND_SUM_ODD_FACTORS_NUMBER				    FIND_SUM_ODD_FACTORS_NUMBER					  FIND_SUM_ODD_FACTORS_NUMBER
--							      --							    --								  --
static int sumofoddFactors ( int n ) {			      def sumofoddFactors ( n ) :				    def sumofoddFactors ( n ) :					  error : Traceback (most recent call last):   File
  int res = 1 ;						      	  res = 1						    	res = 1							  "dump/transcoder_st/eval/java_python/online_st/206
  while ( n % 2 == 0 ) n = n / 2 ;			      	  while n % 2 == 0 :					    	while n % 2 == 0 :					  68770/eval_scripts/java_sa-python_sa.test/FIND_SUM
  for ( int i = 3 ;					      	      n = n // 2					    	    n = n // 2						  _ODD_FACTORS_NUMBER.py", line 71, in <module>
  i <= Math . sqrt ( n ) ;				      	  for i in range ( 3 , int ( math.sqrt ( n ) + 1 ) ) :	    	for i in range ( 3 , math.sqrt ( n ) + 1 ) :		  if f_filled(*parameters_set) == f_gold(*parameters
  i ++ ) {						      	      count = 0						    	    count , currSum = 0 , 1				  _set):   File "dump/transcoder_st/eval/java_python
    int count = 0 , curr_sum = 1 ;			      	      curr_sum = 1					    	    currTerm = 1					  /online_st/20668770/eval_scripts/java_sa-python_sa
    int curr_term = 1 ;					      	      curr_term = 1					    	    while n % i == 0 :					  .test/FIND_SUM_ODD_FACTORS_NUMBER.py", line 42, in
    while ( n % i == 0 ) {				      	      while n % i == 0 :				    		count += 1					   f_filled	for i in range ( 3 , math.sqrt ( n )
      count ++ ;					      		  count += 1					    		n = n // i					   + 1 ) : TypeError: 'float' object cannot be inter
      n = n / i ;					      		  n = n // i					    		currTerm *= i					  preted as an integer
      curr_term *= i ;					      		  curr_term *= i				    		currSum += currTerm				  
      curr_sum += curr_term ;				      		  curr_sum += curr_term				    	    res *= currSum					  
    }							      	      res *= curr_sum					    	if n >= 2 :						  
    res *= curr_sum ;					      	  if n >= 2 :						    	    res *= ( 1 + n )					  
  }							      	      res *= ( 1 + n )					    	return res						  
  if ( n >= 2 ) res *= ( 1 + n ) ;			      	  return res						    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS      COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS	    COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS	  COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS
--							      --							    --								  --
static int chordCnt ( int A ) {				      def chordCnt ( A ) :					    def chordCnt ( A ) :					  success : None
  int n = 2 * A ;					      	  n = 2 * A						    	n = 2 * A						  
  int [ ] dpArray = new int [ n + 1 ] ;			      	  dpArray = [ 0 ] * ( n + 1 )				    	dplist = [ 0 ] * ( n + 1 )				  
  dpArray [ 0 ] = 1 ;					      	  dpArray [ 0 ] = 1					    	dplist [ 0 ] = 1					  
  dpArray [ 2 ] = 1 ;					      	  dpArray [ 2 ] = 1					    	dplist [ 2 ] = 1					  
  for ( int i = 4 ;					      	  for i in range ( 4 , n + 1 , 2 ) :			    	for i in range ( 4 , n + 1 , 2 ) :			  
  i <= n ;						      	      for j in range ( 0 , i - 1 , 2 ) :		    	    for j in range ( 0 , i - 1 , 2 ) :			  
  i += 2 ) {						      		  dpArray [ i ] += ( dpArray [ j ] * dpArray [ i -  		dplist [ i ] += ( dplist [ j ] * dplist [ i - 2 - 
    for ( int j = 0 ;					      	  return int ( dpArray [ n ] )				    	return dplist [ n ]					  
    j < i - 1 ;						      								    								  
    j += 2 ) {						      								    								  
      dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j  								    								  
    }							      								    								  
  }							      								    								  
  return dpArray [ n ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE
--							      --							    --								  --
static int countWays ( int n , int m ) {		      def countWays ( n , m ) :					    def count_ways ( n , m ) :					  success : None
  int count [ ] = new int [ n + 1 ] ;			      	  count = [ ]						    	count = [ 0 ] * ( n + 1 )				  
  count [ 0 ] = 0 ;					      	  for i in range ( n + 2 ) :				    	count [ 0 ] = 0						  
  int i ;						      	      count.append ( 0 )				    	i = 0							  
  for ( i = 1 ;						      	  count [ 0 ] = 0					    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	  for i in range ( 1 , n + 1 ) :			    	    if i > m :						  
  i ++ ) {						      	      if ( i > m ) :					    		count [ i ] = count [ i - 1 ] + count [ i - m ]	  
    if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i -  		  count [ i ] = count [ i - 1 ] + count [ i - m ]   	    elif i < m :					  
    else if ( i < m ) count [ i ] = 1 ;			      	      elif ( i < m ) :					    		count [ i ] = 1					  
    else count [ i ] = 2 ;				      		  count [ i ] = 1				    	    else :						  
  }							      	      else :						    		count [ i ] = 2					  
  return count [ n ] ;					      		  count [ i ] = 2				    	return count [ n ]					  
}							      	  return count [ n ]					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMAINDER_7_LARGE_NUMBERS				      REMAINDER_7_LARGE_NUMBERS					    REMAINDER_7_LARGE_NUMBERS					  REMAINDER_7_LARGE_NUMBERS
--							      --							    --								  --
static int remainderWith7 ( String num ) {		      def remainderWith7 ( num ) :				    def remainder_with_7 ( num ) :				  error : Traceback (most recent call last):   File
  int series [ ] = {					      	  series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ]		    	series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ]		  "dump/transcoder_st/eval/java_python/online_st/206
    1 , 3 , 2 , - 1 , - 3 , - 2 }			      	  series_index = 0					    	series_index = 0					  68770/eval_scripts/java_sa-python_sa.test/REMAINDE
    ;							      	  result = 0						    	result = 0						  R_7_LARGE_NUMBERS.py", line 59, in <module>	  if
    int series_index = 0 ;				      	  for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) :	    	for digit in num [ : : - 1 ] :				   f_filled(*parameters_set) == f_gold(*parameters_s
    int result = 0 ;					      	      digit = ord ( num [ i ] ) - 48			    	    result += digit * series [ series_index ]		  et):	 File "dump/transcoder_st/eval/java_python/o
    for ( int i = num . length ( ) - 1 ;		      	      result += digit * series [ series_index ]		    	    series_index = ( series_index + 1 ) % 6		  nline_st/20668770/eval_scripts/java_sa-python_sa.t
    i >= 0 ;						      	      series_index = ( series_index + 1 ) % 6		    	    result %= 7						  est/REMAINDER_7_LARGE_NUMBERS.py", line 36, in f_f
    i -- ) {						      	      result %= 7					    	if result < 0 :						  illed	    result += digit * series [ series_index
      int digit = num . charAt ( i ) - '0' ;		      	  if ( result < 0 ) :					    	    result = ( result + 7 ) % 7				  ] TypeError: unsupported operand type(s) for +=: '
      result += digit * series [ series_index ] ;	      	      result = ( result + 7 ) % 7			    	return result						  int' and 'str'
      series_index = ( series_index + 1 ) % 6 ;		      	  return result						    								  
      result %= 7 ;					      								    								  
    }							      								    								  
    if ( result < 0 ) result = ( result + 7 ) % 7 ;	      								    								  
    return result ;					      								    								  
  }							      								    								  
  -							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PATH_SUM_TRIANGLE				      MAXIMUM_PATH_SUM_TRIANGLE					    MAXIMUM_PATH_SUM_TRIANGLE					  MAXIMUM_PATH_SUM_TRIANGLE
--							      --							    --								  --
static int maxPathSum ( int tri [ ] [ ] , int m , int n ) {   def maxPathSum ( tri , m , n ) :				    def maxPathSum ( tri , m , n ) :				  script_not_found : None
  for ( int i = m - 1 ;					      	  for i in range ( m - 1 , - 1 , - 1 ) :		    	for i in range ( m - 1 , - 1 , - 1 ) :			  
  i >= 0 ;						      	      for j in range ( i + 1 ) :			    	    for j in range ( 0 , i + 1 ) :			  
  i -- ) {						      		  if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1  		if tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ]  
    for ( int j = 0 ;					      		      tri [ i ] [ j ] += tri [ i + 1 ] [ j ]	    		    tri [ i ] [ j ] += tri [ i + 1 ] [ j ]	  
    j <= i ;						      		  else :					    		else :						  
    j ++ ) {						      		      tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ]    		    tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ]	  
      if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tr 	  return tri [ 0 ] [ 0 ]				    	return tri [ 0 ] [ 0 ]					  
      else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ;	      								    								  
    }							      								    								  
  }							      								    								  
  return tri [ 0 ] [ 0 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT	      GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT	    GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT	  GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT
--							      --							    --								  --
static void findSymPairs ( int arr [ ] [ ] ) {		      def findSymPairs ( arr , row ) :				    def find_sym_pairs ( arr ) :				  script_not_found : None
  HashMap < Integer , Integer > hM = new HashMap < Integer ,  	  hM = dict ( )						    	h_m = { }						  
  for ( int i = 0 ;					      	  for i in range ( row ) :				    	for first , sec in arr :				  
  i < arr . length ;					      	      first = arr [ i ] [ 0 ]				    	    val = h_m.get ( sec )				  
  i ++ ) {						      	      sec = arr [ i ] [ 1 ]				    	    if val and val == first :				  
    int first = arr [ i ] [ 0 ] ;			      	      if ( sec in hM.keys ( ) and hM [ sec ] == first ) :   		print ( "(%d, %d)" % ( sec , first ) )		  
    int sec = arr [ i ] [ 1 ] ;				      		  print ( "(" , sec , "," , first , ")" )	    	    else :						  
    Integer val = hM . get ( sec ) ;			      	      else :						    		h_m [ first ] = sec				  
    if ( val != null && val == first ) System . out . println 		  hM [ first ] = sec				    								  
    else hM . put ( first , sec ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY		      MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY			    MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY			  MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY
--							      --							    --								  --
static int findLongestConseqSubseq ( int arr [ ] , int n ) {  def findLongestConseqSubseq ( arr , n ) :			    def find_longest_conseq_substring ( arr , n ) :		  success : None
  HashSet < Integer > S = new HashSet < Integer > ( ) ;	      	  S = set ( )						    	S = set ( )						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      S.add ( arr [ i ] )				    	    S.add ( arr [ i ] )					  
  i ++ ) S . add ( arr [ i ] ) ;			      	  ans = 0						    	ans = 0							  
  int ans = 0 ;						      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      if S.__contains__ ( arr [ i ] ) :			    	    if arr [ i ] in S :					  
  i < n ;						      		  j = arr [ i ]					    		j = arr [ i ]					  
  i ++ ) {						      		  while ( S.__contains__ ( j ) ) :		    		while j in S :					  
    if ( S . contains ( arr [ i ] ) ) {			      		      j += 1					    		    j += 1					  
      int j = arr [ i ] ;				      		  ans = max ( ans , j - arr [ i ] )		    		ans = max ( ans , j - arr [ i ] )		  
      while ( S . contains ( j ) ) j ++ ;		      	  return ans						    	return ans						  
      ans = Math . max ( ans , j - arr [ i ] ) ;	      								    								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES	      COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES		    COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES		  COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES
--							      --							    --								  --
static int countOfSubstringWithKOnes ( String s , int K ) {   def countOfSubstringWithKOnes ( s , K ) :			    def count_of_substring_with_k_ones ( s , K ) :		  script_not_found : None
  int N = s . length ( ) ;				      	  N = len ( s )						    	N = len ( s )						  
  int res = 0 ;						      	  res = 0						    	res = 0							  
  int countOfOne = 0 ;					      	  countOfOne = 0					    	count_of_one = 0					  
  int [ ] freq = new int [ N + 1 ] ;			      	  freq = [ 0 for i in range ( N + 1 ) ]			    	freq = [ 0 ] * ( N + 1 )				  
  freq [ 0 ] = 1 ;					      	  freq [ 0 ] = 1					    	freq [ 0 ] = 1						  
  for ( int i = 0 ;					      	  for i in range ( 0 , N , 1 ) :			    	for c in s :						  
  i < N ;						      	      countOfOne += ord ( s [ i ] ) - ord ( '0' )	    	    count_of_one += ord ( c ) - ord ( '0' )		  
  i ++ ) {						      	      if ( countOfOne >= K ) :				    	    if count_of_one >= K :				  
    countOfOne += ( s . charAt ( i ) - '0' ) ;		      		  res += freq [ countOfOne - K ]		    		res += freq [ count_of_one - K ]		  
    if ( countOfOne >= K ) {				      	      freq [ countOfOne ] += 1				    	    freq [ count_of_one ] += 1				  
      res += freq [ countOfOne - K ] ;			      	  return res						    	return res						  
    }							      								    								  
    freq [ countOfOne ] ++ ;				      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STERN_BROCOT_SEQUENCE					      STERN_BROCOT_SEQUENCE					    STERN_BROCOT_SEQUENCE					  STERN_BROCOT_SEQUENCE
--							      --							    --								  --
static void SternSequenceFunc ( Vector < Integer > BrocotSequ def SternSequenceFunc ( BrocotSequence , n ) :		    def SternSequenceFunc ( BrocotSequence , n ) :		  script_not_found : None
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , len ( BrocotSequence ) , n ) :	  
  BrocotSequence . size ( ) < n ;			      	      considered_element = BrocotSequence [ i ]		    	    considered_element = BrocotSequence [ i ]		  
  i ++ ) {						      	      precedent = BrocotSequence [ i - 1 ]		    	    precedent = BrocotSequence [ i - 1 ]		  
    int considered_element = BrocotSequence . get ( i ) ;     	      BrocotSequence.append ( considered_element + preceden 	    BrocotSequence [ i ] = considered_element + precedent 
    int precedent = BrocotSequence . get ( i - 1 ) ;	      	      BrocotSequence.append ( considered_element )	    	    BrocotSequence [ i ] = considered_element		  
    BrocotSequence . add ( considered_element + precedent ) ; 	  for i in range ( 0 , 15 ) :				    	for i in range ( 15 ) :					  
    BrocotSequence . add ( considered_element ) ;	      	      print ( BrocotSequence [ i ] , end = " " )	    	    print ( BrocotSequence [ i ] , end = ' ' )		  
  }							      								    								  
  for ( int i = 0 ;					      								    								  
  i < 15 ;						      								    								  
  ++ i ) System . out . print ( BrocotSequence . get ( i ) +  								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS	      HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS	    HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS	  HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS
--							      --							    --								  --
static int findoptimal ( int N ) {			      def findoptimal ( N ) :					    def findoptimal ( N ) :					  success : None
  if ( N <= 6 ) return N ;				      	  if ( N <= 6 ) :					    	if N <= 6 :						  
  int [ ] screen = new int [ N ] ;			      	      return N						    	    return N						  
  int b ;						      	  screen = [ 0 ] * N					    	screen = [ 0 ] * N					  
  int n ;						      	  for n in range ( 1 , 7 ) :				    	for n in range ( 1 , 6 + 1 ) :				  
  for ( n = 1 ;						      	      screen [ n - 1 ] = n				    	    screen [ n - 1 ] = n				  
  n <= 6 ;						      	  for n in range ( 7 , N + 1 ) :			    	for n in range ( 7 , N + 1 ) :				  
  n ++ ) screen [ n - 1 ] = n ;				      	      screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 	    screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 
  for ( n = 7 ;						      	  return screen [ N - 1 ]				    	return screen [ N - 1 ]					  
  n <= N ;						      								    								  
  n ++ ) {						      								    								  
    screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Ma 								    								  
  }							      								    								  
  return screen [ N - 1 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1		      COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1			    COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1			  COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1
--							      --							    --								  --
public static int countPairs ( int arr [ ] , int n ) {	      def countPairs ( arr , n ) :				    def count_pairs ( arr , n ) :				  success : None
  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;    	  mp = dict ( )						    	hm = { }						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if arr [ i ] in mp.keys ( ) :			    	    if arr [ i ] in hm :				  
  i ++ ) {						      		  mp [ arr [ i ] ] += 1				    		hm [ arr [ i ] ] = hm [ arr [ i ] ] + 1		  
    if ( hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i  	      else :						    	    else :						  
    else hm . put ( arr [ i ] , 1 ) ;			      		  mp [ arr [ i ] ] = 1				    		hm [ arr [ i ] ] = 1				  
  }							      	  ans = 0						    	ans = 0							  
  int ans = 0 ;						      	  for it in mp :					    	for it , count in hm.items ( ) :			  
  for ( Map . Entry < Integer , Integer > it : hm . entrySet  	      count = mp [ it ]					    	    ans += ( count * ( count - 1 ) ) / 2		  
    int count = it . getValue ( ) ;			      	      ans += ( count * ( count - 1 ) ) // 2		    	return ans						  
    ans += ( count * ( count - 1 ) ) / 2 ;		      	  return ans						    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2	      FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2		    FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2		  FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2
--							      --							    --								  --
static void findElements ( int arr [ ] , int n ) {	      def findElements ( arr , n ) :				    def find_elements ( arr , n ) :				  script_not_found : None
  int first = Integer . MIN_VALUE ;			      	  first = - sys.maxsize					    	first = sys.maxsize					  
  int second = Integer . MAX_VALUE ;			      	  second = - sys.maxsize				    	second = sys.maxsize					  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( arr [ i ] > first ) :			    	    if arr [ i ] > first :				  
  i ++ ) {						      		  second = first				    		second = first					  
    if ( arr [ i ] > first ) {				      		  first = arr [ i ]				    		first = arr [ i ]				  
      second = first ;					      	      elif ( arr [ i ] > second ) :			    	    elif arr [ i ] > second :				  
      first = arr [ i ] ;				      		  second = arr [ i ]				    		second = arr [ i ]				  
    }							      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
    else if ( arr [ i ] > second ) second = arr [ i ] ;	      	      if ( arr [ i ] < second ) :			    	    if arr [ i ] < second :				  
  }							      		  print ( arr [ i ] , end = " " )		    		print ( arr [ i ] , end = ' ' )			  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) if ( arr [ i ] < second ) System . out . print ( arr 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3		      NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3		    NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3		  NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3
--							      --							    --								  --
static int divisible ( String num ) {			      def divisible ( num ) :					    def divisible ( num ) :					  script_not_found : None
  int n = num . length ( ) ;				      	  n = len ( num )					    	n = len ( num )						  
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for c in num :						  
  i < n ;						      	      sum += int ( num [ i ] )				    	    sum += ord ( c )					  
  i ++ ) sum += ( int ) ( num . charAt ( i ) ) ;	      	  if ( sum % 3 == 0 ) :					    	if sum % 3 == 0 :					  
  if ( sum % 3 == 0 ) return 0 ;			      	      return 0						    	    return 0						  
  if ( n == 1 ) return - 1 ;				      	  if ( n == 1 ) :					    	if n == 1 :						  
  for ( int i = 0 ;					      	      return - 1					    	    return - 1						  
  i < n ;						      	  for i in range ( n ) :				    	for c in num :						  
  i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) r 	      if ( sum % 3 == int ( num [ i ] ) % 3 ) :		    	    if sum % 3 == ( ord ( c ) - ord ( '0' ) ) % 3 :	  
  if ( n == 2 ) return - 1 ;				      		  return 1					    		return 1					  
  return 2 ;						      	  if ( n == 2 ) :					    	if n == 2 :						  
}							      	      return - 1					    	    return - 1						  
							      	  return 2						    	return 2						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES	      COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES	    COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES	  COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES
--							      --							    --								  --
int countwalks ( int graph [ ] [ ] , int u , int v , int k )  def countwalks ( graph , u , v , k ) :			    def countwalks ( graph , u , v , k ) :			  script_not_found : None
  if ( k == 0 && u == v ) return 1 ;			      	  if ( k == 0 and u == v ) :				    	if k == 0 and u == v :					  
  if ( k == 1 && graph [ u ] [ v ] == 1 ) return 1 ;	      	      return 1						    	    return 1						  
  if ( k <= 0 ) return 0 ;				      	  if ( k == 1 and graph [ u ] [ v ] ) :			    	if k == 1 and graph [ u ] [ v ] == 1 :			  
  int count = 0 ;					      	      return 1						    	    return 1						  
  for ( int i = 0 ;					      	  if ( k <= 0 ) :					    	if k <= 0 :						  
  i < V ;						      	      return 0						    	    return 0						  
  i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks (  	  count = 0						    	count = 0						  
  return count ;					      	  for i in range ( 0 , V ) :				    	for i in range ( V ) :					  
}							      	      if ( graph [ u ] [ i ] == 1 ) :			    	    if graph [ u ] [ i ] == 1 :				  
							      		  count += countwalks ( graph , i , v , k - 1 )	    		count += countwalks ( graph , i , v , k - 1 )	  
							      	  return count						    	return count						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_BRACKET_NUMBER					      PRINT_BRACKET_NUMBER					    PRINT_BRACKET_NUMBER					  PRINT_BRACKET_NUMBER
--							      --							    --								  --
static void printBracketNumber ( String exp , int n ) {	      def printBracketNumber ( exp , n ) :			    def print_bracket_number ( exp , n ) :			  script_not_found : None
  int left_bnum = 1 ;					      	  left_bnum = 1						    	left_bnum = 1						  
  Stack < Integer > right_bnum = new Stack < Integer > ( ) ;  	  right_bnum = list ( )					    	right_bnum = [ ]					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if exp [ i ] == '(' :				    	    if exp [ i ] == '(' :				  
  i ++ ) {						      		  print ( left_bnum , end = " " )		    		print ( left_bnum , end = ' ' )			  
    if ( exp . charAt ( i ) == '(' ) {			      		  right_bnum.append ( left_bnum )		    		right_bnum.append ( left_bnum )			  
      System . out . print ( left_bnum + " " ) ;	      		  left_bnum += 1				    		left_bnum += 1					  
      right_bnum . push ( left_bnum ) ;			      	      elif exp [ i ] == ')' :				    	    elif exp [ i ] == ')' :				  
      left_bnum ++ ;					      		  print ( right_bnum [ - 1 ] , end = " " )	    		print ( right_bnum [ - 1 ] , end = ' ' )	  
    }							      		  right_bnum.pop ( )				    		right_bnum.pop ( )				  
    else if ( exp . charAt ( i ) == ')' ) {		      								    								  
      System . out . print ( right_bnum . peek ( ) + " " ) ;  								    								  
      right_bnum . pop ( ) ;				      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS		      PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS			    PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS			  PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS
--							      --							    --								  --
public static void amendSentence ( String sstr ) {	      def amendSentence ( string ) :				    def amend_sentence ( sstr ) :				  script_not_found : None
  char [ ] str = sstr . toCharArray ( ) ;		      	  string = list ( string )				    	data = list ( sstr )					  
  for ( int i = 0 ;					      	  for i in range ( len ( string ) ) :			    	for i in range ( len ( data ) ) :			  
  i < str . length ;					      	      if string [ i ] >= 'A' and string [ i ] <= 'Z' :	    	    if data [ i ] >= 'A' and data [ i ] <= 'Z' :	  
  i ++ ) {						      		  string [ i ] = chr ( ord ( string [ i ] ) + 32 )  		data [ i ] = chr ( ord ( data [ i ] ) + 32 )	  
    if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {	      		  if i != 0 :					    		if i != 0 :					  
      str [ i ] = ( char ) ( str [ i ] + 32 ) ;		      		      print ( "" , end = "" )			    		    print ( ' ' , end = ' ' )			  
      if ( i != 0 ) System . out . print ( " " ) ;	      		  print ( string [ i ] , end = "" )		    		print ( data [ i ] , end = ' ' )		  
      System . out . print ( str [ i ] ) ;		      	      else :						    	    else :						  
    }							      		  print ( string [ i ] , end = "" )		    		print ( data [ i ] , end = ' ' )		  
    else System . out . print ( str [ i ] ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM		      DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM		    DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM		  DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM
--							      --							    --								  --
static int knapSack ( int W , int wt [ ] , int val [ ] , int  def knapSack ( W , wt , val , n ) :			    def knapSack ( W , wt , val , n ) :				  script_not_found : None
  if ( n == 0 || W == 0 ) return 0 ;			      	  if n == 0 or W == 0 :					    	if n == 0 or W == 0 :					  
  if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n  	      return 0						    	    return 0						  
  else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 	  if ( wt [ n - 1 ] > W ) :				    	if wt [ n - 1 ] > W :					  
}							      	      return knapSack ( W , wt , val , n - 1 )		    	    return knapSack ( W , wt , val , n - 1 )		  
							      	  else :						    	else :							  
							      	      return max ( val [ n - 1 ] + knapSack ( W - wt [ n -  	    return max ( val [ n - 1 ] + knapSack ( W - wt [ n -  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND			      CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND			    CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND			  CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND
--							      --							    --								  --
static int calcAngle ( double h , double m ) {		      def calcAngle ( h , m ) :					    def calc_angle ( h , m ) :					  failure : Wrong input Wrong input Wrong input Wron
  if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . pr 	  if ( h < 0 or m < 0 or h > 12 or m > 60 ) :		    	if h < 0 or m < 0 or h > 12 or m > 60 :			  g input Wrong input Wrong input Wrong input Wrong
  if ( h == 12 ) h = 0 ;				      	      print ( 'Wrong input' )				    	    print ( "Wrong input" )				  input Wrong input Wrong input Wrong input Wrong in
  if ( m == 60 ) m = 0 ;				      	  if ( h == 12 ) :					    	if h == 12 :						  put Wrong input Wrong input Wrong input Wrong inpu
  int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ;	      	      h = 0						    	    h = 0						  t Wrong input Wrong input Wrong input Wrong input
  int minute_angle = ( int ) ( 6 * m ) ;		      	  if ( m == 60 ) :					    	if m == 60 :						  #Results: 0, 10
  int angle = Math . abs ( hour_angle - minute_angle ) ;      	      m = 0						    	    m = 0						  
  angle = Math . min ( 360 - angle , angle ) ;		      	  hour_angle = 0.5 * ( h * 60 + m )			    	hour_angle = int ( 0.5 * ( h * 60 + m ) )		  
  return angle ;					      	  minute_angle = 6 * m					    	minute_angle = int ( 6 * m )				  
}							      	  angle = abs ( hour_angle - minute_angle )		    	angle = abs ( hour_angle - minute_angle )		  
							      	  angle = min ( 360 - angle , angle )			    	angle = min ( 360 - angle , angle )			  
							      	  return angle						    	return angle						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_SPECIFIC_PAIR_IN_MATRIX				      FIND_A_SPECIFIC_PAIR_IN_MATRIX				    FIND_A_SPECIFIC_PAIR_IN_MATRIX				  FIND_A_SPECIFIC_PAIR_IN_MATRIX
--							      --							    --								  --
static int findMaxValue ( int N , int mat [ ] [ ] ) {	      def findMaxValue ( mat ) :				    def find_max_value ( N , mat ) :				  script_not_found : None
  int maxValue = Integer . MIN_VALUE ;			      	  maxValue = 0						    	max_value = 0						  
  for ( int a = 0 ;					      	  for a in range ( N - 1 ) :				    	for a in range ( N - 1 ) :				  
  a < N - 1 ;						      	      for b in range ( N - 1 ) :			    	    for b in range ( N - 1 ) :				  
  a ++ ) for ( int b = 0 ;				      		  for d in range ( a + 1 , N ) :		    		for d in range ( a + 1 , N ) :			  
  b < N - 1 ;						      		      for e in range ( b + 1 , N ) :		    		    for e in range ( b + 1 , N ) :		  
  b ++ ) for ( int d = a + 1 ;				      			  if maxValue < int ( mat [ d ] [ e ] - mat 			if max_value < ( mat [ d ] [ e ] - mat [  
  d < N ;						      			      maxValue = int ( mat [ d ] [ e ] - ma 			    max_value = mat [ d ] [ e ] - mat [ a 
  d ++ ) for ( int e = b + 1 ;				      	  return maxValue ;					    	return max_value					  
  e < N ;						      								    								  
  e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ]  								    								  
  return maxValue ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HARDY_RAMANUJAN_THEOREM					      HARDY_RAMANUJAN_THEOREM					    HARDY_RAMANUJAN_THEOREM					  HARDY_RAMANUJAN_THEOREM
--							      --							    --								  --
static int exactPrimeFactorCount ( int n ) {		      def exactPrimeFactorCount ( n ) :				    def exact_prime_factor_count ( n ) :			  error : Traceback (most recent call last):   File
  int count = 0 ;					      	  count = 0						    	count = 0						  "dump/transcoder_st/eval/java_python/online_st/206
  if ( n % 2 == 0 ) {					      	  if ( n % 2 == 0 ) :					    	if n % 2 == 0 :						  68770/eval_scripts/java_sa-python_sa.test/HARDY_RA
    count ++ ;						      	      count = count + 1					    	    count += 1						  MANUJAN_THEOREM.py", line 68, in <module>	if f
    while ( n % 2 == 0 ) n = n / 2 ;			      	      while ( n % 2 == 0 ) :				    	    while n % 2 == 0 :					  _filled(*parameters_set) == f_gold(*parameters_set
  }							      		  n = int ( n / 2 )				    		n = n // 2					  ):   File "dump/transcoder_st/eval/java_python/onl
  for ( int i = 3 ;					      	  i = 3							    	for i in range ( 3 , math.sqrt ( n ) + 1 , 2 ) :	  ine_st/20668770/eval_scripts/java_sa-python_sa.tes
  i <= Math . sqrt ( n ) ;				      	  while ( i <= int ( math.sqrt ( n ) ) ) :		    	    if n % i == 0 :					  t/HARDY_RAMANUJAN_THEOREM.py", line 43, in f_fille
  i = i + 2 ) {						      	      if ( n % i == 0 ) :				    		count += 1					  d	for i in range ( 3 , math.sqrt ( n ) + 1 , 2
    if ( n % i == 0 ) {					      		  count = count + 1				    		while n % i == 0 :				   ) : TypeError: 'float' object cannot be interpret
      count ++ ;					      		  while ( n % i == 0 ) :			    		    n = n // i					  ed as an integer
      while ( n % i == 0 ) n = n / i ;			      		      n = int ( n / i )				    	if n > 2 :						  
    }							      	      i = i + 2						    	    count += 1						  
  }							      	  if ( n > 2 ) :					    	return count						  
  if ( n > 2 ) count ++ ;				      	      count = count + 1					    								  
  return count ;					      	  return count						    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_REVERSE_STRING_REMOVING_VOWELS			      PRINT_REVERSE_STRING_REMOVING_VOWELS			    PRINT_REVERSE_STRING_REMOVING_VOWELS			  PRINT_REVERSE_STRING_REMOVING_VOWELS
--							      --							    --								  --
static void replaceOriginal ( String s , int n ) {	      def replaceOriginal ( s , n ) :				    def replace_original ( s , n ) :				  script_not_found : None
  char r [ ] = new char [ n ] ;				      	  r = [ ' ' ] * n					    	r = [ ]							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      r [ i ] = s [ n - 1 - i ]				    	    r.append ( s [ n - 1 - i ] )			  
  i ++ ) {						      	      if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 	    if s [ i ] not in " a " and s [ i ] not in " e " and  
    r [ i ] = s . charAt ( n - 1 - i ) ;		      		  print ( r [ i ] , end = "" )			    		print ( r , end = "" )				  
    if ( s . charAt ( i ) != 'a' && s . charAt ( i ) != 'e' & 	  print ( )						    	print ( "" )						  
      System . out . print ( r [ i ] ) ;		      								    								  
    }							      								    								  
  }							      								    								  
  System . out . println ( "" ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PANGRAM_CHECKING					      PANGRAM_CHECKING						    PANGRAM_CHECKING						  PANGRAM_CHECKING
--							      --							    --								  --
public static boolean checkPangram ( String str ) {	      def checkPangram ( s ) :					    def check_pangram ( data ) :				  script_not_found : None
  boolean [ ] mark = new boolean [ 26 ] ;		      	  List = [ ]						    	mark = [ False ] * 26					  
  int index = 0 ;					      	  for i in range ( 26 ) :				    	index = 0						  
  for ( int i = 0 ;					      	      List.append ( False )				    	for c in data :						  
  i < str . length ( ) ;				      	  for c in s.lower ( ) :				    	    if 'A' <= c <= 'Z' :				  
  i ++ ) {						      	      if not c == " " :					    		index = ord ( c ) - ord ( 'A' )			  
    if ( 'A' <= str . charAt ( i ) && str . charAt ( i ) <= ' 		  List [ ord ( c ) - ord ( 'a' ) ] = True	    	    elif 'a' <= c <= 'z' :				  
    else if ( 'a' <= str . charAt ( i ) && str . charAt ( i ) 	  for ch in List :					    		index = ord ( c ) - ord ( 'a' )			  
    mark [ index ] = true ;				      	      if ch == False :					    	    mark [ index ] = True				  
  }							      		  return False					    	for i in range ( 0 , 25 ) :				  
  for ( int i = 0 ;					      	  return True						    	    if mark [ i ] == False :				  
  i <= 25 ;						      								    		return ( False )				  
  i ++ ) if ( mark [ i ] == false ) return ( false ) ;	      								    	return ( True )						  
  return ( true ) ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT		      MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT		    MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT		  MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT
--							      --							    --								  --
public static int maxSum ( int grid [ ] [ ] , int n ) {	      def maxSum ( grid , n ) :					    def max_sum ( grid , n ) :					  success : None
  int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] 	  incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] )	    	incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] )	  
  int excl = 0 , excl_new ;				      	  excl = 0						    	excl , excl_new = 0 , 0					  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i < n ;						      	      excl_new = max ( excl , incl )			    	    excl_new = max ( excl , incl )			  
  i ++ ) {						      	      incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i 	    incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i 
    excl_new = Math . max ( excl , incl ) ;		      	      excl = excl_new					    	    excl = excl_new					  
    incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ]  	  return max ( excl , incl )				    	return max ( excl , incl )				  
    excl = excl_new ;					      								    								  
  }							      								    								  
  return Math . max ( excl , incl ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N		      PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N		    PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N		  PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N
--							      --							    --								  --
static void findConsecutive ( int N ) {			      def findConsecutive ( N ) :				    def find_consecutive ( N ) :				  script_not_found : None
  int start = 1 ;					      	  start = 1						    	start = 1						  
  int end = ( N + 1 ) / 2 ;				      	  end = ( N + 1 ) // 2					    	end = ( N + 1 ) // 2					  
  while ( start < end ) {				      	  while ( start < end ) :				    	while start < end :					  
    int sum = 0 ;					      	      Sum = 0						    	    sum = 0						  
    for ( int i = start ;				      	      for i in range ( start , end + 1 ) :		    	    for i in range ( start , end + 1 ) :		  
    i <= end ;						      		  Sum = Sum + i					    		sum = sum + i					  
    i ++ ) {						      		  if ( Sum == N ) :				    		if sum == N :					  
      sum = sum + i ;					      		      for j in range ( start , i + 1 ) :	    		    for j in range ( start , i + 1 ) :		  
      if ( sum == N ) {					      			  print ( j , end = " " )		    			print ( j , end = ' ' )			  
	for ( int j = start ;				      		      print ( )					    		    print ( )					  
	j <= i ;					      		      break					    		    break					  
	j ++ ) System . out . print ( j + " " ) ;	      		  if ( Sum > N ) :				    		if sum > N :					  
	System . out . println ( ) ;			      		      break					    		    break					  
	break ;						      	      Sum = 0						    	    sum = 0						  
      }							      	      start += 1					    	    start += 1						  
      if ( sum > N ) break ;				      								    								  
    }							      								    								  
    sum = 0 ;						      								    								  
    start ++ ;						      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY	      MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY	    MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY	  MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY
--							      --							    --								  --
static int minJumps ( int arr [ ] , int l , int h ) {	      def minJumps ( arr , l , h ) :				    def min_jumps ( arr , l , h ) :				  script_not_found : None
  if ( h == l ) return 0 ;				      	  if ( h == l ) :					    	if h == l :						  
  if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ;	      	      return 0						    	    return 0						  
  int min = Integer . MAX_VALUE ;			      	  if ( arr [ l ] == 0 ) :				    	if not arr [ l ] :					  
  for ( int i = l + 1 ;					      	      return float ( 'inf' )				    	    return sys.maxsize					  
  i <= h && i <= l + arr [ l ] ;			      	  min = float ( 'inf' )					    	min = sys.maxsize					  
  i ++ ) {						      	  for i in range ( l + 1 , h + 1 ) :			    	for i in range ( l + 1 , h + 1 ) :			  
    int jumps = minJumps ( arr , i , h ) ;		      	      if ( i < l + arr [ l ] + 1 ) :			    	    jumps = min_jumps ( arr , i , h )			  
    if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) mi 		  jumps = minJumps ( arr , i , h )		    	    if jumps != sys.maxsize and jumps + 1 < min :	  
  }							      		  if ( jumps != float ( 'inf' ) and jumps + 1 < min 		min = jumps + 1					  
  return min ;						      		      min = jumps + 1				    	return min						  
}							      	  return min						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FITTING_SHELVES_PROBLEM					      FITTING_SHELVES_PROBLEM					    FITTING_SHELVES_PROBLEM					  FITTING_SHELVES_PROBLEM
--							      --							    --								  --
static void minSpacePreferLarge ( int wall , int m , int n )  def minSpacePreferLarge ( w , m , n ) :			    def min_space_prefers_large ( wall , m , n ) :		  script_not_found : None
  int num_m = 0 , num_n = 0 , min_empty = wall ;	      	  num_m = 0						    	num_m , num_n , min_empty = 0 , 0 , 0 , wall		  
  int p = 0 , q = 0 , rem ;				      	  num_n = 0						    	p , q , rem = 0 , 0 , 0 , 0				  
  while ( wall >= n ) {					      	  rem = w						    	while wall >= n :					  
    p = wall / m ;					      	  p = 0							    	    p = wall // m					  
    rem = wall % m ;					      	  q = 0							    	    rem = wall % m					  
    if ( rem <= min_empty ) {				      	  r = 0							    	    if rem <= min_empty :				  
      num_m = p ;					      	  while ( w >= n ) :					    		num_m = p					  
      num_n = q ;					      	      p = w / m						    		num_n = q					  
      min_empty = rem ;					      	      r = w % m						    		min_empty = rem					  
    }							      	      if ( r <= rem ) :					    	    q += 1						  
    q += 1 ;						      		  num_m = p					    	    wall = wall - n					  
    wall = wall - n ;					      		  num_n = q					    	print ( num_m , num_n , min_empty )			  
  }							      		  rem = r					    								  
  System . out . println ( num_m + " " + num_n + " " + min_em 	      q += 1						    								  
}							      	      w -= n						    								  
							      	  print ( str ( int ( num_m ) ) + " " + str ( num_n ) + " " 								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SIZE_SUBARRAY_MAXIMUM_SUM				      SIZE_SUBARRAY_MAXIMUM_SUM					    SIZE_SUBARRAY_MAXIMUM_SUM					  SIZE_SUBARRAY_MAXIMUM_SUM
--							      --							    --								  --
static int maxSubArraySum ( int a [ ] , int size ) {	      def maxSubArraySum ( a , size ) :				    def max_sub_array_sum ( a , size ) :			  script_not_found : None
  int max_so_far = Integer . MIN_VALUE , max_ending_here = 0  	  max_so_far = - maxsize - 1				    	max_so_far , max_ending_here , start , end , s = 0 , 0 ,  
  for ( int i = 0 ;					      	  max_ending_here = 0					    	for i in range ( size ) :				  
  i < size ;						      	  start = 0						    	    max_ending_here += a [ i ]				  
  i ++ ) {						      	  end = 0						    	    if max_so_far < max_ending_here :			  
    max_ending_here += a [ i ] ;			      	  s = 0							    		max_so_far = max_ending_here			  
    if ( max_so_far < max_ending_here ) {		      	  for i in range ( 0 , size ) :				    		start , end = s , i				  
      max_so_far = max_ending_here ;			      	      max_ending_here += a [ i ]			    	    if max_ending_here < 0 :				  
      start = s ;					      	      if max_so_far < max_ending_here :			    		max_ending_here = 0				  
      end = i ;						      		  max_so_far = max_ending_here			    		s = i + 1					  
    }							      		  start = s					    	return ( end - start + 1 )				  
    if ( max_ending_here < 0 ) {			      		  end = i					    								  
      max_ending_here = 0 ;				      	      if max_ending_here < 0 :				    								  
      s = i + 1 ;					      		  max_ending_here = 0				    								  
    }							      		  s = i + 1					    								  
  }							      	  return ( end - start + 1 )				    								  
  return ( end - start + 1 ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING	      SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING	    SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING		  SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING
--							      --							    --								  --
static void sortByPattern ( char [ ] str , char [ ] pat ) {   def sortByPattern ( str , pat ) :				    def sort_by_pattern ( str , pat ) :				  script_not_found : None
  int count [ ] = new int [ MAX_CHAR ] ;		      	  global MAX_CHAR					    	count = [ 0 ] * MAX_CHAR				  
  for ( int i = 0 ;					      	  count = [ 0 ] * MAX_CHAR				    	for c in str :						  
  i < str . length ;					      	  for i in range ( 0 , len ( str ) ) :			    	    count [ ord ( c ) - ord ( 'a' ) ] += 1		  
  i ++ ) {						      	      count [ ord ( str [ i ] ) - 97 ] += 1		    	index = 0						  
    count [ str [ i ] - 'a' ] ++ ;			      	  index = 0						    	for c in pat :						  
  }							      	  str = ""						    	    for i in range ( count [ ord ( c ) - ord ( 'a' ) ] )  
  int index = 0 ;					      	  for i in range ( 0 , len ( pat ) ) :			    		str [ index ] = c				  
  for ( int i = 0 ;					      	      j = 0						    		index += 1					  
  i < pat . length ;					      	      while ( j < count [ ord ( pat [ i ] ) - ord ( 'a' ) ] 								  
  i ++ ) {						      		  str += pat [ i ]				    								  
    for ( int j = 0 ;					      		  j = j + 1					    								  
    j < count [ pat [ i ] - 'a' ] ;			      		  index += 1					    								  
    j ++ ) {						      	  return str						    								  
      str [ index ++ ] = pat [ i ] ;			      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY	      FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY	    FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY	  FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY
--							      --							    --								  --
static void findPair ( int [ ] arr , int n ) {		      def findPair ( arr , n ) :				    def find_pair ( arr , n ) :					  script_not_found : None
  boolean found = false ;				      	  found = False						    	found = False						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) {						      		  for k in range ( 0 , n ) :			    		for k in range ( n ) :				  
    for ( int j = i + 1 ;				      		      if ( arr [ i ] + arr [ j ] == arr [ k ] ) :   		    if arr [ i ] + arr [ j ] == arr [ k ] :	  
    j < n ;						      			  print ( arr [ i ] , arr [ j ] )	    			print ( arr [ i ] , arr [ j ] )		  
    j ++ ) {						      			  found = True				    			found = True				  
      for ( int k = 0 ;					      	  if ( found == False ) :				    	if found == False :					  
      k < n ;						      	      print ( "Not exist" )				    	    print ( "Not exist" )				  
      k ++ ) {						      								    								  
	if ( arr [ i ] + arr [ j ] == arr [ k ] ) {	      								    								  
	  System . out . println ( arr [ i ] + " " + arr [ j  								    								  
	  found = true ;				      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  if ( found == false ) System . out . println ( "Not exist"  								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_1_N_SWAPPING_ADJACENT_ELEMENTS			      SORT_1_N_SWAPPING_ADJACENT_ELEMENTS			    SORT_1_N_SWAPPING_ADJACENT_ELEMENTS				  SORT_1_N_SWAPPING_ADJACENT_ELEMENTS
--							      --							    --								  --
static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] ,  def sortedAfterSwap ( A , B , n ) :			    def sorted_after_swap ( A , B , n ) :			  script_not_found : None
  int i , j ;						      	  for i in range ( 0 , n - 1 ) :			    	i , j = 0 , 0						  
  for ( i = 0 ;						      	      if ( B [ i ] == 1 ) :				    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      		  j = i						    	    if B [ i ] :					  
  i ++ ) {						      		  while ( B [ j ] == 1 ) :			    		j = i						  
    if ( B [ i ] ) {					      		      j = j + 1					    		while B [ j ] :					  
      j = i ;						      		  A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A  		    j += 1					  
      while ( B [ j ] ) {				      		  i = j						    		A [ i : i + 1 + j ] = B [ i : j + 1 ]		  
	j ++ ;						      	  for i in range ( 0 , n ) :				    		i = j						  
      }							      	      if ( A [ i ] != i + 1 ) :				    	for i in range ( n ) :					  
      Arrays . sort ( A , i , 1 + j ) ;			      		  return False					    	    if A [ i ] != i + 1 :				  
      i = j ;						      	  return True						    		return False					  
    }							      								    	return True						  
  }							      								    								  
  for ( i = 0 ;						      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    if ( A [ i ] != i + 1 ) {				      								    								  
      return false ;					      								    								  
    }							      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_ LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_ LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_ LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_
--							      --							    --								  --
static void longestSubseqWithK ( String str , int k ) {	      def longestSubseqWithK ( str , k ) :			    def longest_subseq_with_k ( str , k ) :			  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  int freq [ ] = new int [ MAX_CHARS ] ;		      	  freq = [ 0 ] * MAX_CHARS				    	freq = np.zeros ( MAX_CHARS )				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for c in str :						  
  i < n ;						      	      freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1	    	    freq [ ord ( c ) - ord ( 'a' ) ] += 1		  
  i ++ ) {						      	  for i in range ( n ) :				    	for c in str :						  
    freq [ str . charAt ( i ) - 'a' ] ++ ;		      	      if ( freq [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k )  	    if freq [ ord ( c ) - ord ( 'a' ) ] >= k :		  
  }							      		  print ( str [ i ] , end = "" )		    		print ( c , end = ' ' )				  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    if ( freq [ str . charAt ( i ) - 'a' ] >= k ) {	      								    								  
      System . out . print ( str . charAt ( i ) ) ;	      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE	      FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE	    FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE	  FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE
--							      --							    --								  --
static int findMinNumber ( int n ) {			      def findMinNumber ( n ) :					    def find_min_number ( n ) :					  error : Traceback (most recent call last):   File
  int count = 0 , ans = 1 ;				      	  count = 0						    	count , ans = 0 , 1					  "dump/transcoder_st/eval/java_python/online_st/206
  while ( n % 2 == 0 ) {				      	  ans = 1						    	while n % 2 == 0 :					  68770/eval_scripts/java_sa-python_sa.test/FIND_MIN
    count ++ ;						      	  while n % 2 == 0 :					    	    count += 1						  IMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE.py"
    n /= 2 ;						      	      count += 1					    	    n //= 2						  , line 73, in <module>     if f_filled(*parameters
  }							      	      n //= 2						    	if count % 2 == 1 :					  _set) == f_gold(*parameters_set):   File "dump/tra
  if ( count % 2 == 1 ) ans *= 2 ;			      	  if count % 2 is not 0 :				    	    ans *= 2						  nscoder_st/eval/java_python/online_st/20668770/eva
  for ( int i = 3 ;					      	      ans *= 2						    	for i in range ( 3 , math.sqrt ( n ) + 1 , 2 ) :	  l_scripts/java_sa-python_sa.test/FIND_MINIMUM_NUMB
  i <= Math . sqrt ( n ) ;				      	  for i in range ( 3 , ( int ) ( math.sqrt ( n ) ) + 1 , 2  	    count = 0						  ER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE.py", line 46
  i += 2 ) {						      	      count = 0						    	    while n % i == 0 :					  , in f_filled	    for i in range ( 3 , math.sqrt (
    count = 0 ;						      	      while n % i == 0 :				    		count += 1					   n ) + 1 , 2 ) : TypeError: 'float' object cannot
    while ( n % i == 0 ) {				      		  count += 1					    		n //= i						  be interpreted as an integer
      count ++ ;					      		  n //= i					    	    if count % 2 == 1 :					  
      n /= i ;						      	      if count % 2 is not 0 :				    		ans *= i					  
    }							      		  ans *= i					    	if n > 2 :						  
    if ( count % 2 == 1 ) ans *= i ;			      	  if n > 2 :						    	    ans *= n						  
  }							      	      ans *= n						    	return ans						  
  if ( n > 2 ) ans *= n ;				      	  return ans						    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU
--							      --							    --								  --
static int returnMaxSum ( int A [ ] , int B [ ] , int n ) {   def returnMaxSum ( A , B , n ) :				    def return_max_sum ( A , B , n ) :				  success : None
  Set < Integer > mp = new HashSet < Integer > ( ) ;	      	  mp = set ( )						    	mp = set ( )						  
  int result = 0 ;					      	  result = 0						    	result = 0						  
  int curr_sum = 0 , curr_begin = 0 ;			      	  curr_sum = curr_begin = 0				    	curr_sum , curr_begin = 0 , 0				  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      while A [ i ] in mp :				    	    while A [ i ] in mp :				  
  ++ i ) {						      		  mp.remove ( A [ curr_begin ] )		    		mp.remove ( A [ curr_begin ] )			  
    while ( mp . contains ( A [ i ] ) ) {		      		  curr_sum -= B [ curr_begin ]			    		curr_sum -= B [ curr_begin ]			  
      mp . remove ( A [ curr_begin ] ) ;		      		  curr_begin += 1				    		curr_begin += 1					  
      curr_sum -= B [ curr_begin ] ;			      	      mp.add ( A [ i ] )				    	    mp.add ( A [ i ] )					  
      curr_begin ++ ;					      	      curr_sum += B [ i ]				    	    curr_sum += B [ i ]					  
    }							      	      result = max ( result , curr_sum )		    	    result = max ( result , curr_sum )			  
    mp . add ( A [ i ] ) ;				      	  return result						    	return result						  
    curr_sum += B [ i ] ;				      								    								  
    result = Integer . max ( result , curr_sum ) ;	      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1	      COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1		    COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1		  COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1
--							      --							    --								  --
int getInvCount ( int arr [ ] , int n ) {		      def getInvCount ( arr , n ) :				    def get_inv_count ( arr , n ) :				  success : None
  int invcount = 0 ;					      	  invcount = 0						    	invcount = 0						  
  for ( int i = 0 ;					      	  for i in range ( 1 , n - 1 ) :			    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      small = 0						    	    small = 0						  
  i ++ ) {						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
    int small = 0 ;					      		  if ( arr [ i ] > arr [ j ] ) :		    		if arr [ i ] > arr [ j ] :			  
    for ( int j = i + 1 ;				      		      small += 1				    		    small += 1					  
    j < n ;						      	      great = 0						    	    great = 0						  
    j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ;	      	      for j in range ( i - 1 , - 1 , - 1 ) :		    	    for j in range ( i - 1 , - 1 , - 1 ) :		  
    int great = 0 ;					      		  if ( arr [ i ] < arr [ j ] ) :		    		if arr [ i ] < arr [ j ] :			  
    for ( int j = i - 1 ;				      		      great += 1				    		    great += 1					  
    j >= 0 ;						      	      invcount += great * small				    	    invcount += great * small				  
    j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ;	      	  return invcount					    	return invcount						  
    invcount += great * small ;				      								    								  
  }							      								    								  
  return invcount ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1	      PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1	    PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1	  PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1
--							      --							    --								  --
static boolean isProduct ( int arr [ ] , int n , int x ) {    def isProduct ( arr , n , x ) :				    def is_product ( arr , n , x ) :				  success : None
  HashSet < Integer > hset = new HashSet < > ( ) ;	      	  if n < 2 :						    	hset = set ( )						  
  if ( n < 2 ) return false ;				      	      return False					    	if n < 2 :						  
  for ( int i = 0 ;					      	  s = set ( )						    	    return False					  
  i < n ;						      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i ++ ) {						      	      if arr [ i ] == 0 :				    	    if not arr [ i ] :					  
    if ( arr [ i ] == 0 ) {				      		  if x == 0 :					    		if not x :					  
      if ( x == 0 ) return true ;			      		      return True				    		    return True					  
      else continue ;					      		  else :					    		else :						  
    }							      		      continue					    		    continue					  
    if ( x % arr [ i ] == 0 ) {				      	      if x % arr [ i ] == 0 :				    	    if x % arr [ i ] == 0 :				  
      if ( hset . contains ( x / arr [ i ] ) ) return true ;  		  if x // arr [ i ] in s :			    		if x // arr [ i ] in hset :			  
      hset . add ( arr [ i ] ) ;			      		      return True				    		    return True					  
    }							      		  s.add ( arr [ i ] )				    		hset.add ( arr [ i ] )				  
  }							      	  return False						    	return False						  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1		      FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1		    FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1			  FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1
--							      --							    --								  --
static int findMaxAverage ( int arr [ ] , int n , int k ) {   def findMaxAverage ( arr , n , k ) :			    def find_max_average ( arr , n , k ) :			  success : None
  if ( k > n ) return - 1 ;				      	  if ( k > n ) :					    	if k > n :						  
  int sum = arr [ 0 ] ;					      	      return - 1					    	    return - 1						  
  for ( int i = 1 ;					      	  sum = arr [ 0 ]					    	sum = arr [ 0 ]						  
  i < k ;						      	  for i in range ( 1 , k ) :				    	for i in range ( 1 , k ) :				  
  i ++ ) sum += arr [ i ] ;				      	      sum += arr [ i ]					    	    sum += arr [ i ]					  
  int max_sum = sum , max_end = k - 1 ;			      	  max_sum = sum						    	max_sum , max_end = sum , k - 1				  
  for ( int i = k ;					      	  max_end = k - 1					    	for i in range ( k , n ) :				  
  i < n ;						      	  for i in range ( k , n ) :				    	    sum = sum + arr [ i ] - arr [ i - k ]		  
  i ++ ) {						      	      sum = sum + arr [ i ] - arr [ i - k ]		    	    if sum > max_sum :					  
    sum = sum + arr [ i ] - arr [ i - k ] ;		      	      if ( sum > max_sum ) :				    		max_sum = sum					  
    if ( sum > max_sum ) {				      		  max_sum = sum					    		max_end = i					  
      max_sum = sum ;					      		  max_end = i					    	return max_end - k + 1					  
      max_end = i ;					      	  return max_end - k + 1				    								  
    }							      								    								  
  }							      								    								  
  return max_end - k + 1 ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS		      MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS		    MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS		  MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS
--							      --							    --								  --
static int maximumSum ( int arr [ ] , int n , int k ) {	      def maximumSum ( arr , n , k ) :				    def maximum_sum ( arr , n , k ) :				  script_not_found : None
  for ( int i = 1 ;					      	  for i in range ( 1 , k + 1 ) :			    	for i in range ( 1 , k + 1 ) :				  
  i <= k ;						      	      min = + 2147483647				    	    min = + 2147483647					  
  i ++ ) {						      	      index = - 1					    	    index = - 1						  
    int min = + 2147483647 ;				      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
    int index = - 1 ;					      		  if ( arr [ j ] < min ) :			    		if arr [ j ] < min :				  
    for ( int j = 0 ;					      		      min = arr [ j ]				    		    min = arr [ j ]				  
    j < n ;						      		      index = j					    		    index = j					  
    j ++ ) {						      	      if ( min == 0 ) :					    	    if not min :					  
      if ( arr [ j ] < min ) {				      		  break						    		break						  
	min = arr [ j ] ;				      	      arr [ index ] = - arr [ index ]			    	    arr [ index ] = - arr [ index ]			  
	index = j ;					      	  sum = 0						    	sum = 0							  
      }							      	  for i in range ( n ) :				    	for i in range ( n ) :					  
    }							      	      sum += arr [ i ]					    	    sum += arr [ i ]					  
    if ( min == 0 ) break ;				      	  return sum						    	return sum						  
    arr [ index ] = - arr [ index ] ;			      								    								  
  }							      								    								  
  int sum = 0 ;						      								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) sum += arr [ i ] ;				      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES    CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES    CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES	  CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES
--							      --							    --								  --
static boolean isRotated ( String str1 , String str2 ) {      def isRotated ( str1 , str2 ) :				    def is_rotated ( str1 , str2 ) :				  error : Traceback (most recent call last):   File
  if ( str1 . length ( ) != str2 . length ( ) ) return false  	  if ( len ( str1 ) != len ( str2 ) ) :			    	if len ( str1 ) != len ( str2 ) :			  "dump/transcoder_st/eval/java_python/online_st/206
  String clock_rot = "" ;				      	      return False					    	    return False					  68770/eval_scripts/java_sa-python_sa.test/CHECK_ST
  String anticlock_rot = "" ;				      	  clock_rot = ""					    	clock_rot = ""						  RING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES
  int len = str2 . length ( ) ;				      	  anticlock_rot = ""					    	anticlock_rot = ""					  .py", line 54, in <module>	 if f_filled(*parame
  anticlock_rot = anticlock_rot + str2 . substring ( len - 2  	  l = len ( str2 )					    	str2 = list ( str2 )					  ters_set) == f_gold(*parameters_set):	  File "dump
  clock_rot = clock_rot + str2 . substring ( 2 ) + str2 . sub 	  anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 	anticlock_rot = anticlock_rot + str2 [ - 2 : ] + str2 [ : /transcoder_st/eval/java_python/online_st/20668770
  return ( str1 . equals ( clock_rot ) || str1 . equals ( ant 	  clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ]	    	clock_rot = clock_rot + str2 [ 2 : ] + str2 [ : 2 ]	  /eval_scripts/java_sa-python_sa.test/CHECK_STRING_
}							      	  return ( str1 == clock_rot or str1 == anticlock_rot )	    	return ( str1 == clock_rot or str1 == anticlock_rot )	  CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES.py",
							      								    								   line 34, in f_filled	    anticlock_rot = anticloc
							      								    								  k_rot + str2 [ - 2 : ] + str2 [ : - 2 ] TypeError:
							      								    								   must be str, not list
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1	      CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1		    CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1		  CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1
--							      --							    --								  --
static boolean checkCorrectOrNot ( String s ) {		      def checkCorrectOrNot ( s ) :				    def check_correct_or_not ( s ) :				  script_not_found : None
  int [ ] count = new int [ MAX_CHAR ] ;		      	  global MAX_CHAR					    	count = [ 0 ] * MAX_CHAR				  
  int n = s . length ( ) ;				      	  count = [ 0 ] * MAX_CHAR				    	n = len ( s )						  
  if ( n == 1 ) return true ;				      	  n = len ( s )						    	if n == 1 :						  
  for ( int i = 0 , j = n - 1 ;				      	  if n == 1 :						    	    return True						  
  i < j ;						      	      return true					    	for i , j in enumerate ( s [ : - 1 ] ) :		  
  i ++ , j -- ) {					      	  i = 0 j = n - 1					    	    count [ i - 'a' ] += 1				  
    count [ s . charAt ( i ) - 'a' ] ++ ;		      	  while i < j :						    	    count [ j - 'a' ] -= 1				  
    count [ s . charAt ( j ) - 'a' ] -- ;		      	      count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1	    	for i in range ( MAX_CHAR ) :				  
  }							      	      count [ ord ( s [ j ] ) - ord ( 'a' ) ] -= 1	    	    if count [ i ] != 0 :				  
  for ( int i = 0 ;					      	      i += 1 j -= 1					    		return False					  
  i < MAX_CHAR ;					      	  for i in range ( MAX_CHAR ) :				    	return True						  
  i ++ ) if ( count [ i ] != 0 ) return false ;		      	      if count [ i ] != 0 :				    								  
  return true ;						      		  return False					    								  
}							      	  return True						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
JUMP_SEARCH						      JUMP_SEARCH						    JUMP_SEARCH							  JUMP_SEARCH
--							      --							    --								  --
public static int jumpSearch ( int [ ] arr , int x ) {	      def jumpSearch ( arr , x , n ) :				    def jump_search ( arr , x ) :				  script_not_found : None
  int n = arr . length ;				      	  step = math.sqrt ( n )				    	n = len ( arr )						  
  int step = ( int ) Math . floor ( Math . sqrt ( n ) ) ;     	  prev = 0						    	step = int ( math.floor ( math.sqrt ( n ) ) )		  
  int prev = 0 ;					      	  while arr [ int ( min ( step , n ) - 1 ) ] < x :	    	prev = 0						  
  while ( arr [ Math . min ( step , n ) - 1 ] < x ) {	      	      prev = step					    	while arr [ min ( step , n ) - 1 ] < x :		  
    prev = step ;					      	      step += math.sqrt ( n )				    	    prev = step						  
    step += ( int ) Math . floor ( Math . sqrt ( n ) ) ;      	      if prev >= n :					    	    step += int ( math.floor ( math.sqrt ( n ) ) )	  
    if ( prev >= n ) return - 1 ;			      		  return - 1					    	    if prev >= n :					  
  }							      	  while arr [ int ( prev ) ] < x :			    		return - 1					  
  while ( arr [ prev ] < x ) {				      	      prev += 1						    	while arr [ prev ] < x :				  
    prev ++ ;						      	      if prev == min ( step , n ) :			    	    prev += 1						  
    if ( prev == Math . min ( step , n ) ) return - 1 ;	      		  return - 1					    	    if prev == min ( step , n ) :			  
  }							      	  if arr [ int ( prev ) ] == x :			    		return - 1					  
  if ( arr [ prev ] == x ) return prev ;		      	      return prev					    	if arr [ prev ] == x :					  
  return - 1 ;						      	  return - 1						    	    return prev						  
}							      								    	return - 1						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA
--							      --							    --								  --
public static String noAdjacentDup ( String s1 ) {	      def noAdjacentDup ( s ) :					    def no_adjacent_dup ( s1 ) :				  script_not_found : None
  int n = s1 . length ( ) ;				      	  n = len ( s )						    	n = len ( s1 )						  
  char [ ] s = s1 . toCharArray ( ) ;			      	  for i in range ( 1 , n ) :				    	s = list ( s1 )						  
  for ( int i = 1 ;					      	      if ( s [ i ] == s [ i - 1 ] ) :			    	for i in range ( 1 , n ) :				  
  i < n ;						      		  s [ i ] = "a"					    	    if s [ i ] == s [ i - 1 ] :				  
  i ++ ) {						      		  while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and 		s [ i ] = 'a'					  
    if ( s [ i ] == s [ i - 1 ] ) {			      		      s [ i ] += 1				    		while s [ i ] == s [ i - 1 ] or ( i + 1 < n and s 
      s [ i ] = 'a' ;					      		  i += 1					    		    s [ i ] += 1				  
      while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i  	  return s						    		i += 1						  
      i ++ ;						      								    	return ( ''.join ( s ) )				  
    }							      								    								  
  }							      								    								  
  return ( new String ( s ) ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1		      SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1		    SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1			  SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1
--							      --							    --								  --
static void minheapify ( int [ ] a , int index ) {	      def minheapify ( a , index ) :				    def minheapify ( a , index ) :				  script_not_found : None
  int small = index ;					      	  small = index						    	small = index						  
  int l = 2 * index + 1 ;				      	  l = 2 * index + 1					    	l = 2 * index + 1					  
  int r = 2 * index + 2 ;				      	  r = 2 * index + 2					    	r = 2 * index + 2					  
  if ( l < n && a [ l ] < a [ small ] ) small = l ;	      	  if ( l < n and a [ l ] < a [ small ] ) :		    	if l < n and a [ l ] < a [ small ] :			  
  if ( r < n && a [ r ] < a [ small ] ) small = r ;	      	      small = l						    	    small = l						  
  if ( small != index ) {				      	  if ( r < n and a [ r ] < a [ small ] ) :		    	if r < n and a [ r ] < a [ small ] :			  
    int t = a [ small ] ;				      	      small = r						    	    small = r						  
    a [ small ] = a [ index ] ;				      	  if ( small != index ) :				    	if small != index :					  
    a [ index ] = t ;					      	      ( a [ small ] , a [ index ] ) = ( a [ index ] , a [ s 	    t = a [ small ]					  
    minheapify ( a , small ) ;				      	      minheapify ( a , small )				    	    a [ small ] = a [ index ]				  
  }							      								    	    a [ index ] = t					  
}							      								    	    minheapify ( a , small )				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BRESENHAMS_LINE_GENERATION_ALGORITHM			      BRESENHAMS_LINE_GENERATION_ALGORITHM			    BRESENHAMS_LINE_GENERATION_ALGORITHM			  BRESENHAMS_LINE_GENERATION_ALGORITHM
--							      --							    --								  --
static void bresenham ( int x1 , int y1 , int x2 , int y2 ) { def bresenham ( x1 , y1 , x2 , y2 ) :			    def bresenham ( x1 , y1 , x2 , y2 ) :			  script_not_found : None
  int m_new = 2 * ( y2 - y1 ) ;				      	  m_new = 2 * ( y2 - y1 )				    	m_new = 2 * ( y2 - y1 )					  
  int slope_error_new = m_new - ( x2 - x1 ) ;		      	  slope_error_new = m_new - ( x2 - x1 )			    	slope_error_new = m_new - ( x2 - x1 )			  
  for ( int x = x1 , y = y1 ;				      	  y = y1						    	for x , y in zip ( x1 , y1 ) :				  
  x <= x2 ;						      	  for x in range ( x1 , x2 + 1 ) :			    	    print ( "(%d,%d)\n" % ( x , y ) , end = ' ' )	  
  x ++ ) {						      	      print ( "(" , x , "," , y , ")\n" )		    	    slope_error_new += m_new				  
    System . out . print ( "(" + x + "," + y + ")\n" ) ;      	      slope_error_new = slope_error_new + m_new		    	    if slope_error_new >= 0 :				  
    slope_error_new += m_new ;				      	      if ( slope_error_new >= 0 ) :			    		y += 1						  
    if ( slope_error_new >= 0 ) {			      		  y = y + 1					    		slope_error_new -= 2 * ( x2 - x1 )		  
      y ++ ;						      		  slope_error_new = slope_error_new - 2 * ( x2 - x1 								  
      slope_error_new -= 2 * ( x2 - x1 ) ;		      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS	      NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS	    NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS	  NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS
--							      --							    --								  --
int countTriangle ( int graph [ ] [ ] , boolean isDirected )  def countTriangle ( g , isDirected ) :			    def count_triangle ( graph , is_directed ) :		  script_not_found : None
  int count_Triangle = 0 ;				      	  nodes = len ( g )					    	count_triangle = 0					  
  for ( int i = 0 ;					      	  count_Triangle = 0					    	for i in range ( V ) :					  
  i < V ;						      	  for i in range ( nodes ) :				    	    for j in range ( V ) :				  
  i ++ ) {						      	      for j in range ( nodes ) :			    		for k in range ( V ) :				  
    for ( int j = 0 ;					      		  for k in range ( nodes ) :			    		    if graph [ i ] [ j ] == 1 and graph [ j ] [ k 
    j < V ;						      		      if ( i != j and i != k and j != k and g [ i ] 			count_triangle += 1			  
    j ++ ) {						      			  count_Triangle += 1			    	if is_directed == True :				  
      for ( int k = 0 ;					      	  return count_Triangle / 3 if isDirected else count_Triang 	    count_triangle /= 3					  
      k < V ;						      								    	else :							  
      k ++ ) {						      								    	    count_triangle /= 6					  
	if ( graph [ i ] [ j ] == 1 && graph [ j ] [ k ] == 1 								    	return count_triangle					  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  if ( isDirected == true ) {				      								    								  
    count_Triangle /= 3 ;				      								    								  
  }							      								    								  
  else {						      								    								  
    count_Triangle /= 6 ;				      								    								  
  }							      								    								  
  return count_Triangle ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE			      FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE			    FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE			  FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE
--							      --							    --								  --
static void findDimen ( int H , int A ) {		      def findDimen ( H , A ) :					    def find_dimen ( H , A ) :					  script_not_found : None
  if ( H * H < 4 * A ) {				      	  if H * H < 4 * A :					    	if H * H < 4 * A :					  
    System . out . println ( "Not Possible" ) ;		      	      print ( "Not Possible" )				    	    print ( "Not Possible" )				  
    return ;						      	      return						    	    return						  
  }							      	  apb = sqrt ( H * H + 4 * A )				    	apb = math.sqrt ( H * H + 4 * A )			  
  double apb = Math . sqrt ( H * H + 4 * A ) ;		      	  asb = sqrt ( H * H - 4 * A )				    	asb = math.sqrt ( H * H - 4 * A )			  
  double asb = Math . sqrt ( H * H - 4 * A ) ;		      	  print ( "P = " , "%.2f" % ( ( apb - asb ) / 2.0 ) )	    	print ( "P = %d" % round ( ( ( apb - asb ) / 2.0 ) * 100. 
  System . out . println ( "P = " + Math . round ( ( ( apb -  	  print ( "B = " , "%.2f" % ( ( apb + asb ) / 2.0 ) )	    	print ( "B = %d" % round ( ( ( apb + asb ) / 2.0 ) * 100. 
  System . out . print ( "B = " + Math . round ( ( ( apb + as 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF
--							      --							    --								  --
static int isMultipleOf3 ( int n ) {			      def isMultipleOf3 ( n ) :					    def is_multiple_of_3 ( n ) :				  success : None
  int odd_count = 0 ;					      	  odd_count = 0						    	odd_count = 0						  
  int even_count = 0 ;					      	  even_count = 0					    	even_count = 0						  
  if ( n < 0 ) n = - n ;				      	  if ( n < 0 ) :					    	if n < 0 :						  
  if ( n == 0 ) return 1 ;				      	      n = - n						    	    n = - n						  
  if ( n == 1 ) return 0 ;				      	  if ( n == 0 ) :					    	if n == 0 :						  
  while ( n != 0 ) {					      	      return 1						    	    return 1						  
    if ( ( n & 1 ) != 0 ) odd_count ++ ;		      	  if ( n == 1 ) :					    	if n == 1 :						  
    if ( ( n & 2 ) != 0 ) even_count ++ ;		      	      return 0						    	    return 0						  
    n = n >> 2 ;					      	  while ( n ) :						    	while n != 0 :						  
  }							      	      if ( n & 1 ) :					    	    if n & 1 :						  
  return isMultipleOf3 ( Math . abs ( odd_count - even_count  		  odd_count += 1				    		odd_count += 1					  
}							      	      if ( n & 2 ) :					    	    if n & 2 :						  
							      		  even_count += 1				    		even_count += 1					  
							      	      n = n >> 2					    	    n = n >> 2						  
							      	  return isMultipleOf3 ( abs ( odd_count - even_count ) )   	return is_multiple_of_3 ( abs ( odd_count - even_count )  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL		      CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL		    CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL			  CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL
--							      --							    --								  --
static void substringConversions ( String str , int k , int b def substringConversions ( s , k , b ) :			    def substring_conversions ( data , k , b ) :		  script_not_found : None
  for ( int i = 0 ;					      	  l = len ( s )						    	for i in range ( 0 , i + k + 1 ) :			  
  i + k <= str . length ( ) ;				      	  for i in range ( l ) :				    	    sub = data [ i : i + k ]				  
  i ++ ) {						      	      if ( ( i + k ) < l + 1 ) :			    	    sum , counter = 0 , 0				  
    String sub = str . substring ( i , i + k ) ;	      		  sub = s [ i : i + k ]				    	    for j in sub [ : - 1 ] :				  
    int sum = 0 , counter = 0 ;				      		  sum , counter = 0 , 0				    		sum = int ( sum + ( ( ord ( sub [ j ] ) - ord ( ' 
    for ( int j = sub . length ( ) - 1 ;		      		  for i in range ( len ( sub ) - 1 , - 1 , - 1 ) :  		counter += 1					  
    j >= 0 ;						      		      sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' 	    print ( sum , end = ' ' )				  
    j -- ) {						      		      counter += 1				    								  
      sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) *  		  print ( sum , end = " " )			    								  
      counter ++ ;					      								    								  
    }							      								    								  
    System . out . print ( sum + " " ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY
--							      --							    --								  --
public static void longestAlternating ( int arr [ ] , int n ) def longestAlternating ( arr , n ) :			    def longest_alternating ( arr , n ) :			  script_not_found : None
  int [ ] count = new int [ n ] ;			      	  count = [ None ] * n					    	count = [ 0 ] * n					  
  count [ n - 1 ] = 1 ;					      	  count [ n - 1 ] = 1					    	count [ n - 1 ] = 1					  
  for ( int i = n - 2 ;					      	  i = n - 2						    	for i in range ( n - 2 , - 1 , - 1 ) :			  
  i >= 0 ;						      	  while i >= 0 :					    	    if arr [ i ] * arr [ i + 1 ] < 0 :			  
  i -- ) {						      	      if ( arr [ i ] * arr [ i + 1 ] < 0 ) :		    		count [ i ] = count [ i + 1 ] + 1		  
    if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count  		  count [ i ] = count [ i + 1 ] + 1		    	    else :						  
    else count [ i ] = 1 ;				      	      else :						    		count [ i ] = 1					  
  }							      		  count [ i ] = 1				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      i = i - 1						    	    print ( count [ i ] , end = ' ' )			  
  i < n ;						      	  i = 0							    								  
  i ++ ) System . out . print ( count [ i ] + " " ) ;	      	  while i < n :						    								  
}							      	      print ( count [ i ] , end = " " )			    								  
							      	      i = i + 1						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_AN_ARRAY_OF_0S_1S_AND_2S				      SORT_AN_ARRAY_OF_0S_1S_AND_2S				    SORT_AN_ARRAY_OF_0S_1S_AND_2S				  SORT_AN_ARRAY_OF_0S_1S_AND_2S
--							      --							    --								  --
static void sort012 ( int a [ ] , int arr_size ) {	      def sort012 ( a , arr_size ) :				    def sort012 ( a , arr_size ) :				  timeout : None
  int lo = 0 ;						      	  lo = 0						    	lo = 0							  
  int hi = arr_size - 1 ;				      	  hi = arr_size - 1					    	hi = arr_size - 1					  
  int mid = 0 , temp = 0 ;				      	  mid = 0						    	mid , temp = 0 , 0					  
  while ( mid <= hi ) {					      	  while mid <= hi :					    	while mid <= hi :					  
    switch ( a [ mid ] ) {				      	      if a [ mid ] == 0 :				    	    if a [ mid ] == 0 :					  
      case 0 : {					      		  a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ]	    		temp = a [ lo ]					  
	temp = a [ lo ] ;				      		  lo = lo + 1					    		a [ lo ] = a [ mid ]				  
	a [ lo ] = a [ mid ] ;				      		  mid = mid + 1					    		a [ mid ] = temp				  
	a [ mid ] = temp ;				      	      elif a [ mid ] == 1 :				    		lo += 1						  
	lo ++ ;						      		  mid = mid + 1					    		mid += 1					  
	mid ++ ;					      	      else :						    	    elif a [ mid ] == 1 :				  
	break ;						      		  a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ]	    		mid += 1					  
      }							      		  hi = hi - 1					    	    elif a [ mid ] == 2 :				  
      case 1 : mid ++ ;					      								    		temp = a [ mid ]				  
      break ;						      								    		a [ mid ] = a [ hi ]				  
      case 2 : {					      								    		a [ hi ] = temp					  
	temp = a [ mid ] ;				      								    		hi -= 1						  
	a [ mid ] = a [ hi ] ;				      								    								  
	a [ hi ] = temp ;				      								    								  
	hi -- ;						      								    								  
	break ;						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD
--							      --							    --								  --
static void assign ( int a [ ] , int n ) {		      def assign ( a , n ) :					    def assign ( a , n ) :					  script_not_found : None
  Arrays . sort ( a ) ;					      	  a.sort ( )						    	a.sort ( )						  
  int ans [ ] = new int [ n ] ;				      	  ans = [ 0 ] * n					    	ans = [ 0 ] * n						  
  int p = 0 , q = n - 1 ;				      	  p = 0							    	p , q = 0 , n - 1					  
  for ( int i = 0 ;					      	  q = n - 1						    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( n ) :				    	    if ( i + 1 ) % 2 == 0 :				  
  i ++ ) {						      	      if ( i + 1 ) % 2 == 0 :				    		ans [ i ] = a [ q ]				  
    if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ;	      		  ans [ i ] = a [ q ]				    		q -= 1						  
    else ans [ i ] = a [ p ++ ] ;			      		  q = q - 1					    	    else :						  
  }							      	      else :						    		ans [ i ] = a [ p ]				  
  for ( int i = 0 ;					      		  ans [ i ] = a [ p ]				    		p += 1						  
  i < n ;						      		  p = p + 1					    	for i in range ( n ) :					  
  i ++ ) System . out . print ( ans [ i ] + " " ) ;	      	  for i in range ( n ) :				    	    print ( ans [ i ] , end = ' ' )			  
}							      	      print ( ans [ i ] , end = " " )			    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS		      FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS		    FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS			  FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS
--							      --							    --								  --
static void printFirstRepeating ( int arr [ ] ) {	      def printFirstRepeating ( arr , n ) :			    def print_first_repeating ( arr ) :				  script_not_found : None
  int min = - 1 ;					      	  Min = - 1						    	min = - 1						  
  HashSet < Integer > set = new HashSet < > ( ) ;	      	  myset = dict ( )					    	seen = set ( )						  
  for ( int i = arr . length - 1 ;			      	  for i in range ( n - 1 , - 1 , - 1 ) :		    	for i in range ( len ( arr ) - 1 , - 1 , - 1 ) :	  
  i >= 0 ;						      	      if arr [ i ] in myset.keys ( ) :			    	    if arr [ i ] in seen :				  
  i -- ) {						      		  Min = i					    		min = i						  
    if ( set . contains ( arr [ i ] ) ) min = i ;	      	      else :						    	    else :						  
    else set . add ( arr [ i ] ) ;			      		  myset [ arr [ i ] ] = 1			    		seen.add ( arr [ i ] )				  
  }							      	  if ( Min != - 1 ) :					    	if min != - 1 :						  
  if ( min != - 1 ) System . out . println ( "The first repea 	      print ( "The first repeating element is" , arr [ Min  	    print ( "The first repeating element is %d" % arr [ m 
  else System . out . println ( "There are no repeating eleme 	  else :						    	else :							  
}							      	      print ( "There are no repeating elements" )	    	    print ( "There are no repeating elements" )		  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH		      REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH		    REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH		  REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH
--							      --							    --								  --
static void rearrange ( int arr [ ] , int n ) {		      def rearrange ( arr , n ) :				    def rearrange ( arr , n ) :					  success : None
  int i = - 1 , temp = 0 ;				      	  i = - 1						    	i , temp = - 1 , 0					  
  for ( int j = 0 ;					      	  for j in range ( n ) :				    	for j in range ( n ) :					  
  j < n ;						      	      if ( arr [ j ] < 0 ) :				    	    if arr [ j ] < 0 :					  
  j ++ ) {						      		  i += 1					    		i += 1						  
    if ( arr [ j ] < 0 ) {				      		  arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]	    		temp = arr [ i ]				  
      i ++ ;						      	  pos , neg = i + 1 , 0					    		arr [ i ] = arr [ j ]				  
      temp = arr [ i ] ;				      	  while ( pos < n and neg < pos and arr [ neg ] < 0 ) :	    		arr [ j ] = temp				  
      arr [ i ] = arr [ j ] ;				      	      arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] 	pos , neg = i + 1 , 0					  
      arr [ j ] = temp ;				      	      pos += 1						    	while pos < n and neg < pos and arr [ neg ] < 0 :	  
    }							      	      neg += 2						    	    temp = arr [ neg ]					  
  }							      								    	    arr [ neg ] = arr [ pos ]				  
  int pos = i + 1 , neg = 0 ;				      								    	    arr [ pos ] = temp					  
  while ( pos < n && neg < pos && arr [ neg ] < 0 ) {	      								    	    pos += 1						  
    temp = arr [ neg ] ;				      								    	    neg += 2						  
    arr [ neg ] = arr [ pos ] ;				      								    								  
    arr [ pos ] = temp ;				      								    								  
    pos ++ ;						      								    								  
    neg += 2 ;						      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER	      SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER	    SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER	  SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER
--							      --							    --								  --
public static int sumOfSubstrings ( String num ) {	      def sumOfSubstrings ( num ) :				    def sum_of_substrings ( num ) :				  script_not_found : None
  int n = num . length ( ) ;				      	  n = len ( num )					    	n = len ( num )						  
  int sumofdigit [ ] = new int [ n ] ;			      	  sumofdigit = [ ]					    	sumofdigit = [ 0 ] * n					  
  sumofdigit [ 0 ] = num . charAt ( 0 ) - '0' ;		      	  sumofdigit.append ( int ( num [ 0 ] ) )		    	sumofdigit [ 0 ] = num [ 0 ] - '0'			  
  int res = sumofdigit [ 0 ] ;				      	  res = sumofdigit [ 0 ]				    	res = sumofdigit [ 0 ]					  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i < n ;						      	      numi = int ( num [ i ] )				    	    numi = num [ i ] - '0'				  
  i ++ ) {						      	      sumofdigit.append ( ( i + 1 ) * numi + 10 * sumofdigi 	    sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit 
    int numi = num . charAt ( i ) - '0' ;		      	      res += sumofdigit [ i ]				    	    res += sumofdigit [ i ]				  
    sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i 	  return res						    	return res						  
    res += sumofdigit [ i ] ;				      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE		      NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE		    NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE		  NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE
--							      --							    --								  --
static int getNumStrictMonotone ( int len ) {		      def getNumStrictMonotone ( ln ) :				    def get_num_strict_monotone ( len_ ) :			  script_not_found : None
  int [ ] [ ] DP = new int [ len ] [ DP_s ] ;		      	  DP = [ [ 0 ] * DP_s for _ in range ( ln ) ]		    	DP = np.zeros ( ( len_ , DP_s ) )			  
  for ( int i = 0 ;					      	  for i in range ( DP_s ) :				    	for i in range ( DP_s ) :				  
  i < DP_s ;						      	      DP [ 0 ] [ i ] = i + 1				    	    DP [ 0 ] [ i ] = i + 1				  
  ++ i ) DP [ 0 ] [ i ] = i + 1 ;			      	  for i in range ( 1 , ln ) :				    	for i in range ( 1 , len_ ) :				  
  for ( int i = 1 ;					      	      for j in range ( 1 , DP_s ) :			    	    for j in range ( 1 , DP_s ) :			  
  i < len ;						      		  DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i  		DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i  
  ++ i ) for ( int j = 1 ;				      	  return DP [ ln - 1 ] [ DP_s - 1 ]			    	return DP [ len_ - 1 ] [ DP_s - 1 ]			  
  j < DP_s ;						      								    								  
  ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ 								    								  
  return DP [ len - 1 ] [ DP_s - 1 ] ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS	      SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS	    SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS		  SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS
--							      --							    --								  --
static int findSmallestDifference ( int A [ ] , int B [ ] , i def findSmallestDifference ( A , B , m , n ) :		    def find_smallest_difference ( A , B , m , n ) :		  success : None
  Arrays . sort ( A ) ;					      	  A.sort ( )						    	A.sort ( )						  
  Arrays . sort ( B ) ;					      	  B.sort ( )						    	B.sort ( )						  
  int a = 0 , b = 0 ;					      	  a = 0							    	a , b = 0 , 0						  
  int result = Integer . MAX_VALUE ;			      	  b = 0							    	result = sys.maxsize					  
  while ( a < m && b < n ) {				      	  result = sys.maxsize					    	while a < m and b < n :					  
    if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = 	  while ( a < m and b < n ) :				    	    if abs ( A [ a ] - B [ b ] ) < result :		  
    if ( A [ a ] < B [ b ] ) a ++ ;			      	      if ( abs ( A [ a ] - B [ b ] ) < result ) :	    		result = abs ( A [ a ] - B [ b ] )		  
    else b ++ ;						      		  result = abs ( A [ a ] - B [ b ] )		    	    if A [ a ] < B [ b ] :				  
  }							      	      if ( A [ a ] < B [ b ] ) :			    		a += 1						  
  return result ;					      		  a += 1					    	    else :						  
}							      	      else :						    		b += 1						  
							      		  b += 1					    	return result						  
							      	  return result						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT		      REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT		    REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT		  REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT
--							      --							    --								  --
static int solve ( int dp [ ] [ ] , int a [ ] , int low , int def solve ( dp , a , low , high , turn ) :		    def solve ( dp , a , low , high , turn ) :			  success : None
  if ( low == high ) {					      	  if ( low == high ) :					    	if low == high :					  
    return a [ low ] * turn ;				      	      return a [ low ] * turn				    	    return a [ low ] * turn				  
  }							      	  if ( dp [ low ] [ high ] != 0 ) :			    	if dp [ low ] [ high ] != 0 :				  
  if ( dp [ low ] [ high ] != 0 ) {			      	      return dp [ low ] [ high ]			    	    return dp [ low ] [ high ]				  
    return dp [ low ] [ high ] ;			      	  dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp 	dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp 
  }							      	  return dp [ low ] [ high ]				    	return dp [ low ] [ high ]				  
  dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve 								    								  
  return dp [ low ] [ high ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STOOGE_SORT						      STOOGE_SORT						    STOOGE_SORT							  STOOGE_SORT
--							      --							    --								  --
static void stoogesort ( int arr [ ] , int l , int h ) {      def stoogesort ( arr , l , h ) :				    def stoogesort ( arr , l , h ) :				  success : None
  if ( l >= h ) return ;				      	  if l >= h :						    	if l >= h :						  
  if ( arr [ l ] > arr [ h ] ) {			      	      return						    	    return						  
    int t = arr [ l ] ;					      	  if arr [ l ] > arr [ h ] :				    	if arr [ l ] > arr [ h ] :				  
    arr [ l ] = arr [ h ] ;				      	      t = arr [ l ]					    	    t = arr [ l ]					  
    arr [ h ] = t ;					      	      arr [ l ] = arr [ h ]				    	    arr [ l ] = arr [ h ]				  
  }							      	      arr [ h ] = t					    	    arr [ h ] = t					  
  if ( h - l + 1 > 2 ) {				      	  if h - l + 1 > 2 :					    	if h - l + 1 > 2 :					  
    int t = ( h - l + 1 ) / 3 ;				      	      t = ( int ) ( ( h - l + 1 ) / 3 )			    	    t = ( h - l + 1 ) // 3				  
    stoogesort ( arr , l , h - t ) ;			      	      stoogesort ( arr , l , ( h - t ) )		    	    stoogesort ( arr , l , h - t )			  
    stoogesort ( arr , l + t , h ) ;			      	      stoogesort ( arr , l + t , ( h ) )		    	    stoogesort ( arr , l + t , h )			  
    stoogesort ( arr , l , h - t ) ;			      	      stoogesort ( arr , l , ( h - t ) )		    	    stoogesort ( arr , l , h - t )			  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_INCREASING_SUBSEQUENCE_1			      LONGEST_INCREASING_SUBSEQUENCE_1				    LONGEST_INCREASING_SUBSEQUENCE_1				  LONGEST_INCREASING_SUBSEQUENCE_1
--							      --							    --								  --
static int lis ( int arr [ ] , int n ) {		      def lis ( arr ) :						    def lis ( arr , n ) :					  script_not_found : None
  int lis [ ] = new int [ n ] ;				      	  n = len ( arr )					    	lis = [ 0 ] * n						  
  int i , j , max = 0 ;					      	  lis = [ 1 ] * n					    	i , j , max = 0 , 0 , 0					  
  for ( i = 0 ;						      	  for i in range ( 1 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( 0 , i ) :			    	    lis [ i ] = 1					  
  i ++ ) lis [ i ] = 1 ;				      		  if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j  	for i in range ( 1 , n ) :				  
  for ( i = 1 ;						      		      lis [ i ] = lis [ j ] + 1			    	    for j in range ( i ) :				  
  i < n ;						      	  maximum = 0						    		if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j  
  i ++ ) for ( j = 0 ;					      	  for i in range ( n ) :				    		    lis [ i ] = lis [ j ] + 1			  
  j < i ;						      	      maximum = max ( maximum , lis [ i ] )		    	for i in range ( n ) :					  
  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ]  	  return maximum					    	    if max < lis [ i ] :				  
  for ( i = 0 ;						      								    		max = lis [ i ]					  
  i < n ;						      								    	return max						  
  i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;	      								    								  
  return max ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES      PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES	    PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES	  PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES
--							      --							    --								  --
static void printString ( String str , char ch , int count )  def printString ( str , ch , count ) :			    def print_string ( str , ch , count ) :			  script_not_found : None
  int occ = 0 , i ;					      	  occ , i = 0 , 0					    	occ , i = 0 , 0						  
  if ( count == 0 ) {					      	  if ( count == 0 ) :					    	if count == 0 :						  
    System . out . println ( str ) ;			      	      print ( str )					    	    print ( str )					  
    return ;						      	  for i in range ( len ( str ) ) :			    	    return						  
  }							      	      if ( str [ i ] == ch ) :				    	for c in str :						  
  for ( i = 0 ;						      		  occ += 1					    	    if c == ch :					  
  i < str . length ( ) ;				      	      if ( occ == count ) :				    		occ += 1					  
  i ++ ) {						      		  break						    	    if occ == count :					  
    if ( str . charAt ( i ) == ch ) occ ++ ;		      	  if ( i < len ( str ) - 1 ) :				    		break						  
    if ( occ == count ) break ;				      	      print ( str [ i + 1 : len ( str ) - i + 2 ] )	    	if i < len ( str ) - 1 :				  
  }							      	  else :						    	    print ( str [ i + 1 : ] )				  
  if ( i < str . length ( ) - 1 ) System . out . println ( st 	      print ( "Empty string" )				    	else :							  
  else System . out . println ( "Empty string" ) ;	      								    	    print ( 'Empty string' )				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER	      COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER	    COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER	  COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER
--							      --							    --								  --
static int countNumber ( int n ) {			      def countNumber ( n ) :					    def count_number ( n ) :					  error : Traceback (most recent call last):   File
  int result = 0 ;					      	  result = 0						    	result = 0						  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int i = 1 ;					      	  for i in range ( 1 , 10 ) :				    	for i in range ( 1 , 9 + 1 ) :				  68770/eval_scripts/java_sa-python_sa.test/COUNT_NA
  i <= 9 ;						      	      s = [ ]						    	    s = [ ]						  TURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER.py"
  i ++ ) {						      	      if ( i <= n ) :					    	    if i <= n :						  , line 68, in <module>     if f_filled(*parameters
    Stack < Integer > s = new Stack < > ( ) ;		      		  s.append ( i )				    		s.append ( i )					  _set) == f_gold(*parameters_set):   File "dump/tra
    if ( i <= n ) {					      		  result += 1					    		result += 1					  nscoder_st/eval/java_python/online_st/20668770/eva
      s . push ( i ) ;					      	      while len ( s ) != 0 :				    	    while not s :					  l_scripts/java_sa-python_sa.test/COUNT_NATURAL_NUM
      result ++ ;					      		  tp = s [ - 1 ]				    		tp = s [ - 1 ]					  BERS_WHOSE_PERMUTATION_GREATER_NUMBER.py", line 43
    }							      		  s.pop ( )					    		s.append ( tp )					  , in f_filled	    tp = s [ - 1 ] IndexError: list
    while ( ! s . empty ( ) ) {				      		  for j in range ( tp % 10 , 10 ) :		    		for j in range ( tp % 10 , 9 + 1 ) :		  index out of range
      int tp = s . peek ( ) ;				      		      x = tp * 10 + j				    		    x = tp * 10 + j				  
      s . pop ( ) ;					      		      if ( x <= n ) :				    		    if x <= n :					  
      for ( int j = tp % 10 ;				      			  s.append ( x )			    			s.append ( x )				  
      j <= 9 ;						      			  result += 1				    			result += 1				  
      j ++ ) {						      	  return result						    	return result						  
	int x = tp * 10 + j ;				      								    								  
	if ( x <= n ) {					      								    								  
	  s . push ( x ) ;				      								    								  
	  result ++ ;					      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT			      KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT			    KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT			  KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT
--							      --							    --								  --
static void printkthnode ( Vector < pair > adj [ ] , int wt [ def printkthnode ( adj , wt , n , k ) :			    def printkthnode ( adj , wt , n , k ) :			  script_not_found : None
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      adj [ i ].sort ( )				    	    adj [ i ].sort ( key = lambda p1 , p2 : cmp ( p1 [ 0  
  i ++ ) Collections . sort ( adj [ i ] , new Comparator < pa 	  for i in range ( n ) :				    	for i in range ( n ) :					  
    public int compare ( pair p1 , pair p2 ) {		      	      if ( len ( adj [ i ] ) >= k ) :			    	    if len ( adj [ i ] ) >= k :				  
      return p1 . first - p2 . first ;			      		  print ( adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ] 		print ( adj [ i ] [ - k ] [ 1 ] , end = ' ' )	  
    }							      	      else :						    	    else :						  
  }							      		  print ( "-1" , end = " " )			    		print ( '-1' , end = ' ' )			  
  ) ;							      								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    if ( adj [ i ] . size ( ) >= k ) System . out . print ( a 								    								  
    else System . out . print ( "-1" ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY			      FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY			    FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY			  FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY
--							      --							    --								  --
static int firstElement ( int arr [ ] , int n , int k ) {     def firstElement ( arr , n , k ) :			    def first_element ( arr , n , k ) :				  error : Traceback (most recent call last):   File
  HashMap < Integer , Integer > count_map = new HashMap < > ( 	  count_map = { }					    	count_dict = { }					  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  68770/eval_scripts/java_sa-python_sa.test/FIRST_EL
  i < n ;						      	      if ( arr [ i ] in count_map.keys ( ) ) :		    	    a = 0						  EMENT_OCCURRING_K_TIMES_ARRAY.py", line 60, in <mo
  i ++ ) {						      		  count_map [ arr [ i ] ] += 1			    	    if arr [ i ] is not None :				  dule>	    if f_filled(*parameters_set) == f_gold(*
    int a = 0 ;						      	      else :						    		a = count_dict [ arr [ i ] ]			  parameters_set):   File "dump/transcoder_st/eval/j
    if ( count_map . get ( arr [ i ] ) != null ) {	      		  count_map [ arr [ i ] ] = 1			    	    count_dict [ arr [ i ] ] = a + 1			  ava_python/online_st/20668770/eval_scripts/java_sa
      a = count_map . get ( arr [ i ] ) ;		      	      i += 1						    	for i in range ( n ) :					  -python_sa.test/FIRST_ELEMENT_OCCURRING_K_TIMES_AR
    }							      	  for i in range ( 0 , n ) :				    	    if count_dict [ arr [ i ] ] == k :			  RAY.py", line 37, in f_filled	    a = count_dict [
    count_map . put ( arr [ i ] , a + 1 ) ;		      	      if ( count_map [ arr [ i ] ] == k ) :		    		return arr [ i ]				   arr [ i ] ] KeyError: 2
  }							      		  return arr [ i ]				    	return - 1						  
  for ( int i = 0 ;					      	      i += 1						    								  
  i < n ;						      	  return - 1						    								  
  i ++ ) {						      								    								  
    if ( count_map . get ( arr [ i ] ) == k ) {		      								    								  
      return arr [ i ] ;				      								    								  
    }							      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1			      FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1			    FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1			  FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1
--							      --							    --								  --
static int maxLen ( int arr [ ] ) {			      def maxLen ( arr ) :					    def maxLen ( arr ) :					  script_not_found : None
  HashMap < Integer , Integer > hM = new HashMap < Integer ,  	  hash_map = { }					    	hM = { }						  
  int sum = 0 ;						      	  max_len = 0						    	sum = 0							  
  int max_len = 0 ;					      	  curr_sum = 0						    	maxLen = 0						  
  for ( int i = 0 ;					      	  for i in range ( len ( arr ) ) :			    	for i in range ( len ( arr ) ) :			  
  i < arr . length ;					      	      curr_sum += arr [ i ]				    	    sum += arr [ i ]					  
  i ++ ) {						      	      if arr [ i ] is 0 and max_len is 0 :		    	    if not i and maxLen == 0 :				  
    sum += arr [ i ] ;					      		  max_len = 1					    		maxLen = 1					  
    if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ;	      	      if curr_sum is 0 :				    	    if sum == 0 :					  
    if ( sum == 0 ) max_len = i + 1 ;			      		  max_len = i + 1				    		maxLen = i + 1					  
    Integer prev_i = hM . get ( sum ) ;			      	      if curr_sum in hash_map :				    	    prev_i = hM.get ( sum )				  
    if ( prev_i != null ) max_len = Math . max ( max_len , i  		  max_len = max ( max_len , i - hash_map [ curr_sum 	    if prev_i :						  
    else hM . put ( sum , i ) ;				      	      else :						    		maxLen = max ( maxLen , i - prev_i )		  
  }							      		  hash_map [ curr_sum ] = i			    	    else :						  
  return max_len ;					      	  return max_len					    		hM [ sum ] = i					  
}							      								    	return maxLen						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K     GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K	    GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K	  GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K
--							      --							    --								  --
static void printSumSimple ( int mat [ ] [ ] , int k ) {      def printSumSimple ( mat , k ) :				    def printSumSimple ( mat , k ) :				  script_not_found : None
  if ( k > n ) return ;					      	  if ( k > n ) :					    	if k > n :						  
  for ( int i = 0 ;					      	      return						    	    return						  
  i < n - k + 1 ;					      	  for i in range ( n - k + 1 ) :			    	for i in range ( n - k + 1 ) :				  
  i ++ ) {						      	      for j in range ( n - k + 1 ) :			    	    for j in range ( n - k + 1 ) :			  
    for ( int j = 0 ;					      		  sum = 0					    		sum = 0						  
    j < n - k + 1 ;					      		  for p in range ( i , k + i ) :		    		for p in range ( i , k + i ) :			  
    j ++ ) {						      		      for q in range ( j , k + j ) :		    		    for q in range ( j , k + j ) :		  
      int sum = 0 ;					      			  sum += mat [ p ] [ q ]		    			sum += mat [ p ] [ q ]			  
      for ( int p = i ;					      		  print ( sum , end = " " )			    		print ( sum , end = ' ' )			  
      p < k + i ;					      	      print ( )						    	print ( )						  
      p ++ ) for ( int q = j ;				      								    								  
      q < k + j ;					      								    								  
      q ++ ) sum += mat [ p ] [ q ] ;			      								    								  
      System . out . print ( sum + " " ) ;		      								    								  
    }							      								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_ COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_ COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_ COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_
--							      --							    --								  --
private static void findCount ( int n , int sum ) {	      def findCount ( n , sum ) :				    def find_count ( n , sum ) :				  script_not_found : None
  int start = ( int ) Math . pow ( 10 , n - 1 ) ;	      	  start = math.pow ( 10 , n - 1 )			    	start = int ( math.pow ( 10 , n - 1 ) )			  
  int end = ( int ) Math . pow ( 10 , n ) - 1 ;		      	  end = math.pow ( 10 , n ) - 1				    	end = int ( math.pow ( 10 , n ) - 1 )			  
  int count = 0 ;					      	  count = 0						    	count = 0						  
  int i = start ;					      	  i = start						    	i = start						  
  while ( i < end ) {					      	  while ( i <= end ) :					    	while i < end :						  
    int cur = 0 ;					      	      cur = 0						    	    cur = 0						  
    int temp = i ;					      	      temp = i						    	    temp = i						  
    while ( temp != 0 ) {				      	      while ( temp != 0 ) :				    	    while temp != 0 :					  
      cur += temp % 10 ;				      		  cur += temp % 10				    		cur += temp % 10				  
      temp = temp / 10 ;				      		  temp = temp // 10				    		temp = temp // 10				  
    }							      	      if ( cur == sum ) :				    	    if cur == sum :					  
    if ( cur == sum ) {					      		  count = count + 1				    		count += 1					  
      count ++ ;					      		  i += 9					    		i += 9						  
      i += 9 ;						      	      else :						    	    else :						  
    }							      		  i = i + 1					    		i += 1						  
    else i ++ ;						      	  print ( count )					    	print ( count )						  
  }							      								    								  
  System . out . println ( count ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY		      FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY			    FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY			  FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY
--							      --							    --								  --
static int findSubarraySum ( int [ ] arr , int n ) {	      def findSubarraySum ( arr , n ) :				    def find_subarray_sum ( arr , n ) :				  success : None
  int res = 0 ;						      	  res = 0						    	res = 0							  
  HashMap < Integer , Integer > m = new HashMap < Integer , I 	  m = dict ( )						    	m = { }							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      Sum = 0						    	    sum = 0						  
  i ++ ) {						      	      for j in range ( i , n ) :			    	    for j in arr [ i : n ] :				  
    int sum = 0 ;					      		  Sum += arr [ j ]				    		sum += j					  
    for ( int j = i ;					      		  m [ Sum ] = m.get ( Sum , 0 ) + 1		    		if sum in m :					  
    j < n ;						      	  for x in m :						    		    m [ sum ] = m [ sum ] + 1			  
    j ++ ) {						      	      if m [ x ] == 1 :					    		else :						  
      sum += arr [ j ] ;				      		  res += x					    		    m [ sum ] = 1				  
      if ( m . containsKey ( sum ) ) {			      	  return res						    	for x , y in m.items ( ) :				  
	m . put ( sum , m . get ( sum ) + 1 ) ;		      								    	    if y == 1 :						  
      }							      								    		res += x					  
      else {						      								    	return res						  
	m . put ( sum , 1 ) ;				      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  for ( Map . Entry < Integer , Integer > x : m . entrySet (  								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN
--							      --							    --								  --
static void printMaxOfMin ( int n ) {			      def printMaxOfMin ( arr , n ) :				    def print_max_of_min ( n ) :				  script_not_found : None
  for ( int k = 1 ;					      	  for k in range ( 1 , n + 1 ) :			    	for k in range ( 1 , n + 1 ) :				  
  k <= n ;						      	      maxOfMin = INT_MIN				    	    max_of_min = sys.maxsize				  
  k ++ ) {						      	      for i in range ( n - k + 1 ) :			    	    for i in range ( 0 , n - k + 1 ) :			  
    int maxOfMin = Integer . MIN_VALUE ;		      		  min = arr [ i ]				    		min = sys.maxsize				  
    for ( int i = 0 ;					      		  for j in range ( k ) :			    		for j in range ( 1 , k ) :			  
    i <= n - k ;					      		      if ( arr [ i + j ] < min ) :		    		    if sys.maxsize < min :			  
    i ++ ) {						      			  min = arr [ i + j ]			    			min = sys.maxsize			  
      int min = arr [ i ] ;				      		  if ( min > maxOfMin ) :			    		if min > max_of_min :				  
      for ( int j = 1 ;					      		      maxOfMin = min				    		    max_of_min = min				  
      j < k ;						      	      print ( maxOfMin , end = " " )			    	    sys.stdout.write ( str ( max_of_min ) + ' ' )	  
      j ++ ) {						      								    								  
	if ( arr [ i + j ] < min ) min = arr [ i + j ] ;      								    								  
      }							      								    								  
      if ( min > maxOfMin ) maxOfMin = min ;		      								    								  
    }							      								    								  
    System . out . print ( maxOfMin + " " ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_DIVISIBLE_PAIRS_SUBSET				      LARGEST_DIVISIBLE_PAIRS_SUBSET				    LARGEST_DIVISIBLE_PAIRS_SUBSET				  LARGEST_DIVISIBLE_PAIRS_SUBSET
--							      --							    --								  --
static int largestSubset ( int [ ] a , int n ) {	      def largestSubset ( a , n ) :				    def largestSubset ( a , n ) :				  script_not_found : None
  Arrays . sort ( a ) ;					      	  a.sort ( )						    	a.sort ( )						  
  int [ ] dp = new int [ n ] ;				      	  dp = [ 0 for i in range ( n ) ]			    	dp = [ 0 ] * n						  
  dp [ n - 1 ] = 1 ;					      	  dp [ n - 1 ] = 1					    	dp [ n - 1 ] = 1					  
  for ( int i = n - 2 ;					      	  for i in range ( n - 2 , - 1 , - 1 ) :		    	for i in range ( n - 2 , - 1 , - 1 ) :			  
  i >= 0 ;						      	      mxm = 0						    	    mxm = 0						  
  i -- ) {						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
    int mxm = 0 ;					      		  if a [ j ] % a [ i ] == 0 :			    		if a [ j ] % a [ i ] == 0 :			  
    for ( int j = i + 1 ;				      		      mxm = max ( mxm , dp [ j ] )		    		    mxm = max ( mxm , dp [ j ] )		  
    j < n ;						      	      dp [ i ] = 1 + mxm				    	    dp [ i ] = 1 + mxm					  
    j ++ ) {						      	  return max ( dp )					    	return max ( dp )					  
      if ( a [ j ] % a [ i ] == 0 ) {			      								    								  
	mxm = Math . max ( mxm , dp [ j ] ) ;		      								    								  
      }							      								    								  
    }							      								    								  
    dp [ i ] = 1 + mxm ;				      								    								  
  }							      								    								  
  return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ;    								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECAMANS_SEQUENCE					      RECAMANS_SEQUENCE						    RECAMANS_SEQUENCE						  RECAMANS_SEQUENCE
--							      --							    --								  --
static void recaman ( int n ) {				      def recaman ( n ) :					    def recaman ( n ) :						  script_not_found : None
  int arr [ ] = new int [ n ] ;				      	  arr = [ 0 ] * n					    	arr = [ 0 ] * n						  
  arr [ 0 ] = 0 ;					      	  arr [ 0 ] = 0						    	arr [ 0 ] = 0						  
  System . out . print ( arr [ 0 ] + " ," ) ;		      	  print ( arr [ 0 ] , end = ", " )			    	print ( arr [ 0 ] , end = ' ,' , flush = True )		  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i < n ;						      	      curr = arr [ i - 1 ] - i				    	    curr = arr [ i - 1 ] - i				  
  i ++ ) {						      	      for j in range ( 0 , i ) :			    	    j = 0						  
    int curr = arr [ i - 1 ] - i ;			      		  if ( ( arr [ j ] == curr ) or curr < 0 ) :	    	    for j in range ( i ) :				  
    int j ;						      		      curr = arr [ i - 1 ] + i			    		if ( arr [ j ] == curr ) or curr < 0 :		  
    for ( j = 0 ;					      		      break					    		    curr = arr [ i - 1 ] + i			  
    j < i ;						      	      arr [ i ] = curr					    		    break					  
    j ++ ) {						      	      print ( arr [ i ] , end = ", " )			    	    arr [ i ] = curr					  
      if ( ( arr [ j ] == curr ) || curr < 0 ) {	      								    	    print ( arr [ i ] , end = ' , ' , flush = True )	  
	curr = arr [ i - 1 ] + i ;			      								    								  
	break ;						      								    								  
      }							      								    								  
    }							      								    								  
    arr [ i ] = curr ;					      								    								  
    System . out . print ( arr [ i ] + ", " ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_PATH_TRIANGLE				      MINIMUM_SUM_PATH_TRIANGLE					    MINIMUM_SUM_PATH_TRIANGLE					  MINIMUM_SUM_PATH_TRIANGLE
--							      --							    --								  --
static int minSumPath ( ) {				      def minSumPath ( A ) :					    def min_sum_path ( ) :					  script_not_found : None
  int [ ] memo = new int [ A . length ] ;		      	  memo = [ None ] * len ( A )				    	memo = [ 0 ] * len ( A )				  
  int n = A . length - 1 ;				      	  n = len ( A ) - 1					    	n = len ( A ) - 1					  
  for ( int i = 0 ;					      	  for i in range ( len ( A [ n ] ) ) :			    	for i in range ( len ( A [ n ] ) ) :			  
  i < A [ n ] . length ;				      	      memo [ i ] = A [ n ] [ i ]			    	    memo [ i ] = A [ n ] [ i ]				  
  i ++ ) memo [ i ] = A [ n ] [ i ] ;			      	  for i in range ( len ( A ) - 2 , - 1 , - 1 ) :	    	for i in range ( len ( A ) - 2 , - 1 , - 1 ) :		  
  for ( int i = A . length - 2 ;			      	      for j in range ( len ( A [ i ] ) ) :		    	    for j in range ( len ( A [ i ] ) ) :		  
  i >= 0 ;						      		  memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , m 		memo [ j ] = A [ i ] [ j ] + int ( min ( memo [ j 
  i -- ) for ( int j = 0 ;				      	  return memo [ 0 ]					    	return memo [ 0 ]					  
  j < A [ i ] . length ;				      								    								  
  j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . min ( me 								    								  
  return memo [ 0 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER		      C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER			    C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER			  C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER
--							      --							    --								  --
static char getSecondMostFreq ( String str ) {		      def getSecondMostFreq ( str ) :				    def get_second_most_freq ( data ) :				  error : Traceback (most recent call last):   File
  int [ ] count = new int [ NO_OF_CHARS ] ;		      	  NO_OF_CHARS = 256					    	count = [ 0 ] * len ( data )				  "dump/transcoder_st/eval/java_python/online_st/206
  int i ;						      	  count = [ 0 ] * NO_OF_CHARS				    	for c in data :						  68770/eval_scripts/java_sa-python_sa.test/C_PROGRA
  for ( i = 0 ;						      	  for i in range ( len ( str ) ) :			    	    ( count [ ord ( c ) ] ) += 1			  M_FIND_SECOND_FREQUENT_CHARACTER.py", line 61, in
  i < str . length ( ) ;				      	      count [ ord ( str [ i ] ) ] += 1			    	first , second = 0 , 0					  <module>     if f_filled(*parameters_set) == f_gol
  i ++ ) ( count [ str . charAt ( i ) ] ) ++ ;		      	  first , second = 0 , 0				    	for i in range ( len ( data ) ) :			  d(*parameters_set):	File "dump/transcoder_st/eva
  int first = 0 , second = 0 ;				      	  for i in range ( NO_OF_CHARS ) :			    	    if count [ i ] > count [ first ] :			  l/java_python/online_st/20668770/eval_scripts/java
  for ( i = 0 ;						      	      if count [ i ] > count [ first ] :		    		second = first					  _sa-python_sa.test/C_PROGRAM_FIND_SECOND_FREQUENT_
  i < NO_OF_CHARS ;					      		  second = first				    		first = i					  CHARACTER.py", line 35, in f_filled	  ( count [
  i ++ ) {						      		  first = i					    	    elif count [ i ] > count [ second ] and count [ i ] ! ord ( c ) ] ) += 1 IndexError: list index out of r
    if ( count [ i ] > count [ first ] ) {		      	      elif ( count [ i ] > count [ second ] and count [ i ] 		second = i					  ange
      second = first ;					      		  second = i					    	return chr ( second )					  
      first = i ;					      	  return chr ( second )					    								  
    }							      								    								  
    else if ( count [ i ] > count [ second ] && count [ i ] ! 								    								  
  }							      								    								  
  return ( char ) second ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FREQUENT_ELEMENT_ARRAY_1				      FREQUENT_ELEMENT_ARRAY_1					    FREQUENT_ELEMENT_ARRAY_1					  FREQUENT_ELEMENT_ARRAY_1
--							      --							    --								  --
static int mostFrequent ( int arr [ ] , int n ) {	      def mostFrequent ( arr , n ) :				    def most_frequent ( arr , n ) :				  failure : #Results: 8, 10
  Map < Integer , Integer > hp = new HashMap < Integer , Inte 	  Hash = dict ( )					    	hp = { }						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for key in arr :					  
  i < n ;						      	      if arr [ i ] in Hash.keys ( ) :			    	    if key in hp :					  
  i ++ ) {						      		  Hash [ arr [ i ] ] += 1			    		freq = hp [ key ]				  
    int key = arr [ i ] ;				      	      else :						    		freq += 1					  
    if ( hp . containsKey ( key ) ) {			      		  Hash [ arr [ i ] ] = 1			    		hp [ key ] = freq				  
      int freq = hp . get ( key ) ;			      	  max_count = 0						    	    else :						  
      freq ++ ;						      	  res = - 1						    		hp [ key ] = 1					  
      hp . put ( key , freq ) ;				      	  for i in Hash :					    	max_count , res = 0 , - 1				  
    }							      	      if ( max_count < Hash [ i ] ) :			    	for val , count in hp.items ( ) :			  
    else {						      		  res = i					    	    if max_count < count :				  
      hp . put ( key , 1 ) ;				      		  max_count = Hash [ i ]			    		res = val					  
    }							      	  return res						    		max_count = count				  
  }							      								    	return res						  
  int max_count = 0 , res = - 1 ;			      								    								  
  for ( Entry < Integer , Integer > val : hp . entrySet ( ) ) 								    								  
    if ( max_count < val . getValue ( ) ) {		      								    								  
      res = val . getKey ( ) ;				      								    								  
      max_count = val . getValue ( ) ;			      								    								  
    }							      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM			      MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM			    MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM			  MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM
--							      --							    --								  --
static int maximumSumSubarray ( int arr [ ] , int n ) {	      def maximumSumSubarray ( arr , n ) :			    def maximum_sum_substring ( arr , n ) :			  failure : #Results: 9, 10
  int min_prefix_sum = 0 ;				      	  min_prefix_sum = 0					    	min_prefix_sum = 0					  
  int res = Integer . MIN_VALUE ;			      	  res = - math.inf					    	res = 0							  
  int prefix_sum [ ] = new int [ n ] ;			      	  prefix_sum = [ ]					    	prefix_sum = [ 0 ] * n					  
  prefix_sum [ 0 ] = arr [ 0 ] ;			      	  prefix_sum.append ( arr [ 0 ] )			    	prefix_sum [ 0 ] = arr [ 0 ]				  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i < n ;						      	      prefix_sum.append ( prefix_sum [ i - 1 ] + arr [ i ]  	    prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ]	  
  i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ]  	  for i in range ( n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      res = max ( res , prefix_sum [ i ] - min_prefix_sum ) 	    res = max ( res , prefix_sum [ i ] - min_prefix_sum ) 
  i < n ;						      	      min_prefix_sum = min ( min_prefix_sum , prefix_sum [  	    min_prefix_sum = min ( min_prefix_sum , prefix_sum [  
  i ++ ) {						      	  return res						    	return res						  
    res = Math . max ( res , prefix_sum [ i ] - min_prefix_su 								    								  
    min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum 								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1	      FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1	    FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1	  FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1
--							      --							    --								  --
public static void findPair ( int [ ] arr , int n ) {	      def findPair ( arr , n ) :				    def find_pair ( arr , n ) :					  script_not_found : None
  HashSet < Integer > s = new HashSet < Integer > ( ) ;	      	  s = { i : 1 for i in arr }				    	s = set ( )						  
  for ( Integer i : arr ) {				      	  found = False						    	for i in arr :						  
    s . add ( i ) ;					      	  for i in range ( n ) :				    	    s.add ( i )						  
  }							      	      for j in range ( i + 1 , n ) :			    	found = False						  
  boolean found = false ;				      		  if arr [ i ] + arr [ j ] in s.keys ( ) :	    	for i in range ( n - 1 ) :				  
  for ( int i = 0 ;					      		      print ( arr [ i ] , arr [ j ] )		    	    for j in range ( i + 1 , n ) :			  
  i < n - 1 ;						      		      found = True				    		sum = arr [ i ] + arr [ j ]			  
  i ++ ) {						      	  if found == False :					    		if sum in s :					  
    for ( int j = i + 1 ;				      	      print ( "Not exist" )				    		    found = True				  
    j < n ;						      								    		    print ( arr [ i ] , arr [ j ] )		  
    j ++ ) {						      								    	if found == False :					  
      int sum = arr [ i ] + arr [ j ] ;			      								    	    print ( "Not Exist " )				  
      if ( s . contains ( sum ) ) {			      								    								  
	found = true ;					      								    								  
	System . out . println ( arr [ i ] + " " + arr [ j ]  								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  if ( found == false ) System . out . println ( "Not Exist " 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS	      MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS		    MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS		  MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS
--							      --							    --								  --
static int maxSum ( int arr [ ] , int N , int k ) {	      def maxSum ( arr , N , k ) :				    def max_sum ( arr , N , k ) :				  success : None
  int MS [ ] = new int [ N ] ;				      	  MS = [ 0 for i in range ( N ) ]			    	MS = [ 0 ] * N						  
  MS [ N - 1 ] = arr [ N - 1 ] ;			      	  MS [ N - 1 ] = arr [ N - 1 ]				    	MS [ N - 1 ] = arr [ N - 1 ]				  
  for ( int i = N - 2 ;					      	  for i in range ( N - 2 , - 1 , - 1 ) :		    	for i in range ( N - 2 , - 1 , - 1 ) :			  
  i >= 0 ;						      	      if ( i + k + 1 >= N ) :				    	    if i + k + 1 >= N :					  
  i -- ) {						      		  MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] )	    		MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] )	  
    if ( i + k + 1 >= N ) MS [ i ] = Math . max ( arr [ i ] , 	      else :						    	    else :						  
    else MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ] 		  MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , M 		MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , M 
  }							      	  return MS [ 0 ]					    	return MS [ 0 ]						  
  return MS [ 0 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE	      FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE	    FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE	  FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE
--							      --							    --								  --
private static void printDuplicates ( int [ ] arr , int n ) { def printDuplicates ( arr ) :				    def print_duplicates ( arr , n ) :				  script_not_found : None
  Map < Integer , Integer > map = new HashMap < > ( ) ;	      	  dict = { }						    	d = { }							  
  int count = 0 ;					      	  for ele in arr :					    	count = 0						  
  boolean dup = false ;					      	      try :						    	dup = False						  
  for ( int i = 0 ;					      		  dict [ ele ] += 1				    	for i in range ( n ) :					  
  i < n ;						      	      except :						    	    if arr [ i ] in d :					  
  i ++ ) {						      		  dict [ ele ] = 1				    		count = d [ arr [ i ] ]				  
    if ( map . containsKey ( arr [ i ] ) ) {		      	  for item in dict :					    		d [ arr [ i ] ] = count + 1			  
      count = map . get ( arr [ i ] ) ;			      	      if ( dict [ item ] > 1 ) :			    	    else :						  
      map . put ( arr [ i ] , count + 1 ) ;		      		  print ( item , end = " " )			    		d [ arr [ i ] ] = 1				  
    }							      	  print ( "\n" )					    	for key , value in d.items ( ) :			  
    else {						      								    	    if value > 1 :					  
      map . put ( arr [ i ] , 1 ) ;			      								    		print ( key , end = ' ' )			  
    }							      								    		dup = True					  
  }							      								    	if not dup :						  
  for ( Entry < Integer , Integer > entry : map . entrySet (  								    	    print ( '-1' )					  
    if ( entry . getValue ( ) > 1 ) {			      								    								  
      System . out . print ( entry . getKey ( ) + " " ) ;     								    								  
      dup = true ;					      								    								  
    }							      								    								  
  }							      								    								  
  if ( ! dup ) {					      								    								  
    System . out . println ( "-1" ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING		      LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING		    LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING		  LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING
--							      --							    --								  --
static String lexicographicSubConcat ( String s ) {	      def lexicographicSubConcat ( s ) :			    def lexicographicSubConcat ( s ) :				  error : Traceback (most recent call last):   File
  int n = s . length ( ) ;				      	  n = len ( s )						    	n = len ( s )						  "dump/transcoder_st/eval/java_python/online_st/206
  int sub_count = n * ( n + 1 ) / 2 ;			      	  sub_count = ( n * ( n + 1 ) ) // 2			    	sub_count = n * ( n + 1 ) // 2				  68770/eval_scripts/java_sa-python_sa.test/LEXICOGR
  String [ ] arr = new String [ sub_count ] ;		      	  arr = [ 0 ] * sub_count				    	arr = [ ]						  APHICAL_CONCATENATION_SUBSTRINGS_STRING.py", line
  int index = 0 ;					      	  index = 0						    	index = 0						  64, in <module>     if f_filled(*parameters_set) =
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  = f_gold(*parameters_set):   File "dump/transcoder
  i < n ;						      	      for j in range ( 1 , n - i + 1 ) :		    	    for len in range ( 1 , n - i + 1 ) :		  _st/eval/java_python/online_st/20668770/eval_scrip
  i ++ ) for ( int len = 1 ;				      		  arr [ index ] = s [ i : i + j ]		    		arr.append ( s [ i : i + len ] )		  ts/java_sa-python_sa.test/LEXICOGRAPHICAL_CONCATEN
  len <= n - i ;					      		  index += 1					    		index += 1					  ATION_SUBSTRINGS_STRING.py", line 34, in f_filled
  len ++ ) {						      	  arr.sort ( )						    	arr.sort ( )						      n = len ( s ) UnboundLocalError: local variabl
    arr [ index ++ ] = s . substring ( i , i + len ) ;	      	  res = ""						    	res = ""						  e 'len' referenced before assignment
  }							      	  for i in range ( sub_count ) :			    	for i in range ( sub_count ) :				  
  Arrays . sort ( arr ) ;				      	      res += arr [ i ]					    	    res += arr [ i ]					  
  String res = "" ;					      	  return res						    	return res						  
  for ( int i = 0 ;					      								    								  
  i < sub_count ;					      								    								  
  i ++ ) res += arr [ i ] ;				      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP			      PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP			    PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP				  PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP
--							      --							    --								  --
static void printAllAPTriplets ( int [ ] arr , int n ) {      def printAllAPTriplets ( arr , n ) :			    def print_all_ap_triplets ( arr , n ) :			  script_not_found : None
  ArrayList < Integer > s = new ArrayList < Integer > ( ) ;   	  s = [ ]						    	s = [ ]							  
  for ( int i = 0 ;					      	  for i in range ( 0 , n - 1 ) :			    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) {						      		  diff = arr [ j ] - arr [ i ]			    		diff = arr [ j ] - arr [ i ]			  
    for ( int j = i + 1 ;				      		  if ( ( arr [ i ] - diff ) in arr ) :		    		exists = arr [ i ] - diff in s			  
    j < n ;						      		      print ( "{} {} {}".format ( ( arr [ i ] - dif 		if exists :					  
    j ++ ) {						      	  s.append ( arr [ i ] )				    		    print ( arr [ i ] - diff , arr [ i ] , arr [  
      int diff = arr [ j ] - arr [ i ] ;		      								    	    s.append ( arr [ i ] )				  
      boolean exists = s . contains ( arr [ i ] - diff ) ;    								    								  
      if ( exists ) System . out . println ( arr [ i ] - diff 								    								  
    }							      								    								  
    s . add ( arr [ i ] ) ;				      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR
--							      --							    --								  --
static void alternateSubarray ( boolean arr [ ] , int n ) {   def alternateSubarray ( arr , n ) :			    def alternate_substring ( arr , n ) :			  script_not_found : None
  int len [ ] = new int [ n ] ;				      	  len = [ ]						    	s = [ 0 ] * n						  
  len [ n - 1 ] = 1 ;					      	  for i in range ( n + 1 ) :				    	s [ n - 1 ] = 1						  
  for ( int i = n - 2 ;					      	      len.append ( 0 )					    	for i in range ( n - 2 , - 1 , - 1 ) :			  
  i >= 0 ;						      	  len [ n - 1 ] = 1					    	    if arr [ i ] ^ arr [ i + 1 ] == True :		  
  -- i ) {						      	  for i in range ( n - 2 , - 1 , - 1 ) :		    		s [ i ] = s [ i + 1 ] + 1			  
    if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len  	      if ( arr [ i ] ^ arr [ i + 1 ] == True ) :	    	    else :						  
    else len [ i ] = 1 ;				      		  len [ i ] = len [ i + 1 ] + 1			    		s [ i ] = 1					  
  }							      	      else :						    	for i in range ( n ) :					  
  for ( int i = 0 ;					      		  len [ i ] = 1					    	    print ( s , end = ' ' )				  
  i < n ;						      	  for i in range ( n ) :				    								  
  ++ i ) System . out . print ( len [ i ] + " " ) ;	      	      print ( len [ i ] , "" , end = "" )		    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHIFT_MATRIX_ELEMENTS_K					      SHIFT_MATRIX_ELEMENTS_K					    SHIFT_MATRIX_ELEMENTS_K					  SHIFT_MATRIX_ELEMENTS_K
--							      --							    --								  --
static void shiftMatrixByK ( int [ ] [ ] mat , int k ) {      def shiftMatrixByK ( mat , k ) :				    def shift_matrix_by_k ( mat , k ) :				  script_not_found : None
  if ( k > N ) {					      	  if ( k > N ) :					    	if k > N :						  
    System . out . print ( "Shifting is" + " not possible" )  	      print ( "shifting is"" not possible" )		    	    print ( "Shifting is" , " not possible" , end = " " ) 
    return ;						      	      return						    	    return						  
  }							      	  j = 0							    	j = 0							  
  int j = 0 ;						      	  while ( j < N ) :					    	while j < N :						  
  while ( j < N ) {					      	      for i in range ( k , N ) :			    	    for i in range ( k , N ) :				  
    for ( int i = k ;					      		  print ( "{} ".format ( mat [ j ] [ i ] ) , end =  		print ( "%d " % ( mat [ j ] [ i ] ) , end = " " ) 
    i < N ;						      	      for i in range ( 0 , k ) :			    	    for i in range ( k ) :				  
    i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ;   		  print ( "{} ".format ( mat [ j ] [ i ] ) , end =  		print ( "%d " % ( mat [ j ] [ i ] ) , end = " " ) 
    for ( int i = 0 ;					      	      print ( "" )					    	    print ( )						  
    i < k ;						      	      j = j + 1						    	    j += 1						  
    i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ;   								    								  
    System . out . println ( ) ;			      								    								  
    j ++ ;						      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION			      PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION			    PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION			  PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION
--							      --							    --								  --
static void decToHexa ( int n ) {			      def decToHexa ( n ) :					    def dec_to_hexa ( n ) :					  script_not_found : None
  char [ ] hexaDeciNum = new char [ 100 ] ;		      	  hexaDeciNum = [ '0' ] * 100				    	hexadeci_num = [ ]					  
  int i = 0 ;						      	  i = 0							    	i = 0							  
  while ( n != 0 ) {					      	  while ( n != 0 ) :					    	while n != 0 :						  
    int temp = 0 ;					      	      temp = 0						    	    temp = 0						  
    temp = n % 16 ;					      	      temp = n % 16					    	    temp = n % 16					  
    if ( temp < 10 ) {					      	      if ( temp < 10 ) :				    	    if temp < 10 :					  
      hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ;	      		  hexaDeciNum [ i ] = chr ( temp + 48 )		    		hexadeci_num.append ( chr ( temp + 48 ) )	  
      i ++ ;						      		  i = i + 1					    		i += 1						  
    }							      	      else :						    	    else :						  
    else {						      		  hexaDeciNum [ i ] = chr ( temp + 55 )		    		hexadeci_num.append ( chr ( temp + 55 ) )	  
      hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ;	      		  i = i + 1					    		i += 1						  
      i ++ ;						      	      n = int ( n / 16 )				    	    n = n // 16						  
    }							      	  j = i - 1						    	for j in range ( i - 1 , - 1 , - 1 ) :			  
    n = n / 16 ;					      	  while ( j >= 0 ) :					    	    sys.stdout.write ( hexadeci_num [ j ] )		  
  }							      	      print ( ( hexaDeciNum [ j ] ) , end = "" )	    								  
  for ( int j = i - 1 ;					      	      j = j - 1						    								  
  j >= 0 ;						      								    								  
  j -- ) System . out . print ( hexaDeciNum [ j ] ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A
--							      --							    --								  --
static int findmin ( Point p [ ] , int n ) {		      def findmin ( p , n ) :					    def findmin ( p , n ) :					  script_not_found : None
  int a = 0 , b = 0 , c = 0 , d = 0 ;			      	  a , b , c , d = 0 , 0 , 0 , 0				    	a , b , c , d = 0 , 0 , 0 , 0 , 0			  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( p [ i ] [ 0 ] <= 0 ) :			    	    if p [ i ] [ 0 ] <= 0 :				  
  i ++ ) {						      		  a += 1					    		a += 1						  
    if ( p [ i ] . x <= 0 ) a ++ ;			      	      elif ( p [ i ] [ 0 ] >= 0 ) :			    	    elif p [ i ] [ 0 ] >= 0 :				  
    else if ( p [ i ] . x >= 0 ) b ++ ;			      		  b += 1					    		b += 1						  
    if ( p [ i ] . y >= 0 ) c ++ ;			      	      if ( p [ i ] [ 1 ] >= 0 ) :			    	    if p [ i ] [ 1 ] >= 0 :				  
    else if ( p [ i ] . y <= 0 ) d ++ ;			      		  c += 1					    		c += 1						  
  }							      	      elif ( p [ i ] [ 1 ] <= 0 ) :			    	    elif p [ i ] [ 1 ] <= 0 :				  
  return Math . min ( Math . min ( a , b ) , Math . min ( c , 		  d += 1					    		d += 1						  
}							      	  return min ( [ a , b , c , d ] )			    	return min ( min ( a , b ) , min ( c , d ) )		  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_DECIMAL_FRACTION_BINARY_NUMBER			      CONVERT_DECIMAL_FRACTION_BINARY_NUMBER			    CONVERT_DECIMAL_FRACTION_BINARY_NUMBER			  CONVERT_DECIMAL_FRACTION_BINARY_NUMBER
--							      --							    --								  --
static String decimalToBinary ( double num , int k_prec ) {   def decimalToBinary ( num , k_prec ) :			    def decimal_to_binary ( num , k_prec ) :			  script_not_found : None
  String binary = "" ;					      	  binary = ""						    	binary = ""						  
  int Integral = ( int ) num ;				      	  Integral = int ( num )				    	Integral = int ( num )					  
  double fractional = num - Integral ;			      	  fractional = num - Integral				    	fractional = num - Integral				  
  while ( Integral > 0 ) {				      	  while ( Integral ) :					    	while Integral > 0 :					  
    int rem = Integral % 2 ;				      	      rem = Integral % 2				    	    rem = Integral % 2					  
    binary += ( ( char ) ( rem + '0' ) ) ;		      	      binary += str ( rem )				    	    binary += chr ( rem + ord ( '0' ) )			  
    Integral /= 2 ;					      	      Integral //= 2					    	    Integral //= 2					  
  }							      	  binary = binary [ : : - 1 ]				    	binary = reverse ( binary )				  
  binary = reverse ( binary ) ;				      	  binary += '.'						    	binary += ( '.' )					  
  binary += ( '.' ) ;					      	  while ( k_prec ) :					    	while k_prec > 0 :					  
  while ( k_prec -- > 0 ) {				      	      fractional *= 2					    	    fractional *= 2					  
    fractional *= 2 ;					      	      fract_bit = int ( fractional )			    	    frac_bit = int ( fractional )			  
    int fract_bit = ( int ) fractional ;		      	      if ( fract_bit == 1 ) :				    	    if frac_bit == 1 :					  
    if ( fract_bit == 1 ) {				      		  fractional -= fract_bit			    		fractional -= frac_bit				  
      fractional -= fract_bit ;				      		  binary += '1'					    		binary += chr ( 1 + ord ( '0' ) )		  
      binary += ( char ) ( 1 + '0' ) ;			      	      else :						    	    else :						  
    }							      		  binary += '0'					    		binary += chr ( 0 + ord ( '0' ) )		  
    else {						      	      k_prec -= 1					    	return binary						  
      binary += ( char ) ( 0 + '0' ) ;			      	  return binary						    								  
    }							      								    								  
  }							      								    								  
  return binary ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT
--							      --							    --								  --
static int minCost ( int cost [ ] [ ] ) {		      def minCost ( cost ) :					    def min_cost ( cost ) :					  script_not_found : None
  int dist [ ] = new int [ N ] ;			      	  dist = [ 0 for i in range ( N ) ]			    	dist = [ 0 ] * N					  
  for ( int i = 0 ;					      	  for i in range ( N ) :				    	for i in range ( N ) :					  
  i < N ;						      	      dist [ i ] = INF					    	    dist [ i ] = INF					  
  i ++ ) dist [ i ] = INF ;				      	  dist [ 0 ] = 0					    	dist [ 0 ] = 0						  
  dist [ 0 ] = 0 ;					      	  for i in range ( N ) :				    	for i in range ( N ) :					  
  for ( int i = 0 ;					      	      for j in range ( i + 1 , N ) :			    	    for j in range ( i + 1 , N ) :			  
  i < N ;						      		  if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) 		if dist [ j ] > dist [ i ] + cost [ i ] [ j ] :	  
  i ++ ) for ( int j = i + 1 ;				      		      dist [ j ] = dist [ i ] + cost [ i ] [ j ]    		    dist [ j ] = dist [ i ] + cost [ i ] [ j ]	  
  j < N ;						      	  return dist [ N - 1 ]					    	return dist [ N - 1 ]					  
  j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) di 								    								  
  return dist [ N - 1 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_ DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_ DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_ DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_
--							      --							    --								  --
static int findDiff ( int arr [ ] , int n ) {		      def findDiff ( arr , n ) :				    def find_diff ( arr , n ) :					  script_not_found : None
  Map < Integer , Integer > mp = new HashMap < > ( ) ;	      	  mp = defaultdict ( lambda : 0 )			    	mp = { }						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      mp [ arr [ i ] ] += 1				    	    if arr [ i ] in mp :				  
  i ++ ) {						      	  max_count = 0 min_count = n				    		mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1		  
    if ( mp . containsKey ( arr [ i ] ) ) {		      	  for key , values in mp.items ( ) :			    	    else :						  
      mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ;   	      max_count = max ( max_count , values )		    		mp [ arr [ i ] ] = 1				  
    }							      	      min_count = min ( min_count , values )		    	max_count , min_count = 0 , n				  
    else {						      	  return max_count - min_count				    	for x , count in mp.items ( ) :				  
      mp . put ( arr [ i ] , 1 ) ;			      								    	    max_count = max ( max_count , count )		  
    }							      								    	    min_count = min ( min_count , count )		  
  }							      								    	return ( max_count - min_count )			  
  int max_count = 0 , min_count = n ;			      								    								  
  for ( Map . Entry < Integer , Integer > x : mp . entrySet ( 								    								  
    max_count = Math . max ( max_count , x . getValue ( ) ) ; 								    								  
    min_count = Math . min ( min_count , x . getValue ( ) ) ; 								    								  
  }							      								    								  
  return ( max_count - min_count ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ENTRINGER_NUMBER_1					      ENTRINGER_NUMBER_1					    ENTRINGER_NUMBER_1						  ENTRINGER_NUMBER_1
--							      --							    --								  --
static int zigzag ( int n , int k ) {			      def zigzag ( n , k ) :					    def zigzag ( n , k ) :					  script_not_found : None
  int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ;	      	  dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n  	dp = np.zeros ( ( n + 1 , k + 1 ) )			  
  dp [ 0 ] [ 0 ] = 1 ;					      	  dp [ 0 ] [ 0 ] = 1					    	dp [ 0 ] [ 0 ] = 1					  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	      dp [ i ] [ 0 ] = 0				    	    dp [ i ] [ 0 ] = 0					  
  i ++ ) dp [ i ] [ 0 ] = 0 ;				      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  for ( int i = 1 ;					      	      for j in range ( 1 , k + 1 ) :			    	    for j in range ( 1 , min ( i , k ) + 1 ) :		  
  i <= n ;						      		  dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i -  		dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1  
  i ++ ) {						      	  return dp [ n ] [ k ]					    	return dp [ n ] [ k ]					  
    for ( int j = 1 ;					      								    								  
    j <= Math . min ( i , k ) ;				      								    								  
    j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] 								    								  
  }							      								    								  
  return dp [ n ] [ k ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2		      FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2		    FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2			  FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2
--							      --							    --								  --
static void printDivisors ( int n ) {			      def printDivisors ( n ) :					    def print_divisors ( n ) :					  script_not_found : None
  Vector < Integer > v = new Vector < > ( ) ;		      	  list = [ ]						    	v = [ ]							  
  for ( int i = 1 ;					      	  for i in range ( 1 , int ( math.sqrt ( n ) + 1 ) ) :	    	for i in range ( 1 , math.sqrt ( n ) + 1 ) :		  
  i <= Math . sqrt ( n ) ;				      	      if ( n % i == 0 ) :				    	    if n % i == 0 :					  
  i ++ ) {						      		  if ( n / i == i ) :				    		if n / i == i :					  
    if ( n % i == 0 ) {					      		      print ( i , end = " " )			    		    print ( i )					  
      if ( n / i == i ) System . out . printf ( "%d " , i ) ; 		  else :					    		else :						  
      else {						      		      print ( i , end = " " )			    		    print ( i )					  
	System . out . printf ( "%d " , i ) ;		      		      list.append ( int ( n / i ) )		    		    v.append ( n / i )				  
	v . add ( n / i ) ;				      	  for i in list [ : : - 1 ] :				    	for i in v [ : : - 1 ] :				  
      }							      	      print ( i , end = " " )				    	    print ( i )						  
    }							      								    								  
  }							      								    								  
  for ( int i = v . size ( ) - 1 ;			      								    								  
  i >= 0 ;						      								    								  
  i -- ) System . out . printf ( "%d " , v . get ( i ) ) ;    								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1    DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1    DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1	  DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1
--							      --							    --								  --
static int lis ( int arr [ ] , int n ) {		      def lis ( arr ) :						    def lis ( arr , n ) :					  script_not_found : None
  int lis [ ] = new int [ n ] ;				      	  n = len ( arr )					    	lis = [ 0 ] * n						  
  int i , j , max = 0 ;					      	  lis = [ 1 ] * n					    	i , j , max = 0 , 0 , 0					  
  for ( i = 0 ;						      	  for i in range ( 1 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( 0 , i ) :			    	    lis [ i ] = 1					  
  i ++ ) lis [ i ] = 1 ;				      		  if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j  	for i in range ( 1 , n ) :				  
  for ( i = 1 ;						      		      lis [ i ] = lis [ j ] + 1			    	    for j in range ( i ) :				  
  i < n ;						      	  maximum = 0						    		if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j  
  i ++ ) for ( j = 0 ;					      	  for i in range ( n ) :				    		    lis [ i ] = lis [ j ] + 1			  
  j < i ;						      	      maximum = max ( maximum , lis [ i ] )		    	for i in range ( n ) :					  
  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ]  	  return maximum					    	    if max < lis [ i ] :				  
  for ( i = 0 ;						      								    		max = lis [ i ]					  
  i < n ;						      								    	return max						  
  i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;	      								    								  
  return max ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE
--							      --							    --								  --
static void solve ( int i , int par , int a [ ] , int n , int def solve ( i , par , a , n , k , current_ans ) :		    def solve ( i , par , a , n , k , current_ans ) :		  script_not_found : None
  if ( par > k ) return ;				      	  if ( par > k ) :					    	if par > k :						  
  if ( par == k && i == n - 1 ) {			      	      return 0						    	    return						  
    ans = Math . min ( ans , current_ans ) ;		      	  global ans						    	if par == k and i == n - 1 :				  
    return ;						      	  if ( par == k and i == n - 1 ) :			    	    ans = min ( ans , current_ans )			  
  }							      	      ans = min ( ans , current_ans )			    	    return						  
  for ( int j = i + 1 ;					      	      return 0						    	for j in range ( i + 1 , n ) :				  
  j < n ;						      	  for j in range ( i + 1 , n ) :			    	    solve ( j , par + 1 , a , n , k , current_ans + ( a [ 
  j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a  	      solve ( j , par + 1 , a , n , k , current_ans + ( a [ 								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED		      MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED		    MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED		  MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED
--							      --							    --								  --
static void segregateElements ( int arr [ ] , int n ) {	      def segregateElements ( arr , n ) :			    def segregateElements ( arr , n ) :				  success : None
  int temp [ ] = new int [ n ] ;			      	  temp = [ 0 for k in range ( n ) ]			    	temp = [ 0 ] * n					  
  int j = 0 ;						      	  j = 0							    	j = 0							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( arr [ i ] >= 0 ) :				    	    if arr [ i ] >= 0 :					  
  i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ;    		  temp [ j ] = arr [ i ]			    		temp [ j ] = arr [ i ]				  
  if ( j == n || j == 0 ) return ;			      		  j += 1					    		j += 1						  
  for ( int i = 0 ;					      	  if ( j == n or j == 0 ) :				    	if j == n or j == 0 :					  
  i < n ;						      	      return						    	    return						  
  i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ;     	  for i in range ( n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      if ( arr [ i ] < 0 ) :				    	    if arr [ i ] < 0 :					  
  i < n ;						      		  temp [ j ] = arr [ i ]			    		temp [ j ] = arr [ i ]				  
  i ++ ) arr [ i ] = temp [ i ] ;			      		  j += 1					    		j += 1						  
}							      	  for k in range ( n ) :				    	for i in range ( n ) :					  
							      	      arr [ k ] = temp [ k ]				    	    arr [ i ] = temp [ i ]				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS	      LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS	    LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS	  LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS
--							      --							    --								  --
public static void findFibSubset ( Integer [ ] x ) {	      def findFibSubset ( arr , n ) :				    def find_fib_subset ( x = None ) :				  script_not_found : None
  Integer max = Collections . max ( Arrays . asList ( x ) ) ; 	  m = max ( arr )					    	max = max ( x )						  
  List < Integer > fib = new ArrayList < Integer > ( ) ;      	  a = 0							    	fib = [ ]						  
  List < Integer > result = new ArrayList < Integer > ( ) ;   	  b = 1							    	result = [ ]						  
  Integer a = 0 ;					      	  hash = [ ]						    	a = 0							  
  Integer b = 1 ;					      	  hash.append ( a )					    	b = 1							  
  while ( b < max ) {					      	  hash.append ( b )					    	while b < max :						  
    Integer c = a + b ;					      	  while ( b < m ) :					    	    c = a + b						  
    a = b ;						      	      c = a + b						    	    a = b						  
    b = c ;						      	      a = b						    	    b = c						  
    fib . add ( c ) ;					      	      b = c						    	    fib.append ( c )					  
  }							      	      hash.append ( b )					    	for i in x :						  
  for ( Integer i = 0 ;					      	  for i in range ( n ) :				    	    if i in fib :					  
  i < x . length ;					      	      if arr [ i ] in hash :				    		result.append ( i )				  
  i ++ ) {						      		  print ( arr [ i ] , end = " " )		    	print ( result )					  
    if ( fib . contains ( x [ i ] ) ) {			      								    								  
      result . add ( x [ i ] ) ;			      								    								  
    }							      								    								  
  }							      								    								  
  System . out . println ( result ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAJORITY_ELEMENT_1					      MAJORITY_ELEMENT_1					    MAJORITY_ELEMENT_1						  MAJORITY_ELEMENT_1
--							      --							    --								  --
private static void findMajority ( int [ ] arr ) {	      def findMajority ( arr , size ) :				    def find_majority ( arr ) :					  script_not_found : None
  HashMap < Integer , Integer > map = new HashMap < Integer , 	  m = { }						    	d = { }							  
  for ( int i = 0 ;					      	  for i in range ( size ) :				    	for i in range ( len ( arr ) ) :			  
  i < arr . length ;					      	      if arr [ i ] in m :				    	    if arr [ i ] in d :					  
  i ++ ) {						      		  m [ arr [ i ] ] += 1				    		count = d [ arr [ i ] ] + 1			  
    if ( map . containsKey ( arr [ i ] ) ) {		      	      else :						    		if count > len ( arr ) // 2 :			  
      int count = map . get ( arr [ i ] ) + 1 ;		      		  m [ arr [ i ] ] = 1				    		    print ( 'Majority found :- %d' % arr [ i ] )  
      if ( count > arr . length / 2 ) {			      	  count = 0						    		    return					  
	System . out . println ( "Majority found :- " + arr [ 	  for key in m :					    		else :						  
	return ;					      	      if m [ key ] > size / 2 :				    		    d [ arr [ i ] ] = count			  
      }							      		  count = 1					    	    else :						  
      else map . put ( arr [ i ] , count ) ;		      		  print ( "Majority found :-" , key )		    		d [ arr [ i ] ] = 1				  
    }							      		  break						    	print ( 'No Majority element' )				  
    else map . put ( arr [ i ] , 1 ) ;			      	  if ( count == 0 ) :					    								  
  }							      	      print ( "No Majority element" )			    								  
  System . out . println ( " No Majority element" ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS		      COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS		    COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS		  COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS
--							      --							    --								  --
static int countNums ( int n , int x , int y ) {	      def countNums ( n , x , y ) :				    def count_nums ( n , x , y ) :				  success : None
  boolean [ ] arr = new boolean [ n + 1 ] ;		      	  arr = [ False for i in range ( n + 2 ) ]		    	arr = [ False ] * ( n + 1 )				  
  if ( x <= n ) arr [ x ] = true ;			      	  if ( x <= n ) :					    	if x <= n :						  
  if ( y <= n ) arr [ y ] = true ;			      	      arr [ x ] = True					    	    arr [ x ] = True					  
  int result = 0 ;					      	  if ( y <= n ) :					    	if y <= n :						  
  for ( int i = Math . min ( x , y ) ;			      	      arr [ y ] = True					    	    arr [ y ] = True					  
  i <= n ;						      	  result = 0						    	result = 0						  
  i ++ ) {						      	  for i in range ( min ( x , y ) , n + 1 ) :		    	for i in range ( min ( x , y ) , n + 1 ) :		  
    if ( arr [ i ] ) {					      	      if ( arr [ i ] ) :				    	    if arr [ i ] :					  
      if ( i + x <= n ) arr [ i + x ] = true ;		      		  if ( i + x <= n ) :				    		if i + x <= n :					  
      if ( i + y <= n ) arr [ i + y ] = true ;		      		      arr [ i + x ] = True			    		    arr [ i + x ] = True			  
      result ++ ;					      		  if ( i + y <= n ) :				    		if i + y <= n :					  
    }							      		      arr [ i + y ] = True			    		    arr [ i + y ] = True			  
  }							      		  result = result + 1				    		result += 1					  
  return result ;					      	  return result						    	return result						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION		      MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION		    MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION		  MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION
--							      --							    --								  --
static int getMinSteps ( int n ) {			      def getMinSteps ( n ) :					    def get_min_steps ( n ) :					  success : None
  int table [ ] = new int [ n + 1 ] ;			      	  table = [ 0 ] * ( n + 1 )				    	table = [ 0 ] * ( n + 1 )				  
  for ( int i = 0 ;					      	  for i in range ( n + 1 ) :				    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      table [ i ] = n - i				    	    table [ i ] = n - i					  
  i ++ ) table [ i ] = n - i ;				      	  for i in range ( n , 0 , - 1 ) :			    	for i in range ( n , 1 , - 1 ) :			  
  for ( int i = n ;					      	      if ( not ( i % 2 ) ) :				    	    if not ( i % 2 > 0 ) :				  
  i >= 1 ;						      		  table [ i // 2 ] = min ( table [ i ] + 1 , table  		table [ i // 2 ] = min ( table [ i ] + 1 , table  
  i -- ) {						      	      if ( not ( i % 3 ) ) :				    	    if not ( i % 3 > 0 ) :				  
    if ( ! ( i % 2 > 0 ) ) table [ i / 2 ] = Math . min ( tab 		  table [ i // 3 ] = min ( table [ i ] + 1 , table  		table [ i // 3 ] = min ( table [ i ] + 1 , table  
    if ( ! ( i % 3 > 0 ) ) table [ i / 3 ] = Math . min ( tab 	  return table [ 1 ]					    	return table [ 1 ]					  
  }							      								    								  
  return table [ 1 ] ;					      								    								  
  -							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_ MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_ MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_ MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_
--							      --							    --								  --
static int countManipulations ( String s1 , String s2 ) {     def countManipulations ( s1 , s2 ) :			    def count_manipulation ( s1 , s2 ) :			  script_not_found : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  int char_count [ ] = new int [ 26 ] ;			      	  char_count = [ 0 ] * 26				    	char_count = [ 0 ] * 26					  
  for ( int i = 0 ;					      	  for i in range ( 26 ) :				    	for c in s1 :						  
  i < s1 . length ( ) ;					      	      char_count [ i ] = 0				    	    char_count [ ord ( c ) - ord ( 'a' ) ] += 1		  
  i ++ ) char_count [ s1 . charAt ( i ) - 'a' ] ++ ;	      	  for i in range ( len ( s1 ) ) :			    	for c in s2 :						  
  for ( int i = 0 ;					      	      char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1    	    if char_count [ ord ( c ) - ord ( 'a' ) ] <= 0 :	  
  i < s2 . length ( ) ;					      	  for i in range ( len ( s2 ) ) :			    		count += 1					  
  i ++ ) if ( char_count [ s2 . charAt ( i ) - 'a' ] -- <= 0  	      char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] -= 1    	return count						  
  return count ;					      	      if ( char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] <  								  
}							      		  count += 1					    								  
							      	  return count						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI
--							      --							    --								  --
static int stringReduction ( String str ) {		      def stringReduction ( str ) :				    def string_reduction ( str ) :				  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  int count [ ] = new int [ 3 ] ;			      	  count = [ 0 ] * 3					    	count = [ 0 ] * 3					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for c in str :						  
  i < n ;						      	      count [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1	    	    count [ ord ( c ) - ord ( 'a' ) ] += 1		  
  ++ i ) {						      	  if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ]  	if count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == 
    count [ str . charAt ( i ) - 'a' ] ++ ;		      	      return n						    	    return n						  
  }							      	  if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( cou 	if ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count 
  if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == 	      return 2						    	    return 2						  
    return n ;						      	  return 1						    	return 1						  
  }							      								    								  
  if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count  								    								  
    return 2 ;						      								    								  
  }							      								    								  
  return 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS		      COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS			    COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS			  COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS
--							      --							    --								  --
static long countWays ( int n ) {			      def countWays ( n ) :					    def count_ways ( n ) :					  failure : #Results: 3, 10
  long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ;		      	  dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ]	    	dp = np.zeros ( ( 2 , n + 1 ) )				  
  dp [ 0 ] [ 1 ] = 1 ;					      	  dp [ 0 ] [ 1 ] = 1					    	dp [ 0 ] [ 1 ] = 1					  
  dp [ 1 ] [ 1 ] = 2 ;					      	  dp [ 1 ] [ 1 ] = 2					    	dp [ 1 ] [ 1 ] = 2					  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	      dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i -  	    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i -  
  i ++ ) {						      	      dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ]  	    dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [  
    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ]  	  return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]		    	return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]			  
    dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i -  								    								  
  }							      								    								  
  return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M	      DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M	    DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M		  DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M
--							      --							    --								  --
static int numberofways ( int n , int m ) {		      def numberofways ( n , m ) :				    def numberofways ( n , m ) :				  script_not_found : None
  int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ;	      	  dp = np.zeros ( ( n + 2 , n + 2 ) )			    	dp = np.zeros ( ( n + 2 , n + 2 ) )			  
  dp [ 0 ] [ n + 1 ] = 1 ;				      	  dp [ 0 ] [ n + 1 ] = 1				    	dp [ 0 ] [ n + 1 ] = 1					  
  for ( int k = n ;					      	  for k in range ( n , m - 1 , - 1 ) :			    	for k in range ( n , m - 1 , - 1 ) :			  
  k >= m ;						      	      for i in range ( n + 1 ) :			    	    for i in range ( 0 , n + 1 ) :			  
  k -- ) {						      		  dp [ i ] [ k ] = dp [ i ] [ k + 1 ]		    		dp [ i ] [ k ] = dp [ i ] [ k + 1 ]		  
    for ( int i = 0 ;					      		  if ( i - k >= 0 ) :				    		if i - k >= 0 :					  
    i <= n ;						      		      dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i -  		    dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i -  
    i ++ ) {						      	  return dp [ n ] [ m ]					    	return dp [ n ] [ m ]					  
      dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ;		      								    								  
      if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + d 								    								  
    }							      								    								  
  }							      								    								  
  return dp [ n ] [ m ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER			      DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER			    DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER			  DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER
--							      --							    --								  --
static boolean isDvisibleBy12 ( String num ) {		      def isDvisibleBy12 ( num ) :				    def is_dvisible_by_12 ( num ) :				  script_not_found : None
  if ( num . length ( ) >= 3 ) {			      	  if ( len ( num ) >= 3 ) :				    	if len ( num ) >= 3 :					  
    int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ;  	      d1 = int ( num [ len ( num ) - 1 ] )		    	    d1 = ord ( num [ - 1 ] )				  
    if ( d1 % 2 != 0 ) return false ;			      	      if ( d1 % 2 != 0 ) :				    	    if d1 % 2 :						  
    int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ;  		  return False					    		return False					  
    int sum = 0 ;					      	      d2 = int ( num [ len ( num ) - 2 ] )		    	    d2 = ord ( num [ - 2 ] )				  
    for ( int i = 0 ;					      	      sum = 0						    	    sum = 0						  
    i < num . length ( ) ;				      	      for i in range ( 0 , len ( num ) ) :		    	    for c in num :					  
    i ++ ) sum += num . charAt ( i ) ;			      		  sum += int ( num [ i ] )			    		sum += ord ( c )				  
    return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ;    	      return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) 	    return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) 
  }							      	  else :						    	else :							  
  else {						      	      number = int ( num )				    	    number = int ( num )				  
    int number = Integer . parseInt ( num ) ;		      	      return ( number % 12 == 0 )			    	    return ( number % 12 == 0 )				  
    return ( number % 12 == 0 ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
OVERLAPPING_SUM_TWO_ARRAY				      OVERLAPPING_SUM_TWO_ARRAY					    OVERLAPPING_SUM_TWO_ARRAY					  OVERLAPPING_SUM_TWO_ARRAY
--							      --							    --								  --
static int findSum ( int [ ] A , int [ ] B , int n ) {	      def findSum ( A , B , n ) :				    def find_sum ( A , B , n ) :				  script_not_found : None
  HashMap < Integer , Integer > hash = new HashMap < > ( ) ;  	  Hash = defaultdict ( lambda : 0 )			    	hash = { }						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      Hash [ A [ i ] ] += 1				    	    if A [ i ] in hash :				  
  i ++ ) {						      	      Hash [ B [ i ] ] += 1				    		hash [ A [ i ] ] = 1 + hash [ A [ i ] ]		  
    if ( hash . containsKey ( A [ i ] ) ) hash . put ( A [ i  	  Sum = 0						    	    else :						  
    else hash . put ( A [ i ] , 1 ) ;			      	  for x in Hash :					    		hash [ A [ i ] ] = 1				  
    if ( hash . containsKey ( B [ i ] ) ) hash . put ( B [ i  	      if Hash [ x ] == 1 :				    	    if B [ i ] in hash :				  
    else hash . put ( B [ i ] , 1 ) ;			      		  Sum += x					    		hash [ B [ i ] ] = 1 + hash [ B [ i ] ]		  
  }							      	  return Sum						    	    else :						  
  int sum = 0 ;						      								    		hash [ B [ i ] ] = 1				  
  for ( Map . Entry entry : hash . entrySet ( ) ) {	      								    	sum = 0							  
    if ( Integer . parseInt ( ( entry . getValue ( ) ) . toSt 								    	for key , value in hash.items ( ) :			  
  }							      								    	    if int ( ( str ( value ) ) ) == 1 :			  
  return sum ;						      								    		sum += int ( ( str ( key ) ) )			  
}							      								    	return sum						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX	      MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX	    MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX	  MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX
--							      --							    --								  --
static int minOperation ( boolean arr [ ] [ ] ) {	      def minOperation ( arr ) :				    def min_operation ( arr ) :					  script_not_found : None
  int ans = 0 ;						      	  ans = 0						    	ans = 0							  
  for ( int i = N - 1 ;					      	  for i in range ( N - 1 , - 1 , - 1 ) :		    	for i in range ( N - 1 , - 1 , - 1 ) :			  
  i >= 0 ;						      	      for j in range ( M - 1 , - 1 , - 1 ) :		    	    for j in range ( M - 1 , - 1 , - 1 ) :		  
  i -- ) {						      		  if ( arr [ i ] [ j ] == 0 ) :			    		if arr [ i ] [ j ] == False :			  
    for ( int j = M - 1 ;				      		      ans += 1					    		    ans += 1					  
    j >= 0 ;						      		      for k in range ( i + 1 ) :		    		    for k in range ( 0 , i + 1 ) :		  
    j -- ) {						      			  for h in range ( j + 1 ) :		    			for h in range ( 0 , j + 1 ) :		  
      if ( arr [ i ] [ j ] == false ) {			      			      if ( arr [ k ] [ h ] == 1 ) :	    			    if arr [ k ] [ h ] == True :	  
	ans ++ ;					      				  arr [ k ] [ h ] = 0		    				arr [ k ] [ h ] = False		  
	for ( int k = 0 ;				      			      else :				    			    else :				  
	k <= i ;					      				  arr [ k ] [ h ] = 1		    				arr [ k ] [ h ] = True		  
	k ++ ) {					      	  return ans						    	return ans						  
	  for ( int h = 0 ;				      								    								  
	  h <= j ;					      								    								  
	  h ++ ) {					      								    								  
	    if ( arr [ k ] [ h ] == true ) {		      								    								  
	      arr [ k ] [ h ] = false ;			      								    								  
	    }						      								    								  
	    else {					      								    								  
	      arr [ k ] [ h ] = true ;			      								    								  
	    }						      								    								  
	  }						      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DICE_THROW_PROBLEM					      DICE_THROW_PROBLEM					    DICE_THROW_PROBLEM						  DICE_THROW_PROBLEM
--							      --							    --								  --
public static long findWays ( int m , int n , int x ) {	      def findWays ( m , n , x ) :				    def find_ways ( m , n , x ) :				  error : Traceback (most recent call last):   File
  long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ;	      	  table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ]    	table = np.zeros ( ( n + 1 , x + 1 ) )			  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int j = 1 ;					      	  for j in range ( 1 , min ( m + 1 , x + 1 ) ) :	    	for j in range ( 1 , m + 1 ) :				  68770/eval_scripts/java_sa-python_sa.test/DICE_THR
  j <= m && j <= x ;					      	      table [ 1 ] [ j ] = 1				    	    table [ 1 ] [ j ] = 1				  OW_PROBLEM.py", line 54, in <module>	   if f_fill
  j ++ ) table [ 1 ] [ j ] = 1 ;			      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  ed(*parameters_set) == f_gold(*parameters_set):
  for ( int i = 2 ;					      	      for j in range ( 1 , x + 1 ) :			    	    for j in range ( 1 , x + 1 ) :			  File "dump/transcoder_st/eval/java_python/online_s
  i <= n ;						      		  for k in range ( 1 , min ( m + 1 , j ) ) :	    		for k in range ( 1 , j , m + 1 ) :		  t/20668770/eval_scripts/java_sa-python_sa.test/DIC
  i ++ ) {						      		      table [ i ] [ j ] += table [ i - 1 ] [ j - k  		    table [ i ] [ j ] += table [ i - 1 ] [ j - k  E_THROW_PROBLEM.py", line 31, in f_filled	tabl
    for ( int j = 1 ;					      	  return table [ - 1 ] [ - 1 ]				    	return table [ n ] [ x ]				  e [ 1 ] [ j ] = 1 IndexError: index 70 is out of b
    j <= x ;						      								    								  ounds for axis 0 with size 70
    j ++ ) {						      								    								  
      for ( int k = 1 ;					      								    								  
      k < j && k <= m ;					      								    								  
      k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; 								    								  
    }							      								    								  
  }							      								    								  
  return table [ n ] [ x ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE		      FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE			    FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE			  FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE
--							      --							    --								  --
boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { def find3Numbers ( A , arr_size , sum ) :			    def find3Numbers ( A , arr_size , sum ) :			  success : None
  int l , r ;						      	  for i in range ( 0 , arr_size - 2 ) :			    	l , r = 0 , 0						  
  for ( int i = 0 ;					      	      for j in range ( i + 1 , arr_size - 1 ) :		    	for i in range ( arr_size - 2 ) :			  
  i < arr_size - 2 ;					      		  for k in range ( j + 1 , arr_size ) :		    	    for j in range ( i + 1 , arr_size - 1 ) :		  
  i ++ ) {						      		      if A [ i ] + A [ j ] + A [ k ] == sum :	    		for k in range ( j + 1 , arr_size ) :		  
    for ( int j = i + 1 ;				      			  print ( "Triplet is" , A [ i ] , ", " , A 		    if A [ i ] + A [ j ] + A [ k ] == sum :	  
    j < arr_size - 1 ;					      			  return True				    			print ( "Triplet is %d, %d, %d" % ( A [ i 
    j ++ ) {						      	  return False						    			return True				  
      for ( int k = j + 1 ;				      								    	return False						  
      k < arr_size ;					      								    								  
      k ++ ) {						      								    								  
	if ( A [ i ] + A [ j ] + A [ k ] == sum ) {	      								    								  
	  System . out . print ( "Triplet is " + A [ i ] + ", 								    								  
	  return true ;					      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S	      FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S		    FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S		  FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S
--							      --							    --								  --
static int MaxDotProduct ( int A [ ] , int B [ ] , int m , in def MaxDotProduct ( A , B , m , n ) :			    def MaxDotProduct ( A , B , m , n ) :			  success : None
  int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;	      	  dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n  	dp = [ [ 0 ] * ( n + 1 ) * ( m + 1 ) for row in range ( n 
  for ( int [ ] row : dp ) Arrays . fill ( row , 0 ) ;	      	  for i in range ( 1 , n + 1 , 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  for ( int i = 1 ;					      	      for j in range ( i , m + 1 , 1 ) :		    	    for j in range ( i , m + 1 ) :			  
  i <= n ;						      		  dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + 		dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + 
  i ++ ) for ( int j = i ;				      	  return dp [ n ] [ m ]					    	return dp [ n ] [ m ]					  
  j <= m ;						      								    								  
  j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 								    								  
  return dp [ n ] [ m ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_ALMOST_SORTED_ARRAY				      SEARCH_ALMOST_SORTED_ARRAY				    SEARCH_ALMOST_SORTED_ARRAY					  SEARCH_ALMOST_SORTED_ARRAY
--							      --							    --								  --
int binarySearch ( int arr [ ] , int l , int r , int x ) {    def binarySearch ( arr , l , r , x ) :			    def binary_search ( arr , l , r , x ) :			  error :   File "dump/transcoder_st/eval/java_pytho
  if ( r >= l ) {					      	  if ( r >= l ) :					    	if r >= l :						  n/online_st/20668770/eval_scripts/java_sa-python_s
    int mid = l + ( r - l ) / 2 ;			      	      mid = int ( l + ( r - l ) / 2 )			    	    mid = l + ( r - l ) // 2				  a.test/SEARCH_ALMOST_SORTED_ARRAY.py", line 50
    if ( arr [ mid ] == x ) return mid ;		      	      if ( arr [ mid ] == x ) : return mid		    	    if arr [ mid ] == x :				   ([-92,-96,-68,-40,70], 0, 4, ,    -96),
    if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) 	      if ( mid > l and arr [ mid - 1 ] == x ) :		    		return mid					  			  ^ SyntaxError: invalid syn
    if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) 		  return ( mid - 1 )				    	    if mid > l and arr [ mid - 1 ] == x :		  tax
    if ( arr [ mid ] > x ) return binarySearch ( arr , l , mi 	      if ( mid < r and arr [ mid + 1 ] == x ) :		    		return ( mid - 1 )				  
    return binarySearch ( arr , mid + 2 , r , x ) ;	      		  return ( mid + 1 )				    	    if mid < r and arr [ mid + 1 ] == x :		  
  }							      	      if ( arr [ mid ] > x ) :				    		return ( mid + 1 )				  
  return - 1 ;						      		  return binarySearch ( arr , l , mid - 2 , x )	    	    if arr [ mid ] > x :				  
}							      	      return binarySearch ( arr , mid + 2 , r , x )	    		return binary_search ( arr , l , mid - 2 , x )	  
							      	  return - 1						    	    return binary_search ( arr , mid + 2 , r , x )	  
							      								    	return - 1						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_N_DIGITS_NON_DECREASING_INTEGERS			      NUMBER_N_DIGITS_NON_DECREASING_INTEGERS			    NUMBER_N_DIGITS_NON_DECREASING_INTEGERS			  NUMBER_N_DIGITS_NON_DECREASING_INTEGERS
--							      --							    --								  --
static int nonDecNums ( int n ) {			      def nonDecNums ( n ) :					    def non_dec_nums ( n ) :					  script_not_found : None
  int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ;		      	  a = np.zeros ( ( n + 1 , 10 ) )			    	a = np.zeros ( ( n + 1 , 10 ) )				  
  for ( int i = 0 ;					      	  for i in range ( 10 ) :				    	for i in range ( 0 , 9 + 1 ) :				  
  i <= 9 ;						      	      a [ 0 ] [ i ] = 1					    	    a [ 0 ] [ i ] = 1					  
  i ++ ) a [ 0 ] [ i ] = 1 ;				      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  for ( int i = 1 ;					      	      a [ i ] [ 9 ] = 1					    	    a [ i ] [ 9 ] = 1					  
  i <= n ;						      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i ++ ) a [ i ] [ 9 ] = 1 ;				      	      for j in range ( 8 , - 1 , - 1 ) :		    	    for j in range ( 8 , - 1 , - 1 ) :			  
  for ( int i = 1 ;					      		  a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 		a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 
  i <= n ;						      	  return int ( a [ n ] [ 0 ] )				    	return a [ n ] [ 0 ]					  
  i ++ ) for ( int j = 8 ;				      								    								  
  j >= 0 ;						      								    								  
  j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1  								    								  
  return a [ n ] [ 0 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE     REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE	    REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE	  REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE
--							      --							    --								  --
public static void rearrange ( int arr [ ] , int n ) {	      def rearrange ( arr , n ) :				    def rearrange ( arr , n ) :					  failure : #Results: 2, 10
  int max_idx = n - 1 , min_idx = 0 ;			      	  max_idx = n - 1					    	max_idx , min_idx = n - 1 , 0				  
  int max_elem = arr [ n - 1 ] + 1 ;			      	  min_idx = 0						    	max_elem = arr [ n - 1 ] + 1				  
  for ( int i = 0 ;					      	  max_elem = arr [ n - 1 ] + 1				    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( 0 , n ) :				    	    if i % 2 == 0 :					  
  i ++ ) {						      	      if i % 2 == 0 :					    		arr [ i ] += ( arr [ max_idx ] % max_elem ) * max 
    if ( i % 2 == 0 ) {					      		  arr [ i ] += ( arr [ max_idx ] % max_elem ) * max 		max_idx -= 1					  
      arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem  		  max_idx -= 1					    	    else :						  
      max_idx -- ;					      	      else :						    		arr [ i ] += ( arr [ min_idx ] % max_elem ) * max 
    }							      		  arr [ i ] += ( arr [ min_idx ] % max_elem ) * max 		min_idx += 1					  
    else {						      		  min_idx += 1					    	for i in range ( n ) :					  
      arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem  	  for i in range ( 0 , n ) :				    	    arr [ i ] = arr [ i ] // max_elem			  
      min_idx ++ ;					      	      arr [ i ] = arr [ i ] / max_elem			    								  
    }							      								    								  
  }							      								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) arr [ i ] = arr [ i ] / max_elem ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TEMPLE_OFFERINGS					      TEMPLE_OFFERINGS						    TEMPLE_OFFERINGS						  TEMPLE_OFFERINGS
--							      --							    --								  --
static int offeringNumber ( int n , int templeHeight [ ] ) {  def offeringNumber ( n , templeHeight ) :			    def offeringNumber ( n , templeHeight ) :			  success : None
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      left = 0						    	    left , right = 0 , 0				  
  ++ i ) {						      	      right = 0						    	    for j in range ( i - 1 , - 1 , - 1 ) :		  
    int left = 0 , right = 0 ;				      	      for j in range ( i - 1 , - 1 , - 1 ) :		    		if templeHeight [ j ] < templeHeight [ j + 1 ] :  
    for ( int j = i - 1 ;				      		  if ( templeHeight [ j ] < templeHeight [ j + 1 ]  		    left += 1					  
    j >= 0 ;						      		      left += 1					    		else :						  
    -- j ) {						      		  else :					    		    break					  
      if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ l 		      break					    	    for j in range ( i + 1 , n ) :			  
      else break ;					      	      for j in range ( i + 1 , n ) :			    		if templeHeight [ j ] < templeHeight [ j - 1 ] :  
    }							      		  if ( templeHeight [ j ] < templeHeight [ j - 1 ]  		    right += 1					  
    for ( int j = i + 1 ;				      		      right += 1				    		else :						  
    j < n ;						      		  else :					    		    break					  
    ++ j ) {						      		      break					    	    sum += max ( right , left ) + 1			  
      if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ r 	      sum += max ( right , left ) + 1			    	return sum						  
      else break ;					      	  return sum						    								  
    }							      								    								  
    sum += Math . max ( right , left ) + 1 ;		      								    								  
  }							      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT			      FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT			    FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT				  FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT
--							      --							    --								  --
static void possibleOrNot ( long a1 , long a2 , long b1 , lon def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) :	    def possible_or_not ( a1 , a2 , b1 , b2 , c1 , c2 ) :	  script_not_found : None
  long dis1 = ( long ) Math . pow ( b1 - a1 , 2 ) + ( long )  	  dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) )	    	dis1 = int ( math.pow ( b1 - a1 , 2 ) ) + int ( math.pow  
  long dis2 = ( long ) Math . pow ( c1 - b1 , 2 ) + ( long )  	  dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) )	    	dis2 = int ( math.pow ( c1 - b1 , 2 ) ) + int ( math.pow  
  if ( dis1 != dis2 ) System . out . print ( "No" ) ;	      	  if ( dis1 != dis2 ) :					    	if dis1 != dis2 :					  
  else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2  	      print ( "No" )					    	    print ( "No" , end = "" )				  
  else System . out . print ( "Yes" ) ;			      	  elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 	elif b1 == ( ( a1 + c1 ) / 2.0 ) and b2 == ( ( a2 + c2 )  
}							      	      print ( "No" )					    	    print ( "No" , end = "" )				  
							      	  else :						    	else :							  
							      	      print ( "Yes" )					    	    print ( "Yes" , end = "" )				  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1	      MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1		    MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1		  MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1
--							      --							    --								  --
static int smallestSubWithSum ( int arr [ ] , int n , int x ) def smallestSubWithSum ( arr , n , x ) :			    def smallest_sub_with_sum ( arr , n , x ) :			  success : None
  int curr_sum = 0 , min_len = n + 1 ;			      	  curr_sum = 0						    	curr_sum , min_len = 0 , n + 1				  
  int start = 0 , end = 0 ;				      	  min_len = n + 1					    	start , end = 0 , 0					  
  while ( end < n ) {					      	  start = 0						    	while end < n :						  
    while ( curr_sum <= x && end < n ) {		      	  end = 0						    	    while curr_sum <= x and end < n :			  
      if ( curr_sum <= 0 && x > 0 ) {			      	  while ( end < n ) :					    		if curr_sum <= 0 and x > 0 :			  
	start = end ;					      	      while ( curr_sum <= x and end < n ) :		    		    start = end					  
	curr_sum = 0 ;					      		  if ( curr_sum <= 0 and x > 0 ) :		    		    curr_sum = 0				  
      }							      		      start = end				    		curr_sum += arr [ end ]				  
      curr_sum += arr [ end ++ ] ;			      		      curr_sum = 0				    		end += 1					  
    }							      		  curr_sum += arr [ end ]			    	    while curr_sum > x and start < n :			  
    while ( curr_sum > x && start < n ) {		      		  end += 1					    		if end - start < min_len :			  
      if ( end - start < min_len ) min_len = end - start ;    	      while ( curr_sum > x and start < n ) :		    		    min_len = end - start			  
      curr_sum -= arr [ start ++ ] ;			      		  if ( end - start < min_len ) :		    		curr_sum -= arr [ start ]			  
    }							      		      min_len = end - start			    		start += 1					  
  }							      		  curr_sum -= arr [ start ]			    	return min_len						  
  return min_len ;					      		  start += 1					    								  
}							      	  return min_len					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIME_FACTORS_BIG_NUMBER				      PRIME_FACTORS_BIG_NUMBER					    PRIME_FACTORS_BIG_NUMBER					  PRIME_FACTORS_BIG_NUMBER
--							      --							    --								  --
static void factorize ( long n ) {			      def factorize ( n ) :					    def factorize ( n ) :					  script_not_found : None
  int count = 0 ;					      	  count = 0						    	count = 0						  
  while ( ! ( n % 2 > 0 ) ) {				      	  while ( ( n % 2 > 0 ) == False ) :			    	while not ( n % 2 > 0 ) :				  
    n >>= 1 ;						      	      n >>= 1						    	    n >>= 1						  
    count ++ ;						      	      count += 1					    	    count += 1						  
  }							      	  if ( count > 0 ) :					    	if count > 0 :						  
  if ( count > 0 ) {					      	      print ( 2 , count )				    	    print ( '2' , count )				  
    System . out . println ( "2" + " " + count ) ;	      	  for i in range ( 3 , int ( math.sqrt ( n ) ) + 1 ) :	    	for i in range ( 3 , int ( math.sqrt ( n ) ) + 1 , 2 ) :  
  }							      	      count = 0						    	    count = 0						  
  for ( long i = 3 ;					      	      while ( n % i == 0 ) :				    	    while n % i == 0 :					  
  i <= ( long ) Math . sqrt ( n ) ;			      		  count += 1					    		count += 1					  
  i += 2 ) {						      		  n = int ( n / i )				    		n = n // i					  
    count = 0 ;						      	      if ( count > 0 ) :				    	    if count > 0 :					  
    while ( n % i == 0 ) {				      		  print ( i , count )				    		print ( i , count )				  
      count ++ ;					      	      i += 2						    	if n > 2 :						  
      n = n / i ;					      	  if ( n > 2 ) :					    	    print ( n , '1' )					  
    }							      	      print ( n , 1 )					    								  
    if ( count > 0 ) {					      								    								  
      System . out . println ( i + " " + count ) ;	      								    								  
    }							      								    								  
  }							      								    								  
  if ( n > 2 ) {					      								    								  
    System . out . println ( n + " " + "1" ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_ISBN					      PROGRAM_CHECK_ISBN					    PROGRAM_CHECK_ISBN						  PROGRAM_CHECK_ISBN
--							      --							    --								  --
static boolean isValidISBN ( String isbn ) {		      def isValidISBN ( isbn ) :				    def is_valid_isbn ( isbn ) :				  script_not_found : None
  int n = isbn . length ( ) ;				      	  if len ( isbn ) != 10 :				    	n = len ( isbn )					  
  if ( n != 10 ) return false ;				      	      return False					    	if n != 10 :						  
  int sum = 0 ;						      	  _sum = 0						    	    return False					  
  for ( int i = 0 ;					      	  for i in range ( 9 ) :				    	sum = 0							  
  i < 9 ;						      	      if 0 <= int ( isbn [ i ] ) <= 9 :			    	for i in range ( 9 ) :					  
  i ++ ) {						      		  _sum += int ( isbn [ i ] ) * ( 10 - i )	    	    digit = ord ( isbn [ i ] ) - ord ( '0' )		  
    int digit = isbn . charAt ( i ) - '0' ;		      	      else :						    	    if 0 > digit or 9 < digit :				  
    if ( 0 > digit || 9 < digit ) return false ;	      		  return False					    		return False					  
    sum += ( digit * ( 10 - i ) ) ;			      	  if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) 	    sum += ( digit * ( 10 - i ) )			  
  }							      	      return False					    	last = isbn [ 9 ]					  
  char last = isbn . charAt ( 9 ) ;			      	  _sum += 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] )   	if last != 'X' and ( last < ord ( '0' ) or last > ord ( ' 
  if ( last != 'X' && ( last < '0' || last > '9' ) ) return f 	  return ( _sum % 11 == 0 )				    	    return False					  
  sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ;	      								    	sum += ( ( 10 if last == 'X' else ( last - ord ( '0' ) )  
  return ( sum % 11 == 0 ) ;				      								    	return ( sum % 11 == 0 )				  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_EVEN_FACTORS_NUMBER				      FIND_SUM_EVEN_FACTORS_NUMBER				    FIND_SUM_EVEN_FACTORS_NUMBER				  FIND_SUM_EVEN_FACTORS_NUMBER
--							      --							    --								  --
public static int sumofFactors ( int n ) {		      def sumofFactors ( n ) :					    def sumof_factors ( n ) :					  error : Traceback (most recent call last):   File
  if ( n % 2 != 0 ) return 0 ;				      	  if ( n % 2 != 0 ) :					    	if n % 2 :						  "dump/transcoder_st/eval/java_python/online_st/206
  int res = 1 ;						      	      return 0						    	    return 0						  68770/eval_scripts/java_sa-python_sa.test/FIND_SUM
  for ( int i = 2 ;					      	  res = 1						    	res = 1							  _EVEN_FACTORS_NUMBER.py", line 75, in <module>
  i <= Math . sqrt ( n ) ;				      	  for i in range ( 2 , ( int ) ( math.sqrt ( n ) ) + 1 ) :  	for i in range ( 2 , math.sqrt ( n ) + 1 ) :		   if f_filled(*parameters_set) == f_gold(*parameter
  i ++ ) {						      	      count = 0						    	    count , curr_sum = 0 , 1				  s_set):   File "dump/transcoder_st/eval/java_pytho
    int count = 0 , curr_sum = 1 ;			      	      curr_sum = 1					    	    curr_term = 1					  n/online_st/20668770/eval_scripts/java_sa-python_s
    int curr_term = 1 ;					      	      curr_term = 1					    	    while n % i == 0 :					  a.test/FIND_SUM_EVEN_FACTORS_NUMBER.py", line 44,
    while ( n % i == 0 ) {				      	      while ( n % i == 0 ) :				    		count += 1					  in f_filled	  for i in range ( 2 , math.sqrt ( n
      count ++ ;					      		  count = count + 1				    		n = n // i					   ) + 1 ) : TypeError: 'float' object cannot be int
      n = n / i ;					      		  n = n // i					    		if i == 2 and count == 1 :			  erpreted as an integer
      if ( i == 2 && count == 1 ) curr_sum = 0 ;	      		  if ( i == 2 and count == 1 ) :		    		    curr_sum = 0				  
      curr_term *= i ;					      		      curr_sum = 0				    		curr_term *= i					  
      curr_sum += curr_term ;				      		  curr_term = curr_term * i			    		curr_sum += curr_term				  
    }							      		  curr_sum = curr_sum + curr_term		    	    res *= curr_sum					  
    res *= curr_sum ;					      	      res = res * curr_sum				    	if n >= 2 :						  
  }							      	  if ( n >= 2 ) :					    	    res *= ( 1 + n )					  
  if ( n >= 2 ) res *= ( 1 + n ) ;			      	      res = res * ( 1 + n )				    	return res						  
  return res ;						      	  return res						    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS	      LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS	    LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS	  LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS
--							      --							    --								  --
static void minimizeWithKSwaps ( int arr [ ] , int n , int k  def minimizeWithKSwaps ( arr , n , k ) :			    def minimize_with_k_swaps ( arr , n , k ) :			  failure : #Results: 6, 10
  for ( int i = 0 ;					      	  for i in range ( n - 1 ) :				    	for i in range ( n - 1 and k > 0 ) :			  
  i < n - 1 && k > 0 ;					      	      pos = i						    	    pos = i						  
  ++ i ) {						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
    int pos = i ;					      		  if ( j - i > k ) :				    		if j - i > k :					  
    for ( int j = i + 1 ;				      		      break					    		    break					  
    j < n ;						      		  if ( arr [ j ] < arr [ pos ] ) :		    		if arr [ j ] < arr [ pos ] :			  
    ++ j ) {						      		      pos = j					    		    pos = j					  
      if ( j - i > k ) break ;				      	      for j in range ( pos , i , - 1 ) :		    	    for j in range ( pos , i , - 1 ) :			  
      if ( arr [ j ] < arr [ pos ] ) pos = j ;		      		  arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ 		temp = arr [ j ]				  
    }							      	      k -= pos - i					    		arr [ j ] = arr [ j - 1 ]			  
    int temp ;						      								    		arr [ j - 1 ] = temp				  
    for ( int j = pos ;					      								    	    k -= pos - i					  
    j > i ;						      								    								  
    -- j ) {						      								    								  
      temp = arr [ j ] ;				      								    								  
      arr [ j ] = arr [ j - 1 ] ;			      								    								  
      arr [ j - 1 ] = temp ;				      								    								  
    }							      								    								  
    k -= pos - i ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_ PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_ PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_ PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_
--							      --							    --								  --
static void swapUpperToLower ( int arr [ ] [ ] ) {	      def swapUpperToLower ( arr ) :				    def swap_upper_lower ( arr ) :				  script_not_found : None
  for ( int i = 0 ;					      	  n = 4 ;						    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( 0 , n ) :				    	    for j in range ( i + 1 , n ) :			  
  i ++ ) {						      	      for j in range ( i + 1 , n ) :			    		temp = arr [ i ] [ j ]				  
    for ( int j = i + 1 ;				      		  temp = arr [ i ] [ j ] ;			    		arr [ i ] [ j ] = arr [ j ] [ i ]		  
    j < n ;						      		  arr [ i ] [ j ] = arr [ j ] [ i ] ;		    		arr [ j ] [ i ] = temp				  
    j ++ ) {						      		  arr [ j ] [ i ] = temp ;			    	for i in range ( n ) :					  
      int temp = arr [ i ] [ j ] ;			      	  for i in range ( 0 , n ) :				    	    for j in range ( n ) :				  
      arr [ i ] [ j ] = arr [ j ] [ i ] ;		      	      for j in range ( 0 , n ) :			    		print ( arr [ i ] [ j ] , end = ' ' )		  
      arr [ j ] [ i ] = temp ;				      		  print ( arr [ i ] [ j ] , end = " " ) ;	    	    print ( )						  
    }							      	      print ( " " ) ;					    								  
  }							      								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j < n ;						      								    								  
    j ++ ) System . out . print ( arr [ i ] [ j ] + " " ) ;   								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER		      CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER		    CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER		  CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER
--							      --							    --								  --
static boolean checkCorrectOrNot ( String s ) {		      def checkCorrectOrNot ( s ) :				    def check_correct_or_not ( s ) :				  script_not_found : None
  int [ ] count1 = new int [ MAX_CHAR ] ;		      	  global MAX_CHAR					    	count1 = [ 0 ] * MAX_CHAR				  
  int [ ] count2 = new int [ MAX_CHAR ] ;		      	  count1 = [ 0 ] * MAX_CHAR				    	count2 = [ 0 ] * MAX_CHAR				  
  int n = s . length ( ) ;				      	  count2 = [ 0 ] * MAX_CHAR				    	n = len ( s )						  
  if ( n == 1 ) return true ;				      	  n = len ( s )						    	if n == 1 :						  
  for ( int i = 0 , j = n - 1 ;				      	  if n == 1 :						    	    return True						  
  i < j ;						      	      return true					    	for i , j in enumerate ( s [ : : - 1 ] ) :		  
  i ++ , j -- ) {					      	  i = 0 j = n - 1					    	    count1 [ i - 'a' ] += 1				  
    count1 [ s . charAt ( i ) - 'a' ] ++ ;		      	  while ( i < j ) :					    	    count2 [ j - 'a' ] += 1				  
    count2 [ s . charAt ( j ) - 'a' ] ++ ;		      	      count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1	    	for i in range ( MAX_CHAR ) :				  
  }							      	      count2 [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1	    	    if count1 [ i ] != count2 [ i ] :			  
  for ( int i = 0 ;					      	      i += 1 j -= 1					    		return False					  
  i < MAX_CHAR ;					      	  for i in range ( MAX_CHAR ) :				    	return True						  
  i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ;   	      if count1 [ i ] != count2 [ i ] :			    								  
  return true ;						      		  return False					    								  
}							      	  return True						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUBARRAY_WITH_GIVEN_SUM				      FIND_SUBARRAY_WITH_GIVEN_SUM				    FIND_SUBARRAY_WITH_GIVEN_SUM				  FIND_SUBARRAY_WITH_GIVEN_SUM
--							      --							    --								  --
int subArraySum ( int arr [ ] , int n , int sum ) {	      def subArraySum ( arr , n , sum ) :			    def subarray_sum ( arr , n , sum ) :			  success : None
  int curr_sum , i , j ;				      	  for i in range ( n ) :				    	curr_sum , i , j = 0 , 0 , 0				  
  for ( i = 0 ;						      	      curr_sum = arr [ i ]				    	for i in range ( n ) :					  
  i < n ;						      	      j = i + 1						    	    curr_sum = arr [ i ]				  
  i ++ ) {						      	      while j <= n :					    	    for j in range ( i + 1 , n + 1 ) :			  
    curr_sum = arr [ i ] ;				      		  if curr_sum == sum :				    		if curr_sum == sum :				  
    for ( j = i + 1 ;					      		      print ( "Sum found between" )		    		    p = j - 1					  
    j <= n ;						      		      print ( "indexes %d and %d" % ( i , j - 1 ) ) 		    print ( "Sum found between indexes %d and %d" 
    j ++ ) {						      		      return 1					    		    return 1					  
      if ( curr_sum == sum ) {				      		  if curr_sum > sum or j == n :			    		if curr_sum > sum or j == n :			  
	int p = j - 1 ;					      		      break					    		    break					  
	System . out . println ( "Sum found between indexes " 		  curr_sum = curr_sum + arr [ j ]		    		curr_sum = curr_sum + arr [ j ]			  
	return 1 ;					      		  j += 1					    	print ( "No subarray found" )				  
      }							      	  print ( "No subarray found" )				    	return 0						  
      if ( curr_sum > sum || j == n ) break ;		      	  return 0						    								  
      curr_sum = curr_sum + arr [ j ] ;			      								    								  
    }							      								    								  
  }							      								    								  
  System . out . println ( "No subarray found" ) ;	      								    								  
  return 0 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1			      SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1			    SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1			  SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1
--							      --							    --								  --
static void diagonalsquare ( int mat [ ] [ ] , int row , int  def diagonalsquare ( mat , row , column ) :		    def diagonalsquare ( mat , row , column ) :			  script_not_found : None
  System . out . print ( " Diagonal one : " ) ;		      	  print ( "Diagonal one : " , end = "" )		    	print ( "Diagonal one : " , end = "" )			  
  for ( int i = 0 ;					      	  for i in range ( 0 , row ) :				    	for i in range ( row ) :				  
  i < row ;						      	      print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = ""  	    print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = ""  
  i ++ ) {						      	  print ( "\n\nDiagonal two : " , end = "" )		    	print ( )						  
    System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ]  	  for i in range ( 0 , row ) :				    	print ( "Diagonal two : " , end = "" )			  
  }							      	      print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - 	for i in range ( row ) :				  
  System . out . println ( ) ;				      								    	    print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - 
  System . out . print ( " Diagonal two : " ) ;		      								    								  
  for ( int i = 0 ;					      								    								  
  i < row ;						      								    								  
  i ++ ) {						      								    								  
    System . out . print ( mat [ i ] [ row - i - 1 ] * mat [  								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PASCAL_TRIANGLE						      PASCAL_TRIANGLE						    PASCAL_TRIANGLE						  PASCAL_TRIANGLE
--							      --							    --								  --
public static void printPascal ( int n ) {		      def printPascal ( n : int ) :				    def print_pascal ( n ) :					  script_not_found : None
  int [ ] [ ] arr = new int [ n ] [ n ] ;		      	  arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] 	arr = np.zeros ( ( n , n ) )				  
  for ( int line = 0 ;					      	  for line in range ( 0 , n ) :				    	for line in range ( n ) :				  
  line < n ;						      	      for i in range ( 0 , line + 1 ) :			    	    for i in range ( 0 , line + 1 ) :			  
  line ++ ) {						      		  if ( i is 0 or i is line ) :			    		if line == i or i == 0 :			  
    for ( int i = 0 ;					      		      arr [ line ] [ i ] = 1			    		    arr [ line ] [ i ] = 1			  
    i <= line ;						      		      print ( arr [ line ] [ i ] , end = "" )	    		else :						  
    i ++ ) {						      		  else :					    		    arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 
      if ( line == i || i == 0 ) arr [ line ] [ i ] = 1 ;     		      arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 	    print ( arr [ line ] [ i ] , end = '' )		  
      else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] +  		      print ( arr [ line ] [ i ] , end = "" )	    	print ( '' )						  
      System . out . print ( arr [ line ] [ i ] ) ;	      	      print ( "\n" , end = "" )				    								  
    }							      								    								  
    System . out . println ( "" ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_WITH_GIVEN_SUM_1				      COUNT_PAIRS_WITH_GIVEN_SUM_1				    COUNT_PAIRS_WITH_GIVEN_SUM_1				  COUNT_PAIRS_WITH_GIVEN_SUM_1
--							      --							    --								  --
static int getPairsCount ( int n , int sum ) {		      def getPairsCount ( arr , n , sum ) :			    def get_paired_count ( n , sum ) :				  script_not_found : None
  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;    	  m = [ 0 ] * 1000					    	hm = { }						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      m [ arr [ i ] ]					    	    if arr [ i ] not in hm :				  
  i ++ ) {						      	      m [ arr [ i ] ] += 1				    		hm [ arr [ i ] ] = 0				  
    if ( ! hm . containsKey ( arr [ i ] ) ) hm . put ( arr [  	  twice_count = 0					    	    hm [ arr [ i ] ] = hm [ arr [ i ] ] + 1		  
    hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ;     	  for i in range ( 0 , n ) :				    	twice_count = 0						  
  }							      	      twice_count += m [ sum - arr [ i ] ]		    	for i in range ( n ) :					  
  int twice_count = 0 ;					      	      if ( sum - arr [ i ] == arr [ i ] ) :		    	    if hm [ sum - arr [ i ] ] in hm :			  
  for ( int i = 0 ;					      		  twice_count -= 1				    		twice_count += hm [ sum - arr [ i ] ]		  
  i < n ;						      	  return int ( twice_count / 2 )			    	    if sum - arr [ i ] == arr [ i ] :			  
  i ++ ) {						      								    		twice_count -= 1				  
    if ( hm . get ( sum - arr [ i ] ) != null ) twice_count + 								    	return twice_count / 2					  
    if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ;      								    								  
  }							      								    								  
  return twice_count / 2 ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN
--							      --							    --								  --
static int findMinInsertions ( char str [ ] , int l , int h ) def findMinInsertions ( str , l , h ) :			    def find_min_insertions ( str , l , h ) :			  success : None
  if ( l > h ) return Integer . MAX_VALUE ;		      	  if ( l > h ) :					    	if l > h :						  
  if ( l == h ) return 0 ;				      	      return sys.maxsize				    	    return sys.maxsize					  
  if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 	  if ( l == h ) :					    	if l == h :						  
  return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str 	      return 0						    	    return 0						  
}							      	  if ( l == h - 1 ) :					    	if l == h - 1 :						  
							      	      return 0 if ( str [ l ] == str [ h ] ) else 1	    	    return ( 0 if str [ l ] == str [ h ] else 1 )	  
							      	  if ( str [ l ] == str [ h ] ) :			    	return ( find_min_insertions ( str , l + 1 , h - 1 ) if s 
							      	      return findMinInsertions ( str , l + 1 , h - 1 )	    								  
							      	  else :						    								  
							      	      return ( min ( findMinInsertions ( str , l , h - 1 )  								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1		      FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1		    FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1			  FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1
--							      --							    --								  --
static int countRotations ( int arr [ ] , int low , int high  def countRotations ( arr , low , high ) :			    def count_rotations ( arr , low , high ) :			  success : None
  if ( high < low ) return 0 ;				      	  if ( high < low ) :					    	if high < low :						  
  if ( high == low ) return low ;			      	      return 0						    	    return 0						  
  int mid = low + ( high - low ) / 2 ;			      	  if ( high == low ) :					    	if high == low :					  
  if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( 	      return low					    	    return low						  
  if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mi 	  mid = low + ( high - low ) / 2			    	mid = low + ( high - low ) // 2				  
  if ( arr [ high ] > arr [ mid ] ) return countRotations ( a 	  mid = int ( mid )					    	if mid < high and arr [ mid + 1 ] < arr [ mid ] :	  
  return countRotations ( arr , mid + 1 , high ) ;	      	  if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) :	    	    return ( mid + 1 )					  
}							      	      return ( mid + 1 )				    	if mid > low and arr [ mid ] < arr [ mid - 1 ] :	  
							      	  if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) :	    	    return mid						  
							      	      return mid					    	if arr [ high ] > arr [ mid ] :				  
							      	  if ( arr [ high ] > arr [ mid ] ) :			    	    return count_rotations ( arr , low , mid - 1 )	  
							      	      return countRotations ( arr , low , mid - 1 )	    	return count_rotations ( arr , mid + 1 , high )		  
							      	  return countRotations ( arr , mid + 1 , high )	    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1		      FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1			    FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1			  FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1
--							      --							    --								  --
static String getMinNumberForPattern ( String seq ) {	      def getMinNumberForPattern ( seq ) :			    def get_min_number_for_pattern ( seq ) :			  failure : #Results: 0, 10
  int n = seq . length ( ) ;				      	  n = len ( seq )					    	n = len ( seq )						  
  if ( n >= 9 ) return "-1" ;				      	  if ( n >= 9 ) :					    	if n >= 9 :						  
  char result [ ] = new char [ n + 1 ] ;		      	      return "-1"					    	    return '-1'						  
  int count = 1 ;					      	  result = [ None ] * ( n + 1 )				    	result = [ ]						  
  for ( int i = 0 ;					      	  count = 1						    	count = 1						  
  i <= n ;						      	  for i in range ( n + 1 ) :				    	for i in range ( 0 , n + 1 ) :				  
  i ++ ) {						      	      if ( i == n or seq [ i ] == 'I' ) :		    	    if i == n or seq [ i ] in ' I ' :			  
    if ( i == n || seq . charAt ( i ) == 'I' ) {	      		  for j in range ( i - 1 , - 2 , - 1 ) :	    		for j in range ( i - 1 , - 1 , - 1 ) :		  
      for ( int j = i - 1 ;				      		      result [ j + 1 ] = int ( '0' + str ( count )  		    result.append ( chr ( ord ( '0' ) + count ) ) 
      j >= - 1 ;					      		      count += 1				    		    count += 1					  
      j -- ) {						      		      if ( j >= 0 and seq [ j ] == 'I' ) :	    		    if j >= 0 and seq [ j ] in ' I ' :		  
	result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++  			  break					    			break					  
	if ( j >= 0 && seq . charAt ( j ) == 'I' ) break ;    	  return result						    	return ''.join ( result )				  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return new String ( result ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_ MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_ MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_ MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_
--							      --							    --								  --
static int getMinSquares ( int n ) {			      def getMinSquares ( n ) :					    def get_min_squares ( n ) :					  script_not_found : None
  if ( n <= 3 ) return n ;				      	  dp = [ 0 , 1 , 2 , 3 ]				    	if n <= 3 :						  
  int dp [ ] = new int [ n + 1 ] ;			      	  for i in range ( 4 , n + 1 ) :			    	    return n						  
  dp [ 0 ] = 0 ;					      	      dp.append ( i )					    	dp = [ 0 ] * ( n + 1 )					  
  dp [ 1 ] = 1 ;					      	      for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1  	dp [ 0 ] = 0						  
  dp [ 2 ] = 2 ;					      		  temp = x * x ;				    	dp [ 1 ] = 1						  
  dp [ 3 ] = 3 ;					      		  if temp > i :					    	dp [ 2 ] = 2						  
  for ( int i = 4 ;					      		      break					    	dp [ 3 ] = 3						  
  i <= n ;						      		  else :					    	for i in range ( 4 , n + 1 ) :				  
  i ++ ) {						      		      dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp 	    dp [ i ] = i					  
    dp [ i ] = i ;					      	  return dp [ n ]					    	    for x in range ( 1 , math.ceil ( math.sqrt ( i ) ) +  
    for ( int x = 1 ;					      								    		temp = x * x					  
    x <= Math . ceil ( Math . sqrt ( i ) ) ;		      								    		if temp > i :					  
    x ++ ) {						      								    		    break					  
      int temp = x * x ;				      								    		else :						  
      if ( temp > i ) break ;				      								    		    dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp 
      else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - te 								    	res = dp [ n ]						  
    }							      								    	return res						  
  }							      								    								  
  int res = dp [ n ] ;					      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY	      FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY	    FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY		  FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY
--							      --							    --								  --
static int findMin ( int arr [ ] , int low , int high ) {     def findMin ( arr , low , high ) :			    def find_min ( arr , low , high ) :				  success : None
  if ( high < low ) return arr [ 0 ] ;			      	  if high < low :					    	if high < low :						  
  if ( high == low ) return arr [ low ] ;		      	      return arr [ 0 ]					    	    return arr [ 0 ]					  
  int mid = low + ( high - low ) / 2 ;			      	  if high == low :					    	if high == low :					  
  if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return a 	      return arr [ low ]				    	    return arr [ low ]					  
  if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return ar 	  mid = int ( ( low + high ) / 2 )			    	mid = low + ( high - low ) // 2				  
  if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , lo 	  if mid < high and arr [ mid + 1 ] < arr [ mid ] :	    	if mid < high and arr [ mid + 1 ] < arr [ mid ] :	  
  return findMin ( arr , mid + 1 , high ) ;		      	      return arr [ mid + 1 ]				    	    return arr [ mid + 1 ]				  
}							      	  if mid > low and arr [ mid ] < arr [ mid - 1 ] :	    	if mid > low and arr [ mid ] < arr [ mid - 1 ] :	  
							      	      return arr [ mid ]				    	    return arr [ mid ]					  
							      	  if arr [ high ] > arr [ mid ] :			    	if arr [ high ] > arr [ mid ] :				  
							      	      return findMin ( arr , low , mid - 1 )		    	    return find_min ( arr , low , mid - 1 )		  
							      	  return findMin ( arr , mid + 1 , high )		    	return find_min ( arr , mid + 1 , high )		  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FREQUENCY_ELEMENT_UNSORTED_ARRAY			      FREQUENCY_ELEMENT_UNSORTED_ARRAY				    FREQUENCY_ELEMENT_UNSORTED_ARRAY				  FREQUENCY_ELEMENT_UNSORTED_ARRAY
--							      --							    --								  --
static void countFreq ( int [ ] a , int n ) {		      def countFreq ( a , n ) :					    def count_freq ( a , n ) :					  script_not_found : None
  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;    	  hm = { }						    	hm = { }						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      hm [ a [ i ] ] = hm.get ( a [ i ] , 0 ) + 1	    	    hm [ a [ i ] ] = 1 if hm.get ( a [ i ] ) is None else 
  i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) == null ?  	  st = set ( )						    	st = defaultdict ( int )				  
  SortedMap < Integer , Integer > st = new TreeMap < > ( ) ;  	  for x in hm :						    	for x , v in hm.items ( ) :				  
  for ( HashMap . Entry < Integer , Integer > x : hm . entryS 	      st.add ( ( x , hm [ x ] ) )			    	    st [ x ] += v					  
    st . put ( x . getKey ( ) , x . getValue ( ) ) ;	      	  cumul = 0						    	cumul = 0						  
  }							      	  for x in sorted ( st ) :				    	for x , v in st.items ( ) :				  
  int cumul = 0 ;					      	      cumul += x [ 1 ]					    	    cumul += v						  
  for ( SortedMap . Entry < Integer , Integer > x : st . entr 	      print ( x [ 0 ] , cumul )				    	    print ( x , cumul )					  
    cumul += x . getValue ( ) ;				      								    								  
    System . out . println ( x . getKey ( ) + " " + cumul ) ; 								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY		      PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY		    PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY		  PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY
--							      --							    --								  --
public static void printPairs ( int arr [ ] , int n ) {	      def printPairs ( arr , n ) :				    def print_pairs ( arr , n ) :				  script_not_found : None
  Vector < Integer > v = new Vector < Integer > ( ) ;	      	  v = [ ]						    	v = [ ]							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) for ( int j = i + 1 ;				      		  if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) :   		if abs ( arr [ i ] ) == abs ( arr [ j ] ) :	  
  j < n ;						      		      v.append ( abs ( arr [ i ] ) )		    		    v.append ( abs ( arr [ i ] ) )		  
  j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [  	  if ( len ( v ) == 0 ) :				    	if not len ( v ) :					  
  if ( v . size ( ) == 0 ) return ;			      	      return ;						    	    return						  
  Collections . sort ( v ) ;				      	  v.sort ( )						    	v.sort ( )						  
  for ( int i = 0 ;					      	  for i in range ( len ( v ) ) :			    	for i in v :						  
  i < v . size ( ) ;					      	      print ( - v [ i ] , "" , v [ i ] , end = " " )	    	    print ( '%d %d' % ( - v [ i ] , i ) , end = ' ' )	  
  i ++ ) System . out . print ( - v . get ( i ) + " " + v . g 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1
--							      --							    --								  --
static int numberOfPaths ( int m , int n ) {		      def numberOfPaths ( m , n ) :				    def numberOfPaths ( m , n ) :				  script_not_found : None
  int count [ ] [ ] = new int [ m ] [ n ] ;		      	  count = [ [ 0 for x in range ( m ) ] for y in range ( n ) 	count = np.zeros ( ( m , n ) )				  
  for ( int i = 0 ;					      	  for i in range ( m ) :				    	for i in range ( m ) :					  
  i < m ;						      	      count [ i ] [ 0 ] = 1 ;				    	    count [ i ] [ 0 ] = 1				  
  i ++ ) count [ i ] [ 0 ] = 1 ;			      	  for j in range ( n ) :				    	for j in range ( n ) :					  
  for ( int j = 0 ;					      	      count [ 0 ] [ j ] = 1 ;				    	    count [ 0 ] [ j ] = 1				  
  j < n ;						      	  for i in range ( 1 , m ) :				    	for i in range ( 1 , m ) :				  
  j ++ ) count [ 0 ] [ j ] = 1 ;			      	      for j in range ( n ) :				    	    for j in range ( 1 , n ) :				  
  for ( int i = 1 ;					      		  count [ i ] [ j ] = count [ i - 1 ] [ j ] + count 		count [ i ] [ j ] = count [ i - 1 ] [ j ] + count 
  i < m ;						      	  return count [ m - 1 ] [ n - 1 ]			    	return count [ m - 1 ] [ n - 1 ]			  
  i ++ ) {						      								    								  
    for ( int j = 1 ;					      								    								  
    j < n ;						      								    								  
    j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count  								    								  
  }							      								    								  
  return count [ m - 1 ] [ n - 1 ] ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE			      MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE			    MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE			  MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE
--							      --							    --								  --
static int lis ( int [ ] arr , int n ) {		      def lis ( arr , n ) :					    def lis ( arr , n ) :					  success : None
  int [ ] mpis = new int [ n ] ;			      	  mpis = [ 0 ] * ( n )					    	mpis = [ 0 ] * n					  
  int max = Integer . MIN_VALUE ;			      	  for i in range ( n ) :				    	max = 0							  
  for ( int i = 0 ;					      	      mpis [ i ] = arr [ i ]				    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( 1 , n ) :				    	    mpis [ i ] = arr [ i ]				  
  i ++ ) mpis [ i ] = arr [ i ] ;			      	      for j in range ( i ) :				    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      		  if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpi 	    for j in range ( i ) :				  
  i < n ;						      		      mpis [ i ] = mpis [ j ] * arr [ i ]	    		if arr [ i ] > arr [ j ] and mpis [ i ] < ( mpis  
  i ++ ) for ( int j = 0 ;				      	  return max ( mpis )					    		    mpis [ i ] = mpis [ j ] * arr [ i ]		  
  j < i ;						      								    	for k in range ( len ( mpis ) ) :			  
  j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [  								    	    if mpis [ k ] > max :				  
  for ( int k = 0 ;					      								    		max = mpis [ k ]				  
  k < mpis . length ;					      								    	return max						  
  k ++ ) {						      								    								  
    if ( mpis [ k ] > max ) {				      								    								  
      max = mpis [ k ] ;				      								    								  
    }							      								    								  
  }							      								    								  
  return max ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_INSERTIONS_SORT_ARRAY				      MINIMUM_INSERTIONS_SORT_ARRAY				    MINIMUM_INSERTIONS_SORT_ARRAY				  MINIMUM_INSERTIONS_SORT_ARRAY
--							      --							    --								  --
static int minInsertionStepToSortArray ( int arr [ ] , int N  def minInsertionStepToSortArray ( arr , N ) :		    def min_insertion_step_to_sort_array ( arr , N ) :		  success : None
  int [ ] lis = new int [ N ] ;				      	  lis = [ 0 ] * N					    	lis = [ 0 ] * N						  
  for ( int i = 0 ;					      	  for i in range ( N ) :				    	for i in range ( N ) :					  
  i < N ;						      	      lis [ i ] = 1					    	    lis [ i ] = 1					  
  i ++ ) lis [ i ] = 1 ;				      	  for i in range ( 1 , N ) :				    	for i in range ( 1 , N ) :				  
  for ( int i = 1 ;					      	      for j in range ( i ) :				    	    for j in range ( i ) :				  
  i < N ;						      		  if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ 		if arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j 
  i ++ ) for ( int j = 0 ;				      		      lis [ i ] = lis [ j ] + 1			    		    lis [ i ] = lis [ j ] + 1			  
  j < i ;						      	  max = 0						    	max = 0							  
  j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] 	  for i in range ( N ) :				    	for i in range ( N ) :					  
  int max = 0 ;						      	      if ( max < lis [ i ] ) :				    	    if max < lis [ i ] :				  
  for ( int i = 0 ;					      		  max = lis [ i ]				    		max = lis [ i ]					  
  i < N ;						      	  return ( N - max )					    	return ( N - max )					  
  i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;	      								    								  
  return ( N - max ) ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM   REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM   REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM	  REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM
--							      --							    --								  --
static int remAnagram ( String str1 , String str2 ) {	      def remAnagram ( str1 , str2 ) :				    def remAnagram ( str1 , str2 ) :				  script_not_found : None
  int count1 [ ] = new int [ 26 ] ;			      	  count1 = [ 0 ] * CHARS				    	count1 = [ 0 ] * 26					  
  int count2 [ ] = new int [ 26 ] ;			      	  count2 = [ 0 ] * CHARS				    	count2 = [ 0 ] * 26					  
  for ( int i = 0 ;					      	  i = 0							    	for c in str1 :						  
  i < str1 . length ( ) ;				      	  while i < len ( str1 ) :				    	    count1 [ ord ( c ) - ord ( 'a' ) ] += 1		  
  i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++ ;	      	      count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1	    	for c in str2 :						  
  for ( int i = 0 ;					      	      i += 1						    	    count2 [ ord ( c ) - ord ( 'a' ) ] += 1		  
  i < str2 . length ( ) ;				      	  i = 0							    	result = 0						  
  i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++ ;	      	  while i < len ( str2 ) :				    	for i in range ( 26 ) :					  
  int result = 0 ;					      	      count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1	    	    result += abs ( count1 [ i ] - count2 [ i ] )	  
  for ( int i = 0 ;					      	      i += 1						    	return result						  
  i < 26 ;						      	  result = 0						    								  
  i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) 	  for i in range ( 26 ) :				    								  
  return result ;					      	      result += abs ( count1 [ i ] - count2 [ i ] )	    								  
}							      	  return result						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE	      GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE	    GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE	  GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE
--							      --							    --								  --
static void printGrouped ( String str ) {		      def printGrouped ( string ) :				    def print_grouped ( data ) :				  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( string )					    	n = len ( data )					  
  int count [ ] = new int [ MAX_CHAR ] ;		      	  count = [ 0 ] * MAX_CHAR				    	count = [ 0 ] * MAX_CHAR				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for c in data :						  
  i < n ;						      	      count [ ord ( string [ i ] ) - ord ( "a" ) ] += 1	    	    count [ ord ( c ) - ord ( 'a' ) ] += 1		  
  i ++ ) count [ str . charAt ( i ) - 'a' ] ++ ;	      	  for i in range ( n ) :				    	for c in data :						  
  for ( int i = 0 ;					      	      while count [ ord ( string [ i ] ) - ord ( "a" ) ] :  	    while count [ ord ( c ) - ord ( 'a' ) ] != 0 :	  
  i < n ;						      		  print ( string [ i ] , end = "" )		    		print ( ord ( c ) , end = ' ' )			  
  i ++ ) {						      		  count [ ord ( string [ i ] ) - ord ( "a" ) ] -= 1 		count [ ord ( c ) - ord ( 'a' ) ] -= 1		  
    while ( count [ str . charAt ( i ) - 'a' ] != 0 ) {	      	      count [ ord ( string [ i ] ) - ord ( "a" ) ] = 0	    	    count [ ord ( c ) - ord ( 'a' ) ] = 0		  
      System . out . print ( str . charAt ( i ) ) ;	      								    								  
      count [ str . charAt ( i ) - 'a' ] -- ;		      								    								  
    }							      								    								  
    count [ str . charAt ( i ) - 'a' ] = 0 ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
A_PRODUCT_ARRAY_PUZZLE_1				      A_PRODUCT_ARRAY_PUZZLE_1					    A_PRODUCT_ARRAY_PUZZLE_1					  A_PRODUCT_ARRAY_PUZZLE_1
--							      --							    --								  --
void productArray ( int arr [ ] , int n ) {		      def productArray ( arr , n ) :				    def product_array ( arr , n ) :				  script_not_found : None
  if ( n == 1 ) {					      	  if n == 1 :						    	if n == 1 :						  
    System . out . print ( "0" ) ;			      	      print ( 0 )					    	    print ( '0' , end = ' ' )				  
    return ;						      	      return						    	    return						  
  }							      	  i , temp = 1 , 1					    	i , temp = 1 , 1					  
  int i , temp = 1 ;					      	  prod = [ 1 for i in range ( n ) ]			    	prod = [ 0 ] * n					  
  int prod [ ] = new int [ n ] ;			      	  for i in range ( n ) :				    	for j in range ( n ) :					  
  for ( int j = 0 ;					      	      prod [ i ] = temp					    	    prod [ j ] = 1					  
  j < n ;						      	      temp *= arr [ i ]					    	for i in range ( n ) :					  
  j ++ ) prod [ j ] = 1 ;				      	  temp = 1						    	    prod [ i ] = temp					  
  for ( i = 0 ;						      	  for i in range ( n - 1 , - 1 , - 1 ) :		    	    temp *= arr [ i ]					  
  i < n ;						      	      prod [ i ] *= temp				    	temp = 1						  
  i ++ ) {						      	      temp *= arr [ i ]					    	for i in range ( n - 1 , - 1 , - 1 ) :			  
    prod [ i ] = temp ;					      	  for i in range ( n ) :				    	    prod [ i ] *= temp					  
    temp *= arr [ i ] ;					      	      print ( prod [ i ] , end = " " )			    	    temp *= arr [ i ]					  
  }							      	  return						    	for i in range ( n ) :					  
  temp = 1 ;						      								    	    print ( prod [ i ] , end = ' ' )			  
  for ( i = n - 1 ;					      								    	return							  
  i >= 0 ;						      								    								  
  i -- ) {						      								    								  
    prod [ i ] *= temp ;				      								    								  
    temp *= arr [ i ] ;					      								    								  
  }							      								    								  
  for ( i = 0 ;						      								    								  
  i < n ;						      								    								  
  i ++ ) System . out . print ( prod [ i ] + " " ) ;	      								    								  
  return ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STEINS_ALGORITHM_FOR_FINDING_GCD			      STEINS_ALGORITHM_FOR_FINDING_GCD				    STEINS_ALGORITHM_FOR_FINDING_GCD				  STEINS_ALGORITHM_FOR_FINDING_GCD
--							      --							    --								  --
static int gcd ( int a , int b ) {			      def gcd ( a , b ) :					    def gcd ( a , b ) :						  timeout : None
  if ( a == 0 ) return b ;				      	  if ( a == 0 ) :					    	if not a :						  
  if ( b == 0 ) return a ;				      	      return b						    	    return b						  
  int k ;						      	  if ( b == 0 ) :					    	if not b :						  
  for ( k = 0 ;						      	      return a						    	    return a						  
  ( ( a | b ) & 1 ) == 0 ;				      	  k = 0							    	for k in range ( 0 , ( - 1 ) , - 1 ) :			  
  ++ k ) {						      	  while ( ( ( a | b ) & 1 ) == 0 ) :			    	    a >>= 1						  
    a >>= 1 ;						      	      a = a >> 1					    	    b >>= 1						  
    b >>= 1 ;						      	      b = b >> 1					    	while True :						  
  }							      	      k = k + 1						    	    while True :					  
  while ( ( a & 1 ) == 0 ) a >>= 1 ;			      	  while ( ( a & 1 ) == 0 ) :				    		b >>= 1						  
  do {							      	      a = a >> 1					    		if a > b :					  
    while ( ( b & 1 ) == 0 ) b >>= 1 ;			      	  while ( b != 0 ) :					    		    temp = a					  
    if ( a > b ) {					      	      while ( ( b & 1 ) == 0 ) :			    		    a = b					  
      int temp = a ;					      		  b = b >> 1					    		    b = temp					  
      a = b ;						      	      if ( a > b ) :					    		b = ( b - a )					  
      b = temp ;					      		  temp = a					    	return a << k						  
    }							      		  a = b						    								  
    b = ( b - a ) ;					      		  b = temp					    								  
  }							      	      b = ( b - a )					    								  
  while ( b != 0 ) ;					      	  return ( a << k )					    								  
  return a << k ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1		      COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1		    COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1		  COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1
--							      --							    --								  --
static int countDecodingDP ( char digits [ ] , int n ) {      def countDecodingDP ( digits , n ) :			    def count_decoding_dp ( digits , n ) :			  failure : #Results: 8, 10
  int count [ ] = new int [ n + 1 ] ;			      	  count = [ 0 ] * ( n + 1 )				    	count = [ 1 ] * ( n + 1 )				  
  count [ 0 ] = 1 ;					      	  count [ 0 ] = 1					    	count [ 0 ] = 1						  
  count [ 1 ] = 1 ;					      	  count [ 1 ] = 1					    	count [ 1 ] = 1						  
  if ( digits [ 0 ] == '0' ) return 0 ;			      	  for i in range ( 2 , n + 1 ) :			    	if digits [ 0 ] == '0' :				  
  for ( int i = 2 ;					      	      count [ i ] = 0					    	    return 0						  
  i <= n ;						      	      if ( digits [ i - 1 ] > '0' ) :			    	for i in range ( 2 , n + 1 ) :				  
  i ++ ) {						      		  count [ i ] = count [ i - 1 ]			    	    count [ i ] = 0					  
    count [ i ] = 0 ;					      	      if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == 	    if digits [ i - 1 ] > '0' :				  
    if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 		  count [ i ] += count [ i - 2 ]		    		count [ i ] = count [ i - 1 ]			  
    if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' 	  return count [ n ]					    	    if digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == ' 
  }							      								    		count [ i ] += count [ i - 2 ]			  
  return count [ n ] ;					      								    	return count [ n ]					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVIDE_LARGE_NUMBER_REPRESENTED_STRING			      DIVIDE_LARGE_NUMBER_REPRESENTED_STRING			    DIVIDE_LARGE_NUMBER_REPRESENTED_STRING			  DIVIDE_LARGE_NUMBER_REPRESENTED_STRING
--							      --							    --								  --
static String longDivision ( String number , int divisor ) {  def longDivision ( number , divisor ) :			    def long_division ( number , divisor ) :			  script_not_found : None
  String ans = "" ;					      	  ans = ""						    	ans = ""						  
  int idx = 0 ;						      	  idx = 0						    	idx = 0							  
  char [ ] num = number . toCharArray ( ) ;		      	  temp = ord ( number [ idx ] ) - ord ( '0' )		    	num = list ( number )					  
  int temp = num [ idx ] - '0' ;			      	  while ( temp < divisor ) :				    	temp = num [ idx ] - '0'				  
  while ( temp < divisor ) temp = temp * 10 + ( num [ ++ idx  	      temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord 	while temp < divisor :					  
  idx += 1 ;						      	      idx += 1						    	    temp = temp * 10 + ( num [ idx ] - '0' )		  
  while ( num . length > idx ) {			      	  idx += 1						    	    idx += 1						  
    ans += ( temp / divisor ) ;				      	  while ( ( len ( number ) ) > idx ) :			    	while len ( num ) > idx :				  
    temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' ;   	      ans += chr ( math.floor ( temp // divisor ) + ord ( ' 	    ans += ( temp // divisor )				  
  }							      	      temp = ( ( temp % divisor ) * 10 + ord ( number [ idx 	    temp = ( temp % divisor ) * 10 + num [ idx ] - '0'	  
  if ( ans . length ( ) == 0 ) return "0" ;		      	      idx += 1						    	    idx += 1						  
  return ans ;						      	  ans += chr ( math.floor ( temp // divisor ) + ord ( '0' ) 	if not ans :						  
}							      	  if ( len ( ans ) == 0 ) :				    	    return "0"						  
							      	      return "0"					    	return ans						  
							      	  return ans						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT
--							      --							    --								  --
static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) :	    def find_triplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) :	  error : Traceback (most recent call last):   File
  HashSet < Integer > s = new HashSet < Integer > ( ) ;	      	  s = set ( )						    	s = set ( a1 )						  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int i = 0 ;					      	  for i in range ( n1 ) :				    	al = list ( s )						  68770/eval_scripts/java_sa-python_sa.test/FIND_THR
  i < n1 ;						      	      s.add ( a1 [ i ] )				    	for i in range ( n2 ) :					  EE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_T
  i ++ ) {						      	  for i in range ( n2 ) :				    	    for j in range ( n3 ) :				  HAT_A_B_C_K_1.py", line 53, in <module>     if f_f
    s . add ( a1 [ i ] ) ;				      	      for j in range ( n3 ) :				    		if sum - a2 [ i ] - a3 [ j ] & al.find ( sum - a2 illed(*parameters_set) == f_gold(*parameters_set):
  }							      		  if sum - a2 [ i ] - a3 [ j ] in s :		    		    return True					     File "dump/transcoder_st/eval/java_python/onlin
  ArrayList < Integer > al = new ArrayList < > ( s ) ;	      		      return True				    	return False						  e_st/20668770/eval_scripts/java_sa-python_sa.test/
  for ( int i = 0 ;					      	  return False						    								  FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUC
  i < n2 ;						      								    								  H_THAT_THAT_A_B_C_K_1.py", line 33, in f_filled
  i ++ ) {						      								    								    if sum - a2 [ i ] - a3 [ j ] & al.find ( sum - a
    for ( int j = 0 ;					      								    								  2 [ i ] - a3 [ j ] ) != al [ - 1 ] : AttributeErro
    j < n3 ;						      								    								  r: 'list' object has no attribute 'find'
    j ++ ) {						      								    								  
      if ( al . contains ( sum - a2 [ i ] - a3 [ j ] ) & al . 								    								  
	return true ;					      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
INTERPOLATION_SEARCH					      INTERPOLATION_SEARCH					    INTERPOLATION_SEARCH					  INTERPOLATION_SEARCH
--							      --							    --								  --
static int interpolationSearch ( int x ) {		      def interpolationSearch ( arr , n , x ) :			    def interpolation_search ( x ) :				  script_not_found : None
  int lo = 0 , hi = ( arr . length - 1 ) ;		      	  lo = 0						    	lo , hi = 0 , ( len ( arr ) - 1 )			  
  while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {  	  hi = ( n - 1 )					    	while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] :  
    if ( lo == hi ) {					      	  while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] :  	    if lo == hi :					  
      if ( arr [ lo ] == x ) return lo ;		      	      if lo == hi :					    		if arr [ lo ] == x :				  
      return - 1 ;					      		  if arr [ lo ] == x :				    		    return lo					  
    }							      		      return lo ;				    		return - 1					  
    int pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo  		  return - 1 ;					    	    pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo  
    if ( arr [ pos ] == x ) return pos ;		      	      pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] 	    if arr [ pos ] == x :				  
    if ( arr [ pos ] < x ) lo = pos + 1 ;		      	      if arr [ pos ] == x :				    		return pos					  
    else hi = pos - 1 ;					      		  return pos					    	    if arr [ pos ] < x :				  
  }							      	      if arr [ pos ] < x :				    		lo = pos + 1					  
  return - 1 ;						      		  lo = pos + 1 ;				    	    else :						  
}							      	      else :						    		hi = pos - 1					  
							      		  hi = pos - 1 ;				    	return - 1						  
							      	  return - 1						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1			      FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1			    FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1			  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
--							      --							    --								  --
static boolean isRectangle ( int m [ ] [ ] ) {		      def isRectangle ( m ) :					    def is_rectangle ( m ) :					  script_not_found : None
  int rows = m . length ;				      	  rows = len ( m )					    	rows = len ( m )					  
  if ( rows == 0 ) return false ;			      	  if ( rows == 0 ) :					    	if not rows :						  
  int columns = m [ 0 ] . length ;			      	      return False					    	    return False					  
  for ( int y1 = 0 ;					      	  columns = len ( m [ 0 ] )				    	columns = len ( m [ 0 ] )				  
  y1 < rows ;						      	  for y1 in range ( rows ) :				    	for y1 in range ( rows ) :				  
  y1 ++ ) for ( int x1 = 0 ;				      	      for x1 in range ( columns ) :			    	    for x1 in range ( columns ) :			  
  x1 < columns ;					      		  if ( m [ y1 ] [ x1 ] == 1 ) :			    		if m [ y1 ] [ x1 ] == 1 :			  
  x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ; 		      for y2 in range ( y1 + 1 , rows ) :	    		    for y2 in range ( y1 + 1 , rows ) :		  
  y2 < rows ;						      			  for x2 in range ( x1 + 1 , columns ) :    			for x2 in range ( x1 + 1 , columns ) :	  
  y2 ++ ) for ( int x2 = x1 + 1 ;			      			      if ( m [ y1 ] [ x2 ] == 1 and m [ y2  			    if m [ y1 ] [ x2 ] == 1 and m [ y2 ]  
  x2 < columns ;					      				  return True			    				return True			  
  x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 & 	  return False						    	return False						  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DISTANCE_TWO_POINTS_EARTH			      PROGRAM_DISTANCE_TWO_POINTS_EARTH				    PROGRAM_DISTANCE_TWO_POINTS_EARTH				  PROGRAM_DISTANCE_TWO_POINTS_EARTH
--							      --							    --								  --
public static double distance ( double lat1 , double lat2 , d def distance ( lat1 , lat2 , lon1 , lon2 ) :		    def distance ( lat1 , lat2 , lon1 , lon2 ) :		  script_not_found : None
  lon1 = Math . toRadians ( lon1 ) ;			      	  lon1 = radians ( lon1 )				    	lon1 = math.radians ( lon1 )				  
  lon2 = Math . toRadians ( lon2 ) ;			      	  lon2 = radians ( lon2 )				    	lon2 = math.radians ( lon2 )				  
  lat1 = Math . toRadians ( lat1 ) ;			      	  lat1 = radians ( lat1 )				    	lat1 = math.radians ( lat1 )				  
  lat2 = Math . toRadians ( lat2 ) ;			      	  lat2 = radians ( lat2 )				    	lat2 = math.radians ( lat2 )				  
  double dlon = lon2 - lon1 ;				      	  dlon = lon2 - lon1					    	dlon = lon2 - lon1					  
  double dlat = lat2 - lat1 ;				      	  dlat = lat2 - lat1					    	dlat = lat2 - lat1					  
  double a = Math . pow ( Math . sin ( dlat / 2 ) , 2 ) + Mat 	  a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * 	a = math.pow ( math.sin ( dlat / 2 ) , 2 ) + math.cos ( l 
  double c = 2 * Math . asin ( Math . sqrt ( a ) ) ;	      	  c = 2 * asin ( sqrt ( a ) )				    	c = 2 * math.asin ( math.sqrt ( a ) )			  
  double r = 6371 ;					      	  r = 6371						    	r = 6371						  
  return ( c * r ) ;					      	  return ( c * r )					    	return ( c * r )					  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT
--							      --							    --								  --
static int minTimeForWritingChars ( int N , int insert , int  def minTimeForWritingChars ( N , insrt , remov , cpy ) :	    def min_time_for_writing_chars ( N , insert , remove , copy ) failure : #Results: 0, 10
  if ( N == 0 ) return 0 ;				      	  if N == 0 :						    	if not N :						  
  if ( N == 1 ) return insert ;				      	      return 0						    	    return 0						  
  int dp [ ] = new int [ N + 1 ] ;			      	  if N == 1 :						    	if N == 1 :						  
  for ( int i = 1 ;					      	      return insrt					    	    return insert					  
  i <= N ;						      	  dp = [ 0 ] * ( N + 1 )				    	dp = [ 0 ] * ( N + 1 )					  
  i ++ ) {						      	  for i in range ( 1 , N + 1 ) :			    	for i in range ( 1 , N + 1 ) :				  
    if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] +  	      if i % 2 == 0 :					    	    if i % 2 == 0 :					  
    else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ 		  dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ i // 		dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i / 
  }							      	      else :						    	    else :						  
  return dp [ N ] ;					      		  dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ ( i  		dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i 
}							      	  return dp [ N ]					    	return dp [ N ]						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C		      LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C		    LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C			  LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C
--							      --							    --								  --
static boolean prevPermutation ( char [ ] str ) {	      def prevPermutation ( str ) :				    def prevPermutation ( str ) :				  error : Traceback (most recent call last):   File
  int n = str . length - 1 ;				      	  n = len ( str ) - 1					    	n = len ( str ) - 1					  "dump/transcoder_st/eval/java_python/online_st/206
  int i = n ;						      	  i = n							    	i = n							  68770/eval_scripts/java_sa-python_sa.test/LEXICOGR
  while ( i > 0 && str [ i - 1 ] <= str [ i ] ) {	      	  while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :	    	while i > 0 and str [ i - 1 ] <= str [ i ] :		  APHICALLY_PREVIOUS_PERMUTATION_IN_C.py", line 68,
    i -- ;						      	      i -= 1						    	    i -= 1						  in <module>	  if f_filled(*parameters_set) == f_
  }							      	  if ( i <= 0 ) :					    	if i <= 0 :						  gold(*parameters_set):   File "dump/transcoder_st/
  if ( i <= 0 ) {					      	      return False					    	    return False					  eval/java_python/online_st/20668770/eval_scripts/j
    return false ;					      	  j = i - 1						    	j = i - 1						  ava_sa-python_sa.test/LEXICOGRAPHICALLY_PREVIOUS_P
  }							      	  while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : 	while j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] :	  ERMUTATION_IN_C.py", line 46, in f_filled	swap
  int j = i - 1 ;					      	      j += 1						    	    j += 1						   ( str , i - 1 , j ) NameError: name 'swap' is not
  while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) {    	  str = list ( str )					    	swap ( str , i - 1 , j )				   defined
    j ++ ;						      	  temp = str [ i - 1 ]					    	s = list ( str )					  
  }							      	  str [ i - 1 ] = str [ j ]				    	s.reverse ( )						  
  swap ( str , i - 1 , j ) ;				      	  str [ j ] = temp					    	str = ''.join ( s )					  
  StringBuilder sb = new StringBuilder ( String . valueOf ( s 	  str = ''.join ( str )					    	return True						  
  sb . reverse ( ) ;					      	  str [ : : - 1 ]					    								  
  str = sb . toString ( ) . toCharArray ( ) ;		      	  return True , str					    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING    SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING    SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING	  SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING
--							      --							    --								  --
static void splitString ( String str ) {		      def splitString ( str ) :					    def split_string ( data ) :					  script_not_found : None
  StringBuffer alpha = new StringBuffer ( ) , num = new Strin 	  alpha = ""						    	alpha , num , special = '' , '' , ''			  
  for ( int i = 0 ;					      	  num = ""						    	for c in data :						  
  i < str . length ( ) ;				      	  special = ""						    	    if c.isdigit ( ) :					  
  i ++ ) {						      	  for i in range ( len ( str ) ) :			    		num += c					  
    if ( Character . isDigit ( str . charAt ( i ) ) ) num . a 	      if ( str [ i ].isdigit ( ) ) :			    	    elif c.isalpha ( ) :				  
    else if ( Character . isAlphabetic ( str . charAt ( i ) ) 		  num = num + str [ i ]				    		alpha += c					  
    else special . append ( str . charAt ( i ) ) ;	      	      elif ( ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) or ( 	    else :						  
  }							      		  alpha += str [ i ]				    		special += c					  
  System . out . println ( alpha ) ;			      	      else :						    	print ( alpha )						  
  System . out . println ( num ) ;			      		  special += str [ i ]				    	print ( num )						  
  System . out . println ( special ) ;			      	  print ( alpha )					    	print ( special )					  
}							      	  print ( num )						    								  
							      	  print ( special )					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1		      SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1		    SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1		  SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1
--							      --							    --								  --
static int sumAtKthLevel ( String tree , int k , int level )  def sumAtKthLevel ( tree , k , i , level ) :		    def sum_at_kth_level ( tree , k , level ) :			  script_not_found : None
  if ( tree . charAt ( i ++ ) == '(' ) {		      	  if ( tree [ i [ 0 ] ] == '(' ) :			    	global i						  
    if ( tree . charAt ( i ) == ')' ) return 0 ;	      	      i [ 0 ] += 1					    	if tree [ i ] == '(' :					  
    int sum = 0 ;					      	      if ( tree [ i [ 0 ] ] == ')' ) :			    	    if tree [ i ] == ')' :				  
    if ( level == k ) sum = tree . charAt ( i ) - '0' ;	      		  return 0					    		return 0					  
    ++ i ;						      	      sum = 0						    	    sum = 0						  
    int leftsum = sumAtKthLevel ( tree , k , level + 1 ) ;    	      if ( level == k ) :				    	    if level == k :					  
    ++ i ;						      		  sum = int ( tree [ i [ 0 ] ] )		    		sum = tree [ i ] - '0'				  
    int rightsum = sumAtKthLevel ( tree , k , level + 1 ) ;   	      i [ 0 ] += 1					    	    i += 1						  
    ++ i ;						      	      leftsum = sumAtKthLevel ( tree , k , i , level + 1 )  	    leftsum = sum_at_kth_level ( tree , k , level + 1 )	  
    return sum + leftsum + rightsum ;			      	      i [ 0 ] += 1					    	    i += 1						  
  }							      	      rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) 	    rightsum = sum_at_kth_level ( tree , k , level + 1 )  
  return Integer . MIN_VALUE ;				      	      i [ 0 ] += 1					    	    i += 1						  
}							      	      return sum + leftsum + rightsum			    	    return sum + leftsum + rightsum			  
							      								    	return int ( 0 )					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES
--							      --							    --								  --
static int countNum ( int arr [ ] , int n ) {		      def countNum ( arr , n ) :				    def count_num ( arr , n ) :					  failure : #Results: 6, 10
  HashSet < Integer > s = new HashSet < > ( ) ;		      	  s = dict ( )						    	s = set ( )						  
  int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer 	  count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9		    	count , maxm , minm = 0 , 0 , 0				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      s [ arr [ i ] ] = 1				    	    s.add ( arr [ i ] )					  
  i ++ ) {						      	      if ( arr [ i ] < minm ) :				    	    if arr [ i ] < minm :				  
    s . add ( arr [ i ] ) ;				      		  minm = arr [ i ]				    		minm = arr [ i ]				  
    if ( arr [ i ] < minm ) minm = arr [ i ] ;		      	      if ( arr [ i ] > maxm ) :				    	    if arr [ i ] > maxm :				  
    if ( arr [ i ] > maxm ) maxm = arr [ i ] ;		      		  maxm = arr [ i ]				    		maxm = arr [ i ]				  
  }							      	  for i in range ( minm , maxm + 1 ) :			    	for i in range ( minm , maxm + 1 ) :			  
  for ( int i = minm ;					      	      if i not in s.keys ( ) :				    	    if i not in s :					  
  i <= maxm ;						      		  count += 1					    		count += 1					  
  i ++ ) if ( ! s . contains ( i ) ) count ++ ;		      	  return count						    	return count						  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1	      FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1		    FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1		  FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1
--							      --							    --								  --
static int minCoins ( int coins [ ] , int m , int V ) {	      def minCoins ( coins , m , V ) :				    def min_coins ( coins , m , V ) :				  script_not_found : None
  int table [ ] = new int [ V + 1 ] ;			      	  table = [ 0 for i in range ( V + 1 ) ]		    	table = [ 0 ] * ( V + 1 )				  
  table [ 0 ] = 0 ;					      	  table [ 0 ] = 0					    	table [ 0 ] = 0						  
  for ( int i = 1 ;					      	  for i in range ( 1 , V + 1 ) :			    	for i in range ( 1 , V + 1 ) :				  
  i <= V ;						      	      table [ i ] = sys.maxsize				    	    table [ i ] = sys.maxsize				  
  i ++ ) table [ i ] = Integer . MAX_VALUE ;		      	  for i in range ( 1 , V + 1 ) :			    	for i in range ( 1 , V + 1 ) :				  
  for ( int i = 1 ;					      	      for j in range ( m ) :				    	    for j in range ( m ) :				  
  i <= V ;						      		  if ( coins [ j ] <= i ) :			    		if coins [ j ] <= i :				  
  i ++ ) {						      		      sub_res = table [ i - coins [ j ] ]	    		    sub_res = table [ i - coins [ j ] ]		  
    for ( int j = 0 ;					      		      if ( sub_res != sys.maxsize and sub_res + 1 < 		    if sub_res != sys.maxsize and sub_res + 1 < t 
    j < m ;						      			  table [ i ] = sub_res + 1		    			table [ i ] = sub_res + 1		  
    j ++ ) if ( coins [ j ] <= i ) {			      	  return table [ V ]					    	return table [ V ]					  
      int sub_res = table [ i - coins [ j ] ] ;		      								    								  
      if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < ta 								    								  
    }							      								    								  
  }							      								    								  
  return table [ V ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1		      MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1		    MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1		  MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1
--							      --							    --								  --
static int maxSum ( int arr [ ] , int n ) {		      def maxSum ( arr , n ) :					    def max_sum ( arr , n ) :					  success : None
  int cum_sum = 0 ;					      	  cum_sum = 0						    	cum_sum = 0						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      cum_sum += arr [ i ]				    	    cum_sum += arr [ i ]				  
  i ++ ) cum_sum += arr [ i ] ;				      	  curr_val = 0						    	curr_val = 0						  
  int curr_val = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      curr_val += i * arr [ i ]				    	    curr_val += i * arr [ i ]				  
  i < n ;						      	  res = curr_val					    	res = curr_val						  
  i ++ ) curr_val += i * arr [ i ] ;			      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  int res = curr_val ;					      	      next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + 	    next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + a 
  for ( int i = 1 ;					      	      curr_val = next_val				    	    curr_val = next_val					  
  i < n ;						      	      res = max ( res , next_val )			    	    res = max ( res , next_val )			  
  i ++ ) {						      	  return res						    	return res						  
    int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + a 								    								  
    curr_val = next_val ;				      								    								  
    res = Math . max ( res , next_val ) ;		      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1		      FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1		    FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1			  FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1
--							      --							    --								  --
static void findTriplets ( int arr [ ] , int n ) {	      def findTriplets ( arr , n ) :				    def find_triplets ( arr , n ) :				  success : None
  boolean found = false ;				      	  found = False						    	found = False						  
  for ( int i = 0 ;					      	  for i in range ( n - 1 ) :				    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      s = set ( )					    	    s = set ( )						  
  i ++ ) {						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
    HashSet < Integer > s = new HashSet < Integer > ( ) ;     		  x = - ( arr [ i ] + arr [ j ] )		    		x = - ( arr [ i ] + arr [ j ] )			  
    for ( int j = i + 1 ;				      		  if x in s :					    		if x in s :					  
    j < n ;						      		      print ( x , arr [ i ] , arr [ j ] )	    		    print ( "%d %d %d\n" % ( x , arr [ i ] , arr  
    j ++ ) {						      		      found = True				    		    found = True				  
      int x = - ( arr [ i ] + arr [ j ] ) ;		      		  else :					    		else :						  
      if ( s . contains ( x ) ) {			      		      s.add ( arr [ j ] )			    		    s.add ( arr [ j ] )				  
	System . out . printf ( "%d %d %d\n" , x , arr [ i ]  	  if found == False :					    	if found == False :					  
	found = true ;					      	      print ( "No Triplet Found" )			    	    print ( " No Triplet Found\n" )			  
      }							      								    								  
      else {						      								    								  
	s . add ( arr [ j ] ) ;				      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  if ( found == false ) {				      								    								  
    System . out . printf ( " No Triplet Found\n" ) ;	      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_MAXIMUM_GCD_ARRAY_1				      FIND_PAIR_MAXIMUM_GCD_ARRAY_1				    FIND_PAIR_MAXIMUM_GCD_ARRAY_1				  FIND_PAIR_MAXIMUM_GCD_ARRAY_1
--							      --							    --								  --
public static int findMaxGCD ( int arr [ ] , int n ) {	      def findMaxGCD ( arr , n ) :				    def find_max_gcd ( arr , n ) :				  script_not_found : None
  int high = 0 ;					      	  high = 0						    	high = 0						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      high = max ( high , arr [ i ] )			    	    high = max ( high , arr [ i ] )			  
  i ++ ) high = Math . max ( high , arr [ i ] ) ;	      	  count = [ 0 ] * ( high + 1 )				    	count = [ 0 ] * ( high + 1 )				  
  int count [ ] = new int [ high + 1 ] ;		      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      count [ arr [ i ] ] += 1				    	    count [ arr [ i ] ] += 1				  
  i < n ;						      	  counter = 0						    	counter = 0						  
  i ++ ) count [ arr [ i ] ] ++ ;			      	  for i in range ( high , 0 , - 1 ) :			    	for i in range ( high , 1 , - 1 ) :			  
  int counter = 0 ;					      	      j = i						    	    j = i						  
  for ( int i = high ;					      	      while ( j <= high ) :				    	    while j <= high :					  
  i >= 1 ;						      		  if ( count [ j ] > 0 ) :			    		if count [ j ] > 0 :				  
  i -- ) {						      		      counter += count [ j ]			    		    counter += count [ j ]			  
    int j = i ;						      		  j += i					    		j += i						  
    while ( j <= high ) {				      		  if ( counter == 2 ) :				    		if counter == 2 :				  
      if ( count [ j ] > 0 ) counter += count [ j ] ;	      		      return i					    		    return i					  
      j += i ;						      	      counter = 0					    	    counter = 0						  
      if ( counter == 2 ) return i ;			      								    	return 1						  
    }							      								    								  
    counter = 0 ;					      								    								  
  }							      								    								  
  return 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS		      FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS		    FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS			  FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS
--							      --							    --								  --
static void relativeComplement ( int arr1 [ ] , int arr2 [ ]  def relativeComplement ( arr1 , arr2 , n , m ) :		    def relativeComplement ( arr1 , arr2 , n , m ) :		  script_not_found : None
  int i = 0 , j = 0 ;					      	  i = 0							    	i , j = 0 , 0						  
  while ( i < n && j < m ) {				      	  j = 0							    	while i < n and j < m :					  
    if ( arr1 [ i ] < arr2 [ j ] ) {			      	  while ( i < n and j < m ) :				    	    if arr1 [ i ] < arr2 [ j ] :			  
      System . out . print ( arr1 [ i ] + " " ) ;	      	      if ( arr1 [ i ] < arr2 [ j ] ) :			    		print ( arr1 [ i ] , end = ' ' )		  
      i ++ ;						      		  print ( arr1 [ i ] , "" , end = "" )		    		i += 1						  
    }							      		  i += 1					    	    elif arr1 [ i ] > arr2 [ j ] :			  
    else if ( arr1 [ i ] > arr2 [ j ] ) {		      	      elif ( arr1 [ i ] > arr2 [ j ] ) :		    		j += 1						  
      j ++ ;						      		  j += 1					    	    elif arr1 [ i ] == arr2 [ j ] :			  
    }							      	      elif ( arr1 [ i ] == arr2 [ j ] ) :		    		i += 1						  
    else if ( arr1 [ i ] == arr2 [ j ] ) {		      		  i += 1					    		j += 1						  
      i ++ ;						      		  j += 1					    	while i < n :						  
      j ++ ;						      	  while ( i < n ) :					    	    print ( arr1 [ i ] , end = ' ' )			  
    }							      	      print ( arr1 [ i ] , "" , end = "" )		    								  
  }							      								    								  
  while ( i < n ) System . out . print ( arr1 [ i ] + " " ) ; 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1   REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1   REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1	  REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1
--							      --							    --								  --
static void translate ( char str [ ] ) {		      def translate ( st ) :					    def translate ( str ) :					  script_not_found : None
  int len = str . length ;				      	  l = len ( st )					    	s = list ( str )					  
  if ( len < 2 ) return ;				      	  if ( l < 2 ) :					    	if len ( s ) < 2 :					  
  int i = 0 ;						      	      return						    	    return						  
  int j = 0 ;						      	  i = 0							    	i = 0							  
  while ( j < len - 1 ) {				      	  j = 0							    	j = 0							  
    if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) {	      	  while ( j < l - 1 ) :					    	while j < len ( s ) - 1 :				  
      j = j + 2 ;					      	      if ( st [ j ] == 'A' and st [ j + 1 ] == 'B' ) :	    	    if s [ j ] == 'A' and s [ j + 1 ] == 'B' :		  
      str [ i ++ ] = 'C' ;				      		  j += 2					    		j = j + 2					  
      continue ;					      		  st [ i ] = 'C'				    		s [ i ] = 'C'					  
    }							      		  i += 1					    		continue					  
    str [ i ++ ] = str [ j ++ ] ;			      		  continue					    	    s [ i ] = s [ j ]					  
  }							      	      st [ i ] = st [ j ]				    	    j = j + 1						  
  if ( j == len - 1 ) str [ i ++ ] = str [ j ] ;	      	      i += 1						    	if j == len ( s ) - 1 :					  
  str [ i ] = ' ' ;					      	      j += 1						    	    s [ i ] = s [ j ]					  
  str [ len - 1 ] = ' ' ;				      	  if ( j == l - 1 ) :					    	s [ i ] = ' '						  
}							      	      st [ i ] = st [ j ]				    	s [ - 1 ] = ' '						  
							      	      i += 1						    								  
							      	  st [ i ] = ' '					    								  
							      	  st [ l - 1 ] = ' '					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3	  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3
--							      --							    --								  --
static int findLength ( String str , int n ) {		      def findLength ( st , n ) :				    def find_length ( str , n ) :				  script_not_found : None
  int ans = 0 ;						      	  total = [ 0 ] * ( n + 1 )				    	ans = 0							  
  for ( int i = 0 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 0 , n - 2 + 1 ) :			  
  i <= n - 2 ;						      	      total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ]  	    l , r = i , i + 1					  
  i ++ ) {						      	  ans = 0						    	    lsum , rsum = 0 , 0					  
    int l = i , r = i + 1 ;				      	  l = 2							    	    while r < n and l >= 0 :				  
    int lsum = 0 , rsum = 0 ;				      	  while ( l <= n ) :					    		lsum += ord ( str [ l ] ) - ord ( '0' )		  
    while ( r < n && l >= 0 ) {				      	      for i in range ( n - l + 1 ) :			    		rsum += ord ( str [ r ] ) - ord ( '0' )		  
      lsum += str . charAt ( l ) - '0' ;		      		  j = i + l - 1					    		if lsum == rsum :				  
      rsum += str . charAt ( r ) - '0' ;		      		  if ( total [ i + int ( l / 2 ) ] - total [ i ] == 		    ans = max ( ans , r - l + 1 )		  
      if ( lsum == rsum ) {				      		      ans = max ( ans , l )			    		l -= 1						  
	ans = Math . max ( ans , r - l + 1 ) ;		      	      l = l + 2						    		r += 1						  
      }							      	  return ans						    	return ans						  
      l -- ;						      								    								  
      r ++ ;						      								    								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS		      MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS		    MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS		  MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS
--							      --							    --								  --
static int maximumSum ( int a [ ] [ ] , int n ) {	      def maximumSum ( a , n ) :				    def maximum_sum ( a , n ) :					  script_not_found : None
  for ( int i = 0 ;					      	  global M						    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( 0 , n ) :				    	    sort ( a , i , n )					  
  i ++ ) sort ( a , i , n ) ;				      	      a [ i ].sort ( )					    	sum = a [ n - 1 ] [ M - 1 ]				  
  int sum = a [ n - 1 ] [ M - 1 ] ;			      	  sum = a [ n - 1 ] [ M - 1 ]				    	prev = a [ n - 1 ] [ M - 1 ]				  
  int prev = a [ n - 1 ] [ M - 1 ] ;			      	  prev = a [ n - 1 ] [ M - 1 ]				    	i , j = 0 , 0						  
  int i , j ;						      	  for i in range ( n - 2 , - 1 , - 1 ) :		    	for i in range ( n - 2 , - 1 , - 1 ) :			  
  for ( i = n - 2 ;					      	      for j in range ( M - 1 , - 1 , - 1 ) :		    	    for j in range ( M - 1 , - 1 , - 1 ) :		  
  i >= 0 ;						      		  if ( a [ i ] [ j ] < prev ) :			    		if a [ i ] [ j ] < prev :			  
  i -- ) {						      		      prev = a [ i ] [ j ]			    		    prev = a [ i ] [ j ]			  
    for ( j = M - 1 ;					      		      sum += prev				    		    sum += prev					  
    j >= 0 ;						      		      break					    		    break					  
    j -- ) {						      	      if ( j == - 1 ) :					    	    if j == - 1 :					  
      if ( a [ i ] [ j ] < prev ) {			      		  return 0					    		return 0					  
	prev = a [ i ] [ j ] ;				      	  return sum						    	return sum						  
	sum += prev ;					      								    								  
	break ;						      								    								  
      }							      								    								  
    }							      								    								  
    if ( j == - 1 ) return 0 ;				      								    								  
  }							      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1	      MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1	    MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1	  MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1
--							      --							    --								  --
private static int minJumps ( int [ ] arr , int n ) {	      def minJumps ( arr , n ) :				    def _min_jumps ( arr , n ) :				  failure : #Results: 5, 10
  int jumps [ ] = new int [ n ] ;			      	  jumps = [ 0 for i in range ( n ) ]			    	jumps = [ 0 ] * n					  
  int i , j ;						      	  if ( n == 0 ) or ( arr [ 0 ] == 0 ) :			    	i , j = 0 , 0						  
  if ( n == 0 || arr [ 0 ] == 0 ) return Integer . MAX_VALUE  	      return float ( 'inf' )				    	if not n or not arr [ 0 ] :				  
  jumps [ 0 ] = 0 ;					      	  jumps [ 0 ] = 0					    	    return sys.maxsize					  
  for ( i = 1 ;						      	  for i in range ( 1 , n ) :				    	jumps [ 0 ] = 0						  
  i < n ;						      	      jumps [ i ] = float ( 'inf' )			    	for i in range ( 1 , n ) :				  
  i ++ ) {						      	      for j in range ( i ) :				    	    jumps [ i ] = sys.maxsize				  
    jumps [ i ] = Integer . MAX_VALUE ;			      		  if ( i <= j + arr [ j ] ) and ( jumps [ j ] != fl 	    for j in range ( i ) :				  
    for ( j = 0 ;					      		      jumps [ i ] = min ( jumps [ i ] , jumps [ j ] 		if i <= j + arr [ j ] and jumps [ j ] != sys.maxs 
    j < i ;						      		      break					    		    jumps [ i ] = min ( jumps [ i ] , jumps [ j ] 
    j ++ ) {						      	  return jumps [ n - 1 ]				    		    break					  
      if ( i <= j + arr [ j ] && jumps [ j ] != Integer . MAX 								    	return jumps [ n - 1 ]					  
	jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ]  								    								  
	break ;						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return jumps [ n - 1 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S			      LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S			    LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S			  LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S
--							      --							    --								  --
static int lenOfLongSubarr ( int arr [ ] , int n ) {	      def lenOfLongSubarr ( arr , n ) :				    def len_of_long_subarr ( arr , n ) :			  failure : #Results: 4, 10
  HashMap < Integer , Integer > um = new HashMap < Integer ,  	  um = { i : 0 for i in range ( 10 ) }			    	um = { }						  
  int sum = 0 , maxLen = 0 ;				      	  sum = 0						    	sum , max_len = 0 , 0					  
  for ( int i = 0 ;					      	  maxLen = 0						    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( n ) :				    	    sum += - 1 if arr [ i ] == 0 else 1			  
  i ++ ) {						      	      if arr [ i ] == 0 :				    	    if sum == 1 :					  
    sum += arr [ i ] == 0 ? - 1 : 1 ;			      		  sum += - 1					    		max_len = i + 1					  
    if ( sum == 1 ) maxLen = i + 1 ;			      	      else :						    	    elif sum not in um :				  
    else if ( ! um . containsKey ( sum ) ) um . put ( sum , i 		  sum += 1					    		um [ sum ] = i					  
    if ( um . containsKey ( sum - 1 ) ) {		      	      if ( sum == 1 ) :					    	    if sum - 1 in um :					  
      if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i 		  maxLen = i + 1				    		if max_len < ( i - um [ sum - 1 ] ) :		  
    }							      	      elif ( sum not in um ) :				    		    max_len = i - um [ sum - 1 ]		  
  }							      		  um [ sum ] = i				    	return max_len						  
  return maxLen ;					      	      if ( ( sum - 1 ) in um ) :			    								  
}							      		  if ( maxLen < ( i - um [ sum - 1 ] ) ) :	    								  
							      		      maxLen = i - um [ sum - 1 ]		    								  
							      	  return maxLen						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES	      CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES		    CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES		  CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES
--							      --							    --								  --
static int minRemove ( int arr [ ] , int n ) {		      def minRemove ( arr , n ) :				    def min_remove ( arr , n ) :				  success : None
  int LIS [ ] = new int [ n ] ;				      	  LIS = [ 0 for i in range ( n ) ]			    	LIS = [ 0 ] * n						  
  int len = 0 ;						      	  len = 0						    	len_ = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      LIS [ i ] = 1					    	    LIS [ i ] = 1					  
  i ++ ) LIS [ i ] = 1 ;				      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      	      for j in range ( i ) :				    	    for j in range ( i ) :				  
  i < n ;						      		  if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr 		if arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ 
  i ++ ) {						      		      LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) 		    LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) 
    for ( int j = 0 ;					      	      len = max ( len , LIS [ i ] )			    	    len_ = max ( len_ , LIS [ i ] )			  
    j < i ;						      	  return ( n - len )					    	return n - len_						  
    j ++ ) {						      								    								  
      if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ]  								    								  
    }							      								    								  
    len = Math . max ( len , LIS [ i ] ) ;		      								    								  
  }							      								    								  
  return n - len ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_PREFIX_ALSO_SUFFIX_1				      LONGEST_PREFIX_ALSO_SUFFIX_1				    LONGEST_PREFIX_ALSO_SUFFIX_1				  LONGEST_PREFIX_ALSO_SUFFIX_1
--							      --							    --								  --
static int longestPrefixSuffix ( String s ) {		      def longestPrefixSuffix ( s ) :				    def longest_prefix_suffix ( s ) :				  error : Traceback (most recent call last):   File
  int n = s . length ( ) ;				      	  n = len ( s )						    	n = len ( s )						  "dump/transcoder_st/eval/java_python/online_st/206
  int lps [ ] = new int [ n ] ;				      	  lps = [ 0 ] * n					    	lps = [ 0 ] * n						  68770/eval_scripts/java_sa-python_sa.test/LONGEST_
  lps [ 0 ] = 0 ;					      	  l = 0							    	data = None						  PREFIX_ALSO_SUFFIX_1.py", line 74, in <module>
  int len = 0 ;						      	  i = 1							    	i = 1							   if f_filled(*parameters_set) == f_gold(*parameter
  int i = 1 ;						      	  while ( i < n ) :					    	while i < n :						  s_set):   File "dump/transcoder_st/eval/java_pytho
  while ( i < n ) {					      	      if ( s [ i ] == s [ l ] ) :			    	    if s [ i ] == s [ len ( s ) ] :			  n/online_st/20668770/eval_scripts/java_sa-python_s
    if ( s . charAt ( i ) == s . charAt ( len ) ) {	      		  l = l + 1					    		data = s [ i ]					  a.test/LONGEST_PREFIX_ALSO_SUFFIX_1.py", line 46,
      len ++ ;						      		  lps [ i ] = l					    		i += 1						  in f_filled	  if s [ i ] == s [ len ( s ) ] : In
      lps [ i ] = len ;					      		  i = i + 1					    	    else :						  dexError: string index out of range
      i ++ ;						      	      else :						    		if data is not None :				  
    }							      		  if ( l != 0 ) :				    		    data = lps [ data - 1 ]			  
    else {						      		      l = lps [ l - 1 ]				    		else :						  
      if ( len != 0 ) {					      		  else :					    		    lps [ i ] = 0				  
	len = lps [ len - 1 ] ;				      		      lps [ i ] = 0				    		    i += 1					  
      }							      		      i = i + 1					    	res = lps [ n - 1 ]					  
      else {						      	  res = lps [ n - 1 ]					    	return ( n // 2 ) if res > n // 2 else res		  
	lps [ i ] = 0 ;					      	  if ( res > n / 2 ) :					    								  
	i ++ ;						      	      return n // 2					    								  
      }							      	  else :						    								  
    }							      	      return res					    								  
  }							      								    								  
  int res = lps [ n - 1 ] ;				      								    								  
  return ( res > n / 2 ) ? n / 2 : res ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUBARRAY_WITH_GIVEN_SUM_1				      FIND_SUBARRAY_WITH_GIVEN_SUM_1				    FIND_SUBARRAY_WITH_GIVEN_SUM_1				  FIND_SUBARRAY_WITH_GIVEN_SUM_1
--							      --							    --								  --
int subArraySum ( int arr [ ] , int n , int sum ) {	      def subArraySum ( arr , n , sum ) :			    def subarray_sum ( arr , n , sum ) :			  error : Traceback (most recent call last):   File
  int curr_sum = arr [ 0 ] , start = 0 , i ;		      	  curr_sum = arr [ 0 ]					    	curr_sum = arr [ 0 ] , start , i			  "dump/transcoder_st/eval/java_python/online_st/206
  for ( i = 1 ;						      	  start = 0						    	for i in range ( 1 , n + 1 ) :				  68770/eval_scripts/java_sa-python_sa.test/FIND_SUB
  i <= n ;						      	  i = 1							    	    while curr_sum > sum and start < i - 1 :		  ARRAY_WITH_GIVEN_SUM_1.py", line 67, in <module>
  i ++ ) {						      	  while i <= n :					    		curr_sum = curr_sum - arr [ start ]		     if f_filled(*parameters_set) == f_gold(*paramet
    while ( curr_sum > sum && start < i - 1 ) {		      	      while curr_sum > sum and start < i - 1 :		    		start += 1					  ers_set):   File "dump/transcoder_st/eval/java_pyt
      curr_sum = curr_sum - arr [ start ] ;		      		  curr_sum = curr_sum - arr [ start ]		    	    if curr_sum == sum :				  hon/online_st/20668770/eval_scripts/java_sa-python
      start ++ ;					      		  start += 1					    		p = i - 1					  _sa.test/FIND_SUBARRAY_WITH_GIVEN_SUM_1.py", line
    }							      	      if curr_sum == sum :				    		print ( "Sum found between indexes %d and %d" % ( 37, in f_filled     curr_sum = arr [ 0 ] , start ,
    if ( curr_sum == sum ) {				      		  print ( "Sum found between indexes" )		    		return 1					   i UnboundLocalError: local variable 'start' refer
      int p = i - 1 ;					      		  print ( "%d and %d" % ( start , i - 1 ) )	    	    if i < n :						  enced before assignment
      System . out . println ( "Sum found between indexes " + 		  return 1					    		curr_sum = curr_sum + arr [ i ]			  
      return 1 ;					      	      if i < n :					    	print ( "No subarray found" )				  
    }							      		  curr_sum = curr_sum + arr [ i ]		    	return 0						  
    if ( i < n ) curr_sum = curr_sum + arr [ i ] ;	      	      i += 1						    								  
  }							      	  print ( "No subarray found" )				    								  
  System . out . println ( "No subarray found" ) ;	      	  return 0						    								  
  return 0 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS
--							      --							    --								  --
static int countGroups ( int position , int previous_sum , in def countGroups ( position , previous_sum , length , num ) :  def count_groups ( position , previous_sum , length , num ) : script_not_found : None
  if ( position == length ) return 1 ;			      	  if ( position == length ) :				    	if position == length :					  
  if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [  	      return 1						    	    return 1						  
  dp [ position ] [ previous_sum ] = 0 ;		      	  if ( dp [ position ] [ previous_sum ] != - 1 ) :	    	if previous_sum in dp [ position ] :			  
  int res = 0 ;						      	      return dp [ position ] [ previous_sum ]		    	    return dp [ position ] [ previous_sum ]		  
  int sum = 0 ;						      	  dp [ position ] [ previous_sum ] = 0			    	dp [ position ] [ previous_sum ] = 0			  
  for ( int i = position ;				      	  res = 0						    	res = 0							  
  i < length ;						      	  sum = 0						    	sum = 0							  
  i ++ ) {						      	  for i in range ( position , length ) :		    	for i in range ( position , length ) :			  
    sum += ( num [ i ] - '0' ) ;			      	      sum += ( ord ( num [ i ] ) - ord ( '0' ) )	    	    sum += ord ( num [ i ] ) - ord ( '0' )		  
    if ( sum >= previous_sum ) res += countGroups ( i + 1 , s 	      if ( sum >= previous_sum ) :			    	    if sum >= previous_sum :				  
  }							      		  res += countGroups ( i + 1 , sum , length , num ) 		res += count_groups ( i + 1 , sum , length , num  
  dp [ position ] [ previous_sum ] = res ;		      	  dp [ position ] [ previous_sum ] = res		    	dp [ position ] [ previous_sum ] = res			  
  return res ;						      	  return res						    	return res						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_SUBSEQUENCES				      COUNT_DISTINCT_SUBSEQUENCES				    COUNT_DISTINCT_SUBSEQUENCES					  COUNT_DISTINCT_SUBSEQUENCES
--							      --							    --								  --
static int countSub ( String str ) {			      def countSub ( ss ) :					    def count_sub ( str ) :					  script_not_found : None
  int [ ] last = new int [ MAX_CHAR ] ;			      	  last = [ - 1 for i in range ( MAX_CHAR + 1 ) ]	    	last = np.zeros ( MAX_CHAR )				  
  Arrays . fill ( last , - 1 ) ;			      	  n = len ( ss )					    	last [ - 1 ] = 1					  
  int n = str . length ( ) ;				      	  dp = [ - 2 for i in range ( n + 1 ) ]			    	n = len ( str )						  
  int [ ] dp = new int [ n + 1 ] ;			      	  dp [ 0 ] = 1						    	dp = np.zeros ( n + 1 )					  
  dp [ 0 ] = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	dp [ 0 ] = 1						  
  for ( int i = 1 ;					      	      dp [ i ] = 2 * dp [ i - 1 ]			    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	      if last [ ord ( ss [ i - 1 ] ) ] != - 1 :		    	    dp [ i ] = 2 * dp [ i - 1 ]				  
  i ++ ) {						      		  dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i -  	    if last [ ord ( str [ i - 1 ] ) ] != - 1 :		  
    dp [ i ] = 2 * dp [ i - 1 ] ;			      	      last [ ord ( ss [ i - 1 ] ) ] = i - 1		    		dp [ i ] = dp [ i ] - dp [ last [ ord ( str [ i - 
    if ( last [ ( int ) str . charAt ( i - 1 ) ] != - 1 ) dp  	  return dp [ n ]					    	    last [ ord ( str [ i - 1 ] ) ] = ( i - 1 )		  
    last [ ( int ) str . charAt ( i - 1 ) ] = ( i - 1 ) ;     								    	return dp [ n ]						  
  }							      								    								  
  return dp [ n ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX		      COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX		    COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX		  COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX
--							      --							    --								  --
static void printCommonElements ( int mat [ ] [ ] ) {	      def printCommonElements ( mat ) :				    def print_common_elements ( mat ) :				  script_not_found : None
  Map < Integer , Integer > mp = new HashMap < > ( ) ;	      	  mp = dict ( )						    	mp = { }						  
  for ( int j = 0 ;					      	  for j in range ( N ) :				    	for j in range ( N ) :					  
  j < N ;						      	      mp [ mat [ 0 ] [ j ] ] = 1			    	    mp [ mat [ 0 ] [ j ] ] = 1				  
  j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ;		      	  for i in range ( 1 , M ) :				    	for i in range ( 1 , M ) :				  
  for ( int i = 1 ;					      	      for j in range ( N ) :				    	    for j in range ( N ) :				  
  i < M ;						      		  if ( mat [ i ] [ j ] in mp.keys ( ) and mp [ mat  		if mp.get ( mat [ i ] [ j ] ) and mp [ mat [ i ]  
  i ++ ) {						      		      mp [ mat [ i ] [ j ] ] = i + 1		    		    mp [ mat [ i ] [ j ] ] = i + 1		  
    for ( int j = 0 ;					      		      if i == M - 1 :				    		    if i == M - 1 :				  
    j < N ;						      			  print ( mat [ i ] [ j ] , end = " " )	    			print ( mat [ i ] [ j ] , end = ' ' )	  
    j ++ ) {						      								    								  
      if ( mp . get ( mat [ i ] [ j ] ) != null && mp . get ( 								    								  
	mp . put ( mat [ i ] [ j ] , i + 1 ) ;		      								    								  
	if ( i == M - 1 ) System . out . print ( mat [ i ] [  								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE	      CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE	    CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE	  CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE
--							      --							    --								  --
static int isChangeable ( int notes [ ] , int n ) {	      def isChangeable ( notes , n ) :				    def is_changeable ( notes , n ) :				  success : None
  int fiveCount = 0 ;					      	  fiveCount = 0						    	five_count = 0						  
  int tenCount = 0 ;					      	  tenCount = 0						    	ten_count = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( notes [ i ] == 5 ) :				    	    if notes [ i ] == 5 :				  
  i ++ ) {						      		  fiveCount += 1				    		five_count += 1					  
    if ( notes [ i ] == 5 ) fiveCount ++ ;		      	      elif ( notes [ i ] == 10 ) :			    	    elif notes [ i ] == 10 :				  
    else if ( notes [ i ] == 10 ) {			      		  if ( fiveCount > 0 ) :			    		if five_count > 0 :				  
      if ( fiveCount > 0 ) {				      		      fiveCount -= 1				    		    five_count -= 1				  
	fiveCount -- ;					      		      tenCount += 1				    		    ten_count += 1				  
	tenCount ++ ;					      		  else :					    		else :						  
      }							      		      return 0					    		    return 0					  
      else return 0 ;					      	      else :						    	    else :						  
    }							      		  if ( fiveCount > 0 and tenCount > 0 ) :	    		if five_count > 0 and ten_count > 0 :		  
    else {						      		      fiveCount -= 1				    		    five_count -= 1				  
      if ( fiveCount > 0 && tenCount > 0 ) {		      		      tenCount -= 1				    		    ten_count -= 1				  
	fiveCount -- ;					      		  elif ( fiveCount >= 3 ) :			    		elif five_count >= 3 :				  
	tenCount -- ;					      		      fiveCount -= 3				    		    five_count -= 3				  
      }							      		  else :					    		else :						  
      else if ( fiveCount >= 3 ) {			      		      return 0					    		    return 0					  
	fiveCount -= 3 ;				      	  return 1						    	return 1						  
      }							      								    								  
      else return 0 ;					      								    								  
    }							      								    								  
  }							      								    								  
  return 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
UNIQUE_CELLS_BINARY_MATRIX				      UNIQUE_CELLS_BINARY_MATRIX				    UNIQUE_CELLS_BINARY_MATRIX					  UNIQUE_CELLS_BINARY_MATRIX
--							      --							    --								  --
static int countUnique ( int mat [ ] [ ] , int n , int m ) {  def countUnique ( mat , n , m ) :				    def count_unique ( mat , n , m ) :				  success : None
  int [ ] rowsum = new int [ n ] ;			      	  rowsum = [ 0 ] * n					    	rowsum = [ 0 ] * n					  
  int [ ] colsum = new int [ m ] ;			      	  colsum = [ 0 ] * m					    	colsum = [ 0 ] * m					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( m ) :				    	    for j in range ( m ) :				  
  i ++ ) for ( int j = 0 ;				      		  if ( mat [ i ] [ j ] != 0 ) :			    		if mat [ i ] [ j ] != 0 :			  
  j < m ;						      		      rowsum [ i ] += 1				    		    rowsum [ i ] += 1				  
  j ++ ) if ( mat [ i ] [ j ] != 0 ) {			      		      colsum [ j ] += 1				    		    colsum [ j ] += 1				  
    rowsum [ i ] ++ ;					      	  uniquecount = 0					    	uniquecount = 0						  
    colsum [ j ] ++ ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  }							      	      for j in range ( m ) :				    	    for j in range ( m ) :				  
  int uniquecount = 0 ;					      		  if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 a 		if mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 and 
  for ( int i = 0 ;					      		      uniquecount += 1				    		    uniquecount += 1				  
  i < n ;						      	  return uniquecount					    	return uniquecount					  
  i ++ ) for ( int j = 0 ;				      								    								  
  j < m ;						      								    								  
  j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && co 								    								  
  return uniquecount ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS		      COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS		    COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS		  COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS
--							      --							    --								  --
static int countSubarrays ( int [ ] arr , int n ) {	      def countSubarrays ( arr , n ) :				    def count_subarrays ( arr , n ) :				  success : None
  int difference = 0 ;					      	  difference = 0					    	difference = 0						  
  int ans = 0 ;						      	  ans = 0						    	ans = 0							  
  int [ ] hash_positive = new int [ n + 1 ] ;		      	  hash_positive = [ 0 ] * ( n + 1 )			    	hash_positive = [ 0 ] * ( n + 1 )			  
  int [ ] hash_negative = new int [ n + 1 ] ;		      	  hash_negative = [ 0 ] * ( n + 1 )			    	hash_negative = [ 0 ] * ( n + 1 )			  
  hash_positive [ 0 ] = 1 ;				      	  hash_positive [ 0 ] = 1				    	hash_positive [ 0 ] = 1					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( arr [ i ] & 1 == 1 ) :			    	    if arr [ i ] & 1 == 1 :				  
  i ++ ) {						      		  difference = difference + 1			    		difference += 1					  
    if ( ( arr [ i ] & 1 ) == 1 ) {			      	      else :						    	    else :						  
      difference ++ ;					      		  difference = difference - 1			    		difference -= 1					  
    }							      	      if ( difference < 0 ) :				    	    if difference < 0 :					  
    else {						      		  ans += hash_negative [ - difference ]		    		ans += hash_negative [ - difference ]		  
      difference -- ;					      		  hash_negative [ - difference ] = hash_negative [  		hash_negative [ - difference ] += 1		  
    }							      	      else :						    	    else :						  
    if ( difference < 0 ) {				      		  ans += hash_positive [ difference ]		    		ans += hash_positive [ difference ]		  
      ans += hash_negative [ - difference ] ;		      		  hash_positive [ difference ] = hash_positive [ di 		hash_positive [ difference ] += 1		  
      hash_negative [ - difference ] ++ ;		      	  return ans						    	return ans						  
    }							      								    								  
    else {						      								    								  
      ans += hash_positive [ difference ] ;		      								    								  
      hash_positive [ difference ] ++ ;			      								    								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T
--							      --							    --								  --
static int maxDifference ( int arr [ ] , int N , int k ) {    def maxDifference ( arr , N , k ) :			    def max_difference ( arr , N , k ) :			  script_not_found : None
  int M , S = 0 , S1 = 0 , max_difference = 0 ;		      	  S = 0							    	M , S , S1 , max_difference = 0 , 0 , 0 , 0		  
  for ( int i = 0 ;					      	  S1 = 0						    	for i in range ( N ) :					  
  i < N ;						      	  max_difference = 0					    	    S += arr [ i ]					  
  i ++ ) S += arr [ i ] ;				      	  for i in range ( N ) :				    	for i in range ( N ) :					  
  int temp ;						      	      S += arr [ i ]					    	    for j in range ( i + 1 , N ) :			  
  for ( int i = 0 ;					      	  arr.sort ( reverse = True )				    		if arr [ i ] < arr [ j ] :			  
  i < N ;						      	  M = max ( k , N - k )					    		    temp = arr [ i ]				  
  i ++ ) {						      	  for i in range ( M ) :				    		    arr [ i ] = arr [ j ]			  
    for ( int j = i + 1 ;				      	      S1 += arr [ i ]					    		    arr [ j ] = temp				  
    j < N ;						      	  max_difference = S1 - ( S - S1 )			    	M = max ( k , N - k )					  
    j ++ ) {						      	  return max_difference					    	for i in range ( M ) :					  
      if ( arr [ i ] < arr [ j ] ) {			      								    	    S1 += arr [ i ]					  
	temp = arr [ i ] ;				      								    	max_difference = S1 - ( S - S1 )			  
	arr [ i ] = arr [ j ] ;				      								    	return max_difference					  
	arr [ j ] = temp ;				      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  M = Math . max ( k , N - k ) ;			      								    								  
  for ( int i = 0 ;					      								    								  
  i < M ;						      								    								  
  i ++ ) S1 += arr [ i ] ;				      								    								  
  max_difference = S1 - ( S - S1 ) ;			      								    								  
  return max_difference ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SORTED_ROWS_MATRIX				      COUNT_SORTED_ROWS_MATRIX					    COUNT_SORTED_ROWS_MATRIX					  COUNT_SORTED_ROWS_MATRIX
--							      --							    --								  --
static int sortedCount ( int mat [ ] [ ] , int r , int c ) {  def sortedCount ( mat , r , c ) :				    def sorted_count ( mat , r , c ) :				  failure : #Results: 7, 10
  int result = 0 ;					      	  result = 0						    	result = 0						  
  for ( int i = 0 ;					      	  for i in range ( r ) :				    	for i in range ( r ) :					  
  i < r ;						      	      j = 0						    	    for j in range ( c - 1 ) :				  
  i ++ ) {						      	      for j in range ( c - 1 ) :			    		if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] :	  
    int j ;						      		  if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] :	    		    break					  
    for ( j = 0 ;					      		      break					    	    if j == c - 1 :					  
    j < c - 1 ;						      	      if j == c - 2 :					    		result += 1					  
    j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) brea 		  result += 1					    	for i in range ( r ) :					  
    if ( j == c - 1 ) result ++ ;			      	  for i in range ( 0 , r ) :				    	    for j in range ( c - 1 , 0 , - 1 ) :		  
  }							      	      j = 0						    		if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] :	  
  for ( int i = 0 ;					      	      for j in range ( c - 1 , 0 , - 1 ) :		    		    break					  
  i < r ;						      		  if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] :	    	    if c > 1 and j == 0 :				  
  i ++ ) {						      		      break					    		result += 1					  
    int j ;						      	      if c > 1 and j == 1 :				    	return result						  
    for ( j = c - 1 ;					      		  result += 1					    								  
    j > 0 ;						      	  return result						    								  
    j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) brea 								    								  
    if ( c > 1 && j == 0 ) result ++ ;			      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY		      SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY		    SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY		  SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY
--							      --							    --								  --
static int search ( int arr [ ] , int l , int h , int key ) { def search ( arr , l , h , key ) :			    def search ( arr , l , h , key ) :				  error : Traceback (most recent call last):   File
  if ( l > h ) return - 1 ;				      	  if l > h :						    	if l > h :						  "dump/transcoder_st/eval/java_python/online_st/206
  int mid = ( l + h ) / 2 ;				      	      return - 1					    	    return - 1						  68770/eval_scripts/java_sa-python_sa.test/SEARCH_A
  if ( arr [ mid ] == key ) return mid ;		      	  mid = ( l + h ) // 2					    	mid = ( l + h ) // 2					  N_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY.py", line
  if ( arr [ l ] <= arr [ mid ] ) {			      	  if arr [ mid ] == key :				    	if arr [ mid ] == key :					  68, in <module>     if f_filled(*parameters_set) =
    if ( key >= arr [ l ] && key <= arr [ mid ] ) return sear 	      return mid					    	    return mid						  = f_gold(*parameters_set):   File "dump/transcoder
    return search ( arr , mid + 1 , h , key ) ;		      	  if arr [ l ] <= arr [ mid ] :				    	if arr [ l ] <= arr [ mid ] :				  _st/eval/java_python/online_st/20668770/eval_scrip
  }							      	      if key >= arr [ l ] and key <= arr [ mid ] :	    	    if key >= arr [ l ] and key <= arr [ mid ] :	  ts/java_sa-python_sa.test/SEARCH_AN_ELEMENT_IN_A_S
  if ( key >= arr [ mid ] && key <= arr [ h ] ) return search 		  return search ( arr , l , mid - 1 , key )	    		return search ( arr , l , mid - 1 , key )	  ORTED_AND_PIVOTED_ARRAY.py", line 26, in f_gold
  return search ( arr , l , mid - 1 , key ) ;		      	      return search ( arr , mid + 1 , h , key )		    	    return search ( arr , mid + 1 , h , key )		    return f_gold(arr, mid + 1, h, key)	  File "dump
}							      	  if key >= arr [ mid ] and key <= arr [ h ] :		    	if key >= arr [ mid ] and key <= arr [ h ] :		  /transcoder_st/eval/java_python/online_st/20668770
							      	      return search ( a , mid + 1 , h , key )		    	    return search ( arr , mid + 1 , h , key )		  /eval_scripts/java_sa-python_sa.test/SEARCH_AN_ELE
							      	  return search ( arr , l , mid - 1 , key )		    	return search ( arr , l , mid - 1 , key )		  MENT_IN_A_SORTED_AND_PIVOTED_ARRAY.py", line 28, i
							      								    								  n f_gold     return f_gold(a, mid + 1, h, key) Nam
							      								    								  eError: name 'a' is not defined
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF		  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF
--							      --							    --								  --
static int findLength ( String str ) {			      def findLength ( str ) :					    def find_length ( str ) :					  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  int maxlen = 0 ;					      	  maxlen = 0						    	maxlen = 0						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , n , 2 ) :		    	    for j in range ( i + 1 , n , 2 ) :			  
  i ++ ) {						      		  length = j - i + 1				    		length = j - i + 1				  
    for ( int j = i + 1 ;				      		  leftsum = 0					    		leftsum , rightsum = 0 , 0			  
    j < n ;						      		  rightsum = 0					    		for k in range ( length // 2 ) :		  
    j += 2 ) {						      		  for k in range ( 0 , int ( length / 2 ) ) :	    		    leftsum += ord ( str [ i + k ] ) - ord ( '0'  
      int length = j - i + 1 ;				      		      leftsum += ( int ( str [ i + k ] ) - int ( '0 		    rightsum += ord ( str [ i + k + length // 2 ] 
      int leftsum = 0 , rightsum = 0 ;			      		      rightsum += ( int ( str [ i + k + int ( lengt 		if leftsum == rightsum and maxlen < length :	  
      for ( int k = 0 ;					      		  if ( leftsum == rightsum and maxlen < length ) :  		    maxlen = length				  
      k < length / 2 ;					      		      maxlen = length				    	return maxlen						  
      k ++ ) {						      	  return maxlen						    								  
	leftsum += ( str . charAt ( i + k ) - '0' ) ;	      								    								  
	rightsum += ( str . charAt ( i + k + length / 2 ) - ' 								    								  
      }							      								    								  
      if ( leftsum == rightsum && maxlen < length ) maxlen =  								    								  
    }							      								    								  
  }							      								    								  
  return maxlen ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K		      MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K		    MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K		  MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K
--							      --							    --								  --
static void pairs ( int arr [ ] , int n , int k ) {	      def pairs ( arr , n , k ) :				    def pairs ( arr , n , k ) :					  script_not_found : None
  int smallest = Integer . MAX_VALUE ;			      	  smallest = 999999999999				    	smallest = sys.maxsize					  
  int count = 0 ;					      	  count = 0						    	count = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) for ( int j = i + 1 ;				      		  if abs ( arr [ i ] + arr [ j ] - k ) < smallest : 		if abs ( arr [ i ] + arr [ j ] - k ) < smallest : 
  j < n ;						      		      smallest = abs ( arr [ i ] + arr [ j ] - k )  		    smallest = abs ( arr [ i ] + arr [ j ] - k )  
  j ++ ) {						      		      count = 1					    		    count = 1					  
    if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest  		  elif abs ( arr [ i ] + arr [ j ] - k ) == smalles 		elif abs ( arr [ i ] + arr [ j ] - k ) == smalles 
      smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ;   		      count += 1				    		    count += 1					  
      count = 1 ;					      	  print ( "Minimal Value = " , smallest )		    	print ( "Minimal Value = %d" % smallest )		  
    }							      	  print ( "Total Pairs = " , count )			    	print ( "Total Pairs = %d" % count )			  
    else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == sma 								    								  
  }							      								    								  
  System . out . println ( "Minimal Value = " + smallest ) ;  								    								  
  System . out . println ( "Total Pairs = " + count ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE			      FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE			    FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE				  FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE
--							      --							    --								  --
static void printOtherSides ( int n ) {			      def printOtherSides ( n ) :				    def print_other_sides ( n ) :				  script_not_found : None
  if ( n % 2 != 0 ) {					      	  if ( n & 1 ) :					    	if n % 2 :						  
    if ( n == 1 ) System . out . println ( "-1" ) ;	      	      if ( n == 1 ) :					    	    if n == 1 :						  
    else {						      		  print ( - 1 )					    		print ( "-1" )					  
      int b = ( n * n - 1 ) / 2 ;			      	      else :						    	    else :						  
      int c = ( n * n + 1 ) / 2 ;			      		  b = ( n * n - 1 ) // 2			    		b = ( n * n - 1 ) // 2				  
      System . out . println ( "b = " + b + ", c = " + c ) ;  		  c = ( n * n + 1 ) // 2			    		c = ( n * n + 1 ) // 2				  
    }							      		  print ( "b =" , b , ", c =" , c )		    		print ( "b = %d, c = %d" % ( b , c ) )		  
  }							      	  else :						    	else :							  
  else {						      	      if ( n == 2 ) :					    	    if n == 2 :						  
    if ( n == 2 ) System . out . println ( "-1" ) ;	      		  print ( - 1 )					    		print ( "-1" )					  
    else {						      	      else :						    	    else :						  
      int b = n * n / 4 - 1 ;				      		  b = n * n // 4 - 1				    		b = n * n // 4 - 1				  
      int c = n * n / 4 + 1 ;				      		  c = n * n // 4 + 1				    		c = n * n // 4 + 1				  
      System . out . println ( "b = " + b + ", c = " + c ) ;  		  print ( "b =" , b", c =" , c )		    		print ( "b = %d, c = %d" % ( b , c ) )		  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DELANNOY_NUMBER_1					      DELANNOY_NUMBER_1						    DELANNOY_NUMBER_1						  DELANNOY_NUMBER_1
--							      --							    --								  --
static int dealnnoy ( int n , int m ) {			      def dealnnoy ( n , m ) :					    def dealnnoy ( n , m ) :					  script_not_found : None
  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	  dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m  	dp = np.zeros ( ( m + 1 , n + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( m ) :				    	for i in range ( 0 , m + 1 ) :				  
  i <= m ;						      	      dp [ 0 ] [ i ] = 1				    	    dp [ i ] [ 0 ] = 1					  
  i ++ ) dp [ i ] [ 0 ] = 1 ;				      	  for i in range ( 1 , m + 1 ) :			    	for i in range ( m ) :					  
  for ( int i = 0 ;					      	      dp [ i ] [ 0 ] = 1				    	    dp [ 0 ] [ i ] = 1					  
  i < m ;						      	  for i in range ( 1 , m + 1 ) :			    	for i in range ( 1 , m + 1 ) :				  
  i ++ ) dp [ 0 ] [ i ] = 1 ;				      	      for j in range ( 1 , n + 1 ) :			    	    for j in range ( 1 , n + 1 ) :			  
  for ( int i = 1 ;					      		  dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1  		dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1  
  i <= m ;						      	  return dp [ m ] [ n ]					    	return dp [ m ] [ n ]					  
  i ++ ) for ( int j = 1 ;				      								    								  
  j <= n ;						      								    								  
  j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ 								    								  
  return dp [ m ] [ n ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS			      SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS			    SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS			  SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS
--							      --							    --								  --
static void minRange ( int arr [ ] , int n , int k ) {	      def minRange ( arr , n , k ) :				    def min_range ( arr , n , k ) :				  script_not_found : None
  int l = 0 , r = n ;					      	  l = 0							    	l , r = 0 , n						  
  for ( int i = 0 ;					      	  r = n							    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( n ) :				    	    s = set ( )						  
  i ++ ) {						      	      s = [ ]						    	    j = 0						  
    Set < Integer > s = new HashSet < Integer > ( ) ;	      	      for j in range ( i , n ) :			    	    for j in range ( i , n ) :				  
    int j ;						      		  s.append ( arr [ j ] )			    		s.add ( arr [ j ] )				  
    for ( j = i ;					      		  if ( len ( s ) == k ) :			    		if len ( s ) == k :				  
    j < n ;						      		      if ( ( j - i ) < ( r - l ) ) :		    		    if ( j - i ) < ( r - l ) :			  
    j ++ ) {						      			  r = j					    			r = j					  
      s . add ( arr [ j ] ) ;				      			  l = i					    			l = i					  
      if ( s . size ( ) == k ) {			      		      break					    		    break					  
	if ( ( j - i ) < ( r - l ) ) {			      	      if ( j == n ) :					    	    if j == n :						  
	  r = j ;					      		  break						    		break						  
	  l = i ;					      	  if ( l == 0 and r == n ) :				    	if l == 0 and r == n :					  
	}						      	      print ( "Invalid k" )				    	    print ( 'Invalid k' )				  
	break ;						      	  else :						    	else :							  
      }							      	      print ( l , r )					    	    print ( l , r )					  
    }							      								    								  
    if ( j == n ) break ;				      								    								  
  }							      								    								  
  if ( l == 0 && r == n ) System . out . println ( "Invalid k 								    								  
  else System . out . println ( l + " " + r ) ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1		      CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1		    CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1		  CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1
--							      --							    --								  --
static void substringConversions ( String str , int k , int b def substringConversions ( str1 , k , b ) :		    def substring_conversions ( data , k , b ) :		  script_not_found : None
  int i = 0 , sum = 0 , counter = k - 1 ;		      	  for i in range ( 0 , len ( str1 ) - k + 1 ) :		    	i , sum , counter = 0 , 0 , k - 1			  
  for ( i = 0 ;						      	      sub = str1 [ i : k + i ]				    	for c in data :						  
  i < k ;						      	      Sum = 0						    	    sum = int ( sum + ( ord ( c ) - ord ( '0' ) ) * pow ( 
  i ++ ) {						      	      counter = 0					    	    counter -= 1					  
    sum = ( int ) ( sum + ( ( str . charAt ( i ) - '0' ) * Ma 	      for i in range ( len ( sub ) - 1 , - 1 , - 1 ) :	    	print ( sum , end = ' ' )				  
    counter -- ;					      		  Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) 	prev = sum						  
  }							      		  counter += 1					    	sum = 0							  
  System . out . print ( sum + " " ) ;			      	      print ( Sum , end = " " )				    	counter = 0						  
  int prev = sum ;					      								    	for c in data :						  
  sum = 0 ;						      								    	    sum = int ( prev - ( ord ( c ) - ord ( '0' ) ) * pow  
  counter = 0 ;						      								    	    sum = sum * b					  
  for ( ;						      								    	    sum = sum + ( ord ( c ) - ord ( '0' ) )		  
  i < str . length ( ) ;				      								    	    print ( sum , end = ' ' )				  
  i ++ ) {						      								    	    prev = sum						  
    sum = ( int ) ( prev - ( ( str . charAt ( i - k ) - '0' ) 								    	    counter += 1					  
    sum = sum * b ;					      								    								  
    sum = sum + ( str . charAt ( i ) - '0' ) ;		      								    								  
    System . out . print ( sum + " " ) ;		      								    								  
    prev = sum ;					      								    								  
    counter ++ ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUBARRAY_LEAST_AVERAGE				      FIND_SUBARRAY_LEAST_AVERAGE				    FIND_SUBARRAY_LEAST_AVERAGE					  FIND_SUBARRAY_LEAST_AVERAGE
--							      --							    --								  --
static void findMinAvgSubarray ( int n , int k ) {	      def findMinAvgSubarray ( arr , n , k ) :			    def find_min_avg_subarray ( n , k ) :			  script_not_found : None
  if ( n < k ) return ;					      	  if ( n < k ) : return 0				    	if n < k :						  
  int res_index = 0 ;					      	  res_index = 0						    	    return						  
  int curr_sum = 0 ;					      	  curr_sum = 0						    	res_index = 0						  
  for ( int i = 0 ;					      	  for i in range ( k ) :				    	curr_sum = 0						  
  i < k ;						      	      curr_sum += arr [ i ]				    	for i in range ( k ) :					  
  i ++ ) curr_sum += arr [ i ] ;			      	  min_sum = curr_sum					    	    curr_sum += arr [ i ]				  
  int min_sum = curr_sum ;				      	  for i in range ( k , n ) :				    	min_sum = curr_sum					  
  for ( int i = k ;					      	      curr_sum += arr [ i ] - arr [ i - k ]		    	for i in range ( k , n ) :				  
  i < n ;						      	      if ( curr_sum < min_sum ) :			    	    curr_sum += arr [ i ] - arr [ i - k ]		  
  i ++ ) {						      		  min_sum = curr_sum				    	    if curr_sum < min_sum :				  
    curr_sum += arr [ i ] - arr [ i - k ] ;		      		  res_index = ( i - k + 1 )			    		min_sum = curr_sum				  
    if ( curr_sum < min_sum ) {				      	  print ( "Subarray between [" , res_index , ", " , ( res_i 		res_index = ( i - k + 1 )			  
      min_sum = curr_sum ;				      								    	print ( "Subarray between [%d, %d] has minimum average" % 
      res_index = ( i - k + 1 ) ;			      								    								  
    }							      								    								  
  }							      								    								  
  System . out . println ( "Subarray between [" + res_index + 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY		      MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY		    MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY		  MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY
--							      --							    --								  --
static int maxDiff ( int [ ] arr , int n ) {		      def maxDiff ( arr , n ) :					    def max_diff ( arr , n ) :					  success : None
  int SubsetSum_1 = 0 , SubsetSum_2 = 0 ;		      	  SubsetSum_1 = 0					    	SubsetSum_1 , SubsetSum_2 = 0 , 0			  
  for ( int i = 0 ;					      	  SubsetSum_2 = 0					    	for i in range ( 0 , n - 1 + 1 ) :			  
  i <= n - 1 ;						      	  for i in range ( 0 , n ) :				    	    is_single_occurance = True				  
  i ++ ) {						      	      isSingleOccurance = True				    	    for j in range ( i + 1 , n - 1 + 1 ) :		  
    boolean isSingleOccurance = true ;			      	      for j in range ( i + 1 , n ) :			    		if arr [ i ] == arr [ j ] :			  
    for ( int j = i + 1 ;				      		  if ( arr [ i ] == arr [ j ] ) :		    		    is_single_occurance = False			  
    j <= n - 1 ;					      		      isSingleOccurance = False			    		    arr [ i ] , arr [ j ] = 0 , 0		  
    j ++ ) {						      		      arr [ i ] = arr [ j ] = 0			    		    break					  
      if ( arr [ i ] == arr [ j ] ) {			      		      break					    	    if is_single_occurance :				  
	isSingleOccurance = false ;			      	      if ( isSingleOccurance == True ) :		    		if arr [ i ] > 0 :				  
	arr [ i ] = arr [ j ] = 0 ;			      		  if ( arr [ i ] > 0 ) :			    		    SubsetSum_1 += arr [ i ]			  
	break ;						      		      SubsetSum_1 += arr [ i ]			    		else :						  
      }							      		  else :					    		    SubsetSum_2 += arr [ i ]			  
    }							      		      SubsetSum_2 += arr [ i ]			    	return abs ( SubsetSum_1 - SubsetSum_2 )		  
    if ( isSingleOccurance ) {				      	  return abs ( SubsetSum_1 - SubsetSum_2 )		    								  
      if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ;	      								    								  
      else SubsetSum_2 += arr [ i ] ;			      								    								  
    }							      								    								  
  }							      								    								  
  return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH		      FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH			    FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH			  FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH
--							      --							    --								  --
static int findMaxAverage ( int [ ] arr , int n , int k ) {   def findMaxAverage ( arr , n , k ) :			    def find_max_average ( arr , n , k ) :			  success : None
  if ( k > n ) return - 1 ;				      	  if k > n :						    	if k > n :						  
  int [ ] csum = new int [ n ] ;			      	      return - 1					    	    return - 1						  
  csum [ 0 ] = arr [ 0 ] ;				      	  csum = [ 0 ] * n					    	csum = [ 0 ] * n					  
  for ( int i = 1 ;					      	  csum [ 0 ] = arr [ 0 ]				    	csum [ 0 ] = arr [ 0 ]					  
  i < n ;						      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ;	      	      csum [ i ] = csum [ i - 1 ] + arr [ i ]		    	    csum [ i ] = csum [ i - 1 ] + arr [ i ]		  
  int max_sum = csum [ k - 1 ] , max_end = k - 1 ;	      	  max_sum = csum [ k - 1 ]				    	max_sum , max_end = csum [ k - 1 ] , k - 1		  
  for ( int i = k ;					      	  max_end = k - 1					    	for i in range ( k , n ) :				  
  i < n ;						      	  for i in range ( k , n ) :				    	    curr_sum = csum [ i ] - csum [ i - k ]		  
  i ++ ) {						      	      curr_sum = csum [ i ] - csum [ i - k ]		    	    if curr_sum > max_sum :				  
    int curr_sum = csum [ i ] - csum [ i - k ] ;	      	      if curr_sum > max_sum :				    		max_sum = curr_sum				  
    if ( curr_sum > max_sum ) {				      		  max_sum = curr_sum				    		max_end = i					  
      max_sum = curr_sum ;				      		  max_end = i					    	return max_end - k + 1					  
      max_end = i ;					      	  return max_end - k + 1				    								  
    }							      								    								  
  }							      								    								  
  return max_end - k + 1 ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT		      CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT		    CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT		  CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT
--							      --							    --								  --
static void checkPoint ( int radius , int x , int y , float p def checkPoint ( radius , x , y , percent , startAngle ) :    def check_point ( radius , x , y , percent , start_angle ) :  script_not_found : None
  float endAngle = 360 / percent + startAngle ;		      	  endAngle = 360 / percent + startAngle			    	end_angle = 360 / percent + start_angle			  
  double polarradius = Math . sqrt ( x * x + y * y ) ;	      	  polarradius = math.sqrt ( x * x + y * y )		    	polarradius = math.sqrt ( x * x + y * y )		  
  double Angle = Math . atan ( y / x ) ;		      	  Angle = math.atan ( y / x )				    	Angle = math.atan ( y / x )				  
  if ( Angle >= startAngle && Angle <= endAngle && polarradiu 	  if ( Angle >= startAngle and Angle <= endAngle and polarr 	if Angle >= start_angle and Angle <= end_angle and polarr 
  else System . out . print ( "Point" + "(" + x + "," + y + " 	      print ( "Point (" , x , "," , y , ") " "exist in the  	    print ( "Point","(" , str ( x ) , "," , str ( y ) , " 
}							      	  else :						    	else :							  
							      	      print ( "Point (" , x , "," , y , ") " "does not exis 	    print ( "Point","(" , str ( x ) , "," , str ( y ) , " 
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_BINOMIAL_COEFFICIENTS				      SUM_BINOMIAL_COEFFICIENTS					    SUM_BINOMIAL_COEFFICIENTS					  SUM_BINOMIAL_COEFFICIENTS
--							      --							    --								  --
static int binomialCoeffSum ( int n ) {			      def binomialCoeffSum ( n ) :				    def binomial_coeff_sum ( n ) :				  success : None
  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;		      	  C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ]    	C = np.zeros ( ( n + 1 , n + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( 0 , n + 1 ) :			    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      for j in range ( 0 , min ( i , n ) + 1 ) :	    	    for j in range ( 0 , min ( i , n ) + 1 ) :		  
  i ++ ) {						      		  if ( j == 0 or j == i ) :			    		if j == 0 or j == i :				  
    for ( int j = 0 ;					      		      C [ i ] [ j ] = 1				    		    C [ i ] [ j ] = 1				  
    j <= Math . min ( i , n ) ;				      		  else :					    		else :						  
    j ++ ) {						      		      C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i 		    C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i 
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;	      	  sum = 0						    	sum = 0							  
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	  for i in range ( 0 , n + 1 ) :			    	for i in range ( 0 , n + 1 ) :				  
    }							      	      sum += C [ n ] [ i ]				    	    sum += C [ n ] [ i ]				  
  }							      	  return sum						    	return sum						  
  int sum = 0 ;						      								    								  
  for ( int i = 0 ;					      								    								  
  i <= n ;						      								    								  
  i ++ ) sum += C [ n ] [ i ] ;				      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STEINS_ALGORITHM_FOR_FINDING_GCD_1			      STEINS_ALGORITHM_FOR_FINDING_GCD_1			    STEINS_ALGORITHM_FOR_FINDING_GCD_1				  STEINS_ALGORITHM_FOR_FINDING_GCD_1
--							      --							    --								  --
static int gcd ( int a , int b ) {			      def gcd ( a , b ) :					    def gcd ( a , b ) :						  success : None
  if ( a == b ) return a ;				      	  if ( a == b ) :					    	if a == b :						  
  if ( a == 0 ) return b ;				      	      return a						    	    return a						  
  if ( b == 0 ) return a ;				      	  if ( a == 0 ) :					    	if not a :						  
  if ( ( ~ a & 1 ) == 1 ) {				      	      return b						    	    return b						  
    if ( ( b & 1 ) == 1 ) return gcd ( a >> 1 , b ) ;	      	  if ( b == 0 ) :					    	if not b :						  
    else return gcd ( a >> 1 , b >> 1 ) << 1 ;		      	      return a						    	    return a						  
  }							      	  if ( ( ~ a & 1 ) == 1 ) :				    	if ( ~ a & 1 ) == 1 :					  
  if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ;	      	      if ( ( b & 1 ) == 1 ) :				    	    if ( b & 1 ) == 1 :					  
  if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ;	      		  return gcd ( a >> 1 , b )			    		return gcd ( a >> 1 , b )			  
  return gcd ( ( b - a ) >> 1 , a ) ;			      	      else :						    	    else :						  
}							      		  return ( gcd ( a >> 1 , b >> 1 ) << 1 )	    		return gcd ( a >> 1 , b >> 1 ) << 1		  
							      	  if ( ( ~ b & 1 ) == 1 ) :				    	if ( ~ b & 1 ) == 1 :					  
							      	      return gcd ( a , b >> 1 )				    	    return gcd ( a , b >> 1 )				  
							      	  if ( a > b ) :					    	if a > b :						  
							      	      return gcd ( ( a - b ) >> 1 , b )			    	    return gcd ( ( a - b ) >> 1 , b )			  
							      	  return gcd ( ( b - a ) >> 1 , a )			    	return gcd ( ( b - a ) >> 1 , a )			  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_LINE_PASSING_2_POINTS			      PROGRAM_FIND_LINE_PASSING_2_POINTS			    PROGRAM_FIND_LINE_PASSING_2_POINTS				  PROGRAM_FIND_LINE_PASSING_2_POINTS
--							      --							    --								  --
static void lineFromPoints ( Pair P , Pair Q ) {	      def lineFromPoints ( P , Q ) :				    def line_from_points ( P , Q ) :				  script_not_found : None
  int a = Q . second - P . second ;			      	  a = Q [ 1 ] - P [ 1 ]					    	a = Q [ 1 ] - P [ 1 ]					  
  int b = P . first - Q . first ;			      	  b = P [ 0 ] - Q [ 0 ]					    	b = P [ 0 ] - Q [ 0 ]					  
  int c = a * ( P . first ) + b * ( P . second ) ;	      	  c = a * ( P [ 0 ] ) + b * ( P [ 1 ] )			    	c = a * ( P [ 0 ] ) + b * ( P [ 1 ] )			  
  if ( b < 0 ) {					      	  if ( b < 0 ) :					    	if b < 0 :						  
    System . out . println ( "The line passing through points 	      print ( "The line passing through points P and Q is:" 	    print ( "The line passing through points P and Q is:  
  }							      	  else :						    	else :							  
  else {						      	      print ( "The line passing through points P and Q is:  	    print ( "The line passing through points P and Q is:  
    System . out . println ( "The line passing through points 								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_DERANGEMENT_SEQUENCE				      SMALLEST_DERANGEMENT_SEQUENCE				    SMALLEST_DERANGEMENT_SEQUENCE				  SMALLEST_DERANGEMENT_SEQUENCE
--							      --							    --								  --
static void generate_derangement ( int N ) {		      def generate_derangement ( N ) :				    def generate_derangement ( N ) :				  script_not_found : None
  int S [ ] = new int [ N + 1 ] ;			      	  S = [ 0 ] * ( N + 1 )					    	S = [ ]							  
  for ( int i = 1 ;					      	  for i in range ( 1 , N + 1 ) :			    	for i in range ( 1 , N + 1 ) :				  
  i <= N ;						      	      S [ i ] = i					    	    S.append ( i )					  
  i ++ ) S [ i ] = i ;					      	  D = [ 0 ] * ( N + 1 )					    	D = [ ]							  
  int D [ ] = new int [ N + 1 ] ;			      	  for i in range ( 1 , N + 1 , 2 ) :			    	for i in range ( 1 , N + 1 , 2 ) :			  
  for ( int i = 1 ;					      	      if i == N :					    	    if i == N :						  
  i <= N ;						      		  D [ N ] = S [ N - 1 ]				    		D.append ( S [ N - 1 ] )			  
  i += 2 ) {						      		  D [ N - 1 ] = S [ N ]				    		D.append ( S [ N - 1 ] )			  
    if ( i == N ) {					      	      else :						    	    else :						  
      D [ N ] = S [ N - 1 ] ;				      		  D [ i ] = i + 1				    		D.append ( i + 1 )				  
      D [ N - 1 ] = S [ N ] ;				      		  D [ i + 1 ] = i				    		D.append ( i )					  
    }							      	  for i in range ( 1 , N + 1 ) :			    	for i in range ( 1 , N + 1 ) :				  
    else {						      	      print ( D [ i ] , end = " " )			    	    print ( D [ i ] , end = ' ' )			  
      D [ i ] = i + 1 ;					      	  print ( )						    	print ( )						  
      D [ i + 1 ] = i ;					      								    								  
    }							      								    								  
  }							      								    								  
  for ( int i = 1 ;					      								    								  
  i <= N ;						      								    								  
  i ++ ) System . out . print ( D [ i ] + " " ) ;	      								    								  
  System . out . println ( ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_ LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_ LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_ LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_
--							      --							    --								  --
static void subsequence ( char s [ ] , char t [ ] , int n , i def subsequence ( s , t , n , k ) :			    def subsequence ( s , t , n , k ) :				  failure : #Results: 0, 10
  int last = 0 , cnt = 0 , new_last = 0 , size = 0 ;	      	  last = 0						    	last , cnt , new_last , size = 0 , 0 , 0 , 0		  
  for ( char ch = 'z' ;					      	  cnt = 0						    	for ch in 'z' , 'a' , - 1 :				  
  ch >= 'a' ;						      	  new_last = 0						    	    cnt = 0						  
  ch -- ) {						      	  size = 0						    	    for i in range ( last , n ) :			  
    cnt = 0 ;						      	  string = 'zyxwvutsrqponmlkjihgfedcba'			    		if s [ i ] == ch :				  
    for ( int i = last ;				      	  for ch in string :					    		    cnt += 1					  
    i < n ;						      	      cnt = 0						    	    if cnt >= k :					  
    i ++ ) {						      	      for i in range ( last , n ) :			    		for i in range ( last , n ) :			  
      if ( s [ i ] == ch ) cnt ++ ;			      		  if s [ i ] == ch :				    		    if s [ i ] == ch :				  
    }							      		      cnt += 1					    			t [ size ] = ch				  
    if ( cnt >= k ) {					      	      if cnt >= k :					    			new_last = i				  
      for ( int i = last ;				      		  for i in range ( last , n ) :			    		last = new_last					  
      i < n ;						      		      if s [ i ] == ch :			    	t [ size ] = '\0'					  
      i ++ ) {						      			  t [ size ] = ch			    								  
	if ( s [ i ] == ch ) {				      			  new_last = i				    								  
	  t [ size ++ ] = ch ;				      			  size += 1				    								  
	  new_last = i ;				      		  last = new_last				    								  
	}						      								    								  
      }							      								    								  
      last = new_last ;					      								    								  
    }							      								    								  
  }							      								    								  
  t [ size ] = '\0' ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_REPEATING_SUBSEQUENCE				      LONGEST_REPEATING_SUBSEQUENCE				    LONGEST_REPEATING_SUBSEQUENCE				  LONGEST_REPEATING_SUBSEQUENCE
--							      --							    --								  --
static int findLongestRepeatingSubSeq ( String str ) {	      def findLongestRepeatingSubSeq ( str ) :			    def find_longest_repeating_subseq ( str ) :			  success : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;	      	  dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 )		    	dp = np.zeros ( ( n + 1 , n + 1 ) )			  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	      for j in range ( 1 , n + 1 ) :			    	    for j in range ( 1 , n + 1 ) :			  
  i ++ ) {						      		  if ( str [ i - 1 ] == str [ j - 1 ] and i != j )  		if str [ i - 1 ] == str [ j - 1 ] and i != j :	  
    for ( int j = 1 ;					      		      dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]   		    dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]	  
    j <= n ;						      		  else :					    		else :						  
    j ++ ) {						      		      dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , d 		    dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , d 
      if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) & 	  return dp [ n ] [ n ]					    	return dp [ n ] [ n ]					  
      else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , 								    								  
    }							      								    								  
  }							      								    								  
  return dp [ n ] [ n ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MEDIAN_OF_TWO_SORTED_ARRAYS				      MEDIAN_OF_TWO_SORTED_ARRAYS				    MEDIAN_OF_TWO_SORTED_ARRAYS					  MEDIAN_OF_TWO_SORTED_ARRAYS
--							      --							    --								  --
static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) {  def getMedian ( ar1 , ar2 , n ) :				    def get_median ( ar1 , ar2 , n ) :				  success : None
  int i = 0 ;						      	  i = 0							    	i = 0							  
  int j = 0 ;						      	  j = 0							    	j = 0							  
  int count ;						      	  m1 = - 1						    	count = 0						  
  int m1 = - 1 , m2 = - 1 ;				      	  m2 = - 1						    	m1 , m2 = - 1 , - 1					  
  for ( count = 0 ;					      	  count = 0						    	for count in range ( 0 , n + 1 ) :			  
  count <= n ;						      	  while count < n + 1 :					    	    if i == n :						  
  count ++ ) {						      	      count += 1					    		m1 = m2						  
    if ( i == n ) {					      	      if i == n :					    		m2 = ar2 [ 0 ]					  
      m1 = m2 ;						      		  m1 = m2					    		break						  
      m2 = ar2 [ 0 ] ;					      		  m2 = ar2 [ 0 ]				    	    elif j == n :					  
      break ;						      		  break						    		m1 = m2						  
    }							      	      elif j == n :					    		m2 = ar1 [ 0 ]					  
    else if ( j == n ) {				      		  m1 = m2					    		break						  
      m1 = m2 ;						      		  m2 = ar1 [ 0 ]				    	    if ar1 [ i ] < ar2 [ j ] :				  
      m2 = ar1 [ 0 ] ;					      		  break						    		m1 = m2						  
      break ;						      	      if ar1 [ i ] < ar2 [ j ] :			    		m2 = ar1 [ i ]					  
    }							      		  m1 = m2					    		i += 1						  
    if ( ar1 [ i ] < ar2 [ j ] ) {			      		  m2 = ar1 [ i ]				    	    else :						  
      m1 = m2 ;						      		  i += 1					    		m1 = m2						  
      m2 = ar1 [ i ] ;					      	      else :						    		m2 = ar2 [ j ]					  
      i ++ ;						      		  m1 = m2					    		j += 1						  
    }							      		  m2 = ar2 [ j ]				    	return ( m1 + m2 ) / 2					  
    else {						      		  j += 1					    								  
      m1 = m2 ;						      	  return ( m1 + m2 ) / 2				    								  
      m2 = ar2 [ j ] ;					      								    								  
      j ++ ;						      								    								  
    }							      								    								  
  }							      								    								  
  return ( m1 + m2 ) / 2 ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH
--							      --							    --								  --
static int findElement ( int [ ] arr , int n ) {	      def findElement ( arr , n ) :				    def find_element ( arr , n ) :				  failure : #Results: 7, 10
  int [ ] leftMax = new int [ n ] ;			      	  leftMax = [ None ] * n				    	left_max = [ 0 ] * n					  
  leftMax [ 0 ] = Integer . MIN_VALUE ;			      	  leftMax [ 0 ] = float ( '-inf' )			    	left_max [ 0 ] = sys.maxsize				  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i < n ;						      	      leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 	    left_max [ i ] = max ( left_max [ i - 1 ] , arr [ i - 
  i ++ ) leftMax [ i ] = Math . max ( leftMax [ i - 1 ] , arr 	  rightMin = float ( 'inf' )				    	right_min = sys.maxsize					  
  int rightMin = Integer . MAX_VALUE ;			      	  for i in range ( n - 1 , - 1 , - 1 ) :		    	for i in range ( n - 1 , - 1 , - 1 ) :			  
  for ( int i = n - 1 ;					      	      if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] 	    if left_max [ i ] < arr [ i ] and right_min > arr [ i 
  i >= 0 ;						      		  return i					    		return i					  
  i -- ) {						      	      rightMin = min ( rightMin , arr [ i ] )		    	    right_min = min ( right_min , arr [ i ] )		  
    if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] )  	  return - 1						    	return - 1						  
    rightMin = Math . min ( rightMin , arr [ i ] ) ;	      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_VALID_SEQUENCE_DIVISIBLE_M_1			      CHECK_VALID_SEQUENCE_DIVISIBLE_M_1			    CHECK_VALID_SEQUENCE_DIVISIBLE_M_1				  CHECK_VALID_SEQUENCE_DIVISIBLE_M_1
--							      --							    --								  --
static int isPossible ( int n , int index , int modulo , int  def isPossible ( n , index , modulo , M , arr , dp ) :	    def is_possible ( n , index , modulo , M , arr , dp ) :	  success : None
  modulo = ( ( modulo % M ) + M ) % M ;			      	  modulo = ( ( modulo % M ) + M ) % M			    	modulo = ( ( modulo % M ) + M ) % M			  
  if ( index == n ) {					      	  if ( index == n ) :					    	if index == n :						  
    if ( modulo == 0 ) {				      	      if ( modulo == 0 ) :				    	    if modulo == 0 :					  
      return 1 ;					      		  return 1					    		return 1					  
    }							      	      return 0						    	    return 0						  
    return 0 ;						      	  if ( dp [ index ] [ modulo ] != - 1 ) :		    	if dp [ index ] [ modulo ] != - 1 :			  
  }							      	      return dp [ index ] [ modulo ]			    	    return dp [ index ] [ modulo ]			  
  if ( dp [ index ] [ modulo ] != - 1 ) {		      	  placeAdd = isPossible ( n , index + 1 , modulo + arr [ in 	place_add = is_possible ( n , index + 1 , modulo + arr [  
    return dp [ index ] [ modulo ] ;			      	  placeMinus = isPossible ( n , index + 1 , modulo - arr [  	place_minus = is_possible ( n , index + 1 , modulo - arr  
  }							      	  res = bool ( placeAdd or placeMinus )			    	res = place_add						  
  int placeAdd = isPossible ( n , index + 1 , modulo + arr [  	  dp [ index ] [ modulo ] = res				    	dp [ index ] [ modulo ] = res				  
  int placeMinus = isPossible ( n , index + 1 , modulo - arr  	  return res						    	return res						  
  int res = placeAdd ;					      								    								  
  dp [ index ] [ modulo ] = res ;			      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS		      MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS		    MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS			  MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS
--							      --							    --								  --
static void find ( Vector < String > list1 , Vector < String  def find ( list1 , list2 ) :				    def find ( list1 , list2 ) :				  script_not_found : None
  Vector < String > res = new Vector < > ( ) ;		      	  res = [ ]						    	res = [ ]						  
  int max_possible_sum = list1 . size ( ) + list2 . size ( )  	  max_possible_sum = len ( list1 ) + len ( list2 ) - 2	    	max_possible_sum = len ( list1 ) + len ( list2 ) - 2	  
  for ( int sum = 0 ;					      	  for sum in range ( max_possible_sum + 1 ) :		    	for sum in range ( 0 , max_possible_sum + 1 ) :		  
  sum <= max_possible_sum ;				      	      for i in range ( sum + 1 ) :			    	    for i in range ( 0 , sum + 1 ) :			  
  sum ++ ) {						      		  if ( i < len ( list1 ) and ( sum - i ) < len ( li 		if i < len ( list1 ) and ( sum - i ) < len ( list 
    for ( int i = 0 ;					      		      res.append ( list1 [ i ] )		    		    res.append ( list1 [ i ] )			  
    i <= sum ;						      	      if ( len ( res ) > 0 ) :				    		if len ( res ) > 0 :				  
    i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . 		  break						    		    break					  
    if ( res . size ( ) > 0 ) break ;			      	  for i in range ( len ( res ) ) :			    	for i in range ( len ( res ) ) :			  
  }							      	      print ( res [ i ] , end = " " )			    	    print ( res [ i ] , end = ' ' )			  
  for ( int i = 0 ;					      								    								  
  i < res . size ( ) ;					      								    								  
  i ++ ) System . out . print ( res . get ( i ) + " " ) ;     								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CEILING_IN_A_SORTED_ARRAY_1				      CEILING_IN_A_SORTED_ARRAY_1				    CEILING_IN_A_SORTED_ARRAY_1					  CEILING_IN_A_SORTED_ARRAY_1
--							      --							    --								  --
static int ceilSearch ( int arr [ ] , int low , int high , in def ceilSearch ( arr , low , high , x ) :			    def ceil_search ( arr , low , high , x ) :			  success : None
  int mid ;						      	  if x <= arr [ low ] :					    	if x <= arr [ low ] :					  
  if ( x <= arr [ low ] ) return low ;			      	      return low					    	    return low						  
  if ( x > arr [ high ] ) return - 1 ;			      	  if x > arr [ high ] :					    	if x > arr [ high ] :					  
  mid = ( low + high ) / 2 ;				      	      return - 1					    	    return - 1						  
  if ( arr [ mid ] == x ) return mid ;			      	  mid = ( low + high ) / 2				    	mid = ( low + high ) // 2				  
  else if ( arr [ mid ] < x ) {				      	  if arr [ mid ] == x :					    	if arr [ mid ] == x :					  
    if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid 	      return mid					    	    return mid						  
    else return ceilSearch ( arr , mid + 1 , high , x ) ;     	  elif arr [ mid ] < x :				    	elif arr [ mid ] < x :					  
  }							      	      if mid + 1 <= high and x <= arr [ mid + 1 ] :	    	    if mid + 1 <= high and x <= arr [ mid + 1 ] :	  
  else {						      		  return mid + 1				    		return mid + 1					  
    if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; 	      else :						    	    else :						  
    else return ceilSearch ( arr , low , mid - 1 , x ) ;      		  return ceilSearch ( arr , mid + 1 , high , x )    		return ceil_search ( arr , mid + 1 , high , x )	  
  }							      	  else :						    	else :							  
}							      	      if mid - 1 >= low and x > arr [ mid - 1 ] :	    	    if mid - 1 >= low and x > arr [ mid - 1 ] :		  
							      		  return mid					    		return mid					  
							      	      else :						    	    else :						  
							      		  return ceilSearch ( arr , low , mid - 1 , x )	    		return ceil_search ( arr , low , mid - 1 , x )	  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE
--							      --							    --								  --
public static int maxLenSub ( int arr [ ] , int n ) {	      def maxLenSub ( arr , n ) :				    def max_len_sub ( arr , n ) :				  success : None
  int mls [ ] = new int [ n ] , max = 0 ;		      	  mls = [ ]						    	mls , max = [ 0 ] * n , 0				  
  for ( int i = 0 ;					      	  max = 0						    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( n ) :				    	    mls [ i ] = 1					  
  i ++ ) mls [ i ] = 1 ;				      	      mls.append ( 1 )					    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      	  for i in range ( n ) :				    	    for j in range ( i ) :				  
  i < n ;						      	      for j in range ( i ) :				    		if abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i 
  i ++ ) for ( int j = 0 ;				      		  if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ 		    mls [ i ] = mls [ j ] + 1			  
  j < i ;						      		      mls [ i ] = mls [ j ] + 1			    	for i in range ( n ) :					  
  j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && ml 	  for i in range ( n ) :				    	    if max < mls [ i ] :				  
  for ( int i = 0 ;					      	      if ( max < mls [ i ] ) :				    		max = mls [ i ]					  
  i < n ;						      		  max = mls [ i ]				    	return max						  
  i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ;	      	  return max						    								  
  return max ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX		      RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX		    RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX		  RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX
--							      --							    --								  --
static StringBuilder findLeft ( StringBuilder str ) {	      def findLeft ( str ) :					    def findLeft ( data ) :					  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( str ) - 1					    	n = len ( data )					  
  while ( n > 0 ) {					      	  while ( n > 0 ) :					    	while n > 0 :						  
    n -- ;						      	      if ( str [ n ] == 'd' ) :				    	    n -= 1						  
    if ( str . charAt ( n ) == 'd' ) {			      		  str = str [ 0 : n ] + 'c' + str [ n + 1 : ]	    	    if data [ n ] == 'd' :				  
      str . setCharAt ( n , 'c' ) ;			      		  break						    		data [ n ] = 'c'				  
      break ;						      	      if ( str [ n ] == 'b' ) :				    		break						  
    }							      		  str = str [ 0 : n ] + 'a' + str [ n + 1 : ]	    	    if data [ n ] == 'b' :				  
    if ( str . charAt ( n ) == 'b' ) {			      		  break						    		data [ n ] = 'a'				  
      str . setCharAt ( n , 'a' ) ;			      	      if ( str [ n ] == 'a' ) :				    		break						  
      break ;						      		  str = str [ 0 : n ] + 'b' + str [ n + 1 : ]	    	    if data [ n ] == 'a' :				  
    }							      	      elif ( str [ n ] == 'c' ) :			    		data [ n ] = 'b'				  
    if ( str . charAt ( n ) == 'a' ) str . setCharAt ( n , 'b 		  str = str [ 0 : n ] + 'd' + str [ n + 1 : ]	    	    elif data [ n ] == 'c' :				  
    else if ( str . charAt ( n ) == 'c' ) str . setCharAt ( n 	      n -= 1						    		data [ n ] = 'd'				  
  }							      	  return str						    	return data						  
  return str ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD    FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD    FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD	  FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD
--							      --							    --								  --
boolean findPairs ( int arr [ ] ) {			      def findPairs ( arr , n ) :				    def find_pairs ( arr ) :					  script_not_found : None
  HashMap < Integer , pair > map = new HashMap < Integer , pa Hash = { }						    	d = { }							  
  int n = arr . length ;				      for i in range ( n - 1 ) :				    	n = len ( arr )						  
  for ( int i = 0 ;					      	  for j in range ( i + 1 , n ) :			    	for i in range ( n ) :					  
  i < n ;						      	  sum = arr [ i ] + arr [ j ]				    	    for j in range ( i + 1 , n ) :			  
  ++ i ) {						      	  if sum in Hash.keys ( ) :				    		sum = arr [ i ] + arr [ j ]			  
    for ( int j = i + 1 ;				      	      prev = Hash.get ( sum )				    		if sum not in d :				  
    j < n ;						      	      print ( str ( prev ) + " and (%d, %d)" % ( arr [ i ]  		    d [ sum ] = ( i , j )			  
    ++ j ) {						      	      return True					    		else :						  
      int sum = arr [ i ] + arr [ j ] ;			      	  else :						    		    p = d [ sum ]				  
      if ( ! map . containsKey ( sum ) ) map . put ( sum , ne 	      Hash [ sum ] = ( arr [ i ] , arr [ j ] )		    		    print ( "(%d, %d) and (%d, %d)" % ( arr [ p [ 
      else {						      								    		    return True					  
	pair p = map . get ( sum ) ;			      								    	return False						  
	System . out . println ( "(" + arr [ p . first ] + ", 								    								  
	return true ;					      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY		      COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY		    COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY			  COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY
--							      --							    --								  --
static int countMinOperations ( int n ) {		      def countMinOperations ( target , n ) :			    def count_min_operations ( n ) :				  script_not_found : None
  int result = 0 ;					      	  result = 0						    	result = 0						  
  while ( true ) {					      	  while ( True ) :					    	while True :						  
    int zero_count = 0 ;				      	      zero_count = 0					    	    zero_count = 0					  
    int i ;						      	      i = 0						    	    i = 0						  
    for ( i = 0 ;					      	      while ( i < n ) :					    	    for i in range ( n ) :				  
    i < n ;						      		  if ( ( target [ i ] & 1 ) > 0 ) :		    		if arr [ i ] % 2 == 1 :				  
    i ++ ) {						      		      break					    		    break					  
      if ( arr [ i ] % 2 == 1 ) break ;			      		  elif ( target [ i ] == 0 ) :			    		elif arr [ i ] == 0 :				  
      else if ( arr [ i ] == 0 ) zero_count ++ ;	      		      zero_count += 1				    		    zero_count += 1				  
    }							      		  i += 1					    	    if zero_count == n :				  
    if ( zero_count == n ) return result ;		      	      if ( zero_count == n ) :				    		return result					  
    if ( i == n ) {					      		  return result					    	    if i == n :						  
      for ( int j = 0 ;					      	      if ( i == n ) :					    		for j in range ( n ) :				  
      j < n ;						      		  for j in range ( n ) :			    		    arr [ j ] = arr [ j ] // 2			  
      j ++ ) arr [ j ] = arr [ j ] / 2 ;		      		      target [ j ] = target [ j ] // 2		    		result += 1					  
      result ++ ;					      		  result += 1					    	    for j in range ( i , n ) :				  
    }							      	      for j in range ( i , n ) :			    		if arr [ j ] % 2 == 1 :				  
    for ( int j = i ;					      		  if ( target [ j ] & 1 ) :			    		    arr [ j ] -= 1				  
    j < n ;						      		      target [ j ] -= 1				    		    result += 1					  
    j ++ ) {						      		      result += 1				    								  
      if ( arr [ j ] % 2 == 1 ) {			      								    								  
	arr [ j ] -- ;					      								    								  
	result ++ ;					      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY	      INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY	    INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY	  INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY
--							      --							    --								  --
static int findInteger ( int arr [ ] , int n ) {	      def findInteger ( arr , n ) :				    def find_integer ( arr , n ) :				  error : Traceback (most recent call last):   File
  HashMap < Integer , Integer > hash = new HashMap < > ( ) ;  	  hash = dict ( )					    	hash = { }						  "dump/transcoder_st/eval/java_python/online_st/206
  int maximum = 0 ;					      	  maximum = 0						    	maximum = 0						  68770/eval_scripts/java_sa-python_sa.test/INTEGER_
  for ( int i = 0 ;					      	  for i in arr :					    	for i in range ( n ) :					  POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY.py",
  i < n ;						      	      if ( i < 0 ) :					    	    if arr [ i ] < 0 :					  line 70, in <module>	   if f_filled(*parameters_s
  i ++ ) {						      		  if abs ( i ) not in hash.keys ( ) :		    		hash [ abs ( arr [ i ] ) ] = ( 0 if hash [ abs (  et) == f_gold(*parameters_set):   File "dump/trans
    if ( arr [ i ] < 0 ) hash . put ( Math . abs ( arr [ i ]  		      hash [ abs ( i ) ] = - 1			    	    else :						  coder_st/eval/java_python/online_st/20668770/eval_
    else hash . put ( Math . abs ( arr [ i ] ) , ( hash . get 		  else :					    		hash [ abs ( arr [ i ] ) ] = ( 0 if hash [ abs (  scripts/java_sa-python_sa.test/INTEGER_POSITIVE_VA
  }							      		      hash [ abs ( i ) ] -= 1			    	for i in range ( n ) :					  LUE_POSITIVE_NEGATIVE_VALUE_ARRAY.py", line 41, in
  for ( int i = 0 ;					      	      else :						    	    if hash [ arr [ i ] ] > 0 :				   f_filled	hash [ abs ( arr [ i ] ) ] = ( 0 if
  i < n ;						      		  hash [ i ] = hash.get ( i , 0 ) + 1		    		return arr [ i ]				  hash [ abs ( arr [ i ] ) ] == 0 else hash [ abs (
  i ++ ) if ( hash . get ( arr [ i ] ) > 0 ) return arr [ i ] 	  for i in arr :					    	return - 1						  arr [ i ] ) ] + 1 ) KeyError: 1
  return - 1 ;						      	      if i in hash.keys ( ) and hash [ i ] > 0 :	    								  
}							      		  return i					    								  
							      	  return - 1						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2	  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2
--							      --							    --								  --
static int findLength ( String str , int n ) {		      def findLength ( string , n ) :				    def find_length ( str , n ) :				  script_not_found : None
  int sum [ ] = new int [ n + 1 ] ;			      	  Sum = [ 0 ] * ( n + 1 )				    	sum = [ 0 ] * ( n + 1 )					  
  sum [ 0 ] = 0 ;					      	  for i in range ( 1 , n + 1 ) :			    	sum [ 0 ] = 0						  
  for ( int i = 1 ;					      	      Sum [ i ] = ( Sum [ i - 1 ] + int ( string [ i - 1 ]  	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	  ans = 0						    	    sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] - '0' )	  
  i ++ ) sum [ i ] = ( sum [ i - 1 ] + str . charAt ( i - 1 ) 	  for length in range ( 2 , n + 1 , 2 ) :		    	ans = 0							  
  int ans = 0 ;						      	      for i in range ( 0 , n - length + 1 ) :		    	for len in range ( 2 , n + 1 , 2 ) :			  
  for ( int len = 2 ;					      		  j = i + length - 1				    	    for i in range ( 0 , n - len + 1 ) :		  
  len <= n ;						      		  if ( Sum [ i + length // 2 ] - Sum [ i ] == Sum [ 		j = i + len - 1					  
  len += 2 ) {						      		      ans = max ( ans , length )		    		if sum [ i + len // 2 ] - sum [ i ] == sum [ i +  
    for ( int i = 0 ;					      	  return ans						    		    ans = max ( ans , len )			  
    i <= n - len ;					      								    	return ans						  
    i ++ ) {						      								    								  
      int j = i + len - 1 ;				      								    								  
      if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] 								    								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES	      REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES		    REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES		  REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES
--							      --							    --								  --
static void arrangeString ( String str , int x , int y ) {    def arrangeString ( str1 , x , y ) :			    def arrangeString ( str , x , y ) :				  script_not_found : None
  int count_0 = 0 ;					      	  count_0 = 0						    	count_0 = 0						  
  int count_1 = 0 ;					      	  count_1 = 0						    	count_1 = 0						  
  int len = str . length ( ) ;				      	  n = len ( str1 )					    	str = list ( str )					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for c in str :						  
  i < len ;						      	      if str1 [ i ] == '0' :				    	    if c == '0' :					  
  i ++ ) {						      		  count_0 += 1					    		count_0 += 1					  
    if ( str . charAt ( i ) == '0' ) count_0 ++ ;	      	      else :						    	    else :						  
    else count_1 ++ ;					      		  count_1 += 1					    		count_1 += 1					  
  }							      	  while count_0 > 0 or count_1 > 0 :			    	while count_0 > 0 or count_1 > 0 :			  
  while ( count_0 > 0 || count_1 > 0 ) {		      	      for i in range ( 0 , x ) :			    	    for j in range ( x ) :				  
    for ( int j = 0 ;					      		  if count_0 > 0 :				    		if count_0 > 0 :				  
    j < x && count_0 > 0 ;				      		      print ( "0" , end = "" )			    		    print ( '0' , end = ' ' )			  
    j ++ ) {						      		      count_0 -= 1				    		    count_0 -= 1				  
      if ( count_0 > 0 ) {				      	      for j in range ( 0 , y ) :			    	    for j in range ( y ) :				  
	System . out . print ( "0" ) ;			      		  if count_1 > 0 :				    		if count_1 > 0 :				  
	count_0 -- ;					      		      print ( "1" , end = "" )			    		    print ( '1' , end = ' ' )			  
      }							      		      count_1 -= 1				    		    count_1 -= 1				  
    }							      								    								  
    for ( int j = 0 ;					      								    								  
    j < y && count_1 > 0 ;				      								    								  
    j ++ ) {						      								    								  
      if ( count_1 > 0 ) {				      								    								  
	System . out . print ( "1" ) ;			      								    								  
	count_1 -- ;					      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F
--							      --							    --								  --
static int CountSubstring ( char str [ ] , int n ) {	      def CountSubString ( Str , n ) :				    def CountSubstring ( str , n ) :				  script_not_found : None
  int ans = ( n * ( n + 1 ) ) / 2 ;			      	  ans = ( n * ( n + 1 ) ) // 2				    	ans = ( n * ( n + 1 ) ) // 2				  
  int a_index = 0 ;					      	  a_index = 0						    	a_index = 0						  
  int b_index = 0 ;					      	  b_index = 0						    	b_index = 0						  
  int c_index = 0 ;					      	  c_index = 0						    	c_index = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( Str [ i ] == 'a' ) :				    	    if str [ i ] == 'a' :				  
  i ++ ) {						      		  a_index = i + 1				    		a_index = i + 1					  
    if ( str [ i ] == 'a' ) {				      		  ans -= min ( b_index , c_index )		    		ans -= min ( b_index , c_index )		  
      a_index = i + 1 ;					      	      elif ( Str [ i ] == 'b' ) :			    	    elif str [ i ] == 'b' :				  
      ans -= Math . min ( b_index , c_index ) ;		      		  b_index = i + 1				    		b_index = i + 1					  
    }							      		  ans -= min ( a_index , c_index )		    		ans -= min ( a_index , c_index )		  
    else if ( str [ i ] == 'b' ) {			      	      else :						    	    else :						  
      b_index = i + 1 ;					      		  c_index = i + 1				    		c_index = i + 1					  
      ans -= Math . min ( a_index , c_index ) ;		      		  ans -= min ( a_index , b_index )		    		ans -= min ( a_index , b_index )		  
    }							      	  return ans						    	return ans						  
    else {						      								    								  
      c_index = i + 1 ;					      								    								  
      ans -= Math . min ( a_index , b_index ) ;		      								    								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ROTATIONS_DIVISIBLE_4				      COUNT_ROTATIONS_DIVISIBLE_4				    COUNT_ROTATIONS_DIVISIBLE_4					  COUNT_ROTATIONS_DIVISIBLE_4
--							      --							    --								  --
static int countRotations ( String n ) {		      def countRotations ( n ) :				    def count_rotations ( n ) :					  script_not_found : None
  int len = n . length ( ) ;				      	  l = len ( n )						    	n = list ( n )						  
  if ( len == 1 ) {					      	  if ( l == 1 ) :					    	if len ( n ) == 1 :					  
    int oneDigit = n . charAt ( 0 ) - '0' ;		      	      oneDigit = ( int ) ( n [ 0 ] )			    	    one_digit = n [ 0 ] - '0'				  
    if ( oneDigit % 4 == 0 ) return 1 ;			      	      if ( oneDigit % 4 == 0 ) :			    	    if one_digit % 4 == 0 :				  
    return 0 ;						      		  return 1					    		return 1					  
  }							      	      return 0						    	    return 0						  
  int twoDigit , count = 0 ;				      	  count = 0						    	two_digit , count = 0 , 0				  
  for ( int i = 0 ;					      	  for i in range ( 0 , l - 1 ) :			    	for i in range ( ( len ( n ) - 1 ) ) :			  
  i < ( len - 1 ) ;					      	      twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i 	    two_digit = ( n [ i ] - '0' ) * 10 + ( n [ i + 1 ] -  
  i ++ ) {						      	      if ( twoDigit % 4 == 0 ) :			    	    if two_digit % 4 == 0 :				  
    twoDigit = ( n . charAt ( i ) - '0' ) * 10 + ( n . charAt 		  count = count + 1				    		count += 1					  
    if ( twoDigit % 4 == 0 ) count ++ ;			      	  twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 	two_digit = ( n [ - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' )  
  }							      	  if ( twoDigit % 4 == 0 ) :				    	if two_digit % 4 == 0 :					  
  twoDigit = ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . ch 	      count = count + 1					    	    count += 1						  
  if ( twoDigit % 4 == 0 ) count ++ ;			      	  return count						    	return count						  
  return count ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2			      PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2			    PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2				  PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2
--							      --							    --								  --
public static int fib ( int n ) {			      def fib ( n ) :						    def fib ( n ) :						  script_not_found : None
  if ( n == 0 ) return 0 ;				      	  if ( n == 0 ) :					    	if not n :						  
  if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ;	      	      return 0						    	    return 0						  
  if ( f [ n ] != 0 ) return f [ n ] ;			      	  if ( n == 1 or n == 2 ) :				    	if n in [ 1 , 2 ] :					  
  int k = ( n & 1 ) == 1 ? ( n + 1 ) / 2 : n / 2 ;	      	      f [ n ] = 1					    	    return ( f [ n ] = 1 )				  
  f [ n ] = ( n & 1 ) == 1 ? ( fib ( k ) * fib ( k ) + fib (  	      return ( f [ n ] )				    	if n in f :						  
  return f [ n ] ;					      	  if ( f [ n ] ) :					    	    return f [ n ]					  
}							      	      return f [ n ]					    	k = ( n + 1 ) // 2 if n & 1 == 1 else n // 2		  
							      	  if ( n & 1 ) :					    	f [ n ] = ( fib ( k ) ** 2 + fib ( k - 1 ) ** 2 ) if n &  
							      	      k = ( n + 1 ) // 2				    	return f [ n ]						  
							      	  else :						    								  
							      	      k = n // 2					    								  
							      	  if ( ( n & 1 ) ) :					    								  
							      	      f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * f 								  
							      	  else :						    								  
							      	      f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k 								  
							      	  return f [ n ]					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS		      FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS			    FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS			  FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS
--							      --							    --								  --
static int evenSum ( int n ) {				      def evenSum ( n ) :					    def even_sum ( n ) :					  failure : #Results: 4, 10
  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;		      	  C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 	C = np.zeros ( ( n + 1 , n + 1 ) )			  
  int i , j ;						      	  for i in range ( 0 , n + 1 ) :			    	i , j = 0 , 0						  
  for ( i = 0 ;						      	      for j in range ( 0 , min ( i , n + 1 ) ) :	    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      		  if j == 0 or j == i :				    	    for j in range ( 0 , min ( i , n ) + 1 ) :		  
  i ++ ) {						      		      C [ i ] [ j ] = 1				    		if j == 0 or j == i :				  
    for ( j = 0 ;					      		  else :					    		    C [ i ] [ j ] = 1				  
    j <= Math . min ( i , n ) ;				      		      C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i 		else :						  
    j ++ ) {						      	  sum = 0 ;						    		    C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i 
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;	      	  for i in range ( 0 , n + 1 ) :			    	sum = 0							  
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	      if n % 2 == 0 :					    	for i in range ( 0 , n + 1 , 2 ) :			  
    }							      		  sum = sum + C [ n ] [ i ]			    	    sum += C [ n ] [ i ]				  
  }							      	  return sum						    	return sum						  
  int sum = 0 ;						      								    								  
  for ( i = 0 ;						      								    								  
  i <= n ;						      								    								  
  i += 2 ) sum += C [ n ] [ i ] ;			      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE			      MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE			    MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE			  MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE
--							      --							    --								  --
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] ,  def maxSumPairWithDifferenceLessThanK ( arr , N , K ) :	    def max_sum_pair_with_difference_lt_k ( arr , N , K ) :	  success : None
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  int dp [ ] = new int [ N ] ;				      	  dp = [ 0 ] * N					    	dp = [ 0 ] * N						  
  dp [ 0 ] = 0 ;					      	  dp [ 0 ] = 0						    	dp [ 0 ] = 0						  
  for ( int i = 1 ;					      	  for i in range ( 1 , N ) :				    	for i in range ( 1 , N ) :				  
  i < N ;						      	      dp [ i ] = dp [ i - 1 ]				    	    dp [ i ] = dp [ i - 1 ]				  
  i ++ ) {						      	      if ( arr [ i ] - arr [ i - 1 ] < K ) :		    	    if arr [ i ] - arr [ i - 1 ] < K :			  
    dp [ i ] = dp [ i - 1 ] ;				      		  if ( i >= 2 ) :				    		if i >= 2 :					  
    if ( arr [ i ] - arr [ i - 1 ] < K ) {		      		      dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + ar 		    dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + ar 
      if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i 		  else :					    		else :						  
      else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr 		      dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ 		    dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ 
    }							      	  return dp [ N - 1 ]					    	return dp [ N - 1 ]					  
  }							      								    								  
  return dp [ N - 1 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS
--							      --							    --								  --
static int longestSubseqWithDiffOne ( int arr [ ] , int n ) { def longestSubseqWithDiffOne ( arr , n ) :		    def longest_subseq_with_diff_one ( arr , n ) :		  success : None
  int dp [ ] = new int [ n ] ;				      	  dp = [ 1 for i in range ( n ) ]			    	dp = [ 0 ] * n						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i ) :				    	    dp [ i ] = 1					  
  i ++ ) dp [ i ] = 1 ;					      		  if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i  	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      		      dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 )    	    for j in range ( i ) :				  
  i < n ;						      	  result = 1						    		if ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ]  
  i ++ ) {						      	  for i in range ( n ) :				    		    dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 )	  
    for ( int j = 0 ;					      	      if ( result < dp [ i ] ) :			    	result = 1						  
    j < i ;						      		  result = dp [ i ]				    	for i in range ( n ) :					  
    j ++ ) {						      	  return result						    	    if result < dp [ i ] :				  
      if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == a 								    		result = dp [ i ]				  
    }							      								    	return result						  
  }							      								    								  
  int result = 1 ;					      								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ;	      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE			      MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE			    MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE			  MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE
--							      --							    --								  --
static int maxcoefficientvalue ( int n ) {		      def maxcoefficientvalue ( n ) :				    def maxcoefficientvalue ( n ) :				  failure : #Results: 7, 10
  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;		      	  C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 	C = np.zeros ( ( n + 1 , n + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( n + 1 ) :				    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      for j in range ( min ( i , n ) + 1 ) :		    	    for j in range ( 0 , min ( i , n ) + 1 ) :		  
  i ++ ) {						      		  if ( j == 0 or j == i ) :			    		if j == 0 or j == i :				  
    for ( int j = 0 ;					      		      C [ i ] [ j ] = 1				    		    C [ i ] [ j ] = 1				  
    j <= Math . min ( i , n ) ;				      		  else :					    		else :						  
    j ++ ) {						      		      C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ 		    C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i 
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;	      	  maxvalue = 0						    	maxvalue = 0						  
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	  for i in range ( n + 1 ) :				    	for i in range ( 0 , n + 1 ) :				  
    }							      	      maxvalue = max ( maxvalue , C [ n ] [ i ] )	    	    maxvalue = max ( maxvalue , C [ n ] [ i ] )		  
  }							      	  return maxvalue					    	return maxvalue						  
  int maxvalue = 0 ;					      								    								  
  for ( int i = 0 ;					      								    								  
  i <= n ;						      								    								  
  i ++ ) maxvalue = Math . max ( maxvalue , C [ n ] [ i ] ) ; 								    								  
  return maxvalue ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_TWO_NUMBERS_B_FIND_X_X_B				      GIVEN_TWO_NUMBERS_B_FIND_X_X_B				    GIVEN_TWO_NUMBERS_B_FIND_X_X_B				  GIVEN_TWO_NUMBERS_B_FIND_X_X_B
--							      --							    --								  --
static void modularEquation ( int a , int b ) {		      def modularEquation ( a , b ) :				    def modular_equation ( a , b ) :				  script_not_found : None
  if ( a < b ) {					      	  if ( a < b ) :					    	if a < b :						  
    System . out . println ( "No solution possible " ) ;      	      print ( "No solution possible " )			    	    print ( "No solution possible " )			  
    return ;						      	      return						    	    return						  
  }							      	  if ( a == b ) :					    	if a == b :						  
  if ( a == b ) {					      	      print ( "Infinite Solution possible " )		    	    print ( "Infinite Solution possible " )		  
    System . out . println ( "Infinite Solution possible " )  	      return						    	    return						  
    return ;						      	  count = 0						    	count = 0						  
  }							      	  n = a - b						    	n = a - b						  
  int count = 0 ;					      	  y = ( int ) ( math.sqrt ( a - b ) )			    	y = int ( math.sqrt ( a - b ) )				  
  int n = a - b ;					      	  for i in range ( 1 , y + 1 ) :			    	for i in range ( 1 , y + 1 ) :				  
  int y = ( int ) Math . sqrt ( a - b ) ;		      	      if ( n % i == 0 ) :				    	    if n % i == 0 :					  
  for ( int i = 1 ;					      		  if ( n / i > b ) :				    		if n / i > b :					  
  i <= y ;						      		      count = count + 1				    		    count += 1					  
  ++ i ) {						      		  if ( i > b ) :				    		if i > b :					  
    if ( n % i == 0 ) {					      		      count = count + 1				    		    count += 1					  
      if ( n / i > b ) count ++ ;			      	  if ( y * y == n and y > b ) :				    	if y * y == n and y > b :				  
      if ( i > b ) count ++ ;				      	      count = count - 1					    	    count -= 1						  
    }							      	  print ( count )					    	print ( count )						  
  }							      								    								  
  if ( y * y == n && y > b ) count -- ;			      								    								  
  System . out . println ( count ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE
--							      --							    --								  --
static int maxSumIS ( int arr [ ] , int n ) {		      def maxSumIS ( arr , n ) :				    def max_sum_fp ( arr , n ) :				  success : None
  int i , j , max = 0 ;					      	  max = 0						    	i , j , max = 0 , 0 , 0					  
  int msis [ ] = new int [ n ] ;			      	  msis = [ 0 for x in range ( n ) ]			    	msis = [ 0 ] * n					  
  for ( i = 0 ;						      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      msis [ i ] = arr [ i ]				    	    msis [ i ] = arr [ i ]				  
  i ++ ) msis [ i ] = arr [ i ] ;			      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  for ( i = 1 ;						      	      for j in range ( i ) :				    	    for j in range ( i ) :				  
  i < n ;						      		  if ( arr [ i ] > arr [ j ] and msis [ i ] < msis  		if arr [ i ] > arr [ j ] and msis [ i ] < msis [  
  i ++ ) for ( j = 0 ;					      		      msis [ i ] = msis [ j ] + arr [ i ]	    		    msis [ i ] = msis [ j ] + arr [ i ]		  
  j < i ;						      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j  	      if max < msis [ i ] :				    	    if max < msis [ i ] :				  
  for ( i = 0 ;						      		  max = msis [ i ]				    		max = msis [ i ]				  
  i < n ;						      	  return max						    	return max						  
  i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ;	      								    								  
  return max ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH	      SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH	    SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH	  SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH
--							      --							    --								  --
int shortestPath ( int graph [ ] [ ] , int u , int v , int k  def shortestPath ( graph , u , v , k ) :			    def shortest_path ( graph , u , v , k ) :			  script_not_found : None
  if ( k == 0 && u == v ) return 0 ;			      	  V = 4							    	if k == 0 and u == v :					  
  if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u  	  INF = 999999999999					    	    return 0						  
  if ( k <= 0 ) return INF ;				      	  if k == 0 and u == v :				    	if k == 1 and graph [ u ] [ v ] != INF :		  
  int res = INF ;					      	      return 0						    	    return graph [ u ] [ v ]				  
  for ( int i = 0 ;					      	  if k == 1 and graph [ u ] [ v ] != INF :		    	if k <= 0 :						  
  i < V ;						      	      return graph [ u ] [ v ]				    	    return INF						  
  i ++ ) {						      	  if k <= 0 :						    	res = INF						  
    if ( graph [ u ] [ i ] != INF && u != i && v != i ) {     	      return INF					    	for i in range ( V ) :					  
      int rec_res = shortestPath ( graph , i , v , k - 1 ) ;  	  res = INF						    	    if graph [ u ] [ i ] != INF and u != i and v != i :	  
      if ( rec_res != INF ) res = Math . min ( res , graph [  	  for i in range ( V ) :				    		rec_res = shortest_path ( graph , i , v , k - 1 ) 
    }							      	      if graph [ u ] [ i ] != INF and u != i and v != i :   		if rec_res != INF :				  
  }							      		  rec_res = shortestPath ( graph , i , v , k - 1 )  		    res = min ( res , graph [ u ] [ i ] + rec_res 
  return res ;						      		  if rec_res != INF :				    	return res						  
}							      		      res = min ( res , graph [ u ] [ i ] + rec_res 								  
							      	  return res						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1   SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1   SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1	  SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1
--							      --							    --								  --
static int getTotalNumberOfSequences ( int m , int n ) {      def getTotalNumberOfSequences ( m , n ) :			    def get_total_number_of_sequences ( m , n ) :		  success : None
  int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;		      	  T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 	T = np.zeros ( ( m + 1 , n + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( m + 1 ) :				    	for i in range ( m + 1 ) :				  
  i < m + 1 ;						      	      for j in range ( n + 1 ) :			    	    for j in range ( n + 1 ) :				  
  i ++ ) {						      		  if i == 0 or j == 0 :				    		if i == 0 or j == 0 :				  
    for ( int j = 0 ;					      		      T [ i ] [ j ] = 0				    		    T [ i ] [ j ] = 0				  
    j < n + 1 ;						      		  elif i < j :					    		elif i < j :					  
    j ++ ) {						      		      T [ i ] [ j ] = 0				    		    T [ i ] [ j ] = 0				  
      if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ;	      		  elif j == 1 :					    		elif j == 1 :					  
      else if ( i < j ) T [ i ] [ j ] = 0 ;		      		      T [ i ] [ j ] = i				    		    T [ i ] [ j ] = i				  
      else if ( j == 1 ) T [ i ] [ j ] = i ;		      		  else :					    		else :						  
      else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [  		      T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i //  		    T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i //  
    }							      	  return T [ m ] [ n ]					    	return T [ m ] [ n ]					  
  }							      								    								  
  return T [ m ] [ n ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1		      THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1		    THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1		  THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1
--							      --							    --								  --
static void thirdLargest ( int arr [ ] , int arr_size ) {     def thirdLargest ( arr , arr_size ) :			    def third_largest ( arr , arr_size ) :			  success : None
  if ( arr_size < 3 ) {					      	  if ( arr_size < 3 ) :					    	if arr_size < 3 :					  
    System . out . printf ( " Invalid Input " ) ;	      	      print ( " Invalid Input " )			    	    print ( " Invalid Input " )				  
    return ;						      	      return						    	    return						  
  }							      	  first = arr [ 0 ]					    	first , second , third = arr [ 0 ] , int ( 0 ) , int ( 0  
  int first = arr [ 0 ] , second = Integer . MIN_VALUE , thir 	  second = - sys.maxsize				    	for i in range ( 1 , arr_size ) :			  
  for ( int i = 1 ;					      	  third = - sys.maxsize					    	    if arr [ i ] > first :				  
  i < arr_size ;					      	  for i in range ( 1 , arr_size ) :			    		third = second					  
  i ++ ) {						      	      if ( arr [ i ] > first ) :			    		second = first					  
    if ( arr [ i ] > first ) {				      		  third = second				    		first = arr [ i ]				  
      third = second ;					      		  second = first				    	    elif arr [ i ] > second :				  
      second = first ;					      		  first = arr [ i ]				    		third = second					  
      first = arr [ i ] ;				      	      elif ( arr [ i ] > second ) :			    		second = arr [ i ]				  
    }							      		  third = second				    	    elif arr [ i ] > third :				  
    else if ( arr [ i ] > second ) {			      		  second = arr [ i ]				    		third = arr [ i ]				  
      third = second ;					      	      elif ( arr [ i ] > third ) :			    	print ( "The third Largest element is %d\n" % third )	  
      second = arr [ i ] ;				      		  third = arr [ i ]				    								  
    }							      	  print ( "The third Largest" , "element is" , third )	    								  
    else if ( arr [ i ] > third ) {			      								    								  
      third = arr [ i ] ;				      								    								  
    }							      								    								  
  }							      								    								  
  System . out . printf ( "The third Largest element is %d\n" 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S
--							      --							    --								  --
static void deleteElements ( int arr [ ] , int n , int k ) {  def deleteElements ( arr , n , k ) :			    def delete_elements ( arr , n , k ) :			  script_not_found : None
  Stack < Integer > s = new Stack < > ( ) ;		      	  st = [ ]						    	s = [ arr [ 0 ] ]					  
  s . push ( arr [ 0 ] ) ;				      	  st.append ( arr [ 0 ] )				    	count = 0						  
  int count = 0 ;					      	  top = 0						    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      	  count = 0						    	    while not s and s [ - 1 ] < arr [ i ] and count < k : 
  i < n ;						      	  for i in range ( 1 , n ) :				    		s.pop ( )					  
  i ++ ) {						      	      while ( len ( st ) != 0 and count < k and st [ top ]  		count += 1					  
    while ( ! s . empty ( ) && s . peek ( ) < arr [ i ] && co 		  st.pop ( )					    	    s.append ( arr [ i ] )				  
      s . pop ( ) ;					      		  count += 1					    	m = len ( s )						  
      count ++ ;					      		  top -= 1					    	v = [ None ] * m					  
    }							      	      st.append ( arr [ i ] )				    	while not s :						  
    s . push ( arr [ i ] ) ;				      	      top += 1						    	    v [ - 1 ] = s [ - 1 ]				  
  }							      	  for i in range ( 0 , len ( st ) ) :			    	    s.pop ( )						  
  int m = s . size ( ) ;				      	      print ( st [ i ] , "" , end = "" )		    	for x in v :						  
  Integer [ ] v = new Integer [ m ] ;			      								    	    print ( x , end = '' )				  
  while ( ! s . empty ( ) ) {				      								    	print ( '' )						  
    v [ -- m ] = s . peek ( ) ;				      								    								  
    s . pop ( ) ;					      								    								  
  }							      								    								  
  for ( Integer x : v ) {				      								    								  
    System . out . print ( x + " " ) ;			      								    								  
  }							      								    								  
  ;							      								    								  
  System . out . println ( "" ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA			      FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA			    FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA			  FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA
--							      --							    --								  --
static void parabola ( float a , float b , float c ) {	      def parabola ( a , b , c ) :				    def parabola ( a , b , c ) :				  script_not_found : None
  System . out . println ( "Vertex: (" + ( - b / ( 2 * a ) )  	  print ( "Vertex: (" , ( - b / ( 2 * a ) ) , ", " , ( ( (  	print ( "Vertex: (%d, %d)" % ( - b / ( 2 * a ) , ( ( 4 *  
  System . out . println ( "Focus: (" + ( - b / ( 2 * a ) ) + 	  print ( "Focus: (" , ( - b / ( 2 * a ) ) , ", " , ( ( ( 4 	print ( "Focus: (%d, %d)" % ( - b / ( 2 * a ) , ( ( 4 * a 
  System . out . println ( "Directrix:" + " y=" + ( int ) ( c 	  print ( "Directrix: y=" , c - ( ( b * b ) + 1 ) * 4 * a , 	print ( "Directrix:" , " y=" , int ( c - ( ( b * b ) + 1  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_ELEMENT_TWO_SORTED_ARRAYS				      K_TH_ELEMENT_TWO_SORTED_ARRAYS				    K_TH_ELEMENT_TWO_SORTED_ARRAYS				  K_TH_ELEMENT_TWO_SORTED_ARRAYS
--							      --							    --								  --
static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n  def kth ( arr1 , arr2 , m , n , k ) :			    def kth ( arr1 , arr2 , m , n , k ) :			  failure : #Results: 2, 10
  int [ ] sorted1 = new int [ m + n ] ;			      	  sorted1 = [ 0 ] * ( m + n )				    	sorted1 = [ 0 ] * ( m + n )				  
  int i = 0 , j = 0 , d = 0 ;				      	  i = 0							    	i , j , d = 0 , 0 , 0					  
  while ( i < m && j < n ) {				      	  j = 0							    	while i < m and j < n :					  
    if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [  	  d = 0							    	    if arr1 [ i ] < arr2 [ j ] :			  
    else sorted1 [ d ++ ] = arr2 [ j ++ ] ;		      	  while ( i < m and j < n ) :				    		sorted1 [ d ] = arr1 [ i ]			  
  }							      	      if ( arr1 [ i ] < arr2 [ j ] ) :			    		i += 1						  
  while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ;	      		  sorted1 [ d ] = arr1 [ i ]			    	    else :						  
  while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ;	      		  i += 1					    		sorted1 [ d ] = arr2 [ j ]			  
  return sorted1 [ k - 1 ] ;				      	      else :						    		j += 1						  
}							      		  sorted1 [ d ] = arr2 [ j ]			    	while i < m :						  
							      		  j += 1					    	    sorted1 [ d ] = arr1 [ i ]				  
							      	      d += 1						    	    i += 1						  
							      	  while ( i < m ) :					    	while j < n :						  
							      	      sorted1 [ d ] = arr1 [ i ]			    	    sorted1 [ d ] = arr2 [ j ]				  
							      	      d += 1						    	    j += 1						  
							      	      i += 1						    	return sorted1 [ k - 1 ]				  
							      	  while ( j < n ) :					    								  
							      	      sorted1 [ d ] = arr2 [ j ]			    								  
							      	      d += 1						    								  
							      	      j += 1						    								  
							      	  return sorted1 [ k - 1 ]				    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST
--							      --							    --								  --
static void printClosest ( int arr [ ] , int n , int x ) {    def printClosest ( arr , n , x ) :			    def print_closer ( arr , n , x ) :				  script_not_found : None
  int res_l = 0 , res_r = 0 ;				      	  res_l , res_r = 0 , 0					    	res_l , res_r = 0 , 0					  
  int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ;	      	  l , r , diff = 0 , n - 1 , MAX_VAL			    	l , r , diff = 0 , n - 1 , sys.maxsize			  
  while ( r > l ) {					      	  while r > l :						    	while r > l :						  
    if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) {  	      if abs ( arr [ l ] + arr [ r ] - x ) < diff :	    	    if abs ( arr [ l ] + arr [ r ] - x ) < diff :	  
      res_l = l ;					      		  res_l = l					    		res_l = l					  
      res_r = r ;					      		  res_r = r					    		res_r = r					  
      diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ;	      		  diff = abs ( arr [ l ] + arr [ r ] - x )	    		diff = abs ( arr [ l ] + arr [ r ] - x )	  
    }							      	      if arr [ l ] + arr [ r ] > x :			    	    if arr [ l ] + arr [ r ] > x :			  
    if ( arr [ l ] + arr [ r ] > x ) r -- ;		      		  r -= 1					    		r -= 1						  
    else l ++ ;						      	      else :						    	    else :						  
  }							      		  l += 1					    		l += 1						  
  System . out . println ( " The closest pair is " + arr [ re 	  print ( 'The closest pair is {} and {}'.format ( arr [ re 	print ( " The closest pair is %d and %d" % ( arr [ res_l  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8	      GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8	    GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8	  GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8
--							      --							    --								  --
static boolean isSubSeqDivisible ( String str ) {	      def isSubSeqDivisible ( st ) :				    def is_subseq_divisible ( data ) :				  error : Traceback (most recent call last):   File
  int i , j , k , l = str . length ( ) ;		      	  l = len ( st )					    	i , j , k , l = list ( data )				  "dump/transcoder_st/eval/java_python/online_st/206
  int arr [ ] = new int [ l ] ;				      	  arr = [ 0 ] * l					    	arr = [ 0 ] * l						  68770/eval_scripts/java_sa-python_sa.test/GIVEN_LA
  for ( i = 0 ;						      	  for i in range ( 0 , l ) :				    	for i in range ( l ) :					  RGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8.py
  i < l ;						      	      for j in range ( i , l ) :			    	    for j in range ( i , l ) :				  ", line 62, in <module>     if f_filled(*parameter
  i ++ ) {						      		  for k in range ( j , l ) :			    		for k in range ( j , l ) :			  s_set) == f_gold(*parameters_set):   File "dump/tr
    for ( j = i ;					      		      if ( arr [ i ] % 8 == 0 ) :		    		    if arr [ i ] % 8 == 0 :			  anscoder_st/eval/java_python/online_st/20668770/ev
    j < l ;						      			  return True				    			return True				  al_scripts/java_sa-python_sa.test/GIVEN_LARGE_NUMB
    j ++ ) {						      		      elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 ==  		    elif ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0  ER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8.py", line
      for ( k = j ;					      			  return True				    			return True				  33, in f_filled     i , j , k , l = list ( data )
      k < l ;						      		      elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + a 		    elif ( arr [ i ] * 100 + arr [ j ] * 10 + arr ValueError: too many values to unpack (expected 4)
      k ++ ) {						      			  return True				    			return True				  
	if ( arr [ i ] % 8 == 0 ) return true ;		      	  return False						    	return False						  
	else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 &&  								    								  
	else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [  								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA
--							      --							    --								  --
static int possibleStrings ( int n , int r , int b , int g )  def possibleStrings ( n , r , b , g ) :			    def possible_strings ( n , r , b , g ) :			  success : None
  int fact [ ] = new int [ n + 1 ] ;			      	  fact = [ 0 for i in range ( n + 1 ) ]			    	fact = [ 1 ] * n + [ 0 ] * n				  
  fact [ 0 ] = 1 ;					      	  fact [ 0 ] = 1					    	fact [ 0 ] = 1						  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 , 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	      fact [ i ] = fact [ i - 1 ] * i			    	    fact [ i ] = fact [ i - 1 ] * i			  
  i ++ ) fact [ i ] = fact [ i - 1 ] * i ;		      	  left = n - ( r + g + b )				    	left = n - ( r + g + b )				  
  int left = n - ( r + g + b ) ;			      	  sum = 0						    	sum = 0							  
  int sum = 0 ;						      	  for i in range ( 0 , left + 1 , 1 ) :			    	for i in range ( 0 , left + 1 ) :			  
  for ( int i = 0 ;					      	      for j in range ( 0 , left - i + 1 , 1 ) :		    	    for j in range ( 0 , left - i + 1 ) :		  
  i <= left ;						      		  k = left - ( i + j )				    		k = left - ( i + j )				  
  i ++ ) {						      		  sum = ( sum + fact [ n ] / ( fact [ i + r ] * fac 		sum = sum + fact [ n ] / ( fact [ i + r ] * fact  
    for ( int j = 0 ;					      	  return sum						    	return sum						  
    j <= left - i ;					      								    								  
    j ++ ) {						      								    								  
      int k = left - ( i + j ) ;			      								    								  
      sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j +  								    								  
    }							      								    								  
  }							      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SQUARES_BINOMIAL_COEFFICIENTS			      SUM_SQUARES_BINOMIAL_COEFFICIENTS				    SUM_SQUARES_BINOMIAL_COEFFICIENTS				  SUM_SQUARES_BINOMIAL_COEFFICIENTS
--							      --							    --								  --
static int sumofsquare ( int n ) {			      def sumofsquare ( n ) :					    def sumofsquare ( n ) :					  failure : #Results: 4, 10
  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;		      	  C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 	C = np.zeros ( ( n + 1 , n + 1 ) )			  
  int i , j ;						      	  for i in range ( 0 , n + 1 ) :			    	i , j = 0 , 0						  
  for ( i = 0 ;						      	      for j in range ( 0 , min ( i , n ) + 1 ) :	    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      		  if ( j == 0 or j == i ) :			    	    for j in range ( 0 , min ( i , n ) + 1 ) :		  
  i ++ ) {						      		      C [ i ] [ j ] = 1				    		if j == 0 or j == i :				  
    for ( j = 0 ;					      		  else :					    		    C [ i ] [ j ] = 1				  
    j <= min ( i , n ) ;				      		      C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ 		else :						  
    j ++ ) {						      	  sum = 0						    		    C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i 
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;	      	  for i in range ( 0 , n + 1 ) :			    	sum = 0							  
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	      sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] )	    	for i in range ( 0 , n + 1 ) :				  
    }							      	  return sum						    	    sum += ( C [ n ] [ i ] ** 2 )			  
  }							      								    	return sum						  
  int sum = 0 ;						      								    								  
  for ( i = 0 ;						      								    								  
  i <= n ;						      								    								  
  i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ;	      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX		      MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX		    MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX		  MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX
--							      --							    --								  --
static int maxRowDiff ( int mat [ ] [ ] , int m , int n ) {   def maxRowDiff ( mat , m , n ) :				    def max_row_diff ( mat , m , n ) :				  success : None
  int rowSum [ ] = new int [ m ] ;			      	  rowSum = [ 0 ] * m					    	row_sum = [ 0 ] * m					  
  for ( int i = 0 ;					      	  for i in range ( 0 , m ) :				    	for i in range ( m ) :					  
  i < m ;						      	      sum = 0						    	    sum = 0						  
  i ++ ) {						      	      for j in range ( 0 , n ) :			    	    for j in range ( n ) :				  
    int sum = 0 ;					      		  sum += mat [ i ] [ j ]			    		sum += mat [ i ] [ j ]				  
    for ( int j = 0 ;					      	      rowSum [ i ] = sum				    	    row_sum [ i ] = sum					  
    j < n ;						      	  max_diff = rowSum [ 1 ] - rowSum [ 0 ]		    	max_diff = row_sum [ 1 ] - row_sum [ 0 ]		  
    j ++ ) sum += mat [ i ] [ j ] ;			      	  min_element = rowSum [ 0 ]				    	min_element = row_sum [ 0 ]				  
    rowSum [ i ] = sum ;				      	  for i in range ( 1 , m ) :				    	for i in range ( 1 , m ) :				  
  }							      	      if ( rowSum [ i ] - min_element > max_diff ) :	    	    if row_sum [ i ] - min_element > max_diff :		  
  int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ;		      		  max_diff = rowSum [ i ] - min_element		    		max_diff = row_sum [ i ] - min_element		  
  int min_element = rowSum [ 0 ] ;			      	      if ( rowSum [ i ] < min_element ) :		    	    if row_sum [ i ] < min_element :			  
  for ( int i = 1 ;					      		  min_element = rowSum [ i ]			    		min_element = row_sum [ i ]			  
  i < m ;						      	  return max_diff					    	return max_diff						  
  i ++ ) {						      								    								  
    if ( rowSum [ i ] - min_element > max_diff ) max_diff = r 								    								  
    if ( rowSum [ i ] < min_element ) min_element = rowSum [  								    								  
  }							      								    								  
  return max_diff ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING  MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING  MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING  MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING
--							      --							    --								  --
static int minimalSteps ( String s , int n ) {		      def minimalSteps ( s , n ) :				    def minimalSteps ( s , n ) :				  script_not_found : None
  int [ ] dp = new int [ n ] ;				      	  dp = [ INT_MAX for i in range ( n ) ]			    	dp = [ 0 for i in range ( n ) ]				  
  for ( int i = 0 ;					      	  s1 = ""						    	s1 , s2 = "" , ""					  
  i < n ;						      	  s2 = ""						    	dp [ 0 ] = 1						  
  i ++ ) dp [ i ] = Integer . MAX_VALUE ;		      	  dp [ 0 ] = 1						    	s1 += s [ 0 ]						  
  String s1 = "" , s2 = "" ;				      	  s1 += s [ 0 ]						    	for i in range ( 1 , n ) :				  
  dp [ 0 ] = 1 ;					      	  for i in range ( 1 , n ) :				    	    s1 += s [ i ]					  
  s1 += s . charAt ( 0 ) ;				      	      s1 += s [ i ]					    	    s2 = s [ i + 1 : i + 1 ]				  
  for ( int i = 1 ;					      	      s2 = s [ i + 1 : i + 1 + i + 1 ]			    	    dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 )	  
  i < n ;						      	      dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 )	    	    if s1 == s2 :					  
  i ++ ) {						      	      if ( s1 == s2 ) :					    		dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i *  
    s1 += s . charAt ( i ) ;				      		  dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i *  	return dp [ n - 1 ]					  
    s2 = s . substring ( i + 1 , i + 1 ) ;		      	  return dp [ n - 1 ]					    								  
    dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ;   								    								  
    if ( s1 == s2 ) dp [ i * 2 + 1 ] = Math . min ( dp [ i ]  								    								  
  }							      								    								  
  return dp [ n - 1 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS		      LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS			    LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS			  LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS
--							      --							    --								  --
static void longest ( int a [ ] , int n , int k ) {	      def longest ( a , n , k ) :				    def longest ( a , n , k ) :					  script_not_found : None
  int [ ] freq = new int [ 7 ] ;			      	  freq = [ 0 ] * n					    	freq = np.zeros ( 7 )					  
  int start = 0 , end = 0 , now = 0 , l = 0 ;		      	  start = 0						    	start , end , now , l = 0 , 0 , 0 , 0 , 0		  
  for ( int i = 0 ;					      	  end = 0						    	for i in range ( n ) :					  
  i < n ;						      	  now = 0						    	    freq [ a [ i ] ] += 1				  
  i ++ ) {						      	  l = 0							    	    if freq [ a [ i ] ] == 1 :				  
    freq [ a [ i ] ] ++ ;				      	  for i in range ( n ) :				    		now += 1					  
    if ( freq [ a [ i ] ] == 1 ) now ++ ;		      	      freq [ a [ i ] ] += 1				    	    while now > k :					  
    while ( now > k ) {					      	      if ( freq [ a [ i ] ] == 1 ) :			    		freq [ a [ l ] ] -= 1				  
      freq [ a [ l ] ] -- ;				      		  now += 1					    		if freq [ a [ l ] ] == 0 :			  
      if ( freq [ a [ l ] ] == 0 ) now -- ;		      	      while ( now > k ) :				    		    now -= 1					  
      l ++ ;						      		  freq [ a [ l ] ] -= 1				    		l += 1						  
    }							      		  if ( freq [ a [ l ] ] == 0 ) :		    	if i - l + 1 >= end - start + 1 :			  
    if ( i - l + 1 >= end - start + 1 ) {		      		      now -= 1					    	    end = i						  
      end = i ;						      		  l += 1					    	    start = l						  
      start = l ;					      	      if ( i - l + 1 >= end - start + 1 ) :		    	for i in range ( start , end + 1 ) :			  
    }							      		  end = i					    	    print ( a [ i ] , end = ' ' )			  
  }							      		  start = l					    								  
  for ( int i = start ;					      	  for i in range ( start , end + 1 ) :			    								  
  i <= end ;						      	      print ( a [ i ] , end = " " )			    								  
  i ++ ) System . out . print ( a [ i ] + " " ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PETERSON_GRAPH						      PETERSON_GRAPH						    PETERSON_GRAPH						  PETERSON_GRAPH
--							      --							    --								  --
static boolean findthepath ( char [ ] S , int v ) {	      def findthepath ( S , v ) :				    def findthepath ( S , v ) :					  script_not_found : None
  result [ 0 ] = ( char ) ( v + '0' ) ;			      	  result [ 0 ] = v					    	global result						  
  for ( int i = 1 ;					      	  for i in range ( 1 , len ( S ) ) :			    	result [ 0 ] = chr ( v + ord ( '0' ) )			  
  i < ( int ) S . length ;				      	      if ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) ] or a 	for i in range ( 1 , int ( len ( S ) ) ) :		  
  i ++ ) {						      		  v = ord ( S [ i ] ) - ord ( 'A' )		    	    if S [ i ] [ i ] [ 0 ] == 'A' or S [ i ] [ i ] [ 0 ]  
    if ( adj [ v ] [ S [ i ] - 'A' ] || adj [ S [ i ] - 'A' ] 	      elif ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) + 5  		v = S [ i ] [ i ] [ 0 ] - 'A'			  
      v = S [ i ] - 'A' ;				      		  v = ord ( S [ i ] ) - ord ( 'A' ) + 5		    	    elif S [ i ] [ i ] [ 0 ] == 'A' + 5 or S [ i ] [ i ]  
    }							      	      else :						    		v = S [ i ] [ i ] [ 0 ] - 'A' + 5		  
    else if ( adj [ v ] [ S [ i ] - 'A' + 5 ] || adj [ S [ i  		  return False					    	    else :						  
      v = S [ i ] - 'A' + 5 ;				      	      result.append ( v )				    		return False					  
    }							      	  return True						    	    result [ i ] = chr ( v + ord ( '0' ) )		  
    else return false ;					      								    	return True						  
    result [ i ] = ( char ) ( v + '0' ) ;		      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE		      COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE		    COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE		  COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE
--							      --							    --								  --
static void printRect ( Integer X [ ] , Integer Y [ ] , int n def printRect ( X , Y , n ) :				    def print_rect ( X = None , Y = None , n = None ) :		  script_not_found : None
  int Xmax = Collections . max ( Arrays . asList ( X ) ) ;    	  Xmax = max ( X )					    	Xmax = max ( X )					  
  int Xmin = Collections . min ( Arrays . asList ( X ) ) ;    	  Xmin = min ( X )					    	Xmin = min ( X )					  
  int Ymax = Collections . max ( Arrays . asList ( Y ) ) ;    	  Ymax = max ( Y )					    	Ymax = max ( Y )					  
  int Ymin = Collections . min ( Arrays . asList ( Y ) ) ;    	  Ymin = min ( Y )					    	Ymin = min ( Y )					  
  System . out . println ( "{" + Xmin + ", " + Ymin + "}" ) ; 	  print ( "{" , Xmin , ", " , Ymin , "}" , sep = "" )	    	print ( "{%d, %d}" % ( Xmin , Ymin ) )			  
  System . out . println ( "{" + Xmin + ", " + Ymax + "}" ) ; 	  print ( "{" , Xmin , ", " , Ymax , "}" , sep = "" )	    	print ( "{%d, %d}" % ( Xmin , Ymax ) )			  
  System . out . println ( "{" + Xmax + ", " + Ymax + "}" ) ; 	  print ( "{" , Xmax , ", " , Ymax , "}" , sep = "" )	    	print ( "{%d, %d}" % ( Xmax , Ymax ) )			  
  System . out . println ( "{" + Xmax + ", " + Ymin + "}" ) ; 	  print ( "{" , Xmax , ", " , Ymin , "}" , sep = "" )	    	print ( "{%d, %d}" % ( Xmax , Ymin ) )			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D		      FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D			    FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D			  FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D
--							      --							    --								  --
static int findLargestd ( int [ ] S , int n ) {		      def findLargestd ( S , n ) :				    def find_largestd ( S , n ) :				  failure : #Results: 8, 10
  boolean found = false ;				      	  found = False						    	found = False						  
  Arrays . sort ( S ) ;					      	  S.sort ( )						    	S.sort ( )						  
  for ( int i = n - 1 ;					      	  for i in range ( n - 1 , - 1 , - 1 ) :		    	for i in range ( n - 1 , - 1 , - 1 ) :			  
  i >= 0 ;						      	      for j in range ( 0 , n ) :			    	    for j in range ( n ) :				  
  i -- ) {						      		  if ( i == j ) :				    		if i == j :					  
    for ( int j = 0 ;					      		      continue					    		    continue					  
    j < n ;						      		  for k in range ( j + 1 , n ) :		    		for k in range ( j + 1 , n ) :			  
    j ++ ) {						      		      if ( i == k ) :				    		    if i == k :					  
      if ( i == j ) continue ;				      			  continue				    			continue				  
      for ( int k = j + 1 ;				      		      for l in range ( k + 1 , n ) :		    		    for l in range ( k + 1 , n ) :		  
      k < n ;						      			  if ( i == l ) :			    			if i == l :				  
      k ++ ) {						      			      continue				    			    continue				  
	if ( i == k ) continue ;			      			  if ( S [ i ] == S [ j ] + S [ k ] + S [ l 			if S [ i ] == S [ j ] + S [ k ] + S [ l ] 
	for ( int l = k + 1 ;				      			      found = True			    			    found = True			  
	l < n ;						      			      return S [ i ]			    			    return S [ i ]			  
	l ++ ) {					      	  if ( found == False ) :				    	if found == False :					  
	  if ( i == l ) continue ;			      	      return - 1					    	    return sys.maxsize					  
	  if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {     								    	return - 1						  
	    found = true ;				      								    								  
	    return S [ i ] ;				      								    								  
	  }						      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  if ( found == false ) return Integer . MAX_VALUE ;	      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PRODUCT_SUBSET_ARRAY				      MAXIMUM_PRODUCT_SUBSET_ARRAY				    MAXIMUM_PRODUCT_SUBSET_ARRAY				  MAXIMUM_PRODUCT_SUBSET_ARRAY
--							      --							    --								  --
static int maxProductSubset ( int a [ ] , int n ) {	      def maxProductSubset ( a , n ) :				    def max_product_subset ( a , n ) :				  failure : #Results: 9, 10
  if ( n == 1 ) {					      	  if n == 1 :						    	if n == 1 :						  
    return a [ 0 ] ;					      	      return a [ 0 ]					    	    return a [ 0 ]					  
  }							      	  max_neg = - 999999999999				    	max_neg = sys.maxsize					  
  int max_neg = Integer . MIN_VALUE ;			      	  count_neg = 0						    	count_neg , count_zero = 0 , 0				  
  int count_neg = 0 , count_zero = 0 ;			      	  count_zero = 0					    	prod = 1						  
  int prod = 1 ;					      	  prod = 1						    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	    if a [ i ] == 0 :					  
  i < n ;						      	      if a [ i ] == 0 :					    		count_zero += 1					  
  i ++ ) {						      		  count_zero += 1				    		continue					  
    if ( a [ i ] == 0 ) {				      		  continue					    	    if a [ i ] < 0 :					  
      count_zero ++ ;					      	      if a [ i ] < 0 :					    		count_neg += 1					  
      continue ;					      		  count_neg += 1				    		max_neg = max ( max_neg , a [ i ] )		  
    }							      		  max_neg = max ( max_neg , a [ i ] )		    	    prod = prod * a [ i ]				  
    if ( a [ i ] < 0 ) {				      	      prod = prod * a [ i ]				    	if count_zero == n :					  
      count_neg ++ ;					      	  if count_zero == n :					    	    return 0						  
      max_neg = Math . max ( max_neg , a [ i ] ) ;	      	      return 0						    	if count_neg % 2 == 1 :					  
    }							      	  if count_neg & 1 :					    	    if count_neg == 1 and count_zero > 0 and count_zero + 
    prod = prod * a [ i ] ;				      	      if ( count_neg == 1 and count_zero > 0 and count_zero 		return 0					  
  }							      		  return 0					    	    prod = prod // max_neg				  
  if ( count_zero == n ) {				      	      prod = int ( prod / max_neg )			    	return prod						  
    return 0 ;						      	  return prod						    								  
  }							      								    								  
  if ( count_neg % 2 == 1 ) {				      								    								  
    if ( count_neg == 1 && count_zero > 0 && count_zero + cou 								    								  
      return 0 ;					      								    								  
    }							      								    								  
    prod = prod / max_neg ;				      								    								  
  }							      								    								  
  return prod ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_WAYS_JUMP_REACH_END			      COUNT_NUMBER_WAYS_JUMP_REACH_END				    COUNT_NUMBER_WAYS_JUMP_REACH_END				  COUNT_NUMBER_WAYS_JUMP_REACH_END
--							      --							    --								  --
static void countWaysToJump ( int arr [ ] , int n ) {	      def countWaysToJump ( arr , n ) :				    def count_ways_to_jump ( arr , n ) :			  script_not_found : None
  int count_jump [ ] = new int [ n ] ;			      	  count_jump = [ 0 for i in range ( n ) ]		    	count_jump = [ 0 ] * n					  
  Arrays . fill ( count_jump , 0 ) ;			      	  for i in range ( n - 2 , - 1 , - 1 ) :		    	count_jump [ 0 ] = 0					  
  for ( int i = n - 2 ;					      	      if ( arr [ i ] >= n - i - 1 ) :			    	for i in range ( n - 2 , - 1 , - 1 ) :			  
  i >= 0 ;						      		  count_jump [ i ] += 1				    	    if arr [ i ] >= n - i - 1 :				  
  i -- ) {						      	      j = i + 1						    		count_jump [ i ] += 1				  
    if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ;	      	      while ( j < n - 1 and j <= arr [ i ] + i ) :	    	    for j in range ( i + 1 , n - 1 , - 1 ) :		  
    for ( int j = i + 1 ;				      		  if ( count_jump [ j ] != - 1 ) :		    		if count_jump [ j ] != - 1 :			  
    j < n - 1 && j <= arr [ i ] + i ;			      		      count_jump [ i ] += count_jump [ j ]	    		    count_jump [ i ] += count_jump [ j ]	  
    j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += 		  j += 1					    	    if count_jump [ i ] == 0 :				  
    if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ;     	      if ( count_jump [ i ] == 0 ) :			    		count_jump [ i ] = - 1				  
  }							      		  count_jump [ i ] = - 1			    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	    print ( count_jump [ i ] , end = ' ' )		  
  i < n ;						      	      print ( count_jump [ i ] , end = " " )		    								  
  i ++ ) System . out . print ( count_jump [ i ] + " " ) ;    								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_AREA_RECTANGLES_POSSIBLE_ARRAY			      SUM_AREA_RECTANGLES_POSSIBLE_ARRAY			    SUM_AREA_RECTANGLES_POSSIBLE_ARRAY				  SUM_AREA_RECTANGLES_POSSIBLE_ARRAY
--							      --							    --								  --
static int MaxTotalRectangleArea ( int [ ] a , int n ) {      def MaxTotalRectangleArea ( a , n ) :			    def MaxTotalRectangleArea ( a , n ) :			  script_not_found : None
  Arrays . sort ( a ) ;					      	  a.sort ( reverse = True )				    	a.sort ( )						  
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  boolean flag = false ;				      	  flag = False						    	flag = 0						  
  int len = 0 ;						      	  len = 0						    	len_ = 0						  
  for ( int i = 0 ;					      	  i = 0							    	for i in range ( n ) :					  
  i < n ;						      	  while ( i < n - 1 ) :					    	    if ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ]  
  i ++ ) {						      	      if ( i != 0 ) :					    		flag = 1					  
    if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 		  i = i + 1					    		len_ = a [ i + 1 ]				  
      flag = true ;					      	      if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1  		i += 1						  
      len = a [ i + 1 ] ;				      		  flag = True					    	    elif ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1  
      i ++ ;						      		  len = a [ i + 1 ]				    		sum = sum + a [ i + 1 ] * len_			  
    }							      		  i = i + 1					    		flag = 0					  
    else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 	      elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i +  		i += 1						  
      sum = sum + a [ i + 1 ] * len ;			      		  sum = sum + a [ i + 1 ] * len			    	return sum						  
      flag = false ;					      		  flag = False					    								  
      i ++ ;						      		  i = i + 1					    								  
    }							      	  return sum						    								  
  }							      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU
--							      --							    --								  --
static String arrangeString ( String str ) {		      def arrangeString ( string ) :				    def arrangeString ( str ) :					  script_not_found : None
  int char_count [ ] = new int [ MAX_CHAR ] ;		      	  char_count = [ 0 ] * MAX_CHAR				    	char_count = [ 0 ] * MAX_CHAR				  
  int sum = 0 ;						      	  s = 0							    	sum = 0							  
  for ( int i = 0 ;					      	  for i in range ( len ( string ) ) :			    	for c in str :						  
  i < str . length ( ) ;				      	      if string [ i ] >= "A" and string [ i ] <= "Z" :	    	    if c.isupper ( ) :					  
  i ++ ) {						      		  char_count [ ord ( string [ i ] ) - ord ( "A" ) ] 		char_count [ ord ( c ) - ord ( 'A' ) ] += 1	  
    if ( Character . isUpperCase ( str . charAt ( i ) ) ) cha 	      else :						    	    else :						  
    else sum = sum + ( str . charAt ( i ) - '0' ) ;	      		  s += ord ( string [ i ] ) - ord ( "0" )	    		sum = sum + ( ord ( c ) - ord ( '0' ) )		  
  }							      	  res = ""						    	res = ""						  
  String res = "" ;					      	  for i in range ( MAX_CHAR ) :				    	for i in range ( MAX_CHAR ) :				  
  for ( int i = 0 ;					      	      ch = chr ( ord ( "A" ) + i )			    	    ch = chr ( ord ( 'A' ) + i )			  
  i < MAX_CHAR ;					      	      while char_count [ i ] :				    	    while char_count [ i ] :				  
  i ++ ) {						      		  res += ch					    		char_count [ i ] -= 1				  
    char ch = ( char ) ( 'A' + i ) ;			      		  char_count [ i ] -= 1				    	    res = res + ch					  
    while ( char_count [ i ] -- != 0 ) res = res + ch ;	      	  if s > 0 :						    	if sum :						  
  }							      	      res += str ( s )					    	    res = res + str					  
  if ( sum > 0 ) res = res + sum ;			      	  return res						    	return res						  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS	      MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS	    MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS		  MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS
--							      --							    --								  --
static int getMinDiff ( int arr [ ] , int n , int k ) {	      def getMinDiff ( arr , n , k ) :				    def get_min_diff ( arr , n , k ) :				  success : None
  if ( n == 1 ) return 0 ;				      	  if ( n == 1 ) :					    	if n == 1 :						  
  Arrays . sort ( arr ) ;				      	      return 0						    	    return 0						  
  int ans = arr [ n - 1 ] - arr [ 0 ] ;			      	  arr.sort ( )						    	arr.sort ( )						  
  int small = arr [ 0 ] + k ;				      	  ans = arr [ n - 1 ] - arr [ 0 ]			    	ans = arr [ n - 1 ] - arr [ 0 ]				  
  int big = arr [ n - 1 ] - k ;				      	  small = arr [ 0 ] + k					    	small = arr [ 0 ] + k					  
  int temp = 0 ;					      	  big = arr [ n - 1 ] - k				    	big = arr [ n - 1 ] - k					  
  if ( small > big ) {					      	  if ( small > big ) :					    	temp = 0						  
    temp = small ;					      	      small , big = big , small				    	if small > big :					  
    small = big ;					      	  for i in range ( 1 , n - 1 ) :			    	    temp = small					  
    big = temp ;					      	      subtract = arr [ i ] - k				    	    small = big						  
  }							      	      add = arr [ i ] + k				    	    big = temp						  
  for ( int i = 1 ;					      	      if ( subtract >= small or add <= big ) :		    	for i in range ( 1 , n - 1 ) :				  
  i < n - 1 ;						      		  continue					    	    subtract = arr [ i ] - k				  
  i ++ ) {						      	      if ( big - subtract <= add - small ) :		    	    add = arr [ i ] + k					  
    int subtract = arr [ i ] - k ;			      		  small = subtract				    	    if subtract >= small or add <= big :		  
    int add = arr [ i ] + k ;				      	      else :						    		continue					  
    if ( subtract >= small || add <= big ) continue ;	      		  big = add					    	    if big - subtract <= add - small :			  
    if ( big - subtract <= add - small ) small = subtract ;   	  return min ( ans , big - small )			    		small = subtract				  
    else big = add ;					      								    	    else :						  
  }							      								    		big = add					  
  return Math . min ( ans , big - small ) ;		      								    	return min ( ans , big - small )			  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_COMMON_SUBSTRING				      LONGEST_COMMON_SUBSTRING					    LONGEST_COMMON_SUBSTRING					  LONGEST_COMMON_SUBSTRING
--							      --							    --								  --
static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n def LCSubStr ( X , Y , m , n ) :				    def LCSubStr ( X , Y , m , n ) :				  success : None
  int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	  LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range  	LCStuff = np.zeros ( ( m + 1 , n + 1 ) )		  
  int result = 0 ;					      	  result = 0						    	result = 0						  
  for ( int i = 0 ;					      	  for i in range ( m + 1 ) :				    	for i in range ( 0 , m + 1 ) :				  
  i <= m ;						      	      for j in range ( n + 1 ) :			    	    for j in range ( 0 , n + 1 ) :			  
  i ++ ) {						      		  if ( i == 0 or j == 0 ) :			    		if i == 0 or j == 0 :				  
    for ( int j = 0 ;					      		      LCSuff [ i ] [ j ] = 0			    		    LCStuff [ i ] [ j ] = 0			  
    j <= n ;						      		  elif ( X [ i - 1 ] == Y [ j - 1 ] ) :		    		elif X [ i - 1 ] == Y [ j - 1 ] :		  
    j ++ ) {						      		      LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 		    LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 
      if ( i == 0 || j == 0 ) LCStuff [ i ] [ j ] = 0 ;	      		      result = max ( result , LCSuff [ i ] [ j ] )  		    result = max ( result , LCStuff [ i ] [ j ] ) 
      else if ( X [ i - 1 ] == Y [ j - 1 ] ) {		      		  else :					    		else :						  
	LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 		      LCSuff [ i ] [ j ] = 0			    		    LCStuff [ i ] [ j ] = 0			  
	result = Integer . max ( result , LCStuff [ i ] [ j ] 	  return result						    	return result						  
      }							      								    								  
      else LCStuff [ i ] [ j ] = 0 ;			      								    								  
    }							      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A
--							      --							    --								  --
static void printInSortedOrder ( String arr [ ] , int n ) {   def printInSortedOrder ( arr , n ) :			    def print_in_sorted_order ( arr , n ) :			  script_not_found : None
  int index [ ] = new int [ n ] ;			      	  index = [ 0 ] * n					    	index = [ 0 ] * n					  
  int i , j , min ;					      	  for i in range ( n ) :				    	i , j , min = 0 , 0 , 0					  
  for ( i = 0 ;						      	      index [ i ] = i					    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( n - 1 ) :				    	    index [ i ] = i					  
  i ++ ) {						      	      min = i						    	for i in range ( n - 1 ) :				  
    index [ i ] = i ;					      	      for j in range ( i + 1 , n ) :			    	    min = i						  
  }							      		  if ( arr [ index [ min ] ] > arr [ index [ j ] ]  	    for j in range ( i + 1 , n ) :			  
  for ( i = 0 ;						      		      min = j					    		if arr [ index [ min ] ] > arr [ index [ j ] ] :  
  i < n - 1 ;						      	      if ( min != i ) :					    		    min = j					  
  i ++ ) {						      		  index [ min ] , index [ i ] = index [ i ] , index 	    if min != i :					  
    min = i ;						      	  for i in range ( n ) :				    		temp = index [ min ]				  
    for ( j = i + 1 ;					      	      print ( arr [ index [ i ] ] , end = " " )		    		index [ min ] = index [ i ]			  
    j < n ;						      								    		index [ i ] = temp				  
    j ++ ) {						      								    	for i in range ( n ) :					  
      if ( arr [ index [ min ] ] . compareTo ( arr [ index [  								    	    print ( arr [ index [ i ] ] , end = ' ' )		  
	min = j ;					      								    								  
      }							      								    								  
    }							      								    								  
    if ( min != i ) {					      								    								  
      int temp = index [ min ] ;			      								    								  
      index [ min ] = index [ i ] ;			      								    								  
      index [ i ] = temp ;				      								    								  
    }							      								    								  
  }							      								    								  
  for ( i = 0 ;						      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    System . out . print ( arr [ index [ i ] ] + " " ) ;      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_CHECK					      DIVISIBILITY_CHECK					    DIVISIBILITY_CHECK						  DIVISIBILITY_CHECK
--							      --							    --								  --
static void divisibilityCheck ( List < Integer > arr , int n  def divisibilityCheck ( arr , n ) :			    def divisibility_check ( arr , n ) :			  script_not_found : None
  List < Integer > s = new ArrayList < Integer > ( ) ;	      	  s = dict ( )						    	s = [ ]							  
  int max_ele = Integer . MIN_VALUE ;			      	  max_ele = - 10 ** 9					    	max_ele = sys.maxsize					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      s [ arr [ i ] ] = 1				    	    s.append ( arr [ i ] )				  
  i ++ ) {						      	      max_ele = max ( max_ele , arr [ i ] )		    	    max_ele = max ( max_ele , arr [ i ] )		  
    s . add ( arr . get ( i ) ) ;			      	  res = dict ( )					    	res = frozenset ( )					  
    max_ele = Math . max ( max_ele , arr . get ( i ) ) ;      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  }							      	      if ( arr [ i ] != 0 ) :				    	    if arr [ i ] != 0 :					  
  LinkedHashSet < Integer > res = new LinkedHashSet < Integer 		  for j in range ( arr [ i ] * 2 , max_ele + 1 , ar 		for j in range ( arr [ i ] * 2 , max_ele + 1 , ar 
  for ( int i = 0 ;					      		      if ( j in s.keys ( ) ) :			    		    if j in s :					  
  i < n ;						      			  res [ j ] = 1				    			res.append ( j )			  
  i ++ ) {						      	  for x in res :					    	res = list ( res )					  
    if ( arr . get ( i ) != 0 ) for ( int j = arr . get ( i ) 	      print ( x , end = " " )				    	res.reverse ( )						  
    j <= max_ele ;					      								    	for temp in res :					  
    j += arr . get ( i ) ) {				      								    	    print ( temp , end = ' ' )				  
      if ( s . contains ( j ) ) res . add ( j ) ;	      								    								  
    }							      								    								  
  }							      								    								  
  List < Integer > list = new ArrayList < Integer > ( res ) ; 								    								  
  Collections . reverse ( list ) ;			      								    								  
  for ( Integer temp : list ) System . out . print ( temp + " 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C			      MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C			    MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C				  MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C
--							      --							    --								  --
static int maximumSegments ( int n , int a , int b , int c )  def maximumSegments ( n , a , b , c ) :			    def maximum_segments ( n , a , b , c ) :			  success : None
  int dp [ ] = new int [ n + 10 ] ;			      	  dp = [ - 1 ] * ( n + 10 )				    	dp = [ - 1 ] * ( n + 10 )				  
  Arrays . fill ( dp , - 1 ) ;				      	  dp [ 0 ] = 0						    	dp [ 0 ] = 0						  
  dp [ 0 ] = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      if ( dp [ i ] != - 1 ) :				    	    if dp [ i ] != - 1 :				  
  i < n ;						      		  if ( i + a <= n ) :				    		if i + a <= n :					  
  i ++ ) {						      		      dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i +  		    dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i +  
    if ( dp [ i ] != - 1 ) {				      		  if ( i + b <= n ) :				    		if i + b <= n :					  
      if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ]  		      dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i +  		    dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i +  
      if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ]  		  if ( i + c <= n ) :				    		if i + c <= n :					  
      if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ]  		      dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i +  		    dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i +  
    }							      	  return dp [ n ]					    	return dp [ n ]						  
  }							      								    								  
  return dp [ n ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_MAXIMUM_SHORTEST_DISTANCE				      PRINT_MAXIMUM_SHORTEST_DISTANCE				    PRINT_MAXIMUM_SHORTEST_DISTANCE				  PRINT_MAXIMUM_SHORTEST_DISTANCE
--							      --							    --								  --
static int find_maximum ( int a [ ] , int n , int k ) {	      def find_maximum ( a , n , k ) :				    def find_maximum ( a , n , k ) :				  failure : #Results: 1, 10
  HashMap < Integer , Integer > b = new HashMap < Integer , I 	  b = dict ( )						    	b = { }							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      x = a [ i ]					    	    x = a [ i ]						  
  i ++ ) {						      	      d = min ( 1 + i , n - i )				    	    d = min ( 1 + i , n - i )				  
    int x = a [ i ] ;					      	      if x not in b.keys ( ) :				    	    if x not in b :					  
    int d = Math . min ( 1 + i , n - i ) ;		      		  b [ x ] = d					    		b [ x ] = d					  
    if ( ! b . containsKey ( x ) ) b . put ( x , d ) ;	      	      else :						    	    else :						  
    else {						      		  b [ x ] = min ( d , b [ x ] )			    		b [ x ] = min ( d , b [ x ] )			  
      b . put ( x , Math . min ( d , b . get ( x ) ) ) ;      	  ans = 10 ** 9						    	ans = sys.maxsize					  
    }							      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  }							      	      x = a [ i ]					    	    x = a [ i ]						  
  int ans = Integer . MAX_VALUE ;			      	      if ( x != ( k - x ) and ( k - x ) in b.keys ( ) ) :   	    if x != k - x and k - x in b :			  
  for ( int i = 0 ;					      		  ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) 		ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) 
  i < n ;						      	  return ans						    	return ans						  
  i ++ ) {						      								    								  
    int x = a [ i ] ;					      								    								  
    if ( x != k - x && b . containsKey ( k - x ) ) ans = Math 								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N			      NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N			    NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N			  NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N
--							      --							    --								  --
static int countDivisibleSubseq ( String str , int n ) {      def countDivisibleSubseq ( str , n ) :			    def count_divisible_subgraph ( str , n ) :			  script_not_found : None
  int len = str . length ( ) ;				      	  l = len ( str )					    	str = list ( str )					  
  int dp [ ] [ ] = new int [ len ] [ n ] ;		      	  dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ]  	dp = np.zeros ( ( len ( str ) , n ) )			  
  dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ;	      	  dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 	dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] += 1		  
  for ( int i = 1 ;					      	  for i in range ( 1 , l ) :				    	for i in range ( 1 , len ( str ) ) :			  
  i < len ;						      	      dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ]  	    dp [ i ] [ ( str [ i ] - '0' ) % n ] += 1		  
  i ++ ) {						      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
    dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ;	      		  dp [ i ] [ j ] += dp [ i - 1 ] [ j ]		    		dp [ i ] [ j ] += dp [ i - 1 ] [ j ]		  
    for ( int j = 0 ;					      		  dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( 		dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] 
    j < n ;						      	  return dp [ l - 1 ] [ 0 ]				    	return dp [ - 1 ] [ 0 ]					  
    j ++ ) {						      								    								  
      dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ;		      								    								  
      dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) %  								    								  
    }							      								    								  
  }							      								    								  
  return dp [ len - 1 ] [ 0 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KNAPSACK_PROBLEM_1					      KNAPSACK_PROBLEM_1					    KNAPSACK_PROBLEM_1						  KNAPSACK_PROBLEM_1
--							      --							    --								  --
static int knapSack ( int W , int wt [ ] , int val [ ] , int  def knapSack ( W , wt , val , n ) :			    def knapSack ( W , wt , val , n ) :				  script_not_found : None
  int i , w ;						      	  K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 	global K						  
  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;		      	  for i in range ( n + 1 ) :				    	K = np.zeros ( ( n + 1 , W + 1 ) )			  
  for ( i = 0 ;						      	      for w in range ( W + 1 ) :			    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      		  if i == 0 or w == 0 :				    	    for w in range ( 0 , W + 1 ) :			  
  i ++ ) {						      		      K [ i ] [ w ] = 0				    		if i == 0 or w == 0 :				  
    for ( w = 0 ;					      		  elif wt [ i - 1 ] <= w :			    		    K [ i ] [ w ] = 0				  
    w <= W ;						      		      K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 		elif wt [ i - 1 ] <= w :			  
    w ++ ) {						      		  else :					    		    K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 
      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;	      		      K [ i ] [ w ] = K [ i - 1 ] [ w ]		    		else :						  
      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 	  return K [ n ] [ W ]					    		    K [ i ] [ w ] = K [ i - 1 ] [ w ]		  
      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		      								    	return K [ n ] [ W ]					  
    }							      								    								  
  }							      								    								  
  return K [ n ] [ W ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1
--							      --							    --								  --
static int maxSumWO3Consec ( int n ) {			      def maxSumWO3Consec ( n ) :				    def max_sum_wo3_consec ( n ) :				  script_not_found : None
  if ( sum [ n ] != - 1 ) return sum [ n ] ;		      	  if ( sum [ n ] != - 1 ) :				    	if n in sum :						  
  if ( n == 0 ) return sum [ n ] = 0 ;			      	      return sum [ n ]					    	    return sum [ n ]					  
  if ( n == 1 ) return sum [ n ] = arr [ 0 ] ;		      	  if ( n == 0 ) :					    	if n == 0 :						  
  if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ;    	      sum [ n ] = 0					    	    return sum [ n ] = 0				  
  return sum [ n ] = Math . max ( Math . max ( maxSumWO3Conse 	      return sum [ n ]					    	if n == 1 :						  
}							      	  if ( n == 1 ) :					    	    return sum [ n ] = arr [ 0 ]			  
							      	      sum [ n ] = arr [ 0 ]				    	if n == 2 :						  
							      	      return sum [ n ]					    	    return sum [ n ] = arr [ 1 ] + arr [ 0 ]		  
							      	  if ( n == 2 ) :					    	return sum [ n ] = max ( max ( max_sum_wo3_consec ( n - 1 
							      	      sum [ n ] = arr [ 1 ] + arr [ 0 ]			    								  
							      	      return sum [ n ]					    								  
							      	  sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSu 								  
							      	  return sum [ n ]					    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE			      LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE			    LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE			  LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE
--							      --							    --								  --
public static int longOddEvenIncSeq ( int arr [ ] , int n ) { def longOddEvenIncSeq ( arr , n ) :			    def long_odd_even_inc_seq ( arr , n ) :			  success : None
  int [ ] lioes = new int [ n ] ;			      	  lioes = list ( )					    	lioes = [ 0 ] * n					  
  int maxLen = 0 ;					      	  maxLen = 0						    	max_len = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      lioes.append ( 1 )				    	    lioes [ i ] = 1					  
  i ++ ) lioes [ i ] = 1 ;				      	  i = 1							    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      	  for i in range ( n ) :				    	    for j in range ( i ) :				  
  i < n ;						      	      for j in range ( i ) :				    		if arr [ i ] > arr [ j ] and ( arr [ i ] + arr [  
  i ++ ) for ( int j = 0 ;				      		  if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr  		    lioes [ i ] = lioes [ j ] + 1		  
  j < i ;						      		      lioes [ i ] = lioes [ j ] + 1		    	for i in range ( n ) :					  
  j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j  	  for i in range ( n ) :				    	    if max_len < lioes [ i ] :				  
  for ( int i = 0 ;					      	      if maxLen < lioes [ i ] :				    		max_len = lioes [ i ]				  
  i < n ;						      		  maxLen = lioes [ i ]				    	return max_len						  
  i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ;   	  return maxLen						    								  
  return maxLen ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2	      LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2	    LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2		  LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2
--							      --							    --								  --
static int longLenSub ( int [ ] arr , int n ) {		      def longLenSub ( arr , n ) :				    def long_len_sub ( arr , n ) :				  script_not_found : None
  HashMap < Integer , Integer > um = new HashMap < Integer ,  	  um = defaultdict ( lambda : 0 )			    	um = { }						  
  int longLen = 0 ;					      	  longLen = 0						    	long_len = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      len1 = 0						    	    len = 0						  
  i ++ ) {						      	      if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] -  	    if arr [ i ] - 1 in um and len < um [ arr [ i ] - 1 ] 
    int len = 0 ;					      		  len1 = um [ arr [ i ] - 1 ]			    		len = um [ arr [ i ] - 1 ]			  
    if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get 	      if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] +  	    if arr [ i ] + 1 in um and len < um [ arr [ i ] + 1 ] 
    if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get 		  len1 = um [ arr [ i ] + 1 ]			    		len = um [ arr [ i ] + 1 ]			  
    um . put ( arr [ i ] , len + 1 ) ;			      	      um [ arr [ i ] ] = len1 + 1			    	    um [ arr [ i ] ] = len + 1				  
    if ( longLen < um . get ( arr [ i ] ) ) longLen = um . ge 	      if longLen < um [ arr [ i ] ] :			    	    if long_len < um [ arr [ i ] ] :			  
  }							      		  longLen = um [ arr [ i ] ]			    		long_len = um [ arr [ i ] ]			  
  return longLen ;					      	  return longLen					    	return long_len						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1      COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1	    COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1	  COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1
--							      --							    --								  --
static int countP ( int n , int k ) {			      def countP ( n , k ) :					    def count_p ( n , k ) :					  failure : #Results: 6, 10
  int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ;	      	  dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n  	dp = np.zeros ( ( n + 1 , k + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( n + 1 ) :				    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      dp [ i ] [ 0 ] = 0				    	    dp [ i ] [ 0 ] = 0					  
  i ++ ) dp [ i ] [ 0 ] = 0 ;				      	  for i in range ( k + 1 ) :				    	for i in range ( 0 , k + 1 ) :				  
  for ( int i = 0 ;					      	      dp [ 0 ] [ k ] = 0				    	    dp [ 0 ] [ k ] = 0					  
  i <= k ;						      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i ++ ) dp [ 0 ] [ k ] = 0 ;				      	      for j in range ( 1 , k + 1 ) :			    	    for j in range ( 1 , k + 1 ) :			  
  for ( int i = 1 ;					      		  if ( j == 1 or i == j ) :			    		if j == 1 or i == j :				  
  i <= n ;						      		      dp [ i ] [ j ] = 1			    		    dp [ i ] [ j ] = 1				  
  i ++ ) for ( int j = 1 ;				      		  else :					    		else :						  
  j <= k ;						      		      dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + d 		    dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp  
  j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ;	      	  return dp [ n ] [ k ]					    	return dp [ n ] [ k ]					  
  else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] 								    								  
  return dp [ n ] [ k ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SERIES_LARGEST_GCD_SUM_EQUALS_N				      SERIES_LARGEST_GCD_SUM_EQUALS_N				    SERIES_LARGEST_GCD_SUM_EQUALS_N				  SERIES_LARGEST_GCD_SUM_EQUALS_N
--							      --							    --								  --
static void print_sequence ( int n , int k ) {		      def print_sequence ( n , k ) :				    def print_sequence ( n , k ) :				  script_not_found : None
  int b = n / ( k * ( k + 1 ) / 2 ) ;			      	  b = int ( n / ( k * ( k + 1 ) / 2 ) )			    	b = n // ( k * ( k + 1 ) // 2 )				  
  if ( b == 0 ) {					      	  if b == 0 :						    	if b == 0 :						  
    System . out . println ( "-1" ) ;			      	      print ( "-1" )					    	    print ( "-1" )					  
  }							      	  else :						    	else :							  
  else {						      	      r = 1						    	    r = 1						  
    int r = 1 ;						      	      x = 1						    	    for x in range ( 1 , n + 1 ) :			  
    for ( int x = 1 ;					      	      while x ** 2 <= n :				    		if n % x != 0 :					  
    x * x <= n ;					      		  if n % x != 0 :				    		    continue					  
    x ++ ) {						      		      continue					    		if x <= b and x > r :				  
      if ( n % x != 0 ) continue ;			      		  elif x <= b and x > r :			    		    r = x					  
      if ( x <= b && x > r ) r = x ;			      		      r = x					    		if n // x <= b and n // x > r :			  
      if ( n / x <= b && n / x > r ) r = n / x ;	      		  elif n / x <= b and n / x > r :		    		    r = n // x					  
    }							      		      r = n / x					    	    for i in range ( 1 , k ) :				  
    for ( int i = 1 ;					      		  x = x + 1					    		print ( r * i , end = " " )			  
    i < k ;						      	      i = 1						    	    res = n - ( r * ( k * ( k - 1 ) // 2 ) )		  
    i ++ ) System . out . print ( r * i + " " ) ;	      	      while i < k :					    	    print ( res )					  
    int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ;	      		  print ( r * i , end = " " )			    								  
    System . out . println ( res ) ;			      		  i = i + 1					    								  
  }							      	      last_term = n - ( r * ( k * ( k - 1 ) / 2 ) )	    								  
}							      	      print ( last_term )				    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE		      FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE		    FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE		  FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE
--							      --							    --								  --
static int maxHamming ( int arr [ ] , int n ) {		      def maxHamming ( arr , n ) :				    def max_hamming ( arr , n ) :				  failure : #Results: 5, 10
  int brr [ ] = new int [ 2 * n + 1 ] ;			      	  brr = [ 0 ] * ( 2 * n + 1 )				    	brr = [ 0 ] * ( 2 * n + 1 )				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      brr [ i ] = arr [ i ]				    	    brr [ i ] = arr [ i ]				  
  i ++ ) brr [ i ] = arr [ i ] ;			      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      brr [ n + i ] = arr [ i ]				    	    brr [ n + i ] = arr [ i ]				  
  i < n ;						      	  maxHam = 0						    	max_ham = 0						  
  i ++ ) brr [ n + i ] = arr [ i ] ;			      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  int maxHam = 0 ;					      	      currHam = 0					    	    curr_ham = 0					  
  for ( int i = 1 ;					      	      k = 0						    	    for j , k in enumerate ( ( i , n ) ) :		  
  i < n ;						      	      for j in range ( i , i + n ) :			    		if brr [ j ] != arr [ k ] :			  
  i ++ ) {						      		  if brr [ j ] != arr [ k ] :			    		    curr_ham += 1				  
    int currHam = 0 ;					      		      currHam += 1				    	    if curr_ham == n :					  
    for ( int j = i , k = 0 ;				      		      k = k + 1					    		return n					  
    j < ( i + n ) ;					      	      if currHam == n :					    	    max_ham = max ( max_ham , curr_ham )		  
    j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ;  		  return n					    	return max_ham						  
    if ( currHam == n ) return n ;			      	      maxHam = max ( maxHam , currHam )			    								  
    maxHam = Math . max ( maxHam , currHam ) ;		      	  return maxHam						    								  
  }							      								    								  
  return maxHam ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S		      LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S		    LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S		  LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S
--							      --							    --								  --
int findSubArray ( int arr [ ] , int n ) {		      def findSubArray ( arr , n ) :				    def find_subarray ( arr , n ) :				  success : None
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  int maxsize = - 1 , startindex = 0 ;			      	  maxsize = - 1						    	maxsize , startindex = - 1 , 0				  
  int endindex = 0 ;					      	  for i in range ( 0 , n - 1 ) :			    	endindex = 0						  
  for ( int i = 0 ;					      	      sum = - 1 if ( arr [ i ] == 0 ) else 1		    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      for j in range ( i + 1 , n ) :			    	    sum = ( - 1 if arr [ i ] == 0 else 1 )		  
  i ++ ) {						      		  sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else su 	    for j in range ( i + 1 , n ) :			  
    sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;		      		  if ( sum == 0 and maxsize < j - i + 1 ) :	    		if arr [ j ] == 0 :				  
    for ( int j = i + 1 ;				      		      maxsize = j - i + 1			    		    sum += - 1					  
    j < n ;						      		      startindex = i				    		else :						  
    j ++ ) {						      	  if ( maxsize == - 1 ) :				    		    sum += 1					  
      if ( arr [ j ] == 0 ) sum += - 1 ;		      	      print ( "No such subarray" )			    		if sum == 0 and maxsize < j - i + 1 :		  
      else sum += 1 ;					      	  else :						    		    maxsize = j - i + 1				  
      if ( sum == 0 && maxsize < j - i + 1 ) {		      	      print ( startindex , "to" , startindex + maxsize - 1  		    startindex = i				  
	maxsize = j - i + 1 ;				      	  return maxsize					    	endindex = startindex + maxsize - 1			  
	startindex = i ;				      								    	if maxsize == - 1 :					  
      }							      								    	    print ( "No such subarray" )			  
    }							      								    	else :							  
  }							      								    	    print ( "%d to %d" % ( startindex , endindex ) )	  
  endindex = startindex + maxsize - 1 ;			      								    	return maxsize						  
  if ( maxsize == - 1 ) System . out . println ( "No such sub 								    								  
  else System . out . println ( startindex + " to " + endinde 								    								  
  return maxsize ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS	      CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS	    CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS	  CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS
--							      --							    --								  --
static boolean HalfDiagonalSums ( int mat [ ] [ ] , int n ) { def HalfDiagonalSums ( mat , n ) :			    def HalfDiagonalSums ( mat , n ) :				  failure : #Results: 9, 10
  int diag1_left = 0 , diag1_right = 0 ;		      	  diag1_left = 0					    	diag1_left , diag1_right = 0 , 0			  
  int diag2_left = 0 , diag2_right = 0 ;		      	  diag1_right = 0					    	diag2_left , diag2_right = 0 , 0			  
  for ( int i = 0 , j = n - 1 ;				      	  diag2_left = 0					    	for i , j in zip ( range ( n - 1 , n ) , range ( n - 1 ,  
  i < n ;						      	  diag2_right = 0					    	    if i < n // 2 :					  
  i ++ , j -- ) {					      	  i = 0							    		diag1_left += mat [ i ] [ i ]			  
    if ( i < n / 2 ) {					      	  j = n - 1						    		diag2_left += mat [ j ] [ i ]			  
      diag1_left += mat [ i ] [ i ] ;			      	  while i < n :						    	    elif i > n // 2 :					  
      diag2_left += mat [ j ] [ i ] ;			      	      if ( i < n // 2 ) :				    		diag1_right += mat [ i ] [ i ]			  
    }							      		  diag1_left += mat [ i ] [ i ]			    		diag2_right += mat [ j ] [ i ]			  
    else if ( i > n / 2 ) {				      		  diag2_left += mat [ j ] [ i ]			    	return ( diag1_left == diag2_right and diag2_right == dia 
      diag1_right += mat [ i ] [ i ] ;			      	      elif ( i > n // 2 ) :				    								  
      diag2_right += mat [ j ] [ i ] ;			      		  diag1_right += mat [ i ] [ i ]		    								  
    }							      		  diag2_right += mat [ j ] [ i ]		    								  
  }							      	      i += 1						    								  
  return ( diag1_left == diag2_right && diag2_right == diag2_ 	      j -= 1						    								  
}							      	  return ( diag1_left == diag2_right and diag2_right == dia 								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK	      CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK		    CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK		  CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK
--							      --							    --								  --
static boolean checkSorted ( int n ) {			      def checkSorted ( n , q ) :				    def check_sorted ( n ) :					  script_not_found : None
  Stack < Integer > st = new Stack < Integer > ( ) ;	      	  st = [ ]						    	st = [ ]						  
  int expected = 1 ;					      	  expected = 1						    	expected = 1						  
  int fnt ;						      	  fnt = None						    	fnt = None						  
  while ( q . size ( ) != 0 ) {				      	  while ( not q.empty ( ) ) :				    	while len ( q ) != 0 :					  
    fnt = q . peek ( ) ;				      	      fnt = q.queue [ 0 ]				    	    fnt = q [ - 1 ]					  
    q . poll ( ) ;					      	      q.get ( )						    	    q.pop ( )						  
    if ( fnt == expected ) expected ++ ;		      	      if ( fnt == expected ) :				    	    if fnt == expected :				  
    else {						      		  expected += 1					    		expected += 1					  
      if ( st . size ( ) == 0 ) {			      	      else :						    	    else :						  
	st . push ( fnt ) ;				      		  if ( len ( st ) == 0 ) :			    		if len ( st ) == 0 :				  
      }							      		      st.append ( fnt )				    		    st.append ( fnt )				  
      else if ( st . size ( ) != 0 && st . peek ( ) < fnt ) { 		  elif ( len ( st ) != 0 and st [ - 1 ] < fnt ) :   		elif len ( st ) != 0 and st [ - 1 ] < fnt :	  
	return false ;					      		      return False				    		    return False				  
      }							      		  else :					    		else :						  
      else st . push ( fnt ) ;				      		      st.append ( fnt )				    		    st.append ( fnt )				  
    }							      	      while ( len ( st ) != 0 and st [ - 1 ] == expected )  	    while len ( st ) != 0 and st [ - 1 ] == expected :	  
    while ( st . size ( ) != 0 && st . peek ( ) == expected ) 		  st.pop ( )					    		st.pop ( )					  
      st . pop ( ) ;					      		  expected += 1					    		expected += 1					  
      expected ++ ;					      	  if ( expected - 1 == n and len ( st ) == 0 ) :	    	if expected - 1 == n and len ( st ) == 0 :		  
    }							      	      return True					    	    return True						  
  }							      	  return False						    	return False						  
  if ( expected - 1 == n && st . size ( ) == 0 ) return true  								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX		      REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX		    REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX		  REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX
--							      --							    --								  --
static int minRemovalsDP ( int arr [ ] , int n ) {	      def minRemovalsDP ( arr , n ) :				    def min_removals_dp ( arr , n ) :				  failure : #Results: 0, 10
  int longest_start = - 1 , longest_end = 0 ;		      	  longest_start = - 1					    	longest_start , longest_end = - 1 , 0			  
  for ( int start = 0 ;					      	  longest_end = 0					    	for start in range ( n ) :				  
  start < n ;						      	  for start in range ( n ) :				    	    min , max = sys.maxsize , sys.maxsize		  
  start ++ ) {						      	      min = sys.maxsize					    	    for end in range ( start , n ) :			  
    int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE 	      max = - sys.maxsize				    		val = arr [ end ]				  
    for ( int end = start ;				      	      for end in range ( start , n ) :			    		if val < min :					  
    end < n ;						      		  val = arr [ end ]				    		    min = val					  
    end ++ ) {						      		  if ( val < min ) :				    		if val > max :					  
      int val = arr [ end ] ;				      		      min = val					    		    max = val					  
      if ( val < min ) {				      		  if ( val > max ) :				    		if 2 * min <= max :				  
	min = val ;					      		      max = val					    		    break					  
      }							      		  if ( 2 * min <= max ) :			    		if end - start > longest_end - longest_start or l 
      if ( val > max ) {				      		      break					    		    longest_start = start			  
	max = val ;					      		  if ( end - start > longest_end - longest_start or 		    longest_end = end				  
      }							      		      longest_start = start			    	if longest_start == - 1 :				  
      if ( 2 * min <= max ) {				      		      longest_end = end				    	    return n						  
	break ;						      	  if ( longest_start == - 1 ) :				    	return ( n - ( longest_end - longest_start + 1 ) )	  
      }							      	      return n						    								  
      if ( end - start > longest_end - longest_start || longe 	  return ( n - ( longest_end - longest_start + 1 ) )	    								  
	longest_start = start ;				      								    								  
	longest_end = end ;				      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  if ( longest_start == - 1 ) {				      								    								  
    return n ;						      								    								  
  }							      								    								  
  return ( n - ( longest_end - longest_start + 1 ) ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2		      FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2		    FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2			  FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2
--							      --							    --								  --
static void findTriplets ( int arr [ ] , int n ) {	      def findTriplets ( arr , n ) :				    def find_triplets ( arr , n ) :				  success : None
  boolean found = false ;				      	  found = False						    	found = False						  
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n - 1 ) :			    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      l = i + 1						    	    l = i + 1						  
  i ++ ) {						      	      r = n - 1						    	    r = n - 1						  
    int l = i + 1 ;					      	      x = arr [ i ]					    	    x = arr [ i ]					  
    int r = n - 1 ;					      	      while ( l < r ) :					    	    while l < r :					  
    int x = arr [ i ] ;					      		  if ( x + arr [ l ] + arr [ r ] == 0 ) :	    		if x + arr [ l ] + arr [ r ] == 0 :		  
    while ( l < r ) {					      		      print ( x , arr [ l ] , arr [ r ] )	    		    print ( x , end = ' ' )			  
      if ( x + arr [ l ] + arr [ r ] == 0 ) {		      		      l += 1					    		    print ( arr [ l ] , end = ' ' )		  
	System . out . print ( x + " " ) ;		      		      r -= 1					    		    print ( arr [ r ] , end = ' ' )		  
	System . out . print ( arr [ l ] + " " ) ;	      		      found = True				    		    l += 1					  
	System . out . println ( arr [ r ] + " " ) ;	      		  elif ( x + arr [ l ] + arr [ r ] < 0 ) :	    		    r -= 1					  
	l ++ ;						      		      l += 1					    		    found = True				  
	r -- ;						      		  else :					    		elif x + arr [ l ] + arr [ r ] < 0 :		  
	found = true ;					      		      r -= 1					    		    l += 1					  
      }							      	  if ( found == False ) :				    		else :						  
      else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ;	      	      print ( " No Triplet Found" )			    		    r -= 1					  
      else r -- ;					      								    	if found == False :					  
    }							      								    	    print ( ' No Triplet Found' )			  
  }							      								    								  
  if ( found == false ) System . out . println ( " No Triplet 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_COMMON_SUPERSEQUENCE_1				      SHORTEST_COMMON_SUPERSEQUENCE_1				    SHORTEST_COMMON_SUPERSEQUENCE_1				  SHORTEST_COMMON_SUPERSEQUENCE_1
--							      --							    --								  --
static int superSeq ( String X , String Y , int m , int n ) { def superSeq ( X , Y , m , n ) :				    def superSeq ( X , Y , m , n ) :				  script_not_found : None
  int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;	      	  dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ]	    	dp = np.zeros ( ( m + 1 , n + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( m + 1 ) :				    	for i in range ( 0 , m + 1 ) :				  
  i <= m ;						      	      for j in range ( n + 1 ) :			    	    for j in range ( 0 , n + 1 ) :			  
  i ++ ) {						      		  if ( not i ) : dp [ i ] [ j ] = j		    		if i == 0 :					  
    for ( int j = 0 ;					      		  elif ( not j ) : dp [ i ] [ j ] = i		    		    dp [ i ] [ j ] = j				  
    j <= n ;						      		  elif ( X [ i - 1 ] == Y [ j - 1 ] ) :		    		elif j == 0 :					  
    j ++ ) {						      		      dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]   		    dp [ i ] [ j ] = i				  
      if ( i == 0 ) dp [ i ] [ j ] = j ;		      		  else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [  		elif X [ i - 1 ] == Y [ j - 1 ] :		  
      else if ( j == 0 ) dp [ i ] [ j ] = i ;		      	  return dp [ m ] [ n ]					    		    dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]	  
      else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 )  								    		else :						  
      else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j 								    		    dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] 
    }							      								    	return dp [ m ] [ n ]					  
  }							      								    								  
  return dp [ m ] [ n ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_K_MODULUS_ARRAY_ELEMENT				      FINDING_K_MODULUS_ARRAY_ELEMENT				    FINDING_K_MODULUS_ARRAY_ELEMENT				  FINDING_K_MODULUS_ARRAY_ELEMENT
--							      --							    --								  --
static void printEqualModNumbers ( int arr [ ] , int n ) {    def printEqualModNumbers ( arr , n ) :			    def print_equal_mod_numbers ( arr , n ) :			  script_not_found : None
  Arrays . sort ( arr ) ;				      	  arr.sort ( )						    	arr.sort ( )						  
  int d = arr [ n - 1 ] - arr [ 0 ] ;			      	  d = arr [ n - 1 ] - arr [ 0 ]				    	d = arr [ n - 1 ] - arr [ 0 ]				  
  Vector < Integer > v = new Vector < > ( ) ;		      	  v = [ ]						    	v = [ ]							  
  for ( int i = 1 ;					      	  i = 1							    	for i in range ( 1 , n + 1 ) :				  
  i * i <= d ;						      	  while ( i * i <= d ) :				    	    if d % i == 0 :					  
  i ++ ) {						      	      if ( d % i == 0 ) :				    		v.append ( i )					  
    if ( d % i == 0 ) {					      		  v.append ( i )				    		if i != d // i :				  
      v . add ( i ) ;					      		  if ( i != d / i ) :				    		    v.append ( d // i )				  
      if ( i != d / i ) v . add ( d / i ) ;		      		      v.append ( d / i )			    	for i in range ( len ( v ) ) :				  
    }							      	      i += 1						    	    temp = arr [ 0 ] % v [ i ]				  
  }							      	  for i in range ( len ( v ) ) :			    	    j = 0						  
  for ( int i = 0 ;					      	      temp = arr [ 0 ] % v [ i ]			    	    for j in range ( 1 , n ) :				  
  i < v . size ( ) ;					      	      j = 1						    		if arr [ j ] % v [ i ] != temp :		  
  i ++ ) {						      	      while ( j < n ) :					    		    break					  
    int temp = arr [ 0 ] % v . get ( i ) ;		      		  if ( arr [ j ] % v [ i ] != temp ) :		    	    if j == n :						  
    int j ;						      		      break					    		print ( v [ i ] , end = ' ' )			  
    for ( j = 1 ;					      		  j += 1					    								  
    j < n ;						      	      if ( j == n ) :					    								  
    j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ;   		  print ( v [ i ] , end = " " )			    								  
    if ( j == n ) System . out . print ( v . get ( i ) + " "  								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMMON_CHARACTERS_N_STRINGS				      COMMON_CHARACTERS_N_STRINGS				    COMMON_CHARACTERS_N_STRINGS					  COMMON_CHARACTERS_N_STRINGS
--							      --							    --								  --
public static void commonCharacters ( String str [ ] , int n  def commonCharacters ( strings , n ) :			    def common_characters ( str , n ) :				  script_not_found : None
  Boolean [ ] prim = new Boolean [ MAX_CHAR ] ;		      	  prim = [ True ] * MAX_CHAR				    	prim = [ True ] * MAX_CHAR				  
  Arrays . fill ( prim , new Boolean ( true ) ) ;	      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      sec = [ False ] * MAX_CHAR			    	    sec = [ False ] * MAX_CHAR				  
  i < n ;						      	      for j in range ( len ( strings [ i ] ) ) :	    	    for c in str [ i ] :				  
  i ++ ) {						      		  if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( ' 		if prim [ c ] - 'a' in c :			  
    Boolean [ ] sec = new Boolean [ MAX_CHAR ] ;	      		      sec [ ord ( strings [ i ] [ j ] ) - ord ( 'a' 		    sec [ c ] = True				  
    Arrays . fill ( sec , new Boolean ( false ) ) ;	      	      for i in range ( MAX_CHAR ) :			    	    prim [ i ] = sec [ i ]				  
    for ( int j = 0 ;					      		  prim [ i ] = sec [ i ]			    	for i in range ( 26 ) :					  
    j < str [ i ] . length ( ) ;			      	  for i in range ( 26 ) :				    	    if prim [ i ] :					  
    j ++ ) {						      	      if ( prim [ i ] ) :				    		print ( chr ( i + 97 ) , end = ' ' )		  
      if ( prim [ str [ i ] . charAt ( j ) - 'a' ] ) sec [ st 		  print ( "%c " % ( i + ord ( 'a' ) ) , end = "" )  								  
    }							      								    								  
    System . arraycopy ( sec , 0 , prim , 0 , MAX_CHAR ) ;    								    								  
  }							      								    								  
  for ( int i = 0 ;					      								    								  
  i < 26 ;						      								    								  
  i ++ ) if ( prim [ i ] ) {				      								    								  
    System . out . print ( Character . toChars ( i + 97 ) ) ; 								    								  
    System . out . print ( " " ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K		      COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K		    COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K			  COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K
--							      --							    --								  --
static int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int  def numOfIncSubseqOfSizeK ( arr , n , k ) :		    def nb_inc_subseq_of_size_k ( arr , n , k ) :		  script_not_found : None
  int dp [ ] [ ] = new int [ k ] [ n ] , sum = 0 ;	      	  dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ]  	dp , sum = [ [ 1 ] * k for i in range ( n ) ] , 0	  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for l in range ( 1 , k ) :				  
  i < n ;						      	      dp [ 0 ] [ i ] = 1				    	    for i in range ( l , n ) :				  
  i ++ ) {						      	  for l in range ( 1 , k ) :				    		dp [ l ] [ i ] = 0				  
    dp [ 0 ] [ i ] = 1 ;				      	      for i in range ( l , n ) :			    		for j in range ( l - 1 , i ) :			  
  }							      		  dp [ l ] [ i ] = 0				    		    if arr [ j ] < arr [ i ] :			  
  for ( int l = 1 ;					      		  for j in range ( l - 1 , i ) :		    			dp [ l ] [ i ] += dp [ l - 1 ] [ j ]	  
  l < k ;						      		      if ( arr [ j ] < arr [ i ] ) :		    	for i in range ( k - 1 , n ) :				  
  l ++ ) {						      			  dp [ l ] [ i ] += dp [ l - 1 ] [ j ]	    	    sum += dp [ k - 1 ] [ i ]				  
    for ( int i = l ;					      	  Sum = 0						    	return sum						  
    i < n ;						      	  for i in range ( k - 1 , n ) :			    								  
    i ++ ) {						      	      Sum += dp [ k - 1 ] [ i ]				    								  
      dp [ l ] [ i ] = 0 ;				      	  return Sum						    								  
      for ( int j = l - 1 ;				      								    								  
      j < i ;						      								    								  
      j ++ ) {						      								    								  
	if ( arr [ j ] < arr [ i ] ) {			      								    								  
	  dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ;	      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  for ( int i = k - 1 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    sum += dp [ k - 1 ] [ i ] ;				      								    								  
  }							      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED		      LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED		    LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED			  LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED
--							      --							    --								  --
static int longestNull ( String str ) {			      def longestNull ( S ) :					    def longest_none ( str ) :					  failure : #Results: 9, 10
  ArrayList < Pair > arr = new ArrayList < > ( ) ;	      	  arr = [ ]						    	arr = [ ( '@' , - 1 ) ]					  
  arr . add ( new Pair ( '@' , - 1 ) ) ;		      	  arr.append ( [ '@' , - 1 ] )				    	maxlen = 0						  
  int maxlen = 0 ;					      	  maxlen = 0						    	for i , c in enumerate ( str ) :			  
  for ( int i = 0 ;					      	  for i in range ( len ( S ) ) :			    	    arr.append ( ( c , i ) )				  
  i < str . length ( ) ;				      	      arr.append ( [ S [ i ] , i ] )			    	    while len ( arr ) >= 3 and arr [ - 3 ] [ 0 ] == '1' a 
  ++ i ) {						      	      while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ]  		arr.pop ( )					  
    arr . add ( new Pair ( str . charAt ( i ) , i ) ) ;	      		  arr.pop ( )					    		arr.pop ( )					  
    while ( arr . size ( ) >= 3 && arr . get ( arr . size ( ) 		  arr.pop ( )					    	    tmp = arr [ - 1 ] [ 1 ]				  
      arr . remove ( arr . size ( ) - 3 ) ;		      		  arr.pop ( )					    	    maxlen = max ( maxlen , i - tmp )			  
      arr . remove ( arr . size ( ) - 2 ) ;		      	      tmp = arr [ - 1 ]					    	return maxlen						  
      arr . remove ( arr . size ( ) - 1 ) ;		      	      maxlen = max ( maxlen , i - tmp [ 1 ] )		    								  
    }							      	  return maxlen						    								  
    int tmp = arr . get ( arr . size ( ) - 1 ) . second ;     								    								  
    maxlen = Math . max ( maxlen , i - tmp ) ;		      								    								  
  }							      								    								  
  return maxlen ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1	      DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1		    DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1		  DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1
--							      --							    --								  --
static int knapSack ( int W , int wt [ ] , int val [ ] , int  def knapSack ( W , wt , val , n ) :			    def knapSack ( W , wt , val , n ) :				  script_not_found : None
  int i , w ;						      	  K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 	global K						  
  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;		      	  for i in range ( n + 1 ) :				    	K = np.zeros ( ( n + 1 , W + 1 ) )			  
  for ( i = 0 ;						      	      for w in range ( W + 1 ) :			    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      		  if i == 0 or w == 0 :				    	    for w in range ( 0 , W + 1 ) :			  
  i ++ ) {						      		      K [ i ] [ w ] = 0				    		if i == 0 or w == 0 :				  
    for ( w = 0 ;					      		  elif wt [ i - 1 ] <= w :			    		    K [ i ] [ w ] = 0				  
    w <= W ;						      		      K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 		elif wt [ i - 1 ] <= w :			  
    w ++ ) {						      		  else :					    		    K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 
      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;	      		      K [ i ] [ w ] = K [ i - 1 ] [ w ]		    		else :						  
      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 	  return K [ n ] [ W ]					    		    K [ i ] [ w ] = K [ i - 1 ] [ w ]		  
      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		      								    	return K [ n ] [ W ]					  
    }							      								    								  
  }							      								    								  
  return K [ n ] [ W ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN
--							      --							    --								  --
static int findMaximum ( int arr [ ] , int low , int high ) { def findMaximum ( arr , low , high ) :			    def find_maximum ( arr , low , high ) :			  script_not_found : None
  if ( low == high ) return arr [ low ] ;		      	  if low == high :					    	if low == high :					  
  if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) r 	      return arr [ low ]				    	    return arr [ low ]					  
  if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) re 	  if high == low + 1 and arr [ low ] >= arr [ high ] :	    	if ( high == low + 1 ) and arr [ low ] >= arr [ high ] :  
  int mid = ( low + high ) / 2 ;			      	      return arr [ low ]				    	    return arr [ low ]					  
  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ m 	  if high == low + 1 and arr [ low ] < arr [ high ] :	    	if ( high == low + 1 ) and arr [ low ] < arr [ high ] :	  
  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ m 	      return arr [ high ]				    	    return arr [ high ]					  
  else return findMaximum ( arr , mid + 1 , high ) ;	      	  mid = ( low + high ) // 2				    	mid = ( low + high ) // 2				  
}							      	  if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [  	if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [  
							      	      return arr [ mid ]				    	    return arr [ mid ]					  
							      	  if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [  	if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [  
							      	      return findMaximum ( arr , low , mid - 1 )	    	    return find_maximum ( arr , low , mid - 1 )		  
							      	  else :						    	else :							  
							      	      return findMaximum ( arr , mid + 1 , high )	    	    return find_maximum ( arr , mid + 1 , high )	  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS			      SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS			    SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS				  SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS
--							      --							    --								  --
static void diagonalsquare ( int mat [ ] [ ] , int row , int  def diagonalsquare ( mat , row , column ) :		    def diagonalsquare ( mat , row , column ) :			  success : None
  System . out . print ( "Diagonal one : " ) ;		      	  print ( "Diagonal one : " , end = "" )		    	print ( "Diagonal one : " , end = " " )			  
  for ( int i = 0 ;					      	  for i in range ( 0 , row ) :				    	for i in range ( row ) :				  
  i < row ;						      	      for j in range ( 0 , column ) :			    	    for j in range ( column ) :				  
  i ++ ) {						      		  if ( i == j ) :				    		if i == j :					  
    for ( int j = 0 ;					      		      print ( "{} ".format ( mat [ i ] [ j ] * mat  		    print ( "%d " % ( mat [ i ] [ j ] * mat [ i ] 
    j < column ;					      	  print ( " \n\nDiagonal two : " , end = "" )		    	print ( )						  
    j ++ ) if ( i == j ) System . out . print ( mat [ i ] [ j 	  for i in range ( 0 , row ) :				    	print ( "Diagonal two : " , end = " " )			  
  }							      	      for j in range ( 0 , column ) :			    	for i in range ( row ) :				  
  System . out . println ( ) ;				      		  if ( i + j == column - 1 ) :			    	    for j in range ( column ) :				  
  System . out . print ( "Diagonal two : " ) ;		      		      print ( "{} ".format ( mat [ i ] [ j ] * mat  		if i + j == column - 1 :			  
  for ( int i = 0 ;					      								    		    print ( "%d " % ( mat [ i ] [ j ] * mat [ i ] 
  i < row ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j < column ;					      								    								  
    j ++ ) if ( i + j == column - 1 ) System . out . print (  								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR
--							      --							    --								  --
static void bitonicGenerator ( int arr [ ] , int n ) {	      def bitonicGenerator ( arr , n ) :			    def bitonicGenerator ( arr , n ) :				  script_not_found : None
  int i = 1 ;						      	  i = 1							    	i = 1							  
  int j = n - 1 ;					      	  j = n - 1						    	j = n - 1						  
  if ( j % 2 != 0 ) j -- ;				      	  if ( j % 2 != 0 ) :					    	if j % 2 :						  
  while ( i < j ) {					      	      j = j - 1						    	    j -= 1						  
    arr = swap ( arr , i , j ) ;			      	  while ( i < j ) :					    	while i < j :						  
    i += 2 ;						      	      arr [ j ] , arr [ i ] = arr [ i ] , arr [ j ]	    	    arr = arr [ i : j ]					  
    j -= 2 ;						      	      i = i + 2						    	    i += 2						  
  }							      	      j = j - 2						    	    j -= 2						  
  Arrays . sort ( arr , 0 , ( n + 1 ) / 2 ) ;		      	  arr_f = [ ]						    	arr.sort ( )						  
  Arrays . sort ( arr , ( n + 1 ) / 2 , n ) ;		      	  arr_s = [ ]						    	arr.sort ( )						  
  int low = ( n + 1 ) / 2 , high = n - 1 ;		      	  for i in range ( int ( ( n + 1 ) / 2 ) ) :		    	low , high = ( n + 1 ) // 2 , n - 1			  
  while ( low < high ) {				      	      arr_f.append ( arr [ i ] )			    	while low < high :					  
    Integer temp = arr [ low ] ;			      	  i = int ( ( n + 1 ) / 2 )				    	    temp = arr [ low ]					  
    arr [ low ] = arr [ high ] ;			      	  while ( i < n ) :					    	    arr [ low ] = arr [ high ]				  
    arr [ high ] = temp ;				      	      arr_s.append ( arr [ i ] )			    	    arr [ high ] = temp					  
    low ++ ;						      	      i = i + 1						    	    low += 1						  
    high -- ;						      	  arr_f.sort ( )					    	    high -= 1						  
  }							      	  arr_s.sort ( reverse = True )				    								  
}							      	  for i in arr_s :					    								  
							      	      arr_f.append ( i )				    								  
							      	  return arr_f						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2	      MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2	    MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2	  MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2
--							      --							    --								  --
static int minJumps ( int arr [ ] , int n ) {		      def minJumps ( arr , n ) :				    def min_jumps ( arr , n ) :					  error : Traceback (most recent call last):   File
  int [ ] jumps = new int [ n ] ;			      	  jumps = [ 0 for i in range ( n ) ]			    	jumps = [ 0 ] * n					  "dump/transcoder_st/eval/java_python/online_st/206
  int min ;						      	  for i in range ( n - 2 , - 1 , - 1 ) :		    	min = 0							  68770/eval_scripts/java_sa-python_sa.test/MINIMUM_
  jumps [ n - 1 ] = 0 ;					      	      if ( arr [ i ] == 0 ) :				    	jumps [ n - 1 ] = 0					  NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2.py
  for ( int i = n - 2 ;					      		  jumps [ i ] = float ( 'inf' )			    	for i in range ( n - 2 , - 1 , - 1 ) :			  ", line 73, in <module>     if f_filled(*parameter
  i >= 0 ;						      	      elif ( arr [ i ] >= n - i - 1 ) :			    	    if arr [ i ] == 0 :					  s_set) == f_gold(*parameters_set):   File "dump/tr
  i -- ) {						      		  jumps [ i ] = 1				    		jumps [ i ] = sys.maxsize			  anscoder_st/eval/java_python/online_st/20668770/ev
    if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MAX_VALUE ; 	      else :						    	    elif arr [ i ] >= n - i - 1 :			  al_scripts/java_sa-python_sa.test/MINIMUM_NUMBER_O
    else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ;      		  min = float ( 'inf' )				    		jumps [ i ] = 1					  F_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2.py", line
    else {						      		  for j in range ( i + 1 , n ) :		    	    else :						  48, in f_filled     for j in range ( i + 1 , n and
      min = Integer . MAX_VALUE ;			      		      if ( j <= arr [ i ] + i ) :		    		min = sys.maxsize				   j <= arr [ i ] + i + 1 ) : UnboundLocalError: loc
      for ( int j = i + 1 ;				      			  if ( min > jumps [ j ] ) :		    		for j in range ( i + 1 , n and j <= arr [ i ] + i al variable 'j' referenced before assignment
      j < n && j <= arr [ i ] + i ;			      			      min = jumps [ j ]			    		    if min > jumps [ j ] :			  
      j ++ ) {						      		  if ( min != float ( 'inf' ) ) :		    			min = jumps [ j ]			  
	if ( min > jumps [ j ] ) min = jumps [ j ] ;	      		      jumps [ i ] = min + 1			    		if min != sys.maxsize :				  
      }							      		  else :					    		    jumps [ i ] = min + 1			  
      if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 		      jumps [ i ] = min				    		else :						  
      else jumps [ i ] = min ;				      	  return jumps [ 0 ]					    		    jumps [ i ] = min				  
    }							      								    	return jumps [ 0 ]					  
  }							      								    								  
  return jumps [ 0 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_MAXIMUM_GCD_ARRAY				      FIND_PAIR_MAXIMUM_GCD_ARRAY				    FIND_PAIR_MAXIMUM_GCD_ARRAY					  FIND_PAIR_MAXIMUM_GCD_ARRAY
--							      --							    --								  --
public static int findMaxGCD ( int arr [ ] , int n ) {	      def findMaxGCD ( arr , n ) :				    def find_max_gcd ( arr , n ) :				  script_not_found : None
  int high = 0 ;					      	  high = 0						    	high = 0						  
  for ( int i = 0 ;					      	  i = 0							    	for i in range ( n ) :					  
  i < n ;						      	  while i < n :						    	    high = max ( high , arr [ i ] )			  
  i ++ ) high = Math . max ( high , arr [ i ] ) ;	      	      high = max ( high , arr [ i ] )			    	divisors = [ 0 ] * ( high + 1 )				  
  int divisors [ ] = new int [ high + 1 ] ;		      	      i = i + 1						    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	  divisors = [ 0 ] * ( high + 1 )			    	    for j in range ( 1 , math.sqrt ( arr [ i ] ) + 1 ) :  
  i < n ;						      	  i = 0							    		if arr [ i ] % j == 0 :				  
  i ++ ) {						      	  while i < n :						    		    divisors [ j ] += 1				  
    for ( int j = 1 ;					      	      j = 1						    		    if j != arr [ i ] // j :			  
    j <= Math . sqrt ( arr [ i ] ) ;			      	      while j <= math.sqrt ( arr [ i ] ) :		    			divisors [ arr [ i ] // j ] += 1	  
    j ++ ) {						      		  if ( arr [ i ] % j == 0 ) :			    	for i in range ( high , 1 , - 1 ) :			  
      if ( arr [ i ] % j == 0 ) {			      		      divisors [ j ] = divisors [ j ] + 1	    	    if divisors [ i ] > 1 :				  
	divisors [ j ] ++ ;				      		      if ( j != arr [ i ] / j ) :		    		return i					  
	if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ]  			  divisors [ arr [ i ] / j ] = divisors [ a 	return 1						  
      }							      			      + 1				    								  
    }							      		  j = j + 1					    								  
  }							      	      i = i + 1						    								  
  for ( int i = high ;					      	  i = high						    								  
  i >= 1 ;						      	  while i >= 1 :					    								  
  i -- ) if ( divisors [ i ] > 1 ) return i ;		      	      if ( divisors [ i ] > 1 ) :			    								  
  return 1 ;						      		  return i					    								  
}							      	      i = i - 1						    								  
							      	  return 1						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GRAPHS_CYCLE_ODD_LENGTH				      CHECK_GRAPHS_CYCLE_ODD_LENGTH				    CHECK_GRAPHS_CYCLE_ODD_LENGTH				  CHECK_GRAPHS_CYCLE_ODD_LENGTH
--							      --							    --								  --
public static boolean containsOdd ( int G [ ] [ ] , int src ) def containsOdd ( G , src ) :				    def contains_odd ( G , src ) :				  script_not_found : None
  int colorArr [ ] = new int [ V ] ;			      	  global V						    	color_arr = [ - 1 for i in range ( V ) ]		  
  for ( int i = 0 ;					      	  colorArr = [ - 1 ] * V				    	color_arr [ src ] = 1					  
  i < V ;						      	  colorArr [ src ] = 1					    	q = [ src ]						  
  ++ i ) colorArr [ i ] = - 1 ;				      	  q = queue.Queue ( )					    	while not q :						  
  colorArr [ src ] = 1 ;				      	  q.put ( src )						    	    u = q [ 0 ]						  
  LinkedList < Integer > q = new LinkedList < Integer > ( ) ; 	  while ( not q.empty ( ) ) :				    	    q.pop ( 0 )						  
  q . add ( src ) ;					      	      u = q.get ( )					    	    if G [ u ] [ u ] == 1 :				  
  while ( ! q . isEmpty ( ) ) {				      	      if ( G [ u ] [ u ] == 1 ) :			    		return True					  
    int u = q . peek ( ) ;				      		  return True					    	    for v in range ( V ) :				  
    q . pop ( ) ;					      	      for v in range ( V ) :				    		if G [ u ] [ v ] == 1 and color_arr [ v ] == - 1  
    if ( G [ u ] [ u ] == 1 ) return true ;		      		  if ( G [ u ] [ v ] and colorArr [ v ] == - 1 ) :  		    color_arr [ v ] = 1 - color_arr [ u ]	  
    for ( int v = 0 ;					      		      colorArr [ v ] = 1 - colorArr [ u ]	    		    q.append ( v )				  
    v < V ;						      		      q.put ( v )				    		elif G [ u ] [ v ] == 1 and color_arr [ v ] == co 
    ++ v ) {						      		  elif ( G [ u ] [ v ] and colorArr [ v ] == colorA 		    return True					  
      if ( G [ u ] [ v ] == 1 && colorArr [ v ] == - 1 ) {    		      return True				    	return False						  
	colorArr [ v ] = 1 - colorArr [ u ] ;		      	  return False						    								  
	q . push ( v ) ;				      								    								  
      }							      								    								  
      else if ( G [ u ] [ v ] == 1 && colorArr [ v ] == color 								    								  
    }							      								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME		      CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME		    CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME		  CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME
--							      --							    --								  --
static String constructPalin ( char [ ] str , int len ) {     def constructPalin ( string , l ) :			    def construct_palin ( str , len_ ) :			  error : Traceback (most recent call last):   File
  int i = 0 , j = len - 1 ;				      	  string = list ( string )				    	i , j = 0 , len_ - 1					  "dump/transcoder_st/eval/java_python/online_st/206
  for ( ;						      	  i = - 1						    	for i , j in enumerate ( str ) :			  68770/eval_scripts/java_sa-python_sa.test/CONSTRUC
  i < j ;						      	  j = l							    	    if str [ i ] == str [ j ] and str [ i ] != '*' :	  T_LEXICOGRAPHICALLY_SMALLEST_PALINDROME.py", line
  i ++ , j -- ) {					      	  while i < j :						    		continue					  76, in <module>     if f_filled(*parameters_set) =
    if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continu 	      i += 1						    	    elif str [ i ] == str [ j ] and str [ i ] == '*' :	  = f_gold(*parameters_set):   File "dump/transcoder
    else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) {  	      j -= 1						    		str [ i ] = 'a'					  _st/eval/java_python/online_st/20668770/eval_scrip
      str [ i ] = 'a' ;					      	      if ( string [ i ] == string [ j ] and string [ i ] != 		str [ j ] = 'a'					  ts/java_sa-python_sa.test/CONSTRUCT_LEXICOGRAPHICA
      str [ j ] = 'a' ;					      		  continue					    		continue					  LLY_SMALLEST_PALINDROME.py", line 44, in f_filled
      continue ;					      	      elif ( string [ i ] == string [ j ] and string [ i ]  	    elif str [ i ] == '*' :				      if str [ i ] == str [ j ] and str [ i ] != '*'
    }							      		  string [ i ] = 'a'				    		str [ i ] = str [ j ]				   : TypeError: list indices must be integers or sli
    else if ( str [ i ] == '*' ) {			      		  string [ j ] = 'a'				    		continue					  ces, not str
      str [ i ] = str [ j ] ;				      		  continue					    	    elif str [ j ] == '*' :				  
      continue ;					      	      elif string [ i ] == '*' :			    		str [ j ] = str [ i ]				  
    }							      		  string [ i ] = string [ j ]			    		continue					  
    else if ( str [ j ] == '*' ) {			      		  continue					    	    print ( 'Not Possible' )				  
      str [ j ] = str [ i ] ;				      	      elif string [ j ] == '*' :			    	    return ''						  
      continue ;					      		  string [ j ] = string [ i ]			    	return str						  
    }							      		  continue					    								  
    System . out . println ( "Not Possible" ) ;		      	      print ( "Not Possible" )				    								  
    return "" ;						      	      return ""						    								  
  }							      	  return ''.join ( string )				    								  
  return String . valueOf ( str ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B	      DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B	    DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B	  DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B
--							      --							    --								  --
static int discreteLogarithm ( int a , int b , int m ) {      def discreteLogarithm ( a , b , m ) :			    def discrete_log10 ( a , b , m ) :				  script_not_found : None
  int n = ( int ) ( Math . sqrt ( m ) + 1 ) ;		      	  n = int ( math.sqrt ( m ) + 1 )			    	n = int ( math.sqrt ( m ) + 1 )				  
  int an = 1 ;						      	  an = 1						    	an = 1							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      an = ( an * a ) % m				    	    an = ( an * a ) % m					  
  ++ i ) an = ( an * a ) % m ;				      	  value = [ 0 ] * m					    	value = [ 0 ] * m					  
  int [ ] value = new int [ m ] ;			      	  cur = an						    	for i , cur in enumerate ( range ( 1 , an + n + 1 ) ) :	  
  for ( int i = 1 , cur = an ;				      	  for i in range ( 1 , n + 1 ) :			    	    if not value [ cur ] :				  
  i <= n ;						      	      if ( value [ cur ] == 0 ) :			    		value [ cur ] = i				  
  ++ i ) {						      		  value [ cur ] = i				    	    cur = ( cur * an ) % m				  
    if ( value [ cur ] == 0 ) value [ cur ] = i ;	      	      cur = ( cur * an ) % m				    	for i , cur in enumerate ( range ( 0 , b + n + 1 ) ) :	  
    cur = ( cur * an ) % m ;				      	  cur = b						    	    if value [ cur ] :					  
  }							      	  for i in range ( n + 1 ) :				    		ans = value [ cur ] * n - i			  
  for ( int i = 0 , cur = b ;				      	      if ( value [ cur ] > 0 ) :			    		if ans < m :					  
  i <= n ;						      		  ans = value [ cur ] * n - i			    		    return ans					  
  ++ i ) {						      		  if ( ans < m ) :				    	    cur = ( cur * a ) % m				  
    if ( value [ cur ] > 0 ) {				      		      return ans				    	return - 1						  
      int ans = value [ cur ] * n - i ;			      	      cur = ( cur * a ) % m				    								  
      if ( ans < m ) return ans ;			      	  return - 1						    								  
    }							      								    								  
    cur = ( cur * a ) % m ;				      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR
--							      --							    --								  --
static void bitonicGenerator ( int arr [ ] , int n ) {	      def bitonicGenerator ( arr , n ) :			    def bitonic_generator ( arr , n ) :				  failure : #Results: 0, 10
  Vector < Integer > evenArr = new Vector < Integer > ( ) ;   	  evenArr = [ ]						    	even_arr = [ ]						  
  Vector < Integer > oddArr = new Vector < Integer > ( ) ;    	  oddArr = [ ]						    	odds_arr = [ ]						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( ( i % 2 ) == 0 ) :				    	    if i % 2 != 1 :					  
  i ++ ) {						      		  evenArr.append ( arr [ i ] )			    		even_arr.append ( arr [ i ] )			  
    if ( i % 2 != 1 ) {					      	      else :						    	    else :						  
      evenArr . add ( arr [ i ] ) ;			      		  oddArr.append ( arr [ i ] )			    		odds_arr.append ( arr [ i ] )			  
    }							      	  evenArr = sorted ( evenArr )				    	even_arr.sort ( )					  
    else {						      	  oddArr = sorted ( oddArr )				    	odds_arr.sort ( reverse = True )			  
      oddArr . add ( arr [ i ] ) ;			      	  oddArr = oddArr [ : : - 1 ]				    	i = 0							  
    }							      	  i = 0							    	for j in even_arr :					  
  }							      	  for j in range ( len ( evenArr ) ) :			    	    arr [ i ] += 1					  
  Collections . sort ( evenArr ) ;			      	      arr [ i ] = evenArr [ j ]				    	for j in odds_arr :					  
  Collections . sort ( oddArr , Collections . reverseOrder (  	      i += 1						    	    arr [ i ] += 1					  
  int i = 0 ;						      	  for j in range ( len ( oddArr ) ) :			    								  
  for ( int j = 0 ;					      	      arr [ i ] = oddArr [ j ]				    								  
  j < evenArr . size ( ) ;				      	      i += 1						    								  
  j ++ ) {						      								    								  
    arr [ i ++ ] = evenArr . get ( j ) ;		      								    								  
  }							      								    								  
  for ( int j = 0 ;					      								    								  
  j < oddArr . size ( ) ;				      								    								  
  j ++ ) {						      								    								  
    arr [ i ++ ] = oddArr . get ( j ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7			      CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7			    CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7			  CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7
--							      --							    --								  --
static boolean isDivisible7 ( String num ) {		      def isdivisible7 ( num ) :				    def is_divisible7 ( num ) :					  script_not_found : None
  int n = num . length ( ) ;				      	  n = len ( num )					    	n = len ( num )						  
  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;    	  if ( n == 0 and num [ 0 ] == '\n' ) :			    	if n == 0 and num [ 0 ] == '0' :			  
  if ( n % 3 == 1 ) num = "00" + num ;			      	      return 1						    	    return True						  
  if ( n % 3 == 2 ) num = "0" + num ;			      	  if ( n % 3 == 1 ) :					    	if n % 3 == 1 :						  
  n = num . length ( ) ;				      	      num = str ( num ) + "00"				    	    num = '00' + num					  
  int gSum = 0 , p = 1 ;				      	      n += 2						    	if n % 3 == 2 :						  
  for ( int i = n - 1 ;					      	  elif ( n % 3 == 2 ) :					    	    num = '0' + num					  
  i >= 0 ;						      	      num = str ( num ) + "0"				    	n = len ( num )						  
  i -- ) {						      	      n += 1						    	g_sum , p = 0 , 1					  
    int group = 0 ;					      	  GSum = 0						    	for i in range ( n - 1 , - 1 , - 1 ) :			  
    group += num . charAt ( i -- ) - '0' ;		      	  p = 1							    	    group = 0						  
    group += ( num . charAt ( i -- ) - '0' ) * 10 ;	      	  for i in range ( n - 1 , - 1 , - 1 ) :		    	    group += num [ i ] - '0'				  
    group += ( num . charAt ( i ) - '0' ) * 100 ;	      	      group = 0						    	    group += ( num [ i ] - '0' ) * 10			  
    gSum = gSum + group * p ;				      	      group += ord ( num [ i ] ) - ord ( '0' )		    	    group += ( num [ i ] - '0' ) * 100			  
    p = p * - 1 ;					      	      i -= 1						    	    g_sum = g_sum + group * p				  
  }							      	      group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10	    	    p = p * - 1						  
  return ( gSum % 7 == 0 ) ;				      	      i -= 1						    	return ( g_sum % 7 == 0 )				  
}							      	      group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100    								  
							      	      GSum = GSum + group * p				    								  
							      	      p *= ( - 1 )					    								  
							      	  return ( GSum % 7 == 0 )				    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE    MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE    MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE	  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE
--							      --							    --								  --
static int maxSumWO3Consec ( int arr [ ] , int n ) {	      def maxSumWO3Consec ( arr , n ) :				    def max_sum_wo3_consec ( arr , n ) :			  success : None
  int sum [ ] = new int [ n ] ;				      	  sum = [ 0 for k in range ( n ) ]			    	sum = [ 0 ] * n						  
  if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ;			      	  if n >= 1 :						    	if n >= 1 :						  
  if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ;	      	      sum [ 0 ] = arr [ 0 ]				    	    sum [ 0 ] = arr [ 0 ]				  
  if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . ma 	  if n >= 2 :						    	if n >= 2 :						  
  for ( int i = 3 ;					      	      sum [ 1 ] = arr [ 0 ] + arr [ 1 ]			    	    sum [ 1 ] = arr [ 0 ] + arr [ 1 ]			  
  i < n ;						      	  if n > 2 :						    	if n > 2 :						  
  i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ]  	      sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 	    sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 
  return sum [ n - 1 ] ;				      	  for i in range ( 3 , n ) :				    	for i in range ( 3 , n ) :				  
}							      	      sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] 	    sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] 
							      	  return sum [ n - 1 ]					    	return sum [ n - 1 ]					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1		      CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1		    CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1		  CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1
--							      --							    --								  --
static boolean checkReverse ( int arr [ ] , int n ) {	      def checkReverse ( arr , n ) :				    def check_reverse ( arr , n ) :				  error : Traceback (most recent call last):   File
  if ( n == 1 ) {					      	  if ( n == 1 ) :					    	if n == 1 :						  "dump/transcoder_st/eval/java_python/online_st/206
    return true ;					      	      return True					    	    return True						  68770/eval_scripts/java_sa-python_sa.test/CHECK_RE
  }							      	  i = 1							    	i = 0							  VERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1.py", line 82
  int i ;						      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , arr [ i - 1 ] + 1 , n ) :		  , in <module>	    if f_filled(*parameters_set) ==
  for ( i = 1 ;						      	      if arr [ i - 1 ] < arr [ i ] :			    	    if i == n :						  f_gold(*parameters_set):   File "dump/transcoder_s
  arr [ i - 1 ] < arr [ i ] && i < n ;			      		  if ( i == n ) :				    		return True					  t/eval/java_python/online_st/20668770/eval_scripts
  i ++ ) ;						      		      return True				    	    j = i						  /java_sa-python_sa.test/CHECK_REVERSING_SUB_ARRAY_
  if ( i == n ) {					      	  j = i							    	    i += 1						  MAKE_ARRAY_SORTED_1.py", line 51, in f_filled
    return true ;					      	  while ( arr [ j ] < arr [ j - 1 ] ) :			    	    while arr [ j ] < arr [ j - 1 ] :			  while arr [ j ] < arr [ j - 1 ] : IndexError: list
  }							      	      if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :	    		if i > 1 and arr [ j ] < arr [ i - 2 ] :	   index out of range
  int j = i ++ ;					      		  return False					    		    return False				  
  while ( arr [ j ] < arr [ j - 1 ] ) {			      	      j += 1						    		j += 1						  
    if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) {		      	  if ( j == n ) :					    	    if j == n :						  
      return false ;					      	      return True					    		return True					  
    }							      	  k = j							    	    k = j						  
    j ++ ;						      	  if ( arr [ k ] < arr [ i - 1 ] ) :			    	    if arr [ k ] < arr [ i - 1 ] :			  
  }							      	      return False					    		return False					  
  if ( j == n ) {					      	  while ( k > 1 and k < n ) :				    	    while k > 1 and k < n :				  
    return true ;					      	      if ( arr [ k ] < arr [ k - 1 ] ) :		    		if arr [ k ] < arr [ k - 1 ] :			  
  }							      		  return False					    		    return False				  
  int k = j ;						      	      k += 1						    		k += 1						  
  if ( arr [ k ] < arr [ i - 1 ] ) {			      	  return True						    	return True						  
    return false ;					      								    								  
  }							      								    								  
  while ( k > 1 && k < n ) {				      								    								  
    if ( arr [ k ] < arr [ k - 1 ] ) {			      								    								  
      return false ;					      								    								  
    }							      								    								  
    k ++ ;						      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_DIVISIBILITY_LARGE_NUMBER_999			      CHECK_DIVISIBILITY_LARGE_NUMBER_999			    CHECK_DIVISIBILITY_LARGE_NUMBER_999				  CHECK_DIVISIBILITY_LARGE_NUMBER_999
--							      --							    --								  --
static boolean isDivisible999 ( String num ) {		      def isDivisible999 ( num ) :				    def is_divisible_999 ( num ) :				  script_not_found : None
  int n = num . length ( ) ;				      	  n = len ( num ) ;					    	n = len ( num )						  
  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;    	  if ( n == 0 or num [ 0 ] == '0' ) :			    	if n == 0 and num [ 0 ] == '0' :			  
  if ( n % 3 == 1 ) num = "00" + num ;			      	      return true					    	    return True						  
  if ( n % 3 == 2 ) num = "0" + num ;			      	  if ( ( n % 3 ) == 1 ) :				    	if n % 3 == 1 :						  
  int gSum = 0 ;					      	      num = "00" + num					    	    num = '00' + num					  
  for ( int i = 0 ;					      	  if ( ( n % 3 ) == 2 ) :				    	if n % 3 == 2 :						  
  i < n ;						      	      num = "0" + num					    	    num = '0' + num					  
  i ++ ) {						      	  gSum = 0						    	g_sum = 0						  
    int group = 0 ;					      	  for i in range ( 0 , n , 3 ) :			    	for i in range ( n ) :					  
    group += ( num . charAt ( i ++ ) - '0' ) * 100 ;	      	      group = 0						    	    group = 0						  
    group += ( num . charAt ( i ++ ) - '0' ) * 10 ;	      	      group += ( ord ( num [ i ] ) - 48 ) * 100		    	    group += ( num [ i ] - '0' ) * 100			  
    group += num . charAt ( i ) - '0' ;			      	      group += ( ord ( num [ i + 1 ] ) - 48 ) * 10	    	    group += ( num [ i ] - '0' ) * 10			  
    gSum += group ;					      	      group += ( ord ( num [ i + 2 ] ) - 48 )		    	    group += num [ i ] - '0'				  
  }							      	      gSum += group					    	    g_sum += group					  
  if ( gSum > 1000 ) {					      	  if ( gSum > 1000 ) :					    	if g_sum > 1000 :					  
    num = Integer . toString ( gSum ) ;			      	      num = str ( gSum )				    	    num = str ( g_sum )					  
    n = num . length ( ) ;				      	      n = len ( num )					    	    n = len ( num )					  
    gSum = isDivisible999 ( num ) ? 1 : 0 ;		      	      gSum = isDivisible999 ( num )			    	    g_sum = 1 if is_divisible_999 ( num ) else 0	  
  }							      	  return ( gSum == 999 )				    	return ( g_sum == 999 )					  
  return ( gSum == 999 ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_ GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_ GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_ GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_
--							      --							    --								  --
void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n def printClosest ( ar1 , ar2 , m , n , x ) :		    def print_closer ( ar1 , ar2 , m , n , x ) :		  script_not_found : None
  int diff = Integer . MAX_VALUE ;			      	  diff = sys.maxsize					    	diff = sys.maxsize					  
  int res_l = 0 , res_r = 0 ;				      	  l = 0							    	res_l , res_r = 0 , 0					  
  int l = 0 , r = n - 1 ;				      	  r = n - 1						    	l , r = 0 , n - 1					  
  while ( l < m && r >= 0 ) {				      	  while ( l < m and r >= 0 ) :				    	while l < m and r >= 0 :				  
    if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) {  	      if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff :	    	    if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff :	  
      res_l = l ;					      		  res_l = l					    		res_l = l					  
      res_r = r ;					      		  res_r = r					    		res_r = r					  
      diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ;	      		  diff = abs ( ar1 [ l ] + ar2 [ r ] - x )	    		diff = abs ( ar1 [ l ] + ar2 [ r ] - x )	  
    }							      	      if ar1 [ l ] + ar2 [ r ] > x :			    	    if ar1 [ l ] + ar2 [ r ] > x :			  
    if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ;		      		  r = r - 1					    		r -= 1						  
    else l ++ ;						      	      else :						    	    else :						  
  }							      		  l = l + 1					    		l += 1						  
  System . out . print ( "The closest pair is [" + ar1 [ res_ 	  print ( "The closest pair is [" , ar1 [ res_l ] , "," , a 	sys.stdout.write ( "The closest pair is [%d, %d]\n" % ( a 
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS	      CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS	    CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS		  CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS
--							      --							    --								  --
public static boolean check ( String s ) {		      def check ( s ) :						    def check ( s ) :						  error : Traceback (most recent call last):   File
  if ( s . length ( ) >= 10 ) return true ;		      	  if ( len ( s ) >= 10 ) :				    	if len ( s ) >= 10 :					  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int i = 1 ;					      	      return True					    	    return True						  68770/eval_scripts/java_sa-python_sa.test/CHECK_GI
  i < s . length ( ) ;					      	  for i in range ( 1 , len ( s ) ) :			    	for i in range ( 1 , len ( s ) ) :			  VEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS.py", li
  i ++ ) {						      	      for j in range ( i + 1 , len ( s ) ) :		    	    for j in range ( i + 1 , len ( s ) ) :		  ne 66, in <module>	 if f_filled(*parameters_set
    for ( int j = i + 1 ;				      		  for k in range ( j + 1 , len ( s ) ) :	    		for k in range ( j + 1 , len ( s ) ) :		  ) == f_gold(*parameters_set):	  File "dump/transco
    j < s . length ( ) ;				      		      s1 = s [ 0 : i ]				    		    s1 , s2 , s3 , s4 = '' , '' , '' , ''	  der_st/eval/java_python/online_st/20668770/eval_sc
    j ++ ) {						      		      s2 = s [ i : j - i ]			    		    try :					  ripts/java_sa-python_sa.test/CHECK_GIVEN_STRING_CA
      for ( int k = j + 1 ;				      		      s3 = s [ j : k - j ]			    			s1 = s [ : i ]				  N_SPLIT_FOUR_DISTINCT_STRINGS.py", line 46, in f_f
      k < s . length ( ) ;				      		      s4 = s [ k : len ( s ) - k ]		    			s2 = s [ i : j - i ]			  illed	    if strf_filled ( s1 , s2 ) and strf_fill
      k ++ ) {						      		      if ( s1 != s2 and s1 != s3 and s1 != s4 and s 			s3 = s [ j : k - j ]			  ed ( s1 , s3 ) and strf_filled ( s1 , s4 ) and str
	String s1 = "" , s2 = "" , s3 = "" , s4 = "" ;	      			  return True				    			s4 = s [ k : - k ]			  f_filled ( s2 , s3 ) and strf_filled ( s2 , s4 ) a
	try {						      	  return False						    		    except IndexError :				  nd strf_filled ( s3 , s4 ) : NameError: name 'strf
	  s1 = s . substring ( 0 , i ) ;		      								    			pass					  _filled' is not defined
	  s2 = s . substring ( i , j - i ) ;		      								    		    if strcheck ( s1 , s2 ) and strcheck ( s1 , s 
	  s3 = s . substring ( j , k - j ) ;		      								    			return True				  
	  s4 = s . substring ( k , s . length ( ) - k ) ;     								    	return False						  
	}						      								    								  
	catch ( StringIndexOutOfBoundsException e ) {	      								    								  
	}						      								    								  
	if ( strcheck ( s1 , s2 ) && strcheck ( s1 , s3 ) &&  								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_ FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_ FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_ FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_
--							      --							    --								  --
static int maxSubsequenceSubstring ( char x [ ] , char y [ ]  def maxSubsequenceSubstring ( x , y , n , m ) :		    def max_subsequence_substring ( x , y , n , m ) :		  script_not_found : None
  int dp [ ] [ ] = new int [ MAX ] [ MAX ] ;		      	  dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX  	dp = np.zeros ( ( MAX , MAX ) )				  
  for ( int i = 0 ;					      	  for i in range ( 1 , m + 1 ) :			    	for i in range ( 0 , m + 1 ) :				  
  i <= m ;						      	      for j in range ( 1 , n + 1 ) :			    	    for j in range ( 0 , n + 1 ) :			  
  i ++ ) for ( int j = 0 ;				      		  if ( x [ j - 1 ] == y [ i - 1 ] ) :		    		dp [ i ] [ j ] = 0				  
  j <= n ;						      		      dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]   	for i in range ( 1 , m + 1 ) :				  
  j ++ ) dp [ i ] [ j ] = 0 ;				      		  else :					    	    for j in range ( 1 , n + 1 ) :			  
  for ( int i = 1 ;					      		      dp [ i ] [ j ] = dp [ i ] [ j - 1 ]	    		if x [ j - 1 ] == y [ i - 1 ] :			  
  i <= m ;						      	  ans = 0						    		    dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]	  
  i ++ ) {						      	  for i in range ( 1 , m + 1 ) :			    		else :						  
    for ( int j = 1 ;					      	      ans = max ( ans , dp [ i ] [ n ] )		    		    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]		  
    j <= n ;						      	  return ans						    	ans = 0							  
    j ++ ) {						      								    	for i in range ( 1 , m + 1 ) :				  
      if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 +  								    	    ans = max ( ans , dp [ i ] [ n ] )			  
      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;	      								    	return ans						  
    }							      								    								  
  }							      								    								  
  int ans = 0 ;						      								    								  
  for ( int i = 1 ;					      								    								  
  i <= m ;						      								    								  
  i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ;	      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COCKTAIL_SORT						      COCKTAIL_SORT						    COCKTAIL_SORT						  COCKTAIL_SORT
--							      --							    --								  --
void cocktailSort ( int a [ ] ) {			      def cocktailSort ( a ) :					    def cocktail_sort ( a ) :					  script_not_found : None
  boolean swapped = true ;				      	  n = len ( a )						    	swapped = True						  
  int start = 0 ;					      	  swapped = True					    	start = 0						  
  int end = a . length ;				      	  start = 0						    	end = len ( a )						  
  while ( swapped == true ) {				      	  end = n - 1						    	while swapped == True :					  
    swapped = false ;					      	  while ( swapped == True ) :				    	    swapped = False					  
    for ( int i = start ;				      	      swapped = False					    	    for i in range ( start , end - 1 ) :		  
    i < end - 1 ;					      	      for i in range ( start , end ) :			    		if a [ i ] > a [ i + 1 ] :			  
    ++ i ) {						      		  if ( a [ i ] > a [ i + 1 ] ) :		    		    temp = a [ i ]				  
      if ( a [ i ] > a [ i + 1 ] ) {			      		      a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] 		    a [ i ] = a [ i + 1 ]			  
	int temp = a [ i ] ;				      		      swapped = True				    		    a [ i + 1 ] = temp				  
	a [ i ] = a [ i + 1 ] ;				      	      if ( swapped == False ) :				    		    swapped = True				  
	a [ i + 1 ] = temp ;				      		  break						    	    if swapped == False :				  
	swapped = true ;				      	      swapped = False					    		break						  
      }							      	      end = end - 1					    	    swapped = False					  
    }							      	      for i in range ( end - 1 , start - 1 , - 1 ) :	    	    end = end - 1					  
    if ( swapped == false ) break ;			      		  if ( a [ i ] > a [ i + 1 ] ) :		    	    for i in range ( end - 1 , start , - 1 ) :		  
    swapped = false ;					      		      a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] 		if a [ i ] > a [ i + 1 ] :			  
    end = end - 1 ;					      		      swapped = True				    		    temp = a [ i ]				  
    for ( int i = end - 1 ;				      	      start = start + 1					    		    a [ i ] = a [ i + 1 ]			  
    i >= start ;					      								    		    a [ i + 1 ] = temp				  
    i -- ) {						      								    		    swapped = True				  
      if ( a [ i ] > a [ i + 1 ] ) {			      								    	    start = start + 1					  
	int temp = a [ i ] ;				      								    								  
	a [ i ] = a [ i + 1 ] ;				      								    								  
	a [ i + 1 ] = temp ;				      								    								  
	swapped = true ;				      								    								  
      }							      								    								  
    }							      								    								  
    start = start + 1 ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT
--							      --							    --								  --
static boolean checkDivisibility ( String num ) {	      def checkDivisibility ( num ) :				    def check_divisibility ( num ) :				  error : Traceback (most recent call last):   File
  int length = num . length ( ) ;			      	  length = len ( num )					    	length = len ( num )					  "dump/transcoder_st/eval/java_python/online_st/206
  if ( length == 1 && num . charAt ( 0 ) == '0' ) return true 	  if ( length == 1 and num [ 0 ] == '0' ) :		    	if length == 1 and num [ 0 ] == '0' :			  68770/eval_scripts/java_sa-python_sa.test/CHECK_LA
  if ( length % 3 == 1 ) {				      	      return True					    	    return True						  RGE_NUMBER_DIVISIBLE_13_NOT.py", line 79, in <modu
    num += "00" ;					      	  if ( length % 3 == 1 ) :				    	if length % 3 == 1 :					  le>	  if f_filled(*parameters_set) == f_gold(*pa
    length += 2 ;					      	      num = str ( num ) + "00"				    	    num += '00'						  rameters_set):   File "dump/transcoder_st/eval/jav
  }							      	      length += 2					    	    length += 2						  a_python/online_st/20668770/eval_scripts/java_sa-p
  else if ( length % 3 == 2 ) {				      	  elif ( length % 3 == 2 ) :				    	elif length % 3 == 2 :					  ython_sa.test/CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT.
    num += "0" ;					      	      num = str ( num ) + "0"				    	    num += '0'						  py", line 55, in f_filled	group += num [ i ] -
    length += 1 ;					      	      length += 1					    	    length += 1						   '0' TypeError: unsupported operand type(s) for -:
  }							      	  sum = 0						    	sum , p = 0 , 1						   'str' and 'str'
  int sum = 0 , p = 1 ;					      	  p = 1							    	for i in range ( length - 1 , - 1 , - 1 ) :		  
  for ( int i = length - 1 ;				      	  for i in range ( length - 1 , - 1 , - 1 ) :		    	    group = 0						  
  i >= 0 ;						      	      group = 0						    	    group += num [ i ] - '0'				  
  i -- ) {						      	      group += ord ( num [ i ] ) - ord ( '0' )		    	    group += ( num [ i ] - '0' ) * 10			  
    int group = 0 ;					      	      i -= 1						    	    group += ( num [ i ] - '0' ) * 100			  
    group += num . charAt ( i -- ) - '0' ;		      	      group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10	    	    sum = sum + group * p				  
    group += ( num . charAt ( i -- ) - '0' ) * 10 ;	      	      i -= 1						    	    p *= ( - 1 )					  
    group += ( num . charAt ( i ) - '0' ) * 100 ;	      	      group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100    	sum = abs ( sum )					  
    sum = sum + group * p ;				      	      sum = sum + group * p				    	return ( sum % 13 == 0 )				  
    p *= ( - 1 ) ;					      	      p *= ( - 1 )					    								  
  }							      	  sum = abs ( sum )					    								  
  sum = Math . abs ( sum ) ;				      	  return ( sum % 13 == 0 )				    								  
  return ( sum % 13 == 0 ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_KTH_CHARACTER_OF_DECRYPTED_STRING			      FIND_KTH_CHARACTER_OF_DECRYPTED_STRING			    FIND_KTH_CHARACTER_OF_DECRYPTED_STRING			  FIND_KTH_CHARACTER_OF_DECRYPTED_STRING
--							      --							    --								  --
static char encodedChar ( String str , int k ) {	      def encodedChar ( str , k ) :				    def encoded_char ( str , k ) :				  script_not_found : None
  String expand = "" ;					      	  expand = ""						    	expand = ""						  
  String temp = "" ;					      	  freq = 0						    	temp = ""						  
  int freq = 0 ;					      	  i = 0							    	freq = 0						  
  for ( int i = 0 ;					      	  while ( i < len ( str ) ) :				    	for i in range ( len ( str ) ) :			  
  i < str . length ( ) ;				      	      temp = ""						    	    temp = ""						  
  ) {							      	      freq = 0						    	    freq = 0						  
    temp = "" ;						      	      while ( i < len ( str ) and ord ( str [ i ] ) >= ord  	    while i < len ( str ) and str [ i ] >= 'a' and str [  
    freq = 0 ;						      		  temp += str [ i ]				    		temp += str [ i ]				  
    while ( i < str . length ( ) && str . charAt ( i ) >= 'a' 		  i += 1					    		i += 1						  
      temp += str . charAt ( i ) ;			      	      while ( i < len ( str ) and ord ( str [ i ] ) >= ord  	    while i < len ( str ) and str [ i ] >= '1' and str [  
      i ++ ;						      		  freq = freq * 10 + ord ( str [ i ] ) - ord ( '0'  		freq = freq * 10 + str [ i ] - '0'		  
    }							      		  i += 1					    		i += 1						  
    while ( i < str . length ( ) && str . charAt ( i ) >= '1' 	      for j in range ( 1 , freq + 1 , 1 ) :		    	    for j in range ( 1 , freq + 1 ) :			  
      freq = freq * 10 + str . charAt ( i ) - '0' ;	      		  expand += temp				    		expand += temp					  
      i ++ ;						      	  if ( freq == 0 ) :					    	if not freq :						  
    }							      	      expand += temp					    	    expand += temp					  
    for ( int j = 1 ;					      	  return expand [ k - 1 ]				    	return expand [ k - 1 ]					  
    j <= freq ;						      								    								  
    j ++ ) expand += temp ;				      								    								  
  }							      								    								  
  if ( freq == 0 ) expand += temp ;			      								    								  
  return expand . charAt ( k - 1 ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS		      THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS		    THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS		  THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS
--							      --							    --								  --
static void thirdLargest ( int arr [ ] , int arr_size ) {     def thirdLargest ( arr , arr_size ) :			    def third_largest ( arr , arr_size ) :			  success : None
  if ( arr_size < 3 ) {					      	  if ( arr_size < 3 ) :					    	if arr_size < 3 :					  
    System . out . printf ( " Invalid Input " ) ;	      	      print ( " Invalid Input " )			    	    print ( " Invalid Input " )				  
    return ;						      	      return						    	    return						  
  }							      	  first = arr [ 0 ]					    	first = arr [ 0 ]					  
  int first = arr [ 0 ] ;				      	  for i in range ( 1 , arr_size ) :			    	for i in range ( 1 , arr_size ) :			  
  for ( int i = 1 ;					      	      if ( arr [ i ] > first ) :			    	    if arr [ i ] > first :				  
  i < arr_size ;					      		  first = arr [ i ]				    		first = arr [ i ]				  
  i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ;	      	  second = - sys.maxsize				    	second = int ( 0 )					  
  int second = Integer . MIN_VALUE ;			      	  for i in range ( 0 , arr_size ) :			    	for i in range ( arr_size ) :				  
  for ( int i = 0 ;					      	      if ( arr [ i ] > second and arr [ i ] < first ) :	    	    if arr [ i ] > second and arr [ i ] < first :	  
  i < arr_size ;					      		  second = arr [ i ]				    		second = arr [ i ]				  
  i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) secon 	  third = - sys.maxsize					    	third = int ( 0 )					  
  int third = Integer . MIN_VALUE ;			      	  for i in range ( 0 , arr_size ) :			    	for i in range ( arr_size ) :				  
  for ( int i = 0 ;					      	      if ( arr [ i ] > third and arr [ i ] < second ) :	    	    if arr [ i ] > third and arr [ i ] < second :	  
  i < arr_size ;					      		  third = arr [ i ]				    		third = arr [ i ]				  
  i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third 	  print ( "The Third Largest" , "element is" , third )	    	print ( "The third Largest " "element is %d\n" % third )  
  System . out . printf ( "The third Largest " + "element is  								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEIBNIZ_HARMONIC_TRIANGLE				      LEIBNIZ_HARMONIC_TRIANGLE					    LEIBNIZ_HARMONIC_TRIANGLE					  LEIBNIZ_HARMONIC_TRIANGLE
--							      --							    --								  --
static void LeibnizHarmonicTriangle ( int n ) {		      def LeibnizHarmonicTriangle ( n ) :			    def LeibnizHarmonicTriangle ( n ) :				  script_not_found : None
  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;		      	  C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 	C = np.zeros ( ( n + 1 , n + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( 0 , n + 1 ) :			    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      for j in range ( 0 , min ( i , n ) + 1 ) :	    	    for j in range ( 0 , min ( i , n ) + 1 ) :		  
  i ++ ) {						      		  if ( j == 0 or j == i ) :			    		if j == 0 or j == i :				  
    for ( int j = 0 ;					      		      C [ i ] [ j ] = 1				    		    C [ i ] [ j ] = 1				  
    j <= Math . min ( i , n ) ;				      		  else :					    		else :						  
    j ++ ) {						      		      C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ 		    C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i 
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;	      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	      for j in range ( 1 , i + 1 ) :			    	    for j in range ( 1 , i + 1 ) :			  
    }							      		  print ( "1/" , end = "" )			    		print ( "1/" + str ( i * C [ i - 1 ] [ j - 1 ] )  
  }							      		  print ( i * C [ i - 1 ] [ j - 1 ] , end = " " )   	    print ( )						  
  for ( int i = 1 ;					      	      print ( )						    								  
  i <= n ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 1 ;					      								    								  
    j <= i ;						      								    								  
    j ++ ) System . out . print ( "1/" + i * C [ i - 1 ] [ j  								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE
--							      --							    --								  --
static int minCost ( int a [ ] , int n , int k ) {	      def minCost ( a , n , k ) :				    def min_cost ( a , n , k ) :				  script_not_found : None
  int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ;	      	  dp = [ [ inf for i in range ( k + 1 ) ] for j in range (  	dp = np.zeros ( ( n + 1 , k + 1 ) )			  
  for ( int i = 0 ;					      	  dp [ 0 ] [ 0 ] = 0					    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	  for i in range ( 1 , n + 1 ) :			    	    for j in range ( 0 , k + 1 ) :			  
  i ++ ) for ( int j = 0 ;				      	      for j in range ( 1 , k + 1 ) :			    		dp [ i ] [ j ] = inf				  
  j <= k ;						      		  for m in range ( i - 1 , - 1 , - 1 ) :	    	dp [ 0 ] [ 0 ] = 0					  
  j ++ ) dp [ i ] [ j ] = inf ;				      		      dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [  	for i in range ( 1 , n + 1 ) :				  
  dp [ 0 ] [ 0 ] = 0 ;					      	  return dp [ n ] [ k ]					    	    for j in range ( 1 , k + 1 ) :			  
  for ( int i = 1 ;					      								    		for m in range ( i - 1 , - 1 , - 1 ) :		  
  i <= n ;						      								    		    dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [  
  i ++ ) for ( int j = 1 ;				      								    	return dp [ n ] [ k ]					  
  j <= k ;						      								    								  
  j ++ ) for ( int m = i - 1 ;				      								    								  
  m >= 0 ;						      								    								  
  m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [  								    								  
  return dp [ n ] [ k ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH
--							      --							    --								  --
static int pairsInSortedRotated ( int arr [ ] , int n , int x def pairsInSortedRotated ( arr , n , x ) :		    def pairs_in_sorted_rotated ( arr , n , x ) :		  failure : #Results: 8, 10
  int i ;						      	  for i in range ( n ) :				    	i = 0							  
  for ( i = 0 ;						      	      if arr [ i ] > arr [ i + 1 ] :			    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      		  break						    	    if arr [ i ] > arr [ i + 1 ] :			  
  i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ;	      	  l = ( i + 1 ) % n					    		break						  
  int l = ( i + 1 ) % n ;				      	  r = i							    	l = ( i + 1 ) % n					  
  int r = i ;						      	  cnt = 0						    	r = i							  
  int cnt = 0 ;						      	  while ( l != r ) :					    	cnt = 0							  
  while ( l != r ) {					      	      if arr [ l ] + arr [ r ] == x :			    	while l != r :						  
    if ( arr [ l ] + arr [ r ] == x ) {			      		  cnt += 1					    	    if arr [ l ] + arr [ r ] == x :			  
      cnt ++ ;						      		  if l == ( r - 1 + n ) % n :			    		cnt += 1					  
      if ( l == ( r - 1 + n ) % n ) {			      		      return cnt				    		if l == ( r - 1 + n ) % n :			  
	return cnt ;					      		  l = ( l + 1 ) % n				    		    return cnt					  
      }							      		  r = ( r - 1 + n ) % n				    		l = ( l + 1 ) % n				  
      l = ( l + 1 ) % n ;				      	      elif arr [ l ] + arr [ r ] < x :			    		r = ( r - 1 + n ) % n				  
      r = ( r - 1 + n ) % n ;				      		  l = ( l + 1 ) % n				    	    elif arr [ l ] + arr [ r ] < x :			  
    }							      	      else :						    		l = ( l + 1 ) % n				  
    else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; 		  r = ( n + r - 1 ) % n				    	    else :						  
    else r = ( n + r - 1 ) % n ;			      	  return cnt						    		r = ( n + r - 1 ) % n				  
  }							      								    	return cnt						  
  return cnt ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY			      K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY			    K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY			  K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY
--							      --							    --								  --
static int kthLargestSum ( int arr [ ] , int n , int k ) {    def kthLargestSum ( arr , n , k ) :			    def kth_largest_sum ( arr , n , k ) :			  failure : #Results: 1, 10
  int sum [ ] = new int [ n + 1 ] ;			      	  sum = [ ]						    	sum = [ 0 ] * ( n + 1 )					  
  sum [ 0 ] = 0 ;					      	  sum.append ( 0 )					    	sum [ 0 ] = 0						  
  sum [ 1 ] = arr [ 0 ] ;				      	  sum.append ( arr [ 0 ] )				    	sum [ 1 ] = arr [ 0 ]					  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	      sum.append ( sum [ i - 1 ] + arr [ i - 1 ] )	    	    sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ]		  
  i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ;	      	  Q = [ ]						    	Q = [ ]							  
  PriorityQueue < Integer > Q = new PriorityQueue < Integer > 	  heapq.heapify ( Q )					    	for i in range ( 1 , n + 1 ) :				  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	    for j in range ( i , n + 1 ) :			  
  i <= n ;						      	      for j in range ( i , n + 1 ) :			    		x = sum [ j ] - sum [ i - 1 ]			  
  i ++ ) {						      		  x = sum [ j ] - sum [ i - 1 ]			    		if len ( Q ) < k :				  
    for ( int j = i ;					      		  if len ( Q ) < k :				    		    Q.append ( x )				  
    j <= n ;						      		      heapq.heappush ( Q , x )			    		else :						  
    j ++ ) {						      		  else :					    		    if Q [ - 1 ] < x :				  
      int x = sum [ j ] - sum [ i - 1 ] ;		      		      if Q [ 0 ] < x :				    			Q.append ( x )				  
      if ( Q . size ( ) < k ) Q . add ( x ) ;		      			  heapq.heappop ( Q )			    	return Q [ 0 ]						  
      else {						      			  heapq.heappush ( Q , x )		    								  
	if ( Q . peek ( ) < x ) {			      	  return Q [ 0 ]					    								  
	  Q . poll ( ) ;				      								    								  
	  Q . add ( x ) ;				      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return Q . poll ( ) ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL	      FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL		    FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL		  FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL
--							      --							    --								  --
static int countOps ( int A [ ] [ ] , int B [ ] [ ] , int m , def countOps ( A , B , m , n ) :				    def count_ops ( A , B , m , n ) :				  success : None
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( m ) :				    	    for j in range ( m ) :				  
  i ++ ) for ( int j = 0 ;				      		  A [ i ] [ j ] -= B [ i ] [ j ]		    		A [ i ] [ j ] -= B [ i ] [ j ]			  
  j < m ;						      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ;		      	      for j in range ( 1 , n ) :			    	    for j in range ( 1 , m ) :				  
  for ( int i = 1 ;					      		  if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j  		if A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ]  
  i < n ;						      		      return - 1				    		    return - 1					  
  i ++ ) for ( int j = 1 ;				      	  result = 0						    	result = 0						  
  j < m ;						      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + 	      result += abs ( A [ i ] [ 0 ] )			    	    result += abs ( A [ i ] [ 0 ] )			  
  int result = 0 ;					      	  for j in range ( m ) :				    	for j in range ( m ) :					  
  for ( int i = 0 ;					      	      result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] )	    	    result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] )	  
  i < n ;						      	  return ( result )					    	return ( result )					  
  i ++ ) result += Math . abs ( A [ i ] [ 0 ] ) ;	      								    								  
  for ( int j = 0 ;					      								    								  
  j < m ;						      								    								  
  j ++ ) result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] 								    								  
  return ( result ) ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN			      PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN			    PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN			  PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN
--							      --							    --								  --
static void printPath ( String str ) {			      def printPath ( str ) :					    def print_path ( data ) :					  script_not_found : None
  int i = 0 ;						      	  i = 0							    	i = 0							  
  int curX = 0 , curY = 0 ;				      	  curX = 0						    	cur_x , cur_y = 0 , 0					  
  while ( i < str . length ( ) ) {			      	  curY = 0						    	while i < len ( data ) :				  
    int nextX = ( str . charAt ( i ) - 'A' ) / 5 ;	      	  while ( i < len ( str ) ) :				    	    next_x = ( data [ i ] - 'A' ) // 5			  
    int nextY = ( str . charAt ( i ) - 'B' + 1 ) % 5 ;	      	      nextX = int ( ( ord ( str [ i ] ) - ord ( 'A' ) ) / 5 	    next_y = ( data [ i ] - 'B' + 1 ) % 5		  
    while ( curX > nextX ) {				      	      nextY = ( ord ( str [ i ] ) - ord ( 'B' ) + 1 ) % 5   	    while cur_x > next_x :				  
      System . out . println ( "Move Up" ) ;		      	      while ( curX > nextX ) :				    		print ( 'Move Up' )				  
      curX -- ;						      		  print ( "Move Up" )				    		cur_x -= 1					  
    }							      		  curX -= 1					    	    while cur_y > next_y :				  
    while ( curY > nextY ) {				      	      while ( curY > nextY ) :				    		print ( 'Move Left' )				  
      System . out . println ( "Move Left" ) ;		      		  print ( "Move Left" )				    		cur_y -= 1					  
      curY -- ;						      		  curY -= 1					    	    while cur_x < next_x :				  
    }							      	      while ( curX < nextX ) :				    		print ( 'Move Down' )				  
    while ( curX < nextX ) {				      		  print ( "Move Down" )				    		cur_x += 1					  
      System . out . println ( "Move Down" ) ;		      		  curX += 1					    	    while cur_y < next_y :				  
      curX ++ ;						      	      while ( curY < nextY ) :				    		print ( 'Move Right' )				  
    }							      		  print ( "Move Right" )			    		cur_y += 1					  
    while ( curY < nextY ) {				      		  curY += 1					    	    print ( 'Press OK' )				  
      System . out . println ( "Move Right" ) ;		      	      print ( "Press OK" )				    	    i += 1						  
      curY ++ ;						      	      i += 1						    								  
    }							      								    								  
    System . out . println ( "Press OK" ) ;		      								    								  
    i ++ ;						      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_POSSIBLE_PATH_2D_MATRIX				      CHECK_POSSIBLE_PATH_2D_MATRIX				    CHECK_POSSIBLE_PATH_2D_MATRIX				  CHECK_POSSIBLE_PATH_2D_MATRIX
--							      --							    --								  --
static boolean isPath ( int arr [ ] [ ] ) {		      def isPath ( arr ) :					    def is_path ( arr ) :					  script_not_found : None
  arr [ 0 ] [ 0 ] = 1 ;					      	  arr [ 0 ] [ 0 ] = 1					    	arr [ 0 ] [ 0 ] = 1					  
  for ( int i = 1 ;					      	  for i in range ( 1 , row ) :				    	for i in range ( 1 , 5 ) :				  
  i < 5 ;						      	      if ( arr [ i ] [ 0 ] != - 1 ) :			    	    if arr [ 0 ] [ i ] != - 1 :				  
  i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr  		  arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ]		    		arr [ 0 ] [ i ] = arr [ 0 ] [ i - 1 ]		  
  for ( int j = 1 ;					      	  for j in range ( 1 , col ) :				    	for j in range ( 1 , 5 ) :				  
  j < 5 ;						      	      if ( arr [ 0 ] [ j ] != - 1 ) :			    	    if arr [ j ] [ 0 ] != - 1 :				  
  j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr  		  arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ]		    		arr [ j ] [ 0 ] = arr [ j - 1 ] [ 0 ]		  
  for ( int i = 1 ;					      	  for i in range ( 1 , row ) :				    	for i in range ( 1 , 5 ) :				  
  i < 5 ;						      	      for j in range ( 1 , col ) :			    	    for j in range ( 1 , 5 ) :				  
  i ++ ) for ( int j = 1 ;				      		  if ( arr [ i ] [ j ] != - 1 ) :		    		if arr [ i ] [ j ] != - 1 :			  
  j < 5 ;						      		      arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , 		    arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , 
  j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math 	  return ( arr [ row - 1 ] [ col - 1 ] == 1 )		    	return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 )			  
  return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K	      MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K	    MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K	  MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K
--							      --							    --								  --
static int solve ( char X [ ] , char Y [ ] , int l , int r ,  def solve ( X , Y , l , r , k , dp ) :			    def solve ( X , Y , l , r , k , dp ) :			  error :   File "dump/transcoder_st/eval/java_pytho
  if ( k == 0 ) {					      	  if k == 0 :						    	if k == 0 :						  n/online_st/20668770/eval_scripts/java_sa-python_s
    return 0 ;						      	      return 0						    	    return 0						  a.test/MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENC
  }							      	  if l < 0 or r < 0 :					    	if l < 0 or r < 0 :					  E_LENGTH_K.py", line 37     return dp [ l ] [ r ]
  if ( l < 0 | r < 0 ) {				      	      return 1000000000					    	    return int ( 1e9 )					  [ k ] = min ( min ( cost + f_filled ( X , Y , l -
    return ( int ) 1e9 ;				      	  if dp [ l ] [ r ] [ k ] != - 1 :			    	if dp [ l ] [ r ] [ k ] != - 1 :			  1 , r - 1 , k - 1 , dp ) , f_filled ( X , Y , l -
  }							      	      return dp [ l ] [ r ] [ k ]			    	    return dp [ l ] [ r ] [ k ]				  1 , r , k , dp ) ) , f_filled ( X , Y , l , r - 1
  if ( dp [ l ] [ r ] [ k ] != - 1 ) {			      	  cost = ( ( ord ( X [ l ] ) - ord ( 'a' ) ) ^ ( ord ( Y [  	cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' )		  , k , dp ) )				       ^ Syn
    return dp [ l ] [ r ] [ k ] ;			      	  dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 	return dp [ l ] [ r ] [ k ] = min ( min ( cost + solve (  taxError: invalid syntax
  }							      	  return dp [ l ] [ r ] [ k ]				    								  
  int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ;	      								    								  
  return dp [ l ] [ r ] [ k ] = Math . min ( Math . min ( cos 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1		      DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1			    DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1			  DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1
--							      --							    --								  --
static int editDistDP ( String str1 , String str2 , int m , i def editDistDP ( str1 , str2 , m , n ) :			    def edit_dist_dp ( str1 , str2 , m , n ) :			  script_not_found : None
  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	  dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m  	dp = np.zeros ( ( m + 1 , n + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( m + 1 ) :				    	for i in range ( 0 , m + 1 ) :				  
  i <= m ;						      	      for j in range ( n + 1 ) :			    	    for j in range ( 0 , n + 1 ) :			  
  i ++ ) {						      		  if i == 0 :					    		if i == 0 :					  
    for ( int j = 0 ;					      		      dp [ i ] [ j ] = j			    		    dp [ i ] [ j ] = j				  
    j <= n ;						      		  elif j == 0 :					    		elif j == 0 :					  
    j ++ ) {						      		      dp [ i ] [ j ] = i			    		    dp [ i ] [ j ] = i				  
      if ( i == 0 ) dp [ i ] [ j ] = j ;		      		  elif str1 [ i - 1 ] == str2 [ j - 1 ] :	    		elif str1 [ i - 1 ] == str2 [ j - 1 ] :		  
      else if ( j == 0 ) dp [ i ] [ j ] = i ;		      		      dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]	    		    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]	  
      else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j  		  else :					    		else :						  
      else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp 		      dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] 		    dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] 
    }							      	  return dp [ m ] [ n ]					    	return dp [ m ] [ n ]					  
  }							      								    								  
  return dp [ m ] [ n ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBARRAY_SUM_DIVISIBLE_K			      LONGEST_SUBARRAY_SUM_DIVISIBLE_K				    LONGEST_SUBARRAY_SUM_DIVISIBLE_K				  LONGEST_SUBARRAY_SUM_DIVISIBLE_K
--							      --							    --								  --
static int longSubarrWthSumDivByK ( int arr [ ] , int n , int def longSubarrWthSumDivByK ( arr , n , k ) :		    def long_subarr_wth_sum_div_by_k ( arr , n , k ) :		  script_not_found : None
  HashMap < Integer , Integer > um = new HashMap < Integer ,  	  um = { i : 0 for i in range ( 8 ) }			    	um = { }						  
  int mod_arr [ ] = new int [ n ] ;			      	  mod_arr = [ 0 for i in range ( n ) ]			    	mod_arr = [ 0 ] * n					  
  int max = 0 ;						      	  max = 0						    	max = 0							  
  int curr_sum = 0 ;					      	  curr_sum = 0						    	curr_sum = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      curr_sum += arr [ i ]				    	    curr_sum += arr [ i ]				  
  i ++ ) {						      	      mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k	    	    mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k	  
    curr_sum += arr [ i ] ;				      	  for i in range ( n ) :				    	for i in range ( n ) :					  
    mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ;	      	      if ( mod_arr [ i ] == 0 ) :			    	    if mod_arr [ i ] == 0 :				  
  }							      		  max = i + 1					    		max = i + 1					  
  for ( int i = 0 ;					      	      elif ( mod_arr [ i ] in um ) :			    	    elif um.has_key ( mod_arr [ i ] ) == False :	  
  i < n ;						      		  um [ mod_arr [ i ] ] = i			    		um [ mod_arr [ i ] ] = i			  
  i ++ ) {						      	      else :						    	    elif max < ( i - um [ mod_arr [ i ] ] ) :		  
    if ( mod_arr [ i ] == 0 ) max = i + 1 ;		      		  if ( max < ( i - um [ mod_arr [ i ] ] ) ) :	    		max = i - um [ mod_arr [ i ] ]			  
    else if ( um . containsKey ( mod_arr [ i ] ) == false ) u 		      max = i - um [ mod_arr [ i ] ]		    	return max						  
    else if ( max < ( i - um . get ( mod_arr [ i ] ) ) ) max  	  return max						    								  
  }							      								    								  
  return max ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1	  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1
--							      --							    --								  --
static int findLength ( String str ) {			      def findLength ( string ) :				    def find_length ( str ) :					  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( string )					    	n = len ( str )						  
  int maxlen = 0 ;					      	  maxlen = 0						    	maxlen = 0						  
  int sum [ ] [ ] = new int [ n ] [ n ] ;		      	  Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] 	sum = np.zeros ( ( n , n ) )				  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      Sum [ i ] [ i ] = int ( string [ i ] )		    	    sum [ i ] [ i ] = ord ( str [ i ] ) - ord ( '0' )	  
  i ++ ) sum [ i ] [ i ] = str . charAt ( i ) - '0' ;	      	  for length in range ( 2 , n + 1 ) :			    	for len in range ( 2 , n + 1 ) :			  
  for ( int len = 2 ;					      	      for i in range ( 0 , n - length + 1 ) :		    	    for i in range ( n - len + 1 ) :			  
  len <= n ;						      		  j = i + length - 1				    		j = i + len - 1					  
  len ++ ) {						      		  k = length // 2				    		k = len // 2					  
    for ( int i = 0 ;					      		  Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j 		sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - 
    i < n - len + 1 ;					      		  if ( length % 2 == 0 and Sum [ i ] [ j - k ] == S 		if len % 2 == 0 and sum [ i ] [ j - k ] == sum [  
    i ++ ) {						      		      maxlen = length				    		    maxlen = len				  
      int j = i + len - 1 ;				      	  return maxlen						    	return maxlen						  
      int k = len / 2 ;					      								    								  
      sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 								    								  
      if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - 								    								  
    }							      								    								  
  }							      								    								  
  return maxlen ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3		      COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3		    COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3		  COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3
--							      --							    --								  --
int findgroups ( int arr [ ] , int n ) {		      def findgroups ( arr , n ) :				    def findgroups ( arr , n ) :				  success : None
  int c [ ] = new int [ ] {				      	  c = [ 0 , 0 , 0 ]					    	c = [ 0 , 0 , 0 ]					  
    0 , 0 , 0 }						      	  res = 0						    	i = 0							  
    ;							      	  for i in range ( 0 , n ) :				    	res = 0							  
    int i ;						      	      c [ arr [ i ] % 3 ] += 1				    	for i in range ( n ) :					  
    int res = 0 ;					      	  res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 )		    	    c [ arr [ i ] % 3 ] += 1				  
    for ( i = 0 ;					      	  res += c [ 1 ] * c [ 2 ]				    	res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 )		  
    i < n ;						      	  res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) /  	res += c [ 1 ] * c [ 2 ]				  
    i ++ ) c [ arr [ i ] % 3 ] ++ ;			      	  res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) /  	res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) /  
    res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;	      	  res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) )  	res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) /  
    res += c [ 1 ] * c [ 2 ] ;				      	  res += c [ 0 ] * c [ 1 ] * c [ 2 ]			    	res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) )  
    res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) /  	  return res						    	res += c [ 0 ] * c [ 1 ] * c [ 2 ]			  
    res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) /  								    	return res						  
    res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) )  								    								  
    res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;		      								    								  
    return res ;					      								    								  
  }							      								    								  
  -							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1		      DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1			    DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1			  DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1
--							      --							    --								  --
static boolean isSubsetSum ( int set [ ] , int n , int sum )  def isSubsetSum ( set , n , sum ) :			    def is_subset_sum ( set , n , sum ) :			  script_not_found : None
  boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ]  	  subset = ( [ [ False for i in range ( sum + 1 ) ] for i i 	subset = np.zeros ( ( sum + 1 , n + 1 ) )		  
  for ( int i = 0 ;					      	  for i in range ( n + 1 ) :				    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      subset [ i ] [ 0 ] = True				    	    subset [ 0 ] [ i ] = True				  
  i ++ ) subset [ 0 ] [ i ] = true ;			      	      for i in range ( 1 , sum + 1 ) :			    	for i in range ( 1 , sum + 1 ) :			  
  for ( int i = 1 ;					      		  subset [ 0 ] [ i ] = False			    	    subset [ i ] [ 0 ] = False				  
  i <= sum ;						      	      for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , sum + 1 ) :			  
  i ++ ) subset [ i ] [ 0 ] = false ;			      		  for j in range ( 1 , sum + 1 ) :		    	    for j in range ( 1 , n + 1 ) :			  
  for ( int i = 1 ;					      		      if j < set [ i - 1 ] :			    		subset [ i ] [ j ] = subset [ i ] [ j - 1 ]	  
  i <= sum ;						      			  subset [ i ] [ j ] = subset [ i - 1 ] [ j 		if i >= set [ j - 1 ] :				  
  i ++ ) {						      		      if j >= set [ i - 1 ] :			    		    subset [ i ] [ j ] = subset [ i ] [ j ] or su 
    for ( int j = 1 ;					      			  subset [ i ] [ j ] = ( subset [ i - 1 ] [ 	return subset [ sum ] [ n ]				  
    j <= n ;						      	  return subset [ n ] [ sum ]				    								  
    j ++ ) {						      								    								  
      subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ;	      								    								  
      if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ 								    								  
    }							      								    								  
  }							      								    								  
  return subset [ sum ] [ n ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBSET_SUM_PROBLEM_OSUM_SPACE				      SUBSET_SUM_PROBLEM_OSUM_SPACE				    SUBSET_SUM_PROBLEM_OSUM_SPACE				  SUBSET_SUM_PROBLEM_OSUM_SPACE
--							      --							    --								  --
static boolean isSubsetSum ( int arr [ ] , int n , int sum )  def isSubsetSum ( arr , n , sum ) :			    def is_subset_sum ( arr , n , sum ) :			  script_not_found : None
  boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ;    	  subset = [ [ False for j in range ( sum + 1 ) ] for i in  	subset = np.zeros ( ( 2 , sum + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( n + 1 ) :				    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      for j in range ( sum + 1 ) :			    	    for j in range ( 0 , sum + 1 ) :			  
  i ++ ) {						      		  if ( j == 0 ) :				    		if j == 0 :					  
    for ( int j = 0 ;					      		      subset [ i % 2 ] [ j ] = True		    		    subset [ i % 2 ] [ j ] = True		  
    j <= sum ;						      		  elif ( i == 0 ) :				    		elif i == 0 :					  
    j ++ ) {						      		      subset [ i % 2 ] [ j ] = False		    		    subset [ i % 2 ] [ j ] = False		  
      if ( j == 0 ) subset [ i % 2 ] [ j ] = true ;	      		  elif ( arr [ i - 1 ] <= j ) :			    		elif arr [ i - 1 ] <= j :			  
      else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ;     		      subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 		    subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 
      else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = 		  else :					    		else :						  
      else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ]  		      subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 		    subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 
    }							      	  return subset [ n % 2 ] [ sum ]			    	return subset [ n % 2 ] [ sum ]				  
  }							      								    								  
  return subset [ n % 2 ] [ sum ] ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_CORRELATION_COEFFICIENT			      PROGRAM_FIND_CORRELATION_COEFFICIENT			    PROGRAM_FIND_CORRELATION_COEFFICIENT			  PROGRAM_FIND_CORRELATION_COEFFICIENT
--							      --							    --								  --
static float correlationCoefficient ( int X [ ] , int Y [ ] , def correlationCoefficient ( X , Y , n ) :		    def correlation_coef ( X , Y , n ) :			  script_not_found : None
  int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ;		      	  sum_X = 0						    	sum_X , sum_Y , sum_XY = 0 , 0 , 0			  
  int squareSum_X = 0 , squareSum_Y = 0 ;		      	  sum_Y = 0						    	square_sum_X , square_sum_Y = 0 , 0			  
  for ( int i = 0 ;					      	  sum_XY = 0						    	for i in range ( n ) :					  
  i < n ;						      	  squareSum_X = 0					    	    sum_X = sum_X + X [ i ]				  
  i ++ ) {						      	  squareSum_Y = 0					    	    sum_Y = sum_Y + Y [ i ]				  
    sum_X = sum_X + X [ i ] ;				      	  i = 0							    	    sum_XY = sum_XY + X [ i ] * Y [ i ]			  
    sum_Y = sum_Y + Y [ i ] ;				      	  while i < n :						    	    square_sum_X = square_sum_X + X [ i ] * X [ i ]	  
    sum_XY = sum_XY + X [ i ] * Y [ i ] ;		      	      sum_X = sum_X + X [ i ]				    	    square_sum_Y = square_sum_Y + Y [ i ] * Y [ i ]	  
    squareSum_X = squareSum_X + X [ i ] * X [ i ] ;	      	      sum_Y = sum_Y + Y [ i ]				    	corr = float ( n * sum_XY - sum_X * sum_Y ) / float ( mat 
    squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ;	      	      sum_XY = sum_XY + X [ i ] * Y [ i ]		    	return corr						  
  }							      	      squareSum_X = squareSum_X + X [ i ] * X [ i ]	    								  
  float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( f 	      squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ]	    								  
  return corr ;						      	      i = i + 1						    								  
}							      	  corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) /	    								  
							      	      ( float ) ( math.sqrt ( ( n * squareSum_X - sum_X * s 								  
							      	  return corr						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP
--							      --							    --								  --
static void spiralFill ( int m , int n , int a [ ] [ ] ) {    def spiralFill ( m , n , a ) :				    def spiralFill ( m , n , a ) :				  failure : #Results: 0, 10
  int val = 1 ;						      	  val = 1						    	val = 1							  
  int k = 0 , l = 0 ;					      	  k , l = 0 , 0						    	k , l = 0 , 0						  
  while ( k < m && l < n ) {				      	  while ( k < m and l < n ) :				    	while k < m and l < n :					  
    for ( int i = l ;					      	      for i in range ( l , n ) :			    	    for i in range ( l , n ) :				  
    i < n ;						      		  a [ k ] [ i ] = val				    		a [ k ] [ i ] = val				  
    ++ i ) {						      		  val += 1					    		val += 1					  
      a [ k ] [ i ] = val ++ ;				      	      k += 1						    	    k += 1						  
    }							      	      for i in range ( k , m ) :			    	    for i in range ( k , m ) :				  
    k ++ ;						      		  a [ i ] [ n - 1 ] = val			    		a [ i ] [ n - 1 ] = val				  
    for ( int i = k ;					      		  val += 1					    		val += 1					  
    i < m ;						      	      n -= 1						    	    n -= 1						  
    ++ i ) {						      	      if ( k < m ) :					    	    if k < m :						  
      a [ i ] [ n - 1 ] = val ++ ;			      		  for i in range ( n - 1 , l - 1 , - 1 ) :	    		for i in range ( n - 1 , - l , - 1 ) :		  
    }							      		      a [ m - 1 ] [ i ] = val			    		    a [ m - 1 ] [ i ] = val			  
    n -- ;						      		      val += 1					    		    val += 1					  
    if ( k < m ) {					      		  m -= 1					    		m -= 1						  
      for ( int i = n - 1 ;				      	      if ( l < n ) :					    	    if l < n :						  
      i >= l ;						      		  for i in range ( m - 1 , k - 1 , - 1 ) :	    		for i in range ( m - 1 , - k , - 1 ) :		  
      -- i ) {						      		      a [ i ] [ l ] = val			    		    a [ i ] [ l ] = val				  
	a [ m - 1 ] [ i ] = val ++ ;			      		      val += 1					    		    val += 1					  
      }							      		  l += 1					    		l += 1						  
      m -- ;						      								    								  
    }							      								    								  
    if ( l < n ) {					      								    								  
      for ( int i = m - 1 ;				      								    								  
      i >= k ;						      								    								  
      -- i ) {						      								    								  
	a [ i ] [ l ] = val ++ ;			      								    								  
      }							      								    								  
      l ++ ;						      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOSOYAS_TRIANGLE					      HOSOYAS_TRIANGLE						    HOSOYAS_TRIANGLE						  HOSOYAS_TRIANGLE
--							      --							    --								  --
static void printHosoya ( int n ) {			      def printHosoya ( n ) :					    def print_hosoya ( n ) :					  script_not_found : None
  int dp [ ] [ ] = new int [ N ] [ N ] ;		      	  dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ]  	dp = np.zeros ( ( N , N ) )				  
  dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ;			      	  dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1	    	dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1			  
  dp [ 1 ] [ 1 ] = 1 ;					      	  for i in range ( 2 , n ) :				    	dp [ 1 ] [ 1 ] = 1					  
  for ( int i = 2 ;					      	      for j in range ( n ) :				    	for i in range ( 2 , n ) :				  
  i < n ;						      		  if ( i > j ) :				    	    for j in range ( n ) :				  
  i ++ ) {						      		      dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [  		if i > j :					  
    for ( int j = 0 ;					      		  else :					    		    dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i  
    j < n ;						      		      dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + d 		else :						  
    j ++ ) {						      	  for i in range ( n ) :				    		    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp  
      if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ 	      for j in range ( i + 1 ) :			    	for i in range ( n ) :					  
      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 		  print ( dp [ i ] [ j ] , end = ' ' )		    	    for j in range ( 0 , i + 1 ) :			  
    }							      	      print ( )						    		print ( dp [ i ] [ j ] , end = '' )		  
  }							      								    	    print ( '' )					  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j <= i ;						      								    								  
    j ++ ) System . out . print ( dp [ i ] [ j ] + " " ) ;    								    								  
    System . out . println ( "" ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION	      MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION	    MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION	  MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION
--							      --							    --								  --
static void printMaxSum ( int arr [ ] , int n ) {	      def printMaxSum ( arr , n ) :				    def print_max_sum ( arr , n ) :				  script_not_found : None
  int dp [ ] = new int [ n ] ;				      	  dp = [ 0 for i in range ( n ) ]			    	dp = [ 0 ] * n						  
  Arrays . fill ( dp , 0 ) ;				      	  for i in range ( n ) :				    	dp [ 0 ] = 0						  
  for ( int i = 0 ;					      	      dp [ i ] = arr [ i ]				    	for i in range ( n ) :					  
  i < n ;						      	      maxi = 0						    	    dp [ i ] = arr [ i ]				  
  i ++ ) {						      	      for j in range ( 1 , int ( ( i + 1 ) ** 0.5 ) + 1 ) : 	    maxi = 0						  
    dp [ i ] = arr [ i ] ;				      		  if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) :    	    for j in range ( 1 , math.sqrt ( i + 1 ) + 1 ) :	  
    int maxi = 0 ;					      		      if ( dp [ j - 1 ] > maxi ) :		    		if ( ( i + 1 ) % j == 0 ) and ( i + 1 ) != j :	  
    for ( int j = 1 ;					      			  maxi = dp [ j - 1 ]			    		    if dp [ j - 1 ] > maxi :			  
    j <= Math . sqrt ( i + 1 ) ;			      		      if ( dp [ ( i + 1 ) // j - 1 ] > maxi and j ! 			maxi = dp [ j - 1 ]			  
    j ++ ) {						      			  maxi = dp [ ( i + 1 ) // j - 1 ]	    		    if dp [ ( i + 1 ) / j - 1 ] > maxi and j != 1 
      if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) {	      	      dp [ i ] += maxi					    			maxi = dp [ ( i + 1 ) / j - 1 ]		  
	if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ;      	  for i in range ( n ) :				    	    dp [ i ] += maxi					  
	if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi 	      print ( dp [ i ] , end = ' ' )			    	for i in range ( n ) :					  
      }							      								    	    print ( dp [ i ] , end = ' ' )			  
    }							      								    								  
    dp [ i ] += maxi ;					      								    								  
  }							      								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) System . out . print ( dp [ i ] + " " ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS
--							      --							    --								  --
static int maximumNumberDistinctPrimeRange ( int m , int n )  def maximumNumberDistinctPrimeRange ( m , n ) :		    def maximum_number_distinct_prime_range ( m , n ) :		  script_not_found : None
  long factorCount [ ] = new long [ n + 1 ] ;		      	  factorCount = [ 0 ] * ( n + 1 )			    	factorcount = [ 0 ] * ( n + 1 )				  
  boolean prime [ ] = new boolean [ n + 1 ] ;		      	  prime = [ False ] * ( n + 1 )				    	prime = [ True ] * ( n + 1 )				  
  for ( int i = 0 ;					      	  for i in range ( n + 1 ) :				    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      factorCount [ i ] = 0				    	    factorcount [ i ] = 0				  
  i ++ ) {						      	      prime [ i ] = True				    	    prime [ i ] = True					  
    factorCount [ i ] = 0 ;				      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
    prime [ i ] = true ;				      	      if ( prime [ i ] == True ) :			    	    if prime [ i ] == True :				  
  }							      		  factorCount [ i ] = 1				    		factorcount [ i ] = 1				  
  for ( int i = 2 ;					      		  for j in range ( i * 2 , n + 1 , i ) :	    		for j in range ( i * 2 , n + 1 , i ) :		  
  i <= n ;						      		      factorCount [ j ] += 1			    		    factorcount [ j ] += 1			  
  i ++ ) {						      		      prime [ j ] = False			    		    prime [ j ] = False				  
    if ( prime [ i ] == true ) {			      	  max = factorCount [ m ]				    	max = int ( factorcount [ m ] )				  
      factorCount [ i ] = 1 ;				      	  num = m						    	num = m							  
      for ( int j = i * 2 ;				      	  for i in range ( m , n + 1 ) :			    	for i in range ( m , n + 1 ) :				  
      j <= n ;						      	      if ( factorCount [ i ] > max ) :			    	    if factorcount [ i ] > max :			  
      j += i ) {					      		  max = factorCount [ i ]			    		max = int ( factorcount [ i ] )			  
	factorCount [ j ] ++ ;				      		  num = i					    		num = i						  
	prime [ j ] = false ;				      	  return num						    	return num						  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  int max = ( int ) factorCount [ m ] ;			      								    								  
  int num = m ;						      								    								  
  for ( int i = m ;					      								    								  
  i <= n ;						      								    								  
  i ++ ) {						      								    								  
    if ( factorCount [ i ] > max ) {			      								    								  
      max = ( int ) factorCount [ i ] ;			      								    								  
      num = i ;						      								    								  
    }							      								    								  
  }							      								    								  
  return num ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE    MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE    MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE	  MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE
--							      --							    --								  --
static int maxProfit ( int price [ ] , int n ) {	      def maxProfit ( price , n ) :				    def max_profit ( price , n ) :				  success : None
  int profit [ ] = new int [ n ] ;			      	  profit = [ 0 ] * n					    	profit = [ 0 for i in range ( n ) ]			  
  for ( int i = 0 ;					      	  max_price = price [ n - 1 ]				    	max_price = price [ n - 1 ]				  
  i < n ;						      	  for i in range ( n - 2 , 0 , - 1 ) :			    	for i in range ( n - 2 , - 1 , - 1 ) :			  
  i ++ ) profit [ i ] = 0 ;				      	      if price [ i ] > max_price :			    	    if price [ i ] > max_price :			  
  int max_price = price [ n - 1 ] ;			      		  max_price = price [ i ]			    		max_price = price [ i ]				  
  for ( int i = n - 2 ;					      	      profit [ i ] = max ( profit [ i + 1 ] , max_price - p 	    profit [ i ] = max ( profit [ i + 1 ] , max_price - p 
  i >= 0 ;						      	  min_price = price [ 0 ]				    	min_price = price [ 0 ]					  
  i -- ) {						      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
    if ( price [ i ] > max_price ) max_price = price [ i ] ;  	      if price [ i ] < min_price :			    	    if price [ i ] < min_price :			  
    profit [ i ] = Math . max ( profit [ i + 1 ] , max_price  		  min_price = price [ i ]			    		min_price = price [ i ]				  
  }							      	      profit [ i ] = max ( profit [ i - 1 ] , profit [ i ]  	    profit [ i ] = max ( profit [ i - 1 ] , profit [ i ]  
  int min_price = price [ 0 ] ;				      	  result = profit [ n - 1 ]				    	result = profit [ n - 1 ]				  
  for ( int i = 1 ;					      	  return result						    	return result						  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    if ( price [ i ] < min_price ) min_price = price [ i ] ;  								    								  
    profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i 								    								  
  }							      								    								  
  int result = profit [ n - 1 ] ;			      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT		      CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT			    CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT			  CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT
--							      --							    --								  --
static boolean isMagicSquare ( int mat [ ] [ ] ) {	      def isMagicSquare ( mat ) :				    def is_magic_square ( mat ) :				  script_not_found : None
  int sum = 0 , sum2 = 0 ;				      	  s = 0							    	sum , sum2 = 0 , 0					  
  for ( int i = 0 ;					      	  for i in range ( 0 , N ) :				    	for i in range ( N ) :					  
  i < N ;						      	      s = s + mat [ i ] [ i ]				    	    sum = sum + mat [ i ] [ i ]				  
  i ++ ) sum = sum + mat [ i ] [ i ] ;			      	  s2 = 0						    	for i in range ( N ) :					  
  for ( int i = 0 ;					      	  for i in range ( 0 , N ) :				    	    sum2 = sum2 + mat [ i ] [ N - 1 - i ]		  
  i < N ;						      	      s2 = s2 + mat [ i ] [ N - i - 1 ]			    	if sum != sum2 :					  
  i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ;	      	  if ( s != s2 ) :					    	    return False					  
  if ( sum != sum2 ) return false ;			      	      return False					    	for i in range ( N ) :					  
  for ( int i = 0 ;					      	  for i in range ( 0 , N ) :				    	    row_sum = 0						  
  i < N ;						      	      rowSum = 0					    	    for j in range ( N ) :				  
  i ++ ) {						      	      for j in range ( 0 , N ) :			    		row_sum += mat [ i ] [ j ]			  
    int rowSum = 0 ;					      		  rowSum += mat [ i ] [ j ]			    	    if row_sum != sum :					  
    for ( int j = 0 ;					      	      if ( rowSum != s ) :				    		return False					  
    j < N ;						      		  return False					    	for i in range ( N ) :					  
    j ++ ) rowSum += mat [ i ] [ j ] ;			      	  for i in range ( 0 , N ) :				    	    col_sum = 0						  
    if ( rowSum != sum ) return false ;			      	      colSum = 0					    	    for j in range ( N ) :				  
  }							      	      for j in range ( 0 , N ) :			    		col_sum += mat [ j ] [ i ]			  
  for ( int i = 0 ;					      		  colSum += mat [ j ] [ i ]			    	    if sum != col_sum :					  
  i < N ;						      	      if ( s != colSum ) :				    		return False					  
  i ++ ) {						      		  return False					    	return True						  
    int colSum = 0 ;					      	  return True						    								  
    for ( int j = 0 ;					      								    								  
    j < N ;						      								    								  
    j ++ ) colSum += mat [ j ] [ i ] ;			      								    								  
    if ( sum != colSum ) return false ;			      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS	      FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS		    FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS		  FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS
--							      --							    --								  --
static void pairSum ( int mat [ ] [ ] , int n , int sum ) {   def pairSum ( mat , n , sum ) :				    def pair_sum ( mat , n , sum ) :				  failure : (2, 5),  (2, 5),  (2, 5),  (2, 5),	(2,
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  5),  (2, 5),	(3, 4),	 (2, 5),  (2, 5),  (3, 4),
  i < n ;						      	      mat [ i ].sort ( )				    	    mat.sort ( )					  (3, 4),  (2, 5),  (2, 5),  (2, 5),  (4, 3),  (3, 4
  i ++ ) Arrays . sort ( mat [ i ] ) ;			      	  for i in range ( n - 1 ) :				    	for i in range ( n - 1 ) :				  ),  (3, 4),  (3, 4),	(3, 4),	 ( 5 ,	2 ),  ( 5 ,
  for ( int i = 0 ;					      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			   2 ),	 ( 2 ,	5 ),  ( 3 ,  4 ),  ( 2 ,  5 ),	( 3
  i < n - 1 ;						      		  left = 0					    		left , right = 0 , n - 1			  ,  4 ),  ( 3 ,  4 ),	( 2 ,  5 ),  ( 2 ,  5 ),  (
  i ++ ) {						      		  right = n - 1					    		while left < n and right >= 0 :			  2 ,  5 ),  ( 2 ,  5 ),  ( 2 ,	 5 ),  ( 2 ,  5 ),
    for ( int j = i + 1 ;				      		  while ( left < n and right >= 0 ) :		    		    if ( mat [ i ] [ left ] + mat [ j ] [ right ] ( 2 ,	 5 ),  ( 4 ,  3 ),  ( 4 ,  3 ),	 ( 3 ,	4 ),
    j < n ;						      		      if ( ( mat [ i ] [ left ] + mat [ j ] [ right 			print ( '(%d, %d), ' % ( mat [ i ] [ left   ( 3 ,  4 ),	 ( 4 ,	3 ),  ( 2 ,  10 ),  ( 11 ,
    j ++ ) {						      			  print ( "(" , mat [ i ] [ left ] , ", " , 			left += 1				  1 ),	( 7 ,  5 ),  ( 7 ,  5 ),  ( 7 ,	 5 ),  ( 11
      int left = 0 , right = n - 1 ;			      			  left += 1				    			right -= 1				  ,  1 ),  ( 2 ,  10 ),	 ( 7 ,	5 ),  ( 11 ,  1 ),
      while ( left < n && right >= 0 ) {		      			  right -= 1				    		    else :					  ( 2 ,	 10 ),	( 11 ,	1 ),  ( 11 ,  1 ),  ( 6 ,  6
	if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) ==  		      else :					    			if ( mat [ i ] [ left ] + mat [ j ] [ rig  ),  ( 10 ,  2 ),  ( 1 ,  11 ),  ( 9 ,  3 ),	( 9
	  System . out . print ( "(" + mat [ i ] [ left ] + " 			  if ( ( mat [ i ] [ left ] + mat [ j ] [ r 			    left += 1				  ,  3 ),  ( 10 ,  2 ),	 ( 6 ,	6 ),  ( 1 ,  11 ),
	  left ++ ;					      			      left += 1				    			else :					  ( 9 ,	 3 ),  ( 9 ,  3 ),  ( 5 ,  7 ),	 ( 5 ,	7 ),
	  right -- ;					      			  else :				    			    right -= 1				    ( 5 ,  7 ),	 ( 5 ,	7 ),  ( 5 ,  7 ),  ( 5 ,  7
	}						      			      right -= 1			    								  ),  ( 5 ,  7 ),  ( 5 ,  7 ),	( 5 ,  7 ),  ( 7 ,
	else {						      								    								  5 ),	( 5 ,  7 ),  ( 5 ,  7 ),  ( 7 ,	 5 ),  ( 5 ,
	  if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < 								    								    7 ),  ( 8 ,	 4 ),  ( 5 ,  7 ),  ( 5 ,  7 ),	 ( 5
	  else right -- ;				      								    								   ,  7 ),  ( 7 ,  5 ),	 ( 2 ,	10 ),  ( 7 ,  5 ),
	}						      								    								  ( 6 ,	 6 ),  ( 2 ,  10 ),  ( 3 ,  9 ),  ( 5 ,	 7 )
      }							      								    								  ,  ( 5 ,  7 ),  ( 11 ,  1 ),	( 3 ,  9 ),  ( 5 ,
    }							      								    								  7 ),	( 5 ,  7 ),  ( 11 ,  1 ),  ( 5 ,  7 ),	( 5
  }							      								    								  ,  7 ),  ( 3 ,  9 ),	( 5 ,  7 ),  ( 11 ,  1 ),  (
}							      								    								   5 ,	7 ),  ( 11 ,  1 ),  ( 9 ,  3 ),	 ( 7 ,	5 ),
							      								    								    ( 1 ,  11 ),  ( 9 ,	 3 ),  ( 9 ,  3 ),  ( 9 ,  3
							      								    								   ),  ( 9 ,  3 ),  ( 9 ,  3 ),	 ( 3 ,	9 ),  ( 5 ,
							      								    								   7 ),	 ( 2 ,	10 ),  ( 5 ,  7 ),  ( 5 ,  7 ),	 ( 5
							      								    								   ,  7 ),  ( 4 ,  8 ),	 ( 1 ,	11 ),  ( 9 ,  3 ),
							      								    								  ( 9 ,	 3 ),  ( 11 ,  1 ),  (2, 6),  ( 2 ,  6 ),  (
							      								    								  98, -76),  (98, -76),	 (98, -76),  (-70, 92),	 (32
							      								    								  , -10),  (86, -64),  (88, -66),  (-44, 66),  (88,
							      								    								  -66),	 (86, -64),  (80, -58),	 (98, -76),  (0, 22)
							      								    								  ,  (98, -76),	 (-36, 58),  (98, -76),	 (90, -68),
							      								    								   (64, -42),  (88, -66),  (60, -38),  (60, -38),  (
							      								    								  60, -38),  (92, -70),	 (30, -8),  (92, -70),	(92,
							      								    								   -70),  (-16, 38),  (92, -70),  (96, -74),  (92, -
							      								    								  70),	(92, -70),  (96, -74),	(92, -70),  (92, -70
							      								    								  ),  (86, -64),  (92, -70),  (88, -66),  (-44, 66),
							      								    								    (88, -66),	(86, -64),  (96, -74),	(86, -64),
							      								    								  (96, -74),  (98, -76),  (-2, 24),  (92, -70),	 (92
							      								    								  , -70),  (86, -64),  (84, -62),  (-2, 24),  (92, -
							      								    								  70),	(-30, 52),  (86, -64),	(86, -64),  (-26, 48
							      								    								  ),  (94, -72),  (96, -74),  (-26, 48),  (60, -38),
							      								    								    (60, -38),	(96, -74),  (92, -70),	(72, -50),
							      								    								  (86, -64),  (92, -70),  (92, -70),  (84, -62),  (9
							      								    								  8, -76),  (94, -72),	(48, -26),  (18, 4),  (94, -
							      								    								  72),	( 4 ,  18 ),  ( 14 ,  8 ),  ( 40 ,  -18 ),
							      								    								  ( 44 ,  -22 ),  ( 4 ,	 18 ),	( 14 ,	8 ),  ( 42 ,
							      								    								    -20 ),  ( 14 ,  8 ),  ( 22 ,  0 ),	( 22 ,	0 ),
							      								    								    ( 26 ,  -4 ),  ( 12 ,  10 ),  ( 22 ,  0 ),	( 42
							      								    								   ,  -20 ),  ( 40 ,  -18 ),  ( 44 ,  -22 ),  ( 26 ,
							      								    								    -4 ),  ( 40 ,  -18 ),  ( 12 ,  10 ),  ( 42 ,  -2
							      								    								  0 ),	( 12 ,	10 ),  ( 26 ,  -4 ),  ( 42 ,  -20 ),
							      								    								    ( 44 ,  -22 ),  ( 26 ,  -4 ),  ( 40 ,  -18 ),  (
							      								    								   42 ,	 -20 ),	 ( 44 ,	 -22 ),	 ( 4 ,	18 ),  ( 12
							      								    								  ,  10 ),  ( 14 ,  8 ),  ( 22 ,  0 ),	( 26 ,	-4 )
							      								    								  ,  ( 44 ,  -22 ),  ( -18 ,  40 ),  ( 4 ,  18 ),  (
							      								    								   14 ,	 8 ),  ( 26 ,  -4 ),  ( 4 ,  18 ),  ( 12 ,
							      								    								  10 ),	 ( 14 ,	 8 ),  ( 26 ,  -4 ),  ( -14 ,  36 ),
							      								    								    ( -6 ,  28 ),  ( 4 ,  18 ),	 ( 40 ,	 -18 ),	 ( -
							      								    								  6 ,  28 ),  ( 22 ,  0 ),  ( -18 ,  40 ),  ( -14 ,
							      								    								   36 ),  ( -14 ,  36 ),  ( 12 ,  10 ),	 ( 44 ,	 -22
							      								    								   ),  ( 14 ,  8 ),  ( 22 ,  0 ),  ( 26 ,  -4 ),  (
							      								    								  -6 ,	28 ),  ( 26 ,  -4 ),  ( -22 ,  44 ),  ( 12 ,
							      								    								    10 ),  ( 42 ,  -20 ),  ( -22 ,  44 ),  ( -14 ,
							      								    								  36 ),	 ( 12 ,	 10 ),	( 14 ,	8 ),  ( 26 ,  -4 ),
							      								    								   ( 40 ,  -18 ),  ( 4 ,  18 ),	 ( 14 ,	 8 ),  ( 22
							      								    								  ,  0 ),  ( 26 ,  -4 ),  ( 12 ,  10 ),	 ( 22 ,	 0 )
							      								    								  ,  ( 40 ,  -18 ),  ( 42 ,  -20 ),  ( 12 ,  10 ),
							      								    								  ( 44 ,  -22 ),  ( -14 ,  36 ),  ( -6 ,  28 ),	 ( 4
							      								    								   ,  18 ),  ( 12 ,  10 ),  ( 14 ,  8 ),  ( 22 ,  0
							      								    								  ),  ( 44 ,  -22 ),  ( 4 ,  18 ),  ( 18 ,  4 ),  (
							      								    								  -36 ,	 58 ),	( -24 ,	 46 ),	( 2 ,  20 ),  ( 18 ,
							      								    								    4 ),  ( 20 ,  2 ),	( 18 ,	4 ),  ( 20 ,  2 ),
							      								    								  ( 20 ,  2 ),	( 46 ,	-24 ),	( 20 ,	2 ),  ( 34 ,
							      								    								    -12 ),  ( 18 ,  4 ),  ( 20 ,  2 ),	( 20 ,	2 ),
							      								    								    ( 2 ,  20 ),  ( 4 ,	 18 ),	( 18 ,	4 ),  ( 20 ,
							      								    								    2 ),  ( -18 ,  40 ),  ( 4 ,	 18 ),	( 8 ,  14 ),
							      								    								    ( 2 ,  20 ),  ( 4 ,	 18 ),	( 18 ,	4 ),  ( 34 ,
							      								    								    -12 ),  ( 4 ,  18 ),  ( 8 ,	 14 ),	( 18 ,	4 ),
							      								    								    ( 20 ,  2 ),  ( 34 ,  -12 ),  ( 46 ,  -24 ),  (
							      								    								  -16 ,	 38 ),	( 18 ,	4 ),  ( 34 ,  -12 ),  ( -18
							      								    								  ,  40 ),  ( 2 ,  20 ),  ( 8 ,	 14 ),	( 18 ,	4 ),
							      								    								    ( 34 ,  -12 ),  ( 8 ,  14 ),  ( 46 ,  -24 ),  (
							      								    								  46 ,	-24 ),	( -16 ,	 38 ),	( 2 ,  20 ),  ( 20 ,
							      								    								    2 ),  ( -24 ,  46 ),  ( -22 ,  44 ),  ( 2 ,	 20
							      								    								  ),  ( 34 ,  -12 ),  ( 34 ,  -12 ),  ( 46 ,  -24 ),
							      								    								    ( -22 ,  44 ),  ( 20 ,  2 ),  ( 2 ,	 20 ),	( 2
							      								    								  ,  20 ),  ( 4 ,  18 ),  ( 18 ,  4 ),	( 18 ,	4 ),
							      								    								    ( 34 ,  -12 ),  ( 8 ,  14 ),  ( 8 ,	 14 ),	( 18
							      								    								   ,  4 ),  ( 4 ,  18 ),  ( 34 ,  -12 ),  ( -34 ,  5
							      								    								  6 ),	( -32 ,	 54 ),	( -20 ,	 42 ),	( -2 ,	24 )
							      								    								  ,  ( 22 ,  0 ),  ( -2 ,  24 ),  ( 22 ,  0 ),	( 18
							      								    								   ,  4 ),  ( 22 ,  0 ),  ( 18 ,  4 ),	( -10 ,	 32
							      								    								  ),  ( -2 ,  24 ),  ( 6 ,  16 ),  ( 18 ,  4 ),	 ( -
							      								    								  2 ,  24 ),  ( 4 ,  18 ),  ( 18 ,  4 ),  ( 22 ,  0
							      								    								  ),  ( -20 ,  42 ),  ( -2 ,  24 ),  ( 4 ,  18 ),  (
							      								    								   8 ,	14 ),  ( -2 ,  24 ),  ( 4 ,  18 ),  ( 18 ,
							      								    								  4 ),	( 4 ,  18 ),  ( 6 ,  16 ),  ( 8 ,  14 ),  (
							      								    								  18 ,	4 ),  ( -2 ,  24 ),  ( 18 ,  4 ),  ( 22 ,  0
							      								    								   ),  ( -20 ,	42 ),  ( -10 ,	32 ),  ( 6 ,  16 ),
							      								    								   ( 8 ,  14 ),	 ( 18 ,	 4 ),  ( 6 ,  16 ),  ( 8 ,
							      								    								  14 ),	 ( 22 ,	 0 ),  ( -10 ,	32 ),  ( 6 ,  16 ),
							      								    								   ( -20 ,  42 ),  ( -10 ,  32 ),  ( -20 ,  42 ),  (
							      								    								   -10 ,  32 ),	 ( -2 ,	 24 ),	( 4 ,  18 ),  ( 18 ,
							      								    								    4 ),  ( 22 ,  0 ),	( -10 ,	 32 ),	( -2 ,	24 )
							      								    								  ,  ( 18 ,  4 ),  ( 22 ,  0 ),	 ( -2 ,	 24 ),	( 8
							      								    								  ,  14 ),  ( 8 ,  14 ),  ( 18 ,  4 ),	( 4 ,  18 ),
							      								    								    ( 22 ,  0 ),  ( 42 ,  -20 ),  ( 56 ,  -34 ),  (
							      								    								  56 ,	-34 ),	( 60 ,	-38 ),	( 24 ,	-2 ),  ( 24
							      								    								  ,  -2 ),  ( 46 ,  -24 ),  ( 54 ,  -32 ),  ( 56 ,
							      								    								  -34 ),  ( 58 ,  -36 ),  ( 60 ,  -38 ),  ( 6 ,	 16
							      								    								  ),  ( 24 ,  -2 ),  ( 42 ,  -20 ),  ( 54 ,  -32 ),
							      								    								   ( 58 ,  -36 ),  ( 60 ,  -38 ),  ( 24 ,  -2 ),  (
							      								    								  42 ,	-20 ),	( 42 ,	-20 ),	( 60 ,	-38 ),	( 56
							      								    								   ,  -34 ),  ( 60 ,  -38 ),  ( 8 ,  14 ),  ( 56 ,
							      								    								  -34 ),  ( 60 ,  -38 ),  ( -14 ,  36 ),  ( 0 ,	 22
							      								    								  ),  ( 6 ,  16 ),  ( 8 ,  14 ),  ( 46 ,  -24 ),  (
							      								    								  54 ,	-32 ),	( 60 ,	-38 ),	( 56 ,	-34 ),	( 56
							      								    								   ,  -34 ),  ( -14 ,  36 ),  ( -14 ,  36 ),  ( 6 ,
							      								    								   16 ),  ( 8 ,	 14 ),	( 56 ,	-34 ),	( 0 ,  22 ),
							      								    								    ( 6 ,  16 ),  ( 8 ,	 14 ),	( 24 ,	-2 ),  ( 46
							      								    								  ,  -24 ),  ( 56 ,  -34 ),  ( 60 ,  -38 ),  ( 6 ,
							      								    								  16 ),	 ( 54 ,	 -32 ),	 ( 56 ,	 -34 ),	 ( 58 ,	 -36
							      								    								   ),  ( 24 ,  -2 ),  ( 58 ,  -36 ),  ( 42 ,  -20 ),
							      								    								    ( 46 ,  -24 ),  ( 54 ,  -32 ),  ( 56 ,  -34 ),
							      								    								  ( -14 ,  36 ),  ( 0 ,	 22 ),	( 58 ,	-36 ),	( 24
							      								    								   ,  -2 ),  ( 58 ,  -36 ),  ( 60 ,  -38 ),  ( 24 ,
							      								    								   -2 ),  ( 42 ,  -20 ),  ( 54 ,  -32 ),  ( 8 ,	 14
							      								    								  ),  ( 56 ,  -34 ),  ( -14 ,  36 ),  ( 0 ,  22 ),
							      								    								  ( 24 ,  -2 ),	 ( 24 ,	 -2 ),	( 60 ,	-38 ),	( 20
							      								    								   ,  2 ),  ( 24 ,  -2 ),  ( 20 ,  2 ),	 ( 24 ,	 -2
							      								    								  ),  ( -10 ,  32 ),  ( -4 ,  26 ),  ( 20 ,  2 ),  (
							      								    								   24 ,	 -2 ),	( 20 ,	2 ),  ( 24 ,  -2 ),  ( 20 ,
							      								    								   2 ),	 ( 20 ,	 2 ),  ( -8 ,  30 ),  ( -6 ,  28 ),
							      								    								   ( 0 ,  22 ),	 ( 20 ,	 2 ),  ( -6 ,  28 ),  ( -10
							      								    								  ,  32 ),  ( 0 ,  22 ),  ( 24 ,  -2 ),	 ( -10 ,  32
							      								    								   ),  ( -6 ,  28 ),  ( 20 ,  2 ),  ( -10 ,  32 ),
							      								    								  ( 24 ,  -2 ),	 ( -10 ,  32 ),	 ( 0 ,	22 ),  ( 20
							      								    								  ,  2 ),  ( 24 ,  -2 ),  ( -10 ,  32 ),  ( 24 ,  -2
							      								    								   ),  ( -8 ,  30 ),  ( -6 ,  28 ),  ( 0 ,  22 ),  (
							      								    								   24 ,	 -2 ),	( -10 ,	 32 ),	( 6 ,  16 ),  ( 10 ,
							      								    								    12 ),  ( 2 ,  20 ),	 ( 4 ,	18 ),  ( -20 ,	42 )
							      								    								  ,  ( -8 ,  30 ),  ( 4 ,  18 ),  ( 10 ,  12 ),	 ( 2
							      								    								   ,  20 ),  ( 4 ,  18 ),  ( -14 ,  36 ),  ( -6 ,  2
							      								    								  8 ),	( 0 ,  22 ),  ( 4 ,  18 ),  ( 6 ,  16 ),  (
							      								    								  -6 ,	28 ),  ( 10 ,  12 ),  ( -20 ,  42 ),  ( -14
							      								    								  ,  36 ),  ( -10 ,  32 ),  ( 2 ,  20 ),  ( 6 ,	 16
							      								    								  ),  ( 10 ,  12 ),  ( 0 ,  22 ),  ( 6 ,  16 ),	 ( 1
							      								    								  0 ,  12 ),  ( -10 ,  32 ),  ( -6 ,  28 ),  ( 2 ,
							      								    								  20 ),	 ( 6 ,	16 ),  ( 10 ,  12 ),  ( -20 ,  42 ),
							      								    								    ( -10 ,  32 ),  ( 2 ,  20 ),  ( 10 ,  12 ),	 ( -
							      								    								  20 ,	42 ),  ( -14 ,	36 ),  ( -10 ,	32 ),  ( 0 ,
							      								    								    22 ),  ( 2 ,  20 ),	 ( 4 ,	18 ),  ( -10 ,	32 )
							      								    								  ,  ( 10 ,  12 ),  ( -14 ,  36 ),  ( -8 ,  30 ),  (
							      								    								   -6 ,	 28 ),	( 0 ,  22 ),  ( 4 ,  18 ),  ( -2 ,
							      								    								  24 ),	 ( 6 ,	16 ),  ( -2 ,  24 ),  ( 4 ,  18 ),
							      								    								  ( -18 ,  40 ),  ( -2 ,  24 ),	 ( 4 ,	18 ),  ( -2
							      								    								  ,  24 ),  ( 4 ,  18 ),  ( -14 ,  36 ),  ( 4 ,	 18
							      								    								  ),  ( 6 ,  16 ),  ( -2 ,  24 ),  ( -18 ,  40 ),  (
							      								    								   -14 ,  36 ),	 ( 6 ,	16 ),  ( 6 ,  16 ),  ( 6 ,
							      								    								  16 ),	 ( -22 ,  44 ),	 ( -22 ,  44 ),	 ( -14 ,  36
							      								    								   ),  ( -2 ,  24 ),  ( 4 ,  18 ),  ( -2 ,  24 ),  (
							      								    								   -2 ,	 24 ),	( -14 ,	 36 ),	( 4 ,  18 ),  ( -4 ,
							      								    								    26 ),  ( -2 ,  24 ),  ( -2 ,  24 ),	 ( 2 ,	20 )
							      								    								  ,  ( -18 ,  40 ),  ( -18 ,  40 ),  ( -2 ,  24 ),
							      								    								  ( -2 ,  24 ),	 ( 2 ,	20 ),  ( -2 ,  24 ),  ( -18
							      								    								  ,  40 ),  ( 2 ,  20 ),  ( 2 ,	 20 ),	( -24 ,	 46
							      								    								  ),  ( 2 ,  20 ),  ( -2 ,  24 ),  ( 2 ,  20 ),	 ( 2
							      								    								   ,  20 ),  ( -2 ,  24 ),  ( -2 ,  24 ),  ( 10 ,  1
							      								    								  2 ),	( 24 ,	-2 ),  ( 26 ,  -4 ),  ( 16 ,  6 ),
							      								    								  ( 26 ,  -4 ),	 ( -2 ,	 24 ),	( 2 ,  20 ),  ( 26 ,
							      								    								    -4 ),  ( 32 ,  -10 ),  ( -20 ,  42 ),  ( -8 ,  3
							      								    								  0 ),	( -2 ,	24 ),  ( 10 ,  12 ),  ( 26 ,  -4 ),
							      								    								   ( -2 ,  24 ),  ( 2 ,	 20 ),	( 16 ,	6 ),  ( 26 ,
							      								    								    -4 ),  ( 32 ,  -10 ),  ( -12 ,  34 ),  ( -2 ,  2
							      								    								  4 ),	( 10 ,	12 ),  ( -20 ,	42 ),  ( 2 ,  20 ),
							      								    								   ( 10 ,  12 ),  ( 16 ,  6 ),	( 32 ,	-10 ),	( 10
							      								    								   ,  12 ),  ( 16 ,  6 ),  ( 24 ,  -2 ),  ( 26 ,  -4
							      								    								   ),  ( -12 ,	34 ),  ( 2 ,  20 ),  ( 10 ,  12 ),
							      								    								  ( 26 ,  -4 ),	 ( -20 ,  42 ),	 ( 2 ,	20 ),  ( 10
							      								    								  ,  12 ),  ( 24 ,  -2 ),  ( -20 ,  42 ),  ( -12 ,
							      								    								  34 ),	 ( -2 ,	 24 ),	( 26 ,	-4 ),  ( 32 ,  -10 )
							      								    								  ,  ( 2 ,  20 ),  ( 24 ,  -2 ),  ( 26 ,  -4 ),	 ( -
							      								    								  2 ,  24 ),  ( 16 ,  6 ),  ( 24 ,  -2 ),  ( 32 ,  -
							      								    								  10 ),	 ( 32 ,	 -10 ),	 ( -2 ,	 24 ),	( 10 ,	12 )
							      								    								  ,  ( 16 ,  6 ),  ( -8 ,  30 ),  ( 24 ,  -2 ),	 ( -
							      								    								  2 ,  24 ),  ( 2 ,  20 ),  ( 4 ,  18 ),  ( 12 ,  10
							      								    								   ),  ( -20 ,	42 ),  ( -8 ,  30 ),  ( -2 ,  24 ),
							      								    								   ( 4 ,  18 ),	 ( 10 ,	 12 ),	( -2 ,	24 ),  ( 2 ,
							      								    								    20 ),  ( 4 ,  18 ),	 ( 12 ,	 10 ),	( 4 ,  18 ),
							      								    								    ( -2 ,  24 ),  ( 10 ,  12 ),  ( -20 ,  42 ),  (
							      								    								  2 ,  20 ),  ( 10 ,  12 ),  ( 12 ,  10 ),  ( 10 ,
							      								    								  12 ),	 ( 2 ,	20 ),  ( 10 ,  12 ),  ( -22 ,  44 ),
							      								    								    ( -20 ,  42 ),  ( 2 ,  20 ),  ( 10 ,  12 ),	 ( 1
							      								    								  2 ,  10 ),  ( -22 ,  44 ),  ( -20 ,  42 ),  ( -2 ,
							      								    								    24 ),  ( 12 ,  10 ),  ( 2 ,	 20 ),	( 4 ,  18 ),
							      								    								    ( -2 ,  24 ),  ( 12 ,  10 ),  ( -2 ,  24 ),	 ( 1
							      								    								  0 ,  12 ),  ( 12 ,  10 ),  ( -8 ,  30 ),  ( 4 ,  1
							      								    								  8 ),	( 12 ,	10 ),  ( 2 ,  20 ),  ( -20 ,  42 ),
							      								    								   ( -18 ,  40 ),  ( -8 ,  30 ),  ( -8 ,  30 ),	 ( 2
							      								    								   ,  20 ),  ( -14 ,  36 ),  ( 6 ,  16 ),  ( -20 ,
							      								    								  42 ),	 ( -18 ,  40 ),	 ( -14 ,  36 ),	 ( 2 ,	20 )
							      								    								  ,  ( 6 ,  16 ),  ( 6 ,  16 ),	 ( 2 ,	20 ),  ( 6 ,
							      								    								    16 ),  ( -22 ,  44 ),  ( -20 ,  42 ),  ( 2 ,  20
							      								    								   ),  ( -22 ,	44 ),  ( -20 ,	42 ),  ( -14 ,	36 )
							      								    								  ,  ( 2 ,  20 ),  ( -14 ,  36 ),  ( -8 ,  30 ),  (
							      								    								  4 ,  18 ),  ( 8 ,  14 ),  ( 10 ,  12 ),  ( 2 ,  20
							      								    								   ),  ( 4 ,  18 ),  ( 18 ,  4 ),  ( 0 ,  22 ),	 ( 4
							      								    								   ,  18 ),  ( 8 ,  14 ),  ( 18 ,  4 ),	 ( 20 ,	 2 )
							      								    								  ,  ( 10 ,  12 ),  ( 18 ,  4 ),  ( -10 ,  32 ),  (
							      								    								  2 ,  20 ),  ( 8 ,  14 ),  ( 10 ,  12 ),  ( 18 ,  4
							      								    								   ),  ( 0 ,  22 ),  ( 8 ,  14 ),  ( 10 ,  12 ),  (
							      								    								  24 ,	-2 ),  ( -10 ,	32 ),  ( 2 ,  20 ),  ( 10 ,
							      								    								   12 ),  ( 20 ,  2 ),	( -22 ,	 44 ),	( -10 ,	 32
							      								    								  ),  ( 2 ,  20 ),  ( 10 ,  12 ),  ( 24 ,  -2 ),  (
							      								    								  -22 ,	 44 ),	( -10 ,	 32 ),	( 0 ,  22 ),  ( 20 ,
							      								    								    2 ),  ( 2 ,	 20 ),	( 4 ,  18 ),  ( 18 ,  4 ),
							      								    								  ( 24 ,  -2 ),	 ( -10 ,  32 ),	 ( 18 ,	 4 ),  ( 24
							      								    								  ,  -2 ),  ( 8 ,  14 ),  ( 10 ,  12 ),	 ( 18 ,	 4 )
							      								    								  ,  ( 0 ,  22 ),  ( 4 ,  18 ),	 ( 24 ,	 -2 ),	( 12
							      								    								   ,  10 ),  ( 14 ,  8 ),  ( 18 ,  4 ),	 ( -6 ,	 28
							      								    								  ),  ( 8 ,  14 ),  ( 18 ,  4 ),  ( 40 ,  -18 ),  (
							      								    								  -6 ,	28 ),  ( 18 ,  4 ),  ( 8 ,  14 ),  ( 12 ,  1
							      								    								  0 ),	( 18 ,	4 ),  ( 8 ,  14 ),  ( 14 ,  8 ),  (
							      								    								  24 ,	-2 ),  ( -6 ,  28 ),  ( 12 ,  10 ),  ( 24 ,
							      								    								   -2 ),  ( 30 ,  -8 ),	 ( 30 ,	 -8 ),	( 42 ,	-20
							      								    								  ),  ( 12 ,  10 ),  ( 14 ,  8 ),  ( 40 ,  -18 ),  (
							      								    								   14 ,	 8 ),  ( 18 ,  4 ),  ( 24 ,  -2 ),  ( 12 ,
							      								    								  10 ),	 ( 18 ,	 4 ),  ( 24 ,  -2 ),  ( 40 ,  -18 ),
							      								    								    ( 42 ,  -20 ),  ( 8 ,  14 ),  ( 12 ,  10 ),	 ( 1
							      								    								  8 ,  4 ),  ( 30 ,  -8 ),  ( 30 ,  -8 ),  ( -8 ,  3
							      								    								  0 ),	( -6 ,	28 ),  ( 12 ,  10 ),  ( 14 ,  8 ),
							      								    								  ( 24 ,  -2 ),	 ( -14 ,  36 ),	 ( -12 ,  34 ),	 ( 4
							      								    								   ,  18 ),  ( 6 ,  16 ),  ( 8 ,  14 ),	 ( 18 ,	 4 )
							      								    								  ,  ( 20 ,  2 ),  ( -16 ,  38 ),  ( 10 ,  12 ),  (
							      								    								  18 ,	4 ),  ( -14 ,  36 ),  ( -10 ,  32 ),  ( 6 ,
							      								    								   16 ),  ( 8 ,	 14 ),	( 10 ,	12 ),  ( 18 ,  4 ),
							      								    								   ( 6 ,  16 ),	 ( 8 ,	14 ),  ( 10 ,  12 ),  ( 24 ,
							      								    								    -2 ),  ( -16 ,  38 ),  ( -12 ,  34 ),  ( -10 ,
							      								    								  32 ),	 ( 6 ,	16 ),  ( 10 ,  12 ),  ( 20 ,  2 ),
							      								    								  ( -10 ,  32 ),  ( 10 ,  12 ),	 ( 24 ,	 -2 ),	( -1
							      								    								  4 ,  36 ),  ( -12 ,  34 ),  ( -10 ,  32 ),  ( 20 ,
							      								    								    2 ),  ( 4 ,	 18 ),	( 18 ,	4 ),  ( 24 ,  -2 ),
							      								    								   ( -10 ,  32 ),  ( 18 ,  4 ),	 ( 24 ,	 -2 ),	( 8
							      								    								  ,  14 ),  ( 10 ,  12 ),  ( 18 ,  4 ),	 ( -14 ,  36
							      								    								   ),  ( 4 ,  18 ),  ( 24 ,  -2 ),  ( -16 ,  38 ),
							      								    								  ( -6 ,  28 ),	 ( 18 ,	 4 ),  ( 22 ,  0 ),  ( 34 ,
							      								    								   -12 ),  ( -18 ,  40 ),  ( -14 ,  36 ),  ( 2 ,  20
							      								    								   ),  ( 16 ,  6 ),  ( 18 ,  4 ),  ( 28 ,  -6 ),  (
							      								    								  34 ,	-12 ),	( 14 ,	8 ),  ( 16 ,  6 ),  ( 22 ,
							      								    								  0 ),	( 28 ,	-6 ),  ( -16 ,	38 ),  ( -12 ,	34 )
							      								    								  ,  ( -6 ,  28 ),  ( 2 ,  20 ),  ( 36 ,  -14 ),  (
							      								    								  -24 ,	 46 ),	( 2 ,  20 ),  ( 34 ,  -12 ),  ( 28 ,
							      								    								    -6 ),  ( 34 ,  -12 ),  ( -14 ,  36 ),  ( -12 ,
							      								    								  34 ),	 ( 14 ,	 8 ),  ( 2 ,  20 ),  ( 4 ,  18 ),  (
							      								    								   14 ,	 8 ),  ( 18 ,  4 ),  ( 22 ,  0 ),  ( 16 ,  6
							      								    								   ),  ( 18 ,  4 ),  ( 22 ,  0 ),  ( 34 ,  -12 ),  (
							      								    								   16 ,	 6 ),  ( 18 ,  4 ),  ( 28 ,  -6 ),  ( 36 ,
							      								    								  -14 ),  ( -14 ,  36 ),  ( -6 ,  28 ),	 ( 4 ,	18 )
							      								    								  ,  ( 14 ,  8 ),  ( 22 ,  0 ),	 ( 34 ,	 -12 ),	 ( 3
							      								    								  6 ,  -14 ),  ( 12 ,  10 ),  ( 28 ,  -6 ),  ( 0 ,
							      								    								  22 ),	 ( 24 ,	 -2 ),	( 28 ,	-6 ),  ( -16 ,	38 )
							      								    								  ,  ( -12 ,  34 ),  ( 38 ,  -16 ),  ( 12 ,  10 ),
							      								    								  ( 24 ,  -2 ),	 ( 38 ,	 -16 ),	 ( 28 ,	 -6 ),	( -1
							      								    								  2 ,  34 ),  ( 0 ,  22 ),  ( 12 ,  10 ),  ( 4 ,  18
							      								    								   ),  ( 24 ,  -2 ),  ( 12 ,  10 ),  ( 24 ,  -2 ),
							      								    								  ( 12 ,  10 ),	 ( 28 ,	 -6 ),	( 0 ,  22 ),  ( 4 ,
							      								    								   18 ),  ( 12 ,  10 ),	 ( 24 ,	 -2 ),	( 6 ,  16 ),
							      								    								    ( 10 ,  12 ),  ( 14 ,  8 ),	 ( 16 ,	 6 ),  ( -12
							      								    								   ,  34 ),  ( -10 ,  32 ),  ( -6 ,  28 ),  ( 6 ,  1
							      								    								  6 ),	( 10 ,	12 ),  ( 20 ,  2 ),  ( 36 ,  -14 ),
							      								    								   ( -22 ,  44 ),  ( -10 ,  32 ),  ( 10 ,  12 ),  (
							      								    								  12 ,	10 ),  ( 42 ,  -20 ),  ( -22 ,	44 ),  ( -12
							      								    								   ,  34 ),  ( -10 ,  32 ),  ( 12 ,  10 ),  ( 14 ,
							      								    								  8 ),	( 20 ,	2 ),  ( 32 ,  -10 ),  ( 40 ,  -18 ),
							      								    								    ( 4 ,  18 ),  ( 14 ,  8 ),	( -10 ,	 32 ),	( 12
							      								    								   ,  10 ),  ( 16 ,  6 ),  ( 32 ,  -10 ),  ( 40 ,  -
							      								    								  18 ),	 ( 42 ,	 -20 ),	 ( 10 ,	 12 ),	( 12 ,	10 )
							      								    								  ,  ( 16 ,  6 ),  ( 36 ,  -14 ),  ( -6 ,  28 ),  (
							      								    								  4 ,  18 ),  ( 12 ,  10 ),  ( 14 ,  8 ),  ( 36 ,  -
							      								    								  14 ),	 ( 36 ,	 -14 ),	 ( -6 ,	 28 ),	( 6 ,  16 ),
							      								    								    ( -24 ,  46 ),  ( 12 ,  10 ),  ( -2 ,  24 ),  (
							      								    								  0 ,  22 ),  ( 12 ,  10 ),  ( 14 ,  8 ),  ( 14 ,  8
							      								    								   ),  ( 22 ,  0 ),  ( -2 ,  24 ),  ( 12 ,  10 ),  (
							      								    								   16 ,	 6 ),  ( 22 ,  0 ),  ( -2 ,  24 ),  ( 8 ,  1
							      								    								  4 ),	( 8 ,  14 ),  ( 12 ,  10 ),  ( 16 ,  6 ),  (
							      								    								   -6 ,	 28 ),	( 0 ,  22 ),  ( 12 ,  10 ),  ( 14 ,
							      								    								   8 ),	 ( 22 ,	 0 ),  ( 2 ,  20 ),  ( 12 ,  10 ),
							      								    								  ( 34 ,  -12 ),  ( 38 ,  -16 ),  ( 28 ,  -6 ),	 ( 3
							      								    								  4 ,  -12 ),  ( -14 ,	36 ),  ( 12 ,  10 ),  ( 20 ,
							      								    								    2 ),  ( 32 ,  -10 ),  ( 2 ,	 20 ),	( 12 ,	10 )
							      								    								  ,  ( 16 ,  6 ),  ( 32 ,  -10 ),  ( 34 ,  -12 ),  (
							      								    								   12 ,	 10 ),	( 16 ,	6 ),  ( 28 ,  -6 ),  ( -14 ,
							      								    								    36 ),  ( 12 ,  10 ),  ( 34 ,  -12 ),  ( 42 ,  -2
							      								    								  0 ),	( 46 ,	-24 ),	( -12 ,	 34 ),	( -2 ,	24 )
							      								    								  ,  ( 12 ,  10 ),  ( 20 ,  2 ),  ( 32 ,  -10 ),  (
							      								    								  -2 ,	24 ),  ( 12 ,  10 ),  ( 32 ,  -10 ),  ( 42 ,
							      								    								    -20 ),  ( -2 ,  24 ),  ( 10 ,  12 ),  ( 12 ,  10
							      								    								   ),  ( 44 ,  -22 ),  ( -8 ,  30 ),  ( 12 ,  10 ),
							      								    								   ( 44 ,  -22 ),  ( -20 ,  42 ),  ( -12 ,  34 ),  (
							      								    								   -6 ,	 28 ),	( 2 ,  20 ),  ( 22 ,  0 ),  ( 24 ,
							      								    								  -2 ),	 ( -10 ,  32 ),	 ( 22 ,	 0 ),  ( 24 ,  -2 ),
							      								    								    ( 32 ,  -10 ),  ( 34 ,  -12 ),  ( 42 ,  -20 ),
							      								    								  ( 8 ,	 14 ),	( 10 ,	12 ),  ( 36 ,  -14 ),  ( 44
							      								    								  ,  -22 ),  ( 22 ,  0 ),  ( 24 ,  -2 ),  ( 34 ,  -1
							      								    								  2 ),	( 36 ,	-14 ),	( 44 ,	-22 ),	( -2 ,	24 )
							      								    								  ,  ( 18 ,  4 ),  ( -2 ,  24 ),  ( 8 ,	 14 ),	( 18
							      								    								   ,  4 ),  ( 0 ,  22 ),  ( 4 ,	 18 ),	( -2 ,	24 )
							      								    								  ,  ( 10 ,  12 ),  ( 0 ,  22 ),  ( 4 ,	 18 ),	( 24
							      								    								   ,  -2 ),  ( -14 ,  36 ),  ( -8 ,  30 ),  ( -6 ,
							      								    								  28 ),	 ( 4 ,	18 ),  ( 12 ,  10 ),  ( 14 ,  8 ),
							      								    								  ( 14 ,  8 ),	( 24 ,	-2 ),  (10, 5),	 (10, 5),  (
							      								    								  11, 4),  (11, 4),  (11, 4),  ( 5 ,  10 ),  ( 14 ,
							      								    								   1 ),	 ( 5 ,	10 ),  ( 11 ,  4 ),  ( 5 ,  10 ),  (
							      								    								   8 ,	7 ),  ( 6 ,  9 ),  ( 8 ,  7 ),	( 5 ,  10 ),
							      								    								    ( 14 ,  1 ),  ( 6 ,	 9 ),  ( 14 ,  1 ),  ( 6 ,
							      								    								  9 ),	( 5 ,  10 ),  ( 11 ,  4 ),  ( 8 ,  7 ),	 ( 1
							      								    								  1 ,  4 ),  ( 14 ,  1 ),  ( 5 ,  10 ),	 ( 6 ,	9 ),
							      								    								    ( 11 ,  4 ),  ( 14 ,  1 ),	( 11 ,	4 ),  ( 6 ,
							      								    								   9 ),	 ( 5 ,	10 ),  ( 14 ,  1 ),  ( 8 ,  7 ),  (
							      								    								  5 ,  10 ),  ( 10 ,  5 ),  ( 11 ,  4 ),  ( 5 ,	 10
							      								    								  ),  ( 1 ,  14 ),  ( 12 ,  3 ),  ( 5 ,	 10 ),	( 5
							      								    								  ,  10 ),  ( 11 ,  4 ),  ( 10 ,  5 ),	( 1 ,  14 ),
							      								    								    ( 11 ,  4 ),  ( 1 ,	 14 ),	( 5 ,  10 ),  ( 11 ,
							      								    								    4 ),  ( 11 ,  4 ),	( 12 ,	3 ),  ( 5 ,  10 ),
							      								    								  ( 10 ,  5 ),	( 12 ,	3 ),  ( 5 ,  10 ),  ( 12 ,
							      								    								  3 ),	( 5 ,  10 ),  ( 2 ,  13 ),  ( 5 ,  10 ),  (
							      								    								  2 ,  13 ),  ( 2 ,  13 ),  ( 4 ,  11 ),  ( 10 ,  5
							      								    								  ),  ( 4 ,  11 ),  ( 5 ,  10 ),  ( 12 ,  3 ),	( 4
							      								    								  ,  11 ),  ( 5 ,  10 ),  ( 10 ,  5 ),	( 12 ,	3 ),
							      								    								    ( 7 ,  8 ),	 ( 7 ,	8 ),  ( 10 ,  5 ),  ( 7 ,  8
							      								    								   ),  ( 10 ,  5 ),  ( 9 ,  6 ),  ( 9 ,	 6 ),  ( 7 ,
							      								    								    8 ),  ( 8 ,	 7 ),  ( 7 ,  8 ),  ( 8 ,  7 ),	 ( 1
							      								    								  4 ,  1 ),  ( 3 ,  12 ),  ( 14 ,  1 ),	 ( 2 ,	13 )
							      								    								  ,  ( 2 ,  13 ),  ( 3 ,  12 ),	 ( 2 ,	13 ),  ( 14
							      								    								  ,  1 ),  ( 14 ,  1 ),	 ( 3 ,	12 ),  ( 12 ,  3 ),
							      								    								   ( 12 ,  3 ),	 ( 14 ,	 1 ),  ( 10 ,  5 ),  ( 1 ,
							      								    								  14 ),	 ( 1 ,	14 ),  ( 10 ,  5 ),  ( 6 ,  9 ),  (
							      								    								  6 ,  9 ),  ( 6 ,  9 ),  ( 6 ,	 9 ),  ( 12 ,  3 ),
							      								    								   ( 12 ,  3 ),	 ( 9 ,	6 ),  ( 1 ,  14 ),  ( 1 ,  1
							      								    								  4 ),	( 13 ,	2 ),  ( 6 ,  9 ),  ( 6 ,  9 ),	( 8
							      								    								  ,  7 ),  ( 10 ,  5 ),	 ( 10 ,	 5 ),  ( 8 ,  7 ),
							      								    								  ( 2 ,	 13 ),	( 4 ,  11 ),  ( 4 ,  11 ),  ( 12 ,
							      								    								  3 ),	( 4 ,  11 ),  ( 12 ,  3 ),  ( 7 ,  8 ),	 ( 1
							      								    								  1 ,  4 ),  ( 5 ,  10 ),  ( 11 ,  4 ),	 ( 11 ,	 4 )
							      								    								  ,  ( 5 ,  10 ),  ( 1 ,  14 ),	 ( 4 ,	11 ),  ( 14
							      								    								  ,  1 ),  ( 4 ,  11 ),	 ( 14 ,	 1 ),  ( 8 ,  7 ),
							      								    								  ( 11 ,  4 ),	( 4 ,  11 ),  ( 10 ,  5 ),  ( 14 ,
							      								    								  1 ),	( 4 ,  11 ),  ( 12 ,  3 ),  #Results: 0, 10
							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1		      FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1		    FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1		  FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1
--							      --							    --								  --
static int count ( String a , String b ) {		      def count ( a , b ) :					    def count ( a , b ) :					  success : None
  int m = a . length ( ) ;				      	  m = len ( a )						    	m = len ( a )						  
  int n = b . length ( ) ;				      	  n = len ( b )						    	n = len ( b )						  
  int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	  lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]   	lookup = np.zeros ( ( m + 1 , n + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( n + 1 ) :				    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      lookup [ 0 ] [ i ] = 0				    	    lookup [ 0 ] [ i ] = 0				  
  ++ i ) lookup [ 0 ] [ i ] = 0 ;			      	  for i in range ( m + 1 ) :				    	for i in range ( 0 , m + 1 ) :				  
  for ( int i = 0 ;					      	      lookup [ i ] [ 0 ] = 1				    	    lookup [ i ] [ 0 ] = 1				  
  i <= m ;						      	  for i in range ( 1 , m + 1 ) :			    	for i in range ( 1 , m + 1 ) :				  
  ++ i ) lookup [ i ] [ 0 ] = 1 ;			      	      for j in range ( 1 , n + 1 ) :			    	    for j in range ( 1 , n + 1 ) :			  
  for ( int i = 1 ;					      		  if a [ i - 1 ] == b [ j - 1 ] :		    		if a [ i - 1 ] == b [ j - 1 ] :			  
  i <= m ;						      		      lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 		    lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 
  i ++ ) {						      		  else :					    		else :						  
    for ( int j = 1 ;					      		      lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]   		    lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]	  
    j <= n ;						      	  return lookup [ m ] [ n ]				    	return lookup [ m ] [ n ]				  
    j ++ ) {						      								    								  
      if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) loo 								    								  
      else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ;      								    								  
    }							      								    								  
  }							      								    								  
  return lookup [ m ] [ n ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HIGHWAY_BILLBOARD_PROBLEM				      HIGHWAY_BILLBOARD_PROBLEM					    HIGHWAY_BILLBOARD_PROBLEM					  HIGHWAY_BILLBOARD_PROBLEM
--							      --							    --								  --
static int maxRevenue ( int m , int [ ] x , int [ ] revenue , def maxRevenue ( m , x , revenue , n , t ) :		    def max_revenue ( m , x , revenue , n , t ) :		  success : None
  int [ ] maxRev = new int [ m + 1 ] ;			      	  maxRev = [ 0 ] * ( m + 1 )				    	max_rev = [ 0 for i in range ( m + 1 ) ]		  
  for ( int i = 0 ;					      	  nxtbb = 0						    	nxtbb = 0						  
  i < m + 1 ;						      	  for i in range ( 1 , m + 1 ) :			    	for i in range ( 1 , m + 1 ) :				  
  i ++ ) maxRev [ i ] = 0 ;				      	      if ( nxtbb < n ) :				    	    if nxtbb < n :					  
  int nxtbb = 0 ;					      		  if ( x [ nxtbb ] != i ) :			    		if x [ nxtbb ] != i :				  
  for ( int i = 1 ;					      		      maxRev [ i ] = maxRev [ i - 1 ]		    		    max_rev [ i ] = max_rev [ i - 1 ]		  
  i <= m ;						      		  else :					    		else :						  
  i ++ ) {						      		      if ( i <= t ) :				    		    if i <= t :					  
    if ( nxtbb < n ) {					      			  maxRev [ i ] = max ( maxRev [ i - 1 ] , r 			max_rev [ i ] = max ( max_rev [ i - 1 ] , 
      if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] 		      else :					    		    else :					  
      else {						      			  maxRev [ i ] = max ( maxRev [ i - t - 1 ] 			max_rev [ i ] = max ( max_rev [ i - t - 1 
	if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i  		      nxtbb += 1				    		    nxtbb += 1					  
	else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] 	      else :						    	    else :						  
	nxtbb ++ ;					      		  maxRev [ i ] = maxRev [ i - 1 ]		    		max_rev [ i ] = max_rev [ i - 1 ]		  
      }							      	  return maxRev [ m ]					    	return max_rev [ m ]					  
    }							      								    								  
    else maxRev [ i ] = maxRev [ i - 1 ] ;		      								    								  
  }							      								    								  
  return maxRev [ m ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES	      MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES	    MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES	  MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES
--							      --							    --								  --
static int maximumDifferenceSum ( int arr [ ] , int N ) {     def maximumDifferenceSum ( arr , N ) :			    def maximum_difference_sum ( arr , N ) :			  script_not_found : None
  int dp [ ] [ ] = new int [ N ] [ 2 ] ;		      	  dp = [ [ 0 , 0 ] for i in range ( N ) ]		    	dp = np.zeros ( ( N , 2 ) )				  
  for ( int i = 0 ;					      	  for i in range ( N ) :				    	for i in range ( N ) :					  
  i < N ;						      	      dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0		    	    dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0			  
  i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ;		      	  for i in range ( N - 1 ) :				    	for i in range ( ( N - 1 ) ) :				  
  for ( int i = 0 ;					      	      dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ]  	    dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ]  
  i < ( N - 1 ) ;					      	      dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr 	    dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr 
  i ++ ) {						      	  return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] )    	return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] )	  
    dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i 								    								  
    dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . 								    								  
  }							      								    								  
  return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS			      FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS			    FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS			  FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS
--							      --							    --								  --
static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2  def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) :		    def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) :		  script_not_found : None
  if ( k > n1 * n2 ) {					      	  if ( k > n1 * n2 ) :					    	if k > n1 * n2 :					  
    System . out . print ( "k pairs don't exist" ) ;	      	      print ( "k pairs don't exist" )			    	    print ( "k pairs don't exist" , end = " " )		  
    return ;						      	      return						    	    return						  
  }							      	  index2 = [ 0 for i in range ( n1 ) ]			    	index2 = [ 0 ] * n1					  
  int index2 [ ] = new int [ n1 ] ;			      	  while ( k > 0 ) :					    	while k > 0 :						  
  while ( k > 0 ) {					      	      min_sum = sys.maxsize				    	    minSum = sys.maxsize				  
    int min_sum = Integer . MAX_VALUE ;			      	      min_index = 0					    	    minIndex = 0					  
    int min_index = 0 ;					      	      for i1 in range ( 0 , n1 , 1 ) :			    	    for i1 in range ( n1 ) :				  
    for ( int i1 = 0 ;					      		  if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [  		if index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [ in 
    i1 < n1 ;						      		      min_index = i1				    		    minIndex = i1				  
    i1 ++ ) {						      		      min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ]  		    minSum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] 
      if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2  	      print ( "(" , arr1 [ min_index ] , "," , arr2 [ index 	    print ( "(%d, %d) " % ( arr1 [ minIndex ] , arr2 [ in 
	min_index = i1 ;				      	      index2 [ min_index ] += 1				    	    index2 [ minIndex ] += 1				  
	min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ;      	      k -= 1						    	    k -= 1						  
      }							      								    								  
    }							      								    								  
    System . out . print ( "(" + arr1 [ min_index ] + ", " +  								    								  
    index2 [ min_index ] ++ ;				      								    								  
    k -- ;						      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU
--							      --							    --								  --
static void findSmallest ( int m , int s ) {		      def findSmallest ( m , s ) :				    def find_smallest ( m , s ) :				  script_not_found : None
  if ( s == 0 ) {					      	  if ( s == 0 ) :					    	if s == 0 :						  
    System . out . print ( m == 1 ? "Smallest number is 0" :  	      if ( m == 1 ) :					    	    print ( m == 1 and "Smallest number is 0" or "Not pos 
    return ;						      		  print ( "Smallest number is 0" )		    	    return						  
  }							      	      else :						    	if s > 9 * m :						  
  if ( s > 9 * m ) {					      		  print ( "Not possible" )			    	    print ( "Not possible" )				  
    System . out . println ( "Not possible" ) ;		      	      return						    	    return						  
    return ;						      	  if ( s > 9 * m ) :					    	res = [ 0 ] * m						  
  }							      	      print ( "Not possible" )				    	s -= 1							  
  int [ ] res = new int [ m ] ;				      	      return						    	for i in range ( m - 1 , 0 , - 1 ) :			  
  s -= 1 ;						      	  res = [ 0 for i in range ( m + 1 ) ]			    	    if s > 9 :						  
  for ( int i = m - 1 ;					      	  s -= 1						    		res [ i ] = 9					  
  i > 0 ;						      	  for i in range ( m - 1 , 0 , - 1 ) :			    		s -= 9						  
  i -- ) {						      	      if ( s > 9 ) :					    	    else :						  
    if ( s > 9 ) {					      		  res [ i ] = 9					    		res [ i ] = s					  
      res [ i ] = 9 ;					      		  s -= 9					    		s = 0						  
      s -= 9 ;						      	      else :						    	res [ 0 ] = s + 1					  
    }							      		  res [ i ] = s					    	print ( "Smallest number is " , end = " " )		  
    else {						      		  s = 0						    	for i in range ( m ) :					  
      res [ i ] = s ;					      	  res [ 0 ] = s + 1					    	    print ( res [ i ] , end = " " )			  
      s = 0 ;						      	  print ( "Smallest number is " , end = "" )		    								  
    }							      	  for i in range ( m ) :				    								  
  }							      	      print ( res [ i ] , end = "" )			    								  
  res [ 0 ] = s + 1 ;					      								    								  
  System . out . print ( "Smallest number is " ) ;	      								    								  
  for ( int i = 0 ;					      								    								  
  i < m ;						      								    								  
  i ++ ) System . out . print ( res [ i ] ) ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER		      CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER		    CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER			  CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER
--							      --							    --								  --
static boolean check ( String s1 , String s2 ) {	      def check ( s1 , s2 ) :					    def check ( s1 , s2 ) :					  failure : #Results: 8, 10
  int n = s1 . length ( ) ;				      	  n = len ( s1 )					    	n = len ( s1 )						  
  int m = s2 . length ( ) ;				      	  m = len ( s2 )					    	m = len ( s2 )						  
  boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ;      	  dp = ( [ [ False for i in range ( m + 1 ) ] for i in rang 	dp = np.zeros ( ( n + 1 , m + 1 ) )			  
  for ( int i = 0 ;					      	  dp [ 0 ] [ 0 ] = True					    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	  for i in range ( len ( s1 ) ) :			    	    for j in range ( 0 , m + 1 ) :			  
  i ++ ) {						      	      for j in range ( len ( s2 ) + 1 ) :		    		dp [ i ] [ j ] = False				  
    for ( int j = 0 ;					      		  if ( dp [ i ] [ j ] ) :			    	dp [ 0 ] [ 0 ] = True					  
    j <= m ;						      		      if ( ( j < len ( s2 ) and ( s1 [ i ].upper (  	for i in range ( len ( s1 ) ) :				  
    j ++ ) {						      			  dp [ i + 1 ] [ j + 1 ] = True		    	    for j in range ( 0 , len ( s2 ) ) :			  
      dp [ i ] [ j ] = false ;				      		      if ( s1 [ i ].isupper ( ) == False ) :	    		if dp [ i ] [ j ] :				  
    }							      			  dp [ i + 1 ] [ j ] = True		    		    if j < len ( s2 ) and ( s1 [ i ].upper ( ) == 
  }							      	  return ( dp [ n ] [ m ] )				    			dp [ i + 1 ] [ j + 1 ] = True		  
  dp [ 0 ] [ 0 ] = true ;				      								    		    if not s1 [ i ].isupper ( ) :		  
  for ( int i = 0 ;					      								    			dp [ i + 1 ] [ j ] = True		  
  i < s1 . length ( ) ;					      								    	return ( dp [ n ] [ m ] )				  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j <= s2 . length ( ) ;				      								    								  
    j ++ ) {						      								    								  
      if ( dp [ i ] [ j ] ) {				      								    								  
	if ( j < s2 . length ( ) && ( Character . toUpperCase 								    								  
	if ( ! Character . isUpperCase ( s1 . charAt ( i ) )  								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return ( dp [ n ] [ m ] ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN
--							      --							    --								  --
static int countWords ( String str , int len ) {	      def countWords ( str , l ) :				    def count_words ( str , len_ ) :				  script_not_found : None
  int count = 1 ;					      	  count = 1 ;						    	count = 1						  
  if ( len == 1 ) return count ;			      	  if ( l == 1 ) :					    	if len_ == 1 :						  
  if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1  	      return count					    	    return count					  
  else count *= 2 ;					      	  if ( str [ 0 ] == str [ 1 ] ) :			    	if str [ 0 ] == str [ 1 ] :				  
  for ( int j = 1 ;					      	      count *= 1					    	    count *= 1						  
  j < len - 1 ;						      	  else :						    	else :							  
  j ++ ) {						      	      count *= 2					    	    count *= 2						  
    if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str  	  for j in range ( 1 , l - 1 ) :			    	for j in range ( 1 , len_ - 1 ) :			  
    else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || 	      if ( str [ j ] == str [ j - 1 ] and str [ j ] == str  	    if str [ j ] == str [ j - 1 ] and str [ j ] == str [  
    else count *= 3 ;					      		  count *= 1					    		count *= 1					  
  }							      	      elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str 	    elif str [ j ] in [ str [ j - 1 ] , str [ j ] + str [ 
  if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) 		  count *= 2					    		count *= 2					  
  else count *= 2 ;					      	      else :						    	    else :						  
  return count ;					      		  count *= 3					    		count *= 3					  
}							      	  if ( str [ l - 1 ] == str [ l - 2 ] ) :		    	if str [ len_ - 1 ] == str [ len_ - 2 ] :		  
							      	      count *= 1					    	    count *= 1						  
							      	  else :						    	else :							  
							      	      count *= 2					    	    count *= 2						  
							      	  return count						    	return count						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX	      MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX	    MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX		  MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX
--							      --							    --								  --
public static int maxCost ( int mat [ ] [ ] , int N ) {	      def maxCost ( mat , N ) :					    def max_cost ( mat , N ) :					  error : Traceback (most recent call last):   File
  int dp [ ] [ ] = new int [ N ] [ N ] ;		      	  dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ]  	dp = np.zeros ( ( N , N ) )				  "dump/transcoder_st/eval/java_python/online_st/206
  dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ;			      	  dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ]			    	dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ]			  68770/eval_scripts/java_sa-python_sa.test/MAXIMUM_
  for ( int i = 1 ;					      	  for i in range ( 1 , N ) :				    	for i in range ( 1 , N ) :				  WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX.py", li
  i < N ;						      	      dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] 	    dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ne 63, in <module>	 if f_filled(*parameters_set
  i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0  	  for i in range ( 1 , N ) :				    	for i in range ( 1 , N ) :				  ) == f_gold(*parameters_set):	  File "dump/transco
  for ( int i = 1 ;					      	      for j in range ( 1 , min ( i + 1 , N ) ) :	    	    for j in range ( 1 , i + 1 and j < N ) :		  der_st/eval/java_python/online_st/20668770/eval_sc
  i < N ;						      		  dp [ i ] [ j ] = mat [ i ] [ j ] + \		    		dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - ripts/java_sa-python_sa.test/MAXIMUM_WEIGHT_PATH_E
  i ++ ) for ( int j = 1 ;				      		      max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ 	result = 0						  NDING_ELEMENT_LAST_ROW_MATRIX.py", line 39, in f_f
  j < i + 1 && j < N ;					      	  result = 0						    	for i in range ( N ) :					  illed	    for j in range ( 1 , i + 1 and j < N ) :
  j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ 	  for i in range ( N ) :				    	    if result < dp [ N - 1 ] [ i ] :			   UnboundLocalError: local variable 'j' referenced
  int result = 0 ;					      	      if ( result < dp [ N - 1 ] [ i ] ) :		    		result = dp [ N - 1 ] [ i ]			  before assignment
  for ( int i = 0 ;					      		  result = dp [ N - 1 ] [ i ]			    	return result						  
  i < N ;						      	  return result						    								  
  i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1		      LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1		    LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1		  LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1
--							      --							    --								  --
static int lcsOf3 ( int i , int j , int k ) {		      def lcsOf3 ( i , j , k ) :				    def lcsOf3 ( i , j , k ) :					  script_not_found : None
  if ( i == - 1 || j == - 1 || k == - 1 ) {		      	  if ( i == - 1 or j == - 1 or k == - 1 ) :		    	if i == - 1 or j == - 1 or k == - 1 :			  
    return 0 ;						      	      return 0						    	    return 0						  
  }							      	  if ( dp [ i ] [ j ] [ k ] != - 1 ) :			    	if dp [ i ] [ j ] [ k ] != - 1 :			  
  if ( dp [ i ] [ j ] [ k ] != - 1 ) {			      	      return dp [ i ] [ j ] [ k ]			    	    return dp [ i ] [ j ] [ k ]				  
    return dp [ i ] [ j ] [ k ] ;			      	  if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) :	    	if X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] :		  
  }							      	      dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k 	    return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j  
  if ( X . charAt ( i ) == Y . charAt ( j ) && Y . charAt ( j 	      return dp [ i ] [ j ] [ k ]			    	else :							  
    return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1  	  else :						    	    return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i  
  }							      	      dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j 								  
  else {						      	      return dp [ i ] [ j ] [ k ]			    								  
    return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( l 								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MERGING_INTERVALS					      MERGING_INTERVALS						    MERGING_INTERVALS						  MERGING_INTERVALS
--							      --							    --								  --
public static void mergeIntervals ( Interval arr [ ] ) {      def mergeIntervals ( arr ) :				    def merge_intervals ( arr ) :				  script_not_found : None
  Arrays . sort ( arr , new Comparator < Interval > ( ) {     	  arr.sort ( key = lambda x : x [ 0 ] )			    	arr.sort ( key = lambda i1 , i2 : i2.start - i1.start )	  
    public int compare ( Interval i1 , Interval i2 ) {	      	  m = [ ]						    	index = 0						  
      return i2 . start - i1 . start ;			      	  s = - 10000						    	for i in range ( 1 , len ( arr ) ) :			  
    }							      	  max = - 100000					    	    if arr [ index ].end >= arr [ i ].start :		  
  }							      	  for i in range ( len ( arr ) ) :			    		arr [ index ].end = max ( arr [ index ].end , arr 
  ) ;							      	      a = arr [ i ]					    		arr [ index ].start = min ( arr [ index ].start , 
  int index = 0 ;					      	      if a [ 0 ] > max :				    	    else :						  
  for ( int i = 1 ;					      		  if i != 0 :					    		arr [ index ] = arr [ i ]			  
  i < arr . length ;					      		      m.append ( [ s , max ] )			    		index += 1					  
  i ++ ) {						      		  max = a [ 1 ]					    	print ( "The Merged Intervals are: " , end = "" )	  
    if ( arr [ index ] . end >= arr [ i ] . start ) {	      		  s = a [ 0 ]					    	for i in range ( 0 , index + 1 ) :			  
      arr [ index ] . end = Math . max ( arr [ index ] . end  	      else :						    	    print ( "[%d,%d]" % ( arr [ i ].start , arr [ i ].end 
      arr [ index ] . start = Math . min ( arr [ index ] . st 		  if a [ 1 ] >= max :				    								  
    }							      		      max = a [ 1 ]				    								  
    else {						      	  if max != - 100000 and [ s , max ] not in m :		    								  
      arr [ index ] = arr [ i ] ;			      	      m.append ( [ s , max ] )				    								  
      index ++ ;					      	  print ( "The Merged Intervals are :" , end = " " )	    								  
    }							      	  for i in range ( len ( m ) ) :			    								  
  }							      	      print ( m [ i ] , end = " " )			    								  
  System . out . print ( "The Merged Intervals are: " ) ;     								    								  
  for ( int i = 0 ;					      								    								  
  i <= index ;						      								    								  
  i ++ ) {						      								    								  
    System . out . print ( "[" + arr [ i ] . start + "," + ar 								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM			      PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM			    PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM				  PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM
--							      --							    --								  --
static void spiralPrint ( int m , int n , int a [ ] [ ] ) {   def spiralPrint ( m , n , a ) :				    def spiralPrint ( m , n , a ) :				  script_not_found : None
  int i , k = 0 , l = 0 ;				      	  k = 0 l = 0						    	i , k , l = 0 , 0 , 0					  
  while ( k < m && l < n ) {				      	  while ( k < m and l < n ) :				    	while k < m and l < n :					  
    for ( i = l ;					      	      for i in range ( l , n ) :			    	    for i in range ( l , n ) :				  
    i < n ;						      		  print ( a [ k ] [ i ] , end = " " )		    		print ( a [ k ] [ i ] , end = ' ' )		  
    ++ i ) {						      	      k += 1						    	    k += 1						  
      System . out . print ( a [ k ] [ i ] + " " ) ;	      	      for i in range ( k , m ) :			    	    for i in range ( k , m ) :				  
    }							      		  print ( a [ i ] [ n - 1 ] , end = " " )	    		print ( a [ i ] [ n - 1 ] , end = ' ' )		  
    k ++ ;						      	      n -= 1						    	    n -= 1						  
    for ( i = k ;					      	      if ( k < m ) :					    	    if k < m :						  
    i < m ;						      		  for i in range ( n - 1 , ( l - 1 ) , - 1 ) :	    		for i in range ( n - 1 , l - 1 , - 1 ) :	  
    ++ i ) {						      		      print ( a [ m - 1 ] [ i ] , end = " " )	    		    print ( a [ m - 1 ] [ i ] , end = ' ' )	  
      System . out . print ( a [ i ] [ n - 1 ] + " " ) ;      		  m -= 1					    		m -= 1						  
    }							      	      if ( l < n ) :					    	    if l < n :						  
    n -- ;						      		  for i in range ( m - 1 , k - 1 , - 1 ) :	    		for i in range ( m - 1 , k , - 1 ) :		  
    if ( k < m ) {					      		      print ( a [ i ] [ l ] , end = " " )	    		    print ( a [ i ] [ l ] , end = ' ' )		  
      for ( i = n - 1 ;					      		  l += 1					    		l += 1						  
      i >= l ;						      								    								  
      -- i ) {						      								    								  
	System . out . print ( a [ m - 1 ] [ i ] + " " ) ;    								    								  
      }							      								    								  
      m -- ;						      								    								  
    }							      								    								  
    if ( l < n ) {					      								    								  
      for ( i = m - 1 ;					      								    								  
      i >= k ;						      								    								  
      -- i ) {						      								    								  
	System . out . print ( a [ i ] [ l ] + " " ) ;	      								    								  
      }							      								    								  
      l ++ ;						      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY			      MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY			    MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY				  MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY
--							      --							    --								  --
static double largestSumOfAverages ( int [ ] A , int K ) {    def largestSumOfAverages ( A , K ) :			    def largestSumOfAverages ( A , K ) :			  failure : #Results: 9, 10
  int n = A . length ;					      	  n = len ( A )						    	n = len ( A )						  
  double [ ] pre_sum = new double [ n + 1 ] ;		      	  pre_sum = [ 0 ] * ( n + 1 )				    	preSum = [ 0 ] * ( n + 1 )				  
  pre_sum [ 0 ] = 0 ;					      	  pre_sum [ 0 ] = 0					    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	    preSum [ i + 1 ] = preSum [ i ] + A [ i ]		  
  i < n ;						      	      pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ]	    	dp = [ 0 ] * n						  
  i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ;	      	  dp = [ 0 ] * n					    	sum = 0							  
  double [ ] dp = new double [ n ] ;			      	  sum = 0						    	for i in range ( n ) :					  
  double sum = 0 ;					      	  for i in range ( n ) :				    	    dp [ i ] = ( preSum [ n ] - preSum [ i ] ) / ( n - i  
  for ( int i = 0 ;					      	      dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n -  	for k in range ( K - 1 ) :				  
  i < n ;						      	  for k in range ( K - 1 ) :				    	    for i in range ( n ) :				  
  i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - 	      for i in range ( n ) :				    		for j in range ( i + 1 , n ) :			  
  for ( int k = 0 ;					      		  for j in range ( i + 1 , n ) :		    		    dp [ i ] = max ( dp [ i ] , ( preSum [ j ] -  
  k < K - 1 ;						      		      dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - 	return dp [ 0 ]						  
  k ++ ) for ( int i = 0 ;				      	  return int ( dp [ 0 ] )				    								  
  i < n ;						      								    								  
  i ++ ) for ( int j = i + 1 ;				      								    								  
  j < n ;						      								    								  
  j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - 								    								  
  return dp [ 0 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS     NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS	    NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS	  NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS
--							      --							    --								  --
static int waysToArrange ( int N , int K , int [ ] k ) {      def waysToArrange ( N , K , k ) :				    def ways_to_arrows ( N , K , k ) :				  script_not_found : None
  int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ] ;		      	  C = np.zeros ( ( N + 1 , N + 1 ) )			    	C = np.zeros ( ( N + 1 , N + 1 ) )			  
  int i , j ;						      	  for i in range ( N + 1 ) :				    	i , j = 0 , 0						  
  for ( i = 0 ;						      	      for j in range ( i + 1 ) :			    	for i in range ( 0 , N + 1 ) :				  
  i <= N ;						      		  if ( j == 0 or j == i ) :			    	    for j in range ( 0 , i + 1 ) :			  
  i ++ ) {						      		      C [ i ] [ j ] = 1				    		if j == 0 or j == i :				  
    for ( j = 0 ;					      		  else :					    		    C [ i ] [ j ] = 1				  
    j <= i ;						      		      C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ 		else :						  
    j ++ ) {						      	  dp = np.zeros ( ( K + 1 ) )				    		    C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ 
      if ( j == 0 || j == i ) {				      	  count = 0						    	dp = np.zeros ( ( K + 1 , N + 1 ) )			  
	C [ i ] [ j ] = 1 ;				      	  dp [ 0 ] = 1						    	count = 0						  
      }							      	  for i in range ( K ) :				    	dp [ 0 ] = 1						  
      else {						      	      dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] 	for i in range ( K ) :					  
	C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] 	      count += k [ i ]					    	    dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] 
      }							      	  return dp [ K ]					    	    count += k [ i ]					  
    }							      								    	return dp [ K ]						  
  }							      								    								  
  int [ ] dp = new int [ K + 1 ] ;			      								    								  
  int count = 0 ;					      								    								  
  dp [ 0 ] = 1 ;					      								    								  
  for ( i = 0 ;						      								    								  
  i < K ;						      								    								  
  i ++ ) {						      								    								  
    dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k 								    								  
    count += k [ i ] ;					      								    								  
  }							      								    								  
  return dp [ K ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
static void NextFit ( int blockSize [ ] , int m , int process def NextFit ( blockSize , m , processSize , n ) :		    def NextFit ( blockSize , m , processSize , n ) :		  script_not_found : None
  int allocation [ ] = new int [ n ] , j = 0 ;		      	  allocation = [ - 1 ] * n				    	allocation , j = [ 0 ] * n , 0				  
  Arrays . fill ( allocation , - 1 ) ;			      	  j = 0							    	allocation [ 0 ] = - 1					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      while j < m :					    	    while j < m :					  
  i ++ ) {						      		  if blockSize [ j ] >= processSize [ i ] :	    		if blockSize [ j ] >= processSize [ i ] :	  
    while ( j < m ) {					      		      allocation [ i ] = j			    		    allocation [ i ] = j			  
      if ( blockSize [ j ] >= processSize [ i ] ) {	      		      blockSize [ j ] -= processSize [ i ]	    		    blockSize [ j ] -= processSize [ i ]	  
	allocation [ i ] = j ;				      		      break					    		    break					  
	blockSize [ j ] -= processSize [ i ] ;		      		  j = ( j + 1 ) % m				    		j = ( j + 1 ) % m				  
	break ;						      	  print ( "Process No.Process Size Block no." )		    	print ( "\nProcess No.\tProcess Size\tBlock no.\n" , end  
      }							      	  for i in range ( n ) :				    	for i in range ( n ) :					  
      j = ( j + 1 ) % m ;				      	      print ( i + 1 , "		" , processSize [ i ] , end 	    print ( "%d\t\t%d\t\t" % ( i + 1 , processSize [ i ]  
    }							      	      if allocation [ i ] != - 1 :			    	    if allocation [ i ] != - 1 :			  
  }							      		  print ( allocation [ i ] + 1 )		    		print ( "%d\t\t" % ( allocation [ i ] + 1 ) , end 
  System . out . print ( "\nProcess No.\tProcess Size\tBlock  	      else :						    	    else :						  
  for ( int i = 0 ;					      		  print ( "Not Allocated" )			    		print ( "Not Allocated" , end = "" )		  
  i < n ;						      								    	    print ( "" )					  
  i ++ ) {						      								    								  
    System . out . print ( i + 1 + "\t\t" + processSize [ i ] 								    								  
    if ( allocation [ i ] != - 1 ) {			      								    								  
      System . out . print ( allocation [ i ] + 1 ) ;	      								    								  
    }							      								    								  
    else {						      								    								  
      System . out . print ( "Not Allocated" ) ;	      								    								  
    }							      								    								  
    System . out . println ( "" ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT
--							      --							    --								  --
static int maxNumOfChocolates ( int arr [ ] , int n , int k ) def maxNumOfChocolates ( arr , n , k ) :			    def maxNumOfChocolates ( arr , n , k ) :			  error : Traceback (most recent call last):   File
  HashMap < Integer , Integer > um = new HashMap < Integer ,  	  um , curr_rem , maxSum = { } , 0 , 0			    	um = { }						  "dump/transcoder_st/eval/java_python/online_st/206
  int [ ] sum = new int [ n ] ;				      	  sm = [ 0 ] * n					    	sum = [ 0 ] * n						  68770/eval_scripts/java_sa-python_sa.test/MAXIMUM_
  int curr_rem ;					      	  sm [ 0 ] = arr [ 0 ]					    	for i in range ( 1 , n ) :				  NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUD
  int maxSum = 0 ;					      	  for i in range ( 1 , n ) :				    	    sum [ i ] = sum [ i - 1 ] + arr [ i ]		  ENTS.py", line 66, in <module>     if f_filled(*pa
  sum [ 0 ] = arr [ 0 ] ;				      	      sm [ i ] = sm [ i - 1 ] + arr [ i ]		    	for i in range ( n ) :					  rameters_set) == f_gold(*parameters_set):   File "
  for ( int i = 1 ;					      	  for i in range ( n ) :				    	    currRem = sum [ i ] % k				  dump/transcoder_st/eval/java_python/online_st/2066
  i < n ;						      	      curr_rem = sm [ i ] % k				    	    if not currRem :					  8770/eval_scripts/java_sa-python_sa.test/MAXIMUM_N
  i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ;	      	      if ( not curr_rem and maxSum < sm [ i ] ) :	    		if maxSum < sum [ i ] :				  UMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDE
  for ( int i = 0 ;					      		  maxSum = sm [ i ]				    		    maxSum = sum [ i ]				  NTS.py", line 42, in f_filled	    if maxSum < sum
  i < n ;						      	      elif ( not curr_rem in um ) :			    	    elif not um.has_key ( currRem ) :			  [ i ] : UnboundLocalError: local variable 'maxSum'
  i ++ ) {						      		  um [ curr_rem ] = i				    		um [ currRem ] = i				   referenced before assignment
    curr_rem = sum [ i ] % k ;				      	      elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) 	    elif maxSum < ( sum [ i ] - sum [ um [ currRem ] ] )  
    if ( curr_rem == 0 ) {				      		  maxSum = sm [ i ] - sm [ um [ curr_rem ] ]	    		maxSum = sum [ i ] - sum [ um [ currRem ] ]	  
      if ( maxSum < sum [ i ] ) maxSum = sum [ i ] ;	      	  return maxSum // k					    	return ( maxSum / k )					  
    }							      								    								  
    else if ( ! um . containsKey ( curr_rem ) ) um . put ( cu 								    								  
    else if ( maxSum < ( sum [ i ] - sum [ um . get ( curr_re 								    								  
  }							      								    								  
  return ( maxSum / k ) ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_N_DIGIT_STEPPING_NUMBERS				      NUMBER_N_DIGIT_STEPPING_NUMBERS				    NUMBER_N_DIGIT_STEPPING_NUMBERS				  NUMBER_N_DIGIT_STEPPING_NUMBERS
--							      --							    --								  --
static long answer ( int n ) {				      def answer ( n ) :					    def answer ( n ) :						  failure : #Results: 7, 10
  int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ;		      	  dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 	dp = np.zeros ( ( n + 1 , 10 ) )			  
  if ( n == 1 ) return 10 ;				      	  if ( n == 1 ) :					    	if n == 1 :						  
  for ( int j = 0 ;					      	      return 10						    	    return 10						  
  j <= 9 ;						      	  for j in range ( 10 ) :				    	for j in range ( 0 , 9 + 1 ) :				  
  j ++ ) dp [ 1 ] [ j ] = 1 ;				      	      dp [ 1 ] [ j ] = 1				    	    dp [ 1 ] [ j ] = 1					  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	      for j in range ( 10 ) :				    	    for j in range ( 0 , 9 + 1 ) :			  
  i ++ ) {						      		  if ( j == 0 ) :				    		if j == 0 :					  
    for ( int j = 0 ;					      		      dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]	    		    dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]	  
    j <= 9 ;						      		  elif ( j == 9 ) :				    		elif j == 9 :					  
    j ++ ) {						      		      dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]	    		    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]	  
      if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; 		  else :					    		else :						  
      else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j -  		      dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + d 		    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp  
      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 	  sum = 0						    	sum = 0							  
    }							      	  for j in range ( 1 , 10 ) :				    	for j in range ( 1 , 9 + 1 ) :				  
  }							      	      sum = sum + dp [ n ] [ j ]			    	    sum += dp [ n ] [ j ]				  
  long sum = 0 ;					      	  return sum						    	return sum						  
  for ( int j = 1 ;					      								    								  
  j <= 9 ;						      								    								  
  j ++ ) sum += dp [ n ] [ j ] ;			      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTANCE_NEAREST_CELL_1_BINARY_MATRIX			      DISTANCE_NEAREST_CELL_1_BINARY_MATRIX			    DISTANCE_NEAREST_CELL_1_BINARY_MATRIX			  DISTANCE_NEAREST_CELL_1_BINARY_MATRIX
--							      --							    --								  --
static void printDistance ( int mat [ ] [ ] ) {		      def printDistance ( mat ) :				    def print_distance ( mat ) :				  script_not_found : None
  int ans [ ] [ ] = new int [ N ] [ M ] ;		      	  global N , M						    	ans = np.zeros ( ( N , M ) )				  
  for ( int i = 0 ;					      	  ans = [ [ None ] * M for i in range ( N ) ]		    	for i in range ( N ) :					  
  i < N ;						      	  for i in range ( N ) :				    	    for j in range ( M ) :				  
  i ++ ) for ( int j = 0 ;				      	      for j in range ( M ) :				    		ans [ i ] [ j ] = np.inf			  
  j < M ;						      		  ans [ i ] [ j ] = 999999999999		    	for i in range ( N ) :					  
  j ++ ) ans [ i ] [ j ] = Integer . MAX_VALUE ;	      	  for i in range ( N ) :				    	    for j in range ( M ) :				  
  for ( int i = 0 ;					      	      for j in range ( M ) :				    		for k in range ( N ) :				  
  i < N ;						      		  for k in range ( N ) :			    		    for l in range ( M ) :			  
  i ++ ) for ( int j = 0 ;				      		      for l in range ( M ) :			    			if mat [ k ] [ l ] == 1 :		  
  j < M ;						      			  if ( mat [ k ] [ l ] == 1 ) :		    			    ans [ i ] [ j ] = min ( ans [ i ] [ j 
  j ++ ) {						      			      ans [ i ] [ j ] = min ( ans [ i ] [ j 	for i in range ( N ) :					  
    for ( int k = 0 ;					      	  for i in range ( N ) :				    	    for j in range ( M ) :				  
    k < N ;						      	      for j in range ( M ) :				    		print ( ans [ i ] [ j ] , end = ' ' )		  
    k ++ ) for ( int l = 0 ;				      		  print ( ans [ i ] [ j ] , end = " " )		    	    print ( )						  
    l < M ;						      	      print ( )						    								  
    l ++ ) {						      								    								  
      if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . mi 								    								  
    }							      								    								  
  }							      								    								  
  for ( int i = 0 ;					      								    								  
  i < N ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j < M ;						      								    								  
    j ++ ) System . out . print ( ans [ i ] [ j ] + " " ) ;   								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PATH_MAXIMUM_AVERAGE_VALUE				      PATH_MAXIMUM_AVERAGE_VALUE				    PATH_MAXIMUM_AVERAGE_VALUE					  PATH_MAXIMUM_AVERAGE_VALUE
--							      --							    --								  --
public static double maxAverageOfPath ( int cost [ ] [ ] , in def maxAverageOfPath ( cost , N ) :			    def max_average_of_path ( cost , N ) :			  success : None
  int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ;	      	  dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N  	dp = np.zeros ( ( N + 1 , N + 1 ) )			  
  dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;			      	  dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]			    	dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]			  
  for ( int i = 1 ;					      	  for i in range ( 1 , N ) :				    	for i in range ( 1 , N ) :				  
  i < N ;						      	      dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0  	    dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0  
  i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 	  for j in range ( 1 , N ) :				    	for j in range ( 1 , N ) :				  
  for ( int j = 1 ;					      	      dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j  	    dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j  
  j < N ;						      	  for i in range ( 1 , N ) :				    	for i in range ( 1 , N ) :				  
  j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j 	      for j in range ( 1 , N ) :			    	    for j in range ( 1 , N ) :				  
  for ( int i = 1 ;					      		  dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [  		dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [  
  i < N ;						      	  return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 )		    	return float ( dp [ N - 1 ] [ N - 1 ] ) / ( 2 * N - 1 )	  
  i ++ ) for ( int j = 1 ;				      								    								  
  j < N ;						      								    								  
  j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , d 								    								  
  return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ;  								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER		      GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER		    GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER			  GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER
--							      --							    --								  --
static void evaluate ( int n ) {			      def evaluate ( n ) :					    def evaluate ( n ) :					  script_not_found : None
  if ( n == 1 || n == 2 ) System . out . println ( "No Pythag 	  if ( n == 1 or n == 2 ) :				    	if n == 1 or n == 2 :					  
  else if ( n % 2 == 0 ) {				      	      print ( "No Pythagoras" + " Triplet exists" )	    	    print ( "No Pythagoras " "Triplet exists" )		  
    int var = 1 * n * n / 4 ;				      	  elif ( n % 2 == 0 ) :					    	elif n % 2 == 0 :					  
    System . out . print ( "Pythagoras Triplets " + "exist i. 	      var = n * n / 4					    	    var = 1 * n * n // 4				  
    System . out . print ( n + " " ) ;			      	      print ( "Pythagoras Triplets" + " exist i.e." , end = 	    print ( "Pythagoras Triplets " "exist i.e." , n , end 
    System . out . print ( var - 1 + " " ) ;		      	      print ( int ( n ) , "" , int ( var - 1 ) , "" , int ( 	    print ( var - 1 , " " )				  
    System . out . println ( var + 1 + " " ) ;		      	  elif ( n % 2 != 0 ) :					    	    print ( var + 1 , " " )				  
  }							      	      var = n * n + 1					    	elif n % 2 != 0 :					  
  else if ( n % 2 != 0 ) {				      	      print ( "Pythagoras Triplets " + "exist i.e." , end = 	    var = 1 * n * n + 1					  
    int var = 1 * n * n + 1 ;				      	      print ( int ( n ) , "" , int ( var / 2 - 1 ) , "" , i 	    print ( "Pythagoras Triplets " "exist i.e." , n , end 
    System . out . print ( "Pythagoras Triplets " + "exist i. 								    	    print ( var / 2 - 1 , " " )				  
    System . out . print ( n + " " ) ;			      								    	    print ( var / 2 , " " )				  
    System . out . print ( var / 2 - 1 + " " ) ;	      								    								  
    System . out . println ( var / 2 + " " ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE    DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE    DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE
--							      --							    --								  --
static int lps ( String seq ) {				      def lps ( str ) :						    def lps ( seq ) :						  success : None
  int n = seq . length ( ) ;				      	  n = len ( str )					    	n = len ( seq )						  
  int i , j , cl ;					      	  L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ]   	i , j , cl = 0 , 0 , 0					  
  int L [ ] [ ] = new int [ n ] [ n ] ;			      	  for i in range ( n ) :				    	L = np.zeros ( ( n , n ) )				  
  for ( i = 0 ;						      	      L [ i ] [ i ] = 1					    	for i in range ( n ) :					  
  i < n ;						      	  for cl in range ( 2 , n + 1 ) :			    	    L [ i ] [ i ] = 1					  
  i ++ ) L [ i ] [ i ] = 1 ;				      	      for i in range ( n - cl + 1 ) :			    	for cl in range ( 2 , n + 1 ) :				  
  for ( cl = 2 ;					      		  j = i + cl - 1				    	    for i in range ( n - cl + 1 ) :			  
  cl <= n ;						      		  if str [ i ] == str [ j ] and cl == 2 :	    		j = i + cl - 1					  
  cl ++ ) {						      		      L [ i ] [ j ] = 2				    		if seq [ i ] == seq [ j ] and cl == 2 :		  
    for ( i = 0 ;					      		  elif str [ i ] == str [ j ] :			    		    L [ i ] [ j ] = 2				  
    i < n - cl + 1 ;					      		      L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2	    		elif seq [ i ] == seq [ j ] :			  
    i ++ ) {						      		  else :					    		    L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2	  
      j = i + cl - 1 ;					      		      L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ 		else :						  
      if ( seq . charAt ( i ) == seq . charAt ( j ) && cl ==  	  return L [ 0 ] [ n - 1 ]				    		    L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ 
      else if ( seq . charAt ( i ) == seq . charAt ( j ) ) L  								    	return L [ 0 ] [ n - 1 ]				  
      else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i +  								    								  
    }							      								    								  
  }							      								    								  
  return L [ 0 ] [ n - 1 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2	    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2
--							      --							    --								  --
void printRepeating ( int arr [ ] , int size ) {	      def printRepeating ( arr , size ) :			    def print_repeating ( arr , size ) :			  script_not_found : None
  int xor = arr [ 0 ] ;					      	  xor = arr [ 0 ]					    	xor = arr [ 0 ]						  
  int set_bit_no ;					      	  n = size - 2						    	set_bit_no = 0						  
  int i ;						      	  x = 0							    	i = 0							  
  int n = size - 2 ;					      	  y = 0							    	n = size - 2						  
  int x = 0 , y = 0 ;					      	  for i in range ( 1 , size ) :				    	x , y = 0 , 0						  
  for ( i = 1 ;						      	      xor ^= arr [ i ]					    	for i in range ( 1 , size ) :				  
  i < size ;						      	  for i in range ( 1 , n + 1 ) :			    	    xor ^= arr [ i ]					  
  i ++ ) xor ^= arr [ i ] ;				      	      xor ^= i						    	for i in range ( 1 , n + 1 ) :				  
  for ( i = 1 ;						      	  set_bit_no = xor & ~ ( xor - 1 )			    	    xor ^= i						  
  i <= n ;						      	  for i in range ( 0 , size ) :				    	set_bit_no = ( xor & ~ ( xor - 1 ) )			  
  i ++ ) xor ^= i ;					      	      if ( arr [ i ] & set_bit_no ) :			    	for i in range ( size ) :				  
  set_bit_no = ( xor & ~ ( xor - 1 ) ) ;		      		  x = x ^ arr [ i ]				    	    a = arr [ i ] & set_bit_no				  
  for ( i = 0 ;						      	      else :						    	    if a :						  
  i < size ;						      		  y = y ^ arr [ i ]				    		x = x ^ arr [ i ]				  
  i ++ ) {						      	  for i in range ( 1 , n + 1 ) :			    	    else :						  
    int a = arr [ i ] & set_bit_no ;			      	      if ( i & set_bit_no ) :				    		y = y ^ arr [ i ]				  
    if ( a != 0 ) x = x ^ arr [ i ] ;			      		  x = x ^ i					    	for i in range ( 1 , n + 1 ) :				  
    else y = y ^ arr [ i ] ;				      	      else :						    	    a = i & set_bit_no					  
  }							      		  y = y ^ i					    	    if a :						  
  for ( i = 1 ;						      	  print ( "The two repeating" , "elements are" , y , x )    		x = x ^ i					  
  i <= n ;						      								    	    else :						  
  i ++ ) {						      								    		y = y ^ i					  
    int a = i & set_bit_no ;				      								    	print ( 'The two reppeated elements are :' )		  
    if ( a != 0 ) x = x ^ i ;				      								    	print ( str ( x ) + ' ' + str ( y ) )			  
    else y = y ^ i ;					      								    								  
  }							      								    								  
  System . out . println ( "The two reppeated elements are :" 								    								  
  System . out . println ( x + " " + y ) ;		      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
static void firstFit ( int blockSize [ ] , int m , int proces def firstFit ( blockSize , m , processSize , n ) :	    def first_fit ( block_size , m , process_size , n ) :	  script_not_found : None
  int allocation [ ] = new int [ n ] ;			      	  allocation = [ - 1 ] * n				    	allocation = [ - 1 for i in range ( n ) ]		  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < allocation . length ;				      	      for j in range ( m ) :				    	    for j in range ( m ) :				  
  i ++ ) allocation [ i ] = - 1 ;			      		  if blockSize [ j ] >= processSize [ i ] :	    		if block_size [ j ] >= process_size [ i ] :	  
  for ( int i = 0 ;					      		      allocation [ i ] = j			    		    allocation [ i ] = j			  
  i < n ;						      		      blockSize [ j ] -= processSize [ i ]	    		    block_size [ j ] -= process_size [ i ]	  
  i ++ ) {						      		      break					    		    break					  
    for ( int j = 0 ;					      	  print ( " Process No.Process Size	 Block no." )	    	print ( "\nProcess No.\tProcess Size\tBlock no." )	  
    j < m ;						      	  for i in range ( n ) :				    	for i in range ( n ) :					  
    j ++ ) {						      	      print ( " " , i + 1 , "	      " , processSize [ i ] 	    print ( " %d\t\t%d\t\t" % ( i + 1 , process_size [ i  
      if ( blockSize [ j ] >= processSize [ i ] ) {	      	      if allocation [ i ] != - 1 :			    	    if allocation [ i ] != - 1 :			  
	allocation [ i ] = j ;				      		  print ( allocation [ i ] + 1 )		    		print ( " %d\t\t" % ( allocation [ i ] + 1 ) , en 
	blockSize [ j ] -= processSize [ i ] ;		      	      else :						    	    else :						  
	break ;						      		  print ( "Not Allocated" )			    		print ( "Not Allocated" , end = "" )		  
      }							      								    	    print ( )						  
    }							      								    								  
  }							      								    								  
  System . out . println ( "\nProcess No.\tProcess Size\tBloc 								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    System . out . print ( " " + ( i + 1 ) + "\t\t" + process 								    								  
    if ( allocation [ i ] != - 1 ) System . out . print ( all 								    								  
    else System . out . print ( "Not Allocated" ) ;	      								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_PRODUCT_TWO_ARRAYS				      MINIMUM_SUM_PRODUCT_TWO_ARRAYS				    MINIMUM_SUM_PRODUCT_TWO_ARRAYS				  MINIMUM_SUM_PRODUCT_TWO_ARRAYS
--							      --							    --								  --
static int minproduct ( int a [ ] , int b [ ] , int n , int k def minproduct ( a , b , n , k ) :			    def minproduct ( a , b , n , k ) :				  script_not_found : None
  int diff = 0 , res = 0 ;				      	  diff = 0						    	diff , res = 0 , 0					  
  int temp = 0 ;					      	  res = 0						    	temp = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      pro = a [ i ] * b [ i ]				    	    pro = a [ i ] * b [ i ]				  
  i ++ ) {						      	      res = res + pro					    	    res = res + pro					  
    int pro = a [ i ] * b [ i ] ;			      	      if ( pro < 0 and b [ i ] < 0 ) :			    	    if pro < 0 and b [ i ] < 0 :			  
    res = res + pro ;					      		  temp = ( a [ i ] + 2 * k ) * b [ i ]		    		temp = ( a [ i ] + 2 * k ) * b [ i ]		  
    if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k )  	      elif ( pro < 0 and a [ i ] < 0 ) :		    	    elif pro < 0 and a [ i ] < 0 :			  
    else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * 		  temp = ( a [ i ] - 2 * k ) * b [ i ]		    		temp = ( a [ i ] - 2 * k ) * b [ i ]		  
    else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * 	      elif ( pro > 0 and a [ i ] < 0 ) :		    	    elif pro > 0 and a [ i ] < 0 :			  
    else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * 		  temp = ( a [ i ] + 2 * k ) * b [ i ]		    		temp = ( a [ i ] + 2 * k ) * b [ i ]		  
    int d = Math . abs ( pro - temp ) ;			      	      elif ( pro > 0 and a [ i ] > 0 ) :		    	    elif pro > 0 and a [ i ] > 0 :			  
    if ( d > diff ) diff = d ;				      		  temp = ( a [ i ] - 2 * k ) * b [ i ]		    		temp = ( a [ i ] - 2 * k ) * b [ i ]		  
  }							      	      d = abs ( pro - temp )				    	    d = abs ( pro - temp )				  
  return res - diff ;					      	      if ( d > diff ) :					    	    if d > diff :					  
}							      		  diff = d					    		diff = d					  
							      	  return res - diff					    	return res - diff					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX			      MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX			    MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX			  MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX
--							      --							    --								  --
static void maxMin ( int arr [ ] [ ] , int n ) {	      def MAXMIN ( arr , n ) :					    def max_min ( arr , n ) :					  script_not_found : None
  int min = + 2147483647 ;				      	  MIN = 10 ** 9						    	min = + 2147483647					  
  int max = - 2147483648 ;				      	  MAX = - 10 ** 9					    	max = - 2147483648					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( n // 2 + 1 ) :			    	    for j in range ( 0 , n // 2 + 1 ) :			  
  i ++ ) {						      		  if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] )  		if arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] :	  
    for ( int j = 0 ;					      		      if ( MIN > arr [ i ] [ n - j - 1 ] ) :	    		    if min > arr [ i ] [ n - j - 1 ] :		  
    j <= n / 2 ;					      			  MIN = arr [ i ] [ n - j - 1 ]		    			min = arr [ i ] [ n - j - 1 ]		  
    j ++ ) {						      		      if ( MAX < arr [ i ] [ j ] ) :		    		    if max < arr [ i ] [ j ] :			  
      if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) {      			  MAX = arr [ i ] [ j ]			    			max = arr [ i ] [ j ]			  
	if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ]  		  else :					    		else :						  
	if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ;  		      if ( MIN > arr [ i ] [ j ] ) :		    		    if min > arr [ i ] [ j ] :			  
      }							      			  MIN = arr [ i ] [ j ]			    			min = arr [ i ] [ j ]			  
      else {						      		      if ( MAX < arr [ i ] [ n - j - 1 ] ) :	    		    if max < arr [ i ] [ n - j - 1 ] :		  
	if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ;  			  MAX = arr [ i ] [ n - j - 1 ]		    			max = arr [ i ] [ n - j - 1 ]		  
	if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ]  	  print ( "MAXimum =" , MAX , ", MINimum =" , MIN )	    	sys.stdout.write ( 'Maximum = %d, Minimum = %d\n' % ( max 
      }							      								    								  
    }							      								    								  
  }							      								    								  
  System . out . print ( "Maximum = " + max + ", Minimum = "  								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY		      COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY		    COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY		  COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY
--							      --							    --								  --
static int numofAP ( int a [ ] , int n ) {		      def numofAP ( a , n ) :					    def numofAP ( a , n ) :					  script_not_found : None
  int minarr = + 2147483647 ;				      	  minarr = + 2147483647					    	minarr = + 2147483647					  
  int maxarr = - 2147483648 ;				      	  maxarr = - 2147483648					    	maxarr = - 2147483648					  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      minarr = min ( minarr , a [ i ] )			    	    minarr = min ( minarr , a [ i ] )			  
  i ++ ) {						      	      maxarr = max ( maxarr , a [ i ] )			    	    maxarr = max ( maxarr , a [ i ] )			  
    minarr = Math . min ( minarr , a [ i ] ) ;		      	  dp = [ 0 for i in range ( n + 1 ) ]			    	dp = [ 0 ] * n						  
    maxarr = Math . max ( maxarr , a [ i ] ) ;		      	  ans = n + 1						    	sum = [ 0 ] * MAX					  
  }							      	  for d in range ( ( minarr - maxarr ) , ( maxarr - minarr  	ans = n + 1						  
  int dp [ ] = new int [ n ] ;				      	      sum = [ 0 for i in range ( MAX + 1 ) ]		    	for d in range ( ( minarr - maxarr ) , ( maxarr - minarr  
  int sum [ ] = new int [ MAX ] ;			      	      for i in range ( n ) :				    	    sum [ : ] = 0					  
  int ans = n + 1 ;					      		  dp [ i ] = 1					    	    for i in range ( n ) :				  
  for ( int d = ( minarr - maxarr ) ;			      		  if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000  		dp [ i ] = 1					  
  d <= ( maxarr - minarr ) ;				      		      dp [ i ] += sum [ a [ i ] - d ]		    		if a [ i ] - d >= 1 and a [ i ] - d <= 1000000 :  
  d ++ ) {						      		  ans += dp [ i ] - 1				    		    dp [ i ] += sum [ a [ i ] - d ]		  
    Arrays . fill ( sum , 0 ) ;				      		  sum [ a [ i ] ] += dp [ i ]			    		ans += dp [ i ] - 1				  
    for ( int i = 0 ;					      	  return ans						    		sum [ a [ i ] ] += dp [ i ]			  
    i < n ;						      								    	return ans						  
    i ++ ) {						      								    								  
      dp [ i ] = 1 ;					      								    								  
      if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [  								    								  
      ans += dp [ i ] - 1 ;				      								    								  
      sum [ a [ i ] ] += dp [ i ] ;			      								    								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES      PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES	    PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES	  PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES
--							      --							    --								  --
static void constructTree ( int n , int d , int h ) {	      def constructTree ( n , d , h ) :				    def construct_tree ( n , d , h ) :				  script_not_found : None
  if ( d == 1 ) {					      	  if d == 1 :						    	if d == 1 :						  
    if ( n == 2 && h == 1 ) {				      	      if n == 2 and h == 1 :				    	    if n == 2 and h == 1 :				  
      System . out . println ( "1 2" ) ;		      		  print ( "1 2" )				    		print ( '1 2' )					  
      return ;						      		  return 0					    		return						  
    }							      	      print ( "-1" )					    	    print ( '-1' )					  
    System . out . println ( "-1" ) ;			      	      return 0						    	    return						  
    return ;						      	  if d > 2 * h :					    	if d > 2 * h :						  
  }							      	      print ( "-1" )					    	    print ( '-1' )					  
  if ( d > 2 * h ) {					      	      return 0						    	    return						  
    System . out . println ( "-1" ) ;			      	  for i in range ( 1 , h + 1 ) :			    	for i in range ( 1 , h + 1 ) :				  
    return ;						      	      print ( i , " " , i + 1 )				    	    print ( i , i + 1 )					  
  }							      	  if d > h :						    	if d > h :						  
  for ( int i = 1 ;					      	      print ( 1 , "  " , h + 2 )			    	    print ( '1' , h + 2 )				  
  i <= h ;						      	      for i in range ( h + 2 , d + 1 ) :		    	    for i in range ( h + 2 , d + 1 ) :			  
  i ++ ) System . out . println ( i + " " + ( i + 1 ) ) ;     		  print ( i , " " , i + 1 )			    		print ( i , i + 1 )				  
  if ( d > h ) {					      	  for i in range ( d + 1 , n ) :			    	for i in range ( d + 1 , n ) :				  
    System . out . println ( "1" + " " + ( h + 2 ) ) ;	      	      k = 1						    	    k = 1						  
    for ( int i = h + 2 ;				      	      if d == h :					    	    if d == h :						  
    i <= d ;						      		  k = 2						    		k = 2						  
    i ++ ) {						      	      print ( k , " " , i + 1 )				    	    print ( k , i + 1 )					  
      System . out . println ( i + " " + ( i + 1 ) ) ;	      								    								  
    }							      								    								  
  }							      								    								  
  for ( int i = d + 1 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    int k = 1 ;						      								    								  
    if ( d == h ) k = 2 ;				      								    								  
    System . out . println ( k + " " + ( i + 1 ) ) ;	      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE		      COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE		    COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE			  COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE
--							      --							    --								  --
static int findSubsequenceCount ( String S , String T ) {     def findSubsequenceCount ( S , T ) :			    def findSubsequenceCount ( S , T ) :			  success : None
  int m = T . length ( ) ;				      	  m = len ( T )						    	m = len ( T )						  
  int n = S . length ( ) ;				      	  n = len ( S )						    	n = len ( S )						  
  if ( m > n ) return 0 ;				      	  if m > n :						    	if m > n :						  
  int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	      return 0						    	    return 0						  
  for ( int i = 1 ;					      	  mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range (  	mat = np.zeros ( ( m + 1 , n + 1 ) )			  
  i <= m ;						      	  for i in range ( 1 , m + 1 ) :			    	for i in range ( 1 , m + 1 ) :				  
  i ++ ) mat [ i ] [ 0 ] = 0 ;				      	      mat [ i ] [ 0 ] = 0				    	    mat [ i ] [ 0 ] = 0					  
  for ( int j = 0 ;					      	  for j in range ( n + 1 ) :				    	for j in range ( 0 , n + 1 ) :				  
  j <= n ;						      	      mat [ 0 ] [ j ] = 1				    	    mat [ 0 ] [ j ] = 1					  
  j ++ ) mat [ 0 ] [ j ] = 1 ;				      	  for i in range ( 1 , m + 1 ) :			    	for i in range ( 1 , m + 1 ) :				  
  for ( int i = 1 ;					      	      for j in range ( 1 , n + 1 ) :			    	    for j in range ( 1 , n + 1 ) :			  
  i <= m ;						      		  if T [ i - 1 ] != S [ j - 1 ] :		    		if T [ i - 1 ] != S [ j - 1 ] :			  
  i ++ ) {						      		      mat [ i ] [ j ] = mat [ i ] [ j - 1 ]	    		    mat [ i ] [ j ] = mat [ i ] [ j - 1 ]	  
    for ( int j = 1 ;					      		  else :					    		else :						  
    j <= n ;						      		      mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat 		    mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ 
    j ++ ) {						      	  return mat [ m ] [ n ]				    	return mat [ m ] [ n ]					  
      if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat 								    								  
      else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i -  								    								  
    }							      								    								  
  }							      								    								  
  return mat [ m ] [ n ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY		      FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY			    FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY			  FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY
--							      --							    --								  --
static int minAdjustmentCost ( int A [ ] , int n , int target def minAdjustmentCost ( A , n , target ) :		    def min_adjustment_cost ( A , n , target ) :		  script_not_found : None
  int [ ] [ ] dp = new int [ n ] [ M + 1 ] ;		      	  dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n  	dp = np.zeros ( ( n , M + 1 ) )				  
  for ( int j = 0 ;					      	  for j in range ( M + 1 ) :				    	for j in range ( 0 , M + 1 ) :				  
  j <= M ;						      	      dp [ 0 ] [ j ] = abs ( j - A [ 0 ] )		    	    dp [ 0 ] [ j ] = abs ( j - A [ 0 ] )		  
  j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ;	      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      	      for j in range ( M + 1 ) :			    	    for j in range ( 0 , M + 1 ) :			  
  i < n ;						      		  dp [ i ] [ j ] = 100000000			    		dp [ i ] [ j ] = np.inf				  
  i ++ ) {						      		  for k in range ( max ( j - target , 0 ) , min ( M 		k = max ( j - target , 0 )			  
    for ( int j = 0 ;					      		      dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [  		for _ in range ( min ( M , j + target ) + 1 ) :	  
    j <= M ;						      	  res = 10000000					    		    dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [  
    j ++ ) {						      	  for j in range ( M + 1 ) :				    	res = np.inf						  
      dp [ i ] [ j ] = Integer . MAX_VALUE ;		      	      res = min ( res , dp [ n - 1 ] [ j ] )		    	for j in range ( 0 , M + 1 ) :				  
      int k = Math . max ( j - target , 0 ) ;		      	  return res						    	    res = min ( res , dp [ n - 1 ] [ j ] )		  
      for ( ;						      								    	return res						  
      k <= Math . min ( M , j + target ) ;		      								    								  
      k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , d 								    								  
    }							      								    								  
  }							      								    								  
  int res = Integer . MAX_VALUE ;			      								    								  
  for ( int j = 0 ;					      								    								  
  j <= M ;						      								    								  
  j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ;      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1		      FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1		    FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1			  FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1
--							      --							    --								  --
static int findFourElements ( int [ ] arr , int n ) {	      def findFourElements ( arr , n ) :			    def find_four_elements ( arr , n ) :			  error : Traceback (most recent call last):   File
  HashMap < Integer , Indexes > map = new HashMap < > ( ) ;   	  mp = dict ( )						    	d = { }							  "dump/transcoder_st/eval/java_python/online_st/206
  for ( int i = 0 ;					      	  for i in range ( n - 1 ) :				    	for i in range ( n - 1 ) :				  68770/eval_scripts/java_sa-python_sa.test/FIND_LAR
  i < n - 1 ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  GEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1.py", line 64,
  i ++ ) {						      		  mp [ arr [ i ] + arr [ j ] ] = ( i , j )	    		d [ arr [ i ] + arr [ j ] ] = { i : j }		  in <module>	  if f_filled(*parameters_set) == f_
    for ( int j = i + 1 ;				      	  d = - 10 ** 9						    	d = int ( 0 )						  gold(*parameters_set):   File "dump/transcoder_st/
    j < n ;						      	  for i in range ( n - 1 ) :				    	for i in range ( n - 1 ) :				  eval/java_python/online_st/20668770/eval_scripts/j
    j ++ ) {						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  ava_sa-python_sa.test/FIND_LARGEST_D_IN_ARRAY_SUCH
      map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j 		  abs_diff = abs ( arr [ i ] - arr [ j ] )	    		abs_diff = abs ( arr [ i ] - arr [ j ] )	  _THAT_A_B_C_D_1.py", line 42, in f_filled	if a
    }							      		  if abs_diff in mp.keys ( ) :			    		if abs_diff in d :				  bs_diff in d : TypeError: argument of type 'int' i
  }							      		      p = mp [ abs_diff ]			    		    indexes = d [ abs_diff ]			  s not iterable
  int d = Integer . MIN_VALUE ;				      		      if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1  		    if indexes [ 'i' ] != i and indexes [ 'i' ] ! 
  for ( int i = 0 ;					      			  d = max ( d , max ( arr [ i ] , arr [ j ] 			d = max ( d , max ( arr [ i ] , arr [ j ] 
  i < n - 1 ;						      	  return d						    	return d						  
  i ++ ) {						      								    								  
    for ( int j = i + 1 ;				      								    								  
    j < n ;						      								    								  
    j ++ ) {						      								    								  
      int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ;   								    								  
      if ( map . containsKey ( abs_diff ) ) {		      								    								  
	Indexes indexes = map . get ( abs_diff ) ;	      								    								  
	if ( indexes . getI ( ) != i && indexes . getI ( ) != 								    								  
	  d = Math . max ( d , Math . max ( arr [ i ] , arr [ 								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return d ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE		      FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE			    FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE			  FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE
--							      --							    --								  --
static int sumNodes ( int l ) {				      def SumNodes ( l ) :					    def sum_nodes ( l ) :					  script_not_found : None
  int leafNodeCount = ( int ) Math . pow ( 2 , l - 1 ) ;      	  leafNodeCount = pow ( 2 , l - 1 )			    	leaf_node_count = int ( math.pow ( 2 , l - 1 ) )	  
  Vector < Vector < Integer >> vec = new Vector < Vector < In 	  vec = [ [ ] for i in range ( l ) ]			    	vec = [ [ ] for i in range ( 1 , l + 1 ) ]		  
  for ( int i = 1 ;					      	  for i in range ( 1 , leafNodeCount + 1 ) :		    	for i in range ( 1 , leaf_node_count + 1 ) :		  
  i <= l ;						      	      vec [ l - 1 ].append ( i )			    	    vec [ l - 1 ].append ( i )				  
  i ++ ) vec . add ( new Vector < Integer > ( ) ) ;	      	  for i in range ( l - 2 , - 1 , - 1 ) :		    	for i in range ( l - 2 , - 1 , - 1 ) :			  
  for ( int i = 1 ;					      	      k = 0						    	    k = 0						  
  i <= leafNodeCount ;					      	      while ( k < len ( vec [ i + 1 ] ) - 1 ) :		    	    while k < len ( vec [ i + 1 ] ) - 1 :		  
  i ++ ) vec . get ( l - 1 ) . add ( i ) ;		      		  vec [ i ].append ( vec [ i + 1 ] [ k ] + vec [ i  		vec [ i ].append ( vec [ i + 1 ] [ k ] + vec [ i  
  for ( int i = l - 2 ;					      		  k += 2					    		k += 2						  
  i >= 0 ;						      	  Sum = 0						    	sum = 0							  
  i -- ) {						      	  for i in range ( l ) :				    	for i in range ( l ) :					  
    int k = 0 ;						      	      for j in range ( len ( vec [ i ] ) ) :		    	    for j in range ( len ( vec [ i ] ) ) :		  
    while ( k < vec . get ( i + 1 ) . size ( ) - 1 ) {	      		  Sum += vec [ i ] [ j ]			    		sum += vec [ i ] [ j ]				  
      vec . get ( i ) . add ( vec . get ( i + 1 ) . get ( k ) 	  return Sum						    	return sum						  
      k += 2 ;						      								    								  
    }							      								    								  
  }							      								    								  
  int sum = 0 ;						      								    								  
  for ( int i = 0 ;					      								    								  
  i < l ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j < vec . get ( i ) . size ( ) ;			      								    								  
    j ++ ) sum += vec . get ( i ) . get ( j ) ;		      								    								  
  }							      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED     LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED	    LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED	  LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED
--							      --							    --								  --
static int lcs ( int [ ] [ ] [ ] dp , int [ ] arr1 , int n ,  def lcs ( dp , arr1 , n , arr2 , m , k ) :		    def lcs ( dp , arr1 , n , arr2 , m , k ) :			  success : None
  if ( k < 0 ) return - 10000000 ;			      	  if k < 0 :						    	if k < 0 :						  
  if ( n < 0 || m < 0 ) return 0 ;			      	      return - ( 10 ** 7 )				    	    return - 10000000					  
  int ans = dp [ n ] [ m ] [ k ] ;			      	  if n < 0 or m < 0 :					    	if n < 0 or m < 0 :					  
  if ( ans != - 1 ) return ans ;			      	      return 0						    	    return 0						  
  try {							      	  ans = dp [ n ] [ m ] [ k ]				    	ans = dp [ n ] [ m ] [ k ]				  
    ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k 	  if ans != - 1 :					    	if ans != - 1 :						  
    if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max  	      return ans					    	    return ans						  
    ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , ar 	  ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lc 	try :							  
  }							      	  if arr1 [ n - 1 ] == arr2 [ m - 1 ] :			    	    ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k )  
  catch ( Exception e ) {				      	      ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2  	    if arr1 [ n - 1 ] == arr2 [ m - 1 ] :		  
  }							      	  ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1  		ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , a 
  return ans ;						      	  return ans						    	    ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2  
}							      								    	except :						  
							      								    	    pass						  
							      								    	return ans						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS	      LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS	    LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS	  LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS
--							      --							    --								  --
static void findLIS ( int A [ ] , int n ) {		      def findLIS ( A , n ) :					    def find_LIS ( A , n ) :					  script_not_found : None
  Map < Integer , Integer > hash = new HashMap < Integer , In 	  hash = dict ( )					    	hash = { }						  
  int LIS_size = 1 ;					      	  LIS_size , LIS_index = 1 , 0				    	LIS_size = 1						  
  int LIS_index = 0 ;					      	  hash [ A [ 0 ] ] = 1					    	LIS_index = 0						  
  hash . put ( A [ 0 ] , 1 ) ;				      	  for i in range ( 1 , n ) :				    	hash [ A [ 0 ] ] = 1					  
  for ( int i = 1 ;					      	      if A [ i ] - 1 not in hash :			    	for i in range ( 1 , n ) :				  
  i < n ;						      		  hash [ A [ i ] - 1 ] = 0			    	    hash [ A [ i ] ] = 1 if hash.get ( A [ i - 1 ] ) is N 
  i ++ ) {						      	      hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1	    	    if LIS_size < hash [ A [ i ] ] :			  
    hash . put ( A [ i ] , hash . get ( A [ i ] - 1 ) == null 	      if LIS_size < hash [ A [ i ] ] :			    		LIS_size = hash [ A [ i ] ]			  
    if ( LIS_size < hash . get ( A [ i ] ) ) {		      		  LIS_size = hash [ A [ i ] ]			    		LIS_index = A [ i ]				  
      LIS_size = hash . get ( A [ i ] ) ;		      		  LIS_index = A [ i ]				    	print ( "LIS_size = %d" % LIS_size )			  
      LIS_index = A [ i ] ;				      	  print ( "LIS_size =" , LIS_size )			    	print ( "LIS : " , end = " " )				  
    }							      	  print ( "LIS : " , end = "" )				    	start = LIS_index - LIS_size + 1			  
  }							      	  start = LIS_index - LIS_size + 1			    	while start <= LIS_index :				  
  System . out . println ( "LIS_size = " + LIS_size ) ;	      	  while start <= LIS_index :				    	    print ( "%d " % start , end = " " )			  
  System . out . print ( "LIS : " ) ;			      	      print ( start , end = " " )			    	    start += 1						  
  int start = LIS_index - LIS_size + 1 ;		      	      start += 1					    								  
  while ( start <= LIS_index ) {			      								    								  
    System . out . print ( start + " " ) ;		      								    								  
    start ++ ;						      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING		      COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING		    COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING			  COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING
--							      --							    --								  --
static int countPS ( String str ) {			      def countPS ( str ) :					    def count_ps ( str ) :					  success : None
  int N = str . length ( ) ;				      	  N = len ( str )					    	N = len ( str )						  
  int [ ] [ ] cps = new int [ N + 1 ] [ N + 1 ] ;	      	  cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N 	cps = np.zeros ( ( N + 1 , N + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( N ) :				    	for i in range ( N ) :					  
  i < N ;						      	      cps [ i ] [ i ] = 1				    	    cps [ i ] [ i ] = 1					  
  i ++ ) cps [ i ] [ i ] = 1 ;				      	  for L in range ( 2 , N + 1 ) :			    	for L in range ( 2 , N + 1 ) :				  
  for ( int L = 2 ;					      	      for i in range ( N ) :				    	    for i in range ( N ) :				  
  L <= N ;						      		  k = L + i - 1					    		k = L + i - 1					  
  L ++ ) {						      		  if ( k < N ) :				    		if k < N :					  
    for ( int i = 0 ;					      		      if ( str [ i ] == str [ k ] ) :		    		    if str [ i ] == str [ k ] :			  
    i < N ;						      			  cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + 			cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + c 
    i ++ ) {						      		      else :					    		    else :					  
      int k = L + i - 1 ;				      			  cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + 			cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + c 
      if ( k < N ) {					      	  return cps [ 0 ] [ N - 1 ]				    	return cps [ 0 ] [ N - 1 ]				  
	if ( str . charAt ( i ) == str . charAt ( k ) ) cps [ 								    								  
	else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i  								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return cps [ 0 ] [ N - 1 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MEDIAN_ROW_WISE_SORTED_MATRIX			      FIND_MEDIAN_ROW_WISE_SORTED_MATRIX			    FIND_MEDIAN_ROW_WISE_SORTED_MATRIX				  FIND_MEDIAN_ROW_WISE_SORTED_MATRIX
--							      --							    --								  --
static int binaryMedian ( int m [ ] [ ] , int r , int c ) {   def binaryMedian ( m , r , d ) :				    def binary_median ( m , r , c ) :				  script_not_found : None
  int max = Integer . MIN_VALUE ;			      	  mi = m [ 0 ] [ 0 ]					    	max = sys.maxsize					  
  int min = Integer . MAX_VALUE ;			      	  mx = 0						    	min = sys.maxsize					  
  for ( int i = 0 ;					      	  for i in range ( r ) :				    	for i in range ( r ) :					  
  i < r ;						      	      if m [ i ] [ 0 ] < mi :				    	    if m [ i ] [ 0 ] < min :				  
  i ++ ) {						      		  mi = m [ i ] [ 0 ]				    		min = m [ i ] [ 0 ]				  
    if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ;	      	      if m [ i ] [ d - 1 ] > mx :			    	    if m [ i ] [ c - 1 ] > max :			  
    if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ;  		  mx = m [ i ] [ d - 1 ]			    		max = m [ i ] [ c - 1 ]				  
  }							      	  desired = ( r * d + 1 ) // 2				    	desired = ( r * c + 1 ) // 2				  
  int desired = ( r * c + 1 ) / 2 ;			      	  while ( mi < mx ) :					    	while min < max :					  
  while ( min < max ) {					      	      mid = mi + ( mx - mi ) // 2			    	    mid = min + ( max - min ) // 2			  
    int mid = min + ( max - min ) / 2 ;			      	      place = [ 0 ]					    	    place = 0						  
    int place = 0 ;					      	      for i in range ( r ) :				    	    get = 0						  
    int get = 0 ;					      		  j = upper_bound ( m [ i ] , mid )		    	    for i in range ( r ) :				  
    for ( int i = 0 ;					      		  place [ 0 ] = place [ 0 ] + j			    		get = bisect.bisect_right ( m [ i ] , mid )	  
    i < r ;						      	      if place [ 0 ] < desired :			    		if get < 0 :					  
    ++ i ) {						      		  mi = mid + 1					    		    get = abs ( get ) - 1			  
      get = Arrays . binarySearch ( m [ i ] , mid ) ;	      	      else :						    		else :						  
      if ( get < 0 ) get = Math . abs ( get ) - 1 ;	      		  mx = mid					    		    while get < len ( m [ i ] ) and m [ i ] [ get 
      else {						      	  print ( "Median is" , mi )				    			get += 1				  
	while ( get < m [ i ] . length && m [ i ] [ get ] ==  	  return						    		place = place + get				  
      }							      								    	    if place < desired :				  
      place = place + get ;				      								    		min = mid + 1					  
    }							      								    	    else :						  
    if ( place < desired ) min = mid + 1 ;		      								    		max = mid					  
    else max = mid ;					      								    	return min						  
  }							      								    								  
  return min ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_PRODUCT_SUBSET_ARRAY				      MINIMUM_PRODUCT_SUBSET_ARRAY				    MINIMUM_PRODUCT_SUBSET_ARRAY				  MINIMUM_PRODUCT_SUBSET_ARRAY
--							      --							    --								  --
static int minProductSubset ( int a [ ] , int n ) {	      def minProductSubset ( a , n ) :				    def min_product_subset ( a , n ) :				  error : Traceback (most recent call last):   File
  if ( n == 1 ) return a [ 0 ] ;			      	  if ( n == 1 ) :					    	if n == 1 :						  "dump/transcoder_st/eval/java_python/online_st/206
  int negmax = Integer . MIN_VALUE ;			      	      return a [ 0 ]					    	    return a [ 0 ]					  68770/eval_scripts/java_sa-python_sa.test/MINIMUM_
  int posmin = Integer . MAX_VALUE ;			      	  max_neg = float ( '-inf' )				    	negmax = sys.maxint					  PRODUCT_SUBSET_ARRAY.py", line 85, in <module>
  int count_neg = 0 , count_zero = 0 ;			      	  min_pos = float ( 'inf' )				    	posmin = sys.maxint					   if f_filled(*parameters_set) == f_gold(*parameter
  int product = 1 ;					      	  count_neg = 0						    	count_neg , count_zero = 0 , 0				  s_set):   File "dump/transcoder_st/eval/java_pytho
  for ( int i = 0 ;					      	  count_zero = 0					    	product = 1						  n/online_st/20668770/eval_scripts/java_sa-python_s
  i < n ;						      	  prod = 1						    	for i in range ( n ) :					  a.test/MINIMUM_PRODUCT_SUBSET_ARRAY.py", line 47,
  i ++ ) {						      	  for i in range ( 0 , n ) :				    	    if a [ i ] == 0 :					  in f_filled	  negmax = sys.maxint AttributeError
    if ( a [ i ] == 0 ) {				      	      if ( a [ i ] == 0 ) :				    		count_zero += 1					  : module 'sys' has no attribute 'maxint'
      count_zero ++ ;					      		  count_zero = count_zero + 1			    		continue					  
      continue ;					      		  continue					    	    if a [ i ] < 0 :					  
    }							      	      if ( a [ i ] < 0 ) :				    		count_neg += 1					  
    if ( a [ i ] < 0 ) {				      		  count_neg = count_neg + 1			    		negmax = max ( negmax , a [ i ] )		  
      count_neg ++ ;					      		  max_neg = max ( max_neg , a [ i ] )		    	    if a [ i ] > 0 and a [ i ] < posmin :		  
      negmax = Math . max ( negmax , a [ i ] ) ;	      	      if ( a [ i ] > 0 ) :				    		posmin = a [ i ]				  
    }							      		  min_pos = min ( min_pos , a [ i ] )		    	    product *= a [ i ]					  
    if ( a [ i ] > 0 && a [ i ] < posmin ) posmin = a [ i ] ; 	      prod = prod * a [ i ]				    	if count_zero == n or ( count_neg == 0 and count_zero > 0 
    product *= a [ i ] ;				      	  if ( count_zero == n or ( count_neg == 0 and count_zero > 	    return 0						  
  }							      	      return 0						    	if count_neg == 0 :					  
  if ( count_zero == n || ( count_neg == 0 && count_zero > 0  	  if ( count_neg == 0 ) :				    	    return posmin					  
  if ( count_neg == 0 ) return posmin ;			      	      return min_pos					    	if count_neg % 2 == 0 and count_neg != 0 :		  
  if ( count_neg % 2 == 0 && count_neg != 0 ) {		      	  if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) :	    	    product = product // negmax				  
    product = product / negmax ;			      	      prod = int ( prod / max_neg )			    	return product						  
  }							      	  return prod						    								  
  return product ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_MATRIX_ANTISPIRAL_FORM				      PRINT_MATRIX_ANTISPIRAL_FORM				    PRINT_MATRIX_ANTISPIRAL_FORM				  PRINT_MATRIX_ANTISPIRAL_FORM
--							      --							    --								  --
public static void antiSpiralTraversal ( int m , int n , int  def antiSpiralTraversal ( m , n , a ) :			    def anti_spiral_traversal ( m , n , a ) :			  error : Traceback (most recent call last):   File
  int i , k = 0 , l = 0 ;				      	  k = 0							    	i , k , l = 0 , 0					  "dump/transcoder_st/eval/java_python/online_st/206
  Stack < Integer > stk = new Stack < Integer > ( ) ;	      	  l = 0							    	stk = [ ]						  68770/eval_scripts/java_sa-python_sa.test/PRINT_MA
  while ( k <= m && l <= n ) {				      	  stk = [ ]						    	while k <= m and l <= n :				  TRIX_ANTISPIRAL_FORM.py", line 91, in <module>
    for ( i = l ;					      	  while ( k <= m and l <= n ) :				    	    for i in range ( l , n + 1 ) :			   f_filled(*(filled_function_param[i]))   File "dum
    i <= n ;						      	      for i in range ( l , n + 1 ) :			    		stk.append ( a [ k ] [ i ] )			  p/transcoder_st/eval/java_python/online_st/2066877
    ++ i ) stk . push ( a [ k ] [ i ] ) ;		      		  stk.append ( a [ k ] [ i ] )			    	    k += 1						  0/eval_scripts/java_sa-python_sa.test/PRINT_MATRIX
    k ++ ;						      	      k += 1						    	    for i in range ( k , m + 1 ) :			  _ANTISPIRAL_FORM.py", line 42, in f_filled	 i ,
    for ( i = k ;					      	      for i in range ( k , m + 1 ) :			    		stk.append ( a [ i ] [ n ] )			   k , l = 0 , 0 ValueError: not enough values to un
    i <= m ;						      		  stk.append ( a [ i ] [ n ] )			    	    n -= 1						  pack (expected 3, got 2)
    ++ i ) stk . push ( a [ i ] [ n ] ) ;		      	      n -= 1						    	    if k <= m :						  
    n -- ;						      	      if ( k <= m ) :					    		for i in range ( n , l - 1 , - 1 ) :		  
    if ( k <= m ) {					      		  for i in range ( n , l - 1 , - 1 ) :		    		    stk.append ( a [ m ] [ i ] )		  
      for ( i = n ;					      		      stk.append ( a [ m ] [ i ] )		    		m -= 1						  
      i >= l ;						      		  m -= 1					    	    if l <= n :						  
      -- i ) stk . push ( a [ m ] [ i ] ) ;		      	      if ( l <= n ) :					    		for i in range ( m , k - 1 , - 1 ) :		  
      m -- ;						      		  for i in range ( m , k - 1 , - 1 ) :		    		    stk.append ( a [ i ] [ l ] )		  
    }							      		      stk.append ( a [ i ] [ l ] )		    		l += 1						  
    if ( l <= n ) {					      		  l += 1					    	while not stk :						  
      for ( i = m ;					      	  while len ( stk ) != 0 :				    	    print ( stk [ - 1 ] , end = ' ' )			  
      i >= k ;						      	      print ( str ( stk [ - 1 ] ) , end = " " )		    	    stk.pop ( )						  
      -- i ) stk . push ( a [ i ] [ l ] ) ;		      	      stk.pop ( )					    								  
      l ++ ;						      								    								  
    }							      								    								  
  }							      								    								  
  while ( ! stk . empty ( ) ) {				      								    								  
    System . out . print ( stk . peek ( ) + " " ) ;	      								    								  
    stk . pop ( ) ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH			      DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH			    DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH			  DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH
--							      --							    --								  --
private static int minCost ( int cost [ ] [ ] , int m , int n def minCost ( cost , m , n ) :				    def _min_cost ( cost , m , n ) :				  script_not_found : None
  int i , j ;						      	  tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ]  	i , j = 0 , 0						  
  int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	  tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]			    	tc = np.zeros ( ( m + 1 , n + 1 ) )			  
  tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;			      	  for i in range ( 1 , m + 1 ) :			    	tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]			  
  for ( i = 1 ;						      	      tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0  	for i in range ( 1 , m + 1 ) :				  
  i <= m ;						      	  for j in range ( 1 , n + 1 ) :			    	    tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0  
  i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 	      tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j  	for j in range ( 1 , n + 1 ) :				  
  for ( j = 1 ;						      	  for i in range ( 1 , m + 1 ) :			    	    tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j  
  j <= n ;						      	      for j in range ( 1 , n + 1 ) :			    	for i in range ( 1 , m + 1 ) :				  
  j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j 		  tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , t 	    for j in range ( 1 , n + 1 ) :			  
  for ( i = 1 ;						      	  return tc [ m ] [ n ]					    		tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , t 
  i <= m ;						      								    	return tc [ m ] [ n ]					  
  i ++ ) for ( j = 1 ;					      								    								  
  j <= n ;						      								    								  
  j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ 								    								  
  return tc [ m ] [ n ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA
--							      --							    --								  --
static int maxdiff ( int arr [ ] , int n ) {		      def maxdiff ( arr , n ) :					    def maxdiff ( arr , n ) :					  script_not_found : None
  Map < Integer , Integer > freq = new HashMap < > ( ) ;      	  freq = defaultdict ( lambda : 0 )			    	freq = { }						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      freq [ arr [ i ] ] += 1				    	    freq [ arr [ i ] ] = 1 if freq.get ( arr [ i ] ) is N 
  i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) == 	  ans = 0						    	ans = 0							  
  int ans = 0 ;						      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
  i < n ;						      		  if freq [ arr [ i ] ] > freq [ arr [ j ] ] and ar 		if freq [ arr [ i ] ] > freq [ arr [ j ] ] and ar 
  i ++ ) {						      		      ans = max ( ans , freq [ arr [ i ] ] - freq [ 		    ans = max ( ans , freq [ arr [ i ] ] - freq [ 
    for ( int j = 0 ;					      		  elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and  		elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and  
    j < n ;						      		      ans = max ( ans , freq [ arr [ j ] ] - freq [ 		    ans = max ( ans , freq [ arr [ j ] ] - freq [ 
    j ++ ) {						      	  return ans						    	return ans						  
      if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ]  								    								  
      else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ 								    								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_LONGEST_BALANCED_SUBSEQUENCE			      LENGTH_LONGEST_BALANCED_SUBSEQUENCE			    LENGTH_LONGEST_BALANCED_SUBSEQUENCE				  LENGTH_LONGEST_BALANCED_SUBSEQUENCE
--							      --							    --								  --
static int maxLength ( String s , int n ) {		      def maxLength ( s , n ) :					    def maxLength ( s , n ) :					  script_not_found : None
  int dp [ ] [ ] = new int [ n ] [ n ] ;		      	  dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]  	dp = np.zeros ( ( n , n ) )				  
  for ( int i = 0 ;					      	  for i in range ( n - 1 ) :				    	for i in range ( n - 1 ) :				  
  i < n - 1 ;						      	      if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) :	    	    if s [ i ] == '(' and s [ i + 1 ] == ')' :		  
  i ++ ) if ( s . charAt ( i ) == '(' && s . charAt ( i + 1 ) 		  dp [ i ] [ i + 1 ] = 2			    		dp [ i ] [ i + 1 ] = 2				  
  for ( int l = 2 ;					      	  for l in range ( 2 , n ) :				    	for l in range ( 2 , n ) :				  
  l < n ;						      	      i = - 1						    	    for i , j in enumerate ( l , n ) :			  
  l ++ ) {						      	      for j in range ( l , n ) :			    		if s [ i ] == '(' and s [ j ] == ')' :		  
    for ( int i = 0 , j = l ;				      		  i += 1					    		    dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]	  
    j < n ;						      		  if ( s [ i ] == '(' and s [ j ] == ')' ) :	    		for k in range ( i , j ) :			  
    i ++ , j ++ ) {					      		      dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]   		    dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [  
      if ( s . charAt ( i ) == '(' && s . charAt ( j ) == ')' 		  for k in range ( i , j ) :			    	return dp [ 0 ] [ n - 1 ]				  
      for ( int k = i ;					      		      dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [  								  
      k < j ;						      	  return dp [ 0 ] [ n - 1 ]				    								  
      k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , d 								    								  
    }							      								    								  
  }							      								    								  
  return dp [ 0 ] [ n - 1 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE	      MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE	    MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE		  MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE
--							      --							    --								  --
static int maxLower ( String str ) {			      def maxLower ( str ) :					    def max_lower ( data ) :					  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( data )					  
  int i = 0 ;						      	  i = 0							    	i = 0							  
  for ( ;						      	  for i in range ( n ) :				    	for c in data :						  
  i < n ;						      	      if str [ i ] >= 'A' and str [ i ] <= 'Z' :	    	    if ord ( c ) >= ord ( 'A' ) and ord ( c ) <= ord ( 'Z 
  i ++ ) {						      		  i += 1					    		i += 1						  
    if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= ' 		  break						    		break						  
      i ++ ;						      	  maxCount = 0						    	max_count = 0						  
      break ;						      	  count = [ ]						    	count = [ 0 ] * MAX_CHAR				  
    }							      	  for j in range ( MAX_CHAR ) :				    	for c in data :						  
  }							      	      count.append ( 0 )				    	    if ord ( c ) >= ord ( 'A' ) and ord ( c ) <= ord ( 'Z 
  int maxCount = 0 ;					      	  for j in range ( i , n ) :				    		curr_count = 0					  
  int count [ ] = new int [ MAX_CHAR ] ;		      	      if str [ j ] >= 'A' and str [ j ] <= 'Z' :	    		for i in range ( MAX_CHAR ) :			  
  for ( ;						      		  currCount = 0					    		    if count [ i ] > 0 :			  
  i < n ;						      		  for k in range ( MAX_CHAR ) :			    			curr_count += 1				  
  i ++ ) {						      		      if count [ k ] > 0 :			    		max_count = max ( max_count , curr_count )	  
    if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= ' 			  currCount += 1			    		count [ i ] = 0					  
      int currCount = 0 ;				      		  maxCount = max ( maxCount , currCount )	    	    if ord ( c ) >= ord ( 'a' ) and ord ( c ) <= ord ( 'z 
      for ( int j = 0 ;					      		  for y in count :				    		count [ ord ( c ) - ord ( 'a' ) ] += 1		  
      j < MAX_CHAR ;					      		      y = 0					    	return max_count					  
      j ++ ) {						      	      if str [ j ] >= 'a' and str [ j ] <= 'z' :	    								  
	if ( count [ j ] > 0 ) {			      		  count [ ord ( str [ j ] ) - ord ( 'a' ) ] += 1    								  
	  currCount ++ ;				      	  return maxCount					    								  
	}						      								    								  
      }							      								    								  
      maxCount = Math . max ( maxCount , currCount ) ;	      								    								  
      Arrays . fill ( count , 0 ) ;			      								    								  
    }							      								    								  
    if ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= ' 								    								  
      count [ str . charAt ( i ) - 'a' ] ++ ;		      								    								  
    }							      								    								  
  }							      								    								  
  return maxCount ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS  COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS  COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS  COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS
--							      --							    --								  --
static int countStrings ( int n , int k ) {		      def countStrings ( n , k ) :				    def count_strings ( n , k ) :				  failure : #Results: 8, 10
  int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ;    	  dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in r 	dp = np.zeros ( ( n + 1 , k + 1 , 2 ) )			  
  dp [ 1 ] [ 0 ] [ 0 ] = 1 ;				      	  dp [ 1 ] [ 0 ] [ 0 ] = 1				    	dp [ 1 ] [ 0 ] [ 0 ] = 1				  
  dp [ 1 ] [ 0 ] [ 1 ] = 1 ;				      	  dp [ 1 ] [ 0 ] [ 1 ] = 1				    	dp [ 1 ] [ 0 ] [ 1 ] = 1				  
  for ( int i = 2 ;					      	  for i in range ( 2 , n + 1 ) :			    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      	      for j in range ( k + 1 ) :			    	    for j in range ( i , k + 1 ) :			  
  i ++ ) {						      		  dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] 		dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + 
    for ( int j = 0 ;					      		  dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]   		dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]	  
    j < i && j < k + 1 ;				      		  if j >= 1 :					    		if j - 1 >= 0 :					  
    j ++ ) {						      		      dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1  		    dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1  
      dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [  	  return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]	    	return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]	  
      dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;	      								    								  
      if ( j - 1 >= 0 ) {				      								    								  
	dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]  								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K	      COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K		    COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K		  COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K
--							      --							    --								  --
static void countDistinct ( int arr [ ] , int k ) {	      def countDistinct ( arr , k , n ) :			    def count_distinct ( arr , k ) :				  script_not_found : None
  HashMap < Integer , Integer > hM = new HashMap < Integer ,  	  mp = defaultdict ( lambda : 0 )			    	h_m = { }						  
  int dist_count = 0 ;					      	  dist_count = 0					    	dist_count = 0						  
  for ( int i = 0 ;					      	  for i in range ( k ) :				    	for i in range ( k ) :					  
  i < k ;						      	      if mp [ arr [ i ] ] == 0 :			    	    if h_m.get ( arr [ i ] ) is None :			  
  i ++ ) {						      		  dist_count += 1				    		h_m [ arr [ i ] ] = 1				  
    if ( hM . get ( arr [ i ] ) == null ) {		      	      mp [ arr [ i ] ] += 1				    		dist_count += 1					  
      hM . put ( arr [ i ] , 1 ) ;			      	  print ( dist_count )					    	    else :						  
      dist_count ++ ;					      	  for i in range ( k , n ) :				    		count = h_m.get ( arr [ i ] )			  
    }							      	      if mp [ arr [ i - k ] ] == 1 :			    		h_m [ arr [ i ] ] = count + 1			  
    else {						      		  dist_count -= 1				    	print ( dist_count )					  
      int count = hM . get ( arr [ i ] ) ;		      	      mp [ arr [ i - k ] ] -= 1				    	for i in range ( k , len ( arr ) ) :			  
      hM . put ( arr [ i ] , count + 1 ) ;		      	      if mp [ arr [ i ] ] == 0 :			    	    if h_m [ arr [ i - k ] ] == 1 :			  
    }							      		  dist_count += 1				    		h_m.pop ( arr [ i - k ] )			  
  }							      	      mp [ arr [ i ] ] += 1				    		dist_count -= 1					  
  System . out . println ( dist_count ) ;		      	      print ( dist_count )				    	    else :						  
  for ( int i = k ;					      								    		count = h_m.get ( arr [ i - k ] )		  
  i < arr . length ;					      								    		h_m [ arr [ i - k ] ] = count - 1		  
  i ++ ) {						      								    	    if h_m [ arr [ i ] ] is None :			  
    if ( hM . get ( arr [ i - k ] ) == 1 ) {		      								    		h_m [ arr [ i ] ] = 1				  
      hM . remove ( arr [ i - k ] ) ;			      								    		dist_count += 1					  
      dist_count -- ;					      								    	    else :						  
    }							      								    		count = h_m.get ( arr [ i ] )			  
    else {						      								    		h_m [ arr [ i ] ] = count + 1			  
      int count = hM . get ( arr [ i - k ] ) ;		      								    	    print ( dist_count )				  
      hM . put ( arr [ i - k ] , count - 1 ) ;		      								    								  
    }							      								    								  
    if ( hM . get ( arr [ i ] ) == null ) {		      								    								  
      hM . put ( arr [ i ] , 1 ) ;			      								    								  
      dist_count ++ ;					      								    								  
    }							      								    								  
    else {						      								    								  
      int count = hM . get ( arr [ i ] ) ;		      								    								  
      hM . put ( arr [ i ] , count + 1 ) ;		      								    								  
    }							      								    								  
    System . out . println ( dist_count ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINTING_STRING_PLUS_PATTERN_MATRIX			      PRINTING_STRING_PLUS_PATTERN_MATRIX			    PRINTING_STRING_PLUS_PATTERN_MATRIX				  PRINTING_STRING_PLUS_PATTERN_MATRIX
--							      --							    --								  --
static void carveCross ( String str ) {			      def carveCross ( str ) :					    def carve_cross ( str ) :					  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  if ( n % 2 == 0 ) {					      	  if ( n % 2 == 0 ) :					    	if n % 2 == 0 :						  
    System . out . print ( "Not possible. Please enter " + "o 	      print ( "Not possible.Please enter " , "odd length st 	    print ( "Not possible.Please enter ""odd length strin 
  }							      	  else :						    	else :							  
  else {						      	      arr = [ [ False for x in range ( max ) ] for y in ran 	    arr = [ [ 'X' ] * max ]				  
    char arr [ ] [ ] = new char [ max ] [ max ] ;	      	      m = n // 2					    	    m = n // 2						  
    int m = n / 2 ;					      	      for i in range ( n ) :				    	    for i in range ( n ) :				  
    for ( int i = 0 ;					      		  for j in range ( n ) :			    		for j in range ( n ) :				  
    i < n ;						      		      arr [ i ] [ j ] = 'X'			    		    arr [ i ] [ j ] = 'X'			  
    i ++ ) {						      	      for i in range ( n ) :				    	    for i in range ( n ) :				  
      for ( int j = 0 ;					      		  arr [ i ] [ m ] = str [ i ]			    		arr [ i ] [ m ] = str [ i ]			  
      j < n ;						      	      for i in range ( n ) :				    	    for i in range ( n ) :				  
      j ++ ) {						      		  arr [ m ] [ i ] = str [ i ]			    		arr [ m ] [ i ] = str [ i ]			  
	arr [ i ] [ j ] = 'X' ;				      	      for i in range ( n ) :				    	    for i in range ( n ) :				  
      }							      		  for j in range ( n ) :			    		for j in range ( n ) :				  
    }							      		      print ( arr [ i ] [ j ] , end = " " )	    		    print ( arr [ i ] [ j ] , end = "" )	  
    for ( int i = 0 ;					      		  print ( )					    		print ( "\n" , end = "" )			  
    i < n ;						      								    								  
    i ++ ) {						      								    								  
      arr [ i ] [ m ] = str . charAt ( i ) ;		      								    								  
    }							      								    								  
    for ( int i = 0 ;					      								    								  
    i < n ;						      								    								  
    i ++ ) {						      								    								  
      arr [ m ] [ i ] = str . charAt ( i ) ;		      								    								  
    }							      								    								  
    for ( int i = 0 ;					      								    								  
    i < n ;						      								    								  
    i ++ ) {						      								    								  
      for ( int j = 0 ;					      								    								  
      j < n ;						      								    								  
      j ++ ) {						      								    								  
	System . out . print ( arr [ i ] [ j ] + " " ) ;      								    								  
      }							      								    								  
      System . out . print ( "\n" ) ;			      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY		      MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY			    MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY			  MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY
--							      --							    --								  --
public static int minSwaps ( int [ ] arr ) {		      def minSwaps ( arr ) :					    def min_swaps ( arr ) :					  script_not_found : None
  int n = arr . length ;				      	  n = len ( arr )					    	n = len ( arr )						  
  ArrayList < Pair < Integer , Integer >> arrpos = new ArrayL 	  arrpos = [ * enumerate ( arr ) ]			    	arrpos = [ ( arr [ i ] , i ) for i in range ( n ) ]	  
  for ( int i = 0 ;					      	  arrpos.sort ( key = lambda it : it [ 1 ] )		    	arrpos.sort ( lambda x , y : cmp ( x [ 0 ] , y [ 0 ] ) )  
  i < n ;						      	  vis = { k : False for k in range ( n ) }		    	vis = [ False ] * n					  
  i ++ ) arrpos . add ( new Pair < Integer , Integer > ( arr  	  ans = 0						    	ans = 0							  
  arrpos . sort ( new Comparator < Pair < Integer , Integer > 	  for i in range ( n ) :				    	for i in range ( n ) :					  
    @ Override public int compare ( Pair < Integer , Integer  	      if vis [ i ] or arrpos [ i ] [ 0 ] == i :		    	    if vis [ i ] or arrpos [ i ] [ 1 ] == i :		  
      if ( o1 . getKey ( ) > o2 . getKey ( ) ) return - 1 ;   		  continue					    		continue					  
      else if ( o1 . getKey ( ) . equals ( o2 . getKey ( ) )  	      cycle_size = 0					    	    cycle_size = 0					  
      else return 1 ;					      	      j = i						    	    j = i						  
    }							      	      while not vis [ j ] :				    	    while not vis [ j ] :				  
  }							      		  vis [ j ] = True				    		vis [ j ] = True				  
  ) ;							      		  j = arrpos [ j ] [ 0 ]			    		j = arrpos [ j ] [ 1 ]				  
  Boolean [ ] vis = new Boolean [ n ] ;			      		  cycle_size += 1				    		cycle_size += 1					  
  Arrays . fill ( vis , false ) ;			      	      if cycle_size > 0 :				    	    if cycle_size > 0 :					  
  int ans = 0 ;						      		  ans += ( cycle_size - 1 )			    		ans += ( cycle_size - 1 )			  
  for ( int i = 0 ;					      	  return ans						    	return ans						  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    if ( vis [ i ] || arrpos . get ( i ) . getValue ( ) == i  								    								  
    int cycle_size = 0 ;				      								    								  
    int j = i ;						      								    								  
    while ( ! vis [ j ] ) {				      								    								  
      vis [ j ] = true ;				      								    								  
      j = arrpos . get ( j ) . getValue ( ) ;		      								    								  
      cycle_size ++ ;					      								    								  
    }							      								    								  
    if ( cycle_size > 0 ) {				      								    								  
      ans += ( cycle_size - 1 ) ;			      								    								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1		      FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1		    FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1			  FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1
--							      --							    --								  --
static int findGreatest ( int arr [ ] , int n ) {	      def findGreatest ( arr , n ) :				    def find_greatest ( arr , n ) :				  script_not_found : None
  Map < Integer , Integer > m = new HashMap < > ( ) ;	      	  m = dict ( )						    	m = { }							  
  for ( int i = 0 ;					      	  for i in arr :					    	for i in range ( n ) :					  
  i < n ;						      	      m [ i ] = m.get ( i , 0 ) + 1			    	    if arr [ i ] in m :					  
  i ++ ) {						      	  arr = sorted ( arr )					    		m [ arr [ i ] ] = m [ arr [ i ] ] + 1		  
    if ( m . containsKey ( arr [ i ] ) ) {		      	  for i in range ( n - 1 , 0 , - 1 ) :			    	    else :						  
      m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ;     	      j = 0						    		m [ arr [ i ] ] = m [ arr [ i ] ]		  
    }							      	      while ( j < i and arr [ j ] <= sqrt ( arr [ i ] ) ) : 	arr.sort ( )						  
    else {						      		  if ( arr [ i ] % arr [ j ] == 0 ) :		    	for i in range ( n - 1 , 1 , - 1 ) :			  
      m . put ( arr [ i ] , m . get ( arr [ i ] ) ) ;	      		      result = arr [ i ] // arr [ j ]		    	    for j in range ( 0 , i ) and arr [ j ] <= math.sqrt ( 
    }							      		      if ( result != arr [ j ] and ( result in m.ke 		if arr [ i ] % arr [ j ] == 0 :			  
  }							      			  return arr [ i ]			    		    result = arr [ i ] // arr [ j ]		  
  Arrays . sort ( arr ) ;				      		      elif ( result == arr [ j ] and ( result in m. 		    if result != arr [ j ] and m.get ( result ) i 
  for ( int i = n - 1 ;					      			  return arr [ i ]			    			return arr [ i ]			  
  i > 1 ;						      		  j += 1					    		    elif result == arr [ j ] and m [ result ] > 1 
  i -- ) {						      	  return - 1						    			return arr [ i ]			  
    for ( int j = 0 ;					      								    	return - 1						  
    j < i && arr [ j ] <= Math . sqrt ( arr [ i ] ) ;	      								    								  
    j ++ ) {						      								    								  
      if ( arr [ i ] % arr [ j ] == 0 ) {		      								    								  
	int result = arr [ i ] / arr [ j ] ;		      								    								  
	if ( result != arr [ j ] && m . get ( result ) == nul 								    								  
	  return arr [ i ] ;				      								    								  
	}						      								    								  
	else if ( result == arr [ j ] && m . get ( result ) > 								    								  
	  return arr [ i ] ;				      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1	      DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1		    DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1		  DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1
--							      --							    --								  --
static int eggDrop ( int n , int k ) {			      def eggDrop ( n , k ) :					    def eggDrop ( n , k ) :					  script_not_found : None
  int eggFloor [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ;	      	  eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in rang 	eggFloor = np.zeros ( ( n + 1 , k + 1 ) )		  
  int res ;						      	  for i in range ( 1 , n + 1 ) :			    	res = 0							  
  int i , j , x ;					      	      eggFloor [ i ] [ 1 ] = 1				    	i , j , x = 0 , 0 , 0					  
  for ( i = 1 ;						      	      eggFloor [ i ] [ 0 ] = 0				    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	  for j in range ( 1 , k + 1 ) :			    	    eggFloor [ i ] [ 1 ] = 1				  
  i ++ ) {						      	      eggFloor [ 1 ] [ j ] = j				    	    eggFloor [ i ] [ 0 ] = 0				  
    eggFloor [ i ] [ 1 ] = 1 ;				      	  for i in range ( 2 , n + 1 ) :			    	for j in range ( 1 , k + 1 ) :				  
    eggFloor [ i ] [ 0 ] = 0 ;				      	      for j in range ( 2 , k + 1 ) :			    	    eggFloor [ 1 ] [ j ] = j				  
  }							      		  eggFloor [ i ] [ j ] = INT_MAX		    	for i in range ( 2 , n + 1 ) :				  
  for ( j = 1 ;						      		  for x in range ( 1 , j + 1 ) :		    	    for j in range ( 2 , k + 1 ) :			  
  j <= k ;						      		      res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ]  		eggFloor [ i ] [ j ] = np.inf			  
  j ++ ) eggFloor [ 1 ] [ j ] = j ;			      		      if res < eggFloor [ i ] [ j ] :		    		for x in range ( 1 , j + 1 ) :			  
  for ( i = 2 ;						      			  eggFloor [ i ] [ j ] = res		    		    res = 1 + np.max ( eggFloor [ i - 1 ] [ x - 1 
  i <= n ;						      	  return eggFloor [ n ] [ k ]				    		    if res < eggFloor [ i ] [ j ] :		  
  i ++ ) {						      								    			eggFloor [ i ] [ j ] = res		  
    for ( j = 2 ;					      								    	return eggFloor [ n ] [ k ]				  
    j <= k ;						      								    								  
    j ++ ) {						      								    								  
      eggFloor [ i ] [ j ] = Integer . MAX_VALUE ;	      								    								  
      for ( x = 1 ;					      								    								  
      x <= j ;						      								    								  
      x ++ ) {						      								    								  
	res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFlo 								    								  
	if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j  								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return eggFloor [ n ] [ k ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY		      FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY		    FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY		  FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY
--							      --							    --								  --
static int findRepeatingNumber ( int [ ] arr , int n ) {      def findRepeatingNumber ( arr , n ) :			    def find_repeating_number ( arr , n ) :			  script_not_found : None
  int sq = ( int ) Math . sqrt ( n ) ;			      	  sq = sqrt ( n )					    	sq = int ( math.sqrt ( n ) )				  
  int range = ( n / sq ) + 1 ;				      	  range__ = int ( ( n / sq ) + 1 )			    	range = ( n // sq ) + 1					  
  int [ ] count = new int [ range ] ;			      	  count = [ 0 for i in range ( range__ ) ]		    	count = [ 0 ] * range					  
  for ( int i = 0 ;					      	  for i in range ( 0 , n + 1 , 1 ) :			    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      count [ int ( ( arr [ i ] - 1 ) / sq ) ] += 1	    	    count [ ( arr [ i ] - 1 ) // sq ] += 1		  
  i ++ ) {						      	  selected_block = range__ - 1				    	selected_block = range - 1				  
    count [ ( arr [ i ] - 1 ) / sq ] ++ ;		      	  for i in range ( 0 , range__ - 1 , 1 ) :		    	for i in range ( range - 1 ) :				  
  }							      	      if ( count [ i ] > sq ) :				    	    if count [ i ] > sq :				  
  int selected_block = range - 1 ;			      		  selected_block = i				    		selected_block = i				  
  for ( int i = 0 ;					      		  break						    		break						  
  i < range - 1 ;					      	  m = { i : 0 for i in range ( n ) }			    	m = { }							  
  i ++ ) {						      	  for i in range ( 0 , n + 1 , 1 ) :			    	for i in range ( 0 , n + 1 ) :				  
    if ( count [ i ] > sq ) {				      	      if ( ( ( selected_block * sq ) < arr [ i ] ) and ( ar 	    if ( ( selected_block * sq ) < arr [ i ] ) and ( arr  
      selected_block = i ;				      		  m [ arr [ i ] ] += 1				    		m [ arr [ i ] ] = 1				  
      break ;						      		  if ( m [ arr [ i ] ] > 1 ) :			    		if m [ arr [ i ] ] == 1 :			  
    }							      		      return arr [ i ]				    		    return arr [ i ]				  
  }							      	  return - 1						    	return - 1						  
  HashMap < Integer , Integer > m = new HashMap < > ( ) ;     								    								  
  for ( int i = 0 ;					      								    								  
  i <= n ;						      								    								  
  i ++ ) {						      								    								  
    if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i 								    								  
      m . put ( arr [ i ] , 1 ) ;			      								    								  
      if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ;    								    								  
    }							      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1		      SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1			    SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1			  SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1
--							      --							    --								  --
public static void sortSquares ( int arr [ ] ) {	      def sortSquares ( arr , n ) :				    def sort_squares ( arr ) :					  script_not_found : None
  int n = arr . length ;				      	  K = 0							    	n = len ( arr )						  
  int k ;						      	  for K in range ( n ) :				    	k = 0							  
  for ( k = 0 ;						      	      if ( arr [ K ] >= 0 ) :				    	for k in range ( n ) :					  
  k < n ;						      		  break						    	    if arr [ k ] >= 0 :					  
  k ++ ) {						      	  i = K - 1						    		break						  
    if ( arr [ k ] >= 0 ) break ;			      	  j = K							    	i = k - 1						  
  }							      	  ind = 0						    	j = k							  
  int i = k - 1 ;					      	  temp = [ 0 ] * n					    	ind = 0							  
  int j = k ;						      	  while ( i >= 0 and j < n ) :				    	temp = [ 0 ] * n					  
  int ind = 0 ;						      	      if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] )  	while i >= 0 and j < n :				  
  int [ ] temp = new int [ n ] ;			      		  temp [ ind ] = arr [ i ] * arr [ i ]		    	    if arr [ i ] ** 2 < arr [ j ] ** 2 :		  
  while ( i >= 0 && j < n ) {				      		  i -= 1					    		temp [ ind ] = arr [ i ] ** 2			  
    if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) {    	      else :						    		i -= 1						  
      temp [ ind ] = arr [ i ] * arr [ i ] ;		      		  temp [ ind ] = arr [ j ] * arr [ j ]		    	    else :						  
      i -- ;						      		  j += 1					    		temp [ ind ] = arr [ j ] ** 2			  
    }							      	      ind += 1						    		j += 1						  
    else {						      	  while ( i >= 0 ) :					    	    ind += 1						  
      temp [ ind ] = arr [ j ] * arr [ j ] ;		      	      temp [ ind ] = arr [ i ] * arr [ i ]		    	while i >= 0 :						  
      j ++ ;						      	      i -= 1						    	    temp [ ind ] = arr [ i ] ** 2			  
    }							      	      ind += 1						    	    i -= 1						  
    ind ++ ;						      	  while ( j < n ) :					    	while j < n :						  
  }							      	      temp [ ind ] = arr [ j ] * arr [ j ]		    	    temp [ ind ] = arr [ j ] ** 2			  
  while ( i >= 0 ) {					      	      j += 1						    	    j += 1						  
    temp [ ind ++ ] = arr [ i ] * arr [ i ] ;		      	      ind += 1						    	for x in range ( n ) :					  
    i -- ;						      	  for i in range ( n ) :				    	    arr [ x ] = temp [ x ]				  
  }							      	      arr [ i ] = temp [ i ]				    								  
  while ( j < n ) {					      								    								  
    temp [ ind ++ ] = arr [ j ] * arr [ j ] ;		      								    								  
    j ++ ;						      								    								  
  }							      								    								  
  for ( int x = 0 ;					      								    								  
  x < n ;						      								    								  
  x ++ ) arr [ x ] = temp [ x ] ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING		      SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING		    SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING			  SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING
--							      --							    --								  --
static String findSubString ( String str ) {		      def findSubString ( str ) :				    def findSubString ( str ) :					  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  int dist_count = 0 ;					      	  dist_count = len ( set ( [ x for x in str ] ) )	    	dist_count = 0						  
  boolean [ ] visited = new boolean [ MAX_CHARS ] ;	      	  count , start , start_index , min_len = 0 , 0 , - 1 , 999 	visited = [ False ] * MAX_CHARS				  
  Arrays . fill ( visited , false ) ;			      	  curr_count = defaultdict ( lambda : 0 )		    	for c in str :						  
  for ( int i = 0 ;					      	  for j in range ( n ) :				    	    if visited [ c ] == False :				  
  i < n ;						      	      curr_count [ str [ j ] ] += 1			    		visited [ c ] = True				  
  i ++ ) {						      	      if curr_count [ str [ j ] ] == 1 :		    		dist_count += 1					  
    if ( visited [ str . charAt ( i ) ] == false ) {	      		  count += 1					    	start , start_index = 0 , - 1				  
      visited [ str . charAt ( i ) ] = true ;		      	      if count == dist_count :				    	min_len = sys.maxsize					  
      dist_count ++ ;					      		  while curr_count [ str [ start ] ] > 1 :	    	count = 0						  
    }							      		      if curr_count [ str [ start ] ] > 1 :	    	curr_count = [ 0 ] * MAX_CHARS				  
  }							      			  curr_count [ str [ start ] ] -= 1	    	for c in str :						  
  int start = 0 , start_index = - 1 ;			      		      start += 1				    	    curr_count [ c ] += 1				  
  int min_len = Integer . MAX_VALUE ;			      		  len_window = j - start + 1			    	    if curr_count [ c ] == 1 :				  
  int count = 0 ;					      		  if min_len > len_window :			    		count += 1					  
  int [ ] curr_count = new int [ MAX_CHARS ] ;		      		      min_len = len_window			    	    if count == dist_count :				  
  for ( int j = 0 ;					      		      start_index = start			    		while curr_count [ start ] > 1 :		  
  j < n ;						      	  return str [ start_index : start_index + min_len ]	    		    if curr_count [ start ] > 1 :		  
  j ++ ) {						      								    			curr_count [ start ] -= 1		  
    curr_count [ str . charAt ( j ) ] ++ ;		      								    		    start += 1					  
    if ( curr_count [ str . charAt ( j ) ] == 1 ) count ++ ;  								    		len_window = c - start + 1			  
    if ( count == dist_count ) {			      								    		if min_len > len_window :			  
      while ( curr_count [ str . charAt ( start ) ] > 1 ) {   								    		    min_len = len_window			  
	if ( curr_count [ str . charAt ( start ) ] > 1 ) curr 								    		    start_index = start				  
	start ++ ;					      								    	return str [ start_index : start_index + min_len ]	  
      }							      								    								  
      int len_window = j - start + 1 ;			      								    								  
      if ( min_len > len_window ) {			      								    								  
	min_len = len_window ;				      								    								  
	start_index = start ;				      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return str . substring ( start_index , start_index + min_le 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING	      EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING	    EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING		  EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING
--							      --							    --								  --
static int evaluateBoolExpr ( StringBuffer s ) {	      def evaluateBoolExpr ( s ) :				    def evaluate_bool_expr ( s ) :				  script_not_found : None
  int n = s . length ( ) ;				      	  n = len ( s )						    	n = len ( s )						  
  for ( int i = 0 ;					      	  for i in range ( 0 , n - 2 , 2 ) :			    	for i in range ( 0 , n , 2 ) :				  
  i < n ;						      	      if ( s [ i + 1 ] == "A" ) :			    	    if i + 1 < n and i + 2 < n :			  
  i += 2 ) {						      		  if ( s [ i + 2 ] == "0" or s [ i ] == "0" ) :	    		if s [ i + 1 ] == 'A' :				  
    if ( i + 1 < n && i + 2 < n ) {			      		      s [ i + 2 ] = "0"				    		    if s [ i + 2 ] in [ '0' , '' ] :		  
      if ( s . charAt ( i + 1 ) == 'A' ) {		      		  else :					    			s [ i + 2 ] = '0'			  
	if ( s . charAt ( i + 2 ) == '0' || s . charAt ( i )  		      s [ i + 2 ] = "1"				    		    else :					  
	else s . setCharAt ( i + 2 , '1' ) ;		      	      elif ( s [ i + 1 ] == "B" ) :			    			s [ i + 2 ] = '1'			  
      }							      		  if ( s [ i + 2 ] == "1" or s [ i ] == "1" ) :	    		elif ( i + 1 ) < n and s [ i + 1 ] == 'B' :	  
      else if ( ( i + 1 ) < n && s . charAt ( i + 1 ) == 'B'  		      s [ i + 2 ] = "1"				    		    if s [ i + 2 ] in [ '1' , '1' ] :		  
	if ( s . charAt ( i + 2 ) == '1' || s . charAt ( i )  		  else :					    			s [ i + 2 ] = '1'			  
	else s . setCharAt ( i + 2 , '0' ) ;		      		      s [ i + 2 ] = "0"				    		    else :					  
      }							      	      else :						    			s [ i + 2 ] = '0'			  
      else {						      		  if ( s [ i + 2 ] == s [ i ] ) :		    		else :						  
	if ( s . charAt ( i + 2 ) == s . charAt ( i ) ) s . s 		      s [ i + 2 ] = "0"				    		    if s [ i + 2 ] == s [ i ] :			  
	else s . setCharAt ( i + 2 , '1' ) ;		      		  else :					    			s [ i + 2 ] = '0'			  
      }							      		      s [ i + 2 ] = "1"				    		    else :					  
    }							      	  return ord ( s [ n - 1 ] ) - ord ( "0" )		    			s [ i + 2 ] = '1'			  
  }							      								    	return s [ n - 1 ] - '0'				  
  return s . charAt ( n - 1 ) - '0' ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_ENDLESS_POINTS				      FIND_NUMBER_ENDLESS_POINTS				    FIND_NUMBER_ENDLESS_POINTS					  FIND_NUMBER_ENDLESS_POINTS
--							      --							    --								  --
static int countEndless ( boolean input [ ] [ ] , int n ) {   def countEndless ( input_mat , n ) :			    def count_endless ( input , n ) :				  script_not_found : None
  boolean row [ ] [ ] = new boolean [ n ] [ n ] ;	      	  row = np.zeros ( ( n , n ) )				    	row = np.zeros ( ( n , n ) )				  
  boolean col [ ] [ ] = new boolean [ n ] [ n ] ;	      	  col = np.zeros ( ( n , n ) )				    	col = np.zeros ( ( n , n ) )				  
  for ( int j = 0 ;					      	  for j in range ( n ) :				    	for j in range ( n ) :					  
  j < n ;						      	      isEndless = 1					    	    is_endless = True					  
  j ++ ) {						      	      for i in range ( n - 1 , - 1 , - 1 ) :		    	    for i in range ( n - 1 , - 1 , - 1 ) :		  
    boolean isEndless = true ;				      		  if ( input_mat [ i ] [ j ] == 0 ) :		    		if input [ i ] [ j ] == False :			  
    for ( int i = n - 1 ;				      		      isEndless = 0				    		    is_endless = False				  
    i >= 0 ;						      		  col [ i ] [ j ] = isEndless			    	    col [ i ] [ j ] = is_endless			  
    i -- ) {						      	  for i in range ( n ) :				    	for i in range ( n ) :					  
      if ( input [ i ] [ j ] == false ) isEndless = false ;   	      isEndless = 1					    	    is_endless = True					  
      col [ i ] [ j ] = isEndless ;			      	      for j in range ( n - 1 , - 1 , - 1 ) :		    	    for j in range ( n - 1 , - 1 , - 1 ) :		  
    }							      		  if ( input_mat [ i ] [ j ] == 0 ) :		    		if input [ i ] [ j ] == False :			  
  }							      		      isEndless = 0				    		    is_endless = False				  
  for ( int i = 0 ;					      		  row [ i ] [ j ] = isEndless			    		row [ i ] [ j ] = is_endless			  
  i < n ;						      	  ans = 0						    	ans = 0							  
  i ++ ) {						      	  for i in range ( n ) :				    	for i in range ( n ) :					  
    boolean isEndless = true ;				      	      for j in range ( 1 , n ) :			    	    for j in range ( 1 , n ) :				  
    for ( int j = n - 1 ;				      		  if ( row [ i ] [ j ] and col [ i ] [ j ] ) :	    		if row [ i ] [ j ] and col [ i ] [ j ] :	  
    j >= 0 ;						      		      ans += 1					    		    ans += 1					  
    j -- ) {						      	  return ans						    	return ans						  
      if ( input [ i ] [ j ] == false ) isEndless = false ;   								    								  
      row [ i ] [ j ] = isEndless ;			      								    								  
    }							      								    								  
  }							      								    								  
  int ans = 0 ;						      								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) for ( int j = 1 ;				      								    								  
  j < n ;						      								    								  
  j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ;   								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PATH_SUM_MATRIX					      MAXIMUM_PATH_SUM_MATRIX					    MAXIMUM_PATH_SUM_MATRIX					  MAXIMUM_PATH_SUM_MATRIX
--							      --							    --								  --
static int findMaxPath ( int mat [ ] [ ] ) {		      def findMaxPath ( mat ) :					    def find_max_path ( mat ) :					  script_not_found : None
  int res = - 1 ;					      	  res = - 1						    	res = - 1						  
  for ( int i = 0 ;					      	  for i in range ( M ) :				    	for i in range ( M ) :					  
  i < M ;						      	      res = max ( res , mat [ 0 ] [ i ] )		    	    res = max ( res , mat [ 0 ] [ i ] )			  
  i ++ ) res = max ( res , mat [ 0 ] [ i ] ) ;		      	  for i in range ( 1 , N ) :				    	for i in range ( 1 , N ) :				  
  for ( int i = 1 ;					      	      res = - 1						    	    res = - 1						  
  i < N ;						      	      for j in range ( M ) :				    	    for j in range ( M ) :				  
  i ++ ) {						      		  if ( j > 0 and j < M - 1 ) :			    		if j > 0 and j < M - 1 :			  
    res = - 1 ;						      		      mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ]  		    mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ]  
    for ( int j = 0 ;					      		  elif ( j > 0 ) :				    		elif j > 0 :					  
    j < M ;						      		      mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ]  		    mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ]  
    j ++ ) {						      		  elif ( j < M - 1 ) :				    		elif j < M - 1 :				  
      if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat  		      mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ]  		    mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ]  
      else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1  		  res = max ( mat [ i ] [ j ] , res )		    		res = max ( mat [ i ] [ j ] , res )		  
      else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i  	  return res						    	return res						  
      res = max ( mat [ i ] [ j ] , res ) ;		      								    								  
    }							      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING	      DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING	    DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING		  DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING
--							      --							    --								  --
static int carAssembly ( int a [ ] [ ] , int t [ ] [ ] , int  def carAssembly ( a , t , e , x ) :			    def car_assembly ( a , t , e , x ) :			  script_not_found : None
  int T1 [ ] = new int [ NUM_STATION ] ;		      	  NUM_STATION = len ( a [ 0 ] )				    	T1 = [ 0 ] * NUM_STATION				  
  int T2 [ ] = new int [ NUM_STATION ] ;		      	  T1 = [ 0 for i in range ( NUM_STATION ) ]		    	T2 = [ 0 ] * NUM_STATION				  
  int i ;						      	  T2 = [ 0 for i in range ( NUM_STATION ) ]		    	i = 0							  
  T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;			      	  T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ]			    	T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ]			  
  T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;			      	  T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ]			    	T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ]			  
  for ( i = 1 ;						      	  for i in range ( 1 , NUM_STATION ) :			    	for i in range ( 1 , NUM_STATION ) :			  
  i < NUM_STATION ;					      	      T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [  	    T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [  
  ++ i ) {						      	      T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [  	    T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [  
    T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i -  	  return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_ 	return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_ 
    T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i -  								    								  
  }							      								    								  
  return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_ST 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_GREATER_FREQUENCY_ELEMENT				      NEXT_GREATER_FREQUENCY_ELEMENT				    NEXT_GREATER_FREQUENCY_ELEMENT				  NEXT_GREATER_FREQUENCY_ELEMENT
--							      --							    --								  --
static void NFG ( int a [ ] , int n , int freq [ ] ) {	      def NFG ( a , n ) :					    def NFG ( a , n , freq ) :					  script_not_found : None
  Stack < Integer > s = new Stack < Integer > ( ) ;	      	  if ( n <= 0 ) :					    	s = [ 0 ]						  
  s . push ( 0 ) ;					      	      print ( "List empty" )				    	res = [ 0 for i in range ( n ) ]			  
  int res [ ] = new int [ n ] ;				      	      return [ ]					    	for i in range ( 1 , n ) :				  
  for ( int i = 0 ;					      	  stack = [ 0 ] * n					    	    if freq [ a [ s [ - 1 ] ] ] > freq [ a [ i ] ] :	  
  i < n ;						      	  freq = { }						    		s.append ( i )					  
  i ++ ) res [ i ] = 0 ;				      	  for i in a :						    	    else :						  
  for ( int i = 1 ;					      	      freq [ a [ i ] ] = 0				    		while freq [ a [ s [ - 1 ] ] ] < freq [ a [ i ] ] 
  i < n ;						      	  for i in a :						    		    res [ s [ - 1 ] ] = a [ i ]			  
  i ++ ) {						      	      freq [ a [ i ] ] += 1				    		    s.pop ( )					  
    if ( freq [ a [ s . peek ( ) ] ] > freq [ a [ i ] ] ) s . 	  res = [ 0 ] * n					    		s.append ( i )					  
    else {						      	  top = - 1						    	while s :						  
      while ( freq [ a [ s . peek ( ) ] ] < freq [ a [ i ] ]  	  top += 1						    	    res [ s [ - 1 ] ] = - 1				  
	res [ s . peek ( ) ] = a [ i ] ;		      	  stack [ top ] = 0					    	    s.pop ( )						  
	s . pop ( ) ;					      	  for i in range ( 1 , n ) :				    	for i in range ( n ) :					  
      }							      	      if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ]  	    print ( res [ i ] , end = ' ' )			  
      s . push ( i ) ;					      		  top += 1					    								  
    }							      		  stack [ top ] = i				    								  
  }							      	      else :						    								  
  while ( s . size ( ) > 0 ) {				      		  while ( top > - 1 and freq [ a [ stack [ top ] ]  								  
    res [ s . peek ( ) ] = - 1 ;			      		      res [ stack [ top ] ] = a [ i ]		    								  
    s . pop ( ) ;					      		      top -= 1					    								  
  }							      		  top += 1					    								  
  for ( int i = 0 ;					      		  stack [ top ] = i				    								  
  i < n ;						      	  while ( top > - 1 ) :					    								  
  i ++ ) {						      	      res [ stack [ top ] ] = - 1			    								  
    System . out . print ( res [ i ] + " " ) ;		      	      top -= 1						    								  
  }							      	  return res						    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_TWO_LARGE_NUMBERS					      SUM_TWO_LARGE_NUMBERS					    SUM_TWO_LARGE_NUMBERS					  SUM_TWO_LARGE_NUMBERS
--							      --							    --								  --
static String findSum ( String str1 , String str2 ) {	      def findSum ( str1 , str2 ) :				    def findSum ( str1 , str2 ) :				  failure : #Results: 0, 10
  if ( str1 . length ( ) > str2 . length ( ) ) {	      	  if ( len ( str1 ) > len ( str2 ) ) :			    	if len ( str1 ) > len ( str2 ) :			  
    String t = str1 ;					      	      t = str1						    	    t = str1						  
    str1 = str2 ;					      	      str1 = str2					    	    str1 = str2						  
    str2 = t ;						      	      str2 = t						    	    str2 = t						  
  }							      	  str = ""						    	str = ""						  
  String str = "" ;					      	  n1 = len ( str1 )					    	n1 , n2 = len ( str1 ) , len ( str2 )			  
  int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;	      	  n2 = len ( str2 )					    	str1 = list ( str1 )					  
  str1 = new StringBuilder ( str1 ) . reverse ( ) . toString  	  str1 = str1 [ : : - 1 ]				    	str2 = list ( str2 )					  
  str2 = new StringBuilder ( str2 ) . reverse ( ) . toString  	  str2 = str2 [ : : - 1 ]				    	carry = 0						  
  int carry = 0 ;					      	  carry = 0						    	for i in range ( n1 ) :					  
  for ( int i = 0 ;					      	  for i in range ( n1 ) :				    	    sum = ( ord ( str1 [ i ] ) - ord ( '0' ) + ord ( str2 
  i < n1 ;						      	      sum = ( ( ord ( str1 [ i ] ) - 48 ) + ( ( ord ( str2  	    str += chr ( sum % 10 + ord ( '0' ) )		  
  i ++ ) {						      	      str += chr ( sum % 10 + 48 )			    	    carry = sum // 10					  
    int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int 	      carry = int ( sum / 10 )				    	for i in range ( n1 , n2 ) :				  
    str += ( char ) ( sum % 10 + '0' ) ;		      	  for i in range ( n1 , n2 ) :				    	    sum = ( ord ( str2 [ i ] ) - ord ( '0' ) + carry )	  
    carry = sum / 10 ;					      	      sum = ( ( ord ( str2 [ i ] ) - 48 ) + carry )	    	    str += chr ( sum % 10 + ord ( '0' ) )		  
  }							      	      str += chr ( sum % 10 + 48 )			    	    carry = sum // 10					  
  for ( int i = n1 ;					      	      carry = ( int ) ( sum / 10 )			    	if carry > 0 :						  
  i < n2 ;						      	  if ( carry ) :					    	    str += chr ( carry + ord ( '0' ) )			  
  i ++ ) {						      	      str += chr ( carry + 48 )				    	str = list ( str )					  
    int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry 	  str = str [ : : - 1 ]					    	return str						  
    str += ( char ) ( sum % 10 + '0' ) ;		      	  return str						    								  
    carry = sum / 10 ;					      								    								  
  }							      								    								  
  if ( carry > 0 ) str += ( char ) ( carry + '0' ) ;	      								    								  
  str = new StringBuilder ( str ) . reverse ( ) . toString (  								    								  
  return str ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORTING_USING_TRIVIAL_HASH_FUNCTION_1			      SORTING_USING_TRIVIAL_HASH_FUNCTION_1			    SORTING_USING_TRIVIAL_HASH_FUNCTION_1			  SORTING_USING_TRIVIAL_HASH_FUNCTION_1
--							      --							    --								  --
static void sortUsingHash ( int a [ ] , int n ) {	      def sortUsingHash ( a , n ) :				    def sort_using_hash ( a , n ) :				  script_not_found : None
  int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ;  	  Max = max ( a )					    	max = np.max ( a )					  
  int min = Math . abs ( Arrays . stream ( a ) . min ( ) . ge 	  Min = abs ( min ( a ) )				    	min = abs ( np.min ( a ) )				  
  int hashpos [ ] = new int [ max + 1 ] ;		      	  hashpos = [ 0 ] * ( Max + 1 )				    	hashpos = np.zeros ( max + 1 )				  
  int hashneg [ ] = new int [ min + 1 ] ;		      	  hashneg = [ 0 ] * ( Min + 1 )				    	hashneg = np.zeros ( min + 1 )				  
  for ( int i = 0 ;					      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if a [ i ] >= 0 :					    	    if a [ i ] >= 0 :					  
  i ++ ) {						      		  hashpos [ a [ i ] ] += 1			    		hashpos [ a [ i ] ] += 1			  
    if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ;	      	      else :						    	    else :						  
    else hashneg [ Math . abs ( a [ i ] ) ] += 1 ;	      		  hashneg [ abs ( a [ i ] ) ] += 1		    		hashneg [ abs ( a [ i ] ) ] += 1		  
  }							      	  for i in range ( Min , 0 , - 1 ) :			    	for i in range ( min , 0 , - 1 ) :			  
  for ( int i = min ;					      	      if hashneg [ i ] != 0 :				    	    if hashneg [ i ] > 0 :				  
  i > 0 ;						      		  for j in range ( 0 , hashneg [ i ] ) :	    		for j in range ( hashneg [ i ] ) :		  
  i -- ) {						      		      print ( ( - 1 ) * i , end = " " )		    		    print ( ( - 1 ) * i , end = ' ' )		  
    if ( hashneg [ i ] > 0 ) {				      	  for i in range ( 0 , Max + 1 ) :			    	for i in range ( 0 , max + 1 ) :			  
      for ( int j = 0 ;					      	      if hashpos [ i ] != 0 :				    	    if hashpos [ i ] > 0 :				  
      j < hashneg [ i ] ;				      		  for j in range ( 0 , hashpos [ i ] ) :	    		for j in range ( hashpos [ i ] ) :		  
      j ++ ) {						      		      print ( i , end = " " )			    		    print ( i , end = ' ' )			  
	System . out . print ( ( - 1 ) * i + " " ) ;	      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  for ( int i = 0 ;					      								    								  
  i <= max ;						      								    								  
  i ++ ) {						      								    								  
    if ( hashpos [ i ] > 0 ) {				      								    								  
      for ( int j = 0 ;					      								    								  
      j < hashpos [ i ] ;				      								    								  
      j ++ ) {						      								    								  
	System . out . print ( i + " " ) ;		      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1		      COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1		    COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1		  COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1
--							      --							    --								  --
static int countPS ( int i , int j ) {			      def countPS ( i , j ) :					    def count_ps ( i , j ) :					  script_not_found : None
  if ( i >= n || j < 0 ) return 0 ;			      	  if ( i >= n or j < 0 ) :				    	if i >= n or j < 0 :					  
  if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ;	      	      return 0						    	    return 0						  
  if ( ( i - j == 1 ) || ( i - j == - 1 ) ) {		      	  if ( dp [ i ] [ j ] != - 1 ) :			    	if j in dp [ i ] [ j ] :				  
    if ( str . charAt ( i ) == str . charAt ( j ) ) return dp 	      return dp [ i ] [ j ]				    	    return dp [ i ] [ j ]				  
    else return dp [ i ] [ j ] = 2 ;			      	  if ( abs ( i - j ) == 1 ) :				    	if ( i - j == 1 ) or ( i - j == - 1 ) :			  
  }							      	      if ( str [ i ] == str [ j ] ) :			    	    if str ( i ) == str ( j ) :				  
  if ( i == j ) return dp [ 1 ] [ j ] = 1 ;		      		  dp [ i ] [ j ] = 3				    		return dp [ i ] [ j ] = 3			  
  else if ( str . charAt ( i ) == str . charAt ( j ) ) return 		  return dp [ i ] [ j ]				    	    else :						  
  else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countP 	      else :						    		return dp [ i ] [ j ] = 2			  
}							      		  dp [ i ] [ j ] = 2				    	if i == j :						  
							      		  return dp [ i ] [ j ]				    	    return dp [ 1 ] [ j ] = 1				  
							      	  if ( i == j ) :					    	elif str ( i ) == str ( j ) :				  
							      	      dp [ 1 ] [ j ] = 1				    	    return dp [ i ] [ j ] = count_ps ( i + 1 , j ) + coun 
							      	      return dp [ 1 ] [ j ]				    	else :							  
							      	  elif ( str [ i ] == str [ j ] ) :			    	    return dp [ i ] [ j ] = count_ps ( i + 1 , j ) + coun 
							      	      dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS (  								  
							      	      return dp [ i ] [ j ]				    								  
							      	  else :						    								  
							      	      dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS (  								  
							      	      return dp [ i ] [ j ]				    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K			      SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K				    SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K				  SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K
--							      --							    --								  --
static void subarrayDivisibleByK ( int [ ] arr , int n , int  def subarrayDivisibleByK ( arr , n , k ) :		    def subarray_divisible_by_k ( arr , n , k ) :		  script_not_found : None
  int [ ] mp = new int [ 1000 ] ;			      	  mp = [ 0 ] * 1000					    	mp = np.zeros ( 1000 )					  
  int s = 0 , e = 0 , maxs = 0 , maxe = 0 ;		      	  s = 0 e = 0 maxs = 0 maxe = 0				    	s , e , maxs , maxe = 0 , 0 , 0 , 0			  
  mp [ arr [ 0 ] % k ] ++ ;				      	  mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1	    	mp [ arr [ 0 ] % k ] += 1				  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for mod in arr [ 1 : ] :				  
  i < n ;						      	      mod = arr [ i ] % k				    	    while mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod  
  i ++ ) {						      	      while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mo 		mp [ arr [ s ] % k ] -= 1			  
    int mod = arr [ i ] % k ;				      		  mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1   		s += 1						  
    while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] ! 		  s = s + 1					    	    mp [ mod ] += 1					  
      mp [ arr [ s ] % k ] -- ;				      	      mp [ mod ] = mp [ mod ] + 1			    	    e += 1						  
      s ++ ;						      	      e = e + 1						    	    if ( e - s ) > ( maxe - maxs ) :			  
    }							      	      if ( ( e - s ) > ( maxe - maxs ) ) :		    		maxe = e					  
    mp [ mod ] ++ ;					      		  maxe = e					    		maxs = s					  
    e ++ ;						      		  maxs = s					    	print ( "The maximum size is %d and the subarray is as fo 
    if ( ( e - s ) > ( maxe - maxs ) ) {		      	  print ( "The maximum size is {} and the ".format ( ( maxe 	for i in range ( maxs , maxe + 1 ) :			  
      maxe = e ;					      	      print ( "{} ".format ( arr [ i ] ) , end = "" )	    	    print ( arr [ i ] , end = ' ' )			  
      maxs = s ;					      								    								  
    }							      								    								  
  }							      								    								  
  System . out . print ( "The maximum size is " + ( maxe - ma 								    								  
  for ( int i = maxs ;					      								    								  
  i <= maxe ;						      								    								  
  i ++ ) System . out . print ( arr [ i ] + " " ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION		      WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION		    WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION			  WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION
--							      --							    --								  --
static void solveWordWrap ( int arr [ ] , int n , int k ) {   def solveWordWrap ( arr , n , k ) :			    def solve_word_wrap ( arr , n , k ) :			  script_not_found : None
  int i , j ;						      	  dp = [ 0 ] * n					    	global dp						  
  int currlen ;						      	  ans = [ 0 ] * n					    	dp = [ 0 ] * n						  
  int cost ;						      	  dp [ n - 1 ] = 0					    	ans = [ 0 ] * n						  
  int dp [ ] = new int [ n ] ;				      	  ans [ n - 1 ] = n - 1					    	dp [ n - 1 ] = 0					  
  int ans [ ] = new int [ n ] ;				      	  for i in range ( n - 2 , - 1 , - 1 ) :		    	ans [ n - 1 ] = n - 1					  
  dp [ n - 1 ] = 0 ;					      	      currlen = - 1					    	for i in range ( n - 2 , - 1 , - 1 ) :			  
  ans [ n - 1 ] = n - 1 ;				      	      dp [ i ] = sys.maxsize				    	    currlen = - 1					  
  for ( i = n - 2 ;					      	      for j in range ( i , n ) :			    	    dp [ i ] = sys.maxsize				  
  i >= 0 ;						      		  currlen += ( arr [ j ] + 1 )			    	    for j in range ( i , n ) :				  
  i -- ) {						      		  if ( currlen > k ) :				    		currlen += ( arr [ j ] + 1 )			  
    currlen = - 1 ;					      		      break					    		if currlen > k :				  
    dp [ i ] = Integer . MAX_VALUE ;			      		  if ( j == n - 1 ) :				    		    break					  
    for ( j = i ;					      		      cost = 0					    		if j == n - 1 :					  
    j < n ;						      		  else :					    		    cost = 0					  
    j ++ ) {						      		      cost = ( ( k - currlen ) * ( k - currlen ) +  		else :						  
      currlen += ( arr [ j ] + 1 ) ;			      		  if ( cost < dp [ i ] ) :			    		    cost = ( k - currlen ) * ( k - currlen ) + dp 
      if ( currlen > k ) break ;			      		      dp [ i ] = cost				    		if cost < dp [ i ] :				  
      if ( j == n - 1 ) cost = 0 ;			      		      ans [ i ] = j				    		    dp [ i ] = cost				  
      else cost = ( k - currlen ) * ( k - currlen ) + dp [ j  	  i = 0							    		    ans [ i ] = j				  
      if ( cost < dp [ i ] ) {				      	  while ( i < n ) :					    	i = 0							  
	dp [ i ] = cost ;				      	      print ( i + 1 , ans [ i ] + 1 , end = " " )	    	while i < n :						  
	ans [ i ] = j ;					      	      i = ans [ i ] + 1					    	    print ( ( i + 1 ) , ans [ i ] + 1 , end = ' ' )	  
      }							      								    	    i = ans [ i ] + 1					  
    }							      								    								  
  }							      								    								  
  i = 0 ;						      								    								  
  while ( i < n ) {					      								    								  
    System . out . print ( ( i + 1 ) + " " + ( ans [ i ] + 1  								    								  
    i = ans [ i ] + 1 ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM			      MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM			    MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM			  MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM
--							      --							    --								  --
static int maxAlternateSum ( int arr [ ] , int n ) {	      def maxAlternateSum ( arr , n ) :				    def max_alternate_sum ( arr , n ) :				  error : Traceback (most recent call last):   File
  if ( n == 1 ) return arr [ 0 ] ;			      	  if ( n == 1 ) :					    	if n == 1 :						  "dump/transcoder_st/eval/java_python/online_st/206
  int dec [ ] = new int [ n ] ;				      	      return arr [ 0 ]					    	    return arr [ 0 ]					  68770/eval_scripts/java_sa-python_sa.test/MAXIMUM_
  int inc [ ] = new int [ n ] ;				      	  dec = [ 0 for i in range ( n + 1 ) ]			    	dec = [ 0 ] * n						  SUM_ALTERNATING_SUBSEQUENCE_SUM.py", line 78, in <
  dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ;			      	  inc = [ 0 for i in range ( n + 1 ) ]			    	inc = [ 0 ] * n						  module>     if f_filled(*parameters_set) == f_gold
  int flag = 0 ;					      	  dec [ 0 ] = inc [ 0 ] = arr [ 0 ]			    	dec [ 0 ] = inc [ 0 ] = arr [ 0 ]			  (*parameters_set):   File "dump/transcoder_st/eval
  for ( int i = 1 ;					      	  flag = 0						    	flag = 0						  /java_python/online_st/20668770/eval_scripts/java_
  i < n ;						      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  sa-python_sa.test/MAXIMUM_SUM_ALTERNATING_SUBSEQUE
  i ++ ) {						      	      for j in range ( i ) :				    	    for j in range ( i ) :				  NCE_SUM.py", line 45, in f_filled	dec [ 0 ] =
    for ( int j = 0 ;					      		  if ( arr [ j ] > arr [ i ] ) :		    		if arr [ j ] > arr [ i ] :			  inc [ 0 ] = arr [ 0 ] IndexError: list assignment
    j < i ;						      		      dec [ i ] = max ( dec [ i ] , inc [ j ] + arr 		    dec [ i ] = max ( dec [ i ] , inc [ j ] + arr index out of range
    j ++ ) {						      		      flag = 1					    		    flag = 1					  
      if ( arr [ j ] > arr [ i ] ) {			      		  elif ( arr [ j ] < arr [ i ] and flag == 1 ) :    		elif arr [ j ] < arr [ i ] and flag == 1 :	  
	dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr  		      inc [ i ] = max ( inc [ i ] , dec [ j ] + arr 		    inc [ i ] = max ( inc [ i ] , dec [ j ] + arr 
	flag = 1 ;					      	  result = - 2147483648					    	result = 0						  
      }							      	  for i in range ( n ) :				    	for i in range ( n ) :					  
      else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i  	      if ( result < inc [ i ] ) :			    	    if result < inc [ i ] :				  
    }							      		  result = inc [ i ]				    		result = inc [ i ]				  
  }							      	      if ( result < dec [ i ] ) :			    	    if result < dec [ i ] :				  
  int result = Integer . MIN_VALUE ;			      		  result = dec [ i ]				    		result = dec [ i ]				  
  for ( int i = 0 ;					      	  return result						    	return result						  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    if ( result < inc [ i ] ) result = inc [ i ] ;	      								    								  
    if ( result < dec [ i ] ) result = dec [ i ] ;	      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE
--							      --							    --								  --
static void smallestSubsegment ( int a [ ] , int n ) {	      def smallestSubsegment ( a , n ) :			    def smallest_substring ( a , n ) :				  script_not_found : None
  HashMap < Integer , Integer > left = new HashMap < Integer  	  left = dict ( )					    	left = { }						  
  HashMap < Integer , Integer > count = new HashMap < Integer 	  count = dict ( )					    	count = { }						  
  int mx = 0 ;						      	  mx = 0						    	mx = 0							  
  int mn = - 1 , strindex = - 1 ;			      	  mn , strindex = 0 , 0					    	mn , strindex = - 1 , - 1				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      x = a [ i ]					    	    x = a [ i ]						  
  i ++ ) {						      	      if ( x not in count.keys ( ) ) :			    	    if count.get ( x ) is None :			  
    int x = a [ i ] ;					      		  left [ x ] = i				    		left [ x ] = i					  
    if ( count . get ( x ) == null ) {			      		  count [ x ] = 1				    		count [ x ] = 1					  
      left . put ( x , i ) ;				      	      else :						    	    else :						  
      count . put ( x , 1 ) ;				      		  count [ x ] += 1				    		count [ x ] = count [ x ] + 1			  
    }							      	      if ( count [ x ] > mx ) :				    	    if count [ x ] > mx :				  
    else count . put ( x , count . get ( x ) + 1 ) ;	      		  mx = count [ x ]				    		mx = count [ x ]				  
    if ( count . get ( x ) > mx ) {			      		  mn = i - left [ x ] + 1			    		mn = i - left [ x ] + 1				  
      mx = count . get ( x ) ;				      		  strindex = left [ x ]				    		strindex = left [ x ]				  
      mn = i - left . get ( x ) + 1 ;			      	      elif ( count [ x ] == mx and i - left [ x ] + 1 < mn  	    elif ( count [ x ] == mx ) and ( i - left [ x ] + 1 < 
      strindex = left . get ( x ) ;			      		  mn = i - left [ x ] + 1			    		mn = i - left [ x ] + 1				  
    }							      		  strindex = left [ x ]				    		strindex = left [ x ]				  
    else if ( ( count . get ( x ) == mx ) && ( i - left . get 	  for i in range ( strindex , strindex + mn ) :		    	for i in range ( strindex , strindex + mn ) :		  
      mn = i - left . get ( x ) + 1 ;			      	      print ( a [ i ] , end = " " )			    	    print ( a [ i ] , end = ' ' )			  
      strindex = left . get ( x ) ;			      								    								  
    }							      								    								  
  }							      								    								  
  for ( int i = strindex ;				      								    								  
  i < strindex + mn ;					      								    								  
  i ++ ) System . out . print ( a [ i ] + " " ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX		      FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX			    FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX			  FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX
--							      --							    --								  --
static void KMP ( int m , int n , String str2 , String str1 ) def KMP ( m , n , str2 , str1 ) :				    def KMP ( m , n , str2 , str1 ) :				  script_not_found : None
  int pos = 0 , len = 0 ;				      	  pos = 0						    	pos , len = 0 , 0					  
  int [ ] p = new int [ m + 1 ] ;			      	  Len = 0						    	p = [ 0 ] * ( m + 1 )					  
  int k = 0 ;						      	  p = [ 0 for i in range ( m + 1 ) ]			    	k = 0							  
  char [ ] ch1 = str1 . toCharArray ( ) ;		      	  k = 0							    	ch1 = str1 [ : ]					  
  char [ ] ch2 = str2 . toCharArray ( ) ;		      	  for i in range ( 2 , n + 1 ) :			    	ch2 = str2 [ : ]					  
  for ( int i = 2 ;					      	      while ( k > 0 and str1 [ k ] != str1 [ i - 1 ] ) :    	for i in range ( 2 , n + 1 ) :				  
  i <= n ;						      		  k = p [ k ]					    	    while k > 0 and ch1 [ k ] != ch1 [ i - 1 ] :	  
  i ++ ) {						      	      if ( str1 [ k ] == str1 [ i - 1 ] ) :		    		k = p [ k ]					  
    while ( k > 0 && ch1 [ k ] != ch1 [ i - 1 ] ) k = p [ k ] 		  k += 1					    	    if ch1 [ k ] == ch1 [ i - 1 ] :			  
    if ( ch1 [ k ] == ch1 [ i - 1 ] ) ++ k ;		      	      p [ i ] = k					    		k += 1						  
    p [ i ] = k ;					      	  j = 0							    	    p [ i ] = k						  
  }							      	  for i in range ( m ) :				    	for j , i in enumerate ( p ) :				  
  for ( int j = 0 , i = 0 ;				      	      while ( j > 0 and j < n and str1 [ j ] != str2 [ i ]  	    while j > 0 and j < n and ch1 [ j ] != ch2 [ i ] :	  
  i < m ;						      		  j = p [ j ]					    		j = p [ j ]					  
  i ++ ) {						      	      if ( j < n and str1 [ j ] == str2 [ i ] ) :	    	    if j < n and ch1 [ j ] == ch2 [ i ] :		  
    while ( j > 0 && j < n && ch1 [ j ] != ch2 [ i ] ) j = p  		  j += 1					    		j += 1						  
    if ( j < n && ch1 [ j ] == ch2 [ i ] ) j ++ ;	      	      if ( j > Len ) :					    	    if j > len :					  
    if ( j > len ) {					      		  Len = j					    		len = j						  
      len = j ;						      		  pos = i - j + 1				    		pos = i - j + 1					  
      pos = i - j + 1 ;					      	  print ( "Shift = " , pos )				    	print ( 'Shift = %d' % ( pos ) )			  
    }							      	  print ( "Prefix = " , str1 [ : Len ] )		    	print ( 'Prefix = %s' % ( str1 [ : len ] ) )		  
  }							      								    								  
  System . out . println ( "Shift = " + pos ) ;		      								    								  
  System . out . println ( "Prefix = " + str1 . substring ( 0 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1		      FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1			    FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1			  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1
--							      --							    --								  --
static boolean isRectangle ( int matrix [ ] [ ] ) {	      def isRectangle ( matrix ) :				    def is_rectangle ( matrix ) :				  script_not_found : None
  int rows = matrix . length ;				      	  rows = len ( matrix )					    	rows = len ( matrix )					  
  if ( rows == 0 ) return false ;			      	  if ( rows == 0 ) :					    	if not rows :						  
  int columns = matrix [ 0 ] . length ;			      	      return False					    	    return False					  
  HashMap < Integer , HashSet < Integer >> table = new HashMa 	  columns = len ( matrix [ 0 ] )			    	columns = len ( matrix [ 0 ] )				  
  for ( int i = 0 ;					      	  table = { }						    	table = { }						  
  i < rows ;						      	  for i in range ( rows ) :				    	for i in range ( rows ) :				  
  i ++ ) {						      	      for j in range ( columns - 1 ) :			    	    for j in range ( columns - 1 ) :			  
    for ( int j = 0 ;					      		  for k in range ( j + 1 , columns ) :		    		for k in range ( j + 1 , columns ) :		  
    j < columns - 1 ;					      		      if ( matrix [ i ] [ j ] == 1 and matrix [ i ] 		    if matrix [ i ] [ j ] == 1 and matrix [ i ] [ 
    j ++ ) {						      			  if ( j in table and k in table [ j ] ) :  			if j in table and k in table [ j ] :	  
      for ( int k = j + 1 ;				      			      return True			    			    return True				  
      k < columns ;					      			  if ( k in table and j in table [ k ] ) :  			if k in table and j in table [ k ] :	  
      k ++ ) {						      			      return True			    			    return True				  
	if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 			  if j not in table :			    			if j not in table :			  
	  if ( table . containsKey ( j ) && table . get ( j ) 			      table [ j ] = set ( )		    			    x = set ( )				  
	    return true ;				      			  if k not in table :			    			    x.add ( k )				  
	  }						      			      table [ k ] = set ( )		    			    table [ j ] = x			  
	  if ( table . containsKey ( k ) && table . get ( k ) 			  table [ j ].add ( k )			    			else :					  
	    return true ;				      			  table [ k ].add ( j )			    			    table [ j ].add ( k )		  
	  }						      	  return False						    			if k not in table :			  
	  if ( ! table . containsKey ( j ) ) {		      								    			    x = set ( )				  
	    HashSet < Integer > x = new HashSet < > ( ) ;     								    			    x.add ( j )				  
	    x . add ( k ) ;				      								    			    table [ k ] = x			  
	    table . put ( j , x ) ;			      								    			else :					  
	  }						      								    			    table [ k ].add ( j )		  
	  else {					      								    	return False						  
	    table . get ( j ) . add ( k ) ;		      								    								  
	  }						      								    								  
	  if ( ! table . containsKey ( k ) ) {		      								    								  
	    HashSet < Integer > x = new HashSet < > ( ) ;     								    								  
	    x . add ( j ) ;				      								    								  
	    table . put ( k , x ) ;			      								    								  
	  }						      								    								  
	  else {					      								    								  
	    table . get ( k ) . add ( j ) ;		      								    								  
	  }						      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B
--							      --							    --								  --
static long arrangeBraces ( int n , int pos [ ] , int k ) {   def arrangeBraces ( n , pos , k ) :			    def arrangeBraces ( n , pos , k ) :				  script_not_found : None
  boolean h [ ] = new boolean [ N ] ;			      	  h = [ False for i in range ( N ) ]			    	h = np.zeros ( N )					  
  int dp [ ] [ ] = new int [ N ] [ N ] ;		      	  dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ]  	dp = np.zeros ( ( N , N ) )				  
  for ( int i = 0 ;					      	  for i in range ( k ) :				    	for i in range ( k ) :					  
  i < k ;						      	      h [ pos [ i ] ] = 1				    	    h [ pos [ i ] ] = True				  
  i ++ ) {						      	  dp [ 0 ] [ 0 ] = 1					    	dp [ 0 ] [ 0 ] = 1					  
    h [ pos [ i ] ] = true ;				      	  for i in range ( 1 , 2 * n + 1 ) :			    	for i in range ( 1 , 2 * n + 1 ) :			  
  }							      	      for j in range ( 2 * n + 1 ) :			    	    for j in range ( 0 , 2 * n + 1 ) :			  
  dp [ 0 ] [ 0 ] = 1 ;					      		  if ( h [ i ] ) :				    		if h [ i ] :					  
  for ( int i = 1 ;					      		      if ( j != 0 ) :				    		    if j != 0 :					  
  i <= 2 * n ;						      			  dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]   			dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]	  
  i ++ ) {						      		      else :					    		    else :					  
    for ( int j = 0 ;					      			  dp [ i ] [ j ] = 0			    			dp [ i ] [ j ] = 0			  
    j <= 2 * n ;					      		  else :					    		elif j != 0 :					  
    j ++ ) {						      		      if ( j != 0 ) :				    		    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp  
      if ( h [ i ] ) {					      			  dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] 		else :						  
	if ( j != 0 ) {					      		      else :					    		    dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]	  
	  dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;	      			  dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]   	return dp [ 2 * n ] [ 0 ]				  
	}						      	  return dp [ 2 * n ] [ 0 ]				    								  
	else {						      								    								  
	  dp [ i ] [ j ] = 0 ;				      								    								  
	}						      								    								  
      }							      								    								  
      else if ( j != 0 ) {				      								    								  
	dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1  								    								  
      }							      								    								  
      else {						      								    								  
	dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;	      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return dp [ 2 * n ] [ 0 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_
--							      --							    --								  --
static int pre_compute ( int a [ ] , int n , int index , int  def pre_compute ( a , n , index , k ) :			    def pre_compute ( a , n , index , k ) :			  script_not_found : None
  int dp [ ] [ ] = new int [ n ] [ n ] ;		      	  dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]  	dp = np.zeros ( ( n , n ) )				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if a [ i ] > a [ 0 ] :				    	    if a [ i ] > a [ 0 ] :				  
  i ++ ) {						      		  dp [ 0 ] [ i ] = a [ i ] + a [ 0 ]		    		dp [ 0 ] [ i ] = a [ i ] + a [ 0 ]		  
    if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 	      else :						    	    else :						  
    else dp [ 0 ] [ i ] = a [ i ] ;			      		  dp [ 0 ] [ i ] = a [ i ]			    		dp [ 0 ] [ i ] = a [ i ]			  
  }							      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
  i < n ;						      		  if a [ j ] > a [ i ] and j > i :		    		if a [ j ] > a [ i ] and j > i :		  
  i ++ ) {						      		      if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1  		    if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1  
    for ( int j = 0 ;					      			  dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ 			dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ 
    j < n ;						      		      else :					    		    else :					  
    j ++ ) {						      			  dp [ i ] [ j ] = dp [ i - 1 ] [ j ]	    			dp [ i ] [ j ] = dp [ i - 1 ] [ j ]	  
      if ( a [ j ] > a [ i ] && j > i ) {		      		  else :					    		else :						  
	if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j  		      dp [ i ] [ j ] = dp [ i - 1 ] [ j ]	    		    dp [ i ] [ j ] = dp [ i - 1 ] [ j ]		  
	else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;	      	  return dp [ index ] [ k ]				    	return dp [ index ] [ k ]				  
      }							      								    								  
      else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;	      								    								  
    }							      								    								  
  }							      								    								  
  return dp [ index ] [ k ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN
--							      --							    --								  --
static int find ( boolean arr [ ] [ ] ) {		      def find ( arr ) :					    def find ( arr , n ) :					  script_not_found : None
  int i = 0 , j = n - 1 ;				      	  n = len ( arr )					    	i , j = 0 , n - 1					  
  int res = - 1 ;					      	  i = 0							    	res = - 1						  
  while ( i < n && j >= 0 ) {				      	  j = n - 1						    	while i < n and j >= 0 :				  
    if ( arr [ i ] [ j ] == false ) {			      	  res = - 1						    	    if arr [ i ] [ j ] == False :			  
      while ( j >= 0 && ( arr [ i ] [ j ] == false || i == j  	  while i < n and j >= 0 :				    		while j >= 0 and ( arr [ i ] [ j ] == False or i  
	j -- ;						      	      if arr [ i ] [ j ] == 0 :				    		    j -= 1					  
      }							      		  while j >= 0 and ( arr [ i ] [ j ] == 0 or i == j 		if j == - 1 :					  
      if ( j == - 1 ) {					      		      j -= 1					    		    res = i					  
	res = i ;					      		  if j == - 1 :					    		    break					  
	break ;						      		      res = i					    		else :						  
      }							      		      break					    		    i += 1					  
      else {						      		  else : i += 1					    	    else :						  
	i ++ ;						      	      else :						    		while i < n and ( arr [ i ] [ j ] == True or i == 
      }							      		  while i < n and ( arr [ i ] [ j ] == 1 or i == j  		    i += 1					  
    }							      		      i += 1					    		if i == n :					  
    else {						      		  if i == n :					    		    res = j					  
      while ( i < n && ( arr [ i ] [ j ] == true || i == j )  		      res = j					    		    break					  
	i ++ ;						      		      break					    		else :						  
      }							      		  else : j -= 1					    		    j -= 1					  
      if ( i == n ) {					      	  if res == - 1 :					    	if res == - 1 :						  
	res = j ;					      	      return res					    	    return res						  
	break ;						      	  for i in range ( 0 , n ) :				    	for k in range ( n ) :					  
      }							      	      if res != i and arr [ i ] [ res ] != 1 :		    	    if res != k and arr [ k ] [ res ] != True :		  
      else {						      		  return - 1					    		return - 1					  
	j -- ;						      	  for j in range ( 0 , j ) :				    	for l in range ( n ) :					  
      }							      	      if res != j and arr [ res ] [ j ] != 0 :		    	    if res != l and arr [ res ] [ l ] != False :	  
    }							      		  return - 1 ;					    		return - 1					  
  }							      	  return res ;						    	return res						  
  if ( res == - 1 ) {					      								    								  
    return res ;					      								    								  
  }							      								    								  
  for ( int k = 0 ;					      								    								  
  k < n ;						      								    								  
  k ++ ) {						      								    								  
    if ( res != k && arr [ k ] [ res ] != true ) {	      								    								  
      return - 1 ;					      								    								  
    }							      								    								  
  }							      								    								  
  for ( int l = 0 ;					      								    								  
  l < n ;						      								    								  
  l ++ ) {						      								    								  
    if ( res != l && arr [ res ] [ l ] != false ) {	      								    								  
      return - 1 ;					      								    								  
    }							      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES			      CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES			    CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES			  CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES
--							      --							    --								  --
static void printMat ( int degseq [ ] , int n ) {	      def printMat ( degseq , n ) :				    def print_mat ( degseq , n ) :				  script_not_found : None
  int [ ] [ ] mat = new int [ n ] [ n ] ;		      	  mat = [ [ 0 ] * n for i in range ( n ) ]		    	mat = np.zeros ( ( n , n ) )				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( i + 1 , n ) :			    	    for j in range ( i + 1 , n ) :			  
  i ++ ) {						      		  if ( degseq [ i ] > 0 and degseq [ j ] > 0 ) :    		if degseq [ i ] > 0 and degseq [ j ] > 0 :	  
    for ( int j = i + 1 ;				      		      degseq [ i ] -= 1				    		    degseq [ i ] -= 1				  
    j < n ;						      		      degseq [ j ] -= 1				    		    degseq [ j ] -= 1				  
    j ++ ) {						      		      mat [ i ] [ j ] = 1			    		    mat [ i ] [ j ] = 1				  
      if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) {	      		      mat [ j ] [ i ] = 1			    		    mat [ j ] [ i ] = 1				  
	degseq [ i ] -- ;				      	  print ( "	 " , end = "" )				    	print ( '\n' + str ( len ( str ( 3 ) ) ) + '	 ' , end  
	degseq [ j ] -- ;				      	  for i in range ( n ) :				    	for i in range ( n ) :					  
	mat [ i ] [ j ] = 1 ;				      	      print ( "" , "(" , i , ")" , end = "" )		    	    print ( '%d(%d)' % ( len ( str ( i ) ) , i ) , end =  
	mat [ j ] [ i ] = 1 ;				      	  print ( )						    	print ( '\n\n' , end = ' ' )				  
      }							      	  print ( )						    	for i in range ( n ) :					  
    }							      	  for i in range ( n ) :				    	    print ( '%d(%d)' % ( len ( str ( i ) ) , i ) , end =  
  }							      	      print ( "" , "(" , i , ")" , end = "" )		    	    for j in range ( n ) :				  
  System . out . print ( "\n" + setw ( 3 ) + "	   " ) ;      	      for j in range ( n ) :				    		print ( '%d%d' % ( len ( str ( i ) ) , mat [ i ]  
  for ( int i = 0 ;					      		  print ( "	" , mat [ i ] [ j ] , end = "" )    	    print ( '\n' , end = ' ' )				  
  i < n ;						      	      print ( )						    								  
  i ++ ) System . out . print ( setw ( 3 ) + "(" + i + ")" )  								    								  
  System . out . print ( "\n\n" ) ;			      								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    System . out . print ( setw ( 4 ) + "(" + i + ")" ) ;     								    								  
    for ( int j = 0 ;					      								    								  
    j < n ;						      								    								  
    j ++ ) System . out . print ( setw ( 5 ) + mat [ i ] [ j  								    								  
    System . out . print ( "\n" ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE	      DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE	    DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE
--							      --							    --								  --
static int lbs ( int arr [ ] , int n ) {		      def lbs ( arr ) :						    def lbs ( arr , n ) :					  script_not_found : None
  int i , j ;						      	  n = len ( arr )					    	global lis						  
  int [ ] lis = new int [ n ] ;				      	  lis = [ 1 for i in range ( n + 1 ) ]			    	lis = [ 1 ] * n						  
  for ( i = 0 ;						      	  for i in range ( 1 , n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for j in range ( 0 , i ) :			    	    lis [ i ] = 1					  
  i ++ ) lis [ i ] = 1 ;				      		  if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] <  	for i in range ( 1 , n ) :				  
  for ( i = 1 ;						      		      lis [ i ] = lis [ j ] + 1			    	    for j in range ( i ) :				  
  i < n ;						      	  lds = [ 1 for i in range ( n + 1 ) ]			    		if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j  
  i ++ ) for ( j = 0 ;					      	  for i in reversed ( range ( n - 1 ) ) :		    		    lis [ i ] = lis [ j ] + 1			  
  j < i ;						      	      for j in reversed ( range ( i - 1 , n ) ) :	    	lds = [ 1 ] * n						  
  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ]  		  if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [  	for i in range ( n - 2 , - 1 , - 1 ) :			  
  int [ ] lds = new int [ n ] ;				      		      lds [ i ] = lds [ j ] + 1			    	    for j in range ( n - 1 , i , - 1 ) :		  
  for ( i = 0 ;						      	  maximum = lis [ 0 ] + lds [ 0 ] - 1			    		if arr [ i ] > arr [ j ] and lds [ i ] < lds [ j  
  i < n ;						      	  for i in range ( 1 , n ) :				    		    lds [ i ] = lds [ j ] + 1			  
  i ++ ) lds [ i ] = 1 ;				      	      maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maxim 	max = lis [ 0 ] + lds [ 0 ] - 1				  
  for ( i = n - 2 ;					      	  return maximum					    	for i in range ( 1 , n ) :				  
  i >= 0 ;						      								    	    if lis [ i ] + lds [ i ] - 1 > max :		  
  i -- ) for ( j = n - 1 ;				      								    		max = lis [ i ] + lds [ i ] - 1			  
  j > i ;						      								    	return max						  
  j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ]  								    								  
  int max = lis [ 0 ] + lds [ 0 ] - 1 ;			      								    								  
  for ( i = 1 ;						      								    								  
  i < n ;						      								    								  
  i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i 								    								  
  return max ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1	      LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1		    LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1		  LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1
--							      --							    --								  --
int maxLen ( int arr [ ] , int n ) {			      def maxLen ( arr , n ) :					    def max_len ( arr , n ) :					  failure : 0  to  -1 0 to -1 0	 to  -1 0 to -1 9  t
  HashMap < Integer , Integer > hM = new HashMap < Integer ,  	  hash_map = { }					    	hM = { }						  o  18 0 to -1 0  to  -1 0 to -1 0  to	 -1 0 to -1
  int sum = 0 ;						      	  curr_sum = 0						    	sum = 0							  0  to	 -1 0 to -1 0  to  -1 0 to -1 10  to  11 0 t
  int max_len = 0 ;					      	  max_len = 0						    	max_len = 0						  o -1 7  to  8 0 to -1 0  to  -1 0 to -1 #Results:
  int ending_index = - 1 ;				      	  ending_index = - 1					    	ending_index = - 1					  7, 10
  int start_index = 0 ;					      	  for i in range ( 0 , n ) :				    	start_index = 0						  
  for ( int i = 0 ;					      	      if ( arr [ i ] == 0 ) :				    	for i in range ( n ) :					  
  i < n ;						      		  arr [ i ] = - 1				    	    arr [ i ] = ( - 1 if arr [ i ] == 0 else 1 )	  
  i ++ ) {						      	      else :						    	for i in range ( n ) :					  
    arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ;		      		  arr [ i ] = 1					    	    sum += arr [ i ]					  
  }							      	  for i in range ( 0 , n ) :				    	    if sum == 0 :					  
  for ( int i = 0 ;					      	      curr_sum = curr_sum + arr [ i ]			    		max_len = i + 1					  
  i < n ;						      	      if ( curr_sum == 0 ) :				    		ending_index = i				  
  i ++ ) {						      		  max_len = i + 1				    	    if sum + n in hM :					  
    sum += arr [ i ] ;					      		  ending_index = i				    		if max_len < i - hM [ sum + n ] :		  
    if ( sum == 0 ) {					      	      if ( curr_sum + n ) in hash_map :			    		    max_len = i - hM [ sum + n ]		  
      max_len = i + 1 ;					      		  max_len = max ( max_len , i - hash_map [ curr_sum 		    ending_index = i				  
      ending_index = i ;				      	      else :						    	    else :						  
    }							      		  hash_map [ curr_sum ] = i			    		hM [ sum + n ] = i				  
    if ( hM . containsKey ( sum + n ) ) {		      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
      if ( max_len < i - hM . get ( sum + n ) ) {	      	      if ( arr [ i ] == - 1 ) :				    	    arr [ i ] = ( - 1 if arr [ i ] == - 1 else 1 )	  
	max_len = i - hM . get ( sum + n ) ;		      		  arr [ i ] = 0					    	end = ending_index - max_len + 1			  
	ending_index = i ;				      	      else :						    	print ( end , ' to ' , ending_index )			  
      }							      		  arr [ i ] = 1					    	return max_len						  
    }							      	  print ( ending_index - max_len + 1 , end = " " )	    								  
    else hM . put ( sum + n , i ) ;			      	  print ( "to" , end = " " )				    								  
  }							      	  print ( ending_index )				    								  
  for ( int i = 0 ;					      	  return max_len					    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ;		      								    								  
  }							      								    								  
  int end = ending_index - max_len + 1 ;		      								    								  
  System . out . println ( end + " to " + ending_index ) ;    								    								  
  return max_len ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY	      FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY	    FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY	  FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY
--							      --							    --								  --
static void findRandomIndexOfMax ( int arr [ ] , int n ) {    def findRandomIndexOfMax ( arr , n ) :			    def find_random_index_of_max ( arr , n ) :			  script_not_found : None
  HashMap < Integer , Integer > mp = new HashMap < Integer ,  	  mp = dict ( )						    	mp = { }						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( arr [ i ] in mp ) :				    	    if arr [ i ] in mp :				  
  i ++ ) if ( mp . containsKey ( arr [ i ] ) ) {	      		  mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1	    		mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1		  
    mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ;     	      else :						    	    else :						  
  }							      		  mp [ arr [ i ] ] = 1				    		mp [ arr [ i ] ] = 1				  
  else {						      	  max_element = - 323567				    	max_element = 0						  
    mp . put ( arr [ i ] , 1 ) ;			      	  max_so_far = - 323567					    	max_so_far = 0						  
  }							      	  for p in mp :						    	for p , i in mp.items ( ) :				  
  int max_element = Integer . MIN_VALUE ;		      	      if ( mp [ p ] > max_so_far ) :			    	    if i > max_so_far :					  
  int max_so_far = Integer . MIN_VALUE ;		      		  max_so_far = mp [ p ]				    		max_so_far = i					  
  for ( Map . Entry < Integer , Integer > p : mp . entrySet ( 		  max_element = p				    		max_element = p					  
    if ( p . getValue ( ) > max_so_far ) {		      	  r = int ( ( ( random.randrange ( 1 , max_so_far , 2 ) % m 	r = int ( ( random.randint ( max_so_far ) % max_so_far )  
      max_so_far = p . getValue ( ) ;			      	  i = 0							    	for i , count in enumerate ( arr ) :			  
      max_element = p . getKey ( ) ;			      	  count = 0						    	    if i == max_element :				  
    }							      	  while ( i < n ) :					    		count += 1					  
  }							      	      if ( arr [ i ] == max_element ) :			    	    if count == r :					  
  int r = ( int ) ( ( new Random ( ) . nextInt ( max_so_far ) 		  count = count + 1				    		print ( "Element with maximum frequency present " 
  for ( int i = 0 , count = 0 ;				      	      if ( count == r ) :				    		break						  
  i < n ;						      		  print ( "Element with maximum frequency present a 								  
  i ++ ) {						      		  break						    								  
    if ( arr [ i ] == max_element ) count ++ ;		      	      i = i + 1						    								  
    if ( count == r ) {					      								    								  
      System . out . print ( "Element with maximum frequency  								    								  
      break ;						      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_BITONIC_SUBARRAY				      MAXIMUM_SUM_BITONIC_SUBARRAY				    MAXIMUM_SUM_BITONIC_SUBARRAY				  MAXIMUM_SUM_BITONIC_SUBARRAY
--							      --							    --								  --
static int maxSumBitonicSubArr ( int arr [ ] , int n ) {      def maxSumBitonicSubArr ( arr , n ) :			    def max_sum_bitonic_sub_arr ( arr , n ) :			  success : None
  int [ ] msis = new int [ n ] ;			      	  msis = [ None ] * n					    	msis = [ 0 ] * n					  
  int [ ] msds = new int [ n ] ;			      	  msds = [ None ] * n					    	msds = [ 0 ] * n					  
  int max_sum = Integer . MIN_VALUE ;			      	  max_sum = 0						    	max_sum = 0						  
  msis [ 0 ] = arr [ 0 ] ;				      	  msis [ 0 ] = arr [ 0 ]				    	msis [ 0 ] = arr [ 0 ]					  
  for ( int i = 1 ;					      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  i < n ;						      	      if ( arr [ i ] > arr [ i - 1 ] ) :		    	    if arr [ i ] > arr [ i - 1 ] :			  
  i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ 		  msis [ i ] = msis [ i - 1 ] + arr [ i ]	    		msis [ i ] = msis [ i - 1 ] + arr [ i ]		  
  else msis [ i ] = arr [ i ] ;				      	      else :						    	    else :						  
  msds [ n - 1 ] = arr [ n - 1 ] ;			      		  msis [ i ] = arr [ i ]			    		msis [ i ] = arr [ i ]				  
  for ( int i = n - 2 ;					      	  msds [ n - 1 ] = arr [ n - 1 ]			    	msds [ n - 1 ] = arr [ n - 1 ]				  
  i >= 0 ;						      	  for i in range ( n - 2 , - 1 , - 1 ) :		    	for i in range ( n - 2 , - 1 , - 1 ) :			  
  i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ 	      if ( arr [ i ] > arr [ i + 1 ] ) :		    	    if arr [ i ] > arr [ i + 1 ] :			  
  else msds [ i ] = arr [ i ] ;				      		  msds [ i ] = msds [ i + 1 ] + arr [ i ]	    		msds [ i ] = msds [ i + 1 ] + arr [ i ]		  
  for ( int i = 0 ;					      	      else :						    	    else :						  
  i < n ;						      		  msds [ i ] = arr [ i ]			    		msds [ i ] = arr [ i ]				  
  i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] 	  for i in range ( n ) :				    	for i in range ( n ) :					  
  return max_sum ;					      	      if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ]  	    if max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] )  
}							      		  max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) 		max_sum = msis [ i ] + msds [ i ] - arr [ i ]	  
							      	  return max_sum					    	return max_sum						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT		      MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT			    MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT			  MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT
--							      --							    --								  --
static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n def maxSumSubarrayRemovingOneEle ( arr , n ) :		    def max_sum_subarray_removing_one_le ( arr , n ) :		  failure : #Results: 8, 10
  int fw [ ] = new int [ n ] ;				      	  fw = [ 0 for k in range ( n ) ]			    	fw = [ 0 ] * n						  
  int bw [ ] = new int [ n ] ;				      	  bw = [ 0 for k in range ( n ) ]			    	bw = [ 0 ] * n						  
  int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ;	      	  cur_max , max_so_far = arr [ 0 ] , arr [ 0 ]		    	cur_max , max_so_far = arr [ 0 ] , arr [ 0 ]		  
  fw [ 0 ] = arr [ 0 ] ;				      	  for i in range ( n ) :				    	fw [ 0 ] = arr [ 0 ]					  
  for ( int i = 1 ;					      	      cur_max = max ( arr [ i ] , cur_max + arr [ i ] )	    	for i in range ( 1 , n ) :				  
  i < n ;						      	      max_so_far = max ( max_so_far , cur_max )		    	    cur_max = max ( arr [ i ] , cur_max + arr [ i ] )	  
  i ++ ) {						      	      fw [ i ] = cur_max				    	    max_so_far = max ( max_so_far , cur_max )		  
    cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] )  	  cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]	    	    fw [ i ] = cur_max					  
    max_so_far = Math . max ( max_so_far , cur_max ) ;	      	  i = n - 2						    	cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]	  
    fw [ i ] = cur_max ;				      	  while i >= 0 :					    	for i in range ( n - 2 , - 1 , - 1 ) :			  
  }							      	      cur_max = max ( arr [ i ] , cur_max + arr [ i ] )	    	    cur_max = max ( arr [ i ] , cur_max + arr [ i ] )	  
  cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ;	      	      max_so_far = max ( max_so_far , cur_max )		    	    max_so_far = max ( max_so_far , cur_max )		  
  for ( int i = n - 2 ;					      	      bw [ i ] = cur_max				    	    bw [ i ] = cur_max					  
  i >= 0 ;						      	      i -= 1						    	fans = max_so_far					  
  i -- ) {						      	  fans = max_so_far					    	for i in range ( 1 , n - 1 ) :				  
    cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] )  	  for i in range ( 1 , n - 1 ) :			    	    fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )	  
    max_so_far = Math . max ( max_so_far , cur_max ) ;	      	      fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )	    	return fans						  
    bw [ i ] = cur_max ;				      	  return fans						    								  
  }							      								    								  
  int fans = max_so_far ;				      								    								  
  for ( int i = 1 ;					      								    								  
  i < n - 1 ;						      								    								  
  i ++ ) fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 								    								  
  return fans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA
--							      --							    --								  --
static int lenghtOfLongestAP ( int set [ ] , int n ) {	      def lenghtOfLongestAP ( set , n ) :			    def lenghtOfLongestAP ( set , n ) :				  error : TypeError: only size-1 arrays can be conve
  if ( n <= 2 ) return n ;				      	  if ( n <= 2 ) :					    	if n <= 2 :						  rted to Python scalars  The above exception was th
  int L [ ] [ ] = new int [ n ] [ n ] ;			      	      return n						    	    return n						  e direct cause of the following exception:  Traceb
  int llap = 2 ;					      	  L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]   	L = np.zeros ( ( n , n ) )				  ack (most recent call last):	 File "dump/transcod
  for ( int i = 0 ;					      	  llap = 2						    	llap = 2						  er_st/eval/java_python/online_st/20668770/eval_scr
  i < n ;						      	  for i in range ( n ) :				    	for i in range ( n ) :					  ipts/java_sa-python_sa.test/LENGTH_OF_THE_LONGEST_
  i ++ ) L [ i ] [ n - 1 ] = 2 ;			      	      L [ i ] [ n - 1 ] = 2				    	    L [ i ] [ n - 1 ] = 2				  ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY.py", line
  for ( int j = n - 2 ;					      	  for j in range ( n - 2 , 0 , - 1 ) :			    	for j in range ( n - 2 , - 1 , - 1 ) :			   85, in <module>     if f_filled(*parameters_set)
  j >= 1 ;						      	      i = j - 1						    	    i , k = j - 1 , j + 1				  == f_gold(*parameters_set):	File "dump/transcode
  j -- ) {						      	      k = j + 1						    	    while i >= 0 and k <= n - 1 :			  r_st/eval/java_python/online_st/20668770/eval_scri
    int i = j - 1 , k = j + 1 ;				      	      while ( i >= 0 and k <= n - 1 ) :			    		if set [ i ] + set [ k ] < 2 * set [ j ] :	  pts/java_sa-python_sa.test/LENGTH_OF_THE_LONGEST_A
    while ( i >= 0 && k <= n - 1 ) {			      		  if ( set [ i ] + set [ k ] < 2 * set [ j ] ) :    		    k += 1					  RITHMATIC_PROGRESSION_IN_A_SORTED_ARRAY.py", line
      if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ;     		      k += 1					    		elif set [ i ] + set [ k ] > 2 * set [ j ] :	  60, in f_filled     L [ i ] [ j ] = L [ j ] + 1 Va
      else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) {     		  elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :  		    L [ i ] [ j ] = 2				  lueError: setting an array element with a sequence
	L [ i ] [ j ] = 2 ;				      		      L [ i ] [ j ] = 2				    		    i -= 1					  .
	i -- ;						      		      i -= 1					    		else :						  
      }							      		  else :					    		    L [ i ] [ j ] = L [ j ] + 1			  
      else {						      		      L [ i ] [ j ] = L [ j ] [ k ] + 1		    		    llap = max ( llap , L [ i ] [ j ] )		  
	L [ i ] [ j ] = L [ j ] [ k ] + 1 ;		      		      llap = max ( llap , L [ i ] [ j ] )	    		    i -= 1					  
	llap = Math . max ( llap , L [ i ] [ j ] ) ;	      		      i -= 1					    		    k += 1					  
	i -- ;						      		      k += 1					    	    while i >= 0 :					  
	k ++ ;						      		      while ( i >= 0 ) :			    		L [ i ] [ j ] = 2				  
      }							      			  L [ i ] [ j ] = 2			    		i -= 1						  
    }							      			  i -= 1				    	return llap						  
    while ( i >= 0 ) {					      	  return llap						    								  
      L [ i ] [ j ] = 2 ;				      								    								  
      i -- ;						      								    								  
    }							      								    								  
  }							      								    								  
  return llap ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET
--							      --							    --								  --
static int maximumZeros ( int arr [ ] , int n , int k ) {     def maximumZeros ( arr , n , k ) :			    def maximum_zeros ( arr , n , k ) :				  script_not_found : None
  int subset [ ] [ ] = new int [ k + 1 ] [ MAX5 + 5 ] ;	      	  global MAX5						    	subset = np.zeros ( ( k + 1 , MAX5 + 5 ) )		  
  for ( int [ ] row : subset ) {			      	  subset = [ [ - 1 ] * ( MAX5 + 5 ) for _ in range ( k + 1  	for row in subset :					  
    Arrays . fill ( row , - 1 ) ;			      	  subset [ 0 ] [ 0 ] = 0				    	    row [ : ] = - 1					  
  }							      	  for p in arr :					    	subset [ 0 ] [ 0 ] = 0					  
  subset [ 0 ] [ 0 ] = 0 ;				      	      pw2 , pw5 = 0 , 0					    	for p in range ( n ) :					  
  for ( int p = 0 ;					      	      while not p % 2 :					    	    pw2 , pw5 = 0 , 0					  
  p < n ;						      		  pw2 += 1					    	    while arr [ p ] % 2 == 0 :				  
  p ++ ) {						      		  p //= 2					    		pw2 += 1					  
    int pw2 = 0 , pw5 = 0 ;				      	      while not p % 5 :					    		arr [ p ] //= 2					  
    while ( arr [ p ] % 2 == 0 ) {			      		  pw5 += 1					    	    while arr [ p ] % 5 == 0 :				  
      pw2 ++ ;						      		  p //= 5					    		pw5 += 1					  
      arr [ p ] /= 2 ;					      	      for i in range ( k - 1 , - 1 , - 1 ) :		    		arr [ p ] //= 5					  
    }							      		  for j in range ( MAX5 ) :			    	    for i in range ( k - 1 , - 1 , - 1 ) :		  
    while ( arr [ p ] % 5 == 0 ) {			      		      if subset [ i ] [ j ] != - 1 :		    		for j in range ( MAX5 ) :			  
      pw5 ++ ;						      			  subset [ i + 1 ] [ j + pw5 ] = ( max ( su 		    if subset [ i ] [ j ] != - 1 :		  
      arr [ p ] /= 5 ;					      	  ans = 0						    			subset [ i + 1 ] [ j + pw5 ] = max ( subs 
    }							      	  for i in range ( MAX5 ) :				    	ans = 0							  
    for ( int i = k - 1 ;				      	      ans = max ( ans , min ( i , subset [ k ] [ i ] ) )    	for i in range ( MAX5 ) :				  
    i >= 0 ;						      	  return ans						    	    ans = max ( ans , min ( i , subset [ k ] [ i ] ) )	  
    i -- ) {						      								    	return ans						  
      for ( int j = 0 ;					      								    								  
      j < MAX5 ;					      								    								  
      j ++ ) {						      								    								  
	if ( subset [ i ] [ j ] != - 1 ) {		      								    								  
	  subset [ i + 1 ] [ j + pw5 ] = Math . max ( subset  								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  int ans = 0 ;						      								    								  
  for ( int i = 0 ;					      								    								  
  i < MAX5 ;						      								    								  
  i ++ ) {						      								    								  
    ans = Math . max ( ans , Math . min ( i , subset [ k ] [  								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
static void bestFit ( int blockSize [ ] , int m , int process def bestFit ( blockSize , m , processSize , n ) :		    def best_fit ( block_size , m , process_size , n ) :	  success : None
  int allocation [ ] = new int [ n ] ;			      	  allocation = [ - 1 ] * n				    	allocation = [ - 1 for i in range ( n ) ]		  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < allocation . length ;				      	      bestIdx = - 1					    	    best_idx = - 1					  
  i ++ ) allocation [ i ] = - 1 ;			      	      for j in range ( m ) :				    	    for j in range ( m ) :				  
  for ( int i = 0 ;					      		  if blockSize [ j ] >= processSize [ i ] :	    		if block_size [ j ] >= process_size [ i ] :	  
  i < n ;						      		      if bestIdx == - 1 :			    		    if best_idx == - 1 :			  
  i ++ ) {						      			  bestIdx = j				    			best_idx = j				  
    int bestIdx = - 1 ;					      		      elif blockSize [ bestIdx ] > blockSize [ j ]  		    elif block_size [ best_idx ] > block_size [ j 
    for ( int j = 0 ;					      			  bestIdx = j				    			best_idx = j				  
    j < m ;						      	      if bestIdx != - 1 :				    	    if best_idx != - 1 :				  
    j ++ ) {						      		  allocation [ i ] = bestIdx			    		allocation [ i ] = best_idx			  
      if ( blockSize [ j ] >= processSize [ i ] ) {	      		  blockSize [ bestIdx ] -= processSize [ i ]	    		block_size [ best_idx ] -= process_size [ i ]	  
	if ( bestIdx == - 1 ) bestIdx = j ;		      	  print ( "Process No.Process Size     Block no." )	    	print ( "\nProcess No.\tProcess Size\tBlock no." )	  
	else if ( blockSize [ bestIdx ] > blockSize [ j ] ) b 	  for i in range ( n ) :				    	for i in range ( n ) :					  
      }							      	      print ( i + 1 , "		" , processSize [ i ] , end 	    print ( "	%d \t\t%d\t\t" % ( i + 1 , process_size [ 
    }							      	      if allocation [ i ] != - 1 :			    	    if allocation [ i ] != - 1 :			  
    if ( bestIdx != - 1 ) {				      		  print ( allocation [ i ] + 1 )		    		print ( allocation [ i ] + 1 , end = " " )	  
      allocation [ i ] = bestIdx ;			      	      else :						    	    else :						  
      blockSize [ bestIdx ] -= processSize [ i ] ;	      		  print ( "Not Allocated" )			    		print ( "Not Allocated" , end = " " )		  
    }							      								    	    print ( )						  
  }							      								    								  
  System . out . println ( "\nProcess No.\tProcess Size\tBloc 								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    System . out . print ( "   " + ( i + 1 ) + "\t\t" + proce 								    								  
    if ( allocation [ i ] != - 1 ) System . out . print ( all 								    								  
    else System . out . print ( "Not Allocated" ) ;	      								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X	      CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X	    CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X	  CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X
--							      --							    --								  --
static void fill0X ( int m , int n ) {			      def fill0X ( m , n ) :					    def fill0X ( m , n ) :					  script_not_found : None
  int i , k = 0 , l = 0 ;				      	  i , k , l = 0 , 0 , 0					    	global a						  
  int r = m , c = n ;					      	  r = m							    	k , l = 0 , 0						  
  char a [ ] [ ] = new char [ m ] [ n ] ;		      	  c = n							    	r , c = m , n						  
  char x = 'X' ;					      	  a = [ [ None ] * n for i in range ( m ) ]		    	a = np.zeros ( ( m , n ) )				  
  while ( k < m && l < n ) {				      	  x = 'X'						    	x = 'X'							  
    for ( i = l ;					      	  while k < m and l < n :				    	while k < m and l < n :					  
    i < n ;						      	      for i in range ( l , n ) :			    	    for i in range ( l , n ) :				  
    ++ i ) a [ k ] [ i ] = x ;				      		  a [ k ] [ i ] = x				    		a [ k ] [ i ] = x				  
    k ++ ;						      	      k += 1						    	    k += 1						  
    for ( i = k ;					      	      for i in range ( k , m ) :			    	    for i in range ( k , m ) :				  
    i < m ;						      		  a [ i ] [ n - 1 ] = x				    		a [ i ] [ n - 1 ] = x				  
    ++ i ) a [ i ] [ n - 1 ] = x ;			      	      n -= 1						    	    n -= 1						  
    n -- ;						      	      if k < m :					    	    if k < m :						  
    if ( k < m ) {					      		  for i in range ( n - 1 , l - 1 , - 1 ) :	    		for i in range ( n - 1 , l - 1 , - 1 ) :	  
      for ( i = n - 1 ;					      		      a [ m - 1 ] [ i ] = x			    		    a [ m - 1 ] [ i ] = x			  
      i >= l ;						      		  m -= 1					    		m -= 1						  
      -- i ) a [ m - 1 ] [ i ] = x ;			      	      if l < n :					    	    if l < n :						  
      m -- ;						      		  for i in range ( m - 1 , k - 1 , - 1 ) :	    		for i in range ( m - 1 , k - 1 , - 1 ) :	  
    }							      		      a [ i ] [ l ] = x				    		    a [ i ] [ l ] = x				  
    if ( l < n ) {					      		  l += 1					    		l += 1						  
      for ( i = m - 1 ;					      	      x = 'X' if x == '0' else '0'			    	    x = ( 'X' if x == '0' else '0' )			  
      i >= k ;						      	  for i in range ( r ) :				    	for i in range ( r ) :					  
      -- i ) a [ i ] [ l ] = x ;			      	      for j in range ( c ) :				    	    for j in range ( c ) :				  
      l ++ ;						      		  print ( a [ i ] [ j ] , end = " " )		    		print ( a [ i ] [ j ] , end = ' ' )		  
    }							      	      print ( )						    	    print ( )						  
    x = ( x == '0' ) ? 'X' : '0' ;			      								    								  
  }							      								    								  
  for ( i = 0 ;						      								    								  
  i < r ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j < c ;						      								    								  
    j ++ ) System . out . print ( a [ i ] [ j ] + " " ) ;     								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS		      LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS		    LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS		  LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS
--							      --							    --								  --
static int lcsOf3 ( String X , String Y , String Z , int m ,  def lcsOf3 ( X , Y , Z , m , n , o ) :			    def lcsOf3 ( X , Y , Z , m , n , o ) :			  script_not_found : None
  int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; 	  L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n 	L = np.zeros ( ( m + 1 , n + 1 , o + 1 ) )		  
  for ( int i = 0 ;					      	  for i in range ( m + 1 ) :				    	for i in range ( 0 , m + 1 ) :				  
  i <= m ;						      	      for j in range ( n + 1 ) :			    	    for j in range ( 0 , n + 1 ) :			  
  i ++ ) {						      		  for k in range ( o + 1 ) :			    		for k in range ( 0 , o + 1 ) :			  
    for ( int j = 0 ;					      		      if ( i == 0 or j == 0 or k == 0 ) :	    		    if i == 0 or j == 0 or k == 0 :		  
    j <= n ;						      			  L [ i ] [ j ] [ k ] = 0		    			L [ i ] [ j ] [ k ] = 0			  
    j ++ ) {						      		      elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 		    elif X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 
      for ( int k = 0 ;					      			  L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 			L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 
      k <= o ;						      		      else :					    		    else :					  
      k ++ ) {						      			  L [ i ] [ j ] [ k ] = max ( max ( L [ i - 			L [ i ] [ j ] [ k ] = max ( max ( L [ i - 
	if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] 	  return L [ m ] [ n ] [ o ]				    	return L [ m ] [ n ] [ o ]				  
	else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1  								    								  
	else L [ i ] [ j ] [ k ] = Math . max ( Math . max (  								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return L [ m ] [ n ] [ o ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM	      SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM		    SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM		  SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM
--							      --							    --								  --
static int KnapSack ( int val [ ] , int wt [ ] , int n , int  def KnapSack ( val , wt , n , W ) :			    def KnapSack ( val , wt , n , W ) :				  script_not_found : None
  int mat [ ] [ ] = new int [ 2 ] [ W + 1 ] ;		      	  mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 	mat = np.zeros ( ( 2 , W + 1 ) )			  
  int i = 0 ;						      	  i = 0							    	i = 0							  
  while ( i < n ) {					      	  while i < n :						    	while i < n :						  
    int j = 0 ;						      	      j = 0						    	    j = 0						  
    if ( i % 2 != 0 ) {					      	      if i % 2 == 0 :					    	    if i % 2 :						  
      while ( ++ j <= W ) {				      		  while j < W :					    		while 1 <= W :					  
	if ( wt [ i ] <= j ) {				      		      j += 1					    		    j += 1					  
	  mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0  		      if wt [ i ] <= j :			    		    if wt [ i ] <= j :				  
	}						      			  mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 			mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 
	else {						      		      else :					    		    else :					  
	  mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ;		      			  mat [ 1 ] [ j ] = mat [ 0 ] [ j ]	    			mat [ 1 ] [ j ] = mat [ 0 ] [ j ]	  
	}						      	      else :						    	    else :						  
      }							      		  while j < W :					    		while 1 <= W :					  
    }							      		      j += 1					    		    j += 1					  
    else {						      		      if wt [ i ] <= j :			    		    if wt [ i ] <= j :				  
      while ( ++ j <= W ) {				      			  mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 			mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 
	if ( wt [ i ] <= j ) {				      		      else :					    		    else :					  
	  mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1  			  mat [ 0 ] [ j ] = mat [ 1 ] [ j ]	    			mat [ 0 ] [ j ] = mat [ 1 ] [ j ]	  
	}						      	      i += 1						    	    i += 1						  
	else {						      	  if n % 2 == 0 :					    	return ( mat [ 0 ] [ W ] if n % 2 else mat [ 1 ] [ W ] )  
	  mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ;		      	      return mat [ 0 ] [ W ]				    								  
	}						      	  else :						    								  
      }							      	      return mat [ 1 ] [ W ]				    								  
    }							      								    								  
    i ++ ;						      								    								  
  }							      								    								  
  return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
static void worstFit ( int blockSize [ ] , int m , int proces def worstFit ( blockSize , m , processSize , n ) :	    def worst_fit ( block_size , m , process_size , n ) :	  success : None
  int allocation [ ] = new int [ n ] ;			      	  allocation = [ - 1 ] * n				    	allocation = [ - 1 for i in range ( n ) ]		  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < allocation . length ;				      	      wstIdx = - 1					    	    wst_idx = - 1					  
  i ++ ) allocation [ i ] = - 1 ;			      	      for j in range ( m ) :				    	    for j in range ( m ) :				  
  for ( int i = 0 ;					      		  if blockSize [ j ] >= processSize [ i ] :	    		if block_size [ j ] >= process_size [ i ] :	  
  i < n ;						      		      if wstIdx == - 1 :			    		    if wst_idx == - 1 :				  
  i ++ ) {						      			  wstIdx = j				    			wst_idx = j				  
    int wstIdx = - 1 ;					      		      elif blockSize [ wstIdx ] < blockSize [ j ] : 		    elif block_size [ wst_idx ] < block_size [ j  
    for ( int j = 0 ;					      			  wstIdx = j				    			wst_idx = j				  
    j < m ;						      	      if wstIdx != - 1 :				    	    if wst_idx != - 1 :					  
    j ++ ) {						      		  allocation [ i ] = wstIdx			    		allocation [ i ] = wst_idx			  
      if ( blockSize [ j ] >= processSize [ i ] ) {	      		  blockSize [ wstIdx ] -= processSize [ i ]	    		block_size [ wst_idx ] -= process_size [ i ]	  
	if ( wstIdx == - 1 ) wstIdx = j ;		      	  print ( "Process No.Process Size Block no." )		    	print ( "\nProcess No.\tProcess Size\tBlock no." )	  
	else if ( blockSize [ wstIdx ] < blockSize [ j ] ) ws 	  for i in range ( n ) :				    	for i in range ( n ) :					  
      }							      	      print ( i + 1 , "		" , processSize [ i ] , end 	    print ( "	%d \t\t%d\t\t" % ( i + 1 , process_size [ 
    }							      	      if allocation [ i ] != - 1 :			    	    if allocation [ i ] != - 1 :			  
    if ( wstIdx != - 1 ) {				      		  print ( allocation [ i ] + 1 )		    		print ( allocation [ i ] + 1 , end = " " )	  
      allocation [ i ] = wstIdx ;			      	      else :						    	    else :						  
      blockSize [ wstIdx ] -= processSize [ i ] ;	      		  print ( "Not Allocated" )			    		print ( "Not Allocated" , end = " " )		  
    }							      								    	    print ( )						  
  }							      								    								  
  System . out . println ( "\nProcess No.\tProcess Size\tBloc 								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    System . out . print ( "   " + ( i + 1 ) + "\t\t" + proce 								    								  
    if ( allocation [ i ] != - 1 ) System . out . print ( all 								    								  
    else System . out . print ( "Not Allocated" ) ;	      								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PREFIX_SUM_2D_ARRAY					      PREFIX_SUM_2D_ARRAY					    PREFIX_SUM_2D_ARRAY						  PREFIX_SUM_2D_ARRAY
--							      --							    --								  --
public static void prefixSum2D ( int a [ ] [ ] ) {	      def prefixSum2D ( a ) :					    def prefix_sum_2d ( a ) :					  script_not_found : None
  int R = a . length ;					      	  global C , R						    	R = len ( a )						  
  int C = a [ 0 ] . length ;				      	  psa = [ [ 0 for x in range ( C ) ] for y in range ( R ) ] 	C = len ( a [ 0 ] )					  
  int psa [ ] [ ] = new int [ R ] [ C ] ;		      	  psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ]			    	psa = np.zeros ( ( R , C ) )				  
  psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ;			      	  for i in range ( 1 , C ) :				    	psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ]				  
  for ( int i = 1 ;					      	      psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i 	for i in range ( 1 , C ) :				  
  i < C ;						      	  for i in range ( 0 , R ) :				    	    psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] 
  i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i  	      psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 	for i in range ( 1 , R ) :				  
  for ( int i = 1 ;					      	  for i in range ( 1 , R ) :				    	    psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] 
  i < R ;						      	      for j in range ( 1 , C ) :			    	for i in range ( 1 , R ) :				  
  i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0  		  psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i 	    for j in range ( 1 , C ) :				  
  for ( int i = 1 ;					      	  for i in range ( 0 , R ) :				    		psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] 
  i < R ;						      	      for j in range ( 0 , C ) :			    	for i in range ( R ) :					  
  i ++ ) for ( int j = 1 ;				      		  print ( psa [ i ] [ j ] , end = " " )		    	    for j in range ( C ) :				  
  j < C ;						      	      print ( )						    		print ( psa [ i ] [ j ] , end = ' ' )		  
  j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [  								    	    print ( )						  
  for ( int i = 0 ;					      								    								  
  i < R ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j < C ;						      								    								  
    j ++ ) System . out . print ( psa [ i ] [ j ] + " " ) ;   								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1     GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1	    GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1	  GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1
--							      --							    --								  --
static boolean isSubSeqDivisible ( String str ) {	      def isSubSeqDivisible ( str ) :				    def is_subseq_divisible ( data ) :				  script_not_found : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( data )					  
  int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ;		      	  dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 	dp = np.zeros ( ( n + 1 , 10 ) )			  
  int arr [ ] = new int [ n + 1 ] ;			      	  arr = [ 0 for i in range ( n + 1 ) ]			    	arr = [ 0 ] * ( n + 1 )					  
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= n ;						      	      arr [ i ] = int ( str [ i - 1 ] )			    	    arr [ i ] = int ( data [ i - 1 ] - '0' )		  
  i ++ ) arr [ i ] = ( int ) ( str . charAt ( i - 1 ) - '0' ) 	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  for ( int i = 1 ;					      	      dp [ i ] [ arr [ i ] % 8 ] = 1			    	    dp [ i ] [ arr [ i ] % 8 ] = 1			  
  i <= n ;						      	      for j in range ( 8 ) :				    	    for j in range ( 8 ) :				  
  i ++ ) {						      		  if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + a 		if dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr 
    dp [ i ] [ arr [ i ] % 8 ] = 1 ;			      		      dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp  		    dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp  
    for ( int j = 0 ;					      		  if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) :	    		if dp [ i - 1 ] [ j ] > dp [ i ] [ j ] :	  
    j < 8 ;						      		      dp [ i ] [ j ] = dp [ i - 1 ] [ j ]	    		    dp [ i ] [ j ] = dp [ i - 1 ] [ j ]		  
    j ++ ) {						      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i 	      if ( dp [ i ] [ 0 ] == 1 ) :			    	    if dp [ i ] [ 0 ] == 1 :				  
      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j 		  return True					    		return True					  
    }							      	  return False						    	return False						  
  }							      								    								  
  for ( int i = 1 ;					      								    								  
  i <= n ;						      								    								  
  i ++ ) {						      								    								  
    if ( dp [ i ] [ 0 ] == 1 ) return true ;		      								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT	      FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT	    FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT	  FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT
--							      --							    --								  --
static void findTriplets ( int x ) {			      def findTriplets ( x ) :					    def find_triplets ( x ) :					  script_not_found : None
  Vector < Integer > fact = new Vector < Integer > ( ) ;      	  fact = [ ]						    	fact = [ ]						  
  HashSet < Integer > factors = new HashSet < Integer > ( ) ; 	  factors = set ( )					    	factors = set ( )					  
  for ( int i = 2 ;					      	  for i in range ( 2 , int ( sqrt ( x ) ) ) :		    	for i in range ( 2 , math.sqrt ( x ) + 1 ) :		  
  i <= Math . sqrt ( x ) ;				      	      if ( x % i == 0 ) :				    	    if x % i == 0 :					  
  i ++ ) {						      		  fact.append ( i )				    		fact.append ( i )				  
    if ( x % i == 0 ) {					      		  if ( x / i != i ) :				    		if x / i != i :					  
      fact . add ( i ) ;				      		      fact.append ( x // i )			    		    fact.append ( x / i )			  
      if ( x / i != i ) fact . add ( x / i ) ;		      		  factors.add ( i )				    		factors.append ( i )				  
      factors . add ( i ) ;				      		  factors.add ( x // i )			    		factors.add ( x / i )				  
      factors . add ( x / i ) ;				      	  found = False						    	found = False						  
    }							      	  k = len ( fact )					    	k = len ( fact )					  
  }							      	  for i in range ( k ) :				    	for i in range ( k ) :					  
  boolean found = false ;				      	      a = fact [ i ]					    	    a = fact [ i ]					  
  int k = fact . size ( ) ;				      	      for j in range ( k ) :				    	    for j in range ( k ) :				  
  for ( int i = 0 ;					      		  b = fact [ j ]				    		b = fact [ j ]					  
  i < k ;						      		  if ( ( a != b ) and ( x % ( a * b ) == 0 ) and (  		if ( a != b ) and ( x % ( a * b ) == 0 ) and ( x  
  i ++ ) {						      		      print ( a , b , x // ( a * b ) )		    		    print ( a , b , x / ( a * b ) , end = ' ' )	  
    int a = fact . get ( i ) ;				      		      found = True				    		    found = True				  
    for ( int j = 0 ;					      		      break					    		    break					  
    j < k ;						      	      if ( found ) :					    	    if found :						  
    j ++ ) {						      		  break						    		break						  
      int b = fact . get ( j ) ;			      	  if ( not found ) :					    	if not found :						  
      if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a  	      print ( "-1" )					    	    print ( '-1' , end = ' ' )				  
	System . out . print ( a + " " + b + " " + ( x / ( a  								    								  
	found = true ;					      								    								  
	break ;						      								    								  
      }							      								    								  
    }							      								    								  
    if ( found ) break ;				      								    								  
  }							      								    								  
  if ( ! found ) System . out . print ( "-1" ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINTING_ITEMS_01_KNAPSACK				      PRINTING_ITEMS_01_KNAPSACK				    PRINTING_ITEMS_01_KNAPSACK					  PRINTING_ITEMS_01_KNAPSACK
--							      --							    --								  --
static void printknapSack ( int W , int wt [ ] , int val [ ]  def printknapSack ( W , wt , val , n ) :			    def print_knap_sack ( W , wt , val , n ) :			  script_not_found : None
  int i , w ;						      	  K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 	global K						  
  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;		      	  for i in range ( n + 1 ) :				    	K = np.zeros ( ( n + 1 , W + 1 ) )			  
  for ( i = 0 ;						      	      for w in range ( W + 1 ) :			    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      		  if i == 0 or w == 0 :				    	    for w in range ( 0 , W + 1 ) :			  
  i ++ ) {						      		      K [ i ] [ w ] = 0				    		if i == 0 or w == 0 :				  
    for ( w = 0 ;					      		  elif wt [ i - 1 ] <= w :			    		    K [ i ] [ w ] = 0				  
    w <= W ;						      		      K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 		elif wt [ i - 1 ] <= w :			  
    w ++ ) {						      		  else :					    		    K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 
      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;	      		      K [ i ] [ w ] = K [ i - 1 ] [ w ]		    		else :						  
      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . ma 	  res = K [ n ] [ W ]					    		    K [ i ] [ w ] = K [ i - 1 ] [ w ]		  
      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		      	  print ( res )						    	res = K [ n ] [ W ]					  
    }							      	  w = W							    	print ( res )						  
  }							      	  for i in range ( n , 0 , - 1 ) :			    	w = W							  
  int res = K [ n ] [ W ] ;				      	      if res <= 0 :					    	for i in range ( n , 0 , - 1 ) :			  
  System . out . println ( res ) ;			      		  break						    	    if res == K [ i - 1 ] [ w ] :			  
  w = W ;						      	      if res == K [ i - 1 ] [ w ] :			    		continue					  
  for ( i = n ;						      		  continue					    	    else :						  
  i > 0 && res > 0 ;					      	      else :						    		print ( wt [ i - 1 ] , end = ' ' )		  
  i -- ) {						      		  print ( wt [ i - 1 ] )			    		res = res - val [ i - 1 ]			  
    if ( res == K [ i - 1 ] [ w ] ) continue ;		      		  res = res - val [ i - 1 ]			    		w = w - wt [ i - 1 ]				  
    else {						      		  w = w - wt [ i - 1 ]				    								  
      System . out . print ( wt [ i - 1 ] + " " ) ;	      								    								  
      res = res - val [ i - 1 ] ;			      								    								  
      w = w - wt [ i - 1 ] ;				      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS	      FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS		    FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS		  FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS
--							      --							    --								  --
public static int maxSum ( int stack1 [ ] , int stack2 [ ] ,  def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) :	    def max_sum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) :	  success : None
  int sum1 = 0 , sum2 = 0 , sum3 = 0 ;			      	  sum1 , sum2 , sum3 = 0 , 0 , 0			    	sum1 , sum2 , sum3 = 0 , 0 , 0				  
  for ( int i = 0 ;					      	  for i in range ( n1 ) :				    	for i in range ( n1 ) :					  
  i < n1 ;						      	      sum1 += stack1 [ i ]				    	    sum1 += stack1 [ i ]				  
  i ++ ) sum1 += stack1 [ i ] ;				      	  for i in range ( n2 ) :				    	for i in range ( n2 ) :					  
  for ( int i = 0 ;					      	      sum2 += stack2 [ i ]				    	    sum2 += stack2 [ i ]				  
  i < n2 ;						      	  for i in range ( n3 ) :				    	for i in range ( n3 ) :					  
  i ++ ) sum2 += stack2 [ i ] ;				      	      sum3 += stack3 [ i ]				    	    sum3 += stack3 [ i ]				  
  for ( int i = 0 ;					      	  top1 , top2 , top3 = 0 , 0 , 0			    	top1 , top2 , top3 = 0 , 0 , 0				  
  i < n3 ;						      	  ans = 0						    	ans = 0							  
  i ++ ) sum3 += stack3 [ i ] ;				      	  while ( 1 ) :						    	while True :						  
  int top1 = 0 , top2 = 0 , top3 = 0 ;			      	      if ( top1 == n1 or top2 == n2 or top3 == n3 ) :	    	    if top1 == n1 or top2 == n2 or top3 == n3 :		  
  int ans = 0 ;						      		  return 0					    		return 0					  
  while ( true ) {					      	      if ( sum1 == sum2 and sum2 == sum3 ) :		    	    if sum1 == sum2 and sum2 == sum3 :			  
    if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ;  		  return sum1					    		return sum1					  
    if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ;	      	      if ( sum1 >= sum2 and sum1 >= sum3 ) :		    	    if sum1 >= sum2 and sum1 >= sum3 :			  
    if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 		  sum1 -= stack1 [ top1 ]			    		sum1 -= stack1 [ top1 ]				  
    else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ 		  top1 = top1 + 1				    		top1 += 1					  
    else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ 	      elif ( sum2 >= sum3 and sum2 >= sum3 ) :		    	    elif sum2 >= sum3 and sum2 >= sum3 :		  
  }							      		  sum2 -= stack2 [ top2 ]			    		sum2 -= stack2 [ top2 ]				  
}							      		  top2 = top2 + 1				    		top2 += 1					  
							      	      elif ( sum3 >= sum2 and sum3 >= sum1 ) :		    	    elif sum3 >= sum2 and sum3 >= sum1 :		  
							      		  sum3 -= stack3 [ top3 ]			    		sum3 -= stack3 [ top3 ]				  
							      		  top3 = top3 + 1				    		top3 += 1					  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K		      LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K		    LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K		  LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K
--							      --							    --								  --
static int longestSubsequenceCommonSegment ( int k , String s def longestSubsequenceCommonSegment ( k , s1 , s2 ) :	    def longest_subsequence_common_segment ( k , s1 , s2 ) :	  error : Traceback (most recent call last):   File
  int n = s1 . length ( ) ;				      	  n = len ( s1 )					    	n = len ( s1 )						  "dump/transcoder_st/eval/java_python/online_st/206
  int m = s2 . length ( ) ;				      	  m = len ( s2 )					    	m = len ( s2 )						  68770/eval_scripts/java_sa-python_sa.test/LCS_FORM
  int lcs [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;	      	  lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n 	lcs = np.zeros ( ( n + 1 , m + 1 ) )			  ED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K.py", line 6
  int cnt [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;	      	  cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n 	cnt = np.zeros ( ( n + 1 , m + 1 ) )			  4, in <module>     if f_filled(*parameters_set) ==
  for ( int i = 1 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				   f_gold(*parameters_set):   File "dump/transcoder_
  i <= n ;						      	      for j in range ( 1 , m + 1 ) :			    	    for j in range ( 1 , m + 1 ) :			  st/eval/java_python/online_st/20668770/eval_script
  i ++ ) {						      		  lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs 		lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs s/java_sa-python_sa.test/LCS_FORMED_CONSECUTIVE_SE
    for ( int j = 1 ;					      		  if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) :		    		if s1 [ i - 1 ] == s2 [ j - 1 ] :		  GMENTS_LEAST_LENGTH_K.py", line 44, in f_filled
    j <= m ;						      		      cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 		    cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1   for a in range ( k , cnt [ i ] [ j ] + 1 ) : Typ
    j ++ ) {						      		  if ( cnt [ i ] [ j ] >= k ) :			    		if cnt [ i ] [ j ] >= k :			  eError: 'numpy.float64' object cannot be interpret
      lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lc 		      for a in range ( k , cnt [ i ] [ j ] + 1 ) :  		    for a in range ( k , cnt [ i ] [ j ] + 1 ) :  ed as an integer
      if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) c 			  lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , 			lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , 
      if ( cnt [ i ] [ j ] >= k ) {			      	  return lcs [ n ] [ m ]				    	return lcs [ n ] [ m ]					  
	for ( int a = k ;				      								    								  
	a <= cnt [ i ] [ j ] ;				      								    								  
	a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] 								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return lcs [ n ] [ m ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_APPLYING_GIVEN_EQUATION			      SORT_ARRAY_APPLYING_GIVEN_EQUATION			    SORT_ARRAY_APPLYING_GIVEN_EQUATION				  SORT_ARRAY_APPLYING_GIVEN_EQUATION
--							      --							    --								  --
static void sortArray ( int arr [ ] , int n , int A , int B , def sortArray ( arr , n , A , B , C ) :			    def sort_array ( arr , n , A , B , C ) :			  failure : #Results: 0, 10
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i 	    arr [ i ] = A * arr [ i ] ** 2 + B * arr [ i ] + C	  
  i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i  	  index = - ( sys.maxsize - 1 )				    	index = - 1						  
  int index = - 1 ;					      	  maximum = - ( sys.maxsize - 1 )			    	maximum = - 999999					  
  int maximum = - 999999 ;				      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  for ( int i = 0 ;					      	      if maximum < arr [ i ] :				    	    if maximum < arr [ i ] :				  
  i < n ;						      		  index = i					    		index = i					  
  i ++ ) {						      		  maximum = arr [ i ]				    		maximum = arr [ i ]				  
    if ( maximum < arr [ i ] ) {			      	  i = 0 j = n - 1					    	i , j = 0 , n - 1					  
      index = i ;					      	  new_arr = [ 0 ] * n					    	new_arr = [ 0 ] * n					  
      maximum = arr [ i ] ;				      	  k = 0							    	k = 0							  
    }							      	  while i < index and j > index :			    	while i < index and j > index :				  
  }							      	      if arr [ i ] < arr [ j ] :			    	    if arr [ i ] < arr [ j ] :				  
  int i = 0 , j = n - 1 ;				      		  new_arr [ k ] = arr [ i ]			    		new_arr [ k ] = arr [ i ]			  
  int [ ] new_arr = new int [ n ] ;			      		  k += 1					    		i += 1						  
  int k = 0 ;						      		  i += 1					    	    else :						  
  while ( i < index && j > index ) {			      	      else :						    		new_arr [ k ] = arr [ j ]			  
    if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i + 		  new_arr [ k ] = arr [ j ]			    		j -= 1						  
    else new_arr [ k ++ ] = arr [ j -- ] ;		      		  k += 1					    	while i < index :					  
  }							      		  j -= 1					    	    new_arr [ k ] = arr [ i ]				  
  while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ] ;	      	  while i < index :					    	    i += 1						  
  while ( j > index ) new_arr [ k ++ ] = arr [ j -- ] ;	      	      new_arr [ k ] = arr [ i ]				    	while j > index :					  
  new_arr [ n - 1 ] = maximum ;				      	      k += 1						    	    new_arr [ k ] = arr [ j ]				  
  for ( int p = 0 ;					      	      i += 1						    	    j -= 1						  
  p < n ;						      	  while j > index :					    	new_arr [ n - 1 ] = maximum				  
  p ++ ) arr [ p ] = new_arr [ p ] ;			      	      new_arr [ k ] = arr [ j ]				    	for p in range ( n ) :					  
}							      	      k += 1						    	    arr [ p ] = new_arr [ p ]				  
							      	      j -= 1						    								  
							      	      new_arr [ n - 1 ] = maximum			    								  
							      	  for i in range ( n ) :				    								  
							      	      arr [ i ] = new_arr [ i ]				    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM			      MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM			    MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM				  MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM
--							      --							    --								  --
static int maxSum ( int [ ] [ ] mat , int n ) {		      def maxSum ( mat , n ) :					    def max_sum ( mat , n ) :					  script_not_found : None
  if ( n == 1 ) return mat [ 0 ] [ 0 ] ;		      	  if n == 1 :						    	if n == 1 :						  
  int dp [ ] [ ] = new int [ n ] [ n ] ;		      	      return mat [ 0 ] [ 0 ]				    	    return mat [ 0 ] [ 0 ]				  
  int maxSum = Integer . MIN_VALUE , max ;		      	  dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]  	dp = np.zeros ( ( n , n ) )				  
  for ( int j = 0 ;					      	  maxSum = INT_MIN					    	max_sum , max = 0 , 0					  
  j < n ;						      	  for j in range ( n ) :				    	for j in range ( n ) :					  
  j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ;	      	      dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ]		    	    dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ]		  
  for ( int i = n - 2 ;					      	  for i in range ( n - 2 , - 1 , - 1 ) :		    	for i in range ( n - 2 , - 1 , - 1 ) :			  
  i >= 0 ;						      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
  i -- ) {						      		  maxi = INT_MIN				    		max = 0						  
    for ( int j = 0 ;					      		  if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 		if ( ( j - 1 ) >= 0 ) and ( max < dp [ i + 1 ] [  
    j < n ;						      		      maxi = dp [ i + 1 ] [ j - 1 ]		    		    max = dp [ i + 1 ] [ j - 1 ]		  
    j ++ ) {						      		  if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1  		if ( ( j + 1 ) < n ) and ( max < dp [ i + 1 ] [ j 
      max = Integer . MIN_VALUE ;			      		      maxi = dp [ i + 1 ] [ j + 1 ]		    		    max = dp [ i + 1 ] [ j + 1 ]		  
      if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 		  dp [ i ] [ j ] = mat [ i ] [ j ] + maxi	    		dp [ i ] [ j ] = mat [ i ] [ j ] + max		  
      if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1  	  for j in range ( n ) :				    	for j in range ( n ) :					  
      dp [ i ] [ j ] = mat [ i ] [ j ] + max ;		      	      if ( maxSum < dp [ 0 ] [ j ] ) :			    	    if max_sum < dp [ 0 ] [ j ] :			  
    }							      		  maxSum = dp [ 0 ] [ j ]			    		max_sum = dp [ 0 ] [ j ]			  
  }							      	  return maxSum						    	return max_sum						  
  for ( int j = 0 ;					      								    								  
  j < n ;						      								    								  
  j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j 								    								  
  return maxSum ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAGIC_SQUARE						      MAGIC_SQUARE						    MAGIC_SQUARE						  MAGIC_SQUARE
--							      --							    --								  --
static void generateSquare ( int n ) {			      def generateSquare ( n ) :				    def generateSquare ( n ) :					  script_not_found : None
  int [ ] [ ] magicSquare = new int [ n ] [ n ] ;	      	  magicSquare = [ [ 0 for x in range ( n ) ] for y in range 	magicSquare = np.zeros ( ( n , n ) )			  
  int i = n / 2 ;					      	  i = n / 2						    	i = n // 2						  
  int j = n - 1 ;					      	  j = n - 1						    	j = n - 1						  
  for ( int num = 1 ;					      	  num = 1						    	for num in range ( 1 , n * n + 1 ) :			  
  num <= n * n ;					      	  while num <= ( n * n ) :				    	    if i == - 1 and j == n :				  
  ) {							      	      if i == - 1 and j == n :				    		j = n - 2					  
    if ( i == - 1 && j == n ) {				      		  j = n - 2					    		i = 0						  
      j = n - 2 ;					      		  i = 0						    	    else :						  
      i = 0 ;						      	      else :						    		if j == n :					  
    }							      		  if j == n :					    		    j = 0					  
    else {						      		      j = 0					    		if i < 0 :					  
      if ( j == n ) j = 0 ;				      		  if i < 0 :					    		    i = n - 1					  
      if ( i < 0 ) i = n - 1 ;				      		      i = n - 1					    	    if magicSquare [ i ] [ j ] != 0 :			  
    }							      	      if magicSquare [ int ( i ) ] [ int ( j ) ] :	    		j -= 2						  
    if ( magicSquare [ i ] [ j ] != 0 ) {		      		  j = j - 2					    		i += 1						  
      j -= 2 ;						      		  i = i + 1					    		continue					  
      i ++ ;						      		  continue					    	    else :						  
      continue ;					      	      else :						    		magicSquare [ i ] [ j ] = num			  
    }							      		  magicSquare [ int ( i ) ] [ int ( j ) ] = num	    		j += 1						  
    else magicSquare [ i ] [ j ] = num ++ ;		      		  num = num + 1					    	    j += 1						  
    j ++ ;						      	      j = j + 1						    	    i -= 1						  
    i -- ;						      	      i = i - 1						    	print ( "The Magic Square for %d:" % n )		  
  }							      	  print ( "Magic Squre for n =" , n )			    	print ( "Sum of each row or column %d:" % ( n * ( n * n + 
  System . out . println ( "The Magic Square for " + n + ":"  	  print ( "Sum of each row or column" , n * ( n * n + 1 ) / 	for i in range ( n ) :					  
  System . out . println ( "Sum of each row or column " + n * 	  for i in range ( 0 , n ) :				    	    for j in range ( n ) :				  
  for ( i = 0 ;						      	      for j in range ( 0 , n ) :			    		print ( magicSquare [ i ] [ j ] , end = ' ' )	  
  i < n ;						      		  print ( '%2d ' % ( magicSquare [ i ] [ j ] ) , en 	    print ( )						  
  i ++ ) {						      		  if j == n - 1 :				    								  
    for ( j = 0 ;					      		      print ( )					    								  
    j < n ;						      								    								  
    j ++ ) System . out . print ( magicSquare [ i ] [ j ] + " 								    								  
    System . out . println ( ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS
--							      --							    --								  --
static int largestKSubmatrix ( int [ ] [ ] a ) {	      def largestKSubmatrix ( a ) :				    def largestKSubmatrix ( a ) :				  script_not_found : None
  int [ ] [ ] dp = new int [ Row ] [ Col ] ;		      	  dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col  	dp = np.zeros ( ( Row , Col ) )				  
  int result = 0 ;					      	  result = 0						    	result = 0						  
  for ( int i = 0 ;					      	  for i in range ( Row ) :				    	for i in range ( Row ) :				  
  i < Row ;						      	      for j in range ( Col ) :				    	    for j in range ( Col ) :				  
  i ++ ) {						      		  if ( i == 0 or j == 0 ) :			    		if i == 0 or j == 0 :				  
    for ( int j = 0 ;					      		      dp [ i ] [ j ] = 1			    		    dp [ i ] [ j ] = 1				  
    j < Col ;						      		  else :					    		else :						  
    j ++ ) {						      		      if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a 		    if a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ 
      if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1 ;	      			  dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] 			dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > d 
      else {						      		      else :					    		    else :					  
	if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [  			  dp [ i ] [ j ] = 1			    			dp [ i ] [ j ] = 1			  
	  dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [  		  result = max ( result , dp [ i ] [ j ] )	    		result = result if result > dp [ i ] [ j ] else d 
	}						      	  return result						    	return result						  
	else dp [ i ] [ j ] = 1 ;			      								    								  
      }							      								    								  
      result = result > dp [ i ] [ j ] ? result : dp [ i ] [  								    								  
    }							      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS	      WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS	    WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS		  WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS
--							      --							    --								  --
static int countTransformation ( String a , String b ) {      def countTransformation ( a , b ) :			    def count_transformation ( a , b ) :			  success : None
  int n = a . length ( ) , m = b . length ( ) ;		      	  n = len ( a )						    	n , m = len ( a ) , len ( b )				  
  if ( m == 0 ) {					      	  m = len ( b )						    	if m == 0 :						  
    return 1 ;						      	  if m == 0 :						    	    return 1						  
  }							      	      return 1						    	dp = np.zeros ( ( m + 1 , n + 1 ) )			  
  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	  dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ]	    	for i in range ( m ) :					  
  for ( int i = 0 ;					      	  for i in range ( m ) :				    	    for j in range ( i , n ) :				  
  i < m ;						      	      for j in range ( i , n ) :			    		if i == 0 :					  
  i ++ ) {						      		  if i == 0 :					    		    if j == 0 :					  
    for ( int j = i ;					      		      if j == 0 :				    			dp [ i ] [ j ] = ( 1 if a [ j ] == b [ i  
    j < n ;						      			  if a [ j ] == b [ i ] :		    		    elif a [ j ] == b [ i ] :			  
    j ++ ) {						      			      dp [ i ] [ j ] = 1		    			dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1	  
      if ( i == 0 ) {					      			  else :				    		    else :					  
	if ( j == 0 ) {					      			      dp [ i ] [ j ] = 0		    			dp [ i ] [ j ] = dp [ i ] [ j - 1 ]	  
	  dp [ i ] [ j ] = ( a . charAt ( j ) == b . charAt ( 		      elif a [ j ] == b [ i ] :			    		elif a [ j ] == b [ i ] :			  
	}						      			  dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1   		    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i  
	else if ( a . charAt ( j ) == b . charAt ( i ) ) {    		      else :					    		else :						  
	  dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ;	      			  dp [ i ] [ j ] = dp [ i ] [ j - 1 ]	    		    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]		  
	}						      		  else :					    	return dp [ m - 1 ] [ n - 1 ]				  
	else {						      		      if a [ j ] == b [ i ] :			    								  
	  dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		      			  dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + d 								  
	}						      		      else :					    								  
      }							      			  dp [ i ] [ j ] = dp [ i ] [ j - 1 ]	    								  
      else if ( a . charAt ( j ) == b . charAt ( i ) ) {      	  return dp [ m - 1 ] [ n - 1 ]				    								  
	dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [  								    								  
      }							      								    								  
      else {						      								    								  
	dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return dp [ m - 1 ] [ n - 1 ] ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ROTATE_MATRIX_ELEMENTS					      ROTATE_MATRIX_ELEMENTS					    ROTATE_MATRIX_ELEMENTS					  ROTATE_MATRIX_ELEMENTS
--							      --							    --								  --
static void rotatematrix ( int m , int n , int mat [ ] [ ] )  def rotateMatrix ( mat ) :				    def rotatematrix ( m , n , mat ) :				  script_not_found : None
  int row = 0 , col = 0 ;				      	  if not len ( mat ) :					    	row , col = 0 , 0					  
  int prev , curr ;					      	      return						    	prev , curr = 0 , 0					  
  while ( row < m && col < n ) {			      	  top = 0						    	while row < m and col < n :				  
    if ( row + 1 == m || col + 1 == n ) break ;		      	  bottom = len ( mat ) - 1				    	    if row + 1 == m or col + 1 == n :			  
    prev = mat [ row + 1 ] [ col ] ;			      	  left = 0						    		break						  
    for ( int i = col ;					      	  right = len ( mat [ 0 ] ) - 1				    	    prev = mat [ row + 1 ] [ col ]			  
    i < n ;						      	  while left < right and top < bottom :			    	    for i in range ( col , n ) :			  
    i ++ ) {						      	      prev = mat [ top + 1 ] [ left ]			    		curr = mat [ row ] [ i ]			  
      curr = mat [ row ] [ i ] ;			      	      for i in range ( left , right + 1 ) :		    		mat [ row ] [ i ] = prev			  
      mat [ row ] [ i ] = prev ;			      		  curr = mat [ top ] [ i ]			    		prev = curr					  
      prev = curr ;					      		  mat [ top ] [ i ] = prev			    	    row += 1						  
    }							      		  prev = curr					    	    for i in range ( row , m ) :			  
    row ++ ;						      	      top += 1						    		curr = mat [ i ] [ n - 1 ]			  
    for ( int i = row ;					      	      for i in range ( top , bottom + 1 ) :		    		mat [ i ] [ n - 1 ] = prev			  
    i < m ;						      		  curr = mat [ i ] [ right ]			    		prev = curr					  
    i ++ ) {						      		  mat [ i ] [ right ] = prev			    	    n -= 1						  
      curr = mat [ i ] [ n - 1 ] ;			      		  prev = curr					    	    if row < m :					  
      mat [ i ] [ n - 1 ] = prev ;			      	      right -= 1					    		for i in range ( n - 1 , col - 1 , - 1 ) :	  
      prev = curr ;					      	      for i in range ( right , left - 1 , - 1 ) :	    		    curr = mat [ m - 1 ] [ i ]			  
    }							      		  curr = mat [ bottom ] [ i ]			    		    mat [ m - 1 ] [ i ] = prev			  
    n -- ;						      		  mat [ bottom ] [ i ] = prev			    		    prev = curr					  
    if ( row < m ) {					      		  prev = curr					    	    m -= 1						  
      for ( int i = n - 1 ;				      	      bottom -= 1					    	    if col < n :					  
      i >= col ;					      	      for i in range ( bottom , top - 1 , - 1 ) :	    		for i in range ( m - 1 , row , - 1 ) :		  
      i -- ) {						      		  curr = mat [ i ] [ left ]			    		    curr = mat [ i ] [ col ]			  
	curr = mat [ m - 1 ] [ i ] ;			      		  mat [ i ] [ left ] = prev			    		    mat [ i ] [ col ] = prev			  
	mat [ m - 1 ] [ i ] = prev ;			      		  prev = curr					    		    prev = curr					  
	prev = curr ;					      	      left += 1						    	    col += 1						  
      }							      	  return mat						    	for i in range ( R ) :					  
    }							      								    	    for j in range ( C ) :				  
    m -- ;						      								    		print ( mat [ i ] [ j ] , end = ' ' )		  
    if ( col < n ) {					      								    	    print ( '\n' , end = ' ' )				  
      for ( int i = m - 1 ;				      								    								  
      i >= row ;					      								    								  
      i -- ) {						      								    								  
	curr = mat [ i ] [ col ] ;			      								    								  
	mat [ i ] [ col ] = prev ;			      								    								  
	prev = curr ;					      								    								  
      }							      								    								  
    }							      								    								  
    col ++ ;						      								    								  
  }							      								    								  
  for ( int i = 0 ;					      								    								  
  i < R ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j < C ;						      								    								  
    j ++ ) System . out . print ( mat [ i ] [ j ] + " " ) ;   								    								  
    System . out . print ( "\n" ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM
--							      --							    --								  --
static int minSum ( int [ ] arr , int n ) {		      def minSum ( arr , n ) :					    def min_sum ( arr , n ) :					  success : None
  int [ ] dp = new int [ n ] ;				      	  dp = [ 0 ] * n					    	dp = [ 0 ] * n						  
  if ( n == 1 ) return arr [ 0 ] ;			      	  if ( n == 1 ) :					    	if n == 1 :						  
  if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; 	      return arr [ 0 ]					    	    return arr [ 0 ]					  
  if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min (  	  if ( n == 2 ) :					    	if n == 2 :						  
  if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] ,  	      return min ( arr [ 0 ] , arr [ 1 ] )		    	    return min ( arr [ 0 ] , arr [ 1 ] )		  
  dp [ 0 ] = arr [ 0 ] ;				      	  if ( n == 3 ) :					    	if n == 3 :						  
  dp [ 1 ] = arr [ 1 ] ;				      	      return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ]  	    return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ]  
  dp [ 2 ] = arr [ 2 ] ;				      	  if ( n == 4 ) :					    	if n == 4 :						  
  dp [ 3 ] = arr [ 3 ] ;				      	      return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( ar 	    return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( ar 
  for ( int i = 4 ;					      	  dp [ 0 ] = arr [ 0 ]					    	dp [ 0 ] = arr [ 0 ]					  
  i < n ;						      	  dp [ 1 ] = arr [ 1 ]					    	dp [ 1 ] = arr [ 1 ]					  
  i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp  	  dp [ 2 ] = arr [ 2 ]					    	dp [ 2 ] = arr [ 2 ]					  
  return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2  	  dp [ 3 ] = arr [ 3 ]					    	dp [ 3 ] = arr [ 3 ]					  
}							      	  for i in range ( 4 , n ) :				    	for i in range ( 4 , n ) :				  
							      	      dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp  	    dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp  
							      	  return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min (  	return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min (  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH
--							      --							    --								  --
static boolean isValidString ( String str ) {		      def isValidString ( str ) :				    def is_valid_string ( str ) :				  script_not_found : None
  int freq [ ] = new int [ CHARS ] ;			      	  freq = [ 0 ] * CHARS					    	freq = np.zeros ( ( CHARS , ) )				  
  for ( int i = 0 ;					      	  for i in range ( len ( str ) ) :			    	for c in str :						  
  i < str . length ( ) ;				      	      freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1	    	    freq [ ord ( c ) - ord ( 'a' ) ] += 1		  
  i ++ ) {						      	  freq1 = 0						    	i , freq1 , count_freq1 = 0 , 0 , 0			  
    freq [ str . charAt ( i ) - 'a' ] ++ ;		      	  count_freq1 = 0					    	for c in range ( CHARS ) :				  
  }							      	  for i in range ( CHARS ) :				    	    if c in freq :					  
  int i , freq1 = 0 , count_freq1 = 0 ;			      	      if ( freq [ i ] != 0 ) :				    		freq1 = freq [ c ]				  
  for ( i = 0 ;						      		  freq1 = freq [ i ]				    		count_freq1 = 1					  
  i < CHARS ;						      		  count_freq1 = 1				    		break						  
  i ++ ) {						      		  break						    	j , freq2 , count_freq2 = 0 , 0 , 0			  
    if ( freq [ i ] != 0 ) {				      	  freq2 = 0						    	for c in range ( i + 1 , CHARS ) :			  
      freq1 = freq [ i ] ;				      	  count_freq2 = 0					    	    if c in freq :					  
      count_freq1 = 1 ;					      	  for j in range ( i + 1 , CHARS ) :			    		if freq [ c ] == freq1 :			  
      break ;						      	      if ( freq [ j ] != 0 ) :				    		    count_freq1 += 1				  
    }							      		  if ( freq [ j ] == freq1 ) :			    		else :						  
  }							      		      count_freq1 += 1				    		    count_freq2 = 1				  
  int j , freq2 = 0 , count_freq2 = 0 ;			      		  else :					    		    freq2 = freq [ c ]				  
  for ( j = i + 1 ;					      		      count_freq2 = 1				    		    break					  
  j < CHARS ;						      		      freq2 = freq [ j ]			    	for c in range ( j + 1 , CHARS ) :			  
  j ++ ) {						      		      break					    	    if c in freq :					  
    if ( freq [ j ] != 0 ) {				      	  for k in range ( j + 1 , CHARS ) :			    		if freq [ c ] == freq1 :			  
      if ( freq [ j ] == freq1 ) {			      	      if ( freq [ k ] != 0 ) :				    		    count_freq1 += 1				  
	count_freq1 ++ ;				      		  if ( freq [ k ] == freq1 ) :			    		if freq [ c ] == freq2 :			  
      }							      		      count_freq1 += 1				    		    count_freq2 += 1				  
      else {						      		  if ( freq [ k ] == freq2 ) :			    		else :						  
	count_freq2 = 1 ;				      		      count_freq2 += 1				    		    return False				  
	freq2 = freq [ j ] ;				      		  else :					    	    if count_freq1 > 1 and count_freq2 > 1 :		  
	break ;						      		      return False				    		return False					  
      }							      	      if ( count_freq1 > 1 and count_freq2 > 1 ) :	    	return True						  
    }							      		  return False					    								  
  }							      	  return True						    								  
  for ( int k = j + 1 ;					      								    								  
  k < CHARS ;						      								    								  
  k ++ ) {						      								    								  
    if ( freq [ k ] != 0 ) {				      								    								  
      if ( freq [ k ] == freq1 ) {			      								    								  
	count_freq1 ++ ;				      								    								  
      }							      								    								  
      if ( freq [ k ] == freq2 ) {			      								    								  
	count_freq2 ++ ;				      								    								  
      }							      								    								  
      else {						      								    								  
	return false ;					      								    								  
      }							      								    								  
    }							      								    								  
    if ( count_freq1 > 1 && count_freq2 > 1 ) {		      								    								  
      return false ;					      								    								  
    }							      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL
--							      --							    --								  --
static int minCells ( int mat [ ] [ ] , int m , int n ) {     def minCells ( mat , m , n ) :				    def min_cells ( mat , m , n ) :				  script_not_found : None
  int dp [ ] [ ] = new int [ m ] [ n ] ;		      	  dp = [ [ MAX for i in range ( n ) ] for i in range ( m )  	dp = np.zeros ( ( m , n ) )				  
  for ( int i = 0 ;					      	  dp [ 0 ] [ 0 ] = 1					    	for i in range ( m ) :					  
  i < m ;						      	  for i in range ( m ) :				    	    for j in range ( n ) :				  
  i ++ ) for ( int j = 0 ;				      	      for j in range ( n ) :				    		dp [ i ] [ j ] = np.inf				  
  j < n ;						      		  if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [  	    dp [ 0 ] [ 0 ] = 1					  
  j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE ;		      		      dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ 	for i in range ( m ) :					  
  dp [ 0 ] [ 0 ] = 1 ;					      		  if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [  	    for j in range ( n ) :				  
  for ( int i = 0 ;					      		      dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ 		if dp [ i ] [ j ] != np.inf and ( j + mat [ i ] [ 
  i < m ;						      	  if ( dp [ m - 1 ] [ n - 1 ] != MAX ) :		    		    dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ 
  i ++ ) {						      	      return dp [ m - 1 ] [ n - 1 ]			    		if dp [ i ] [ j ] != np.inf and ( i + mat [ i ] [ 
    for ( int j = 0 ;					      	  return - 1						    		    dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ 
    j < n ;						      								    	if dp [ m - 1 ] [ n - 1 ] != np.inf :			  
    j ++ ) {						      								    	    return dp [ m - 1 ] [ n - 1 ]			  
      if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat 								    	return - 1						  
      if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat 								    								  
    }							      								    								  
  }							      								    								  
  if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return 								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRUFER_CODE_TREE_CREATION				      PRUFER_CODE_TREE_CREATION					    PRUFER_CODE_TREE_CREATION					  PRUFER_CODE_TREE_CREATION
--							      --							    --								  --
static void printTreeEdges ( int prufer [ ] , int m ) {	      def printTreeEdges ( prufer , m ) :			    def print_tree_edges ( prufer , m ) :			  script_not_found : None
  int vertices = m + 2 ;				      	  vertices = m + 2					    	vertices = m + 2					  
  int vertex_set [ ] = new int [ vertices ] ;		      	  vertex_set = [ 0 ] * vertices				    	vertex_set = [ 0 ] * vertices				  
  for ( int i = 0 ;					      	  for i in range ( vertices - 2 ) :			    	for i in range ( vertices ) :				  
  i < vertices ;					      	      vertex_set [ prufer [ i ] - 1 ] += 1		    	    vertex_set [ i ] = 0				  
  i ++ ) vertex_set [ i ] = 0 ;				      	  print ( "The edge set E(G) is :" )			    	for i in range ( vertices - 2 ) :			  
  for ( int i = 0 ;					      	  j = 0							    	    vertex_set [ prufer [ i ] - 1 ] += 1		  
  i < vertices - 2 ;					      	  for i in range ( vertices - 2 ) :			    	print ( "\nThe edge set E(G) is :\n" , end = "" )	  
  i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1 ;		      	      for j in range ( vertices ) :			    	j = 0							  
  System . out . print ( "\nThe edge set E(G) is :\n" ) ;     		  if ( vertex_set [ j ] == 0 ) :		    	for i in range ( vertices - 2 ) :			  
  int j = 0 ;						      		      vertex_set [ j ] = - 1			    	    for j in range ( vertices ) :			  
  for ( int i = 0 ;					      		      print ( "(" , ( j + 1 ) , ", " , prufer [ i ] 		if vertex_set [ j ] == 0 :			  
  i < vertices - 2 ;					      		      vertex_set [ prufer [ i ] - 1 ] -= 1	    		    vertex_set [ j ] = - 1			  
  i ++ ) {						      		      break					    		    print ( "(%d, %d) " % ( j + 1 , prufer [ i ]  
    for ( j = 0 ;					      	  j = 0							    		    vertex_set [ prufer [ i ] - 1 ] -= 1	  
    j < vertices ;					      	  for i in range ( vertices ) :				    		    break					  
    j ++ ) {						      	      if ( vertex_set [ i ] == 0 and j == 0 ) :		    	j = 0							  
      if ( vertex_set [ j ] == 0 ) {			      		  print ( "(" , ( i + 1 ) , ", " , sep = "" , end = 	for i in range ( vertices ) :				  
	vertex_set [ j ] = - 1 ;			      		  j += 1					    	    if vertex_set [ i ] == 0 and j == 0 :		  
	System . out . print ( "(" + ( j + 1 ) + ", " + prufe 	      elif ( vertex_set [ i ] == 0 and j == 1 ) :	    		print ( "(%d, " % ( i + 1 ) , end = "" )	  
	vertex_set [ prufer [ i ] - 1 ] -- ;		      		  print ( ( i + 1 ) , ")" )			    		j += 1						  
	break ;						      								    	    elif vertex_set [ i ] == 0 and j == 1 :		  
      }							      								    		print ( "%d)\n" % ( ( i + 1 ) ) , end = "" )	  
    }							      								    								  
  }							      								    								  
  j = 0 ;						      								    								  
  for ( int i = 0 ;					      								    								  
  i < vertices ;					      								    								  
  i ++ ) {						      								    								  
    if ( vertex_set [ i ] == 0 && j == 0 ) {		      								    								  
      System . out . print ( "(" + ( i + 1 ) + ", " ) ;	      								    								  
      j ++ ;						      								    								  
    }							      								    								  
    else if ( vertex_set [ i ] == 0 && j == 1 ) System . out  								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION		      MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION		    MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION			  MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION
--							      --							    --								  --
static void minMaxValues ( int [ ] arr , int n , int m ) {    def minMaxValues ( arr , n , m ) :			    def min_max_values ( arr , n , m ) :			  script_not_found : None
  int sum = 0 ;						      	  sum = 0						    	sum = 0							  
  for ( int i = 0 ;					      	  INF = 1000000000					    	for i in range ( ( n + m ) ) :				  
  i < ( n + m ) ;					      	  MAX = 50						    	    sum += arr [ i ]					  
  i ++ ) {						      	  for i in range ( 0 , ( n + m ) ) :			    	    arr [ i ] += 50					  
    sum += arr [ i ] ;					      	      sum += arr [ i ]					    	dp = np.zeros ( ( MAX + 1 , MAX * MAX + 1 ) )		  
    arr [ i ] += 50 ;					      	      arr [ i ] += 50					    	dp [ 0 ] [ 0 ] = True					  
  }							      	  dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in ra 	for i in range ( ( n + m ) ) :				  
  boolean dp [ ] [ ] = new boolean [ MAX + 1 ] [ MAX * MAX +  	  dp [ 0 ] [ 0 ] = 1					    	    for k in np.arange ( min ( n , i + 1 ) , 1 , - 1 ) :  
  dp [ 0 ] [ 0 ] = true ;				      	  for i in range ( 0 , ( n + m ) ) :			    		for j in range ( MAX * MAX + 1 ) :		  
  for ( int i = 0 ;					      	      for k in range ( min ( n , i + 1 ) , 0 , - 1 ) :	    		    if dp [ k - 1 ] [ j ] :			  
  i < ( n + m ) ;					      		  for j in range ( 0 , MAX * MAX + 1 ) :	    			dp [ k ] [ j + arr [ i ] ] = True	  
  i ++ ) {						      		      if ( dp [ k - 1 ] [ j ] ) :		    	max_value , min_value = - 1 * INF , INF			  
    for ( int k = Math . min ( n , i + 1 ) ;		      			  dp [ k ] [ j + arr [ i ] ] = 1	    	for i in range ( MAX * MAX + 1 ) :			  
    k >= 1 ;						      	  max_value = - 1 * INF					    	    if dp [ n ] [ i ] :					  
    k -- ) {						      	  min_value = INF					    		temp = i - 50 * n				  
      for ( int j = 0 ;					      	  for i in range ( 0 , MAX * MAX + 1 ) :		    		max_value = max ( max_value , temp * ( sum - temp 
      j < MAX * MAX + 1 ;				      	      if ( dp [ n ] [ i ] ) :				    		min_value = min ( min_value , temp * ( sum - temp 
      j ++ ) {						      		  temp = i - 50 * n				    	sys.stdout.write ( "Maximum Value: %d\n" % int ( max_valu 
	if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ]  		  max_value = max ( max_value , temp * ( sum - temp 								  
      }							      		  min_value = min ( min_value , temp * ( sum - temp 								  
    }							      	  print ( "Maximum Value: {}\nMinimum Value: {}".format ( m 								  
  }							      								    								  
  double max_value = - 1 * INF , min_value = INF ;	      								    								  
  for ( int i = 0 ;					      								    								  
  i < MAX * MAX + 1 ;					      								    								  
  i ++ ) {						      								    								  
    if ( dp [ n ] [ i ] ) {				      								    								  
      int temp = i - 50 * n ;				      								    								  
      max_value = Math . max ( max_value , temp * ( sum - tem 								    								  
      min_value = Math . min ( min_value , temp * ( sum - tem 								    								  
    }							      								    								  
  }							      								    								  
  System . out . print ( "Maximum Value: " + ( int ) max_valu 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6	      PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6	    PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6	  PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6
--							      --							    --								  --
static void greatest ( String s ) {			      def greatest ( s ) :					    def greatest ( s ) :					  script_not_found : None
  int n = s . length ( ) ;				      	  n = len ( s )						    	n = len ( s )						  
  int [ ] a = new int [ n ] ;				      	  a = [ 0 for i in range ( n ) ]			    	a = list ( range ( n ) )				  
  int sum = 0 ;						      	  Sum = 0						    	sum = 0							  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      a [ i ] = ord ( s [ i ] ) - ord ( '0' )		    	    a [ i ] = ord ( s [ i ] ) - ord ( '0' )		  
  i ++ ) {						      	      Sum += a [ i ]					    	    sum += a [ i ]					  
    a [ i ] = s . charAt ( i ) - '0' ;			      	  if ( a [ n - 1 ] % 2 ) :				    	if a [ n - 1 ] % 2 != 0 :				  
    sum += a [ i ] ;					      	      if ( a [ n - 2 ] % 2 != 0 or ( Sum - a [ n - 1 ] ) %  	    if a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3  
  }							      		  print ( "-1" )				    		print ( '-1' )					  
  if ( a [ n - 1 ] % 2 != 0 ) {				      	      else :						    	    else :						  
    if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 		  print ( n )					    		print ( n )					  
      System . out . println ( "-1" ) ;			      	  else :						    	else :							  
    }							      	      re = Sum % 3					    	    re = sum % 3					  
    else {						      	      dell = - 1					    	    del = - 1						  
      System . out . println ( n ) ;			      	      flag = 0						    	    flag = 0						  
    }							      	      for i in range ( n - 1 ) :			    	    for i in range ( n - 1 ) :				  
  }							      		  if ( ( a [ i ] ) % 3 == re ) :		    		if ( a [ i ] ) % 3 == re :			  
  else {						      		      if ( a [ i + 1 ] > a [ i ] ) :		    		    if a [ i + 1 ] > a [ i ] :			  
    int re = sum % 3 ;					      			  dell = i				    			del = i					  
    int del = - 1 ;					      			  flag = 1				    			flag = 1				  
    int flag = 0 ;					      			  break					    			break					  
    for ( int i = 0 ;					      		      else :					    		    else :					  
    i < n - 1 ;						      			  dell = i				    			del = i					  
    i ++ ) {						      	      if ( flag == 0 ) :				    	    if flag == 0 :					  
      if ( ( a [ i ] ) % 3 == re ) {			      		  if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 		if a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 
	if ( a [ i + 1 ] > a [ i ] ) {			      		      dell = n - 1				    		    del = n - 1					  
	  del = i ;					      	      if ( dell == - 1 ) :				    	    if del == - 1 :					  
	  flag = 1 ;					      		  print ( "-1" )				    		print ( - 1 )					  
	  break ;					      	      else :						    	    else :						  
	}						      		  print ( dell + 1 )				    		print ( del + 1 )				  
	else {						      								    								  
	  del = i ;					      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
    if ( flag == 0 ) {					      								    								  
      if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) de 								    								  
    }							      								    								  
    if ( del == - 1 ) System . out . println ( - 1 ) ;	      								    								  
    else {						      								    								  
      System . out . println ( del + 1 ) ;		      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2	      MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2	    MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2	  MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2
--							      --							    --								  --
static int getLevenstein ( StringBuilder input ) {	      def getLevenstein ( inpt ) :				    def get_levenstein ( input ) :				  script_not_found : None
  StringBuilder revInput = new StringBuilder ( input ) ;      	  revInput = inpt [ : : - 1 ]				    	rev_input = list ( input )				  
  revInput = revInput . reverse ( ) ;			      	  n = len ( inpt )					    	rev_input = rev_input.reverse ( )			  
  int n = input . length ( ) ;				      	  dp = [ [ - 1 for _ in range ( n + 1 ) ] for __ in range ( 	n = len ( input )					  
  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;	      	  for i in range ( n + 1 ) :				    	dp = np.zeros ( ( n + 1 , n + 1 ) )			  
  for ( int i = 0 ;					      	      dp [ 0 ] [ i ] = i				    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      dp [ i ] [ 0 ] = i				    	    dp [ 0 ] [ i ] = i					  
  ++ i ) {						      	  for i in range ( 1 , n + 1 ) :			    	    dp [ i ] [ 0 ] = i					  
    dp [ 0 ] [ i ] = i ;				      	      for j in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
    dp [ i ] [ 0 ] = i ;				      		  if inpt [ i - 1 ] == revInput [ j - 1 ] :	    	    for j in range ( 1 , n + 1 ) :			  
  }							      		      dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]	    		if input [ i - 1 ] == rev_input [ j - 1 ] :	  
  for ( int i = 1 ;					      		  else :					    		    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]	  
  i <= n ;						      		      dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] 		else :						  
  ++ i ) {						      	  res = INT_MAX						    		    dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] 
    for ( int j = 1 ;					      	  i , j = n , 0						    	res = np.inf						  
    j <= n ;						      	  while i >= 0 :					    	for i , j in enumerate ( dp [ n ] , 1 ) :		  
    ++ j ) {						      	      res = min ( res , dp [ i ] [ j ] )		    	    res = min ( res , dp [ i ] [ j ] )			  
      if ( input . charAt ( i - 1 ) == revInput . charAt ( j  	      if i < n :					    	    if i < n :						  
      else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j 		  res = min ( res , dp [ i + 1 ] [ j ] )	    		res = min ( res , dp [ i + 1 ] [ j ] )		  
    }							      	      if i > 0 :					    	    if i > 0 :						  
  }							      		  res = min ( res , dp [ i - 1 ] [ j ] )	    		res = min ( res , dp [ i - 1 ] [ j ] )		  
  int res = Integer . MAX_VALUE ;			      	      i -= 1						    	return res						  
  for ( int i = n , j = 0 ;				      	      j += 1						    								  
  i >= 0 ;						      	  return res						    								  
  i -- , j ++ ) {					      								    								  
    res = Math . min ( res , dp [ i ] [ j ] ) ;		      								    								  
    if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ]  								    								  
    if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ]  								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_REPEATED_SUBSEQUENCE_1				      LONGEST_REPEATED_SUBSEQUENCE_1				    LONGEST_REPEATED_SUBSEQUENCE_1				  LONGEST_REPEATED_SUBSEQUENCE_1
--							      --							    --								  --
static String longestRepeatedSubSeq ( String str ) {	      def longestRepeatedSubSeq ( str ) :			    def longest_repeated_subseq ( str ) :			  success : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( str )						  
  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;	      	  dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n  	dp = np.zeros ( ( n + 1 , n + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 0 , n + 1 ) :				  
  i <= n ;						      	      for j in range ( 1 , n + 1 ) :			    	    for j in range ( 0 , n + 1 ) :			  
  i ++ ) for ( int j = 0 ;				      		  if ( str [ i - 1 ] == str [ j - 1 ] and i != j )  		dp [ i ] [ j ] = 0				  
  j <= n ;						      		      dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]   	for i in range ( 1 , n + 1 ) :				  
  j ++ ) dp [ i ] [ j ] = 0 ;				      		  else :					    	    for j in range ( 1 , n + 1 ) :			  
  for ( int i = 1 ;					      		      dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , d 		if str [ i - 1 ] == str [ j - 1 ] and i != j :	  
  i <= n ;						      	  res = ''						    		    dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]	  
  i ++ ) for ( int j = 1 ;				      	  i = n							    		else :						  
  j <= n ;						      	  j = n							    		    dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , d 
  j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1  	  while ( i > 0 and j > 0 ) :				    	res = ""						  
  else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp  	      if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : 	i , j = n , n						  
  String res = "" ;					      		  res += str [ i - 1 ]				    	while i > 0 and j > 0 :					  
  int i = n , j = n ;					      		  i -= 1					    	    if dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 :	  
  while ( i > 0 && j > 0 ) {				      		  j -= 1					    		res = res + str [ i - 1 ]			  
    if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) {     	      elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :	    		i -= 1						  
      res = res + str . charAt ( i - 1 ) ;		      		  i -= 1					    		j -= 1						  
      i -- ;						      	      else :						    	    elif dp [ i ] [ j ] == dp [ i - 1 ] [ j ] :		  
      j -- ;						      		  j -= 1					    		i -= 1						  
    }							      	  res = ''.join ( reversed ( res ) )			    	    else :						  
    else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ;   	  return res						    		j -= 1						  
    else j -- ;						      								    	reverse = ""						  
  }							      								    	for k in range ( len ( res ) - 1 , - 1 , - 1 ) :	  
  String reverse = "" ;					      								    	    reverse = reverse + res [ k ]			  
  for ( int k = res . length ( ) - 1 ;			      								    	return reverse						  
  k >= 0 ;						      								    								  
  k -- ) {						      								    								  
    reverse = reverse + res . charAt ( k ) ;		      								    								  
  }							      								    								  
  return reverse ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS	      FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS	    FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS	  FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS
--							      --							    --								  --
static void findSmallestRange ( int arr [ ] [ ] , int n , int def findSmallestRange ( arr , n , k ) :			    def find_smallest_range ( arr , n , k ) :			  script_not_found : None
  int i , minval , maxval , minrange , minel = 0 , maxel = 0  	  i , minval , maxval , minrange , minel , maxel , flag , m 	global ptr , minval , maxval , minrange , minel , maxel , 
  for ( i = 0 ;						      	  for i in range ( k + 1 ) :				    	for i in range ( 0 , k + 1 ) :				  
  i <= k ;						      	      ptr [ i ] = 0					    	    ptr [ i ] = 0					  
  i ++ ) {						      	  minrange = 10 ** 9					    	minrange = sys.maxsize					  
    ptr [ i ] = 0 ;					      	  while ( 1 ) :						    	while True :						  
  }							      	      minind = - 1					    	    minind = - 1					  
  minrange = Integer . MAX_VALUE ;			      	      minval = 10 ** 9					    	    minval = sys.maxsize				  
  while ( true ) {					      	      maxval = - 10 ** 9				    	    maxval = sys.maxsize				  
    minind = - 1 ;					      	      flag = 0						    	    flag = 0						  
    minval = Integer . MAX_VALUE ;			      	      for i in range ( k ) :				    	    for i in range ( k ) :				  
    maxval = Integer . MIN_VALUE ;			      		  if ( ptr [ i ] == n ) :			    		if ptr [ i ] == n :				  
    flag = 0 ;						      		      flag = 1					    		    flag = 1					  
    for ( i = 0 ;					      		      break					    		    break					  
    i < k ;						      		  if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] <  		if ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < mi 
    i ++ ) {						      		      minind = i				    		    minind = i					  
      if ( ptr [ i ] == n ) {				      		      minval = arr [ i ] [ ptr [ i ] ]		    		    minval = arr [ i ] [ ptr [ i ] ]		  
	flag = 1 ;					      		  if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] >  		if ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > ma 
	break ;						      		      maxval = arr [ i ] [ ptr [ i ] ]		    		    maxval = arr [ i ] [ ptr [ i ] ]		  
      }							      	      if ( flag ) :					    	    if flag == 1 :					  
      if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval  		  break						    		break						  
	minind = i ;					      	      ptr [ minind ] += 1				    	    ptr [ minind ] += 1					  
	minval = arr [ i ] [ ptr [ i ] ] ;		      	      if ( ( maxval - minval ) < minrange ) :		    	    if ( maxval - minval ) < minrange :			  
      }							      		  minel = minval				    		minel = minval					  
      if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval  		  maxel = maxval				    		maxel = maxval					  
	maxval = arr [ i ] [ ptr [ i ] ] ;		      		  minrange = maxel - minel			    		minrange = maxel - minel			  
      }							      	  print ( "The smallest range is [" , minel , maxel , "]" ) 	sys.stdout.write ( "The smallest range is [%d , %d]\n" %  
    }							      								    								  
    if ( flag == 1 ) {					      								    								  
      break ;						      								    								  
    }							      								    								  
    ptr [ minind ] ++ ;					      								    								  
    if ( ( maxval - minval ) < minrange ) {		      								    								  
      minel = minval ;					      								    								  
      maxel = maxval ;					      								    								  
      minrange = maxel - minel ;			      								    								  
    }							      								    								  
  }							      								    								  
  System . out . printf ( "The smallest range is [%d , %d]\n" 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION		      MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION		    MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION		  MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION
--							      --							    --								  --
static int minInitialPoints ( int points [ ] [ ] , int R , in def minInitialPoints ( points ) :				    def min_initial_points ( points , R , C ) :			  script_not_found : None
  int dp [ ] [ ] = new int [ R ] [ C ] ;		      	  dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R  	dp = np.zeros ( ( R , C ) )				  
  int m = R , n = C ;					      	  m , n = R , C						    	m , n = R , C						  
  dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 	  if points [ m - 1 ] [ n - 1 ] > 0 :			    	dp [ m - 1 ] [ n - 1 ] = 1 if points [ m - 1 ] [ n - 1 ]  
  for ( int i = m - 2 ;					      	      dp [ m - 1 ] [ n - 1 ] = 1			    	for i in range ( m - 2 , - 1 , - 1 ) :			  
  i >= 0 ;						      	  else :						    	    dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - p 
  i -- ) dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 	      dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 	for j in range ( n - 2 , - 1 , - 1 ) :			  
  for ( int j = n - 2 ;					      	  for i in range ( m - 2 , - 1 , - 1 ) :		    	    dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] - p 
  j >= 0 ;						      	      dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - p 	for i in range ( m - 2 , - 1 , - 1 ) :			  
  j -- ) dp [ m - 1 ] [ j ] = Math . max ( dp [ m - 1 ] [ j + 	  for i in range ( 2 , - 1 , - 1 ) :			    	    for j in range ( n - 2 , - 1 , - 1 ) :		  
  for ( int i = m - 2 ;					      	      dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - p 		min_points_on_exit = min ( dp [ i + 1 ] [ j ] , d 
  i >= 0 ;						      	  for i in range ( m - 2 , - 1 , - 1 ) :		    		dp [ i ] [ j ] = max ( min_points_on_exit - point 
  i -- ) {						      	      for j in range ( n - 2 , - 1 , - 1 ) :		    	return dp [ 0 ] [ 0 ]					  
    for ( int j = n - 2 ;				      		  min_points_on_exit = min ( dp [ i + 1 ] [ j ] , d 								  
    j >= 0 ;						      		  dp [ i ] [ j ] = max ( min_points_on_exit - point 								  
    j -- ) {						      	  return dp [ 0 ] [ 0 ]					    								  
      int min_points_on_exit = Math . min ( dp [ i + 1 ] [ j  								    								  
      dp [ i ] [ j ] = Math . max ( min_points_on_exit - poin 								    								  
    }							      								    								  
  }							      								    								  
  return dp [ 0 ] [ 0 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PALINDROME_SUB_STRINGS_STRING			      COUNT_PALINDROME_SUB_STRINGS_STRING			    COUNT_PALINDROME_SUB_STRINGS_STRING				  COUNT_PALINDROME_SUB_STRINGS_STRING
--							      --							    --								  --
static int CountPS ( char str [ ] , int n ) {		      def CountPS ( str , n ) :					    def CountPS ( str , n ) :					  success : None
  int dp [ ] [ ] = new int [ n ] [ n ] ;		      	  dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]  	dp = np.zeros ( ( n , n ) )				  
  boolean P [ ] [ ] = new boolean [ n ] [ n ] ;		      	  P = [ [ False for x in range ( n ) ] for y in range ( n ) 	P = np.zeros ( ( n , n ) )				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      P [ i ] [ i ] = True				    	    P [ i ] [ i ] = True				  
  i ++ ) P [ i ] [ i ] = true ;				      	  for i in range ( n - 1 ) :				    	for i in range ( n - 1 ) :				  
  for ( int i = 0 ;					      	      if ( str [ i ] == str [ i + 1 ] ) :		    	    if str [ i ] == str [ i + 1 ] :			  
  i < n - 1 ;						      		  P [ i ] [ i + 1 ] = True			    		P [ i ] [ i + 1 ] = True			  
  i ++ ) {						      		  dp [ i ] [ i + 1 ] = 1			    		dp [ i ] [ i + 1 ] = 1				  
    if ( str [ i ] == str [ i + 1 ] ) {			      	  for gap in range ( 2 , n ) :				    	for gap in range ( 2 , n ) :				  
      P [ i ] [ i + 1 ] = true ;			      	      for i in range ( n - gap ) :			    	    for i in range ( n - gap ) :			  
      dp [ i ] [ i + 1 ] = 1 ;				      		  j = gap + i ;					    		j = gap + i					  
    }							      		  if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 		if str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 
  }							      		      P [ i ] [ j ] = True			    		    P [ i ] [ j ] = True			  
  for ( int gap = 2 ;					      		  if ( P [ i ] [ j ] == True ) :		    		if P [ i ] [ j ] == True :			  
  gap < n ;						      		      dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [  		    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i  
  gap ++ ) {						      		  else :					    		else :						  
    for ( int i = 0 ;					      		      dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [  		    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i  
    i < n - gap ;					      	  return dp [ 0 ] [ n - 1 ]				    	return dp [ 0 ] [ n - 1 ]				  
    i ++ ) {						      								    								  
      int j = gap + i ;					      								    								  
      if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] )  								    								  
      if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ]  								    								  
      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] 								    								  
    }							      								    								  
  }							      								    								  
  return dp [ 0 ] [ n - 1 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1     RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1	    RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1	  RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1
--							      --							    --								  --
static void maxProduct ( int arr [ ] , int n ) {	      def maxProduct ( arr , n ) :				    def max_product ( arr , n ) :				  script_not_found : None
  if ( n < 2 ) {					      	  if ( n < 2 ) :					    	if n < 2 :						  
    System . out . println ( "No pairs exists" ) ;	      	      print ( "No pairs exists" )			    	    print ( 'No pairs exists' )				  
    return ;						      	      return						    	    return						  
  }							      	  if ( n == 2 ) :					    	if n == 2 :						  
  if ( n == 2 ) {					      	      print ( arr [ 0 ] , " " , arr [ 1 ] )		    	    print ( arr [ 0 ] , arr [ 1 ] )			  
    System . out . println ( arr [ 0 ] + " " + arr [ 1 ] ) ;  	      return						    	    return						  
    return ;						      	  posa = 0						    	posa , posb = int ( 0 ) , int ( 0 )			  
  }							      	  posb = 0						    	nega , negb = int ( 0 ) , int ( 0 )			  
  int posa = Integer . MIN_VALUE , posb = Integer . MIN_VALUE 	  nega = 0						    	for i in range ( n ) :					  
  int nega = Integer . MIN_VALUE , negb = Integer . MIN_VALUE 	  negb = 0						    	    if arr [ i ] > posa :				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    		posb = posa					  
  i < n ;						      	      if ( arr [ i ] > posa ) :				    		posa = arr [ i ]				  
  i ++ ) {						      		  posb = posa					    	    elif arr [ i ] > posb :				  
    if ( arr [ i ] > posa ) {				      		  posa = arr [ i ]				    		posb = arr [ i ]				  
      posb = posa ;					      	      elif ( arr [ i ] > posb ) :			    	    if arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega ) 
      posa = arr [ i ] ;				      		  posb = arr [ i ]				    		negb = nega					  
    }							      	      if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega 		nega = arr [ i ]				  
    else if ( arr [ i ] > posb ) posb = arr [ i ] ;	      		  negb = nega					    	    elif arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( negb 
    if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . a 		  nega = arr [ i ]				    		negb = arr [ i ]				  
      negb = nega ;					      	      elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( ne 	if nega * negb > posa * posb :				  
      nega = arr [ i ] ;				      		  negb = arr [ i ]				    	    print ( 'Max product pair is {%d, %d}' % ( nega , neg 
    }							      	  if ( nega * negb > posa * posb ) :			    	else :							  
    else if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Mat 	      print ( "Max product pair is {" , nega , ", " , negb  	    print ( 'Max product pair is {%d, %d}' % ( posa , pos 
  }							      	  else :						    								  
  if ( nega * negb > posa * posb ) System . out . println ( " 	      print ( "Max product pair is {" , posa , ", " , posb  								  
  else System . out . println ( "Max product pair is {" + pos 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING	      DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING	    DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING		  DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING
--							      --							    --								  --
static int minPalPartion ( String str ) {		      def minPalPartion ( str ) :				    def min_palpartion ( data ) :				  success : None
  int n = str . length ( ) ;				      	  n = len ( str )					    	n = len ( data )					  
  int [ ] [ ] C = new int [ n ] [ n ] ;			      	  C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]   	C = np.zeros ( ( n , n ) )				  
  boolean [ ] [ ] P = new boolean [ n ] [ n ] ;		      	  P = [ [ False for i in range ( n ) ] for i in range ( n ) 	P = np.zeros ( ( n , n ) )				  
  int i , j , k , L ;					      	  j = 0							    	i , j , k , L = 0 , 0 , 0 , 0				  
  for ( i = 0 ;						      	  k = 0							    	for i in range ( n ) :					  
  i < n ;						      	  L = 0							    	    P [ i ] [ i ] = True				  
  i ++ ) {						      	  for i in range ( n ) :				    	    C [ i ] [ i ] = 0					  
    P [ i ] [ i ] = true ;				      	      P [ i ] [ i ] = True				    	for L in range ( 2 , n + 1 ) :				  
    C [ i ] [ i ] = 0 ;					      	      C [ i ] [ i ] = 0					    	    for i in range ( n - L + 1 ) :			  
  }							      	  for L in range ( 2 , n + 1 ) :			    		j = i + L - 1					  
  for ( L = 2 ;						      	      for i in range ( n - L + 1 ) :			    		if L == 2 :					  
  L <= n ;						      		  j = i + L - 1					    		    P [ i ] [ j ] = ( data [ i ] == data [ j ] )  
  L ++ ) {						      		  if L == 2 :					    		else :						  
    for ( i = 0 ;					      		      P [ i ] [ j ] = ( str [ i ] == str [ j ] )    		    P [ i ] [ j ] = ( data [ i ] == data [ j ] )  
    i < n - L + 1 ;					      		  else :					    		if P [ i ] [ j ] == True :			  
    i ++ ) {						      		      P [ i ] [ j ] = ( ( str [ i ] == str [ j ] )  		    C [ i ] [ j ] = 0				  
      j = i + L - 1 ;					      		  if P [ i ] [ j ] == True :			    		else :						  
      if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == s 		      C [ i ] [ j ] = 0				    		    C [ i ] [ j ] = np.inf			  
      else P [ i ] [ j ] = ( str . charAt ( i ) == str . char 		  else :					    		    for k in range ( i , j - 1 + 1 ) :		  
      if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ;	      		      C [ i ] [ j ] = 100000000			    			C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ 
      else {						      		      for k in range ( i , j ) :		    	return C [ 0 ] [ n - 1 ]				  
	C [ i ] [ j ] = Integer . MAX_VALUE ;		      			  C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ 								  
	for ( k = i ;					      	  return C [ 0 ] [ n - 1 ]				    								  
	k <= j - 1 ;					      								    								  
	k ++ ) C [ i ] [ j ] = Integer . min ( C [ i ] [ j ]  								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return C [ 0 ] [ n - 1 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP
--							      --							    --								  --
static void printUnsorted ( int arr [ ] , int n ) {	      def printUnsorted ( arr , n ) :				    def print_unsorted ( arr , n ) :				  script_not_found : None
  int s = 0 , e = n - 1 , i , max , min ;		      	  e = n - 1						    	s , e = 0 , n - 1 , i , max , min = 0 , 0 , 0 , 0	  
  for ( s = 0 ;						      	  for s in range ( 0 , n - 1 ) :			    	for s in range ( n - 1 ) :				  
  s < n - 1 ;						      	      if arr [ s ] > arr [ s + 1 ] :			    	    if arr [ s ] > arr [ s + 1 ] :			  
  s ++ ) {						      		  break						    		break						  
    if ( arr [ s ] > arr [ s + 1 ] ) break ;		      	  if s == n - 1 :					    	if s == n - 1 :						  
  }							      	      print ( "The complete array is sorted" )		    	    print ( "The complete array is sorted" )		  
  if ( s == n - 1 ) {					      	      exit ( )						    	    return						  
    System . out . println ( "The complete array is sorted" ) 	  e = n - 1						    	for e in range ( n - 1 , 0 , - 1 ) :			  
    return ;						      	  while e > 0 :						    	    if arr [ e ] < arr [ e - 1 ] :			  
  }							      	      if arr [ e ] < arr [ e - 1 ] :			    		break						  
  for ( e = n - 1 ;					      		  break						    	max = arr [ s ]						  
  e > 0 ;						      	      e -= 1						    	min = arr [ s ]						  
  e -- ) {						      	  max = arr [ s ]					    	for i in range ( s + 1 , e + 1 ) :			  
    if ( arr [ e ] < arr [ e - 1 ] ) break ;		      	  min = arr [ s ]					    	    if arr [ i ] > max :				  
  }							      	  for i in range ( s + 1 , e + 1 ) :			    		max = arr [ i ]					  
  max = arr [ s ] ;					      	      if arr [ i ] > max :				    	    if arr [ i ] < min :				  
  min = arr [ s ] ;					      		  max = arr [ i ]				    		min = arr [ i ]					  
  for ( i = s + 1 ;					      	      if arr [ i ] < min :				    	for i in range ( s ) :					  
  i <= e ;						      		  min = arr [ i ]				    	    if arr [ i ] > min :				  
  i ++ ) {						      	  for i in range ( s ) :				    		s = i						  
    if ( arr [ i ] > max ) max = arr [ i ] ;		      	      if arr [ i ] > min :				    		break						  
    if ( arr [ i ] < min ) min = arr [ i ] ;		      		  s = i						    	for i in range ( n - 1 , e + 1 , - 1 ) :		  
  }							      		  break						    	    if arr [ i ] < max :				  
  for ( i = 0 ;						      	  i = n - 1						    		e = i						  
  i < s ;						      	  while i >= e + 1 :					    		break						  
  i ++ ) {						      	      if arr [ i ] < max :				    	print ( " The unsorted subarray which" " makes the given  
    if ( arr [ i ] > min ) {				      		  e = i						    	return							  
      s = i ;						      		  break						    								  
      break ;						      	      i -= 1						    								  
    }							      	  print ( "The unsorted subarray which makes the given arra 								  
  }							      	  print ( "sorted lies between the indexes %d and %d" % ( s 								  
  for ( i = n - 1 ;					      								    								  
  i >= e + 1 ;						      								    								  
  i -- ) {						      								    								  
    if ( arr [ i ] < max ) {				      								    								  
      e = i ;						      								    								  
      break ;						      								    								  
    }							      								    								  
  }							      								    								  
  System . out . println ( " The unsorted subarray which" + " 								    								  
  return ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERIAN_PATH_UNDIRECTED_GRAPH				      EULERIAN_PATH_UNDIRECTED_GRAPH				    EULERIAN_PATH_UNDIRECTED_GRAPH				  EULERIAN_PATH_UNDIRECTED_GRAPH
--							      --							    --								  --
static void findpath ( int [ ] [ ] graph , int n ) {	      def findpath ( graph ) :					    def findpath ( graph , n ) :				  script_not_found : None
  Vector < Integer > numofadj = new Vector < > ( ) ;	      	  n = len ( graph )					    	numofadj = [ ]						  
  for ( int i = 0 ;					      	  numofadj = list ( )					    	for i in range ( n ) :					  
  i < n ;						      	  for i in range ( n ) :				    	    numofadj.append ( accumulate ( graph [ i ] , 0 ) )	  
  i ++ ) numofadj . add ( accumulate ( graph [ i ] , 0 ) ) ;  	      numofadj.append ( sum ( graph [ i ] ) )		    	startPoint , numofodd = 0 , 0				  
  int startPoint = 0 , numofodd = 0 ;			      	  startpoint = 0					    	for i in range ( n - 1 , - 1 , - 1 ) :			  
  for ( int i = n - 1 ;					      	  numofodd = 0						    	    if numofadj [ i ] % 2 == 1 :			  
  i >= 0 ;						      	  for i in range ( n - 1 , - 1 , - 1 ) :		    		numofodd += 1					  
  i -- ) {						      	      if ( numofadj [ i ] % 2 == 1 ) :			    		startPoint = i					  
    if ( numofadj . elementAt ( i ) % 2 == 1 ) {	      		  numofodd += 1					    	if numofodd > 2 :					  
      numofodd ++ ;					      		  startpoint = i				    	    print ( "No Solution" )				  
      startPoint = i ;					      	  if ( numofodd > 2 ) :					    	    return						  
    }							      	      print ( "No Solution" )				    	stack = [ ]						  
  }							      	      return						    	path = [ ]						  
  if ( numofodd > 2 ) {					      	  stack = list ( )					    	cur = startPoint					  
    System . out . println ( "No Solution" ) ;		      	  path = list ( )					    	while not stack or accumulate ( graph [ cur ] , 0 ) != 0  
    return ;						      	  cur = startpoint					    	    if accumulate ( graph [ cur ] , 0 ) == 0 :		  
  }							      	  while ( stack != [ ] or sum ( graph [ cur ] ) != 0 ) :    		path.append ( cur )				  
  Stack < Integer > stack = new Stack < > ( ) ;		      	      if ( sum ( graph [ cur ] ) == 0 ) :		    		cur = stack.pop ( )				  
  Vector < Integer > path = new Vector < > ( ) ;	      		  path.append ( cur + 1 )			    	    else :						  
  int cur = startPoint ;				      		  cur = stack.pop ( - 1 )			    		for i in range ( n ) :				  
  while ( ! stack . isEmpty ( ) || accumulate ( graph [ cur ] 	      else :						    		    if graph [ cur ] [ i ] == 1 :		  
    if ( accumulate ( graph [ cur ] , 0 ) == 0 ) {	      		  for i in range ( n ) :			    			stack.append ( cur )			  
      path . add ( cur ) ;				      		      if graph [ cur ] [ i ] == 1 :		    			graph [ cur ] [ i ] = 0			  
      cur = stack . pop ( ) ;				      			  stack.append ( cur )			    			graph [ i ] [ cur ] = 0			  
    }							      			  graph [ cur ] [ i ] = 0		    			cur = i					  
    else {						      			  graph [ i ] [ cur ] = 0		    			break					  
      for ( int i = 0 ;					      			  cur = i				    	for ele in path :					  
      i < n ;						      			  break					    	    print ( "%d -> " % ele , end = ' ' )		  
      i ++ ) {						      	  for ele in path :					    	print ( cur )						  
	if ( graph [ cur ] [ i ] == 1 ) {		      	      print ( ele , "-> " , end = '' )			    								  
	  stack . add ( cur ) ;				      	  print ( cur + 1 )					    								  
	  graph [ cur ] [ i ] = 0 ;			      								    								  
	  graph [ i ] [ cur ] = 0 ;			      								    								  
	  cur = i ;					      								    								  
	  break ;					      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  for ( int ele : path ) System . out . print ( ele + " -> "  								    								  
  System . out . println ( cur ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG		      MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG		    MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG			  MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG
--							      --							    --								  --
public static int MinimumCost ( int cost [ ] , int n , int W  def MinimumCost ( cost , n , W ) :			    def MinimumCost ( cost , n , W ) :				  script_not_found : None
  Vector < Integer > val = new Vector < Integer > ( ) ;	      	  val = list ( )					    	val = [ ]						  
  Vector < Integer > wt = new Vector < Integer > ( ) ;	      	  wt = list ( )						    	wt = [ ]						  
  int size = 0 ;					      	  size = 0						    	size = 0						  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( cost [ i ] != - 1 ) :			    	    if cost [ i ] != - 1 :				  
  i ++ ) {						      		  val.append ( cost [ i ] )			    		val.append ( cost [ i ] )			  
    if ( cost [ i ] != - 1 ) {				      		  wt.append ( i + 1 )				    		wt.append ( i + 1 )				  
      val . add ( cost [ i ] ) ;			      		  size += 1					    		size += 1					  
      wt . add ( i + 1 ) ;				      	  n = size						    	n = size						  
      size ++ ;						      	  min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in rang 	min_cost = np.zeros ( ( n + 1 , W + 1 ) )		  
    }							      	  for i in range ( W + 1 ) :				    	for i in range ( 0 , W + 1 ) :				  
  }							      	      min_cost [ 0 ] [ i ] = INF			    	    min_cost [ 0 ] [ i ] = np.inf			  
  n = size ;						      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  int min_cost [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;	      	      min_cost [ i ] [ 0 ] = 0				    	    min_cost [ i ] [ 0 ] = 0				  
  for ( int i = 0 ;					      	  for i in range ( 1 , n + 1 ) :			    	for i in range ( 1 , n + 1 ) :				  
  i <= W ;						      	      for j in range ( 1 , W + 1 ) :			    	    for j in range ( 1 , W + 1 ) :			  
  i ++ ) min_cost [ 0 ] [ i ] = Integer . MAX_VALUE ;	      		  if ( wt [ i - 1 ] > j ) :			    		if wt [ i - 1 ] > j :				  
  for ( int i = 1 ;					      		      min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j 		    min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j 
  i <= n ;						      		  else :					    		else :						  
  i ++ ) min_cost [ i ] [ 0 ] = 0 ;			      		      min_cost [ i ] [ j ] = min ( min_cost [ i - 1 		    min_cost [ i ] [ j ] = min ( min_cost [ i - 1 
  for ( int i = 1 ;					      	  if ( min_cost [ n ] [ W ] == INF ) :			    	return ( - 1 if min_cost [ n ] [ W ] == np.inf else min_c 
  i <= n ;						      	      return - 1					    								  
  i ++ ) {						      	  else :						    								  
    for ( int j = 1 ;					      	      return min_cost [ n ] [ W ]			    								  
    j <= W ;						      								    								  
    j ++ ) {						      								    								  
      if ( wt . get ( i - 1 ) > j ) min_cost [ i ] [ j ] = mi 								    								  
      else min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 								    								  
    }							      								    								  
  }							      								    								  
  return ( min_cost [ n ] [ W ] == Integer . MAX_VALUE ) ? -  								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS	      REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS	    REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS	  REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS
--							      --							    --								  --
static String simplify ( String str ) {			      def simplify ( Str ) :					    def simplify ( data ) :					  error : Traceback (most recent call last):   File
  int len = str . length ( ) ;				      	  Len = len ( Str )					    	data = list ( data )					  "dump/transcoder_st/eval/java_python/online_st/206
  char res [ ] = new char [ len ] ;			      	  res = [ None ] * Len					    	res = [ ]						  68770/eval_scripts/java_sa-python_sa.test/REMOVE_B
  int index = 0 , i = 0 ;				      	  index = 0						    	index , i = 0 , 0					  RACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS.py",
  Stack < Integer > s = new Stack < Integer > ( ) ;	      	  i = 0							    	s = [ 0 ] * data					   line 99, in <module>	    if f_filled(*parameters_
  s . push ( 0 ) ;					      	  s = [ ]						    	while i < len ( data ) :				  set) == f_gold(*parameters_set):   File "dump/tran
  while ( i < len ) {					      	  s.append ( 0 )					    	    if data [ i ] == '+' :				  scoder_st/eval/java_python/online_st/20668770/eval
    if ( str . charAt ( i ) == '+' ) {			      	  while ( i < Len ) :					    		if s [ - 1 ] == 1 :				  _scripts/java_sa-python_sa.test/REMOVE_BRACKETS_AL
      if ( s . peek ( ) == 1 ) res [ index ++ ] = '-' ;	      	      if ( Str [ i ] == '+' ) :				    		    res [ index ] = '-'				  GEBRAIC_STRING_CONTAINING_OPERATORS.py", line 58,
      if ( s . peek ( ) == 0 ) res [ index ++ ] = '+' ;	      		  if ( s [ - 1 ] == 1 ) :			    		if s [ - 1 ] == 0 :				  in f_filled	  s = [ 0 ] * data TypeError: can't
    }							      		      res [ index ] = '-'			    		    res [ index ] = '+'				  multiply sequence by non-int of type 'list'
    else if ( str . charAt ( i ) == '-' ) {		      		      index += 1				    	    elif data [ i ] == '-' :				  
      if ( s . peek ( ) == 1 ) res [ index ++ ] = '+' ;	      		  if ( s [ - 1 ] == 0 ) :			    		if s [ - 1 ] == 1 :				  
      else if ( s . peek ( ) == 0 ) res [ index ++ ] = '-' ;  		      res [ index ] = '+'			    		    res [ index ] = '+'				  
    }							      		      index += 1				    		elif s [ - 1 ] == 0 :				  
    else if ( str . charAt ( i ) == '(' && i > 0 ) {	      	      elif ( Str [ i ] == '-' ) :			    		    res [ index ] = '-'				  
      if ( str . charAt ( i - 1 ) == '-' ) {		      		  if ( s [ - 1 ] == 1 ) :			    	    elif data [ i ] == '(' and i > 0 :			  
	int x = ( s . peek ( ) == 1 ) ? 0 : 1 ;		      		      res [ index ] = '+'			    		if data [ i - 1 ] == '-' :			  
	s . push ( x ) ;				      		      index += 1				    		    x = ( 0 if s [ - 1 ] == 1 else 1 )		  
      }							      		  elif ( s [ - 1 ] == 0 ) :			    		    s.append ( x )				  
      else if ( str . charAt ( i - 1 ) == '+' ) s . push ( s  		      res [ index ] = '-'			    		elif data [ i - 1 ] == '+' :			  
    }							      		      index += 1				    		    s.append ( s [ - 1 ] )			  
    else if ( str . charAt ( i ) == ')' ) s . pop ( ) ;	      	      elif ( Str [ i ] == '(' and i > 0 ) :		    	    elif data [ i ] == ')' :				  
    else res [ index ++ ] = str . charAt ( i ) ;	      		  if ( Str [ i - 1 ] == '-' ) :			    		s.pop ( )					  
    i ++ ;						      		      x = 0 if ( s [ - 1 ] == 1 ) else 1	    	    else :						  
  }							      		      s.append ( x )				    		res [ index ] = data [ i ]			  
  return new String ( res ) ;				      		  elif ( Str [ i - 1 ] == '+' ) :		    	    i += 1						  
}							      		      s.append ( s [ - 1 ] )			    	return ''.join ( res )					  
							      	      elif ( Str [ i ] == ')' ) :			    								  
							      		  s.pop ( )					    								  
							      	      else :						    								  
							      		  res [ index ] = Str [ i ]			    								  
							      		  index += 1					    								  
							      	      i += 1						    								  
							      	  return res						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS		      MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS			    MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS			  MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS
--							      --							    --								  --
static String maximumPalinUsingKChanges ( String str , int k  def maximumPalinUsingKChanges ( strr , k ) :		    def maximum_palin_using_k_changes ( str , k ) :		  script_not_found : None
  char palin [ ] = str . toCharArray ( ) ;		      	  palin = strr						    	palin = list ( str )					  
  String ans = "" ;					      	  l = 0							    	ans = ""						  
  int l = 0 ;						      	  r = len ( strr ) - 1					    	l = 0							  
  int r = str . length ( ) - 1 ;			      	  while ( l <= r ) :					    	r = len ( str ) - 1					  
  while ( l < r ) {					      	      if ( strr [ l ] != strr [ r ] ) :			    	while l < r :						  
    if ( str . charAt ( l ) != str . charAt ( r ) ) {	      		  palin [ l ] = palin [ r ] = max ( strr [ l ] , st 	    if str [ l ] != str [ r ] :				  
      palin [ l ] = palin [ r ] = ( char ) Math . max ( str . 		  k -= 1					    		palin [ l ] = palin [ r ] = chr ( max ( str [ l ] 
      k -- ;						      	      l += 1						    		k -= 1						  
    }							      	      r -= 1						    	    l += 1						  
    l ++ ;						      	  if ( k < 0 ) :					    	    r -= 1						  
    r -- ;						      	      return "Not possible"				    	if k < 0 :						  
  }							      	  l = 0							    	    return "Not possible"				  
  if ( k < 0 ) {					      	  r = len ( strr ) - 1					    	l = 0							  
    return "Not possible" ;				      	  while ( l <= r ) :					    	r = len ( str ) - 1					  
  }							      	      if ( l == r ) :					    	while l <= r :						  
  l = 0 ;						      		  if ( k > 0 ) :				    	    if l == r :						  
  r = str . length ( ) - 1 ;				      		      palin [ l ] = '9'				    		if k > 0 :					  
  while ( l <= r ) {					      	      if ( palin [ l ] < '9' ) :			    		    palin [ l ] = '9'				  
    if ( l == r ) {					      		  if ( k >= 2 and palin [ l ] == strr [ l ] and pal 	    if palin [ l ] < '9' :				  
      if ( k > 0 ) {					      		      k -= 1					    		if k >= 2 and palin [ l ] == str [ l ] and palin  
	palin [ l ] = '9' ;				      		      palin [ l ] = palin [ r ] = '9'		    		    k -= 2					  
      }							      		  elif ( k >= 1 and ( palin [ l ] != strr [ l ] or  		    palin [ l ] = palin [ r ] = '9'		  
    }							      		      k -= 1					    		elif k >= 1 and ( palin [ l ] != str [ l ] or pal 
    if ( palin [ l ] < '9' ) {				      		      palin [ l ] = palin [ r ] = '9'		    		    k -= 1					  
      if ( k >= 2 && palin [ l ] == str . charAt ( l ) && pal 	      l += 1						    		    palin [ l ] = palin [ r ] = '9'		  
	k -= 2 ;					      	      r -= 1						    	    l += 1						  
	palin [ l ] = palin [ r ] = '9' ;		      	  return palin						    	    r -= 1						  
      }							      								    	for i in range ( len ( palin ) ) :			  
      else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) 								    	    ans += palin [ i ]					  
	k -- ;						      								    	return ans						  
	palin [ l ] = palin [ r ] = '9' ;		      								    								  
      }							      								    								  
    }							      								    								  
    l ++ ;						      								    								  
    r -- ;						      								    								  
  }							      								    								  
  for ( int i = 0 ;					      								    								  
  i < palin . length ;					      								    								  
  i ++ ) ans += palin [ i ] ;				      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L		      MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L		    MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L		  MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L
--							      --							    --								  --
static int findMaxValue ( int [ ] arr , int n ) {	      def findMaxValue ( arr , n ) :				    def find_max_value ( arr , n ) :				  script_not_found : None
  if ( n < 4 ) {					      	  if n < 4 :						    	if n < 4 :						  
    System . out . println ( "The array should have" + " atle 	      print ( "The array should have atlest 4 elements" )   	    print ( "The array should have" " atleast 4 elements" 
  }							      	      return MIN					    	table1 = [ 0 ] * ( n + 1 )				  
  int table1 [ ] = new int [ n + 1 ] ;			      	  table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n	    	table2 = [ 0 ] * ( n )					  
  int table2 [ ] = new int [ n ] ;			      	  table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 	table3 = [ 0 ] * ( n - 1 )				  
  int table3 [ ] = new int [ n - 1 ] ;			      	  for i in range ( n - 1 , - 1 , - 1 ) :		    	table4 = [ 0 ] * ( n - 2 )				  
  int table4 [ ] = new int [ n - 2 ] ;			      	      table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] )   	table1 [ n - 1 ] = max ( table1 [ n - 1 ] , arr [ n - 1 ] 
  Arrays . fill ( table1 , Integer . MIN_VALUE ) ;	      	  for i in range ( n - 2 , - 1 , - 1 ) :		    	table2 [ n - 2 ] = max ( table2 [ n - 2 ] , table1 [ n -  
  Arrays . fill ( table2 , Integer . MIN_VALUE ) ;	      	      table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i +  	table3 [ n - 3 ] = max ( table3 [ n - 1 ] , table2 [ n -  
  Arrays . fill ( table3 , Integer . MIN_VALUE ) ;	      	  for i in range ( n - 3 , - 1 , - 1 ) :		    	table4 [ n - 4 ] = max ( table4 [ n - 4 ] , table3 [ n -  
  Arrays . fill ( table4 , Integer . MIN_VALUE ) ;	      	      table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i +  	return table4 [ 0 ]					  
  for ( int i = n - 1 ;					      	  for i in range ( n - 4 , - 1 , - 1 ) :		    								  
  i >= 0 ;						      	      table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i +  								  
  i -- ) {						      	  return table4 [ 0 ]					    								  
    table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ]  								    								  
  }							      								    								  
  for ( int i = n - 2 ;					      								    								  
  i >= 0 ;						      								    								  
  i -- ) {						      								    								  
    table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i 								    								  
  }							      								    								  
  for ( int i = n - 3 ;					      								    								  
  i >= 0 ;						      								    								  
  i -- ) table3 [ i ] = Math . max ( table3 [ i + 1 ] , table 								    								  
  for ( int i = n - 4 ;					      								    								  
  i >= 0 ;						      								    								  
  i -- ) table4 [ i ] = Math . max ( table4 [ i + 1 ] , table 								    								  
  return table4 [ 0 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K		      SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K		    SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K		  SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K
--							      --							    --								  --
public static int SumOfKsubArray ( int arr [ ] , int k ) {    def SumOfKsubArray ( arr , n , k ) :			    def SumOfKsubArray ( arr , k ) :				  script_not_found : None
  int sum = 0 ;						      	  Sum = 0						    	sum = 0							  
  Deque < Integer > S = new LinkedList < > ( ) , G = new Link 	  S = deque ( )						    	S , G = list ( arr ) , list ( arr )			  
  int i = 0 ;						      	  G = deque ( )						    	i = 0							  
  for ( i = 0 ;						      	  for i in range ( k ) :				    	for i in range ( k ) :					  
  i < k ;						      	      while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [  	    while not S and arr [ S.pop ( ) ] >= arr [ i ] :	  
  i ++ ) {						      		  S.pop ( )					    		S.pop ( )					  
    while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >=  	      while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [  	    while not G and arr [ G.pop ( ) ] <= arr [ i ] :	  
    while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <=  		  G.pop ( )					    		G.pop ( )					  
    G . addLast ( i ) ;					      	      G.append ( i )					    	    G.append ( i )					  
    S . addLast ( i ) ;					      	      S.append ( i )					    	    S.append ( i )					  
  }							      	  for i in range ( k , n ) :				    	for i in range ( len ( arr ) ) :			  
  for ( ;						      	      Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ]		    	    sum += arr [ S.pop ( ) ] + arr [ G.pop ( ) ]	  
  i < arr . length ;					      	      while ( len ( S ) > 0 and S [ 0 ] <= i - k ) :	    	    while not S and S.pop ( ) <= i - k :		  
  i ++ ) {						      		  S.popleft ( )					    		S.pop ( )					  
    sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst (  	      while ( len ( G ) > 0 and G [ 0 ] <= i - k ) :	    	    while not G and G.pop ( ) <= i - k :		  
    while ( ! S . isEmpty ( ) && S . peekFirst ( ) <= i - k ) 		  G.popleft ( )					    		G.pop ( )					  
    while ( ! G . isEmpty ( ) && G . peekFirst ( ) <= i - k ) 	      while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [  	    while not S and arr [ S.pop ( ) ] >= arr [ i ] :	  
    while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >=  		  S.pop ( )					    		S.pop ( )					  
    while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <=  	      while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [  	    while not G and arr [ G.pop ( ) ] <= arr [ i ] :	  
    G . addLast ( i ) ;					      		  G.pop ( )					    		G.pop ( )					  
    S . addLast ( i ) ;					      	      G.append ( i )					    	    G.append ( i )					  
  }							      	      S.append ( i )					    	    S.append ( i )					  
  sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( )  	  Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ]		    	sum += arr [ S.pop ( ) ] + arr [ G.pop ( ) ]		  
  return sum ;						      	  return Sum						    	return sum						  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS		      POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS		    POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS			  POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS
--							      --							    --								  --
static void pointClip ( int XY [ ] [ ] , int n , int Xmin , i def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) :	    def point_clip ( XY , n , Xmin , Ymin , Xmax , Ymax ) :	  success : None
  System . out . printf ( "Point inside the viewing pane:\n"  	  print ( "Point inside the viewing pane:" )		    	print ( "Point inside the viewing pane:\n" )		  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ]  	    if ( XY [ i ] [ 0 ] >= Xmin and XY [ i ] [ 0 ] <= Xma 
  i ++ ) {						      		  if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [  		if ( XY [ i ] [ 1 ] >= Ymin and XY [ i ] [ 1 ] <= 
    if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xm 		      print ( "[" , XY [ i ] [ 0 ] , ", " , XY [ i  		    print ( "[%d, %d] " % ( XY [ i ] [ 0 ] , XY [ 
      if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <=  	  print ( "\n\nPoint outside the viewing pane:" )	    	print ( "\nPoint outside the viewing pane:\n" )		  
    }							      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  }							      	      if ( ( XY [ i ] [ 0 ] < Xmin ) or ( XY [ i ] [ 0 ] >  	    if ( XY [ i ] [ 0 ] < Xmin or XY [ i ] [ 0 ] > Xmax ) 
  System . out . printf ( "\nPoint outside the viewing pane:\ 		  print ( "[" , XY [ i ] [ 0 ] , ", " , XY [ i ] [  		print ( "[%d, %d] " % ( XY [ i ] [ 0 ] , XY [ i ] 
  for ( int i = 0 ;					      	      if ( ( XY [ i ] [ 1 ] < Ymin ) or ( XY [ i ] [ 1 ] >  	    if ( XY [ i ] [ 1 ] < Ymin or XY [ i ] [ 1 ] > Ymax ) 
  i < n ;						      		  print ( "[" , XY [ i ] [ 0 ] , ", " , XY [ i ] [  		print ( "[%d, %d] " % ( XY [ i ] [ 0 ] , XY [ i ] 
  i ++ ) {						      								    								  
    if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax 								    								  
    if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax 								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ROTATIONS_DIVISIBLE_8				      COUNT_ROTATIONS_DIVISIBLE_8				    COUNT_ROTATIONS_DIVISIBLE_8					  COUNT_ROTATIONS_DIVISIBLE_8
--							      --							    --								  --
static int countRotationsDivBy8 ( String n ) {		      def countRotationsDivBy8 ( n ) :				    def count_rotations_div_by_8 ( n ) :			  script_not_found : None
  int len = n . length ( ) ;				      	  l = len ( n )						    	n = list ( n )						  
  int count = 0 ;					      	  count = 0						    	count = 0						  
  if ( len == 1 ) {					      	  if ( l == 1 ) :					    	if len ( n ) == 1 :					  
    int oneDigit = n . charAt ( 0 ) - '0' ;		      	      oneDigit = int ( n [ 0 ] )			    	    one_digit = ord ( n [ 0 ] ) - ord ( '0' )		  
    if ( oneDigit % 8 == 0 ) return 1 ;			      	      if ( oneDigit % 8 == 0 ) :			    	    if one_digit % 8 == 0 :				  
    return 0 ;						      		  return 1					    		return 1					  
  }							      	      return 0						    	    return 0						  
  if ( len == 2 ) {					      	  if ( l == 2 ) :					    	if len ( n ) == 2 :					  
    int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charA 	      first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] )	    	    first = ( ord ( n [ 0 ] ) - ord ( '0' ) ) * 10 + ( or 
    int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . char 	      second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] )	    	    second = ( ord ( n [ 1 ] ) - ord ( '0' ) ) * 10 + ( o 
    if ( first % 8 == 0 ) count ++ ;			      	      if ( first % 8 == 0 ) :				    	    if first % 8 == 0 :					  
    if ( second % 8 == 0 ) count ++ ;			      		  count += 1					    		count += 1					  
    return count ;					      	      if ( second % 8 == 0 ) :				    	    if second % 8 == 0 :				  
  }							      		  count += 1					    		count += 1					  
  int threeDigit ;					      	      return count					    	    return count					  
  for ( int i = 0 ;					      	  threeDigit = 0					    	three_digit = 0						  
  i < ( len - 2 ) ;					      	  for i in range ( 0 , ( l - 2 ) ) :			    	for i in range ( ( len ( n ) - 2 ) ) :			  
  i ++ ) {						      	      threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i +  	    three_digit = ( ord ( n [ i ] ) - ord ( '0' ) ) * 100 
    threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . cha 	      if ( threeDigit % 8 == 0 ) :			    	    if three_digit % 8 == 0 :				  
    if ( threeDigit % 8 == 0 ) count ++ ;		      		  count += 1					    		count += 1					  
  }							      	  threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ]  	three_digit = ( ord ( n [ - 1 ] ) - ord ( '0' ) ) * 100 + 
  threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . 	  if ( threeDigit % 8 == 0 ) :				    	if three_digit % 8 == 0 :				  
  if ( threeDigit % 8 == 0 ) count ++ ;			      	      count += 1					    	    count += 1						  
  threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . 	  threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l -  	three_digit = ( ord ( n [ - 2 ] ) - ord ( '0' ) ) * 100 + 
  if ( threeDigit % 8 == 0 ) count ++ ;			      	  if ( threeDigit % 8 == 0 ) :				    	if three_digit % 8 == 0 :				  
  return count ;					      	      count += 1					    	    count += 1						  
}							      	  return count						    	return count						  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL
--							      --							    --								  --
static int maxArea ( int mat [ ] [ ] ) {		      def maxArea ( mat ) :					    def max_area ( mat ) :					  script_not_found : None
  int hist [ ] [ ] = new int [ R + 1 ] [ C + 1 ] ;	      	  hist = [ [ 0 for i in range ( C + 1 ) ] for i in range (  	hist = np.zeros ( ( R + 1 , C + 1 ) )			  
  for ( int i = 0 ;					      	  for i in range ( 0 , C , 1 ) :			    	for i in range ( C ) :					  
  i < C ;						      	      hist [ 0 ] [ i ] = mat [ 0 ] [ i ]		    	    hist [ 0 ] [ i ] = mat [ 0 ] [ i ]			  
  i ++ ) {						      	      for j in range ( 1 , R , 1 ) :			    	    for j in range ( 1 , R ) :				  
    hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ;		      		  if ( ( mat [ j ] [ i ] == 0 ) ) :		    		hist [ j ] [ i ] = ( 0 if mat [ j ] [ i ] == 0 el 
    for ( int j = 1 ;					      		      hist [ j ] [ i ] = 0			    	for i in range ( R ) :					  
    j < R ;						      		  else :					    	    count = np.zeros ( ( R + 1 , C + 1 ) )		  
    j ++ ) {						      		      hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1   	    for j in range ( C ) :				  
      hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist  	  for i in range ( 0 , R , 1 ) :			    		count [ hist [ i ] [ j ] ] += 1			  
    }							      	      count = [ 0 for i in range ( R + 1 ) ]		    	    col_no = 0						  
  }							      	      for j in range ( 0 , C , 1 ) :			    	    for j in range ( R , - 1 , - 1 ) :			  
  for ( int i = 0 ;					      		  count [ hist [ i ] [ j ] ] += 1		    		if count [ j ] > 0 :				  
  i < R ;						      	      col_no = 0					    		    for k in count [ j ] :			  
  i ++ ) {						      	      j = R						    			hist [ i ] [ col_no ] = j		  
    int count [ ] = new int [ R + 1 ] ;			      	      while ( j >= 0 ) :				    			col_no += 1				  
    for ( int j = 0 ;					      		  if ( count [ j ] > 0 ) :			    	curr_area , max_area = 0 , 0				  
    j < C ;						      		      for k in range ( 0 , count [ j ] , 1 ) :	    	for i in range ( R ) :					  
    j ++ ) {						      			  hist [ i ] [ col_no ] = j		    	    for j in range ( C ) :				  
      count [ hist [ i ] [ j ] ] ++ ;			      			  col_no += 1				    		curr_area = ( j + 1 ) * hist [ i ] [ j ]	  
    }							      		  j -= 1					    		if curr_area > max_area :			  
    int col_no = 0 ;					      	  max_area = 0						    		    max_area = curr_area			  
    for ( int j = R ;					      	  for i in range ( 0 , R , 1 ) :			    	return max_area						  
    j >= 0 ;						      	      for j in range ( 0 , C , 1 ) :			    								  
    j -- ) {						      		  curr_area = ( j + 1 ) * hist [ i ] [ j ]	    								  
      if ( count [ j ] > 0 ) {				      		  if ( curr_area > max_area ) :			    								  
	for ( int k = 0 ;				      		      max_area = curr_area			    								  
	k < count [ j ] ;				      	  return max_area					    								  
	k ++ ) {					      								    								  
	  hist [ i ] [ col_no ] = j ;			      								    								  
	  col_no ++ ;					      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  int curr_area , max_area = 0 ;			      								    								  
  for ( int i = 0 ;					      								    								  
  i < R ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j < C ;						      								    								  
    j ++ ) {						      								    								  
      curr_area = ( j + 1 ) * hist [ i ] [ j ] ;	      								    								  
      if ( curr_area > max_area ) {			      								    								  
	max_area = curr_area ;				      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return max_area ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT			      PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT			    PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT			  PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT
--							      --							    --								  --
static void printSpiral ( int [ ] [ ] mat , int r , int c ) { def printSpiral ( mat , r , c ) :				    def printSpiral ( mat , r , c ) :				  error : Traceback (most recent call last):   File
  int i , a = 0 , b = 2 ;				      	  a = 0							    	i , a , b = 0 , 2					  "dump/transcoder_st/eval/java_python/online_st/206
  int low_row = ( 0 > a ) ? 0 : a ;			      	  b = 2							    	lowRow = ( 0 if a > 0 else a )				  68770/eval_scripts/java_sa-python_sa.test/PRINT_MA
  int low_column = ( 0 > b ) ? 0 : b - 1 ;		      	  low_row = 0 if ( 0 > a ) else a			    	lowColumn = ( 0 if b > 0 else b - 1 )			  TRIX_SPIRAL_FORM_STARTING_POINT.py", line 97, in <
  int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ;	      	  low_column = 0 if ( 0 > b ) else b - 1		    	highRow = ( r - 1 if ( a + 1 ) >= r else a + 1 )	  module>     f_filled(*(filled_function_param[i]))
  int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ;      	  high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1	    	highColumn = ( c - 1 if ( b + 1 ) >= c else b + 1 )	    File "dump/transcoder_st/eval/java_python/online
  while ( ( low_row > 0 - r && low_column > 0 - c ) ) {	      	  high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1	    	while ( lowRow > 0 - r and lowColumn > 0 - c ) :	  _st/20668770/eval_scripts/java_sa-python_sa.test/P
    for ( i = low_column + 1 ;				      	  while ( ( low_row > 0 - r and low_column > 0 - c ) ) :    	    for i in range ( lowColumn + 1 , highColumn + 1 , c ) RINT_MATRIX_SPIRAL_FORM_STARTING_POINT.py", line 4
    i <= high_column && i < c && low_row >= 0 ;		      	      i = low_column + 1				    		print ( '%d ' % i , end = ' ' )			  9, in f_filled     i , a , b = 0 , 2 ValueError: n
    ++ i ) System . out . print ( mat [ low_row ] [ i ] + " " 	      while ( i <= high_column and i < c and low_row >= 0 ) 	    lowRow -= 1						  ot enough values to unpack (expected 3, got 2)
    low_row -= 1 ;					      		  print ( mat [ low_row ] [ i ] , end = " " )	    	    for i in range ( lowRow + 2 , highRow , highColumn +  
    for ( i = low_row + 2 ;				      		  i += 1					    		print ( '%d ' % i , end = ' ' )			  
    i <= high_row && i < r && high_column < c ;		      	      low_row -= 1					    	    highColumn += 1					  
    ++ i ) System . out . print ( mat [ i ] [ high_column ] + 	      i = low_row + 2					    	    for i in range ( highColumn - 2 , lowColumn + 1 , c ) 
    high_column += 1 ;					      	      while ( i <= high_row and i < r and high_column < c ) 		print ( '%d ' % i , end = ' ' )			  
    for ( i = high_column - 2 ;				      		  print ( mat [ i ] [ high_column ] , end = " " )   	    highRow += 1					  
    i >= low_column && i >= 0 && high_row < r ;		      		  i += 1					    	    for i in range ( highRow - 2 , lowRow + 1 , c ) :	  
    -- i ) System . out . print ( mat [ high_row ] [ i ] + "  	      high_column += 1					    		print ( '%d ' % i , end = ' ' )			  
    high_row += 1 ;					      	      i = high_column - 2				    	    lowColumn -= 1					  
    for ( i = high_row - 2 ;				      	      while ( i >= low_column and i >= 0 and high_row < r ) 	print ( )						  
    i > low_row && i >= 0 && low_column >= 0 ;		      		  print ( mat [ high_row ] [ i ] , end = " " )	    								  
    -- i ) System . out . print ( mat [ i ] [ low_column ] +  		  i -= 1					    								  
    low_column -= 1 ;					      	      high_row += 1					    								  
  }							      	      i = high_row - 2					    								  
  System . out . println ( ) ;				      	      while ( i > low_row and i >= 0 and low_column >= 0 )  								  
}							      		  print ( mat [ i ] [ low_column ] , end = " " )    								  
							      		  i -= 1					    								  
							      	      low_column -= 1					    								  
							      	  print ( )						    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER		      MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER			    MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER			  MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER
--							      --							    --								  --
static int findMaxVal ( int [ ] arr , int n , int num , int m def findMaxVal ( arr , n , num , maxLimit ) :		    def find_max_val ( arr , n , num , max_limit ) :		  script_not_found : None
  int ind ;						      	  ind = - 1						    	global dp						  
  int val ;						      	  val = - 1						    	dp = np.zeros ( ( n , max_limit + 1 ) )			  
  int [ ] [ ] dp = new int [ n ] [ maxLimit + 1 ] ;	      	  dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in ran 	for ind in range ( n ) :				  
  for ( ind = 0 ;					      	  for ind in range ( n ) :				    	    for val in range ( 0 , max_limit + 1 ) :		  
  ind < n ;						      	      for val in range ( maxLimit + 1 ) :		    		if ind == 0 :					  
  ind ++ ) {						      		  if ( ind == 0 ) :				    		    if num - arr [ ind ] == val or num + arr [ in 
    for ( val = 0 ;					      		      if ( num - arr [ ind ] == val or num + arr [  			dp [ ind ] [ val ] = 1			  
    val <= maxLimit ;					      			  dp [ ind ] [ val ] = 1		    		    else :					  
    val ++ ) {						      		      else :					    			dp [ ind ] [ val ] = 0			  
      if ( ind == 0 ) {					      			  dp [ ind ] [ val ] = 0		    		else :						  
	if ( num - arr [ ind ] == val || num + arr [ ind ] == 		  else :					    		    if val - arr [ ind ] >= 0 and val + arr [ ind 
	  dp [ ind ] [ val ] = 1 ;			      		      if ( val - arr [ ind ] >= 0 and val + arr [ i 			if dp [ ind - 1 ] [ val - arr [ ind ] ] = 
	}						      			  if ( dp [ ind - 1 ] [ val - arr [ ind ] ] 			    dp [ ind ] [ val ] = 1		  
	else {						      			      dp [ ind ] [ val ] = 1		    		    elif val - arr [ ind ] >= 0 :		  
	  dp [ ind ] [ val ] = 0 ;			      		      elif ( val - arr [ ind ] >= 0 ) :		    			dp [ ind ] [ val ] = dp [ ind - 1 ] [ val 
	}						      			  dp [ ind ] [ val ] = dp [ ind - 1 ] [ val 		    elif val + arr [ ind ] <= max_limit :	  
      }							      		      elif ( val + arr [ ind ] <= maxLimit ) :	    			dp [ ind ] [ val ] = dp [ ind - 1 ] [ val 
      else {						      			  dp [ ind ] [ val ] = dp [ ind - 1 ] [ val 		    else :					  
	if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= m 		      else :					    			dp [ ind ] [ val ] = 0			  
	  if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || d 			  dp [ ind ] [ val ] = 0		    	for val in range ( max_limit , - 1 , - 1 ) :		  
	}						      	  for val in range ( maxLimit , - 1 , - 1 ) :		    	    if dp [ n - 1 ] [ val ] == 1 :			  
	else if ( val - arr [ ind ] >= 0 ) {		      	      if ( dp [ n - 1 ] [ val ] == 1 ) :		    		return val					  
	  dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ i 		  return val					    	return - 1						  
	}						      	  return - 1						    								  
	else if ( val + arr [ ind ] <= maxLimit ) {	      								    								  
	  dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ i 								    								  
	}						      								    								  
	else {						      								    								  
	  dp [ ind ] [ val ] = 0 ;			      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  for ( val = maxLimit ;				      								    								  
  val >= 0 ;						      								    								  
  val -- ) {						      								    								  
    if ( dp [ n - 1 ] [ val ] == 1 ) {			      								    								  
      return val ;					      								    								  
    }							      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PARTITION_NUMBER_TWO_DIVISBLE_PARTS			      PARTITION_NUMBER_TWO_DIVISBLE_PARTS			    PARTITION_NUMBER_TWO_DIVISBLE_PARTS				  PARTITION_NUMBER_TWO_DIVISBLE_PARTS
--							      --							    --								  --
static void findDivision ( String str , int a , int b ) {     def findDivision ( str , a , b ) :			    def find_division ( str , a , b ) :				  script_not_found : None
  int len = str . length ( ) ;				      	  lenn = len ( str )					    	data = list ( str )					  
  int [ ] lr = new int [ len + 1 ] ;			      	  lr = [ 0 ] * ( lenn + 1 )				    	lr = [ 0 ] * ( data [ 0 ] - ord ( '0' ) ) % a		  
  lr [ 0 ] = ( ( int ) str . charAt ( 0 ) - ( int ) '0' ) % a 	  lr [ 0 ] = ( int ( str [ 0 ] ) ) % a			    	for i in range ( 1 , len ( data ) ) :			  
  for ( int i = 1 ;					      	  for i in range ( 1 , lenn ) :				    	    lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ord ( data 
  i < len ;						      	      lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ int ( str  	rl = [ 0 ] * ( data [ - 1 ] - ord ( '0' ) )		  
  i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ( int ) s 	  rl = [ 0 ] * ( lenn + 1 )				    	power10 = 10						  
  int [ ] rl = new int [ len + 1 ] ;			      	  rl [ lenn - 1 ] = int ( str [ lenn - 1 ] ) % b	    	for i in range ( data [ - 2 ] , - 1 , - 1 ) :		  
  rl [ len - 1 ] = ( ( int ) str . charAt ( len - 1 ) - ( int 	  power10 = 10						    	    rl [ i ] = ( rl [ i + 1 ] + ( ord ( data [ i ] ) - or 
  int power10 = 10 ;					      	  for i in range ( lenn - 2 , - 1 , - 1 ) :		    	    power10 = ( power10 * 10 ) % b			  
  for ( int i = len - 2 ;				      	      rl [ i ] = ( rl [ i + 1 ] + int ( str [ i ] ) * power 	for i in range ( data [ - 1 ] ) :			  
  i >= 0 ;						      	      power10 = ( power10 * 10 ) % b			    	    if lr [ i ] != 0 :					  
  i -- ) {						      	  for i in range ( 0 , lenn - 1 ) :			    		continue					  
    rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str . charAt ( i )  	      if ( lr [ i ] != 0 ) :				    	    if rl [ i + 1 ] == 0 :				  
    power10 = ( power10 * 10 ) % b ;			      		  continue					    		print ( 'YES' )					  
  }							      	      if ( rl [ i + 1 ] == 0 ) :			    		for k in range ( 0 , i + 1 ) :			  
  for ( int i = 0 ;					      		  print ( "YES" )				    		    print ( data [ k ] , end = ' ' )		  
  i < len - 1 ;						      		  for k in range ( 0 , i + 1 ) :		    		print ( ', ' )					  
  i ++ ) {						      		      print ( str [ k ] , end = "" )		    		for k in range ( i + 1 , len ( data ) ) :	  
    if ( lr [ i ] != 0 ) continue ;			      		  print ( "," , end = "" )			    		    print ( data [ k ] , end = ' ' )		  
    if ( rl [ i + 1 ] == 0 ) {				      		  for i in range ( i + 1 , lenn ) :		    		return						  
      System . out . println ( "YES" ) ;		      		      print ( str [ k ] , end = "" )		    	print ( 'NO' )						  
      for ( int k = 0 ;					      		      return					    								  
      k <= i ;						      	  print ( "NO" )					    								  
      k ++ ) System . out . print ( str . charAt ( k ) ) ;    								    								  
      System . out . print ( ", " ) ;			      								    								  
      for ( int k = i + 1 ;				      								    								  
      k < len ;						      								    								  
      k ++ ) System . out . print ( str . charAt ( k ) ) ;    								    								  
      return ;						      								    								  
    }							      								    								  
  }							      								    								  
  System . out . println ( "NO" ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER	      COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER		    COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER		  COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER
--							      --							    --								  --
static int numofArray ( int n , int m ) {		      def numofArray ( n , m ) :				    def numofArray ( n , m ) :					  script_not_found : None
  int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;		      	  dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX  	dp = np.zeros ( ( MAX , MAX ) )				  
  Vector < Integer > [ ] di = new Vector [ MAX ] ;	      	  di = [ [ ] for i in range ( MAX ) ]			    	di = np.zeros ( MAX )					  
  Vector < Integer > [ ] mu = new Vector [ MAX ] ;	      	  mu = [ [ ] for i in range ( MAX ) ]			    	mu = np.zeros ( MAX )					  
  for ( int i = 0 ;					      	  for i in range ( 1 , m + 1 ) :			    	for i in range ( MAX ) :				  
  i < MAX ;						      	      for j in range ( 2 * i , m + 1 , i ) :		    	    for j in range ( MAX ) :				  
  i ++ ) {						      		  di [ j ].append ( i )				    		dp [ i ] [ j ] = 0				  
    for ( int j = 0 ;					      		  mu [ i ].append ( j )				    	for i in range ( MAX ) :				  
    j < MAX ;						      	      di [ i ].append ( i )				    	    di [ i ] = [ ]					  
    j ++ ) {						      	  for i in range ( 1 , m + 1 ) :			    	    mu [ i ] = [ ]					  
      dp [ i ] [ j ] = 0 ;				      	      dp [ 1 ] [ i ] = 1				    	for i in range ( 1 , m + 1 ) :				  
    }							      	  for i in range ( 2 , n + 1 ) :			    	    for j in range ( 2 * i , m + 1 , i ) :		  
  }							      	      for j in range ( 1 , m + 1 ) :			    		di [ j ].append ( i )				  
  for ( int i = 0 ;					      		  dp [ i ] [ j ] = 0				    		mu [ i ].append ( j )				  
  i < MAX ;						      		  for x in di [ j ] :				    	    di [ i ].append ( i )				  
  i ++ ) {						      		      dp [ i ] [ j ] += dp [ i - 1 ] [ x ]	    	for i in range ( 1 , m + 1 ) :				  
    di [ i ] = new Vector < > ( ) ;			      		  for x in mu [ j ] :				    	    dp [ 1 ] [ i ] = 1					  
    mu [ i ] = new Vector < > ( ) ;			      		      dp [ i ] [ j ] += dp [ i - 1 ] [ x ]	    	for i in range ( 2 , n + 1 ) :				  
  }							      	  ans = 0						    	    for j in range ( 1 , m + 1 ) :			  
  for ( int i = 1 ;					      	  for i in range ( 1 , m + 1 ) :			    		dp [ i ] [ j ] = 0				  
  i <= m ;						      	      ans += dp [ n ] [ i ]				    		for x in di [ j ] :				  
  i ++ ) {						      	      di [ i ].clear ( )				    		    dp [ i ] [ j ] += dp [ i - 1 ] [ x ]	  
    for ( int j = 2 * i ;				      	      mu [ i ].clear ( )				    		for x in mu [ j ] :				  
    j <= m ;						      	  return ans						    		    dp [ i ] [ j ] += dp [ i - 1 ] [ x ]	  
    j += i ) {						      								    	ans = 0							  
      di [ j ] . add ( i ) ;				      								    	for i in range ( 1 , m + 1 ) :				  
      mu [ i ] . add ( j ) ;				      								    	    ans += dp [ n ] [ i ]				  
    }							      								    	    di [ i ].clear ( )					  
    di [ i ] . add ( i ) ;				      								    	    mu [ i ].clear ( )					  
  }							      								    	return ans						  
  for ( int i = 1 ;					      								    								  
  i <= m ;						      								    								  
  i ++ ) dp [ 1 ] [ i ] = 1 ;				      								    								  
  for ( int i = 2 ;					      								    								  
  i <= n ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 1 ;					      								    								  
    j <= m ;						      								    								  
    j ++ ) {						      								    								  
      dp [ i ] [ j ] = 0 ;				      								    								  
      for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 								    								  
      for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 								    								  
    }							      								    								  
  }							      								    								  
  int ans = 0 ;						      								    								  
  for ( int i = 1 ;					      								    								  
  i <= m ;						      								    								  
  i ++ ) {						      								    								  
    ans += dp [ n ] [ i ] ;				      								    								  
    di [ i ] . clear ( ) ;				      								    								  
    mu [ i ] . clear ( ) ;				      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERS_FOUR_SQUARE_IDENTITY_1				      EULERS_FOUR_SQUARE_IDENTITY_1				    EULERS_FOUR_SQUARE_IDENTITY_1				  EULERS_FOUR_SQUARE_IDENTITY_1
--							      --							    --								  --
public static void checkEulerFourSquareIdentity ( int a , int def checkEulerFourSquareIdentity ( a , b ) :		    def check_euler ( a , b ) :					  script_not_found : None
  int ab = a * b ;					      	  ab = a * b						    	ab = a * b						  
  boolean flag = false ;				      	  flag = False						    	flag = False						  
  int i = 0 ;						      	  i = 0							    	i = 0							  
  while ( i * i <= ab ) {				      	  while i * i <= ab :					    	while i * i <= ab :					  
    int j = i ;						      	      j = i						    	    j = i						  
    while ( i * i + j * j <= ab ) {			      	      while i * i + j * j <= ab :			    	    while i * i + j * j <= ab :				  
      int k = j ;					      		  k = j						    		k = j						  
      while ( i * i + j * j + k * k <= ab ) {		      		  while i * i + j * j + k * k <= ab :		    		while i * i + j * j + k * k <= ab :		  
	double l = Math . sqrt ( ab - ( i * i + j * j + k * k 		      l = ( ab - ( i * i + j * j + k * k ) ) ** ( 0 		    l = math.sqrt ( ab - ( i * i + j * j + k * k  
	if ( Math . floor ( l ) == Math . ceil ( l ) && l >=  		      if l == int ( l ) and l >= k :		    		    if math.floor ( l ) == math.ceil ( l ) and l  
	  flag = true ;					      			  flag = True				    			flag = True				  
	  System . out . print ( "i = " + i + "\n" ) ;	      			  print ( "i = " , i )			    			print ( "i = %d\n" % i , end = ' ' )	  
	  System . out . print ( "j = " + j + "\n" ) ;	      			  print ( "j = " , j )			    			print ( "j = %d\n" % j , end = ' ' )	  
	  System . out . print ( "k = " + k + "\n" ) ;	      			  print ( "k = " , k )			    			print ( "k = %d\n" % k , end = ' ' )	  
	  System . out . print ( "l = " + ( int ) l + "\n" )  			  print ( "l = " , l )			    			print ( "l = %d\n" % int ( l ) , end = '  
	  System . out . print ( "Product of " + a + " and "  			  print ( "Product of" , a , "and" , b , "c 			print ( "Product of %d and %d can be writ 
	  System . out . print ( ab + " = " + i + "*" + i + " 			  print ( ab , " = " , i , "*" , i , "+" ,  			print ( "%d = %d*%d + %d*%d + %d*%d + %d* 
	}						      		      k += 1					    		    k += 1					  
	k += 1 ;					      		  j += 1					    		j += 1						  
      }							      	      i += 1						    	    i += 1						  
      j += 1 ;						      	  if flag == False :					    	if flag == False :					  
    }							      	      print ( "Solution doesn't exist!" )		    	    print ( "Solution doesn't exist!" )			  
    i += 1 ;						      	      return						    	    return						  
  }							      								    								  
  if ( flag == false ) {				      								    								  
    System . out . println ( "Solution doesn't exist!" ) ;    								    								  
    return ;						      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1		      MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1		    MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1		  MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1
--							      --							    --								  --
static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) {  def MaximumDecimalValue ( mat , n ) :			    def MaximumDecimalValue ( mat , n ) :			  script_not_found : None
  int dp [ ] [ ] = new int [ n ] [ n ] ;		      	  dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]  	dp = np.zeros ( ( n , n ) )				  
  if ( mat [ 0 ] [ 0 ] == 1 ) {				      	  if ( mat [ 0 ] [ 0 ] == 1 ) :				    	if mat [ 0 ] [ 0 ] == 1 :				  
    dp [ 0 ] [ 0 ] = 1 ;				      	      dp [ 0 ] [ 0 ] = 1				    	    dp [ 0 ] [ 0 ] = 1					  
  }							      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      	      if ( mat [ 0 ] [ i ] == 1 ) :			    	    if mat [ 0 ] [ i ] == 1 :				  
  i < n ;						      		  dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i	    		dp [ 0 ] [ i ] = int ( dp [ 0 ] [ i - 1 ] + np.po 
  i ++ ) {						      	      else :						    	    else :						  
    if ( mat [ 0 ] [ i ] == 1 ) {			      		  dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ]		    		dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ]		  
      dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math .  	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
    }							      	      if ( mat [ i ] [ 0 ] == 1 ) :			    	    if mat [ i ] [ 0 ] == 1 :				  
    else {						      		  dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i	    		dp [ i ] [ 0 ] = int ( dp [ i - 1 ] [ 0 ] + np.po 
      dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ;		      	  else :						    	    else :						  
    }							      	      dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]		    		dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]		  
  }							      	  for i in range ( 1 , n ) :				    	for i in range ( 1 , n ) :				  
  for ( int i = 1 ;					      	      for j in range ( 1 , n ) :			    	    for j in range ( 1 , n ) :				  
  i < n ;						      		  if ( mat [ i ] [ j ] == 1 ) :			    		if mat [ i ] [ j ] == 1 :			  
  i ++ ) {						      		      dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , d 		    dp [ i ] [ j ] = int ( np.maximum ( dp [ i ]  
    if ( mat [ i ] [ 0 ] == 1 ) {			      		  else :					    		else :						  
      dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math .  		      dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , d 		    dp [ i ] [ j ] = np.maximum ( dp [ i ] [ j -  
    }							      	  return dp [ n - 1 ] [ n - 1 ]				    	return dp [ n - 1 ] [ n - 1 ]				  
    else {						      								    								  
      dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;		      								    								  
    }							      								    								  
  }							      								    								  
  for ( int i = 1 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 1 ;					      								    								  
    j < n ;						      								    								  
    j ++ ) {						      								    								  
      if ( mat [ i ] [ j ] == 1 ) {			      								    								  
	dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j  								    								  
      }							      								    								  
      else {						      								    								  
	dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp 								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return dp [ n - 1 ] [ n - 1 ] ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIRECTION_LAST_SQUARE_BLOCK				      DIRECTION_LAST_SQUARE_BLOCK				    DIRECTION_LAST_SQUARE_BLOCK					  DIRECTION_LAST_SQUARE_BLOCK
--							      --							    --								  --
static void direction ( int R , int C ) {		      def direction ( R , C ) :					    def direction ( R , C ) :					  script_not_found : None
  if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) {	      	  if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) :   	if R != C and R % 2 == 0 and C % 2 != 0 and R < C :	  
    System . out . println ( "Left" ) ;			      	      print ( "Left" )					    	    print ( "Left" )					  
    return ;						      	      return						    	    return						  
  }							      	  if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) :   	if R != C and R % 2 != 0 and C % 2 == 0 and R > C :	  
  if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) {	      	      print ( "Up" )					    	    print ( "Up" )					  
    System . out . println ( "Up" ) ;			      	      return						    	    return						  
    return ;						      	  if R == C and R % 2 != 0 and C % 2 != 0 :		    	if R == C and R % 2 != 0 and C % 2 != 0 :		  
  }							      	      print ( "Right" )					    	    print ( "Right" )					  
  if ( R == C && R % 2 != 0 && C % 2 != 0 ) {		      	      return						    	    return						  
    System . out . println ( "Right" ) ;		      	  if R == C and R % 2 == 0 and C % 2 == 0 :		    	if R == C and R % 2 == 0 and C % 2 == 0 :		  
    return ;						      	      print ( "Left" )					    	    print ( "Left" )					  
  }							      	      return						    	    return						  
  if ( R == C && R % 2 == 0 && C % 2 == 0 ) {		      	  if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) :   	if R != C and R % 2 != 0 and C % 2 != 0 and R < C :	  
    System . out . println ( "Left" ) ;			      	      print ( "Right" )					    	    print ( "Right" )					  
    return ;						      	      return						    	    return						  
  }							      	  if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) :   	if R != C and R % 2 != 0 and C % 2 != 0 and R > C :	  
  if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) {	      	      print ( "Down" )					    	    print ( "Down" )					  
    System . out . println ( "Right" ) ;		      	      return						    	    return						  
    return ;						      	  if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) :   	if R != C and R % 2 == 0 and C % 2 == 0 and R < C :	  
  }							      	      print ( "Left" )					    	    print ( "Left" )					  
  if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) {	      	      return						    	    return						  
    System . out . println ( "Down" ) ;			      	  if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) :   	if R != C and R % 2 == 0 and C % 2 == 0 and C > C :	  
    return ;						      	      print ( "Up" )					    	    print ( "Up" )					  
  }							      	      return						    	    return						  
  if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) {	      	  if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) :   	if R != C and R % 2 == 0 and C % 2 == 0 and C > C :	  
    System . out . println ( "Left" ) ;			      	      print ( "Down" )					    	    print ( "Down" )					  
    return ;						      	      return						    	    return						  
  }							      	  if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) :   	if R != C and R % 2 != 0 and C % 2 == 0 and C < C :	  
  if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) {	      	      print ( "Right" )					    	    print ( "Right" )					  
    System . out . println ( "Up" ) ;			      	      return						    	    return						  
    return ;						      								    								  
  }							      								    								  
  if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) {	      								    								  
    System . out . println ( "Down" ) ;			      								    								  
    return ;						      								    								  
  }							      								    								  
  if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) {	      								    								  
    System . out . println ( "Right" ) ;		      								    								  
    return ;						      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_SPECIFIC_PAIR_IN_MATRIX_1			      FIND_A_SPECIFIC_PAIR_IN_MATRIX_1				    FIND_A_SPECIFIC_PAIR_IN_MATRIX_1				  FIND_A_SPECIFIC_PAIR_IN_MATRIX_1
--							      --							    --								  --
static int findMaxValue ( int N , int mat [ ] [ ] ) {	      def findMaxValue ( mat ) :				    def find_max_value ( N , mat ) :				  script_not_found : None
  int maxValue = Integer . MIN_VALUE ;			      	  maxValue = - sys.maxsize - 1				    	max_value = np.inf					  
  int maxArr [ ] [ ] = new int [ N ] [ N ] ;		      	  maxArr = [ [ 0 for x in range ( N ) ] for y in range ( N  	max_arr = np.zeros ( ( N , N ) )			  
  maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ;      	  maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ]	    	max_arr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ]	  
  int maxv = mat [ N - 1 ] [ N - 1 ] ;			      	  maxv = mat [ N - 1 ] [ N - 1 ]			    	maxv = mat [ N - 1 ] [ N - 1 ]				  
  for ( int j = N - 2 ;					      	  for j in range ( N - 2 , - 1 , - 1 ) :		    	for j in range ( N - 2 , - 1 , - 1 ) :			  
  j >= 0 ;						      	      if ( mat [ N - 1 ] [ j ] > maxv ) :		    	    if mat [ N - 1 ] [ j ] > maxv :			  
  j -- ) {						      		  maxv = mat [ N - 1 ] [ j ]			    		maxv = mat [ N - 1 ] [ j ]			  
    if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [  	      maxArr [ N - 1 ] [ j ] = maxv			    	    max_arr [ N - 1 ] [ j ] = maxv			  
    maxArr [ N - 1 ] [ j ] = maxv ;			      	  maxv = mat [ N - 1 ] [ N - 1 ]			    	maxv = mat [ N - 1 ] [ N - 1 ]				  
  }							      	  for i in range ( N - 2 , - 1 , - 1 ) :		    	for i in range ( N - 2 , - 1 , - 1 ) :			  
  maxv = mat [ N - 1 ] [ N - 1 ] ;			      	      if ( mat [ i ] [ N - 1 ] > maxv ) :		    	    if mat [ i ] [ N - 1 ] > maxv :			  
  for ( int i = N - 2 ;					      		  maxv = mat [ i ] [ N - 1 ]			    		maxv = mat [ i ] [ N - 1 ]			  
  i >= 0 ;						      	      maxArr [ i ] [ N - 1 ] = maxv			    	    max_arr [ i ] [ N - 1 ] = maxv			  
  i -- ) {						      	  for i in range ( N - 2 , - 1 , - 1 ) :		    	for i in range ( N - 2 , - 1 , - 1 ) :			  
    if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N -  	      for j in range ( N - 2 , - 1 , - 1 ) :		    	    for j in range ( N - 2 , - 1 , - 1 ) :		  
    maxArr [ i ] [ N - 1 ] = maxv ;			      		  if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] 		if max_arr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ]  
  }							      		      maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat 		    max_value = max_arr [ i + 1 ] [ j + 1 ] - mat 
  for ( int i = N - 2 ;					      		  maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max  		max_arr [ i ] [ j ] = max ( mat [ i ] [ j ] , max 
  i >= 0 ;						      	  return maxValue					    	return max_value					  
  i -- ) {						      								    								  
    for ( int j = N - 2 ;				      								    								  
    j >= 0 ;						      								    								  
    j -- ) {						      								    								  
      if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > max 								    								  
      maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Mat 								    								  
    }							      								    								  
  }							      								    								  
  return maxValue ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DOOLITTLE_ALGORITHM_LU_DECOMPOSITION			      DOOLITTLE_ALGORITHM_LU_DECOMPOSITION			    DOOLITTLE_ALGORITHM_LU_DECOMPOSITION			  DOOLITTLE_ALGORITHM_LU_DECOMPOSITION
--							      --							    --								  --
static void luDecomposition ( int [ ] [ ] mat , int n ) {     def luDecomposition ( mat , n ) :				    def lu_decomposition ( mat , n ) :				  script_not_found : None
  int [ ] [ ] lower = new int [ n ] [ n ] ;		      	  lower = [ [ 0 for x in range ( n ) ] for y in range ( n ) 	lower = np.zeros ( ( n , n ) )				  
  int [ ] [ ] upper = new int [ n ] [ n ] ;		      	  upper = [ [ 0 for x in range ( n ) ] for y in range ( n ) 	upper = np.zeros ( ( n , n ) )				  
  for ( int i = 0 ;					      	  for i in range ( n ) :				    	for i in range ( n ) :					  
  i < n ;						      	      for k in range ( i , n ) :			    	    for k in range ( i , n ) :				  
  i ++ ) {						      		  sum = 0					    		sum = 0						  
    for ( int k = i ;					      		  for j in range ( i ) :			    		for j in range ( i ) :				  
    k < n ;						      		      sum += ( lower [ i ] [ j ] * upper [ j ] [ k  		    sum += ( lower [ i ] [ j ] * upper [ j ] [ k  
    k ++ ) {						      		  upper [ i ] [ k ] = mat [ i ] [ k ] - sum	    		upper [ i ] [ k ] = mat [ i ] [ k ] - sum	  
      int sum = 0 ;					      	      for k in range ( i , n ) :			    	for k in range ( i , n ) :				  
      for ( int j = 0 ;					      		  if ( i == k ) :				    	    if i == k :						  
      j < i ;						      		      lower [ i ] [ i ] = 1			    		lower [ i ] [ i ] = 1				  
      j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) 		  else :					    	    else :						  
      upper [ i ] [ k ] = mat [ i ] [ k ] - sum ;	      		      sum = 0					    		sum = 0						  
    }							      		      for j in range ( i ) :			    		for j in range ( i ) :				  
    for ( int k = i ;					      			  sum += ( lower [ k ] [ j ] * upper [ j ]  		    sum += ( lower [ k ] [ j ] * upper [ j ] [ i  
    k < n ;						      		      lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - 		lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / u 
    k ++ ) {						      	  print ( "Lower Triangular\t\tUpper Triangular" )	    	print ( '%d	Lower Triangular' % ( 2 ) , '%d Upper Tri 
      if ( i == k ) lower [ i ] [ i ] = 1 ;		      	  for i in range ( n ) :				    	for i in range ( n ) :					  
      else {						      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
	int sum = 0 ;					      		  print ( lower [ i ] [ j ] , end = "\t" )	    		print ( '%s\t%s\t' % ( 4 , lower [ i ] [ j ] , i  
	for ( int j = 0 ;				      	      print ( "" , end = "\t" )				    	    print ( '\t' , end = ' ' )				  
	j < i ;						      	      for j in range ( n ) :				    	    for j in range ( n ) :				  
	j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] 		  print ( upper [ i ] [ j ] , end = "\t" )	    		print ( '%s\t%s\t' % ( 4 , upper [ i ] [ j ] , i  
	lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper 	      print ( "" )					    	    print ( '\n' , end = ' ' )				  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  System . out . println ( setw ( 2 ) + "     Lower Triangula 								    								  
  for ( int i = 0 ;					      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j < n ;						      								    								  
    j ++ ) System . out . print ( setw ( 4 ) + lower [ i ] [  								    								  
    System . out . print ( "\t" ) ;			      								    								  
    for ( int j = 0 ;					      								    								  
    j < n ;						      								    								  
    j ++ ) System . out . print ( setw ( 4 ) + upper [ i ] [  								    								  
    System . out . print ( "\n" ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER
--							      --							    --								  --
static String findSubString ( String str , String pat ) {     def findSubString ( string , pat ) :			    def find_substring ( str , pat ) :				  script_not_found : None
  int len1 = str . length ( ) ;				      	  len1 = len ( string )					    	len1 = len ( str )					  
  int len2 = pat . length ( ) ;				      	  len2 = len ( pat )					    	len2 = len ( pat )					  
  if ( len1 < len2 ) {					      	  if len1 < len2 :					    	if len1 < len2 :					  
    System . out . println ( "No such window exists" ) ;      	      print ( "No such window exists" )			    	    print ( 'No such window exists' )			  
    return "" ;						      	      return ""						    	    return ''						  
  }							      	  hash_pat = [ 0 ] * no_of_chars			    	hash_pat = [ 0 ] * ( no_of_chars - len ( pat ) )	  
  int hash_pat [ ] = new int [ no_of_chars ] ;		      	  hash_str = [ 0 ] * no_of_chars			    	hash_str = [ 0 ] * ( no_of_chars - len ( pat ) )	  
  int hash_str [ ] = new int [ no_of_chars ] ;		      	  for i in range ( 0 , len2 ) :				    	for i in range ( len2 ) :				  
  for ( int i = 0 ;					      	      hash_pat [ ord ( pat [ i ] ) ] += 1		    	    hash_pat [ pat [ i ] ] += 1				  
  i < len2 ;						      	  start , start_index , min_len = 0 , - 1 , float ( 'inf' ) 	start , start_index , min_len = 0 , - 1 , 0		  
  i ++ ) hash_pat [ pat . charAt ( i ) ] ++ ;		      	  count = 0						    	count = 0						  
  int start = 0 , start_index = - 1 , min_len = Integer . MAX 	  for j in range ( 0 , len1 ) :				    	for j in range ( len1 ) :				  
  int count = 0 ;					      	      hash_str [ ord ( string [ j ] ) ] += 1		    	    hash_str [ str [ j ] ] += 1				  
  for ( int j = 0 ;					      	      if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_ 	    if hash_pat [ str [ j ] ] != 0 and hash_str [ str [ j 
  j < len1 ;						      		  count += 1					    		count += 1					  
  j ++ ) {						      	      if count == len2 :				    	    if count == len2 :					  
    hash_str [ str . charAt ( j ) ] ++ ;		      		  while ( hash_str [ ord ( string [ start ] ) ] > h 		while hash_str [ str [ start ] ] > hash_pat [ str 
    if ( hash_pat [ str . charAt ( j ) ] != 0 && hash_str [ s 		      if ( hash_str [ ord ( string [ start ] ) ] >  		    if hash_str [ str [ start ] ] > hash_pat [ st 
    if ( count == len2 ) {				      			  hash_str [ ord ( string [ start ] ) ] -=  			hash_str [ str [ start ] ] -= 1		  
      while ( hash_str [ str . charAt ( start ) ] > hash_pat  		      start += 1				    		    start += 1					  
	if ( hash_str [ str . charAt ( start ) ] > hash_pat [ 		  len_window = j - start + 1			    		len_window = j - start + 1			  
	start ++ ;					      		  if min_len > len_window :			    		if min_len > len_window :			  
      }							      		      min_len = len_window			    		    min_len = len_window			  
      int len_window = j - start + 1 ;			      		      start_index = start			    		    start_index = start				  
      if ( min_len > len_window ) {			      	  if start_index == - 1 :				    	if start_index == - 1 :					  
	min_len = len_window ;				      	      print ( "No such window exists" )			    	    print ( 'No such window exists' )			  
	start_index = start ;				      	      return ""						    	    return ''						  
      }							      	  return string [ start_index : start_index + min_len ]	    	return str [ start_index : start_index + min_len ]	  
    }							      								    								  
  }							      								    								  
  if ( start_index == - 1 ) {				      								    								  
    System . out . println ( "No such window exists" ) ;      								    								  
    return "" ;						      								    								  
  }							      								    								  
  return str . substring ( start_index , start_index + min_le 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_GEOMETRIC_PROGRESSION				      LONGEST_GEOMETRIC_PROGRESSION				    LONGEST_GEOMETRIC_PROGRESSION				  LONGEST_GEOMETRIC_PROGRESSION
--							      --							    --								  --
static int lenOfLongestGP ( int set [ ] , int n ) {	      def lenOfLongestGP ( sett , n ) :				    def len_of_longest_gp ( set , n ) :				  script_not_found : None
  if ( n < 2 ) {					      	  if n < 2 :						    	if n < 2 :						  
    return n ;						      	      return n						    	    return n						  
  }							      	  if n == 2 :						    	if n == 2 :						  
  if ( n == 2 ) {					      	      return ( sett [ 1 ] % sett [ 0 ] == 0 )		    	    return ( 1 if set [ 1 ] % set [ 0 ] == 0 else 0 )	  
    return ( set [ 1 ] % set [ 0 ] == 0 ? 1 : 0 ) ;	      	  sett.sort ( )						    	set.sort ( )						  
  }							      	  L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]   	L = np.zeros ( ( n , n ) )				  
  Arrays . sort ( set ) ;				      	  llgp = 1						    	llgp = 1						  
  int L [ ] [ ] = new int [ n ] [ n ] ;			      	  for i in range ( 0 , n ) :				    	for i in range ( n ) :					  
  int llgp = 1 ;					      	      if sett [ n - 1 ] % sett [ i ] == 0 :		    	    if set [ n - 1 ] % set [ i ] == 0 :			  
  for ( int i = 0 ;					      		  L [ i ] [ n - 1 ] = 2				    		L [ i ] [ n - 1 ] = 2				  
  i < n ;						      	      else :						    	    else :						  
  ++ i ) {						      		  L [ i ] [ n - 1 ] = 1				    		L [ i ] [ n - 1 ] = 1				  
    if ( set [ n - 1 ] % set [ i ] == 0 ) {		      	  for j in range ( n - 2 , 0 , - 1 ) :			    	for j in range ( n - 2 , 1 , - 1 ) :			  
      L [ i ] [ n - 1 ] = 2 ;				      	      i = j - 1						    	    i , k = j - 1 , j + 1				  
    }							      	      k = j + 1						    	    while i >= 0 and k <= n - 1 :			  
    else {						      	      while i >= 0 and k <= n - 1 :			    		if set [ i ] * set [ k ] < set [ j ] * set [ j ]  
      L [ i ] [ n - 1 ] = 1 ;				      		  if sett [ i ] * sett [ k ] < sett [ j ] * sett [  		    k += 1					  
    }							      		      k += 1					    		elif set [ i ] * set [ k ] > set [ j ] * set [ j  
  }							      		  elif sett [ i ] * sett [ k ] > sett [ j ] * sett  		    if set [ j ] % set [ i ] == 0 :		  
  for ( int j = n - 2 ;					      		      if sett [ j ] % sett [ i ] == 0 :		    			L [ i ] [ j ] = 2			  
  j >= 1 ;						      			  L [ i ] [ j ] = 2			    		    else :					  
  -- j ) {						      		      else :					    			L [ i ] [ j ] = 1			  
    int i = j - 1 , k = j + 1 ;				      			  L [ i ] [ j ] = 1			    		    i -= 1					  
    while ( i >= 0 && k <= n - 1 ) {			      		      i -= 1					    		else :						  
      if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) {  		  else :					    		    L [ i ] [ j ] = L [ j ] [ k ] + 1		  
	++ k ;						      		      L [ i ] [ j ] = L [ j ] [ k ] + 1		    		    if L [ i ] [ j ] > llgp :			  
      }							      		      if L [ i ] [ j ] > llgp :			    			llgp = L [ i ] [ j ]			  
      else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] 			  llgp = L [ i ] [ j ]			    		    i -= 1					  
	if ( set [ j ] % set [ i ] == 0 ) {		      		      i -= 1					    		    k += 1					  
	  L [ i ] [ j ] = 2 ;				      		      k + 1					    	    while i >= 0 :					  
	}						      	      while i >= 0 :					    		if set [ j ] % set [ i ] == 0 :			  
	else {						      		  if sett [ j ] % sett [ i ] == 0 :		    		    L [ i ] [ j ] = 2				  
	  L [ i ] [ j ] = 1 ;				      		      L [ i ] [ j ] = 2				    		else :						  
	}						      		  else :					    		    L [ i ] [ j ] = 1				  
	-- i ;						      		      L [ i ] [ j ] = 1				    		i -= 1						  
      }							      		  i -= 1					    	return llgp						  
      else {						      	  return llgp						    								  
	L [ i ] [ j ] = L [ j ] [ k ] + 1 ;		      								    								  
	if ( L [ i ] [ j ] > llgp ) {			      								    								  
	  llgp = L [ i ] [ j ] ;			      								    								  
	}						      								    								  
	-- i ;						      								    								  
	++ k ;						      								    								  
      }							      								    								  
    }							      								    								  
    while ( i >= 0 ) {					      								    								  
      if ( set [ j ] % set [ i ] == 0 ) {		      								    								  
	L [ i ] [ j ] = 2 ;				      								    								  
      }							      								    								  
      else {						      								    								  
	L [ i ] [ j ] = 1 ;				      								    								  
      }							      								    								  
      -- i ;						      								    								  
    }							      								    								  
  }							      								    								  
  return llgp ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS		      SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS			    SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS			  SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS
--							      --							    --								  --
static void printSuperSeq ( String a , String b ) {	      def printSuperSeq ( a , b ) :				    def print_super_seq ( a , b ) :				  script_not_found : None
  int m = a . length ( ) , n = b . length ( ) ;		      	  m = len ( a )						    	m , n = len ( a ) , len ( b )				  
  int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;	      	  n = len ( b )						    	dp = np.zeros ( ( m + 1 , n + 1 ) )			  
  for ( int i = 0 ;					      	  dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]	    	for i in range ( 0 , m + 1 ) :				  
  i <= m ;						      	  for i in range ( 0 , m + 1 ) :			    	    for j in range ( 0 , n + 1 ) :			  
  i ++ ) {						      	      for j in range ( 0 , n + 1 ) :			    		if i == 0 :					  
    for ( int j = 0 ;					      		  if not i :					    		    dp [ i ] [ j ] = j				  
    j <= n ;						      		      dp [ i ] [ j ] = j			    		elif j == 0 :					  
    j ++ ) {						      		  elif not j :					    		    dp [ i ] [ j ] = i				  
      if ( i == 0 ) dp [ i ] [ j ] = j ;		      		      dp [ i ] [ j ] = i			    		elif a [ i - 1 ] == b [ j - 1 ] :		  
      else if ( j == 0 ) dp [ i ] [ j ] = i ;		      		  elif ( a [ i - 1 ] == b [ j - 1 ] ) :		    		    dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]	  
      else if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 )  		      dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]   		else :						  
      else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j 		  else :					    		    dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] 
    }							      		      dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] 	res = ""						  
  }							      	  index = dp [ m ] [ n ]				    	i , j = m , n						  
  String res = "" ;					      	  res = [ "" ] * ( index )				    	while i > 0 and j > 0 :					  
  int i = m , j = n ;					      	  i = m							    	    if a [ i - 1 ] == b [ j - 1 ] :			  
  while ( i > 0 && j > 0 ) {				      	  j = n							    		res = a [ i - 1 ] + res				  
    if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) {     	  while ( i > 0 and j > 0 ) :				    		i -= 1						  
      res = a . charAt ( i - 1 ) + res ;		      	      if ( a [ i - 1 ] == b [ j - 1 ] ) :		    		j -= 1						  
      i -- ;						      		  res [ index - 1 ] = a [ i - 1 ]		    	    elif dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] :	  
      j -- ;						      		  i -= 1					    		res = a [ i - 1 ] + res				  
    }							      		  j -= 1					    		i -= 1						  
    else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) {     		  index -= 1					    	    else :						  
      res = a . charAt ( i - 1 ) + res ;		      	      elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) :    		res = b [ j - 1 ] + res				  
      i -- ;						      		  res [ index - 1 ] = a [ i - 1 ]		    		j -= 1						  
    }							      		  i -= 1					    	while i > 0 :						  
    else {						      		  index -= 1					    	    res = a [ i - 1 ] + res				  
      res = b . charAt ( j - 1 ) + res ;		      	      else :						    	    i -= 1						  
      j -- ;						      		  res [ index - 1 ] = b [ j - 1 ]		    	while j > 0 :						  
    }							      		  j -= 1					    	    res = b [ j - 1 ] + res				  
  }							      		  index -= 1					    	    j -= 1						  
  while ( i > 0 ) {					      	  while ( i > 0 ) :					    	print ( res )						  
    res = a . charAt ( i - 1 ) + res ;			      	      res [ index - 1 ] = a [ i - 1 ]			    								  
    i -- ;						      	      i -= 1						    								  
  }							      	      index -= 1					    								  
  while ( j > 0 ) {					      	  while ( j > 0 ) :					    								  
    res = b . charAt ( j - 1 ) + res ;			      	      res [ index - 1 ] = b [ j - 1 ]			    								  
    j -- ;						      	      j -= 1						    								  
  }							      	      index -= 1					    								  
  System . out . println ( res ) ;			      	  print ( "".join ( res ) )				    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING    DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING    DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING	  DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING
--							      --							    --								  --
static String decode ( String str ) {			      def decode ( Str ) :					    def decode ( data ) :					  script_not_found : None
  Stack < Integer > integerstack = new Stack < > ( ) ;	      	  integerstack = [ ]					    	integerstack = [ ]					  
  Stack < Character > stringstack = new Stack < > ( ) ;	      	  stringstack = [ ]					    	stringstack = [ ]					  
  String temp = "" , result = "" ;			      	  temp = ""						    	temp , result = "" , ""					  
  for ( int i = 0 ;					      	  result = ""						    	for c in data :						  
  i < str . length ( ) ;				      	  for i in range ( len ( Str ) ) :			    	    count = 0						  
  i ++ ) {						      	      count = 0						    	    if c.isdigit ( ) :					  
    int count = 0 ;					      	      if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :	    		while c.isdigit ( ) :				  
    if ( Character . isDigit ( str . charAt ( i ) ) ) {	      		  while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : 		    count = count * 10 + ord ( c ) - ord ( '0' )  
      while ( Character . isDigit ( str . charAt ( i ) ) ) {  		      count = count * 10 + ord ( Str [ i ] ) - ord  		    c += 1					  
	count = count * 10 + str . charAt ( i ) - '0' ;	      		      i += 1					    		c -= 1						  
	i ++ ;						      		  i -= 1					    		integerstack.append ( count )			  
      }							      		  integerstack.append ( count )			    	    elif c == ']' :					  
      i -- ;						      	      elif ( Str [ i ] == ']' ) :			    		temp = ""					  
      integerstack . push ( count ) ;			      		  temp = ""					    		count = 0					  
    }							      		  count = 0					    		if not integerstack :				  
    else if ( str . charAt ( i ) == ']' ) {		      		  if ( len ( integerstack ) != 0 ) :		    		    count = integerstack [ - 1 ]		  
      temp = "" ;					      		      count = integerstack [ - 1 ]		    		    integerstack.pop ( )			  
      count = 0 ;					      		      integerstack.pop ( )			    		while not stringstack and stringstack [ - 1 ] !=  
      if ( ! integerstack . isEmpty ( ) ) {		      		  while ( len ( stringstack ) != 0 and stringstack  		    temp = stringstack [ - 1 ] + temp		  
	count = integerstack . peek ( ) ;		      		      temp = stringstack [ - 1 ] + temp		    		    stringstack.pop ( )				  
	integerstack . pop ( ) ;			      		      stringstack.pop ( )			    		if not stringstack and stringstack [ - 1 ] == "[" 
      }							      		  if ( len ( stringstack ) != 0 and stringstack [ - 		    stringstack.pop ( )				  
      while ( ! stringstack . isEmpty ( ) && stringstack . pe 		      stringstack.pop ( )			    		for j in range ( count ) :			  
	temp = stringstack . peek ( ) + temp ;		      		  for j in range ( count ) :			    		    result = result + temp			  
	stringstack . pop ( ) ;				      		      result = result + temp			    		for j in range ( len ( result ) ) :		  
      }							      		  for j in range ( len ( result ) ) :		    		    stringstack.append ( result [ j ] )		  
      if ( ! stringstack . empty ( ) && stringstack . peek (  		      stringstack.append ( result [ j ] )	    		result = ""					  
      for ( int j = 0 ;					      		  result = ""					    	    elif c == "[" :					  
      j < count ;					      	      elif ( Str [ i ] == '[' ) :			    		if c.isdigit ( ) :				  
      j ++ ) result = result + temp ;			      		  if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9 		    stringstack.append ( c )			  
      for ( int j = 0 ;					      		      stringstack.append ( Str [ i ] )		    		else :						  
      j < result . length ( ) ;				      		  else :					    		    stringstack.append ( c )			  
      j ++ ) stringstack . push ( result . charAt ( j ) ) ;   		      stringstack.append ( Str [ i ] )		    		    integerstack.append ( 1 )			  
      result = "" ;					      		      integerstack.append ( 1 )			    	    else :						  
    }							      	      else :						    		stringstack.append ( c )			  
    else if ( str . charAt ( i ) == '[' ) {		      		  stringstack.append ( Str [ i ] )		    	while not stringstack :					  
      if ( Character . isDigit ( str . charAt ( i - 1 ) ) ) s 	  while len ( stringstack ) != 0 :			    	    result = stringstack [ - 1 ] + result		  
      else {						      	      result = stringstack [ - 1 ] + result		    	    stringstack.pop ( )					  
	stringstack . push ( str . charAt ( i ) ) ;	      	      stringstack.pop ( )				    	return result						  
	integerstack . push ( 1 ) ;			      	  return result						    								  
      }							      								    								  
    }							      								    								  
    else stringstack . push ( str . charAt ( i ) ) ;	      								    								  
  }							      								    								  
  while ( ! stringstack . isEmpty ( ) ) {		      								    								  
    result = stringstack . peek ( ) + result ;		      								    								  
    stringstack . pop ( ) ;				      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE		      NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE		    NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE		  NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE
--							      --							    --								  --
static int numberofways ( String A , String B , int N , int M def numberofways ( A , B , N , M ) :			    def numberofways ( A , B , N , M ) :			  script_not_found : None
  Vector < Integer > [ ] pos = new Vector [ MAX ] ;	      	  pos = [ [ ] for _ in range ( MAX ) ]			    	pos = [ [ ] for i in range ( MAX ) ]			  
  for ( int i = 0 ;					      	  for i in range ( M ) :				    	for i in range ( M ) :					  
  i < MAX ;						      	      pos [ ord ( B [ i ] ) ].append ( i + 1 )		    	    pos [ B [ i ] ].append ( i + 1 )			  
  i ++ ) pos [ i ] = new Vector < > ( ) ;		      	  dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ]	    	dpl = np.zeros ( ( N + 2 , M + 2 ) )			  
  for ( int i = 0 ;					      	  for i in range ( 1 , N + 1 ) :			    	for i in range ( 1 , N + 1 ) :				  
  i < M ;						      	      for j in range ( 1 , M + 1 ) :			    	    for j in range ( 1 , M + 1 ) :			  
  i ++ ) pos [ B . charAt ( i ) ] . add ( i + 1 ) ;	      		  if A [ i - 1 ] == B [ j - 1 ] :		    		if A [ i - 1 ] == B [ j - 1 ] :			  
  int [ ] [ ] dpl = new int [ N + 2 ] [ M + 2 ] ;	      		      dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 		    dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 
  for ( int i = 1 ;					      		  else :					    		else :						  
  i <= N ;						      		      dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , 		    dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , 
  i ++ ) {						      	  LCS = dpl [ N ] [ M ]					    	LCS = dpl [ N ] [ M ]					  
    for ( int j = 1 ;					      	  dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ]	    	dpr = np.zeros ( ( N + 2 , M + 2 ) )			  
    j <= M ;						      	  for i in range ( N , 0 , - 1 ) :			    	for i in range ( N , 1 , - 1 ) :			  
    j ++ ) {						      	      for j in range ( M , 0 , - 1 ) :			    	    for j in range ( M , 1 , - 1 ) :			  
      if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpl 		  if A [ i - 1 ] == B [ j - 1 ] :		    		if A [ i - 1 ] == B [ j - 1 ] :			  
      else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] 		      dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 		    dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 
    }							      		  else :					    		else :						  
  }							      		      dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , 		    dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , 
  int LCS = dpl [ N ] [ M ] ;				      	  ans = 0						    	ans = 0							  
  int [ ] [ ] dpr = new int [ N + 2 ] [ M + 2 ] ;	      	  for i in range ( N + 1 ) :				    	for i in range ( 0 , N + 1 ) :				  
  for ( int i = N ;					      	      for j in range ( MAX ) :				    	    for j in range ( MAX ) :				  
  i >= 1 ;						      		  for x in pos [ j ] :				    		for x in pos [ j ] :				  
  i -- ) {						      		      if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x +  		    if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x +  
    for ( int j = M ;					      			  ans += 1				    			ans += 1				  
    j >= 1 ;						      			  break					    			break					  
    j -- ) {						      	  return ans						    	return ans						  
      if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpr 								    								  
      else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] 								    								  
    }							      								    								  
  }							      								    								  
  int ans = 0 ;						      								    								  
  for ( int i = 0 ;					      								    								  
  i <= N ;						      								    								  
  i ++ ) {						      								    								  
    for ( int j = 0 ;					      								    								  
    j < MAX ;						      								    								  
    j ++ ) {						      								    								  
      for ( int x : pos [ j ] ) {			      								    								  
	if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == 								    								  
	  ans ++ ;					      								    								  
	  break ;					      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
