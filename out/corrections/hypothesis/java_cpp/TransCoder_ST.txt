========================SOURCE============================    ==========================REF=============================    =========================HYPO=============================	  ==========================OUT=============================
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			      MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			    MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			  MAXIMUM_POINTS_INTERSECTION_N_CIRCLES
--							      --							    --								  --
static int intersection ( int n ) {			      int intersection ( int n ) {				    int intersection ( int n ) {				  success : identical to gold
  return n * ( n - 1 ) ;				      	return n * ( n - 1 ) ;					      return n * ( n - 1 ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_AREA_SQUARE					      PROGRAM_AREA_SQUARE					    PROGRAM_AREA_SQUARE						  PROGRAM_AREA_SQUARE
--							      --							    --								  --
static int areaSquare ( int side ) {			      int areaSquare ( int side ) {				    int area_square ( int side ) {				  success : None
  int area = side * side ;				      	int area = side * side ;				      int area = side * side ;					  
  return area ;						      	return area ;						      return area ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TURN_OFF_THE_RIGHTMOST_SET_BIT				      TURN_OFF_THE_RIGHTMOST_SET_BIT				    TURN_OFF_THE_RIGHTMOST_SET_BIT				  TURN_OFF_THE_RIGHTMOST_SET_BIT
--							      --							    --								  --
static int fun ( int n ) {				      int fun ( unsigned int n ) {				    int fun ( int n ) {						  success : None
  return n & ( n - 1 ) ;				      	return n & ( n - 1 ) ;					      return n & ( n - 1 ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEXAGONAL_NUMBER					      HEXAGONAL_NUMBER						    HEXAGONAL_NUMBER						  HEXAGONAL_NUMBER
--							      --							    --								  --
int hexagonalNum ( int n ) {				      int hexagonalNum ( int n ) {				    int hexagonalNum ( int n ) {				  success : identical to gold
  return n * ( 2 * n - 1 ) ;				      	return n * ( 2 * n - 1 ) ;				      return n * ( 2 * n - 1 ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CASSINIS_IDENTITY					      CASSINIS_IDENTITY						    CASSINIS_IDENTITY						  CASSINIS_IDENTITY
--							      --							    --								  --
static int cassini ( int n ) {				      int cassini ( int n ) {					    int cassini ( int n ) {					  success : identical to gold
  return ( n & 1 ) != 0 ? - 1 : 1 ;			      	return ( n & 1 ) ? - 1 : 1 ;				      return ( n & 1 ) ? - 1 : 1 ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ADD_1_TO_A_GIVEN_NUMBER_1				      ADD_1_TO_A_GIVEN_NUMBER_1					    ADD_1_TO_A_GIVEN_NUMBER_1					  ADD_1_TO_A_GIVEN_NUMBER_1
--							      --							    --								  --
static int addOne ( int x ) {				      int addOne ( int x ) {					    int addOne ( int x ) {					  success : identical to gold
  return ( - ( ~ x ) ) ;				      	return ( - ( ~ x ) ) ;					      return ( - ( ~ x ) ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
AREA_SQUARE_CIRCUMSCRIBED_CIRCLE			      AREA_SQUARE_CIRCUMSCRIBED_CIRCLE				    AREA_SQUARE_CIRCUMSCRIBED_CIRCLE				  AREA_SQUARE_CIRCUMSCRIBED_CIRCLE
--							      --							    --								  --
static int find_Area ( int r ) {			      int find_Area ( int r ) {					    int find_Area ( int r ) {					  success : identical to gold
  return ( 2 * r * r ) ;				      	return ( 2 * r * r ) ;					      return ( 2 * r * r ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			      FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			    FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			  FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT
--							      --							    --								  --
static boolean check ( int n ) {			      bool check ( int n ) {					    bool check ( int n ) {					  success : identical to gold
  return 1162261467 % n == 0 ;				      	return 1162261467 % n == 0 ;				      return 1162261467 % n == 0 ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD			      CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD			    CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD				  CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD
--							      --							    --								  --
public static boolean isEven ( int n ) {		      bool isEven ( int n ) {					    bool IsEven ( int n ) {					  success : None
  return ( n % 2 == 0 ) ;				      	return ( n % 2 == 0 ) ;					      return ( n % 2 == 0 ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_PENTAGONAL_NUMBER					      NTH_PENTAGONAL_NUMBER					    NTH_PENTAGONAL_NUMBER					  NTH_PENTAGONAL_NUMBER
--							      --							    --								  --
int pentagonalNum ( int n ) {				      int pentagonalNum ( int n ) {				    int pentagonalNum ( int n ) {				  success : identical to gold
  return ( 3 * n * n - n ) / 2 ;			      	return ( 3 * n * n - n ) / 2 ;				      return ( 3 * n * n - n ) / 2 ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE
--							      --							    --								  --
int Circumference ( int a ) {				      int Circumference ( int a ) {				    int Circumference ( int a ) {				  success : identical to gold
  return 4 * a ;					      	return 4 * a ;						      return 4 * a ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TRIANGULAR_MATCHSTICK_NUMBER				      TRIANGULAR_MATCHSTICK_NUMBER				    TRIANGULAR_MATCHSTICK_NUMBER				  TRIANGULAR_MATCHSTICK_NUMBER
--							      --							    --								  --
public static int numberOfSticks ( int x ) {		      int numberOfSticks ( int x ) {				    int numberOfSticks ( int x ) {				  success : identical to gold
  return ( 3 * x * ( x + 1 ) ) / 2 ;			      	return ( 3 * x * ( x + 1 ) ) / 2 ;			      return ( 3 * x * ( x + 1 ) ) / 2 ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HYPERCUBE_GRAPH						      HYPERCUBE_GRAPH						    HYPERCUBE_GRAPH						  HYPERCUBE_GRAPH
--							      --							    --								  --
static int power ( int n ) {				      int power ( int n ) {					    int power ( int n ) {					  success : identical to gold
  if ( n == 1 ) return 2 ;				      	if ( n == 1 ) return 2 ;				      if ( n == 1 ) return 2 ;					  
  return 2 * power ( n - 1 ) ;				      	return 2 * power ( n - 1 ) ;				      return 2 * power ( n - 1 ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		      COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		    COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		  COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW
--							      --							    --								  --
static int compute_average ( int a , int b ) {		      int compute_average ( int a , int b ) {			    int compute_average ( int a , int b ) {			  success : identical to gold
  return ( a + b ) / 2 ;				      	return ( a + b ) / 2 ;					      return ( a + b ) / 2 ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_BINOMIAL_COEFFICIENTS_1				      SUM_BINOMIAL_COEFFICIENTS_1				    SUM_BINOMIAL_COEFFICIENTS_1					  SUM_BINOMIAL_COEFFICIENTS_1
--							      --							    --								  --
static int binomialCoeffSum ( int n ) {			      int binomialCoeffSum ( int n ) {				    int binomialCoeffSum ( int n ) {				  success : identical to gold
  return ( 1 << n ) ;					      	return ( 1 << n ) ;					      return ( 1 << n ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_TWO_HALVES_SORTED				      SORT_ARRAY_TWO_HALVES_SORTED				    SORT_ARRAY_TWO_HALVES_SORTED				  SORT_ARRAY_TWO_HALVES_SORTED
--							      --							    --								  --
static void mergeTwoHalf ( int [ ] A , int n ) {	      void mergeTwoHalf ( int A [ ] , int n ) {			    void mergeTwoHalf ( int * A , int n ) {			  success : None
  Arrays . sort ( A ) ;					      	sort ( A , A + n ) ;					      std :: sort ( A , A + n ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GCD_ELEMENTS_GIVEN_RANGE				      GCD_ELEMENTS_GIVEN_RANGE					    GCD_ELEMENTS_GIVEN_RANGE					  GCD_ELEMENTS_GIVEN_RANGE
--							      --							    --								  --
static int rangeGCD ( int n , int m ) {			      int rangeGCD ( int n , int m ) {				    int rangeGCD ( int n , int m ) {				  success : identical to gold
  return ( n == m ) ? n : 1 ;				      	return ( n == m ) ? n : 1 ;				      return ( n == m ) ? n : 1 ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1			      PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1			    PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1				  PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1
--							      --							    --								  --
static int summingSeries ( long n ) {			      int summingSeries ( long n ) {				    int summing_series ( long n ) {				  success : None
  return ( int ) Math . pow ( n , 2 ) ;			      	return pow ( n , 2 ) ;					      return ( int ) pow ( n , 2 ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_CIRCUMFERENCE_CIRCLE			      PROGRAM_FIND_CIRCUMFERENCE_CIRCLE				    PROGRAM_FIND_CIRCUMFERENCE_CIRCLE				  PROGRAM_FIND_CIRCUMFERENCE_CIRCLE
--							      --							    --								  --
static double circumference ( double r ) {		      double circumference ( double r ) {			    double circumference ( double r ) {				  script_not_found : None
  double PI = 3.1415 ;					      	double cir = 2 * PI * r ;				      double PI = 3.1415 ;					  
  double cir = 2 * PI * r ;				      	return cir ;						      double cir = 2 * PI * r ;					  
  return cir ;						      }								      return cir ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_AN_INTEGER_WITH_3_5				      MULTIPLY_AN_INTEGER_WITH_3_5				    MULTIPLY_AN_INTEGER_WITH_3_5				  MULTIPLY_AN_INTEGER_WITH_3_5
--							      --							    --								  --
static int multiplyWith3Point5 ( int x ) {		      int multiplyWith3Point5 ( int x ) {			    int multiplyWith3Point5 ( int x ) {				  success : identical to gold
  return ( x << 1 ) + x + ( x >> 1 ) ;			      	return ( x << 1 ) + x + ( x >> 1 ) ;			      return ( x << 1 ) + x + ( x >> 1 ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			      CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			    CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			  CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1
--							      --							    --								  --
public static boolean isEven ( int n ) {		      bool isEven ( int n ) {					    bool isEven ( int n ) {					  success : None
  if ( ( n & 1 ) == 0 ) return true ;			      	return ( ! ( n & 1 ) ) ;				      if ( ( n & 1 ) == 0 ) return true ;			  
  else return false ;					      }								      else return false ;					  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FACTORIAL_NUMBER				      C_PROGRAM_FACTORIAL_NUMBER				    C_PROGRAM_FACTORIAL_NUMBER					  C_PROGRAM_FACTORIAL_NUMBER
--							      --							    --								  --
static int factorial ( int n ) {			      unsigned int factorial ( unsigned int n ) {		    int factorial ( int n ) {					  success : None
  if ( n == 0 ) return 1 ;				      	if ( n == 0 ) return 1 ;				      if ( n == 0 ) return 1 ;					  
  return n * factorial ( n - 1 ) ;			      	return n * factorial ( n - 1 ) ;			      return n * factorial ( n - 1 ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES		      HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES			    HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES			  HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES
--							      --							    --								  --
static int height ( int N ) {				      int height ( int N ) {					    int height ( int N ) {					  success : None
  return ( int ) Math . ceil ( Math . log ( N + 1 ) / Math .  	return ceil ( log2 ( N + 1 ) ) - 1 ;			      return ( int ) ceil ( log ( N + 1 ) / log ( 2 ) ) - 1 ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			      C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			    C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			  C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1
--							      --							    --								  --
static int largest ( int [ ] arr , int n ) {		      int largest ( int arr [ ] , int n ) {			    int largest ( int * arr , int n ) {				  success : None
  Arrays . sort ( arr ) ;				      	return * max_element ( arr , arr + n ) ;		      sort ( arr , arr + n ) ;					  
  return arr [ n - 1 ] ;				      }								      return arr [ n - 1 ] ;					  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_SLOPE_LINE					      PROGRAM_FIND_SLOPE_LINE					    PROGRAM_FIND_SLOPE_LINE					  PROGRAM_FIND_SLOPE_LINE
--							      --							    --								  --
static float slope ( float x1 , float y1 , float x2 , float y float slope ( float x1 , float y1 , float x2 , float y2 ) {   float slope ( float x1 , float y1 , float x2 , float y2 ) {	  success : identical to gold
  return ( y2 - y1 ) / ( x2 - x1 ) ;			      	return ( y2 - y1 ) / ( x2 - x1 ) ;			      return ( y2 - y1 ) / ( x2 - x1 ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_FACTORIAL_OF_A_NUMBER			      PROGRAM_FOR_FACTORIAL_OF_A_NUMBER				    PROGRAM_FOR_FACTORIAL_OF_A_NUMBER				  PROGRAM_FOR_FACTORIAL_OF_A_NUMBER
--							      --							    --								  --
static int factorial ( int n ) {			      unsigned int factorial ( unsigned int n ) {		    int factorial ( int n ) {					  success : None
  if ( n == 0 ) return 1 ;				      	if ( n == 0 ) return 1 ;				      if ( n == 0 ) return 1 ;					  
  return n * factorial ( n - 1 ) ;			      	return n * factorial ( n - 1 ) ;			      return n * factorial ( n - 1 ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SUBSTRINGS_STRING				      NUMBER_SUBSTRINGS_STRING					    NUMBER_SUBSTRINGS_STRING					  NUMBER_SUBSTRINGS_STRING
--							      --							    --								  --
static int countNonEmptySubstr ( String str ) {		      int countNonEmptySubstr ( string str ) {			    int countNonEmptySubstr ( string str ) {			  success : identical to gold
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  return n * ( n + 1 ) / 2 ;				      	return n * ( n + 1 ) / 2 ;				      return n * ( n + 1 ) / 2 ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS		      DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS		    DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS			  DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS
--							      --							    --								  --
static boolean oppositeSigns ( int x , int y ) {	      bool oppositeSigns ( int x , int y ) {			    bool oppositeSigns ( int x , int y ) {			  success : identical to gold
  return ( ( x ^ y ) < 0 ) ;				      	return ( ( x ^ y ) < 0 ) ;				      return ( ( x ^ y ) < 0 ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_TWO_NIBBLES_BYTE					      SWAP_TWO_NIBBLES_BYTE					    SWAP_TWO_NIBBLES_BYTE					  SWAP_TWO_NIBBLES_BYTE
--							      --							    --								  --
static int swapNibbles ( int x ) {			      int swapNibbles ( int x ) {				    int swapNibbles ( int x ) {					  success : identical to gold
  return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ;	      	return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ;	      return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			      PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			    PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			  PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES
--							      --							    --								  --
static int findMaximumPieces ( int n ) {		      int findMaximumPieces ( int n ) {				    int findMaximumPieces ( int n ) {				  success : identical to gold
  return 1 + n * ( n + 1 ) / 2 ;			      	return 1 + n * ( n + 1 ) / 2 ;				      return 1 + n * ( n + 1 ) / 2 ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		      COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		    COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		  COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER
--							      --							    --								  --
static int getModulo ( int n , int d ) {		      unsigned int getModulo ( unsigned int n , unsigned int d ) {  int getModulo ( int n , int d ) {				  success : None
  return ( n & ( d - 1 ) ) ;				      	return ( n & ( d - 1 ) ) ;				      return ( n & ( d - 1 ) ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_TERM_SERIES_2_12_36_80_150				      N_TH_TERM_SERIES_2_12_36_80_150				    N_TH_TERM_SERIES_2_12_36_80_150				  N_TH_TERM_SERIES_2_12_36_80_150
--							      --							    --								  --
public static int nthTerm ( int n ) {			      int nthTerm ( int n ) {					    int nthTerm ( int n ) {					  success : identical to gold
  return ( n * n ) + ( n * n * n ) ;			      	return ( n * n ) + ( n * n * n ) ;			      return ( n * n ) + ( n * n * n ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_INCREASING_SUBSEQUENCE				      LONGEST_INCREASING_SUBSEQUENCE				    LONGEST_INCREASING_SUBSEQUENCE				  LONGEST_INCREASING_SUBSEQUENCE
--							      --							    --								  --
static int lis ( int arr [ ] , int n ) {		      int lis ( int arr [ ] , int n ) {				    int lis ( int arr [ ] , int n ) {				  script_not_found : None
  max_ref = 1 ;						      	int max = 1 ;						      max_ref = 1 ;						  
  _lis ( arr , n ) ;					      	_lis ( arr , n , & max ) ;				      _lis ( arr , n ) ;					  
  return max_ref ;					      	return max ;						      return max_ref ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			      BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			    BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			  BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS
--							      --							    --								  --
public static int gcd ( int a , int b ) {		      int gcd ( int a , int b ) {				    int gcd ( int a , int b ) {					  success : identical to gold
  if ( a == 0 ) return b ;				      	if ( a == 0 ) return b ;				      if ( a == 0 ) return b ;					  
  return gcd ( b % a , a ) ;				      	return gcd ( b % a , a ) ;				      return gcd ( b % a , a ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BREAK_NUMBER_THREE_PARTS_1				      BREAK_NUMBER_THREE_PARTS_1				    BREAK_NUMBER_THREE_PARTS_1					  BREAK_NUMBER_THREE_PARTS_1
--							      --							    --								  --
static long count_of_ways ( long n ) {			      ll count_of_ways ( ll n ) {				    long long count_of_ways ( long long n ) {			  script_not_found : None
  long count = 0 ;					      	ll count ;						      long long count = 0 ;					  
  count = ( n + 1 ) * ( n + 2 ) / 2 ;			      	count = ( n + 1 ) * ( n + 2 ) / 2 ;			      count = ( n + 1 ) * ( n + 2 ) / 2 ;			  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1		      FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1		    FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1			  FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1
--							      --							    --								  --
static int evenbinomialCoeffSum ( int n ) {		      int evenbinomialCoeffSum ( int n ) {			    int evenbinomialCoeffSum ( int n ) {			  success : identical to gold
  return ( 1 << ( n - 1 ) ) ;				      	return ( 1 << ( n - 1 ) ) ;				      return ( 1 << ( n - 1 ) ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR    PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR    PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR	  PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR
--							      --							    --								  --
static int getRemainder ( int num , int divisor ) {	      int getRemainder ( int num , int divisor ) {		    int getRemainder ( int num , int divisor ) {		  success : identical to gold
  return ( num - divisor * ( num / divisor ) ) ;	      	return ( num - divisor * ( num / divisor ) ) ;		      return ( num - divisor * ( num / divisor ) ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_RECTANGLES_NM_GRID				      NUMBER_RECTANGLES_NM_GRID					    NUMBER_RECTANGLES_NM_GRID					  NUMBER_RECTANGLES_NM_GRID
--							      --							    --								  --
public static long rectCount ( int n , int m ) {	      int rectCount ( int n , int m ) {				    long long rectCount ( int n , int m ) {			  success : None
  return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;	      	return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;		      return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10
--							      --							    --								  --
static boolean isMultipleOf10 ( int n ) {		      bool isMultipleOf10 ( int n ) {				    bool isMultipleOf10 ( int n ) {				  success : None
  if ( n % 15 == 0 ) return true ;			      	return ( n % 15 == 0 ) ;				      if ( n % 15 == 0 ) return true ;				  
  return false ;					      }								      return false ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_AREA_OCTAGON				      PROGRAM_CALCULATE_AREA_OCTAGON				    PROGRAM_CALCULATE_AREA_OCTAGON				  PROGRAM_CALCULATE_AREA_OCTAGON
--							      --							    --								  --
static double areaOctagon ( double side ) {		      double areaOctagon ( double side ) {			    double area_octagon ( double side ) {			  success : None
  return ( float ) ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * s 	return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ;   return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ; 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			      PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			    PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			  PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON
--							      --							    --								  --
static double surface_area_octahedron ( double side ) {	      double surface_area_octahedron ( double side ) {		    double surface_area_octahedron ( double side ) {		  success : identical to gold
  return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ;    	return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ;	      return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS_2					      SUM_PAIRWISE_PRODUCTS_2					    SUM_PAIRWISE_PRODUCTS_2					  SUM_PAIRWISE_PRODUCTS_2
--							      --							    --								  --
static int findSum ( int n ) {				      long long int findSum ( int n ) {				    int findSum ( int n ) {					  success : None
  return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ;     	return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ;	      return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_VOLUME_OCTAHEDRON			      PROGRAM_CALCULATE_VOLUME_OCTAHEDRON			    PROGRAM_CALCULATE_VOLUME_OCTAHEDRON				  PROGRAM_CALCULATE_VOLUME_OCTAHEDRON
--							      --							    --								  --
static double vol_of_octahedron ( double side ) {	      double vol_of_octahedron ( double side ) {		    double vol_of_octahedron ( double side ) {			  success : identical to gold
  return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) 	return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ) ;      return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		      PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		    PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		  PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP
--							      --							    --								  --
static double procal ( int n ) {			      double procal ( int n ) {					    double procal ( int n ) {					  success : identical to gold
  return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;	      	return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;		      return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_3				      COUNT_SET_BITS_IN_AN_INTEGER_3				    COUNT_SET_BITS_IN_AN_INTEGER_3				  COUNT_SET_BITS_IN_AN_INTEGER_3
--							      --							    --								  --
public static int countSetBits ( int n ) {		      int countSetBits ( int n ) {				    int countSetBits ( int n ) {				  success : identical to gold
  if ( n == 0 ) return 0 ;				      	if ( n == 0 ) return 0 ;				      if ( n == 0 ) return 0 ;					  
  else return 1 + countSetBits ( n & ( n - 1 ) ) ;	      	else return 1 + countSetBits ( n & ( n - 1 ) ) ;	      else return 1 + countSetBits ( n & ( n - 1 ) ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_1				      COUNT_SET_BITS_IN_AN_INTEGER_1				    COUNT_SET_BITS_IN_AN_INTEGER_1				  COUNT_SET_BITS_IN_AN_INTEGER_1
--							      --							    --								  --
public static int countSetBits ( int n ) {		      int countSetBits ( int n ) {				    int countSetBits ( int n ) {				  success : identical to gold
  if ( n == 0 ) return 0 ;				      	if ( n == 0 ) return 0 ;				      if ( n == 0 ) return 0 ;					  
  else return ( n & 1 ) + countSetBits ( n >> 1 ) ;	      	else return ( n & 1 ) + countSetBits ( n >> 1 ) ;	      else return ( n & 1 ) + countSetBits ( n >> 1 ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	      PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	    PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	  PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM
--							      --							    --								  --
static int Resources ( int process , int need ) {	      int Resources ( int process , int need ) {		    int Resources ( int process , int need ) {			  success : identical to gold
  int minResources = 0 ;				      	int minResources = 0 ;					      int minResources = 0 ;					  
  minResources = process * ( need - 1 ) + 1 ;		      	minResources = process * ( need - 1 ) + 1 ;		      minResources = process * ( need - 1 ) + 1 ;		  
  return minResources ;					      	return minResources ;					      return minResources ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW
--							      --							    --								  --
static boolean isPowerOfTwo ( int x ) {			      int bool isPowerOfTwo ( int x ) {				    bool isPowerOfTwo ( int x ) {				  script_not_found : None
  return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ;		      	return x && ( ! ( x & ( x - 1 ) ) ) ;			      return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_2				      COUNT_SET_BITS_IN_AN_INTEGER_2				    COUNT_SET_BITS_IN_AN_INTEGER_2				  COUNT_SET_BITS_IN_AN_INTEGER_2
--							      --							    --								  --
static int countSetBits ( int n ) {			      public : unsigned int countSetBits ( int n ) {		    int countSetBits ( int n ) {				  script_not_found : None
  int count = 0 ;					      	unsigned int count = 0 ;				      int count = 0 ;						  
  while ( n > 0 ) {					      	while ( n ) {						      while ( n > 0 ) {						  
    n &= ( n - 1 ) ;					      	  n &= ( n - 1 ) ;					    	n &= ( n - 1 ) ;					  
    count ++ ;						      	  count ++ ;						    	count ++ ;						  
  }							      	}							      }								  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_VOLUME_ELLIPSOID			      PROGRAM_CALCULATE_VOLUME_ELLIPSOID			    PROGRAM_CALCULATE_VOLUME_ELLIPSOID				  PROGRAM_CALCULATE_VOLUME_ELLIPSOID
--							      --							    --								  --
public static float volumeOfEllipsoid ( float r1 , float r2 , float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) {  float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) {  success : None
  float pi = ( float ) 3.14 ;				      	float pi = 3.14 ;					      float pi = ( float ) 3.14 ;				  
  return ( float ) 1.33 * pi * r1 * r2 * r3 ;		      	return 1.33 * pi * r1 * r2 * r3 ;			      return ( float ) 1.33 * pi * r1 * r2 * r3 ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE      DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE	    DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE
--							      --							    --								  --
static int lis ( int arr [ ] , int n ) {		      int lis ( int arr [ ] , int n ) {				    int lis ( int arr [ ] , int n ) {				  script_not_found : None
  max_ref = 1 ;						      	int max = 1 ;						      max_ref = 1 ;						  
  _lis ( arr , n ) ;					      	_lis ( arr , n , & max ) ;				      _lis ( arr , n ) ;					  
  return max_ref ;					      	return max ;						      return max_ref ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS		      SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS			    SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS			  SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS
--							      --							    --								  --
static double sumOfSeries ( int n ) {			      float sumOfSeries ( int n ) {				    double sum_of_series ( int n ) {				  success : None
  return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ;      	return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ;		      return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1			      PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1			    PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1				  PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1
--							      --							    --								  --
static int factorial ( int n ) {			      unsigned int factorial ( unsigned int n ) {		    int factorial ( int n ) {					  success : None
  int res = 1 , i ;					      	int res = 1 , i ;					      int res = 1 , i ;						  
  for ( i = 2 ;						      	for ( i = 2 ;						      for ( i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) res *= i ;					      	i ++ ) res *= i ;					      i ++ ) {							  
  return res ;						      	return res ;						    	res *= i ;						  
}							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_CONTAIN_1_N_VALUES				      SORT_ARRAY_CONTAIN_1_N_VALUES				    SORT_ARRAY_CONTAIN_1_N_VALUES				  SORT_ARRAY_CONTAIN_1_N_VALUES
--							      --							    --								  --
static void sortit ( int [ ] arr , int n ) {		      void sortit ( int arr [ ] , int n ) {			    void sortit ( int * arr , int n ) {				  success : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) arr [ i ] = i + 1 ;				  
    arr [ i ] = i + 1 ;					      	  arr [ i ] = i + 1 ;					    }								  
  }							      	}							    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_PALINDROME_SUBSTRING_SET_1			      LONGEST_PALINDROME_SUBSTRING_SET_1			    LONGEST_PALINDROME_SUBSTRING_SET_1				  LONGEST_PALINDROME_SUBSTRING_SET_1
--							      --							    --								  --
static void printSubStr ( String str , int low , int high ) { void printSubStr ( string str , int low , int high ) {	    void print_sub_str ( string str , int low , int high ) {	  script_not_found : None
  System . out . println ( str . substring ( low , high + 1 ) 	for ( int i = low ;					      cout << str . substr ( low , high + 1 ) << endl ;		  
}							      	i <= high ;						    }								  
							      	++ i ) cout << str [ i ] ;				    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1		      BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1			    BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1			  BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1
--							      --							    --								  --
static void bin ( Integer n ) {				      void bin ( unsigned n ) {					    void bin ( int32_t n ) {					  script_not_found : None
  if ( n > 1 ) bin ( n >> 1 ) ;				      	if ( n > 1 ) bin ( n >> 1 ) ;				      if ( n > 1 ) {						  
  System . out . printf ( "%d" , n & 1 ) ;		      	printf ( "%d" , n & 1 ) ;				    	bin ( n >> 1 ) ;					  
}							      }								      }								  
							      								      printf ( "%d" , n & 1 ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1     SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1	    SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1	  SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1
--							      --							    --								  --
static long calculateSum ( int n ) {			      long long int calculateSum ( int n ) {			    long long calculateSum ( int n ) {				  success : None
  long sum = 0 ;					      	long long int sum = 0 ;					      long long sum = 0 ;					  
  sum = 1 << n ;					      	sum = 1 << n ;						      sum = 1 << n ;						  
  return ( sum - 1 ) ;					      	return ( sum - 1 ) ;					      return ( sum - 1 ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT     PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT	    PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT	  PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT
--							      --							    --								  --
static int assignValue ( int a , int b , int x ) {	      int assignValue ( int a , int b , bool x ) {		    int assign_value ( int a , int b , int x ) {		  failure : #Results: 0, 10
  int arr [ ] = {					      	int arr [ ] = {						      int arr [ ] = {						  
    a , b }						      	  a , b }						    	a , b }							  
    ;							      	  ;							    	;							  
    return ( arr [ x ] ) ;				      	  return ( arr [ x ] ) ;				    	return ( arr [ x ] ) ;					  
  }							      	}							      }								  
  -							      	-							      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY		      KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY		    KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY			  KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY
--							      --							    --								  --
public static int kthSmallest ( Integer [ ] arr , int k ) {   int kthSmallest ( int arr [ ] , int n , int k ) {		    int kthSmallest ( int32_t * arr , int k ) {			  script_not_found : None
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      std :: sort ( arr , arr + k ) ;				  
  return arr [ k - 1 ] ;				      	return arr [ k - 1 ] ;					      return arr [ k - 1 ] ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		      C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		    C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		  C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES
--							      --							    --								  --
static String repeat ( String s , int n ) {		      string repeat ( string s , int n ) {			    string repeat ( string s , int n ) {			  success : None
  String s1 = s ;					      	string s1 = s ;						      string s1 = s ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) s += s1 ;					      	i ++ ) s += s1 ;					      i ++ ) {							  
  return s ;						      	return s ;						    	s += s1 ;						  
}							      }								      }								  
							      								      return s ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I
--							      --							    --								  --
static float getArea ( int a ) {			      float getArea ( int a ) {					    float getArea ( int a ) {					  success : None
  float area = ( float ) ( Math . PI * a * a ) / 4 ;	      	float area = ( M_PI * a * a ) / 4.0 ;			      float area = ( float ) ( M_PI * a * a ) / 4 ;		  
  return area ;						      	return area ;						      return area ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		      HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		    HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		  HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER
--							      --							    --								  --
static int turnOffK ( int n , int k ) {			      int turnOffK ( int n , int k ) {				    int turnOffK ( int n , int k ) {				  success : identical to gold
  if ( k <= 0 ) return n ;				      	if ( k <= 0 ) return n ;				      if ( k <= 0 ) return n ;					  
  return ( n & ~ ( 1 << ( k - 1 ) ) ) ;			      	return ( n & ~ ( 1 << ( k - 1 ) ) ) ;			      return ( n & ~ ( 1 << ( k - 1 ) ) ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES		      MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES		    MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES			  MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES
--							      --							    --								  --
static int fib ( int n ) {				      int fib ( int n ) {					    int fib ( int n ) {						  script_not_found : None
  if ( n <= 1 ) return n ;				      	if ( n <= 1 ) return n ;				      if ( n <= 1 ) return n ;					  
  return fib ( n - 1 ) + fib ( n - 2 ) ;		      	return fib ( n - 1 ) + fib ( n - 2 ) ;			      return fib ( n - 1 ) + fib ( n - 2 ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS
--							      --							    --								  --
static int maxSquare ( int b , int m ) {		      int maxSquare ( int b , int m ) {				    int maxSquare ( int b , int m ) {				  success : identical to gold
  return ( b / m - 1 ) * ( b / m ) / 2 ;		      	return ( b / m - 1 ) * ( b / m ) / 2 ;			      return ( b / m - 1 ) * ( b / m ) / 2 ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIME_NUMBERS						      PRIME_NUMBERS						    PRIME_NUMBERS						  PRIME_NUMBERS
--							      --							    --								  --
static boolean isPrime ( int n ) {			      bool isPrime ( int n ) {					    bool isPrime ( int n ) {					  success : identical to gold
  if ( n <= 1 ) return false ;				      	if ( n <= 1 ) return false ;				      if ( n <= 1 ) return false ;				  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( n % i == 0 ) return false ;		      	i ++ ) if ( n % i == 0 ) return false ;			      i ++ ) if ( n % i == 0 ) return false ;			  
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	      COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	    COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	  COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1
--							      --							    --								  --
static int countStr ( int n ) {				      int countStr ( int n ) {					    int countStr ( int n ) {					  success : identical to gold
  return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ;      	return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ;	      return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_DIVISORS_1_N_1					      SUM_DIVISORS_1_N_1					    SUM_DIVISORS_1_N_1						  SUM_DIVISORS_1_N_1
--							      --							    --								  --
static int divisorSum ( int n ) {			      int divisorSum ( int n ) {				    int divisorSum ( int n ) {					  success : None
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  ++ i ) sum += ( n / i ) * i ;				      	++ i ) sum += ( n / i ) * i ;				      ++ i ) {							  
  return sum ;						      	return sum ;						    	sum += ( n / i ) * i ;					  
}							      }								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_CONWAY_SEQUENCE					      NEWMAN_CONWAY_SEQUENCE					    NEWMAN_CONWAY_SEQUENCE					  NEWMAN_CONWAY_SEQUENCE
--							      --							    --								  --
static int sequence ( int n ) {				      int sequence ( int n ) {					    int sequence ( int n ) {					  script_not_found : None
  if ( n == 1 || n == 2 ) return 1 ;			      	if ( n == 1 || n == 2 ) return 1 ;			      if ( n == 1 || n == 2 ) return 1 ;			  
  else return sequence ( sequence ( n - 1 ) ) + sequence ( n  	else return sequence ( sequence ( n - 1 ) ) + sequence ( n    else return sequence ( sequence ( n - 1 ) ) + sequence ( n  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING      COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING	    COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING	  COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING
--							      --							    --								  --
static int getAbs ( int n ) {				      unsigned int getAbs ( int n ) {				    int getAbs ( int n ) {					  script_not_found : None
  int mask = n >> ( SIZE_INT * CHAR_BIT - 1 ) ;		      	int const mask = n >> ( sizeof ( int ) * CHARBIT - 1 ) ;      int mask = n >> ( SIZE_INT * CHAR_BIT - 1 ) ;		  
  return ( ( n + mask ) ^ mask ) ;			      	return ( ( n + mask ) ^ mask ) ;			      return ( ( n + mask ) ^ mask ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			      COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			    COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			  COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER
--							      --							    --								  --
static int findTrailingZeros ( int n ) {		      int findTrailingZeros ( int n ) {				    int findTrailingZeros ( int n ) {				  success : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = 5 ;					      	for ( int i = 5 ;					      for ( int i = 5 ;						  
  n / i >= 1 ;						      	n / i >= 1 ;						      n / i >= 1 ;						  
  i *= 5 ) count += n / i ;				      	i *= 5 ) count += n / i ;				      i *= 5 ) {						  
  return count ;					      	return count ;						    	count += n / i ;					  
}							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ADD_1_TO_A_GIVEN_NUMBER					      ADD_1_TO_A_GIVEN_NUMBER					    ADD_1_TO_A_GIVEN_NUMBER					  ADD_1_TO_A_GIVEN_NUMBER
--							      --							    --								  --
static int addOne ( int x ) {				      int addOne ( int x ) {					    int addOne ( int x ) {					  success : None
  int m = 1 ;						      	int m = 1 ;						      int m = 1 ;						  
  while ( ( int ) ( x & m ) >= 1 ) {			      	while ( x & m ) {					      while ( ( int ) ( x & m ) >= 1 ) {			  
    x = x ^ m ;						      	  x = x ^ m ;						    	x = x ^ m ;						  
    m <<= 1 ;						      	  m <<= 1 ;						    	m <<= 1 ;						  
  }							      	}							      }								  
  x = x ^ m ;						      	x = x ^ m ;						      x = x ^ m ;						  
  return x ;						      	return x ;						      return x ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		      COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		    COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		  COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ
--							      --							    --								  --
public static int find ( int n , int k ) {		      int find ( int n , int k ) {				    int find ( int n , int k ) {				  success : identical to gold
  if ( n + 1 >= k ) return ( k - 1 ) ;			      	if ( n + 1 >= k ) return ( k - 1 ) ;			      if ( n + 1 >= k ) return ( k - 1 ) ;			  
  else return ( 2 * n + 1 - k ) ;			      	else return ( 2 * n + 1 - k ) ;				      else return ( 2 * n + 1 - k ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		      CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		    CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		  CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN
--							      --							    --								  --
public static int checkValidity ( int a , int b , int c ) {   bool checkValidity ( int a , int b , int c ) {		    int checkValidity ( int a , int b , int c ) {		  success : None
  if ( a + b <= c || a + c <= b || b + c <= a ) return 0 ;    	if ( a + b <= c || a + c <= b || b + c <= a ) return false    if ( a + b <= c || a + c <= b || b + c <= a ) return 0 ;	  
  else return 1 ;					      	else return true ;					      else return 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_INPUT_INTEGER_STRING			      PROGRAM_CHECK_INPUT_INTEGER_STRING			    PROGRAM_CHECK_INPUT_INTEGER_STRING				  PROGRAM_CHECK_INPUT_INTEGER_STRING
--							      --							    --								  --
static boolean isNumber ( String s ) {			      bool isNumber ( string s ) {				    bool isNumber ( string s ) {				  success : identical to gold
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < s . length ( ) ;					      	i < s . length ( ) ;					      i < s . length ( ) ;					  
  i ++ ) if ( Character . isDigit ( s . charAt ( i ) ) == fal 	i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ;     i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ;	  
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		      FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		    FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		  FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1
--							      --							    --								  --
double countSquares ( int a , int b ) {			      int countSquares ( int a , int b ) {			    double countSquares ( int a , int b ) {			  script_not_found : None
  return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( 	return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ;   return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ; 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2_1					      NEXT_POWER_OF_2_1						    NEXT_POWER_OF_2_1						  NEXT_POWER_OF_2_1
--							      --							    --								  --
static int nextPowerOf2 ( int n ) {			      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
  int p = 1 ;						      	unsigned int p = 1 ;					      int p = 1 ;						  
  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;	      	if ( n && ! ( n & ( n - 1 ) ) ) return n ;		      if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;		  
  while ( p < n ) p <<= 1 ;				      	while ( p < n ) p <<= 1 ;				      while ( p < n ) {						  
  return p ;						      	return p ;						    	p <<= 1 ;						  
}							      }								      }								  
							      								      return p ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEONARDO_NUMBER						      LEONARDO_NUMBER						    LEONARDO_NUMBER						  LEONARDO_NUMBER
--							      --							    --								  --
static int leonardo ( int n ) {				      int leonardo ( int n ) {					    int leonardo ( int n ) {					  script_not_found : None
  if ( n == 0 || n == 1 ) return 1 ;			      	if ( n == 0 || n == 1 ) return 1 ;			      if ( n == 0 || n == 1 ) return 1 ;			  
  return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ;    	return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ;	      return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE
--							      --							    --								  --
static boolean isPossible ( String str , int n ) {	      bool isPossible ( string str , int n ) {			    bool isPossible ( const std :: string & str , int n ) {	  success : None
  int len = str . length ( ) ;				      	int len = str . length ( ) ;				      std :: size_t len = str . length ( ) ;			  
  if ( len >= n ) return true ;				      	if ( len >= n ) return true ;				      if ( len >= n ) return true ;				  
  return false ;					      	return false ;						      return false ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LINEAR_SEARCH						      LINEAR_SEARCH						    LINEAR_SEARCH						  LINEAR_SEARCH
--							      --							    --								  --
public static int search ( int arr [ ] , int x ) {	      int search ( int arr [ ] , int n , int x ) {		    int search ( int arr [ ] , int x ) {			  script_not_found : None
  int n = arr . length ;				      	int i ;							      int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  for ( int i = 0 ;					      	for ( i = 0 ;						      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) if ( arr [ i ] == x ) return i ;			      i ++ ) {							  
    if ( arr [ i ] == x ) return i ;			      	return - 1 ;						    	if ( arr [ i ] == x ) return i ;			  
  }							      }								      }								  
  return - 1 ;						      								      return - 1 ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_TRIPLET_SUM_ARRAY_1				      MAXIMUM_TRIPLET_SUM_ARRAY_1				    MAXIMUM_TRIPLET_SUM_ARRAY_1					  MAXIMUM_TRIPLET_SUM_ARRAY_1
--							      --							    --								  --
static int maxTripletSum ( int arr [ ] , int n ) {	      int maxTripletSum ( int arr [ ] , int n ) {		    int maxTripletSum ( int arr [ ] , int n ) {			  success : identical to gold
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ;      	return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ;	      return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_EVEN_LENGTH_PALINDROME				      NTH_EVEN_LENGTH_PALINDROME				    NTH_EVEN_LENGTH_PALINDROME					  NTH_EVEN_LENGTH_PALINDROME
--							      --							    --								  --
static String evenlength ( String n ) {			      string evenlength ( string n ) {				    string evenlength ( string n ) {				  success : None
  String res = n ;					      	string res = n ;					      string res = n ;						  
  for ( int j = n . length ( ) - 1 ;			      	for ( int j = n . length ( ) - 1 ;			      for ( int j = n . length ( ) - 1 ;			  
  j >= 0 ;						      	j >= 0 ;						      j >= 0 ;							  
  -- j ) res += n . charAt ( j ) ;			      	-- j ) res += n [ j ] ;					      -- j ) {							  
  return res ;						      	return res ;						    	res += n [ j ] ;					  
}							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER		      FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER			    FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER			  FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER
--							      --							    --								  --
static int findSum ( int N , int K ) {			      int findSum ( int N , int K ) {				    int findSum ( int N , int K ) {				  success : None
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= N ;						      	i <= N ;						      i <= N ;							  
  i ++ ) ans += ( i % K ) ;				      	i ++ ) ans += ( i % K ) ;				      i ++ ) {							  
  return ans ;						      	return ans ;						    	ans += ( i % K ) ;					  
}							      }								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_INTEGER_OVERFLOW_MULTIPLICATION			      CHECK_INTEGER_OVERFLOW_MULTIPLICATION			    CHECK_INTEGER_OVERFLOW_MULTIPLICATION			  CHECK_INTEGER_OVERFLOW_MULTIPLICATION
--							      --							    --								  --
static Boolean isOverflow ( long a , long b ) {		      bool isOverflow ( long long a , long long b ) {		    Boolean isOverflow ( int64_t a , int64_t b ) {		  error : CHECK_INTEGER_OVERFLOW_MULTIPLICATION.cpp:
  if ( a == 0 || b == 0 ) return false ;		      	if ( a == 0 || b == 0 ) return false ;			      if ( a == 0 || b == 0 ) return false ;			  24:1: error: ‘Boolean’ does not name a type  Boole
  long result = a * b ;					      	long long result = a * b ;				      int64_t result = a * b ;					  an f_filled ( int64_t a , int64_t b ) {  ^~~~~~~ C
  if ( a == result / b ) return false ;			      	if ( a == result / b ) return false ;			      if ( a == result / b ) return false ;			  HECK_INTEGER_OVERFLOW_MULTIPLICATION.cpp: In funct
  else return true ;					      	else return true ;					      else return true ;					  ion ‘int main()’: CHECK_INTEGER_OVERFLOW_MULTIPLIC
}							      }								    }								  ATION.cpp:38:12: error: ‘f_filled’ was not declare
							      								    								  d in this scope	   if(f_filled(param0[i],par
							      								    								  am1[i]) == f_gold(param0[i],param1[i]))
							      								    								    ^~~~~~~~ CHECK_INTEGER_OVERFLOW_MULTIPLICATION.c
							      								    								  pp:38:12: note: suggested alternative: ‘f_gold’
							      								    								  	 if(f_filled(param0[i],param1[i]) == f_gold(
							      								    								  param0[i],param1[i]))		    ^~~~~~~~
							      								    								       f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_SHANKS_WILLIAMS_PRIME				      NEWMAN_SHANKS_WILLIAMS_PRIME				    NEWMAN_SHANKS_WILLIAMS_PRIME				  NEWMAN_SHANKS_WILLIAMS_PRIME
--							      --							    --								  --
static int nswp ( int n ) {				      int nswp ( int n ) {					    int nswp ( int n ) {					  script_not_found : None
  if ( n == 0 || n == 1 ) return 1 ;			      	if ( n == 0 || n == 1 ) return 1 ;			      if ( n == 0 || n == 1 ) return 1 ;			  
  return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ;		      	return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ;		      return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTS_PATHS_POINT_REACH_ORIGIN				      COUNTS_PATHS_POINT_REACH_ORIGIN				    COUNTS_PATHS_POINT_REACH_ORIGIN				  COUNTS_PATHS_POINT_REACH_ORIGIN
--							      --							    --								  --
static int countPaths ( int n , int m ) {		      int countPaths ( int n , int m ) {			    int countPaths ( int n , int m ) {				  script_not_found : None
  if ( n == 0 || m == 0 ) return 1 ;			      	if ( n == 0 || m == 0 ) return 1 ;			      if ( n == 0 || m == 0 ) return 1 ;			  
  return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1  	return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1    return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2
--							      --							    --								  --
static boolean isPowerOfFour ( int n ) {		      bool isPowerOfFour ( unsigned int n ) {			    bool isPowerOfFour ( int n ) {				  success : None
  return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAA 	return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAA   return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ( n & 0xAAAA 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSION						      RECURSION							    RECURSION							  RECURSION
--							      --							    --								  --
static void printFun ( int test ) {			      void printFun ( int test ) {				    void print_fun ( int test ) {				  script_not_found : None
  if ( test < 1 ) return ;				      	if ( test < 1 ) return ;				      if ( test < 1 ) return ;					  
  else {						      	else {							      else {							  
    System . out . printf ( "%d " , test ) ;		      	  cout << test << " " ;					    	printf ( "%d " , test ) ;				  
    printFun ( test - 1 ) ;				      	  printFun ( test - 1 ) ;				    	print_fun ( test - 1 ) ;				  
    System . out . printf ( "%d " , test ) ;		      	  cout << test << " " ;					    	printf ( "%d " , test ) ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_VOLUME_DODECAHEDRON				      CALCULATE_VOLUME_DODECAHEDRON				    CALCULATE_VOLUME_DODECAHEDRON				  CALCULATE_VOLUME_DODECAHEDRON
--							      --							    --								  --
static double vol_of_dodecahedron ( int side ) {	      double vol_of_dodecahedron ( int side ) {			    double vol_of_dodecahedron ( int side ) {			  success : identical to gold
  return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( 	return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow (    return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow (  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			      PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			    PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			  PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON
--							      --							    --								  --
static float findArea ( float a ) {			      float findArea ( float a ) {				    float findArea ( float a ) {				  success : None
  float area ;						      	float area ;						      float area ;						  
  area = ( float ) ( Math . sqrt ( 5 * ( 5 + 2 * ( Math . sqr 	area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a )    area = ( float ) ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) )  
  return area ;						      	return area ;						      return area ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY		      MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY			    MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY			  MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY
--							      --							    --								  --
static int minSum ( int [ ] A , int n ) {		      int minSum ( int A [ ] , int n ) {			    int minSum ( int * A , int n ) {				  error : MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.c
  int min_val = Arrays . stream ( A ) . min ( ) . getAsInt (  	int min_val = * min_element ( A , A + n ) ;		      int min_val = std :: min ( A , A + n ) ;			  pp: In function ‘int f_filled(int*, int)’: MINIMUM
  return ( min_val * ( n - 1 ) ) ;			      	return ( min_val * ( n - 1 ) ) ;			      return ( min_val * ( n - 1 ) ) ;				  _SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp:23:28: error
}							      }								    }								  : invalid conversion from ‘int*’ to ‘int’ [-fpermi
							      								    								  ssive]    int min_val = std :: min ( A , A + n ) ;
							      								    								  		    ~~~~~~~~~~~^~~~~~~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LAST_INDEX_CHARACTER_STRING_1			      FIND_LAST_INDEX_CHARACTER_STRING_1			    FIND_LAST_INDEX_CHARACTER_STRING_1				  FIND_LAST_INDEX_CHARACTER_STRING_1
--							      --							    --								  --
static int findLastIndex ( String str , Character x ) {	      int findLastIndex ( string & str , char x ) {		    int findLastIndex ( string str , char x ) {			  script_not_found : None
  for ( int i = str . length ( ) - 1 ;			      	for ( int i = str . length ( ) - 1 ;			      for ( int i = str . length ( ) - 1 ;			  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) if ( str . charAt ( i ) == x ) return i ;	      	i -- ) if ( str [ i ] == x ) return i ;			      i -- ) if ( str [ i ] == x ) return i ;			  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2_2					      NEXT_POWER_OF_2_2						    NEXT_POWER_OF_2_2						  NEXT_POWER_OF_2_2
--							      --							    --								  --
static int nextPowerOf2 ( int n ) {			      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
  n -- ;						      	n -- ;							      n -- ;							  
  n |= n >> 1 ;						      	n |= n >> 1 ;						      n |= n >> 1 ;						  
  n |= n >> 2 ;						      	n |= n >> 2 ;						      n |= n >> 2 ;						  
  n |= n >> 4 ;						      	n |= n >> 4 ;						      n |= n >> 4 ;						  
  n |= n >> 8 ;						      	n |= n >> 8 ;						      n |= n >> 8 ;						  
  n |= n >> 16 ;					      	n |= n >> 16 ;						      n |= n >> 16 ;						  
  n ++ ;						      	n ++ ;							      n ++ ;							  
  return n ;						      	return n ;						      return n ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPETITIVE_ELEMENT_1_N_1				      FIND_REPETITIVE_ELEMENT_1_N_1				    FIND_REPETITIVE_ELEMENT_1_N_1				  FIND_REPETITIVE_ELEMENT_1_N_1
--							      --							    --								  --
static int findRepeating ( int [ ] arr , int n ) {	      int findRepeating ( int arr [ ] , int n ) {		    int findRepeating ( int * arr , int n ) {			  success : None
  int sum = 0 ;						      	return accumulate ( arr , arr + n , 0 ) - ( ( n - 1 ) * n /   int sum = 0 ;						  
  for ( int i = 0 ;					      }								      for ( int i = 0 ;						  
  i < n ;						      								      i < n ;							  
  i ++ ) sum += arr [ i ] ;				      								      i ++ ) {							  
  return sum - ( ( ( n - 1 ) * n ) / 2 ) ;		      								    	sum += arr [ i ] ;					  
}							      								      }								  
							      								      return sum - ( ( ( n - 1 ) * n ) / 2 ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_POWER_PRIME_NUMBER_P_N_1			      FINDING_POWER_PRIME_NUMBER_P_N_1				    FINDING_POWER_PRIME_NUMBER_P_N_1				  FINDING_POWER_PRIME_NUMBER_P_N_1
--							      --							    --								  --
static int PowerOFPINnfactorial ( int n , int p ) {	      int PowerOFPINnfactorial ( int n , int p ) {		    int PowerOFPINnfactorial ( int n , int p ) {		  success : identical to gold
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  int temp = p ;					      	int temp = p ;						      int temp = p ;						  
  while ( temp <= n ) {					      	while ( temp <= n ) {					      while ( temp <= n ) {					  
    ans += n / temp ;					      	  ans += n / temp ;					    	ans += n / temp ;					  
    temp = temp * p ;					      	  temp = temp * p ;					    	temp = temp * p ;					  
  }							      	}							      }								  
  return ans ;						      	return ans ;						      return ans ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_EFFICIENTLY_CALCULATE_EX			      PROGRAM_TO_EFFICIENTLY_CALCULATE_EX			    PROGRAM_TO_EFFICIENTLY_CALCULATE_EX				  PROGRAM_TO_EFFICIENTLY_CALCULATE_EX
--							      --							    --								  --
static float exponential ( int n , float x ) {		      float exponential ( int n , float x ) {			    float exponential ( int n , float x ) {			  script_not_found : None
  float sum = 1 ;					      	float sum = 1.0f ;					      float sum = 1 ;						  
  for ( int i = n - 1 ;					      	for ( int i = n - 1 ;					      for ( int i = n - 1 ;					  
  i > 0 ;						      	i > 0 ;							      i > 0 ;							  
  -- i ) sum = 1 + x * sum / i ;			      	-- i ) sum = 1 + x * sum / i ;				      -- i ) {							  
  return sum ;						      	return sum ;						    	sum = 1 + x * sum / i ;					  
}							      }								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX
--							      --							    --								  --
static int numberOfPaths ( int m , int n ) {		      int numberOfPaths ( int m , int n ) {			    int numberOfPaths ( int m , int n ) {			  script_not_found : None
  if ( m == 1 || n == 1 ) return 1 ;			      	if ( m == 1 || n == 1 ) return 1 ;			      if ( m == 1 || n == 1 ) return 1 ;			  
  return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n  	return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n    return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1		      MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1			    MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1			  MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1
--							      --							    --								  --
static int maxvolume ( int s ) {			      int maxvolume ( int s ) {					    int maxvolume ( int s ) {					  success : identical to gold
  int length = s / 3 ;					      	int length = s / 3 ;					      int length = s / 3 ;					  
  s -= length ;						      	s -= length ;						      s -= length ;						  
  int breadth = s / 2 ;					      	int breadth = s / 2 ;					      int breadth = s / 2 ;					  
  int height = s - breadth ;				      	int height = s - breadth ;				      int height = s - breadth ;				  
  return length * breadth * height ;			      	return length * breadth * height ;			      return length * breadth * height ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2     GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2	    GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2	  GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2
--							      --							    --								  --
static int Largestpower ( int n , int p ) {		      int largestPower ( int n , int p ) {			    int Largestpower ( int n , int p ) {			  script_not_found : None
  int ans = 0 ;						      	int x = 0 ;						      int ans = 0 ;						  
  while ( n > 0 ) {					      	while ( n ) {						      while ( n > 0 ) {						  
    n /= p ;						      	  n /= p ;						    	n /= p ;						  
    ans += n ;						      	  x += n ;						    	ans += n ;						  
  }							      	}							      }								  
  return ans ;						      	return x ;						      return ans ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STACK_SET_3_REVERSE_STRING_USING_STACK			      STACK_SET_3_REVERSE_STRING_USING_STACK			    STACK_SET_3_REVERSE_STRING_USING_STACK			  STACK_SET_3_REVERSE_STRING_USING_STACK
--							      --							    --								  --
static void reverse ( char str [ ] ) {			      void reverse ( char str [ ] ) {				    void reverse ( char str [ ] ) {				  script_not_found : None
  int n = str . length , i ;				      	int n = strlen ( str ) , i ;				      int n = strlen ( str ) , i ;				  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n / 2 ;						      	i < n / 2 ;						      i < n / 2 ;						  
  i ++ ) {						      	i ++ ) swap ( & str [ i ] , & str [ n - i - 1 ] ) ;	      i ++ ) swap ( str + i , str + n - i - 1 ) ;		  
    swap ( str , i , n - i - 1 ) ;			      }								    }								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		      POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		    POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		  POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1
--							      --							    --								  --
static void printArray ( int [ ] a , int n ) {		      void printArray ( int * a , int n ) {			    void print_array ( int * a , int n ) {			  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) System . out . print ( a [ i ] + " " ) ;	      	i ++ ) cout << a [ i ] << " " ;				      i ++ ) {							  
  System . out . println ( ) ;				      	cout << endl ;						    	cout << a [ i ] << " " ;				  
}							      	return ;						      }								  
							      }								      cout << endl ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_ROOT_OF_AN_INTEGER				      SQUARE_ROOT_OF_AN_INTEGER					    SQUARE_ROOT_OF_AN_INTEGER					  SQUARE_ROOT_OF_AN_INTEGER
--							      --							    --								  --
static int floorSqrt ( int x ) {			      int floorSqrt ( int x ) {					    int floorSqrt ( int x ) {					  success : identical to gold
  if ( x == 0 || x == 1 ) return x ;			      	if ( x == 0 || x == 1 ) return x ;			      if ( x == 0 || x == 1 ) return x ;			  
  int i = 1 , result = 1 ;				      	int i = 1 , result = 1 ;				      int i = 1 , result = 1 ;					  
  while ( result <= x ) {				      	while ( result <= x ) {					      while ( result <= x ) {					  
    i ++ ;						      	  i ++ ;						    	i ++ ;							  
    result = i * i ;					      	  result = i * i ;					    	result = i * i ;					  
  }							      	}							      }								  
  return i - 1 ;					      	return i - 1 ;						      return i - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		      CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		    CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		  CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER
--							      --							    --								  --
public static boolean isPower ( int x , int y ) {	      bool isPower ( int x , long int y ) {			    bool isPower ( int x , int y ) {				  success : None
  if ( x == 1 ) return ( y == 1 ) ;			      	if ( x == 1 ) return ( y == 1 ) ;			      if ( x == 1 ) return ( y == 1 ) ;				  
  int pow = 1 ;						      	long int pow = 1 ;					      int pow = 1 ;						  
  while ( pow < y ) pow = pow * x ;			      	while ( pow < y ) pow *= x ;				      while ( pow < y ) {					  
  return ( pow == y ) ;					      	return ( pow == y ) ;					    	pow = pow * x ;						  
}							      }								      }								  
							      								      return ( pow == y ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			      MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			    MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			  MULTIPLICATIVE_INVERSE_UNDER_MODULO_M
--							      --							    --								  --
static int modInverse ( int a , int m ) {		      int modInverse ( int a , int m ) {			    int modInverse ( int a , int m ) {				  script_not_found : None
  a = a % m ;						      	a = a % m ;						      a = a % m ;						  
  for ( int x = 1 ;					      	for ( int x = 1 ;					      for ( int x = 1 ;						  
  x < m ;						      	x < m ;							      x < m ;							  
  x ++ ) if ( ( a * x ) % m == 1 ) return x ;		      	x ++ ) if ( ( a * x ) % m == 1 ) return x ;		      x ++ ) if ( ( a * x ) % m == 1 ) return x ;		  
  return 1 ;						      }								      return 1 ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_IS_DIVISIBLE_BY_29_OR_NOT			      NUMBER_IS_DIVISIBLE_BY_29_OR_NOT				    NUMBER_IS_DIVISIBLE_BY_29_OR_NOT				  NUMBER_IS_DIVISIBLE_BY_29_OR_NOT
--							      --							    --								  --
static boolean isDivisible ( long n ) {			      bool isDivisible ( long long int n ) {			    bool isDivisible ( long long n ) {				  success : None
  while ( n / 100 > 0 ) {				      	while ( n / 100 ) {					      while ( n / 100 > 0 ) {					  
    int last_digit = ( int ) n % 10 ;			      	  int last_digit = n % 10 ;				    	int last_digit = ( int ) n % 10 ;			  
    n /= 10 ;						      	  n /= 10 ;						    	n /= 10 ;						  
    n += last_digit * 3 ;				      	  n += last_digit * 3 ;					    	n += last_digit * 3 ;					  
  }							      	}							      }								  
  return ( n % 29 == 0 ) ;				      	return ( n % 29 == 0 ) ;				      return ( n % 29 == 0 ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY	      QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY		    QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY		  QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY
--							      --							    --								  --
static void leftRotate ( int arr [ ] , int n , int k ) {      void leftRotate ( int arr [ ] , int n , int k ) {		    void leftRotate ( int arr [ ] , int n , int k ) {		  script_not_found : None
  for ( int i = k ;					      	for ( int i = k ;					      for ( int i = k ;						  
  i < k + n ;						      	i < k + n ;						      i < k + n ;						  
  i ++ ) System . out . print ( arr [ i % n ] + " " ) ;	      	i ++ ) cout << arr [ i % n ] << " " ;			      i ++ ) {							  
}							      }								    	cout << arr [ i % n ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DOUBLE_FACTORIAL_1					      DOUBLE_FACTORIAL_1					    DOUBLE_FACTORIAL_1						  DOUBLE_FACTORIAL_1
--							      --							    --								  --
static int doublefactorial ( int n ) {			      unsigned int doublefactorial ( unsigned int n ) {		    int doublefactorial ( int n ) {				  success : None
  int res = 1 ;						      	int res = 1 ;						      int res = 1 ;						  
  for ( int i = n ;					      	for ( int i = n ;					      for ( int i = n ;						  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i = i - 2 ) {						      	i = i - 2 ) {						      i = i - 2 ) {						  
    if ( i == 0 || i == 1 ) return res ;		      	  if ( i == 0 || i == 1 ) return res ;			    	if ( i == 0 || i == 1 ) return res ;			  
    else res *= i ;					      	  else res *= i ;					    	else res *= i ;						  
  }							      	}							      }								  
  return res ;						      }								      return res ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LAST_INDEX_CHARACTER_STRING			      FIND_LAST_INDEX_CHARACTER_STRING				    FIND_LAST_INDEX_CHARACTER_STRING				  FIND_LAST_INDEX_CHARACTER_STRING
--							      --							    --								  --
static int findLastIndex ( String str , Character x ) {	      int findLastIndex ( string & str , char x ) {		    int findLastIndex ( string str , char x ) {			  script_not_found : None
  int index = - 1 ;					      	int index = - 1 ;					      int index = - 1 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < str . length ( ) ;				      	i < str . length ( ) ;					      i < str . length ( ) ;					  
  i ++ ) if ( str . charAt ( i ) == x ) index = i ;	      	i ++ ) if ( str [ i ] == x ) index = i ;		      i ++ ) if ( str [ i ] == x ) index = i ;			  
  return index ;					      	return index ;						      return index ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP   HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP   HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP	  HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP
--							      --							    --								  --
static void printNos ( int n ) {			      public : void printNos ( unsigned int n ) {		    void print_nos ( int n ) {					  script_not_found : None
  if ( n > 0 ) {					      	if ( n > 0 ) {						      if ( n > 0 ) {						  
    printNos ( n - 1 ) ;				      	  printNos ( n - 1 ) ;					    	print_nos ( n - 1 ) ;					  
    System . out . print ( n + " " ) ;			      	  cout << n << " " ;					    	cout << n << " " ;					  
  }							      	}							      }								  
  return ;						      	return ;						      return ;							  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS			      SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS			    SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS				  SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS
--							      --							    --								  --
public static int kthgroupsum ( int k ) {		      int kthgroupsum ( int k ) {				    int kthgroupsum ( int k ) {					  success : None
  int cur = ( k * ( k - 1 ) ) + 1 ;			      	int cur = ( k * ( k - 1 ) ) + 1 ;			      int cur = ( k * ( k - 1 ) ) + 1 ;				  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  while ( k -- > 0 ) {					      	while ( k -- ) {					      while ( k -- > 0 ) {					  
    sum += cur ;					      	  sum += cur ;						    	sum += cur ;						  
    cur += 2 ;						      	  cur += 2 ;						    	cur += 2 ;						  
  }							      	}							      }								  
  return sum ;						      	return sum ;						      return sum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N			      FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N			    FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N				  FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N
--							      --							    --								  --
static void printFactorialNums ( int n ) {		      void printFactorialNums ( int n ) {			    void print_factorial_nums ( int n ) {			  script_not_found : None
  int fact = 1 ;					      	int fact = 1 ;						      int fact = 1 ;						  
  int x = 2 ;						      	int x = 2 ;						      int x = 2 ;						  
  while ( fact <= n ) {					      	while ( fact <= n ) {					      while ( fact <= n ) {					  
    System . out . print ( fact + " " ) ;		      	  cout << fact << " " ;					    	cout << fact << " " ;					  
    fact = fact * x ;					      	  fact = fact * x ;					    	fact = fact * x ;					  
    x ++ ;						      	  x ++ ;						    	x ++ ;							  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2						      NEXT_POWER_OF_2						    NEXT_POWER_OF_2						  NEXT_POWER_OF_2
--							      --							    --								  --
static int nextPowerOf2 ( int n ) {			      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
  int count = 0 ;					      	unsigned count = 0 ;					      int count = 0 ;						  
  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;	      	if ( n && ! ( n & ( n - 1 ) ) ) return n ;		      if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;		  
  while ( n != 0 ) {					      	while ( n != 0 ) {					      while ( n != 0 ) {					  
    n >>= 1 ;						      	  n >>= 1 ;						    	n >>= 1 ;						  
    count += 1 ;					      	  count += 1 ;						    	count += 1 ;						  
  }							      	}							      }								  
  return 1 << count ;					      	return 1 << count ;					      return 1 << count ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER		      FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER		    FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER			  FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER
--							      --							    --								  --
static void center ( int x1 , int x2 , int y1 , int y2 ) {    void center ( int x1 , int x2 , int y1 , int y2 ) {	    void center ( int x1 , int x2 , int y1 , int y2 ) {		  script_not_found : None
  System . out . print ( ( float ) ( x1 + x2 ) / 2 + ", " + ( 	cout << ( float ) ( x1 + x2 ) / 2 << ", " << ( float ) ( y1   cout << ( float ) ( x1 + x2 ) / 2 << ", " << ( float ) ( y1 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING		      HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING			    HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING			  HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING
--							      --							    --								  --
static int search ( int arr [ ] , int n , int x ) {	      int search ( int arr [ ] , int n , int x ) {		    int search ( int arr [ ] , int n , int x ) {		  success : identical to gold
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] == x ) return i ;			      	  if ( arr [ i ] == x ) return i ;			    	if ( arr [ i ] == x ) return i ;			  
  }							      	}							      }								  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES			      SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES			    SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES				  SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES
--							      --							    --								  --
static int findS ( int s ) {				      int findS ( int s ) {					    int findS ( int s ) {					  success : identical to gold
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int n = 1 ;					      	for ( int n = 1 ;					      for ( int n = 1 ;						  
  sum < s ;						      	sum < s ;						      sum < s ;							  
  n ++ ) {						      	n ++ ) {						      n ++ ) {							  
    sum += n * n ;					      	  sum += n * n ;					    	sum += n * n ;						  
    if ( sum == s ) return n ;				      	  if ( sum == s ) return n ;				    	if ( sum == s ) return n ;				  
  }							      	}							      }								  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME
--							      --							    --								  --
static int getSum ( int n ) {				      public : int getSum ( int n ) {				    int getSum ( int n ) {					  script_not_found : None
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  while ( n != 0 ) {					      	while ( n != 0 ) {					      while ( n != 0 ) {					  
    sum = sum + n % 10 ;				      	  sum = sum + n % 10 ;					    	sum = sum + n % 10 ;					  
    n = n / 10 ;					      	  n = n / 10 ;						    	n = n / 10 ;						  
  }							      	}							      }								  
  return sum ;						      	return sum ;						      return sum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE	      SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE		    SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE		  SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE
--							      --							    --								  --
static void swap ( int [ ] xp , int [ ] yp ) {		      void swap ( int * xp , int * yp ) {			    void swap ( int * xp , int * yp ) {				  script_not_found : None
  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;			      	* xp = * xp ^ * yp ;					      * xp = * yp ^ * yp ;					  
  yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;			      	* yp = * xp ^ * yp ;					      * yp = * xp ^ * yp ;					  
  xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;			      	* xp = * xp ^ * yp ;					      * xp = * xp ^ * yp ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		      PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		    PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		  PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING
--							      --							    --								  --
public static int count ( String s , char c ) {		      int count ( string s , char c ) {				    int count ( string s , char c ) {				  success : None
  int res = 0 ;						      	int res = 0 ;						      int res = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < s . length ( ) ;					      	i < s . length ( ) ;					      i < s . length ( ) ;					  
  i ++ ) {						      	i ++ ) if ( s [ i ] == c ) res ++ ;			      i ++ ) {							  
    if ( s . charAt ( i ) == c ) res ++ ;		      	return res ;						    	if ( s [ i ] == c ) {					  
  }							      }								    	  res ++ ;						  
  return res ;						      								    	}							  
}							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			      C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			    C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			  C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY
--							      --							    --								  --
static int largest ( ) {				      int largest ( int arr [ ] , int n ) {			    int largest ( ) {						  script_not_found : None
  int i ;						      	int i ;							      int i ;							  
  int max = arr [ 0 ] ;					      	int max = arr [ 0 ] ;					      int max = arr [ 0 ] ;					  
  for ( i = 1 ;						      	for ( i = 1 ;						      for ( i = 1 ;						  
  i < arr . length ;					      	i < n ;							      i < arr . size ( ) ;					  
  i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;	      	i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;		      i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;		  
  return max ;						      	return max ;						      return max ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MISSING_NUMBER					      FIND_THE_MISSING_NUMBER					    FIND_THE_MISSING_NUMBER					  FIND_THE_MISSING_NUMBER
--							      --							    --								  --
static int getMissingNo ( int a [ ] , int n ) {		      int getMissingNo ( int a [ ] , int n ) {			    int getMissingNo ( int a [ ] , int n ) {			  script_not_found : None
  int i , total ;					      	int total = ( n + 1 ) * ( n + 2 ) / 2 ;			      int i , total ;						  
  total = ( n + 1 ) * ( n + 2 ) / 2 ;			      	for ( int i = 0 ;					      total = ( n + 1 ) * ( n + 2 ) / 2 ;			  
  for ( i = 0 ;						      	i < n ;							      for ( i = 0 ;						  
  i < n ;						      	i ++ ) total -= a [ i ] ;				      i < n ;							  
  i ++ ) total -= a [ i ] ;				      	return total ;						      i ++ ) {							  
  return total ;					      }								    	total -= a [ i ] ;					  
}							      								      }								  
							      								      return total ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION_1			      PROGRAM_DECIMAL_BINARY_CONVERSION_1			    PROGRAM_DECIMAL_BINARY_CONVERSION_1				  PROGRAM_DECIMAL_BINARY_CONVERSION_1
--							      --							    --								  --
public void decToBinary ( int n ) {			      int decToBinary ( int n ) {				    void decToBinary ( int n ) {				  script_not_found : None
  for ( int i = 31 ;					      	for ( int i = 31 ;					      for ( int i = 31 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    int k = n >> i ;					      	  int k = n >> i ;					    	int k = n >> i ;					  
    if ( ( k & 1 ) > 0 ) System . out . print ( "1" ) ;	      	  if ( k & 1 ) cout << "1" ;				    	if ( ( k & 1 ) > 0 ) {					  
    else System . out . print ( "0" ) ;			      	  else cout << "0" ;					    	  cout << "1" ;						  
  }							      	}							    	}							  
}							      }								    	else {							  
							      								    	  cout << "0" ;						  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MISSING_NUMBER_1				      FIND_THE_MISSING_NUMBER_1					    FIND_THE_MISSING_NUMBER_1					  FIND_THE_MISSING_NUMBER_1
--							      --							    --								  --
static int getMissingNo ( int a [ ] , int n ) {		      int getMissingNo ( int a [ ] , int n ) {			    int getMissingNo ( int a [ ] , int n ) {			  success : None
  int total = 1 ;					      	int i , total = 1 ;					      int total = 1 ;						  
  for ( int i = 2 ;					      	for ( i = 2 ;						      for ( int i = 2 ;						  
  i <= ( n + 1 ) ;					      	i <= ( n + 1 ) ;					      i <= ( n + 1 ) ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    total += i ;					      	  total += i ;						    	total += i ;						  
    total -= a [ i - 2 ] ;				      	  total -= a [ i - 2 ] ;				    	total -= a [ i - 2 ] ;					  
  }							      	}							      }								  
  return total ;					      	return total ;						      return total ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SERIES_12_32_52_2N_12				      SUM_SERIES_12_32_52_2N_12					    SUM_SERIES_12_32_52_2N_12					  SUM_SERIES_12_32_52_2N_12
--							      --							    --								  --
static int sumOfSeries ( int n ) {			      int sumOfSeries ( int n ) {				    int sumOfSeries ( int n ) {					  success : None
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ;	      	i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ;	      i ++ ) {							  
  return sum ;						      	return sum ;						    	sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ;		  
}							      }								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	      SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	    SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	  SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS
--							      --							    --								  --
static int smallest ( int x , int y , int z ) {		      int smallest ( int x , int y , int z ) {			    int smallest ( int x , int y , int z ) {			  success : None
  int c = 0 ;						      	int c = 0 ;						      int c = 0 ;						  
  while ( x != 0 && y != 0 && z != 0 ) {		      	while ( x && y && z ) {					      while ( x != 0 && y != 0 && z != 0 ) {			  
    x -- ;						      	  x -- ;						    	x -- ;							  
    y -- ;						      	  y -- ;						    	y -- ;							  
    z -- ;						      	  z -- ;						    	z -- ;							  
    c ++ ;						      	  c ++ ;						    	c ++ ;							  
  }							      	}							      }								  
  return c ;						      	return c ;						      return c ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW
--							      --							    --								  --
static boolean isPowerOfTwo ( int n ) {			      bool isPowerOfTwo ( int n ) {				    bool isPowerOfTwo ( int n ) {				  success : None
  if ( n == 0 ) return false ;				      	if ( n == 0 ) return 0 ;				      if ( n == 0 ) return false ;				  
  while ( n != 1 ) {					      	while ( n != 1 ) {					      while ( n != 1 ) {					  
    if ( n % 2 != 0 ) return false ;			      	  if ( n % 2 != 0 ) return 0 ;				    	if ( n % 2 != 0 ) return false ;			  
    n = n / 2 ;						      	  n = n / 2 ;						    	n = n / 2 ;						  
  }							      	}							      }								  
  return true ;						      	return 1 ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS					      SUM_PAIRWISE_PRODUCTS					    SUM_PAIRWISE_PRODUCTS					  SUM_PAIRWISE_PRODUCTS
--							      --							    --								  --
static int findSum ( int n ) {				      long long int findSum ( int n ) {				    int findSum ( int n ) {					  success : None
  int sum = 0 ;						      	long long int sum = 0 ;					      int sum = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) for ( int j = i ;				      	i ++ ) for ( int j = i ;				      i ++ ) for ( int j = i ;					  
  j <= n ;						      	j <= n ;						      j <= n ;							  
  j ++ ) sum = sum + i * j ;				      	j ++ ) sum = sum + i * j ;				      j ++ ) sum = sum + i * j ;				  
  return sum ;						      	return sum ;						      return sum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TRIANGULAR_NUMBERS					      TRIANGULAR_NUMBERS					    TRIANGULAR_NUMBERS						  TRIANGULAR_NUMBERS
--							      --							    --								  --
static boolean isTriangular ( int num ) {		      bool isTriangular ( int num ) {				    bool isTriangular ( int num ) {				  success : identical to gold
  if ( num < 0 ) return false ;				      	if ( num < 0 ) return false ;				      if ( num < 0 ) return false ;				  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int n = 1 ;					      	for ( int n = 1 ;					      for ( int n = 1 ;						  
  sum <= num ;						      	sum <= num ;						      sum <= num ;						  
  n ++ ) {						      	n ++ ) {						      n ++ ) {							  
    sum = sum + n ;					      	  sum = sum + n ;					    	sum = sum + n ;						  
    if ( sum == num ) return true ;			      	  if ( sum == num ) return true ;			    	if ( sum == num ) return true ;				  
  }							      	}							      }								  
  return false ;					      	return false ;						      return false ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARED_TRIANGULAR_NUMBER_SUM_CUBES			      SQUARED_TRIANGULAR_NUMBER_SUM_CUBES			    SQUARED_TRIANGULAR_NUMBER_SUM_CUBES				  SQUARED_TRIANGULAR_NUMBER_SUM_CUBES
--							      --							    --								  --
static int findS ( int s ) {				      int findS ( int s ) {					    int findS ( int s ) {					  success : identical to gold
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int n = 1 ;					      	for ( int n = 1 ;					      for ( int n = 1 ;						  
  sum < s ;						      	sum < s ;						      sum < s ;							  
  n ++ ) {						      	n ++ ) {						      n ++ ) {							  
    sum += n * n * n ;					      	  sum += n * n * n ;					    	sum += n * n * n ;					  
    if ( sum == s ) return n ;				      	  if ( sum == s ) return n ;				    	if ( sum == s ) return n ;				  
  }							      	}							      }								  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		      FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		    FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		  FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2
--							      --							    --								  --
int getOddOccurrence ( int ar [ ] , int ar_size ) {	      int getOddOccurrence ( int ar [ ] , int ar_size ) {	    int getOddOccurrence ( int ar [ ] , int ar_size ) {		  success : None
  int i ;						      	int res = 0 ;						      int i ;							  
  int res = 0 ;						      	for ( int i = 0 ;					      int res = 0 ;						  
  for ( i = 0 ;						      	i < ar_size ;						      for ( i = 0 ;						  
  i < ar_size ;						      	i ++ ) res = res ^ ar [ i ] ;				      i < ar_size ;						  
  i ++ ) {						      	return res ;						      i ++ ) res = res ^ ar [ i ] ;				  
    res = res ^ ar [ i ] ;				      }								      return res ;						  
  }							      								    }								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_EVEN_FIBONACCI_NUMBER				      NTH_EVEN_FIBONACCI_NUMBER					    NTH_EVEN_FIBONACCI_NUMBER					  NTH_EVEN_FIBONACCI_NUMBER
--							      --							    --								  --
static long evenFib ( int n ) {				      long int evenFib ( int n ) {				    long long evenFib ( int n ) {				  script_not_found : None
  if ( n < 1 ) return n ;				      	if ( n < 1 ) return n ;					      if ( n < 1 ) return n ;					  
  if ( n == 1 ) return 2 ;				      	if ( n == 1 ) return 2 ;				      if ( n == 1 ) return 2 ;					  
  return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;  	return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;    return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_ROOT_OF_A_PERFECT_SQUARE				      SQUARE_ROOT_OF_A_PERFECT_SQUARE				    SQUARE_ROOT_OF_A_PERFECT_SQUARE				  SQUARE_ROOT_OF_A_PERFECT_SQUARE
--							      --							    --								  --
static float squareRoot ( float n ) {			      public : float squareRoot ( float n ) {			    float squareRoot ( float n ) {				  script_not_found : None
  float x = n ;						      	float x = n ;						      float x = n ;						  
  float y = 1 ;						      	float y = 1 ;						      float y = 1 ;						  
  double e = 0.000001 ;					      	float e = 0.000001 ;					      double e = 0.000001 ;					  
  while ( x - y > e ) {					      	while ( x - y > e ) {					      while ( x - y > e ) {					  
    x = ( x + y ) / 2 ;					      	  x = ( x + y ) / 2 ;					    	x = ( x + y ) / 2 ;					  
    y = n / x ;						      	  y = n / x ;						    	y = n / x ;						  
  }							      	}							      }								  
  return x ;						      	return x ;						      return x ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION      CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION	    CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION	  CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION
--							      --							    --								  --
static boolean isPerfectSquare ( int n ) {		      bool isPerfectSquare ( int n ) {				    bool isPerfectSquare ( int n ) {				  success : identical to gold
  for ( int sum = 0 , i = 1 ;				      	for ( int sum = 0 , i = 1 ;				      for ( int sum = 0 , i = 1 ;				  
  sum < n ;						      	sum < n ;						      sum < n ;							  
  i += 2 ) {						      	i += 2 ) {						      i += 2 ) {						  
    sum += i ;						      	  sum += i ;						    	sum += i ;						  
    if ( sum == n ) return true ;			      	  if ( sum == n ) return true ;				    	if ( sum == n ) return true ;				  
  }							      	}							      }								  
  return false ;					      	return false ;						      return false ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1			      NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1			    NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1				  NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1
--							      --							    --								  --
public static int countDigits ( int a , int b ) {	      int countDigits ( int a , int b ) {			    int countDigits ( int a , int b ) {				  success : None
  if ( a == 0 || b == 0 ) return 1 ;			      	if ( a == 0 || b == 0 ) return 1 ;			      if ( a == 0 || b == 0 ) return 1 ;			  
  return ( int ) Math . floor ( Math . log10 ( Math . abs ( a 	return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) )    return ( int ) floor ( log10 ( abs ( a ) ) + log10 ( abs (  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUICK_WAY_CHECK_CHARACTERS_STRING			      QUICK_WAY_CHECK_CHARACTERS_STRING				    QUICK_WAY_CHECK_CHARACTERS_STRING				  QUICK_WAY_CHECK_CHARACTERS_STRING
--							      --							    --								  --
static boolean allCharactersSame ( String s ) {		      bool allCharactersSame ( string s ) {			    bool allCharactersSame ( string s ) {			  success : identical to gold
  int n = s . length ( ) ;				      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return f 	i ++ ) if ( s [ i ] != s [ 0 ] ) return false ;		      i ++ ) if ( s [ i ] != s [ 0 ] ) return false ;		  
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		      CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		    CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		  CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1
--							      --							    --								  --
static boolean isPower ( int x , int y ) {		      bool isPower ( int x , int y ) {				    bool isPower ( int x , int y ) {				  error : /bin/bash: line 1: 3924914 Floating point
  int res1 = ( int ) Math . log ( y ) / ( int ) Math . log (  	int res1 = log ( y ) / log ( x ) ;			      int res1 = ( int ) log ( y ) / ( int ) log ( x ) ;	  exception(core dumped) ./CHECK_IF_A_NUMBER_IS_POWE
  double res2 = Math . log ( y ) / Math . log ( x ) ;	      	double res2 = log ( y ) / log ( x ) ;			      double res2 = log ( y ) / log ( x ) ;			  R_OF_ANOTHER_NUMBER_1_cpp
  return ( res1 == res2 ) ;				      	return ( res1 == res2 ) ;				      return ( res1 == res2 ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REVERSE_A_STRING_USING_RECURSION			      REVERSE_A_STRING_USING_RECURSION				    REVERSE_A_STRING_USING_RECURSION				  REVERSE_A_STRING_USING_RECURSION
--							      --							    --								  --
void reverse ( String str ) {				      void reverse ( string str ) {				    void reverse ( string str ) {				  script_not_found : None
  if ( ( str == null ) || ( str . length ( ) <= 1 ) ) System  	if ( str . size ( ) == 0 ) {				      if ( ( str . empty ( ) ) || ( str . length ( ) <= 1 ) ) {	  
  else {						      	  return ;						    	cout << str << endl ;					  
    System . out . print ( str . charAt ( str . length ( ) -  	}							      }								  
    reverse ( str . substring ( 0 , str . length ( ) - 1 ) )  	reverse ( str . substr ( 1 ) ) ;			      else {							  
  }							      	cout << str [ 0 ] ;					    	cout << str [ str . length ( ) - 1 ] << endl ;		  
}							      }								    	reverse ( str . substr ( 0 , str . length ( ) - 1 ) ) ;	  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT		  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT
--							      --							    --								  --
static int isPowerOfFour ( int n ) {			      public : bool isPowerOfFour ( int n ) {			    int isPowerOfFour ( int n ) {				  script_not_found : None
  if ( n == 0 ) return 0 ;				      	if ( n == 0 ) return 0 ;				      if ( n == 0 ) return 0 ;					  
  while ( n != 1 ) {					      	while ( n != 1 ) {					      while ( n != 1 ) {					  
    if ( n % 4 != 0 ) return 0 ;			      	  if ( n % 4 != 0 ) return 0 ;				    	if ( n % 4 != 0 ) return 0 ;				  
    n = n / 4 ;						      	  n = n / 4 ;						    	n = n / 4 ;						  
  }							      	}							      }								  
  return 1 ;						      	return 1 ;						      return 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HORNERS_METHOD_POLYNOMIAL_EVALUATION			      HORNERS_METHOD_POLYNOMIAL_EVALUATION			    HORNERS_METHOD_POLYNOMIAL_EVALUATION			  HORNERS_METHOD_POLYNOMIAL_EVALUATION
--							      --							    --								  --
static int horner ( int poly [ ] , int n , int x ) {	      int horner ( int poly [ ] , int n , int x ) {		    int horner ( int poly [ ] , int n , int x ) {		  success : None
  int result = poly [ 0 ] ;				      	int result = poly [ 0 ] ;				      int result = poly [ 0 ] ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) result = result * x + poly [ i ] ;		      	i ++ ) result = result * x + poly [ i ] ;		      i ++ ) {							  
  return result ;					      	return result ;						    	result = result * x + poly [ i ] ;			  
}							      }								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1	      SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1		    SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1		  SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1
--							      --							    --								  --
static int nextPowerOf2 ( int n ) {			      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
  int p = 1 ;						      	unsigned int p = 1 ;					      int p = 1 ;						  
  if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;	      	if ( n && ! ( n & ( n - 1 ) ) ) return n ;		      if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ;		  
  while ( p < n ) p <<= 1 ;				      	while ( p < n ) p <<= 1 ;				      while ( p < n ) {						  
  return p ;						      	return p ;						    	p <<= 1 ;						  
}							      }								      }								  
							      								      return p ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		      SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		    SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		  SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX
--							      --							    --								  --
static int spiralDiaSum ( int n ) {			      int spiralDiaSum ( int n ) {				    int spiralDiaSum ( int n ) {				  script_not_found : None
  if ( n == 1 ) return 1 ;				      	if ( n == 1 ) return 1 ;				      if ( n == 1 ) return 1 ;					  
  return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; 	return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ;   return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	      MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	    MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	  MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS
--							      --							    --								  --
static int cost ( int [ ] a , int n ) {			      int cost ( int a [ ] , int n ) {				    int cost ( int a [ ] , int n ) {				  failure : #Results: 8, 10
  int min = a [ 0 ] ;					      	return ( n - 1 ) * ( * min_element ( a , a + n ) ) ;	      int min = a [ 0 ] ;					  
  for ( int i = 1 ;					      }								      for ( int i = 1 ;						  
  i < a . length ;					      								      i < a [ 0 ] ;						  
  i ++ ) {						      								      i ++ ) {							  
    if ( a [ i ] < min ) min = a [ i ] ;		      								    	if ( a [ i ] < min ) {					  
  }							      								    	  min = a [ i ] ;					  
  return ( n - 1 ) * min ;				      								    	}							  
}							      								      }								  
							      								      return ( n - 1 ) * min ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE    FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE    FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE	  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE
--							      --							    --								  --
static char first ( String str ) {			      char first ( string str ) {				    char first ( string str ) {					  success : identical to gold
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < str . length ( ) ;				      	i < str . length ( ) ;					      i < str . length ( ) ;					  
  i ++ ) if ( Character . isUpperCase ( str . charAt ( i ) )  	i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ;	      i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ;	  
  return 0 ;						      	return 0 ;						      return 0 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSITION_OF_RIGHTMOST_SET_BIT_2				      POSITION_OF_RIGHTMOST_SET_BIT_2				    POSITION_OF_RIGHTMOST_SET_BIT_2				  POSITION_OF_RIGHTMOST_SET_BIT_2
--							      --							    --								  --
static int Right_most_setbit ( int num ) {		      int Right_most_setbit ( int num ) {			    int Right_most_setbit ( int num ) {				  script_not_found : None
  int pos = 1 ;						      	int pos = 1 ;						      int pos = 1 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < INT_SIZE ;					      	i < INT_SIZE ;						      i < INT_SIZE ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ;		      	  if ( ! ( num & ( 1 << i ) ) ) pos ++ ;		    	if ( ( num & ( 1 << i ) ) == 0 ) {			  
    else break ;					      	  else break ;						    	  pos ++ ;						  
  }							      	}							    	}							  
  return pos ;						      	return pos ;						    	else {							  
}							      }								    	  break ;						  
							      								    	}							  
							      								      }								  
							      								      return pos ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY		      FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY			    FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY			  FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY
--							      --							    --								  --
static void findLarger ( int arr [ ] , int n ) {	      void findLarger ( int arr [ ] , int n ) {			    void findLarger ( int arr [ ] , int n ) {			  script_not_found : None
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  for ( int i = n - 1 ;					      	for ( int i = n - 1 ;					      for ( int i = n - 1 ;					  
  i >= n / 2 ;						      	i >= n / 2 ;						      i >= n / 2 ;						  
  i -- ) System . out . print ( arr [ i ] + " " ) ;	      	i -- ) cout << arr [ i ] << " " ;			      i -- ) {							  
}							      }								    	cout << arr [ i ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GAME_REPLACING_ARRAY_ELEMENTS				      GAME_REPLACING_ARRAY_ELEMENTS				    GAME_REPLACING_ARRAY_ELEMENTS				  GAME_REPLACING_ARRAY_ELEMENTS
--							      --							    --								  --
public static int playGame ( int arr [ ] ) {		      int playGame ( int arr [ ] , int n ) {			    int playGame ( int arr [ ] ) {				  script_not_found : None
  HashSet < Integer > set = new HashSet < > ( ) ;	      	unordered_set < int > hash ;				      set < int > set ;						  
  for ( int i : arr ) set . add ( i ) ;			      	for ( int i = 0 ;					      for ( int i : arr ) {					  
  return ( set . size ( ) % 2 == 0 ) ? 1 : 2 ;		      	i < n ;							    	set . insert ( i ) ;					  
}							      	i ++ ) hash . insert ( arr [ i ] ) ;			      }								  
							      	return ( hash . size ( ) % 2 == 0 ? 1 : 2 ) ;		      return ( set . size ( ) % 2 == 0 ) ? 1 : 2 ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			      FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			    FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			  FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X
--							      --							    --								  --
static long yMod ( long y , long x ) {			      long long int yMod ( long long int y , long long int x ) {    long long yMod ( long long y , long long x ) {		  success : None
  if ( ( Math . log ( y ) / Math . log ( 2 ) ) < x ) return y 	if ( log2 ( y ) < x ) return y ;			      if ( ( log ( y ) / log ( 2 ) ) < x ) return y ;		  
  if ( x > 63 ) return y ;				      	if ( x > 63 ) return y ;				      if ( x > 63 ) return y ;					  
  return ( y % ( 1 << ( int ) x ) ) ;			      	return ( y % ( 1 << x ) ) ;				      return ( y % ( 1 << ( int ) x ) ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIBONACCI_MODULO_P					      FIBONACCI_MODULO_P					    FIBONACCI_MODULO_P						  FIBONACCI_MODULO_P
--							      --							    --								  --
static int findMinZero ( int p ) {			      int findMinZero ( int p ) {				    int findMinZero ( int p ) {					  success : None
  int first = 1 , second = 1 , number = 2 , next = 1 ;	      	int first = 1 , second = 1 , number = 2 , next = 1 ;	      int first = 1 , second = 1 , number = 2 , next = 1 ;	  
  while ( next > 0 ) {					      	while ( next ) {					      while ( next > 0 ) {					  
    next = ( first + second ) % p ;			      	  next = ( first + second ) % p ;			    	next = ( first + second ) % p ;				  
    first = second ;					      	  first = second ;					    	first = second ;					  
    second = next ;					      	  second = next ;					    	second = next ;						  
    number ++ ;						      	  number ++ ;						    	number ++ ;						  
  }							      	}							      }								  
  return number ;					      	return number ;						      return number ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DIGITS_PRODUCT_TWO_NUMBERS			      NUMBER_DIGITS_PRODUCT_TWO_NUMBERS				    NUMBER_DIGITS_PRODUCT_TWO_NUMBERS				  NUMBER_DIGITS_PRODUCT_TWO_NUMBERS
--							      --							    --								  --
static int countDigits ( int a , int b ) {		      int countDigits ( int a , int b ) {			    int countDigits ( int a , int b ) {				  success : identical to gold
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  int p = Math . abs ( a * b ) ;			      	int p = abs ( a * b ) ;					      int p = abs ( a * b ) ;					  
  if ( p == 0 ) return 1 ;				      	if ( p == 0 ) return 1 ;				      if ( p == 0 ) return 1 ;					  
  while ( p > 0 ) {					      	while ( p > 0 ) {					      while ( p > 0 ) {						  
    count ++ ;						      	  count ++ ;						    	count ++ ;						  
    p = p / 10 ;					      	  p = p / 10 ;						    	p = p / 10 ;						  
  }							      	}							      }								  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS	      ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS		    ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS		  ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS
--							      --							    --								  --
static int search ( int arr [ ] , int n , int x ) {	      int search ( int arr [ ] , int n , int x ) {		    int search ( int arr [ ] , int n , int x ) {		  success : None
  int i ;						      	int i ;							      int i ;							  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] == x ) {				      	  if ( arr [ i ] == x ) return i ;			    	if ( arr [ i ] == x ) {					  
      return i ;					      	}							    	  return i ;						  
    }							      	return - 1 ;						    	}							  
  }							      }								      }								  
  return - 1 ;						      								      return - 1 ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_STRING_ROTATION_PALINDROME			      CHECK_GIVEN_STRING_ROTATION_PALINDROME			    CHECK_GIVEN_STRING_ROTATION_PALINDROME			  CHECK_GIVEN_STRING_ROTATION_PALINDROME
--							      --							    --								  --
static boolean isPalindrome ( String str ) {		      bool isPalindrome ( string str ) {			    bool isPalindrome ( string str ) {				  success : identical to gold
  int l = 0 ;						      	int l = 0 ;						      int l = 0 ;						  
  int h = str . length ( ) - 1 ;			      	int h = str . length ( ) - 1 ;				      int h = str . length ( ) - 1 ;				  
  while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt  	while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return    while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return  
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2
--							      --							    --								  --
static void recursiveReverse ( char [ ] str , int i ) {	      void recursiveReverse ( string & str , int i = 0 ) {	    void recursive_reverse ( string str , int i ) {		  script_not_found : None
  int n = str . length ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  if ( i == n / 2 ) return ;				      	if ( i == n / 2 ) return ;				      if ( i == n / 2 ) return ;				  
  swap ( str , i , n - i - 1 ) ;			      	swap ( str [ i ] , str [ n - i - 1 ] ) ;		      swap ( str [ i ] , str [ n - i - 1 ] ) ;			  
  recursiveReverse ( str , i + 1 ) ;			      	recursiveReverse ( str , i + 1 ) ;			      recursive_reverse ( str , i + 1 ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2	      SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2		    SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2		  SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2
--							      --							    --								  --
static int nextPowerOf2 ( int n ) {			      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
  n -- ;						      	n -- ;							      n -- ;							  
  n |= n >> 1 ;						      	n |= n >> 1 ;						      n |= n >> 1 ;						  
  n |= n >> 2 ;						      	n |= n >> 2 ;						      n |= n >> 2 ;						  
  n |= n >> 4 ;						      	n |= n >> 4 ;						      n |= n >> 4 ;						  
  n |= n >> 8 ;						      	n |= n >> 8 ;						      n |= n >> 8 ;						  
  n |= n >> 16 ;					      	n |= n >> 16 ;						      n |= n >> 16 ;						  
  n ++ ;						      	n ++ ;							      n ++ ;							  
  return n ;						      	return n ;						      return n ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	      MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	    MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	  MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N
--							      --							    --								  --
static int minSum ( int n ) {				      int minSum ( int n ) {					    int minSum ( int n ) {					  success : identical to gold
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  while ( n > 0 ) {					      	while ( n > 0 ) {					      while ( n > 0 ) {						  
    sum += ( n % 10 ) ;					      	  sum += ( n % 10 ) ;					    	sum += ( n % 10 ) ;					  
    n /= 10 ;						      	  n /= 10 ;						    	n /= 10 ;						  
  }							      	}							      }								  
  if ( sum == 1 ) return 10 ;				      	if ( sum == 1 ) return 10 ;				      if ( sum == 1 ) return 10 ;				  
  return sum ;						      	return sum ;						      return sum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2
--							      --							    --								  --
static int find_extra_element_index ( int [ ] arrA , int [ ]  int find_extra_element_index ( int arrA [ ] , int arrB [ ] ,  int findExtraElementIndex ( int * arrA , int * arrB ) {	  script_not_found : None
  int extra_element = sum ( arrA ) - sum ( arrB ) ;	      	int extra_element = sum ( arrA , n ) - sum ( arrB , m ) ;     int extraElement = sum ( arrA ) - sum ( arrB ) ;		  
  return indexOf ( arrA , extra_element ) ;		      	return indexOf ( arrA , extra_element , n ) ;		      return indexOf ( arrA , extraElement ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY    COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY    COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY	  COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY
--							      --							    --								  --
static int countOccurrences ( int arr [ ] , int n , int x ) { int countOccurrences ( int arr [ ] , int n , int x ) {	    int countOccurrences ( int arr [ ] , int n , int x ) {	  success : identical to gold
  int res = 0 ;						      	int res = 0 ;						      int res = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( x == arr [ i ] ) res ++ ;			      	i ++ ) if ( x == arr [ i ] ) res ++ ;			      i ++ ) if ( x == arr [ i ] ) res ++ ;			  
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_POWER_PRIME_NUMBER_P_N				      FINDING_POWER_PRIME_NUMBER_P_N				    FINDING_POWER_PRIME_NUMBER_P_N				  FINDING_POWER_PRIME_NUMBER_P_N
--							      --							    --								  --
static int PowerOFPINnfactorial ( int n , int p ) {	      int PowerOFPINnfactorial ( int n , int p ) {		    int PowerOFPINnfactorial ( int n , int p ) {		  success : None
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  for ( int i = 1 ;					      	int temp = p ;						      for ( int i = 1 ;						  
  i <= n ;						      	while ( temp <= n ) {					      i <= n ;							  
  i ++ ) {						      	  ans += n / temp ;					      i ++ ) {							  
    int count = 0 , temp = i ;				      	  temp = temp * p ;					    	int count = 0 , temp = i ;				  
    while ( temp % p == 0 ) {				      	}							    	while ( temp % p == 0 ) {				  
      count ++ ;					      	return ans ;						    	  count ++ ;						  
      temp = temp / p ;					      }								    	  temp = temp / p ;					  
    }							      								    	}							  
    ans += count ;					      								    	ans += count ;						  
  }							      								      }								  
  return ans ;						      								      return ans ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_1				      DYNAMIC_PROGRAMMING_SET_1					    DYNAMIC_PROGRAMMING_SET_1					  DYNAMIC_PROGRAMMING_SET_1
--							      --							    --								  --
int fib ( int n ) {					      int fib ( int n ) {					    int fib ( int n ) {						  script_not_found : None
  if ( lookup [ n ] == NIL ) {				      	if ( lookup [ n ] == NIL ) {				      if ( lookup [ n ] == NIL ) {				  
    if ( n <= 1 ) lookup [ n ] = n ;			      	  if ( n <= 1 ) lookup [ n ] = n ;			    	if ( n <= 1 ) {						  
    else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ;	      	  else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ;	    	  lookup [ n ] = n ;					  
  }							      	}							    	}							  
  return lookup [ n ] ;					      	return lookup [ n ] ;					    	else {							  
}							      }								    	  lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ;	  
							      								    	}							  
							      								      }								  
							      								      return lookup [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			      C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			    C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			  C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE
--							      --							    --								  --
static void rotate ( ) {				      void rotate ( int arr [ ] , int n ) {			    void rotate ( ) {						  script_not_found : None
  int x = arr [ arr . length - 1 ] , i ;		      	int x = arr [ n - 1 ] , i ;				      int x = arr [ arr . size ( ) - 1 ] , i ;			  
  for ( i = arr . length - 1 ;				      	for ( i = n - 1 ;					      for ( i = arr . size ( ) - 1 ;				  
  i > 0 ;						      	i > 0 ;							      i > 0 ;							  
  i -- ) arr [ i ] = arr [ i - 1 ] ;			      	i -- ) arr [ i ] = arr [ i - 1 ] ;			      i -- ) {							  
  arr [ 0 ] = x ;					      	arr [ 0 ] = x ;						    	arr [ i ] = arr [ i - 1 ] ;				  
}							      }								      }								  
							      								      arr [ 0 ] = x ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_9_USING_BITWISE_OPERATORS			      DIVISIBILITY_9_USING_BITWISE_OPERATORS			    DIVISIBILITY_9_USING_BITWISE_OPERATORS			  DIVISIBILITY_9_USING_BITWISE_OPERATORS
--							      --							    --								  --
static boolean isDivBy9 ( int n ) {			      bool isDivBy9 ( int n ) {					    int isDivBy9 ( int n ) {					  success : None
  if ( n == 0 || n == 9 ) return true ;			      	if ( n == 0 || n == 9 ) return true ;			      if ( n == 0 || n == 9 ) return 1 ;			  
  if ( n < 9 ) return false ;				      	if ( n < 9 ) return false ;				      if ( n < 9 ) return 0 ;					  
  return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )  	return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )    return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT
--							      --							    --								  --
static boolean check ( String str ) {			      int check ( string str ) {				    bool check ( string str ) {					  success : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  int digitSum = 0 ;					      	int digitSum = 0 ;					      int digitSum = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ;	      	i ++ ) digitSum += ( str [ i ] - '0' ) ;		      i ++ ) {							  
  return ( digitSum % 9 == 0 ) ;			      	return ( digitSum % 9 == 0 ) ;				    	digitSum += ( str [ i ] - '0' ) ;			  
}							      }								      }								  
							      								      return ( digitSum % 9 == 0 ) ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			      PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			    PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			  PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS
--							      --							    --								  --
static double gcd ( double a , double b ) {		      double gcd ( double a , double b ) {			    double gcd ( double a , double b ) {			  script_not_found : None
  if ( a < b ) return gcd ( b , a ) ;			      	if ( a < b ) return gcd ( b , a ) ;			      if ( a < b ) return gcd ( b , a ) ;			  
  if ( Math . abs ( b ) < 0.001 ) return a ;		      	if ( fabs ( b ) < 0.001 ) return a ;			      if ( fabs ( b ) < 0.001 ) return a ;			  
  else return ( gcd ( b , a - Math . floor ( a / b ) * b ) )  	else return ( gcd ( b , a - floor ( a / b ) * b ) ) ;	      else return ( gcd ( b , a - floor ( a / b ) * b ) ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS		      SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS			    SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS			  SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS
--							      --							    --								  --
static int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2  int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) {	  script_not_found : None
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + k2 ) ;					  
  int result = 0 ;					      	return accumulate ( arr + k1 , arr + k2 - 1 , 0 ) ;	      int result = 0 ;						  
  for ( int i = k1 ;					      }								      for ( int i = k1 ;					  
  i < k2 - 1 ;						      								      i < k2 - 1 ;						  
  i ++ ) result += arr [ i ] ;				      								      i ++ ) {							  
  return result ;					      								    	result += arr [ i ] ;					  
}							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS   EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS   EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS	  EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS
--							      --							    --								  --
static boolean squareRootExists ( int n , int p ) {	      bool squareRootExists ( int n , int p ) {			    bool squareRootExists ( int n , int p ) {			  success : identical to gold
  n = n % p ;						      	n = n % p ;						      n = n % p ;						  
  for ( int x = 2 ;					      	for ( int x = 2 ;					      for ( int x = 2 ;						  
  x < p ;						      	x < p ;							      x < p ;							  
  x ++ ) if ( ( x * x ) % p == n ) return true ;	      	x ++ ) if ( ( x * x ) % p == n ) return true ;		      x ++ ) if ( ( x * x ) % p == n ) return true ;		  
  return false ;					      	return false ;						      return false ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		      COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		    COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		  COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX
--							      --							    --								  --
static int count ( int n , int x ) {			      int count ( int n , int x ) {				    int count ( int n , int x ) {				  script_not_found : None
  int count = 0 ;					      	int count = = 0 ;					      int count = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n && i <= x ;					      	i <= n && i <= x ;					      i <= n && i <= x ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( x / i <= n && x % i == 0 ) count ++ ;		      	  if ( x / i <= n && x % i == 0 ) count ++ ;		    	if ( x / i <= n && x % i == 0 ) {			  
  }							      	}							    	  count ++ ;						  
  return count ;					      	return count ;						    	}							  
}							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE	      SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE		    SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE		  SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE
--							      --							    --								  --
static int selectRandom ( int x ) {			      int selectRandom ( int x ) {				    int selectRandom ( int x ) {				  script_not_found : None
  count ++ ;						      	static int res ;					      count ++ ;						  
  if ( count == 1 ) res = x ;				      	static int count = 0 ;					      if ( count == 1 ) {					  
  else {						      	count ++ ;						    	res = x ;						  
    Random r = new Random ( ) ;				      	if ( count == 1 ) res = x ;				      }								  
    int i = r . nextInt ( count ) ;			      	else {							      else {							  
    if ( i == count - 1 ) res = x ;			      	  int i = rand ( ) % count ;				    	srand ( time ( NULL ) ) ;				  
  }							      	  if ( i == count - 1 ) res = x ;			    	int i = rand ( ) % count ;				  
  return res ;						      	}							    	if ( i == count - 1 ) {					  
}							      	return res ;						    	  res = x ;						  
							      }								    	}							  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY    FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY    FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY	  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY
--							      --							    --								  --
static int findExtra ( int arr1 [ ] , int arr2 [ ] , int n )  int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) {	    int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) {	  success : identical to gold
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ;	      	i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ;	      i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ;		  
  return n ;						      	return n ;						      return n ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_NTH_CATALAN_NUMBER				      PROGRAM_NTH_CATALAN_NUMBER				    PROGRAM_NTH_CATALAN_NUMBER					  PROGRAM_NTH_CATALAN_NUMBER
--							      --							    --								  --
int catalan ( int n ) {					      unsigned long int catalan ( unsigned int n ) {		    int catalan ( int n ) {					  script_not_found : None
  int res = 0 ;						      	if ( n <= 1 ) return 1 ;				      int res = 0 ;						  
  if ( n <= 1 ) {					      	unsigned long int res = 0 ;				      if ( n <= 1 ) return 1 ;					  
    return 1 ;						      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  }							      	i < n ;							      i < n ;							  
  for ( int i = 0 ;					      	i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ;	      i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ;	  
  i < n ;						      	return res ;						      return res ;						  
  i ++ ) {						      }								    }								  
    res += catalan ( i ) * catalan ( n - i - 1 ) ;	      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		      FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		    FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		  FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO
--							      --							    --								  --
static int fib ( int n ) {				      int fib ( int n ) {					    int fib ( int n ) {						  script_not_found : None
  if ( n < 6 ) return f [ n ] ;				      	if ( n < 6 ) return f [ n ] ;				      if ( n < 6 ) return f [ n ] ;				  
  int t = 5 ;						      	int t = 5 , fn = 5 ;					      int t = 5 ;						  
  int fn = 5 ;						      	while ( t < n ) {					      int fn = 5 ;						  
  while ( t < n ) {					      	  fn = round ( fn * PHI ) ;				      while ( t < n ) {						  
    fn = ( int ) Math . round ( fn * PHI ) ;		      	  t ++ ;						    	fn = ( int ) round ( fn * PHI ) ;			  
    t ++ ;						      	}							    	t ++ ;							  
  }							      	return fn ;						      }								  
  return fn ;						      }								      return fn ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_PROGRAM_PRIME_NUMBER				      RECURSIVE_PROGRAM_PRIME_NUMBER				    RECURSIVE_PROGRAM_PRIME_NUMBER				  RECURSIVE_PROGRAM_PRIME_NUMBER
--							      --							    --								  --
static boolean isPrime ( int n , int i ) {		      bool isPrime ( int n , int i = 2 ) {			    bool isPrime ( int n , int i ) {				  success : None
  if ( n <= 2 ) return ( n == 2 ) ? true : false ;	      	if ( n <= 2 ) return ( n == 2 ) ? true : false ;	      if ( n <= 2 ) return ( n == 2 ) ? true : false ;		  
  if ( n % i == 0 ) return false ;			      	if ( n % i == 0 ) return false ;			      if ( n % i == 0 ) return false ;				  
  if ( i * i > n ) return true ;			      	if ( i * i > n ) return true ;				      if ( i * i > n ) return true ;				  
  return isPrime ( n , i + 1 ) ;			      	return isPrime ( n , i + 1 ) ;				      return isPrime ( n , i + 1 ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3
--							      --							    --								  --
static int numberOfPaths ( int m , int n ) {		      int numberOfPaths ( int m , int n ) {			    int numberOfPaths ( int m , int n ) {			  success : identical to gold
  int path = 1 ;					      	int path = 1 ;						      int path = 1 ;						  
  for ( int i = n ;					      	for ( int i = n ;					      for ( int i = n ;						  
  i < ( m + n - 1 ) ;					      	i < ( m + n - 1 ) ;					      i < ( m + n - 1 ) ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    path *= i ;						      	  path *= i ;						    	path *= i ;						  
    path /= ( i - n + 1 ) ;				      	  path /= ( i - n + 1 ) ;				    	path /= ( i - n + 1 ) ;					  
  }							      	}							      }								  
  return path ;						      	return path ;						      return path ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	      NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	    NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	  NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES
--							      --							    --								  --
static int countRect ( int n ) {			      int countRect ( int n ) {					    int countRect ( int n ) {					  success : identical to gold
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  for ( int length = 1 ;				      	for ( int length = 1 ;					      for ( int length = 1 ;					  
  length <= Math . sqrt ( n ) ;				      	length <= sqrt ( n ) ;					      length <= sqrt ( n ) ;					  
  ++ length ) for ( int height = length ;		      	++ length ) for ( int height = length ;			      ++ length ) for ( int height = length ;			  
  height * length <= n ;				      	height * length <= n ;					      height * length <= n ;					  
  ++ height ) ans ++ ;					      	++ height ) ans ++ ;					      ++ height ) ans ++ ;					  
  return ans ;						      	return ans ;						      return ans ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1     SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1	    SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1	  SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1
--							      --							    --								  --
static int smallest ( int x , int y , int z ) {		      int smallest ( int x , int y , int z ) {			    int smallest ( int x , int y , int z ) {			  failure : #Results: 5, 10
  if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ;   	if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ;	      if ( ( y / x ) != 1 ) return ( ( y / z ) != 1 ) ? y : z ;	  
  return ( ( x / z ) != 1 ) ? x : z ;			      	return ( ! ( x / z ) ) ? x : z ;			      return ( ( x / z ) != 1 ) ? x : z ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	      TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	    TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	  TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1
--							      --							    --								  --
static long countNonDecreasing ( int n ) {		      long long int countNonDecreasing ( int n ) {		    long long countNonDecreasing ( int n ) {			  success : None
  int N = 10 ;						      	int N = 10 ;						      int N = 10 ;						  
  long count = 1 ;					      	long long count = 1 ;					      long long count = 1 ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    count *= ( N + i - 1 ) ;				      	  count *= ( N + i - 1 ) ;				    	count *= ( N + i - 1 ) ;				  
    count /= i ;					      	  count /= i ;						    	count /= i ;						  
  }							      	}							      }								  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	      FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	    FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	  FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN
--							      --							    --								  --
static double compute ( int a , int b ) {		      double compute ( int a , int b ) {			    double compute ( int a , int b ) {				  success : identical to gold
  double AM , GM , HM ;					      	double AM , GM , HM ;					      double AM , GM , HM ;					  
  AM = ( a + b ) / 2 ;					      	AM = ( a + b ) / 2 ;					      AM = ( a + b ) / 2 ;					  
  GM = Math . sqrt ( a * b ) ;				      	GM = sqrt ( a * b ) ;					      GM = sqrt ( a * b ) ;					  
  HM = ( GM * GM ) / AM ;				      	HM = ( GM * GM ) / AM ;					      HM = ( GM * GM ) / AM ;					  
  return HM ;						      	return HM ;						      return HM ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		      DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		    DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		  DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT
--							      --							    --								  --
static int binomialCoeff ( int n , int k ) {		      int binomialCoeff ( int n , int k ) {			    int binomialCoeff ( int n , int k ) {			  script_not_found : None
  if ( k == 0 || k == n ) return 1 ;			      	if ( k == 0 || k == n ) return 1 ;			      if ( k == 0 || k == n ) return 1 ;			  
  return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n  	return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n    return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE		      NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE			    NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE			  NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE
--							      --							    --								  --
static int answer_query ( int a [ ] , int n , int l , int r ) int answer_query ( int a [ ] , int n , int l , int r ) {	    int answer_query ( int a [ ] , int n , int l , int r ) {	  success : identical to gold
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = l ;					      	for ( int i = l ;					      for ( int i = l ;						  
  i < r ;						      	i < r ;							      i < r ;							  
  i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ;	      	i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ;	      i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ;		  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2   SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2   SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2	  SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2
--							      --							    --								  --
static int findSum ( int n ) {				      int findSum ( int n ) {					    int findSum ( int n ) {					  success : identical to gold
  n -- ;						      	n -- ;							      n -- ;							  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  sum += ( n * ( n + 1 ) ) / 2 ;			      	sum += ( n * ( n + 1 ) ) / 2 ;				      sum += ( n * ( n + 1 ) ) / 2 ;				  
  sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;	      	sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;		      sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;		  
  return sum ;						      	return sum ;						      return sum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM	      RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM		    RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM		  RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM
--							      --							    --								  --
static int breakSum ( int n ) {				      int breakSum ( int n ) {					    int breakSum ( int n ) {					  success : identical to gold
  if ( n == 0 || n == 1 ) return n ;			      	if ( n == 0 || n == 1 ) return n ;			      if ( n == 0 || n == 1 ) return n ;			  
  return Math . max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 	return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + br   return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + br 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHANGE_BITS_CAN_MADE_ONE_FLIP_1				      CHANGE_BITS_CAN_MADE_ONE_FLIP_1				    CHANGE_BITS_CAN_MADE_ONE_FLIP_1				  CHANGE_BITS_CAN_MADE_ONE_FLIP_1
--							      --							    --								  --
static boolean isOneFlip ( String str ) {		      bool isOneFlip ( string str ) {				    bool isOneFlip ( string str ) {				  success : None
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) sum += str . charAt ( i ) - '0' ;		      	i ++ ) sum += str [ i ] - '0' ;				      i ++ ) {							  
  return ( sum == n - 1 || sum == 1 ) ;			      	return ( sum == n - 1 || sum == 1 ) ;			    	sum += str [ i ] - '0' ;				  
}							      }								      }								  
							      								      return ( sum == n - 1 || sum == 1 ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHANGE_BITS_CAN_MADE_ONE_FLIP				      CHANGE_BITS_CAN_MADE_ONE_FLIP				    CHANGE_BITS_CAN_MADE_ONE_FLIP				  CHANGE_BITS_CAN_MADE_ONE_FLIP
--							      --							    --								  --
static boolean canMakeAllSame ( String str ) {		      bool canMakeAllSame ( string str ) {			    bool canMakeAllSame ( string str ) {			  success : None
  int zeros = 0 , ones = 0 ;				      	int zeros = 0 , ones = 0 ;				      int zeros = 0 , ones = 0 ;				  
  for ( int i = 0 ;					      	for ( char ch : str ) ( ch == '0' ) ? ++ zeros : ++ ones ;    for ( int i = 0 ;						  
  i < str . length ( ) ;				      	return ( zeros == 1 || ones == 1 ) ;			      i < str . length ( ) ;					  
  i ++ ) {						      }								      i ++ ) {							  
    char ch = str . charAt ( i ) ;			      								    	char ch = str [ i ] ;					  
    if ( ch == '0' ) ++ zeros ;				      								    	if ( ch == '0' ) {					  
    else ++ ones ;					      								    	  zeros ++ ;						  
  }							      								    	}							  
  return ( zeros == 1 || ones == 1 ) ;			      								    	else {							  
}							      								    	  ones ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return ( zeros == 1 || ones == 1 ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_20				      CHECK_LARGE_NUMBER_DIVISIBLE_20				    CHECK_LARGE_NUMBER_DIVISIBLE_20				  CHECK_LARGE_NUMBER_DIVISIBLE_20
--							      --							    --								  --
static Boolean divisibleBy20 ( String num ) {		      bool divisibleBy20 ( string num ) {			    bool divisibleBy20 ( string num ) {				  script_not_found : None
  int lastTwoDigits = Integer . parseInt ( num . substring (  	int lastTwoDigits = stoi ( num . substr ( num . length ( )    int lastTwoDigits = atoi ( num . substr ( num . length ( )  
  return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4  	return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4    return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		      RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		    RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		  RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS
--							      --							    --								  --
public static int findFrequency ( int arr [ ] , int n , int l int findFrequency ( int arr [ ] , int n , int left , int righ int findFrequency ( int arr [ ] , int n , int left , int righ script_not_found : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = left - 1 ;				      	for ( int i = left - 1 ;				      for ( int i = left - 1 ;					  
  i < right ;						      	i <= right ;						      i < right ;						  
  ++ i ) if ( arr [ i ] == element ) ++ count ;		      	++ i ) if ( arr [ i ] == element ) ++ count ;		      ++ i ) if ( arr [ i ] == element ) ++ count ;		  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS
--							      --							    --								  --
static String decToBin ( int n ) {			      string decToBin ( int n ) {				    string decToBin ( int n ) {					  success : None
  if ( n == 0 ) return "0" ;				      	if ( n == 0 ) return "0" ;				      if ( n == 0 ) return "0" ;				  
  String bin = "" ;					      	string bin = "" ;					      string bin ;						  
  while ( n > 0 ) {					      	while ( n > 0 ) {					      while ( n > 0 ) {						  
    bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ;	      	  bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ;		    	bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ;		  
    n >>= 1 ;						      	  n >>= 1 ;						    	n >>= 1 ;						  
  }							      	}							      }								  
  return bin ;						      	return bin ;						      return bin ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1     GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1	    GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1	  GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1
--							      --							    --								  --
int countSubStr ( char str [ ] , int n ) {		      int countSubStr ( char str [ ] ) {			    int countSubStr ( char str [ ] , int n ) {			  script_not_found : None
  int m = 0 ;						      	int m = 0 ;						      int m = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	str [ i ] != '\0' ;					      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( str [ i ] == '1' ) m ++ ;			      	  if ( str [ i ] == '1' ) m ++ ;			    	if ( str [ i ] == '1' ) {				  
  }							      	}							    	  m ++ ;						  
  return m * ( m - 1 ) / 2 ;				      	return m * ( m - 1 ) / 2 ;				    	}							  
}							      }								      }								  
							      								      return m * ( m - 1 ) / 2 ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1
--							      --							    --								  --
static char first ( String str , int i ) {		      char first ( string str , int i = 0 ) {			    char first ( const char * str , int i ) {			  error : FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATI
  if ( str . charAt ( i ) == '\0' ) return 0 ;		      	if ( str [ i ] == '\0' ) return 0 ;			      if ( str [ i ] == '\0' ) return 0 ;			  VE_AND_RECURSIVE_1.cpp: In function ‘int main()’:
  if ( Character . isUpperCase ( str . charAt ( i ) ) ) retur 	if ( isupper ( str [ i ] ) ) return str [ i ] ;		      if ( isupper ( str [ i ] ) ) return str [ i ] ;		  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_R
  return first ( str , i + 1 ) ;			      	return first ( str , i + 1 ) ;				      return first ( str , i + 1 ) ;				  ECURSIVE_1.cpp:36:40: error: cannot convert ‘__gnu
}							      }								    }								  _cxx::__alloc_traits<std::allocator<std::__cxx11::
							      								    								  basic_string<char> >, std::__cxx11::basic_string<c
							      								    								  har> >::value_type’ {aka ‘std::__cxx11::basic_stri
							      								    								  ng<char>’} to ‘const char*’	       if(f_filled(p
							      								    								  aram0[i],param1[i]) == f_gold(param0[i],param1[i])
							      								    								  )					    ^ FIRST_
							      								    								  UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSI
							      								    								  VE_1.cpp:23:30: note:	  initializing argument 1 of
							      								    								   ‘char f_filled(const char*, int)’  char f_filled
							      								    								  ( const char * str , int i ) {		  ~~
							      								    								  ~~~~~~~~~~~^~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_DIVISIBILITY_BINARY_STRING_2K			      CHECK_DIVISIBILITY_BINARY_STRING_2K			    CHECK_DIVISIBILITY_BINARY_STRING_2K				  CHECK_DIVISIBILITY_BINARY_STRING_2K
--							      --							    --								  --
static boolean isDivisible ( String str , int k ) {	      bool isDivisible ( char str [ ] , int k ) {		    bool isDivisible ( string str , int k ) {			  error : /bin/bash: line 1: 3924789 Aborted
  int n = str . length ( ) ;				      	int n = strlen ( str ) ;				      int n = str . length ( ) ;				  	   (core dumped) ./CHECK_DIVISIBILITY_BINARY
  int c = 0 ;						      	int c = 0 ;						      int c = 0 ;						  _STRING_2K_cpp
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < k ;						      	i < k ;							      i < k ;							  
  i ++ ) if ( str . charAt ( n - i - 1 ) == '0' ) c ++ ;      	i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ;		      i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ;		  
  return ( c == k ) ;					      	return ( c == k ) ;					      return ( c == k ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	      PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	    PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	  PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1
--							      --							    --								  --
static void printSquares ( int n ) {			      void printSquares ( int n ) {				    void printSquares ( int n ) {				  script_not_found : None
  int square = 0 , odd = 1 ;				      	int square = 0 , odd = 1 ;				      int square = 0 , odd = 1 ;				  
  for ( int x = 0 ;					      	for ( int x = 0 ;					      for ( int x = 0 ;						  
  x < n ;						      	x < n ;							      x < n ;							  
  x ++ ) {						      	x ++ ) {						      x ++ ) {							  
    System . out . print ( square + " " ) ;		      	  cout << square << " " ;				    	cout << square << " " ;					  
    square = square + odd ;				      	  square = square + odd ;				    	square = square + odd ;					  
    odd = odd + 2 ;					      	  odd = odd + 2 ;					    	odd = odd + 2 ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3		      COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3		    COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3			  COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3
--							      --							    --								  --
public static int findStep ( int n ) {			      public : int findStep ( int n ) {				    int findStep ( int n ) {					  script_not_found : None
  if ( n == 1 || n == 0 ) return 1 ;			      	if ( n == 1 || n == 0 ) return 1 ;			      if ( n == 1 || n == 0 ) return 1 ;			  
  else if ( n == 2 ) return 2 ;				      	else if ( n == 2 ) return 2 ;				      else if ( n == 2 ) return 2 ;				  
  else return findStep ( n - 3 ) + findStep ( n - 2 ) + findS 	else return findStep ( n - 3 ) + findStep ( n - 2 ) + findS   else return findStep ( n - 3 ) + findStep ( n - 2 ) + findS 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY		      K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY			    K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY			  K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY
--							      --							    --								  --
public static void kLargest ( Integer [ ] arr , int k ) {     void kLargest ( int arr [ ] , int n , int k ) {		    void k_largest ( int32_t * arr , int32_t k ) {		  script_not_found : None
  Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;    	sort ( arr , arr + n , greater < int > ( ) ) ;		      std :: sort ( arr , arr + k ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int32_t i = 0 ;					  
  i < k ;						      	i < k ;							      i < k ;							  
  i ++ ) System . out . print ( arr [ i ] + " " ) ;	      	i ++ ) cout << arr [ i ] << " " ;			      i ++ ) {							  
}							      }								    	std :: cout << arr [ i ] << " " ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MODULUS_TWO_FLOAT_DOUBLE_NUMBERS			      MODULUS_TWO_FLOAT_DOUBLE_NUMBERS				    MODULUS_TWO_FLOAT_DOUBLE_NUMBERS				  MODULUS_TWO_FLOAT_DOUBLE_NUMBERS
--							      --							    --								  --
static double findMod ( double a , double b ) {		      double findMod ( double a , double b ) {			    double findMod ( double a , double b ) {			  success : None
  if ( a < 0 ) a = - a ;				      	double mod ;						      if ( a < 0 ) a = - a ;					  
  if ( b < 0 ) b = - b ;				      	if ( a < 0 ) mod = - a ;				      if ( b < 0 ) b = - b ;					  
  double mod = a ;					      	else mod = a ;						      double mod = a ;						  
  while ( mod >= b ) mod = mod - b ;			      	if ( b < 0 ) b = - b ;					      while ( mod >= b ) mod = mod - b ;			  
  if ( a < 0 ) return - mod ;				      	while ( mod >= b ) mod = mod - b ;			      if ( a < 0 ) return - mod ;				  
  return mod ;						      	if ( a < 0 ) return - mod ;				      return mod ;						  
}							      	return mod ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION_2			      PROGRAM_DECIMAL_BINARY_CONVERSION_2			    PROGRAM_DECIMAL_BINARY_CONVERSION_2				  PROGRAM_DECIMAL_BINARY_CONVERSION_2
--							      --							    --								  --
static int decimalToBinary ( int N ) {			      unsigned long long int int decimalToBinary ( int N ) {	    int decimalToBinary ( int N ) {				  script_not_found : None
  int B_Number = 0 ;					      	ull B_Number = 0 ;					      int B_Number = 0 ;					  
  int cnt = 0 ;						      	int cnt = 0 ;						      int cnt = 0 ;						  
  while ( N != 0 ) {					      	while ( N != 0 ) {					      while ( N != 0 ) {					  
    int rem = N % 2 ;					      	  int rem = N % 2 ;					    	int rem = N % 2 ;					  
    double c = Math . pow ( 10 , cnt ) ;		      	  ull c = pow ( 10 , cnt ) ;				    	double c = pow ( 10 , cnt ) ;				  
    B_Number += rem * c ;				      	  B_Number += rem * c ;					    	B_Number += rem * c ;					  
    N /= 2 ;						      	  N /= 2 ;						    	N /= 2 ;						  
    cnt ++ ;						      	  cnt ++ ;						    	cnt ++ ;						  
  }							      	}							      }								  
  return B_Number ;					      	return B_Number ;					      return B_Number ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1   DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1   DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1	  DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1
--							      --							    --								  --
static int maxProd ( int n ) {				      int maxProd ( int n ) {					    int maxProd ( int n ) {					  success : identical to gold
  if ( n == 2 || n == 3 ) return ( n - 1 ) ;		      	if ( n == 2 || n == 3 ) return ( n - 1 ) ;		      if ( n == 2 || n == 3 ) return ( n - 1 ) ;		  
  int res = 1 ;						      	int res = 1 ;						      int res = 1 ;						  
  while ( n > 4 ) {					      	while ( n > 4 ) {					      while ( n > 4 ) {						  
    n -= 3 ;						      	  n -= 3 ;						    	n -= 3 ;						  
    res *= 3 ;						      	  res *= 3 ;						    	res *= 3 ;						  
  }							      	}							      }								  
  return ( n * res ) ;					      	return ( n * res ) ;					      return ( n * res ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2		      N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2			    N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2			  N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2
--							      --							    --								  --
public static int findNth ( int n ) {			      int findNth ( int n ) {					    int findNth ( int n ) {					  success : None
  int nthElement = 19 + ( n - 1 ) * 9 ;			      	int nthElement = 19 + ( n - 1 ) * 9 ;			      int nth_element = 19 + ( n - 1 ) * 9 ;			  
  int outliersCount = ( int ) Math . log10 ( nthElement ) - 1 	int outliersCount = ( int ) log10 ( nthElement ) - 1 ;	      int outliers_count = ( int ) log10 ( nth_element ) - 1 ;	  
  nthElement += 9 * outliersCount ;			      	nthElement += 9 * outliersCount ;			      nth_element += 9 * outliers_count ;			  
  return nthElement ;					      	return nthElement ;					      return nth_element ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA
--							      --							    --								  --
static String lexsmallest ( String a [ ] , int n ) {	      string lexSmallest ( string a [ ] , int n ) {		    string lexsmallest ( string a , int n ) {			  script_not_found : None
  sort ( a , n ) ;					      	sort ( a , a + n , compare ) ;				      sort ( a . begin ( ) , a . end ( ) ) ;			  
  String answer = "" ;					      	string answer = "" ;					      string answer ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) answer += a [ i ] ;				      	i ++ ) answer += a [ i ] ;				      i ++ ) {							  
  return answer ;					      	return answer ;						    	answer += a [ i ] ;					  
}							      }								      }								  
							      								      return answer ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	      FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	    FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	  FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X
--							      --							    --								  --
static int firstFactorialDivisibleNumber ( int x ) {	      int firstFactorialDivisibleNumber ( int x ) {		    int firstFactorialDivisibleNumber ( int x ) {		  success : identical to gold
  int i = 1 ;						      	int i = 1 ;						      int i = 1 ;						  
  int fact = 1 ;					      	int fact = 1 ;						      int fact = 1 ;						  
  for ( i = 1 ;						      	for ( i = 1 ;						      for ( i = 1 ;						  
  i < x ;						      	i < x ;							      i < x ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    fact = fact * i ;					      	  fact = fact * i ;					    	fact = fact * i ;					  
    if ( fact % x == 0 ) break ;			      	  if ( fact % x == 0 ) break ;				    	if ( fact % x == 0 ) break ;				  
  }							      	}							      }								  
  return i ;						      	return i ;						      return i ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTING_INVERSIONS					      COUNTING_INVERSIONS					    COUNTING_INVERSIONS						  COUNTING_INVERSIONS
--							      --							    --								  --
static int getInvCount ( int n ) {			      int getInvCount ( int arr [ ] , int n ) {			    int getInvCount ( int n ) {					  script_not_found : None
  int inv_count = 0 ;					      	int inv_count = 0 ;					      int inv_count = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ;	      	j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ;	      j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ;	  
  return inv_count ;					      	return inv_count ;					      return inv_count ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE     CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE	    CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE	  CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE
--							      --							    --								  --
static boolean check ( int degree [ ] , int n ) {	      bool check ( int degree [ ] , int n ) {			    bool check ( int degree [ ] , int n ) {			  success : identical to gold
  int deg_sum = 0 ;					      	int deg_sum = 0 ;					      int deg_sum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) deg_sum += degree [ i ] ;			      i ++ ) deg_sum += degree [ i ] ;				  
    deg_sum += degree [ i ] ;				      	return ( 2 * ( n - 1 ) == deg_sum ) ;			      return ( 2 * ( n - 1 ) == deg_sum ) ;			  
  }							      }								    }								  
  return ( 2 * ( n - 1 ) == deg_sum ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			      COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			    COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			  COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY
--							      --							    --								  --
static int countPairs ( int arr [ ] , int n ) {		      int countPairs ( int arr [ ] , int n ) {			    int countPairs ( int arr [ ] , int n ) {			  success : identical to gold
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ;		      	j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ;		      j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ;		  
  return ans ;						      	return ans ;						      return ans ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE	      REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE	    REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE		  REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE
--							      --							    --								  --
static String reversingString ( char [ ] str , int start , in string reversingString ( string str , int start , int end ) { string reversingString ( string str , int start , int end ) { script_not_found : None
  while ( start < end ) {				      	while ( start < end ) {					      while ( start < end ) {					  
    str [ start ] ^= str [ end ] ;			      	  str [ start ] ^= str [ end ] ;			    	str [ start ] ^= str [ end ] ;				  
    str [ end ] ^= str [ start ] ;			      	  str [ end ] ^= str [ start ] ;			    	str [ end ] ^= str [ start ] ;				  
    str [ start ] ^= str [ end ] ;			      	  str [ start ] ^= str [ end ] ;			    	str [ start ] ^= str [ end ] ;				  
    ++ start ;						      	  ++ start ;						    	++ start ;						  
    -- end ;						      	  -- end ;						    	-- end ;						  
  }							      	}							      }								  
  return String . valueOf ( str ) ;			      	return str ;						      return string ( str . begin ( ) , str . end ( ) ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PAPER_CUT_MINIMUM_NUMBER_SQUARES			      PAPER_CUT_MINIMUM_NUMBER_SQUARES				    PAPER_CUT_MINIMUM_NUMBER_SQUARES				  PAPER_CUT_MINIMUM_NUMBER_SQUARES
--							      --							    --								  --
static int minimumSquare ( int a , int b ) {		      int minimumSquare ( int a , int b ) {			    int minimum_square ( int a , int b ) {			  success : None
  int result = 0 , rem = 0 ;				      	long long result = 0 , rem = 0 ;			      int result = 0 , rem = 0 ;				  
  if ( a < b ) swap ( a , b ) ;				      	if ( a < b ) swap ( a , b ) ;				      if ( a < b ) {						  
  while ( b > 0 ) {					      	while ( b > 0 ) {					    	swap ( a , b ) ;					  
    result += a / b ;					      	  result += a / b ;					      }								  
    rem = a % b ;					      	  long long rem = a % b ;				      while ( b > 0 ) {						  
    a = b ;						      	  a = b ;						    	result += a / b ;					  
    b = rem ;						      	  b = rem ;						    	rem = a % b ;						  
  }							      	}							    	a = b ;							  
  return result ;					      	return result ;						    	b = rem ;						  
}							      }								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DIGITS_FACTORIAL_SET_1				      COUNT_DIGITS_FACTORIAL_SET_1				    COUNT_DIGITS_FACTORIAL_SET_1				  COUNT_DIGITS_FACTORIAL_SET_1
--							      --							    --								  --
static int findDigits ( int n ) {			      int findDigits ( int n ) {				    int findDigits ( int n ) {					  success : None
  if ( n < 0 ) return 0 ;				      	if ( n < 0 ) return 0 ;					      if ( n < 0 ) return 0 ;					  
  if ( n <= 1 ) return 1 ;				      	if ( n <= 1 ) return 1 ;				      if ( n <= 1 ) return 1 ;					  
  double digits = 0 ;					      	double digits = 0 ;					      double digits = 0 ;					  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) digits += Math . log10 ( i ) ;			      	i ++ ) digits += log10 ( i ) ;				      i ++ ) {							  
  return ( int ) ( Math . floor ( digits ) ) + 1 ;	      	return floor ( digits ) + 1 ;				    	digits += log10 ( i ) ;					  
}							      }								      }								  
							      								      return int ( floor ( digits ) ) + 1 ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2		      MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2		    MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2			  MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2
--							      --							    --								  --
public static int middleOfThree ( int a , int b , int c ) {   int middleOfThree ( int a , int b , int c ) {		    int middleOfThree ( int a , int b , int c ) {		  success : identical to gold
  int x = a - b ;					      	int x = a - b ;						      int x = a - b ;						  
  int y = b - c ;					      	int y = b - c ;						      int y = b - c ;						  
  int z = a - c ;					      	int z = a - c ;						      int z = a - c ;						  
  if ( x * y > 0 ) return b ;				      	if ( x * y > 0 ) return b ;				      if ( x * y > 0 ) return b ;				  
  else if ( x * z > 0 ) return c ;			      	else if ( x * z > 0 ) return c ;			      else if ( x * z > 0 ) return c ;				  
  else return a ;					      	else return a ;						      else return a ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX		      SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX			    SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX			  SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX
--							      --							    --								  --
static void swapDiagonal ( int matrix [ ] [ ] ) {	      void swapDiagonal ( int matrix [ ] [ N ] ) {		    void swapDiagonal ( int matrix [ N ] [ N ] ) {		  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) {						      	i ++ ) swap ( matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1   i ++ ) {							  
    int temp = matrix [ i ] [ i ] ;			      }								    	int temp = matrix [ i ] [ i ] ;				  
    matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] ;	      								    	matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] ;	  
    matrix [ i ] [ N - i - 1 ] = temp ;			      								    	matrix [ i ] [ N - i - 1 ] = temp ;			  
  }							      								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION     DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION	    DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION	  DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION
--							      --							    --								  --
static int lastPosition ( int n , int m , int k ) {	      int lastPosition ( int n , int m , int k ) {		    int lastPosition ( int n , int m , int k ) {		  success : identical to gold
  if ( m <= n - k + 1 ) return m + k - 1 ;		      	if ( m <= n - k + 1 ) return m + k - 1 ;		      if ( m <= n - k + 1 ) return m + k - 1 ;			  
  m = m - ( n - k + 1 ) ;				      	m = m - ( n - k + 1 ) ;					      m = m - ( n - k + 1 ) ;					  
  return ( m % n == 0 ) ? n : ( m % n ) ;		      	return ( m % n == 0 ) ? n : ( m % n ) ;			      return ( m % n == 0 ) ? n : ( m % n ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		      FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		    FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		  FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME
--							      --							    --								  --
static int findIndex ( int n ) {			      int findIndex ( int n ) {					    int findIndex ( int n ) {					  success : identical to gold
  if ( n <= 1 ) return n ;				      	if ( n <= 1 ) return n ;				      if ( n <= 1 ) return n ;					  
  int a = 0 , b = 1 , c = 1 ;				      	int a = 0 , b = 1 , c = 1 ;				      int a = 0 , b = 1 , c = 1 ;				  
  int res = 1 ;						      	int res = 1 ;						      int res = 1 ;						  
  while ( c < n ) {					      	while ( c < n ) {					      while ( c < n ) {						  
    c = a + b ;						      	  c = a + b ;						    	c = a + b ;						  
    res ++ ;						      	  res ++ ;						    	res ++ ;						  
    a = b ;						      	  a = b ;						    	a = b ;							  
    b = c ;						      	  b = c ;						    	b = c ;							  
  }							      	}							      }								  
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_ROTATIONS_REQUIRED_GET_STRING			      MINIMUM_ROTATIONS_REQUIRED_GET_STRING			    MINIMUM_ROTATIONS_REQUIRED_GET_STRING			  MINIMUM_ROTATIONS_REQUIRED_GET_STRING
--							      --							    --								  --
static int findRotations ( String str ) {		      int findRotations ( string str ) {			    int findRotations ( string str ) {				  success : None
  String tmp = str + str ;				      	string tmp = str + str ;				      string tmp = str + str ;					  
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    String substring = tmp . substring ( i , str . length ( ) 	  string substring = tmp . substr ( i , str . size ( ) ) ;  	string substring = tmp . substr ( i , str . length ( ) )  
    if ( str == substring ) return i ;			      	  if ( str == substring ) return i ;			    	if ( str == substring ) return i ;			  
  }							      	}							      }								  
  return n ;						      	return n ;						      return n ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			      PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			    PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			  PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX
--							      --							    --								  --
static void transpose ( int A [ ] [ ] , int B [ ] [ ] ) {     void transpose ( int A [ ] [ N ] , int B [ ] [ N ] ) {	    void transpose ( int A [ N ] [ N ] , int B [ N ] [ N ] ) {	  script_not_found : None
  int i , j ;						      	int i , j ;						      int i , j ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) for ( j = 0 ;					      	i ++ ) for ( j = 0 ;					      i ++ ) for ( j = 0 ;					  
  j < N ;						      	j < N ;							      j < N ;							  
  j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ;		      	j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ;			      j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		      FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		    FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		  FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS
--							      --							    --								  --
static int countSquares ( int a , int b ) {		      int countSquares ( int a , int b ) {			    int countSquares ( int a , int b ) {			  success : identical to gold
  int cnt = 0 ;						      	int cnt = 0 ;						      int cnt = 0 ;						  
  for ( int i = a ;					      	for ( int i = a ;					      for ( int i = a ;						  
  i <= b ;						      	i <= b ;						      i <= b ;							  
  i ++ ) for ( int j = 1 ;				      	i ++ ) for ( int j = 1 ;				      i ++ ) for ( int j = 1 ;					  
  j * j <= i ;						      	j * j <= i ;						      j * j <= i ;						  
  j ++ ) if ( j * j == i ) cnt ++ ;			      	j ++ ) if ( j * j == i ) cnt ++ ;			      j ++ ) if ( j * j == i ) cnt ++ ;				  
  return cnt ;						      	return cnt ;						      return cnt ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_OCTAL_DECIMAL_CONVERSION			      PROGRAM_OCTAL_DECIMAL_CONVERSION				    PROGRAM_OCTAL_DECIMAL_CONVERSION				  PROGRAM_OCTAL_DECIMAL_CONVERSION
--							      --							    --								  --
static int octalToDecimal ( int n ) {			      int octalToDecimal ( int n ) {				    int octalToDecimal ( int n ) {				  success : None
  int num = n ;						      	int num = n ;						      int num = n ;						  
  int dec_value = 0 ;					      	int dec_value = 0 ;					      int decValue = 0 ;					  
  int base = 1 ;					      	int base = 1 ;						      int base = 1 ;						  
  int temp = num ;					      	int temp = num ;					      int temp = num ;						  
  while ( temp > 0 ) {					      	while ( temp ) {					      while ( temp > 0 ) {					  
    int last_digit = temp % 10 ;			      	  int last_digit = temp % 10 ;				    	int lastDigit = temp % 10 ;				  
    temp = temp / 10 ;					      	  temp = temp / 10 ;					    	temp = temp / 10 ;					  
    dec_value += last_digit * base ;			      	  dec_value += last_digit * base ;			    	decValue += lastDigit * base ;				  
    base = base * 8 ;					      	  base = base * 8 ;					    	base = base * 8 ;					  
  }							      	}							      }								  
  return dec_value ;					      	return dec_value ;					      return decValue ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	      PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	    PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	  PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1
--							      --							    --								  --
static boolean arraySortedOrNot ( int arr [ ] , int n ) {     bool arraySortedOrNot ( int arr [ ] , int n ) {		    bool arraySortedOrNot ( int arr [ ] , int n ) {		  success : identical to gold
  if ( n == 0 || n == 1 ) return true ;			      	if ( n == 0 || n == 1 ) return true ;			      if ( n == 0 || n == 1 ) return true ;			  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ;      	i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ;	      i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ;	  
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ARC_LENGTH_ANGLE					      ARC_LENGTH_ANGLE						    ARC_LENGTH_ANGLE						  ARC_LENGTH_ANGLE
--							      --							    --								  --
static double arcLength ( double diameter , double angle ) {  double arcLength ( double diameter , double angle ) {	    double arcLength ( double diameter , double angle ) {	  script_not_found : None
  double pi = 22.0 / 7.0 ;				      	double pi = 22.0 / 7.0 ;				      double pi = 22.0 / 7.0 ;					  
  double arc ;						      	double arc ;						      double arc ;						  
  if ( angle >= 360 ) {					      	if ( angle >= 360 ) {					      if ( angle >= 360 ) {					  
    System . out . println ( "Angle cannot" + " be formed" )  	  cout << "Angle cannot" , " be formed" ;		    	cout << "Angle cannot" << " be formed" << endl ;	  
    return 0 ;						      	  return 0 ;						    	return 0 ;						  
  }							      	}							      }								  
  else {						      	else {							      else {							  
    arc = ( pi * diameter ) * ( angle / 360.0 ) ;	      	  arc = ( pi * diameter ) * ( angle / 360.0 ) ;		    	arc = ( pi * diameter ) * ( angle / 360.0 ) ;		  
    return arc ;					      	  return arc ;						    	return arc ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING	      PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING	    PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING		  PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING
--							      --							    --								  --
static void printSquares ( int n ) {			      void printSquares ( int n ) {				    void printSquares ( int n ) {				  script_not_found : None
  int square = 0 , prev_x = 0 ;				      	int square = 0 , prev_x = 0 ;				      int square = 0 , prev_x = 0 ;				  
  for ( int x = 0 ;					      	for ( int x = 0 ;					      for ( int x = 0 ;						  
  x < n ;						      	x < n ;							      x < n ;							  
  x ++ ) {						      	x ++ ) {						      x ++ ) {							  
    square = ( square + x + prev_x ) ;			      	  square = ( square + x + prev_x ) ;			    	square = ( square + x + prev_x ) ;			  
    System . out . print ( square + " " ) ;		      	  cout << square << " " ;				    	cout << square << " " ;					  
    prev_x = x ;					      	  prev_x = x ;						    	prev_x = x ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1	      EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1		    EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1		  EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1
--							      --							    --								  --
static long exponentiation ( long base , long exp ) {	      long exponentiation ( long base , long exp ) {		    long long exponentiation ( long long base , long long exp ) { script_not_found : None
  long t = 1L ;						      	long t = 1L ;						      long long t = 1 ;						  
  while ( exp > 0 ) {					      	while ( exp > 0 ) {					      while ( exp > 0 ) {					  
    if ( exp % 2 != 0 ) t = ( t * base ) % N ;		      	  if ( exp % 2 != 0 ) t = ( t * base ) % N ;		    	if ( exp % 2 != 0 ) {					  
    base = ( base * base ) % N ;			      	  base = ( base * base ) % N ;				    	  t = ( t * base ) % N ;				  
    exp /= 2 ;						      	  exp /= 2 ;						    	}							  
  }							      	}							    	base = ( base * base ) % N ;				  
  return t % N ;					      	return t % N ;						    	exp /= 2 ;						  
}							      }								      }								  
							      								      return t % N ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y
--							      --							    --								  --
static int countSolutions ( int n ) {			      int countSolutions ( int n ) {				    int countSolutions ( int n ) {				  success : identical to gold
  int res = 0 ;						      	int res = 0 ;						      int res = 0 ;						  
  for ( int x = 0 ;					      	for ( int x = 0 ;					      for ( int x = 0 ;						  
  x * x < n ;						      	x * x < n ;						      x * x < n ;						  
  x ++ ) for ( int y = 0 ;				      	x ++ ) for ( int y = 0 ;				      x ++ ) for ( int y = 0 ;					  
  x * x + y * y < n ;					      	x * x + y * y < n ;					      x * x + y * y < n ;					  
  y ++ ) res ++ ;					      	y ++ ) res ++ ;						      y ++ ) res ++ ;						  
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		      PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		    PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		  PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11
--							      --							    --								  --
static int remainder ( String str ) {			      int remainder ( string str ) {				    int remainder ( string str ) {				  success : identical to gold
  int len = str . length ( ) ;				      	int len = str . length ( ) ;				      int len = str . length ( ) ;				  
  int num , rem = 0 ;					      	int num , rem = 0 ;					      int num , rem = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < len ;						      	i < len ;						      i < len ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    num = rem * 10 + ( str . charAt ( i ) - '0' ) ;	      	  num = rem * 10 + ( str [ i ] - '0' ) ;		    	num = rem * 10 + ( str [ i ] - '0' ) ;			  
    rem = num % 11 ;					      	  rem = num % 11 ;					    	rem = num % 11 ;					  
  }							      	}							      }								  
  return rem ;						      	return rem ;						      return rem ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1		      FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1		    FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1			  FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1
--							      --							    --								  --
static double sumNodes ( int l ) {			      int sumNodes ( int l ) {					    double sumNodes ( int l ) {					  script_not_found : None
  double leafNodeCount = Math . pow ( 2 , l - 1 ) ;	      	int leafNodeCount = pow ( 2 , l - 1 ) ;			      double leafNodeCount = pow ( 2 , l - 1 ) ;		  
  double sumLastLevel = 0 ;				      	int sumLastLevel = 0 ;					      double sumLastLevel = 0 ;					  
  sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) /  	sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) /    sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) /  
  double sum = sumLastLevel * l ;			      	int sum = sumLastLevel * l ;				      double sum = sumLastLevel * l ;				  
  return sum ;						      	return sum ;						      return sum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	      CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	    CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	  CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT
--							      --							    --								  --
static boolean isInorder ( int [ ] arr , int n ) {	      bool isInorder ( int arr [ ] , int n ) {			    bool isInorder ( int * arr , int n ) {			  success : None
  if ( n == 0 || n == 1 ) {				      	if ( n == 0 || n == 1 ) return true ;			      if ( n == 0 || n == 1 ) return true ;			  
    return true ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  }							      	i < n ;							      i < n ;							  
  for ( int i = 1 ;					      	i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ;	      i ++ ) {							  
  i < n ;						      	return true ;						    	if ( arr [ i - 1 ] > arr [ i ] ) return false ;		  
  i ++ ) {						      }								      }								  
    if ( arr [ i - 1 ] > arr [ i ] ) {			      								      return true ;						  
      return false ;					      								    }								  
    }							      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			      MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			    MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			  MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS
--							      --							    --								  --
static int minTime ( int [ ] arr , int n , int m ) {	      int minTime ( int arr [ ] , int n , int m ) {		    int minTime ( int * arr , int n , int m ) {			  script_not_found : None
  int t = 0 ;						      	int t = 0 ;						      int t = 0 ;						  
  while ( true ) {					      	while ( 1 ) {						      while ( true ) {						  
    int items = 0 ;					      	  int items = 0 ;					    	int items = 0 ;						  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
    i < n ;						      	  i < n ;						    	i < n ;							  
    i ++ ) items += ( t / arr [ i ] ) ;			      	  i ++ ) items += ( t / arr [ i ] ) ;			    	i ++ ) {						  
    if ( items >= m ) return t ;			      	  if ( items >= m ) return t ;				    	  items += ( t / arr [ i ] ) ;				  
    t ++ ;						      	  t ++ ;						    	}							  
  }							      	}							    	if ( items >= m ) return t ;				  
}							      }								    	t ++ ;							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE	      QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE		    QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE		  QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE
--							      --							    --								  --
static int countInRange ( int arr [ ] , int n , int x , int y int countInRange ( int arr [ ] , int n , int x , int y ) {    int countInRange ( int arr [ ] , int n , int x , int y ) {	  success : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ;	      	  if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ;	    	if ( arr [ i ] >= x && arr [ i ] <= y ) {		  
  }							      	}							    	  count ++ ;						  
  return count ;					      	return count ;						    	}							  
}							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	      ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	    ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	  ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX
--							      --							    --								  --
static int countCommon ( int mat [ ] [ ] , int n ) {	      int countCommon ( int mat [ ] [ MAX ] , int n ) {		    int countCommon ( int mat [ ] [ 2 ] , int n ) {		  script_not_found : None
  int res = 0 ;						      	int res = 0 ;						      int res = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) re 	i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) re   i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) re 
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		      MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		    MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		  MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET
--							      --							    --								  --
static double minRevolutions ( double r , int x1 , int y1 , i int minRevolutions ( double r , int x1 , int y1 , int x2 , in double minRevolutions ( double r , int x1 , int y1 , int x2 , script_not_found : None
  double d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - 	double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) *   double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * 
  return Math . ceil ( d / ( 2 * r ) ) ;		      	return ceil ( d / ( 2 * r ) ) ;				      return ceil ( d / ( 2 * r ) ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON
--							      --							    --								  --
public static boolean checkcircle ( int r , int R , int r1 ,  bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) success : None
  int dis = ( int ) Math . sqrt ( x1 * x1 + y1 * y1 ) ;	      	int dis = sqrt ( x1 * x1 + y1 * y1 ) ;			      int dis = ( int ) sqrt ( x1 * x1 + y1 * y1 ) ;		  
  return ( dis - r1 >= R && dis + r1 <= r ) ;		      	return ( dis - r1 >= R && dis + r1 <= r ) ;		      return ( dis - r1 >= R && dis + r1 <= r ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING		      QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING		    QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING			  QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING
--							      --							    --								  --
static void query ( String s , int i , int j ) {	      void query ( char s [ ] , int i , int j ) {		    void query ( string s , int i , int j ) {			  script_not_found : None
  int n = s . length ( ) ;				      	int n = strlen ( s ) ;					      int n = s . length ( ) ;					  
  i %= n ;						      	i %= n ;						      i %= n ;							  
  j %= n ;						      	j %= n ;						      j %= n ;							  
  if ( s . charAt ( i ) == s . charAt ( j ) ) System . out .  	( s [ i ] == s [ j ] ) ? ( cout << "Yes" << endl ) : ( cout   if ( s [ i ] == s [ j ] ) {				  
  else System . out . println ( "No" ) ;		      }								    	cout << "Yes" << endl ;					  
}							      								      }								  
							      								      else {							  
							      								    	cout << "No" << endl ;					  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC		      PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC			    PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC			  PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC
--							      --							    --								  --
static boolean isSymmetric ( int mat [ ] [ ] , int N ) {      bool isSymmetric ( int mat [ ] [ MAX ] , int N ) {	    bool isSymmetric ( int mat [ ] [ N ] , int N ) {		  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < N ;						      	j < N ;							      j < N ;							  
  j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return fal 	j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return fal   j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return fal 
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AREA_QUADRILATERAL				      MAXIMUM_AREA_QUADRILATERAL				    MAXIMUM_AREA_QUADRILATERAL					  MAXIMUM_AREA_QUADRILATERAL
--							      --							    --								  --
static double maxArea ( double a , double b , double c , doub double maxArea ( double a , double b , double c , double d )  double max_area ( double a , double b , double c , double d ) script_not_found : None
  double semiperimeter = ( a + b + c + d ) / 2 ;	      	double semiperimeter = ( a + b + c + d ) / 2 ;		      double semiperimeter = ( a + b + c + d ) / 2 ;		  
  return Math . sqrt ( ( semiperimeter - a ) * ( semiperimete 	return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b )   return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BREAK_NUMBER_THREE_PARTS				      BREAK_NUMBER_THREE_PARTS					    BREAK_NUMBER_THREE_PARTS					  BREAK_NUMBER_THREE_PARTS
--							      --							    --								  --
static long count_of_ways ( long n ) {			      ll count_of_ways ( ll n ) {				    long long count_of_ways ( long long n ) {			  script_not_found : None
  long count = 0 ;					      	ll count = 0 ;						      long long count = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j <= n ;						      	j <= n ;						      j <= n ;							  
  j ++ ) for ( int k = 0 ;				      	j ++ ) for ( int k = 0 ;				      j ++ ) for ( int k = 0 ;					  
  k <= n ;						      	k <= n ;						      k <= n ;							  
  k ++ ) if ( i + j + k == n ) count ++ ;		      	k ++ ) if ( i + j + k == n ) count ++ ;			      k ++ ) if ( i + j + k == n ) count ++ ;			  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_BY_7					      DIVISIBILITY_BY_7						    DIVISIBILITY_BY_7						  DIVISIBILITY_BY_7
--							      --							    --								  --
static boolean isDivisibleBy7 ( int num ) {		      int isDivisibleBy7 ( int num ) {				    bool isDivisibleBy7 ( int num ) {				  success : None
  if ( num < 0 ) return isDivisibleBy7 ( - num ) ;	      	if ( num < 0 ) return isDivisibleBy7 ( - num ) ;	      if ( num < 0 ) return isDivisibleBy7 ( - num ) ;		  
  if ( num == 0 || num == 7 ) return true ;		      	if ( num == 0 || num == 7 ) return 1 ;			      if ( num == 0 || num == 7 ) return true ;			  
  if ( num < 10 ) return false ;			      	if ( num < 10 ) return 0 ;				      if ( num < 10 ) return false ;				  
  return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 1 	return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 1   return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 1 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES			      POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES			    POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES				  POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES
--							      --							    --								  --
static boolean isPossibleTriangle ( int [ ] arr , int N ) {   bool isPossibleTriangle ( int arr [ ] , int N ) {		    bool isPossibleTriangle ( int * arr , int N ) {		  failure : #Results: 9, 10
  if ( N < 3 ) return false ;				      	if ( N < 3 ) return false ;				      if ( N < 3 ) return false ;				  
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + N ) ;				      sort ( arr , arr + N ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N - 2 ;						      	i < N - 2 ;						      i < N - 2 ;						  
  i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) ret 	i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) ret   i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) ret 
  return false ;					      }								      return false ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS_1					      SUM_PAIRWISE_PRODUCTS_1					    SUM_PAIRWISE_PRODUCTS_1					  SUM_PAIRWISE_PRODUCTS_1
--							      --							    --								  --
static int findSum ( int n ) {				      long long int findSum ( int n ) {				    int findSum ( int n ) {					  success : None
  int multiTerms = n * ( n + 1 ) / 2 ;			      	long long int multiTerms = n * ( n + 1 ) / 2 ;		      int multiTerms = n * ( n + 1 ) / 2 ;			  
  int sum = multiTerms ;				      	long long int sum = multiTerms ;			      int sum = multiTerms ;					  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    multiTerms = multiTerms - ( i - 1 ) ;		      	  multiTerms = multiTerms - ( i - 1 ) ;			    	multiTerms = multiTerms - ( i - 1 ) ;			  
    sum = sum + multiTerms * i ;			      	  sum = sum + multiTerms * i ;				    	sum = sum + multiTerms * i ;				  
  }							      	}							      }								  
  return sum ;						      	return sum ;						      return sum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX		      PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX		    PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX			  PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX
--							      --							    --								  --
static boolean isDiagonalMatrix ( int mat [ ] [ ] ) {	      bool isDiagonalMatrix ( int mat [ N ] [ N ] ) {		    bool isDiagonalMatrix ( int mat [ N ] [ N ] ) {		  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < N ;						      	j < N ;							      j < N ;							  
  j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return 	j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return   j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return 
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_XOR_VALUE_PAIR					      MINIMUM_XOR_VALUE_PAIR					    MINIMUM_XOR_VALUE_PAIR					  MINIMUM_XOR_VALUE_PAIR
--							      --							    --								  --
static int minXOR ( int arr [ ] , int n ) {		      int minXOR ( int arr [ ] , int n ) {			    int minXOR ( int arr [ ] , int n ) {			  success : identical to gold
  int min_xor = Integer . MAX_VALUE ;			      	int min_xor = INT_MAX ;					      int min_xor = INT_MAX ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) min_xor = Math . min ( min_xor , arr [ i ] ^ arr [ j 	j ++ ) min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] ) ;    j ++ ) min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] ) ;  
  return min_xor ;					      	return min_xor ;					      return min_xor ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ROTATE_MATRIX_180_DEGREE				      ROTATE_MATRIX_180_DEGREE					    ROTATE_MATRIX_180_DEGREE					  ROTATE_MATRIX_180_DEGREE
--							      --							    --								  --
static void rotateMatrix ( int mat [ ] [ ] ) {		      void rotateMatrix ( int mat [ ] [ N ] ) {			    void rotateMatrix ( int mat [ N ] [ N ] ) {			  script_not_found : None
  for ( int i = N - 1 ;					      	for ( int i = N - 1 ;					      for ( int i = N - 1 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    for ( int j = N - 1 ;				      	  for ( int j = N - 1 ;					    	for ( int j = N - 1 ;					  
    j >= 0 ;						      	  j >= 0 ;						    	j >= 0 ;						  
    j -- ) System . out . print ( mat [ i ] [ j ] + " " ) ;   	  j -- ) printf ( "%d " , mat [ i ] [ j ] ) ;		    	j -- ) {						  
    System . out . println ( ) ;			      	  printf ( "\n" ) ;					    	  cout << mat [ i ] [ j ] << " " ;			  
  }							      	}							    	}							  
}							      }								    	cout << endl ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEONARDO_NUMBER_1					      LEONARDO_NUMBER_1						    LEONARDO_NUMBER_1						  LEONARDO_NUMBER_1
--							      --							    --								  --
static int leonardo ( int n ) {				      int leonardo ( int n ) {					    int leonardo ( int n ) {					  success : None
  int dp [ ] = new int [ n + 1 ] ;			      	int dp [ n + 1 ] ;					      int dp [ n + 1 ] ;					  
  dp [ 0 ] = dp [ 1 ] = 1 ;				      	dp [ 0 ] = dp [ 1 ] = 1 ;				      dp [ 0 ] = dp [ 1 ] = 1 ;					  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ;	      	i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ;	      i ++ ) {							  
  return dp [ n ] ;					      	return dp [ n ] ;					    	dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ;		  
}							      }								      }								  
							      								      return dp [ n ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERIAN_NUMBER						      EULERIAN_NUMBER						    EULERIAN_NUMBER						  EULERIAN_NUMBER
--							      --							    --								  --
public static int eulerian ( int n , int m ) {		      int eulerian ( int n , int m ) {				    int eulerian ( int n , int m ) {				  script_not_found : None
  if ( m >= n || n == 0 ) return 0 ;			      	if ( m >= n || n == 0 ) return 0 ;			      if ( m >= n || n == 0 ) return 0 ;			  
  if ( m == 0 ) return 1 ;				      	if ( m == 0 ) return 1 ;				      if ( m == 0 ) return 1 ;					  
  return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * 	return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) *   return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			      NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			    NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			  NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES
--							      --							    --								  --
public static int findPosition ( int k , int n ) {	      int findPosition ( int k , int n ) {			    int findPosition ( int k , int n ) {			  script_not_found : None
  long f1 = 0 , f2 = 1 , f3 ;				      	unsigned long long int f1 = 0 , f2 = 1 , f3 ;		      long long f1 = 0 , f2 = 1 , f3 ;				  
  int i = 2 ;						      	for ( int i = 2 ;					      int i = 2 ;						  
  while ( i != 0 ) {					      	i <= MAX ;						      while ( i != 0 ) {					  
    f3 = f1 + f2 ;					      	i ++ ) {						    	f3 = f1 + f2 ;						  
    f1 = f2 ;						      	  f3 = f1 + f2 ;					    	f1 = f2 ;						  
    f2 = f3 ;						      	  f1 = f2 ;						    	f2 = f3 ;						  
    if ( f2 % k == 0 ) {				      	  f2 = f3 ;						    	if ( f2 % k == 0 ) return n * i ;			  
      return n * i ;					      	  if ( f2 % k == 0 ) return n * i ;			    	i ++ ;							  
    }							      	}							      }								  
    i ++ ;						      }								      return 0 ;						  
  }							      								    }								  
  return 0 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHUFFLE_A_DECK_OF_CARDS_3				      SHUFFLE_A_DECK_OF_CARDS_3					    SHUFFLE_A_DECK_OF_CARDS_3					  SHUFFLE_A_DECK_OF_CARDS_3
--							      --							    --								  --
public static void shuffle ( int card [ ] , int n ) {	      void shuffle ( int card [ ] , int n ) {			    int shuffle ( int card [ ] , int n ) {			  script_not_found : None
  Random rand = new Random ( ) ;			      	srand ( time ( 0 ) ) ;					      int i ;							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int r = i + rand . nextInt ( 52 - i ) ;		      	  int r = i + ( rand ( ) % ( 52 - i ) ) ;		    	int r = i + rand ( ) % ( 52 - i ) ;			  
    int temp = card [ r ] ;				      	  swap ( card [ i ] , card [ r ] ) ;			    	int temp = card [ r ] ;					  
    card [ r ] = card [ i ] ;				      	}							    	card [ r ] = card [ i ] ;				  
    card [ i ] = temp ;					      }								    	card [ i ] = temp ;					  
  }							      								      }								  
}							      								      return i ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA
--							      --							    --								  --
static int russianPeasant ( int a , int b ) {		      unsigned int russianPeasant ( unsigned int a , unsigned int b int russianPeasant ( int a , int b ) {			  success : None
  int res = 0 ;						      	int res = 0 ;						      int res = 0 ;						  
  while ( b > 0 ) {					      	while ( b > 0 ) {					      while ( b > 0 ) {						  
    if ( ( b & 1 ) != 0 ) res = res + a ;		      	  if ( b & 1 ) res = res + a ;				    	if ( ( b & 1 ) != 0 ) {					  
    a = a << 1 ;					      	  a = a << 1 ;						    	  res = res + a ;					  
    b = b >> 1 ;					      	  b = b >> 1 ;						    	}							  
  }							      	}							    	a = a << 1 ;						  
  return res ;						      	return res ;						    	b = b >> 1 ;						  
}							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MARKOV_MATRIX						      MARKOV_MATRIX						    MARKOV_MATRIX						  MARKOV_MATRIX
--							      --							    --								  --
static boolean checkMarkov ( double m [ ] [ ] ) {	      bool checkMarkov ( double m [ ] [ n ] ) {			    bool checkMarkov ( double m [ ] [ 3 ] ) {			  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m . length ;					      	i < n ;							      i < sizeof ( m ) / sizeof ( m [ 0 ] ) ;			  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    double sum = 0 ;					      	  double sum = 0 ;					    	double sum = 0 ;					  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < m [ i ] . length ;				      	  j < n ;						    	j < sizeof ( m [ i ] ) / sizeof ( m [ i ] [ j ] ) ;	  
    j ++ ) sum = sum + m [ i ] [ j ] ;			      	  j ++ ) sum = sum + m [ i ] [ j ] ;			    	j ++ ) {						  
    if ( sum != 1 ) return false ;			      	  if ( sum != 1 ) return false ;			    	  sum = sum + m [ i ] [ j ] ;				  
  }							      	}							    	}							  
  return true ;						      	return true ;						    	if ( sum != 1 ) return false ;				  
}							      }								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO		      MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO		    MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO			  MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO
--							      --							    --								  --
static long moduloMultiplication ( long a , long b , long mod long long moduloMultiplication ( long long a , long long b ,  long long moduloMultiplication ( long long a , long long b ,  success : None
  long res = 0 ;					      	long long res = 0 ;					      long long res = 0 ;					  
  a %= mod ;						      	a %= mod ;						      a %= mod ;						  
  while ( b > 0 ) {					      	while ( b ) {						      while ( b > 0 ) {						  
    if ( ( b & 1 ) > 0 ) {				      	  if ( b & 1 ) res = ( res + a ) % mod ;		    	if ( ( b & 1 ) > 0 ) res = ( res + a ) % mod ;		  
      res = ( res + a ) % mod ;				      	  a = ( 2 * a ) % mod ;					    	a = ( 2 * a ) % mod ;					  
    }							      	  b >>= 1 ;						    	b >>= 1 ;						  
    a = ( 2 * a ) % mod ;				      	}							      }								  
    b >>= 1 ;						      	return res ;						      return res ;						  
  }							      }								    }								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS		      MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS			    MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS			  MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS
--							      --							    --								  --
public static int middleOfThree ( int a , int b , int c ) {   int middleOfThree ( int a , int b , int c ) {		    int middleOfThree ( int a , int b , int c ) {		  success : identical to gold
  if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ;  	if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ;    if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ;  
  else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return 	else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return   else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return 
  else return c ;					      	else return c ;						      else return c ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			      PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			    PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			  PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2
--							      --							    --								  --
static void transpose ( int A [ ] [ ] ) {		      void transpose ( int A [ ] [ N ] ) {			    void transpose ( int A [ N ] [ N ] ) {			  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < N ;						      	j < N ;							      j < N ;							  
  j ++ ) {						      	j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ;		      j ++ ) {							  
    int temp = A [ i ] [ j ] ;				      }								    	int temp = A [ i ] [ j ] ;				  
    A [ i ] [ j ] = A [ j ] [ i ] ;			      								    	A [ i ] [ j ] = A [ j ] [ i ] ;				  
    A [ j ] [ i ] = temp ;				      								    	A [ j ] [ i ] = temp ;					  
  }							      								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1
--							      --							    --								  --
static void reverseStr ( String str ) {			      void reverseStr ( string & str ) {			    void reverseStr ( string str ) {				  script_not_found : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  char [ ] ch = str . toCharArray ( ) ;			      	for ( int i = 0 , j = n - 1 ;				      string ch = str ;						  
  char temp ;						      	i < j ;							      char temp ;						  
  for ( int i = 0 , j = n - 1 ;				      	i ++ , j -- ) swap ( str [ i ] , str [ j ] ) ;		      for ( int i = 0 , j = n - 1 ;				  
  i < j ;						      }								      i < j ;							  
  i ++ , j -- ) {					      								      i ++ , j -- ) {						  
    temp = ch [ i ] ;					      								    	temp = ch [ i ] ;					  
    ch [ i ] = ch [ j ] ;				      								    	ch [ i ] = ch [ j ] ;					  
    ch [ j ] = temp ;					      								    	ch [ j ] = temp ;					  
  }							      								      }								  
  System . out . println ( ch ) ;			      								      cout << ch << endl ;					  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B			      COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B				    COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B				  COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B
--							      --							    --								  --
static int CountPairs ( int n ) {			      int CountPairs ( int n ) {				    int CountPairs ( int n ) {					  success : identical to gold
  int k = n ;						      	int k = n ;						      int k = n ;						  
  int imin = 1 ;					      	int imin = 1 ;						      int imin = 1 ;						  
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  while ( imin <= n ) {					      	while ( imin <= n ) {					      while ( imin <= n ) {					  
    int imax = n / k ;					      	  int imax = n / k ;					    	int imax = n / k ;					  
    ans += k * ( imax - imin + 1 ) ;			      	  ans += k * ( imax - imin + 1 ) ;			    	ans += k * ( imax - imin + 1 ) ;			  
    imin = imax + 1 ;					      	  imin = imax + 1 ;					    	imin = imax + 1 ;					  
    k = n / imin ;					      	  k = n / imin ;					    	k = n / imin ;						  
  }							      	}							      }								  
  return ans ;						      	return ans ;						      return ans ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_DIGIT_RAISED_POWER_B				      K_TH_DIGIT_RAISED_POWER_B					    K_TH_DIGIT_RAISED_POWER_B					  K_TH_DIGIT_RAISED_POWER_B
--							      --							    --								  --
public static int kthdigit ( int a , int b , int k ) {	      int kthdigit ( int a , int b , int k ) {			    int kthdigit ( int a , int b , int k ) {			  success : None
  int p = ( int ) Math . pow ( a , b ) ;		      	int p = pow ( a , b ) ;					      int p = ( int ) pow ( a , b ) ;				  
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  while ( p > 0 && count < k ) {			      	while ( p > 0 && count < k ) {				      while ( p > 0 && count < k ) {				  
    int rem = p % 10 ;					      	  int rem = p % 10 ;					    	int rem = p % 10 ;					  
    count ++ ;						      	  count ++ ;						    	count ++ ;						  
    if ( count == k ) return rem ;			      	  if ( count == k ) return rem ;			    	if ( count == k ) return rem ;				  
    p = p / 10 ;					      	  p = p / 10 ;						    	p = p / 10 ;						  
  }							      	}							      }								  
  return 0 ;						      	return 0 ;						      return 0 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_
--							      --							    --								  --
static int multiply ( int x , int y ) {			      public : int multiply ( int x , int y ) {			    int multiply ( int x , int y ) {				  script_not_found : None
  if ( y == 0 ) return 0 ;				      	if ( y == 0 ) return 0 ;				      if ( y == 0 ) return 0 ;					  
  if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ;	      	if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ;	      if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ;	  
  if ( y < 0 ) return - multiply ( x , - y ) ;		      	if ( y < 0 ) return - multiply ( x , - y ) ;		      if ( y < 0 ) return - multiply ( x , - y ) ;		  
  return - 1 ;						      }								      return - 1 ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION			      PROGRAM_DECIMAL_BINARY_CONVERSION				    PROGRAM_DECIMAL_BINARY_CONVERSION				  PROGRAM_DECIMAL_BINARY_CONVERSION
--							      --							    --								  --
static void decToBinary ( int n ) {			      void decToBinary ( int n ) {				    void decToBinary ( int n ) {				  script_not_found : None
  int [ ] binaryNum = new int [ 32 ] ;			      	int binaryNum [ 32 ] ;					      int binaryNum [ 32 ] ;					  
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  while ( n > 0 ) {					      	while ( n > 0 ) {					      while ( n > 0 ) {						  
    binaryNum [ i ] = n % 2 ;				      	  binaryNum [ i ] = n % 2 ;				    	binaryNum [ i ] = n % 2 ;				  
    n = n / 2 ;						      	  n = n / 2 ;						    	n = n / 2 ;						  
    i ++ ;						      	  i ++ ;						    	i ++ ;							  
  }							      	}							      }								  
  for ( int j = i - 1 ;					      	for ( int j = i - 1 ;					      for ( int j = i - 1 ;					  
  j >= 0 ;						      	j >= 0 ;						      j >= 0 ;							  
  j -- ) System . out . print ( binaryNum [ j ] ) ;	      	j -- ) cout << binaryNum [ j ] ;			      j -- ) {							  
}							      }								    	cout << binaryNum [ j ] << endl ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER   MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER   MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER	  MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER
--							      --							    --								  --
static int maxPrefix ( String s , String t ) {		      int maxPrefix ( char s [ ] , char t [ ] ) {		    int maxPrefix ( string s , string t ) {			  success : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < t . length ( ) ;					      	i < strlen ( t ) ;					      i < t . length ( ) ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( count == t . length ( ) ) break ;		      	  if ( count == strlen ( s ) ) break ;			    	if ( count == t . length ( ) ) break ;			  
    if ( t . charAt ( i ) == s . charAt ( count ) ) count ++  	  if ( t [ i ] == s [ count ] ) count ++ ;		    	if ( t [ i ] == s [ count ] ) count ++ ;		  
  }							      	}							      }								  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN
--							      --							    --								  --
static int search ( int arr [ ] , int n , int x ) {	      int search ( int arr [ ] , int n , int x ) {		    int search ( int arr [ ] , int n , int x ) {		  success : identical to gold
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  while ( i <= n - 1 ) {				      	while ( i <= n - 1 ) {					      while ( i <= n - 1 ) {					  
    if ( arr [ i ] == x ) return i ;			      	  if ( arr [ i ] == x ) return i ;			    	if ( arr [ i ] == x ) return i ;			  
    i += Math . abs ( arr [ i ] - x ) ;			      	  i += abs ( arr [ i ] - x ) ;				    	i += abs ( arr [ i ] - x ) ;				  
  }							      	}							      }								  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LOWER_CASE_UPPER_CASE_INTERESTING_FACT			      LOWER_CASE_UPPER_CASE_INTERESTING_FACT			    LOWER_CASE_UPPER_CASE_INTERESTING_FACT			  LOWER_CASE_UPPER_CASE_INTERESTING_FACT
--							      --							    --								  --
static String to_upper ( char [ ] in ) {		      string to_upper ( string & in ) {				    string to_upper ( string in ) {				  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < in . length ;					      	i < in . length ( ) ;					      i < in . length ( ) ;					  
  i ++ ) {						      	i ++ ) if ( 'a' <= in [ i ] <= 'z' ) in [ i ] = in [ i ] -    i ++ ) {							  
    if ( 'a' <= in [ i ] & in [ i ] <= 'z' ) {		      	return in ;						    	if ( 'a' <= in [ i ] && in [ i ] <= 'z' ) in [ i ] = ( ch 
      in [ i ] = ( char ) ( in [ i ] - 'a' + 'A' ) ;	      }								      }								  
    }							      								      return string ( in . begin ( ) , in . end ( ) ) ;		  
  }							      								    }								  
  return String . valueOf ( in ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_STRING_START_END_GEEKS			      PROGRAM_FIND_STRING_START_END_GEEKS			    PROGRAM_FIND_STRING_START_END_GEEKS				  PROGRAM_FIND_STRING_START_END_GEEKS
--							      --							    --								  --
static boolean isCornerPresent ( String str , String corner ) bool isCornerPresent ( string str , string corner ) {	    bool isCornerPresent ( string str , string corner ) {	  success : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      size_t n = str . length ( ) ;				  
  int cl = corner . length ( ) ;			      	int cl = corner . length ( ) ;				      size_t cl = corner . length ( ) ;				  
  if ( n < cl ) return false ;				      	if ( n < cl ) return false ;				      if ( n < cl ) return false ;				  
  return ( str . substring ( 0 , cl ) . equals ( corner ) &&  	return ( str . substr ( 0 , cl ) . compare ( corner ) == 0    return ( str . substr ( 0 , cl ) == corner && str . substr  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				      CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				    CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				  CONSTRUCT_ARRAY_PAIR_SUM_ARRAY
--							      --							    --								  --
static void constructArr ( int arr [ ] , int pair [ ] , int n void constructArr ( int arr [ ] , int pair [ ] , int n ) {    void constructArr ( int arr [ ] , int pair [ ] , int n ) {	  script_not_found : None
  arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) /  	arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) /    arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) /  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ;	      	i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ;		      i ++ ) {							  
}							      }								    	arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ;		  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS		      PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS		    PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS			  PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS
--							      --							    --								  --
static void printFibonacciNumbers ( int n ) {		      void printFibonacciNumbers ( int n ) {			    void print_fibonacci_numbers ( int n ) {			  script_not_found : None
  int f1 = 0 , f2 = 1 , i ;				      	int f1 = 0 , f2 = 1 , i ;				      int f1 = 0 , f2 = 1 , i ;					  
  if ( n < 1 ) return ;					      	if ( n < 1 ) return ;					      if ( n < 1 ) return ;					  
  for ( i = 1 ;						      	for ( i = 1 ;						      for ( i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    System . out . print ( f2 + " " ) ;			      	  cout << f2 << " " ;					    	cout << f2 << " " ;					  
    int next = f1 + f2 ;				      	  int next = f1 + f2 ;					    	int next = f1 + f2 ;					  
    f1 = f2 ;						      	  f1 = f2 ;						    	f1 = f2 ;						  
    f2 = next ;						      	  f2 = next ;						    	f2 = next ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL		      MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL			    MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL			  MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL
--							      --							    --								  --
static void moveSpaceInFront ( char str [ ] ) {		      void moveSpaceInFront ( char str [ ] ) {			    void moveSpaceInFront ( char str [ ] ) {			  script_not_found : None
  int i = str . length - 1 ;				      	int i = strlen ( str ) ;				      int i = strlen ( str ) - 1 ;				  
  for ( int j = i ;					      	for ( int j = i ;					      for ( int j = i ;						  
  j >= 0 ;						      	j >= 0 ;						      j >= 0 ;							  
  j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ] ;   	j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ] ;     j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ] ;	  
  while ( i >= 0 ) str [ i -- ] = ' ' ;			      	while ( i >= 0 ) str [ i -- ] = ' ' ;			      while ( i >= 0 ) str [ i -- ] = ' ' ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	      MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	    MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	  MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1
--							      --							    --								  --
static int minimumflip ( int mat [ ] [ ] , int n ) {	      int minimumflip ( int mat [ ] [ N ] , int n ) {		    int minimumflip ( int mat [ ] [ 2 ] , int n ) {		  script_not_found : None
  int flip = 0 ;					      	int flip = 0 ;						      int flip = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < i ;						      	j < i ;							      j < i ;							  
  j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ;  	j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ;    j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ;  
  return flip ;						      	return flip ;						      return flip ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1
--							      --							    --								  --
static int isPowerOfFour ( int n ) {			      bool isPowerOfFour ( unsigned int n ) {			    int isPowerOfFour ( int n ) {				  success : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  int x = n & ( n - 1 ) ;				      	if ( n && ! ( n & ( n - 1 ) ) ) {			      int x = n & ( n - 1 ) ;					  
  if ( n > 0 && x == 0 ) {				      	  while ( n > 1 ) {					      if ( n > 0 && x == 0 ) {					  
    while ( n > 1 ) {					      	    n >>= 1 ;						    	while ( n > 1 ) {					  
      n >>= 1 ;						      	    count += 1 ;					    	  n >>= 1 ;						  
      count += 1 ;					      	  }							    	  count += 1 ;						  
    }							      	  return ( count % 2 == 0 ) ? 1 : 0 ;			    	}							  
    return ( count % 2 == 0 ) ? 1 : 0 ;			      	}							    	return ( count % 2 == 0 ) ? 1 : 0 ;			  
  }							      	return 0 ;						      }								  
  return 0 ;						      }								      return 0 ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FRIENDS_PAIRING_PROBLEM_2				      FRIENDS_PAIRING_PROBLEM_2					    FRIENDS_PAIRING_PROBLEM_2					  FRIENDS_PAIRING_PROBLEM_2
--							      --							    --								  --
static int countFriendsPairings ( int n ) {		      int countFriendsPairings ( int n ) {			    int countFriendsPairings ( int n ) {			  success : None
  int a = 1 , b = 2 , c = 0 ;				      	int a = 1 , b = 2 , c = 0 ;				      int a = 1 , b = 2 , c = 0 ;				  
  if ( n <= 2 ) {					      	if ( n <= 2 ) {						      if ( n <= 2 ) return n ;					  
    return n ;						      	  return n ;						      for ( int i = 3 ;						  
  }							      	}							      i <= n ;							  
  for ( int i = 3 ;					      	for ( int i = 3 ;					      i ++ ) {							  
  i <= n ;						      	i <= n ;						    	c = b + ( i - 1 ) * a ;					  
  i ++ ) {						      	i ++ ) {						    	a = b ;							  
    c = b + ( i - 1 ) * a ;				      	  c = b + ( i - 1 ) * a ;				    	b = c ;							  
    a = b ;						      	  a = b ;						      }								  
    b = c ;						      	  b = c ;						      return c ;						  
  }							      	}							    }								  
  return c ;						      	return c ;						    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_BINARY_DECIMAL_CONVERSION_1			      PROGRAM_BINARY_DECIMAL_CONVERSION_1			    PROGRAM_BINARY_DECIMAL_CONVERSION_1				  PROGRAM_BINARY_DECIMAL_CONVERSION_1
--							      --							    --								  --
static int binaryToDecimal ( String n ) {		      int binaryToDecimal ( string n ) {			    int binary_to_decimal ( string n ) {			  success : None
  String num = n ;					      	string num = n ;					      string num = n ;						  
  int dec_value = 0 ;					      	int dec_value = 0 ;					      int dec_value = 0 ;					  
  int base = 1 ;					      	int base = 1 ;						      int base = 1 ;						  
  int len = num . length ( ) ;				      	int len = num . length ( ) ;				      int len = num . length ( ) ;				  
  for ( int i = len - 1 ;				      	for ( int i = len - 1 ;					      for ( int i = len - 1 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    if ( num . charAt ( i ) == '1' ) dec_value += base ;      	  if ( num [ i ] == '1' ) dec_value += base ;		    	if ( num [ i ] == '1' ) dec_value += base ;		  
    base = base * 2 ;					      	  base = base * 2 ;					    	base = base * 2 ;					  
  }							      	}							      }								  
  return dec_value ;					      	return dec_value ;					      return dec_value ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	      MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	    MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	  MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY
--							      --							    --								  --
static int minimum_cost ( int a [ ] , int n ) {		      int minimum_cost ( int a [ ] , int n ) {			    int minimumCost ( int a [ ] , int n ) {			  success : None
  int mn = Integer . MAX_VALUE ;			      	int mn = INT_MAX ;					      int mn = INT_MAX ;					  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    mn = Math . min ( a [ i ] , mn ) ;			      	  mn = min ( a [ i ] , mn ) ;				    	mn = min ( a [ i ] , mn ) ;				  
    sum += a [ i ] ;					      	  sum += a [ i ] ;					    	sum += a [ i ] ;					  
  }							      	}							      }								  
  return mn * ( sum - mn ) ;				      	return mn * ( sum - mn ) ;				      return mn * ( sum - mn ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_FACTORS_NUMBER					      SUM_FACTORS_NUMBER					    SUM_FACTORS_NUMBER						  SUM_FACTORS_NUMBER
--							      --							    --								  --
static int divSum ( int n ) {				      int divSum ( int n ) {					    int divSum ( int n ) {					  success : None
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= Math . sqrt ( n ) ;				      	i <= sqrt ( n ) ;					      i <= sqrt ( n ) ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( n % i == 0 ) {					      	  if ( n % i == 0 ) {					    	if ( n % i == 0 ) {					  
      if ( i == ( n / i ) ) result += i ;		      	    if ( i == ( n / i ) ) result += i ;			    	  if ( i == ( n / i ) ) {				  
      else result += ( i + n / i ) ;			      	    else result += ( i + n / i ) ;			    	    result += i ;					  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  return ( result + n + 1 ) ;				      	return ( result + n + 1 ) ;				    	    result += ( i + n / i ) ;				  
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return ( result + n + 1 ) ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	      RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	    RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	  RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY
--							      --							    --								  --
static int recSearch ( int arr [ ] , int l , int r , int x )  int recSearch ( int arr [ ] , int l , int r , int x ) {	    int recSearch ( int arr [ ] , int l , int r , int x ) {	  success : identical to gold
  if ( r < l ) return - 1 ;				      	if ( r < l ) return - 1 ;				      if ( r < l ) return - 1 ;					  
  if ( arr [ l ] == x ) return l ;			      	if ( arr [ l ] == x ) return l ;			      if ( arr [ l ] == x ) return l ;				  
  if ( arr [ r ] == x ) return r ;			      	if ( arr [ r ] == x ) return r ;			      if ( arr [ r ] == x ) return r ;				  
  return recSearch ( arr , l + 1 , r - 1 , x ) ;	      	return recSearch ( arr , l + 1 , r - 1 , x ) ;		      return recSearch ( arr , l + 1 , r - 1 , x ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		      HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		    HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		  HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION
--							      --							    --								  --
static long mulmod ( long a , long b , long mod ) {	      ll mulmod ( ll a , ll b , ll mod ) {			    long long mulmod ( long long a , long long b , long long mod  script_not_found : None
  long res = 0 ;					      	ll res = 0 ;						      long long res = 0 ;					  
  a = a % mod ;						      	a = a % mod ;						      a = a % mod ;						  
  while ( b > 0 ) {					      	while ( b > 0 ) {					      while ( b > 0 ) {						  
    if ( b % 2 == 1 ) {					      	  if ( b % 2 == 1 ) res = ( res + a ) % mod ;		    	if ( b % 2 == 1 ) res = ( res + a ) % mod ;		  
      res = ( res + a ) % mod ;				      	  a = ( a * 2 ) % mod ;					    	a = ( a * 2 ) % mod ;					  
    }							      	  b /= 2 ;						    	b /= 2 ;						  
    a = ( a * 2 ) % mod ;				      	}							      }								  
    b /= 2 ;						      	return res % mod ;					      return res % mod ;					  
  }							      }								    }								  
  return res % mod ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPETITIVE_ELEMENT_1_N_1_1				      FIND_REPETITIVE_ELEMENT_1_N_1_1				    FIND_REPETITIVE_ELEMENT_1_N_1_1				  FIND_REPETITIVE_ELEMENT_1_N_1_1
--							      --							    --								  --
static int findRepeating ( int arr [ ] , int n ) {	      int findRepeating ( int arr [ ] , int n ) {		    int findRepeating ( int arr [ ] , int n ) {			  success : None
  HashSet < Integer > s = new HashSet < Integer > ( ) ;	      	unordered_set < int > s ;				      set < int > s ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( s . contains ( arr [ i ] ) ) return arr [ i ] ;      	  if ( s . find ( arr [ i ] ) != s . end ( ) ) return arr [ 	if ( s . find ( arr [ i ] ) != s . end ( ) ) return arr [ 
    s . add ( arr [ i ] ) ;				      	  s . insert ( arr [ i ] ) ;				    	s . insert ( arr [ i ] ) ;				  
  }							      	}							      }								  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN
--							      --							    --								  --
static int findMaximum ( int arr [ ] , int low , int high ) { int findMaximum ( int arr [ ] , int low , int high ) {	    int findMaximum ( int arr [ ] , int low , int high ) {	  failure : #Results: 8, 10
  int max = arr [ low ] ;				      	int max = arr [ low ] ;					      int max = arr [ low ] ;					  
  int i ;						      	int i ;							      int i ;							  
  for ( i = low ;					      	for ( i = low + 1 ;					      for ( i = low ;						  
  i <= high ;						      	i <= high ;						      i <= high ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] > max ) max = arr [ i ] ;		      	  if ( arr [ i ] > max ) max = arr [ i ] ;		    	if ( arr [ i ] > max ) {				  
  }							      	  else break ;						    	  max = arr [ i ] ;					  
  return max ;						      	}							    	}							  
}							      	return max ;						      }								  
							      }								      return max ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1		      MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1		    MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1			  MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1
--							      --							    --								  --
public static int middleOfThree ( int a , int b , int c ) {   int middleOfThree ( int a , int b , int c ) {		    int middleOfThree ( int a , int b , int c ) {		  success : identical to gold
  if ( a > b ) {					      	if ( a > b ) {						      if ( a > b ) {						  
    if ( b > c ) return b ;				      	  if ( b > c ) return b ;				    	if ( b > c ) return b ;					  
    else if ( a > c ) return c ;			      	  else if ( a > c ) return c ;				    	else if ( a > c ) return c ;				  
    else return a ;					      	  else return a ;					    	else return a ;						  
  }							      	}							      }								  
  else {						      	else {							      else {							  
    if ( a > c ) return a ;				      	  if ( a > c ) return a ;				    	if ( a > c ) return a ;					  
    else if ( b > c ) return c ;			      	  else if ( b > c ) return c ;				    	else if ( b > c ) return c ;				  
    else return b ;					      	  else return b ;					    	else return b ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS
--							      --							    --								  --
static int numofsubset ( int arr [ ] , int n ) {	      int numofsubset ( int arr [ ] , int n ) {			    int numofsubset ( int arr [ ] , int n ) {			  success : None
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  int count = 1 ;					      	int count = 1 ;						      int count = 1 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ;	      	  if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ;	    	if ( arr [ i ] + 1 != arr [ i + 1 ] ) {			  
  }							      	}							    	  count ++ ;						  
  return count ;					      	return count ;						    	}							  
}							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHUFFLE_A_GIVEN_ARRAY					      SHUFFLE_A_GIVEN_ARRAY					    SHUFFLE_A_GIVEN_ARRAY					  SHUFFLE_A_GIVEN_ARRAY
--							      --							    --								  --
static void randomize ( int arr [ ] , int n ) {		      void randomize ( int arr [ ] , int n ) {			    void randomize ( int arr [ ] , int n ) {			  script_not_found : None
  Random r = new Random ( ) ;				      	srand ( time ( NULL ) ) ;				      srand ( time ( NULL ) ) ;					  
  for ( int i = n - 1 ;					      	for ( int i = n - 1 ;					      for ( int i = n - 1 ;					  
  i > 0 ;						      	i > 0 ;							      i > 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    int j = r . nextInt ( i + 1 ) ;			      	  int j = rand ( ) % ( i + 1 ) ;			    	int j = rand ( ) % ( i + 1 ) ;				  
    int temp = arr [ i ] ;				      	  swap ( & arr [ i ] , & arr [ j ] ) ;			    	int temp = arr [ i ] ;					  
    arr [ i ] = arr [ j ] ;				      	}							    	arr [ i ] = arr [ j ] ;					  
    arr [ j ] = temp ;					      }								    	arr [ j ] = temp ;					  
  }							      								      }								  
  System . out . println ( Arrays . toString ( arr ) ) ;      								      cout << endl ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPLIT_ARRAY_ADD_FIRST_PART_END				      SPLIT_ARRAY_ADD_FIRST_PART_END				    SPLIT_ARRAY_ADD_FIRST_PART_END				  SPLIT_ARRAY_ADD_FIRST_PART_END
--							      --							    --								  --
public static void splitArr ( int arr [ ] , int n , int k ) { void splitArr ( int arr [ ] , int n , int k ) {		    void splitArr ( int arr [ ] , int n , int k ) {		  success : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < k ;						      	i < k ;							      i < k ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int x = arr [ 0 ] ;					      	  int x = arr [ 0 ] ;					    	int x = arr [ 0 ] ;					  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n - 1 ;						      	  j < n - 1 ;						    	j < n - 1 ;						  
    ++ j ) arr [ j ] = arr [ j + 1 ] ;			      	  ++ j ) arr [ j ] = arr [ j + 1 ] ;			    	++ j ) {						  
    arr [ n - 1 ] = x ;					      	  arr [ n - 1 ] = x ;					    	  arr [ j ] = arr [ j + 1 ] ;				  
  }							      	}							    	}							  
}							      }								    	arr [ n - 1 ] = x ;					  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NON_REPEATING_ELEMENT					      NON_REPEATING_ELEMENT					    NON_REPEATING_ELEMENT					  NON_REPEATING_ELEMENT
--							      --							    --								  --
static int firstNonRepeating ( int arr [ ] , int n ) {	      int firstNonRepeating ( int arr [ ] , int n ) {		    int firstNonRepeating ( int arr [ ] , int n ) {		  success : identical to gold
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int j ;						      	  int j ;						    	int j ;							  
    for ( j = 0 ;					      	  for ( j = 0 ;						    	for ( j = 0 ;						  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ;    	  j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ;    	j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ;	  
    if ( j == n ) return arr [ i ] ;			      	  if ( j == n ) return arr [ i ] ;			    	if ( j == n ) return arr [ i ] ;			  
  }							      	}							      }								  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC	      MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC	    MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC		  MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC
--							      --							    --								  --
static int power ( int x , int y , int p ) {		      int power ( int x , unsigned int y , int p ) {		    int power ( int x , int y , int p ) {			  success : None
  int res = 1 ;						      	int res = 1 ;						      int res = 1 ;						  
  x = x % p ;						      	x = x % p ;						      x = x % p ;						  
  while ( y > 0 ) {					      	while ( y > 0 ) {					      while ( y > 0 ) {						  
    if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ;	      	  if ( y & 1 ) res = ( res * x ) % p ;			    	if ( ( y & 1 ) == 1 ) {					  
    y = y >> 1 ;					      	  y = y >> 1 ;						    	  res = ( res * x ) % p ;				  
    x = ( x * x ) % p ;					      	  x = ( x * x ) % p ;					    	}							  
  }							      	}							    	y = y >> 1 ;						  
  return res ;						      	return res ;						    	x = ( x * x ) % p ;					  
}							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_DIFFERENCE_PAIR_1				      FIND_MINIMUM_DIFFERENCE_PAIR_1				    FIND_MINIMUM_DIFFERENCE_PAIR_1				  FIND_MINIMUM_DIFFERENCE_PAIR_1
--							      --							    --								  --
static int findMinDiff ( int [ ] arr , int n ) {	      int findMinDiff ( int arr [ ] , int n ) {			    int findMinDiff ( int * arr , int n ) {			  success : None
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  int diff = Integer . MAX_VALUE ;			      	int diff = INT_MAX ;					      int diff = INT_MAX ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ 	i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [   i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ 
  return diff ;						      	return diff ;						      return diff ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FRIENDS_PAIRING_PROBLEM_1				      FRIENDS_PAIRING_PROBLEM_1					    FRIENDS_PAIRING_PROBLEM_1					  FRIENDS_PAIRING_PROBLEM_1
--							      --							    --								  --
static int countFriendsPairings ( int n ) {		      int countFriendsPairings ( int n ) {			    int countFriendsPairings ( int n ) {			  script_not_found : None
  if ( dp [ n ] != - 1 ) return dp [ n ] ;		      	if ( dp [ n ] != - 1 ) return dp [ n ] ;		      if ( dp [ n ] != - 1 ) return dp [ n ] ;			  
  if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 	if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1   if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 
  else return dp [ n ] = n ;				      	else return dp [ n ] = n ;				      else return dp [ n ] = n ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION
--							      --							    --								  --
public static int nearestSmallerEqFib ( int n ) {	      int nearestSmallerEqFib ( int n ) {			    int nearestSmallerEqFib ( int n ) {				  success : identical to gold
  if ( n == 0 || n == 1 ) return n ;			      	if ( n == 0 || n == 1 ) return n ;			      if ( n == 0 || n == 1 ) return n ;			  
  int f1 = 0 , f2 = 1 , f3 = 1 ;			      	int f1 = 0 , f2 = 1 , f3 = 1 ;				      int f1 = 0 , f2 = 1 , f3 = 1 ;				  
  while ( f3 <= n ) {					      	while ( f3 <= n ) {					      while ( f3 <= n ) {					  
    f1 = f2 ;						      	  f1 = f2 ;						    	f1 = f2 ;						  
    f2 = f3 ;						      	  f2 = f3 ;						    	f2 = f3 ;						  
    f3 = f1 + f2 ;					      	  f3 = f1 + f2 ;					    	f3 = f1 + f2 ;						  
  }							      	}							      }								  
  return f2 ;						      	return f2 ;						      return f2 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1		      PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1		    PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1		  PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1
--							      --							    --								  --
static void printDistinct ( int arr [ ] , int n ) {	      void printDistinct ( int arr [ ] , int n ) {		    void print_distinct ( int arr [ ] , int n ) {		  script_not_found : None
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ;  	  while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ;  	while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) {	  
    System . out . print ( arr [ i ] + " " ) ;		      	  cout << arr [ i ] << " " ;				    	  i ++ ;						  
  }							      	}							    	}							  
}							      }								    	cout << arr [ i ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			      HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			    HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			  HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN
--							      --							    --								  --
static int findHeight ( int [ ] parent , int n ) {	      int findHeight ( int * parent , int n ) {			    int findHeight ( int * parent , int n ) {			  script_not_found : None
  int res = 0 ;						      	int res = 0 ;						      int res = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int p = i , current = 1 ;				      	  int p = i , current = 1 ;				    	int p = i , current = 1 ;				  
    while ( parent [ p ] != - 1 ) {			      	  while ( parent [ p ] != - 1 ) {			    	while ( parent [ p ] != - 1 ) {				  
      current ++ ;					      	    current ++ ;					    	  current ++ ;						  
      p = parent [ p ] ;				      	    p = parent [ p ] ;					    	  p = parent [ p ] ;					  
    }							      	  }							    	}							  
    res = Math . max ( res , current ) ;		      	  res = max ( res , current ) ;				    	res = max ( res , current ) ;				  
  }							      	}							      }								  
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_GAMES_PLAYED_WINNER				      MAXIMUM_GAMES_PLAYED_WINNER				    MAXIMUM_GAMES_PLAYED_WINNER					  MAXIMUM_GAMES_PLAYED_WINNER
--							      --							    --								  --
static int maxGameByWinner ( int N ) {			      int maxGameByWinner ( int N ) {				    int maxGameByWinner ( int N ) {				  success : identical to gold
  int [ ] dp = new int [ N ] ;				      	int dp [ N ] ;						      int dp [ N ] ;						  
  dp [ 0 ] = 1 ;					      	dp [ 0 ] = 1 ;						      dp [ 0 ] = 1 ;						  
  dp [ 1 ] = 2 ;					      	dp [ 1 ] = 2 ;						      dp [ 1 ] = 2 ;						  
  int i = 2 ;						      	int i = 2 ;						      int i = 2 ;						  
  do {							      	do {							      do {							  
    dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ;		      	  dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ;		    	dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ;		  
  }							      	}							      }								  
  while ( dp [ i ++ ] <= N ) ;				      	while ( dp [ i ++ ] <= N ) ;				      while ( dp [ i ++ ] <= N ) ;				  
  return ( i - 2 ) ;					      	return ( i - 2 ) ;					      return ( i - 2 ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	      COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	    COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	  COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS
--							      --							    --								  --
static int countSubstringWithEqualEnds ( String s ) {	      int countSubstringWithEqualEnds ( string s ) {		    int countSubstringWithEqualEnds ( string s ) {		  success : identical to gold
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  int n = s . length ( ) ;				      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = i ;				      	i ++ ) for ( int j = i ;				      i ++ ) for ( int j = i ;					  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result + 	j ++ ) if ( s [ i ] == s [ j ] ) result ++ ;		      j ++ ) if ( s [ i ] == s [ j ] ) result ++ ;		  
  return result ;					      	return result ;						      return result ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MIRROR_IMAGE_POINT_2_D_PLANE			      FIND_MIRROR_IMAGE_POINT_2_D_PLANE				    FIND_MIRROR_IMAGE_POINT_2_D_PLANE				  FIND_MIRROR_IMAGE_POINT_2_D_PLANE
--							      --							    --								  --
static pair mirrorImage ( double a , double b , double c , do pair < double , double > mirrorImage ( double a , double b ,  pair mirror_image ( double a , double b , double c , double x script_not_found : None
  double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * 	double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b *   double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * 
  double x = temp * a + x1 ;				      	double x = temp * a + x1 ;				      double x = temp * a + x1 ;				  
  double y = temp * b + y1 ;				      	double y = temp * b + y1 ;				      double y = temp * b + y1 ;				  
  return new pair ( x , y ) ;				      	return make_pair ( x , y ) ;				      return pair ( x , y ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_NON_FIBONACCI_NUMBER				      NTH_NON_FIBONACCI_NUMBER					    NTH_NON_FIBONACCI_NUMBER					  NTH_NON_FIBONACCI_NUMBER
--							      --							    --								  --
static int nonFibonacci ( int n ) {			      int nonFibonacci ( int n ) {				    int nonFibonacci ( int n ) {				  success : identical to gold
  int prevPrev = 1 , prev = 2 , curr = 3 ;		      	int prevPrev = 1 , prev = 2 , curr = 3 ;		      int prevPrev = 1 , prev = 2 , curr = 3 ;			  
  while ( n > 0 ) {					      	while ( n > 0 ) {					      while ( n > 0 ) {						  
    prevPrev = prev ;					      	  prevPrev = prev ;					    	prevPrev = prev ;					  
    prev = curr ;					      	  prev = curr ;						    	prev = curr ;						  
    curr = prevPrev + prev ;				      	  curr = prevPrev + prev ;				    	curr = prevPrev + prev ;				  
    n = n - ( curr - prev - 1 ) ;			      	  n = n - ( curr - prev - 1 ) ;				    	n = n - ( curr - prev - 1 ) ;				  
  }							      	}							      }								  
  n = n + ( curr - prev - 1 ) ;				      	n = n + ( curr - prev - 1 ) ;				      n = n + ( curr - prev - 1 ) ;				  
  return prev + n ;					      	return prev + n ;					      return prev + n ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	      MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	    MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	  MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED
--							      --							    --								  --
static int minValue ( int A [ ] , int B [ ] , int n ) {	      int minValue ( int A [ ] , int B [ ] , int n ) {		    int minValue ( int A [ ] , int B [ ] , int n ) {		  success : None
  Arrays . sort ( A ) ;					      	sort ( A , A + n ) ;					      sort ( A , A + n ) ;					  
  Arrays . sort ( B ) ;					      	sort ( B , B + n ) ;					      sort ( B , B + n ) ;					  
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ;	      	i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ;	      i ++ ) {							  
  return result ;					      	return result ;						    	result += ( A [ i ] * B [ n - i - 1 ] ) ;		  
}							      }								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_PERIMETER_N_BLOCKS				      MINIMUM_PERIMETER_N_BLOCKS				    MINIMUM_PERIMETER_N_BLOCKS					  MINIMUM_PERIMETER_N_BLOCKS
--							      --							    --								  --
public static long minPerimeter ( int n ) {		      int minPerimeter ( int n ) {				    long long minPerimeter ( int n ) {				  success : None
  int l = ( int ) Math . sqrt ( n ) ;			      	int l = sqrt ( n ) ;					      int l = ( int ) sqrt ( n ) ;				  
  int sq = l * l ;					      	int sq = l * l ;					      int sq = l * l ;						  
  if ( sq == n ) return l * 4 ;				      	if ( sq == n ) return l * 4 ;				      if ( sq == n ) return l * 4 ;				  
  else {						      	else {							      else {							  
    long row = n / l ;					      	  long long int row = n / l ;				    	long long row = n / l ;					  
    long perimeter = 2 * ( l + row ) ;			      	  long long int perimeter = 2 * ( l + row ) ;		    	long long perimeter = 2 * ( l + row ) ;			  
    if ( n % l != 0 ) perimeter += 2 ;			      	  if ( n % l != 0 ) perimeter += 2 ;			    	if ( n % l != 0 ) perimeter += 2 ;			  
    return perimeter ;					      	  return perimeter ;					    	return perimeter ;					  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BINARY_SEARCH_1						      BINARY_SEARCH_1						    BINARY_SEARCH_1						  BINARY_SEARCH_1
--							      --							    --								  --
int binarySearch ( int arr [ ] , int x ) {		      int binarySearch ( int arr [ ] , int l , int r , int x ) {    int binarySearch ( int arr [ ] , int x ) {			  script_not_found : None
  int l = 0 , r = arr . length - 1 ;			      	while ( l <= r ) {					      int l = 0 , r = sizeof ( arr ) / sizeof ( arr [ 0 ] ) - 1 ; 
  while ( l <= r ) {					      	  int m = l + ( r - l ) / 2 ;				      while ( l <= r ) {					  
    int m = l + ( r - l ) / 2 ;				      	  if ( arr [ m ] == x ) return m ;			    	int m = l + ( r - l ) / 2 ;				  
    if ( arr [ m ] == x ) return m ;			      	  if ( arr [ m ] < x ) l = m + 1 ;			    	if ( arr [ m ] == x ) return m ;			  
    if ( arr [ m ] < x ) l = m + 1 ;			      	  else r = m - 1 ;					    	if ( arr [ m ] < x ) l = m + 1 ;			  
    else r = m - 1 ;					      	}							    	else r = m - 1 ;					  
  }							      	return - 1 ;						      }								  
  return - 1 ;						      }								      return - 1 ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		      FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		    FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		  FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1
--							      --							    --								  --
static int maxProduct ( int arr [ ] , int n ) {		      int maxProduct ( int arr [ ] , int n ) {			    int maxProduct ( int arr [ ] , int n ) {			  success : identical to gold
  if ( n < 3 ) {					      	if ( n < 3 ) return - 1 ;				      if ( n < 3 ) return - 1 ;					  
    return - 1 ;					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  }							      	return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [    return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [  
  Arrays . sort ( arr ) ;				      }								    }								  
  return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND
--							      --							    --								  --
static int countSeq ( int n ) {				      int countSeq ( int n ) {					    int countSeq ( int n ) {					  success : identical to gold
  int nCr = 1 , res = 1 ;				      	int nCr = 1 , res = 1 ;					      int nCr = 1 , res = 1 ;					  
  for ( int r = 1 ;					      	for ( int r = 1 ;					      for ( int r = 1 ;						  
  r <= n ;						      	r <= n ;						      r <= n ;							  
  r ++ ) {						      	r ++ ) {						      r ++ ) {							  
    nCr = ( nCr * ( n + 1 - r ) ) / r ;			      	  nCr = ( nCr * ( n + 1 - r ) ) / r ;			    	nCr = ( nCr * ( n + 1 - r ) ) / r ;			  
    res += nCr * nCr ;					      	  res += nCr * nCr ;					    	res += nCr * nCr ;					  
  }							      	}							      }								  
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			      DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			    DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			  DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM
--							      --							    --								  --
static void maximizecube ( int l , int b , int h ) {	      void maximizecube ( int l , int b , int h ) {		    void maximizecube ( int l , int b , int h ) {		  script_not_found : None
  int side = gcd ( l , gcd ( b , h ) ) ;		      	int side = __gcd ( l , __gcd ( b , h ) ) ;		      int side = gcd ( l , gcd ( b , h ) ) ;			  
  int num = l / side ;					      	int num = l / side ;					      int num = l / side ;					  
  num = ( num * b / side ) ;				      	num = ( num * b / side ) ;				      num = ( num * b / side ) ;				  
  num = ( num * h / side ) ;				      	num = ( num * h / side ) ;				      num = ( num * h / side ) ;				  
  System . out . println ( side + " " + num ) ;		      	cout << side << " " << num << endl ;			      cout << side << " " << num << endl ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE
--							      --							    --								  --
static void subArray ( int n ) {			      void subArray ( int arr [ ] , int n ) {			    void subArray ( int n ) {					  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = i ;					      	  for ( int j = i ;					    	for ( int j = i ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      for ( int k = i ;					      	    for ( int k = i ;					    	  for ( int k = i ;					  
      k <= j ;						      	    k <= j ;						    	  k <= j ;						  
      k ++ ) System . out . print ( arr [ k ] + " " ) ;	      	    k ++ ) cout << arr [ k ] << " " ;			    	  k ++ ) {						  
    }							      	    cout << endl ;					    	    cout << arr [ k ] << " " ;				  
  }							      	  }							    	  }							  
}							      	}							    	}							  
							      }								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		      PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		    PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		  PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES
--							      --							    --								  --
static boolean isPrime ( int p ) {			      bool isPrime ( int p ) {					    bool isPrime ( int p ) {					  error : PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SER
  double checkNumber = Math . pow ( 2 , p ) - 1 ;	      	long long checkNumber = pow ( 2 , p ) - 1 ;		      double checkNumber = pow ( 2 , p ) - 1 ;			  IES.cpp: In function ‘bool f_filled(int)’: PRIMALI
  double nextval = 4 % checkNumber ;			      	long long nextval = 4 % checkNumber ;			      double nextval = 4 % checkNumber ;			  TY_TEST_SET_5USING_LUCAS_LEHMER_SERIES.cpp:28:22:
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  error: invalid operands of types ‘int’ and ‘double
  i < p - 1 ;						      	i < p - 1 ;						      i < p - 1 ;						  ’ to binary ‘operator%’    double nextval = 4 % ch
  i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;  	i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;    i ++ ) {							  eckNumber ;			  ~~^~~~~~~~~~~~~ PR
  return ( nextval == 0 ) ;				      	return ( nextval == 0 ) ;				    	nextval = ( nextval * nextval - 2 ) % checkNumber ;	  IMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES.cpp:32
}							      }								      }								  :41: error: invalid operands of types ‘double’ and
							      								      return ( nextval == 0 ) ;					   ‘double’ to binary ‘operator%’      nextval = ( n
							      								    }								  extval * nextval - 2 ) % checkNumber ;
							      								    								      ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FLOOR_IN_A_SORTED_ARRAY					      FLOOR_IN_A_SORTED_ARRAY					    FLOOR_IN_A_SORTED_ARRAY					  FLOOR_IN_A_SORTED_ARRAY
--							      --							    --								  --
static int floorSearch ( int arr [ ] , int n , int x ) {      int floorSearch ( int arr [ ] , int n , int x ) {		    int floorSearch ( int arr [ ] , int n , int x ) {		  success : identical to gold
  if ( x >= arr [ n - 1 ] ) return n - 1 ;		      	if ( x >= arr [ n - 1 ] ) return n - 1 ;		      if ( x >= arr [ n - 1 ] ) return n - 1 ;			  
  if ( x < arr [ 0 ] ) return - 1 ;			      	if ( x < arr [ 0 ] ) return - 1 ;			      if ( x < arr [ 0 ] ) return - 1 ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ;	      	i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ;		      i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ;		  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION		      LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION			    LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION			  LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION
--							      --							    --								  --
static String minLexRotation ( String str ) {		      string minLexRotation ( string str ) {			    string minLexRotation ( string str ) {			  success : identical to gold
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  String arr [ ] = new String [ n ] ;			      	string arr [ n ] ;					      string arr [ n ] ;					  
  String concat = str + str ;				      	string concat = str + str ;				      string concat = str + str ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) arr [ i ] = concat . substr ( i , n ) ;		      i ++ ) arr [ i ] = concat . substr ( i , n ) ;		  
    arr [ i ] = concat . substring ( i , i + n ) ;	      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  }							      	return arr [ 0 ] ;					      return arr [ 0 ] ;					  
  Arrays . sort ( arr ) ;				      }								    }								  
  return arr [ 0 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX	      COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX	    COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX	  COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX
--							      --							    --								  --
static int countZeroes ( int mat [ ] [ ] ) {		      int countZeroes ( int mat [ N ] [ N ] ) {			    int countZeroes ( int mat [ ] [ N ] ) {			  script_not_found : None
  int row = N - 1 , col = 0 ;				      	int row = N - 1 , col = 0 ;				      int row = N - 1 , col = 0 ;				  
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  while ( col < N ) {					      	while ( col < N ) {					      while ( col < N ) {					  
    while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) retur 	  while ( mat [ row ] [ col ] ) if ( -- row < 0 ) return co 	while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) retur 
    count += ( row + 1 ) ;				      	  count += ( row + 1 ) ;				    	count += ( row + 1 ) ;					  
    col ++ ;						      	  col ++ ;						    	col ++ ;						  
  }							      	}							      }								  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_XOR_VALUE_PAIR_1				      MINIMUM_XOR_VALUE_PAIR_1					    MINIMUM_XOR_VALUE_PAIR_1					  MINIMUM_XOR_VALUE_PAIR_1
--							      --							    --								  --
static int minXOR ( int arr [ ] , int n ) {		      int minXOR ( int arr [ ] , int n ) {			    int minXOR ( int arr [ ] , int n ) {			  success : identical to gold
  Arrays . parallelSort ( arr ) ;			      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  int minXor = Integer . MAX_VALUE ;			      	int minXor = INT_MAX ;					      int minXor = INT_MAX ;					  
  int val = 0 ;						      	int val = 0 ;						      int val = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    val = arr [ i ] ^ arr [ i + 1 ] ;			      	  val = arr [ i ] ^ arr [ i + 1 ] ;			    	val = arr [ i ] ^ arr [ i + 1 ] ;			  
    minXor = Math . min ( minXor , val ) ;		      	  minXor = min ( minXor , val ) ;			    	minXor = min ( minXor , val ) ;				  
  }							      	}							      }								  
  return minXor ;					      	return minXor ;						      return minXor ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1		      COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1			    COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1			  COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1
--							      --							    --								  --
static int numberOfWays ( int x ) {			      int numberOfWays ( int x ) {				    int numberOfWays ( int x ) {				  success : None
  int dp [ ] = new int [ x + 1 ] ;			      	int dp [ x + 1 ] ;					      int dp [ x + 1 ] ;					  
  dp [ 0 ] = dp [ 1 ] = 1 ;				      	dp [ 0 ] = dp [ 1 ] = 1 ;				      dp [ 0 ] = dp [ 1 ] = 1 ;					  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= x ;						      	i <= x ;						      i <= x ;							  
  i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; 	i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ;   i ++ ) {							  
  return dp [ x ] ;					      	return dp [ x ] ;					    	dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ;	  
}							      }								      }								  
							      								      return dp [ x ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7	      FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7		    FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7		  FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7
--							      --							    --								  --
static int findpos ( String n ) {			      int findpos ( string n ) {				    int findpos ( string n ) {					  success : None
  int k = 0 , pos = 0 , i = 0 ;				      	int i = 0 , pos = 0 ;					      int k = 0 , pos = 0 , i = 0 ;				  
  while ( k != n . length ( ) ) {			      	while ( n [ i ] != '\0' ) {				      while ( k != n . length ( ) ) {				  
    switch ( n . charAt ( i ) ) {			      	  switch ( n [ i ] ) {					    	switch ( n [ i ] ) {					  
      case '4' : pos = pos * 2 + 1 ;			      	    case '4' : pos = pos * 2 + 1 ;			    	  case '4' : pos = pos * 2 + 1 ;			  
      break ;						      	    break ;						    	  break ;						  
      case '7' : pos = pos * 2 + 2 ;			      	    case '7' : pos = pos * 2 + 2 ;			    	  case '7' : pos = pos * 2 + 2 ;			  
      break ;						      	    break ;						    	  break ;						  
    }							      	  }							    	}							  
    i ++ ;						      	  i ++ ;						    	i ++ ;							  
    k ++ ;						      	}							    	k ++ ;							  
  }							      	return pos ;						      }								  
  return pos ;						      }								      return pos ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_ADDITION_TWO_MATRICES				      C_PROGRAM_ADDITION_TWO_MATRICES				    C_PROGRAM_ADDITION_TWO_MATRICES				  C_PROGRAM_ADDITION_TWO_MATRICES
--							      --							    --								  --
static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N  void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N  script_not_found : None
  int i , j ;						      	int i , j ;						      int i , j ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) for ( j = 0 ;					      	i ++ ) for ( j = 0 ;					      i ++ ) for ( j = 0 ;					  
  j < N ;						      	j < N ;							      j < N ;							  
  j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;      	j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;	      j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DIVISIBLE_PAIRS_ARRAY				      COUNT_DIVISIBLE_PAIRS_ARRAY				    COUNT_DIVISIBLE_PAIRS_ARRAY					  COUNT_DIVISIBLE_PAIRS_ARRAY
--							      --							    --								  --
static int countDivisibles ( int arr [ ] , int n ) {	      int countDivisibles ( int arr [ ] , int n ) {		    int countDivisibles ( int arr [ ] , int n ) {		  script_not_found : None
  int res = 0 ;						      	int res = 0 ;						      int res = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ 	j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [   j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ 
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY		      PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY		    PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY			  PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY
--							      --							    --								  --
static void printDistinct ( int arr [ ] , int n ) {	      void printDistinct ( int arr [ ] , int n ) {		    void print_distinct ( int arr [ ] , int n ) {		  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int j ;						      	  int j ;						    	int j ;							  
    for ( j = 0 ;					      	  for ( j = 0 ;						    	for ( j = 0 ;						  
    j < i ;						      	  j < i ;						    	j < i ;							  
    j ++ ) if ( arr [ i ] == arr [ j ] ) break ;	      	  j ++ ) if ( arr [ i ] == arr [ j ] ) break ;		    	j ++ ) if ( arr [ i ] == arr [ j ] ) break ;		  
    if ( i == j ) System . out . print ( arr [ i ] + " " ) ;  	  if ( i == j ) cout << arr [ i ] << " " ;		    	if ( i == j ) cout << arr [ i ] << " " ;		  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_SUBTRACTION_MATICES				      C_PROGRAM_SUBTRACTION_MATICES				    C_PROGRAM_SUBTRACTION_MATICES				  C_PROGRAM_SUBTRACTION_MATICES
--							      --							    --								  --
static void multiply ( int A [ ] [ ] , int B [ ] [ ] , int C  void multiply ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] void multiply ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] script_not_found : None
  int i , j ;						      	int i , j ;						      int i , j ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) for ( j = 0 ;					      	i ++ ) for ( j = 0 ;					      i ++ ) for ( j = 0 ;					  
  j < N ;						      	j < N ;							      j < N ;							  
  j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;      	j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;	      j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FRIENDS_PAIRING_PROBLEM					      FRIENDS_PAIRING_PROBLEM					    FRIENDS_PAIRING_PROBLEM					  FRIENDS_PAIRING_PROBLEM
--							      --							    --								  --
static int countFriendsPairings ( int n ) {		      int countFriendsPairings ( int n ) {			    int countFriendsPairings ( int n ) {			  success : None
  int dp [ ] = new int [ n + 1 ] ;			      	int dp [ n + 1 ] ;					      int dp [ n + 1 ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( i <= 2 ) dp [ i ] = i ;			      	  if ( i <= 2 ) dp [ i ] = i ;				    	if ( i <= 2 ) {						  
    else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; 	  else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; 	  dp [ i ] = i ;					  
  }							      	}							    	}							  
  return dp [ n ] ;					      	return dp [ n ] ;					    	else {							  
}							      }								    	  dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ;	  
							      								    	}							  
							      								      }								  
							      								      return dp [ n ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN			      N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN			    N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN			  N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN
--							      --							    --								  --
public static int findNth ( int n ) {			      int findNth ( int n ) {					    int findNth ( int n ) {					  success : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int curr = 1 ;					      	for ( int curr = 1 ;					      for ( int curr = 1 ;					  
  ;							      	;							      ;								  
  curr ++ ) {						      	curr ++ ) {						      curr ++ ) {						  
    int sum = 0 ;					      	  int sum = 0 ;						    	int sum = 0 ;						  
    for ( int x = curr ;				      	  for ( int x = curr ;					    	for ( int x = curr ;					  
    x > 0 ;						      	  x > 0 ;						    	x > 0 ;							  
    x = x / 10 ) sum = sum + x % 10 ;			      	  x = x / 10 ) sum = sum + x % 10 ;			    	x = x / 10 ) {						  
    if ( sum == 10 ) count ++ ;				      	  if ( sum == 10 ) count ++ ;				    	  sum = sum + x % 10 ;					  
    if ( count == n ) return curr ;			      	  if ( count == n ) return curr ;			    	}							  
  }							      	}							    	if ( sum == 10 ) {					  
}							      	return - 1 ;						    	  count ++ ;						  
							      }								    	}							  
							      								    	if ( count == n ) {					  
							      								    	  return curr ;						  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_FIRST_MISSING_NUMBER				      FIND_THE_FIRST_MISSING_NUMBER				    FIND_THE_FIRST_MISSING_NUMBER				  FIND_THE_FIRST_MISSING_NUMBER
--							      --							    --								  --
int findFirstMissing ( int array [ ] , int start , int end )  int findFirstMissing ( int array [ ] , int start , int end )  int findFirstMissing ( int array [ ] , int start , int end )  success : identical to gold
  if ( start > end ) return end + 1 ;			      	if ( start > end ) return end + 1 ;			      if ( start > end ) return end + 1 ;			  
  if ( start != array [ start ] ) return start ;	      	if ( start != array [ start ] ) return start ;		      if ( start != array [ start ] ) return start ;		  
  int mid = ( start + end ) / 2 ;			      	int mid = ( start + end ) / 2 ;				      int mid = ( start + end ) / 2 ;				  
  if ( array [ mid ] == mid ) return findFirstMissing ( array 	if ( array [ mid ] == mid ) return findFirstMissing ( array   if ( array [ mid ] == mid ) return findFirstMissing ( array 
  return findFirstMissing ( array , start , mid ) ;	      	return findFirstMissing ( array , start , mid ) ;	      return findFirstMissing ( array , start , mid ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM   DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM   DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM	  DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM
--							      --							    --								  --
static int maxTasks ( int high [ ] , int low [ ] , int n ) {  int maxTasks ( int high [ ] , int low [ ] , int n ) {	    int maxTasks ( int high [ ] , int low [ ] , int n ) {	  success : identical to gold
  if ( n <= 0 ) return 0 ;				      	if ( n <= 0 ) return 0 ;				      if ( n <= 0 ) return 0 ;					  
  return Math . max ( high [ n - 1 ] + maxTasks ( high , low  	return max ( high [ n - 1 ] + maxTasks ( high , low , ( n -   return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		      FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		    FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		  FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS
--							      --							    --								  --
static void findElements ( int arr [ ] , int n ) {	      void findElements ( int arr [ ] , int n ) {		    void findElements ( int arr [ ] , int n ) {			  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int count = 0 ;					      	  int count = 0 ;					    	int count = 0 ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ;	      	  j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ;	    	j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ;		  
    if ( count >= 2 ) System . out . print ( arr [ i ] + " "  	  if ( count >= 2 ) cout << arr [ i ] << " " ;		    	if ( count >= 2 ) cout << arr [ i ] << " " ;		  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		      PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		    PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		  PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2
--							      --							    --								  --
static void printDistinct ( int arr [ ] ) {		      void printDistinct ( int arr [ ] , int n ) {		    void printDistinct ( int arr [ ] ) {			  script_not_found : None
  HashSet < Integer > set = new HashSet < > ( ) ;	      	unordered_set < int > s ;				      set < int > set ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < arr . length ;					      	i < n ;							      i < sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( ! set . contains ( arr [ i ] ) ) {		      	  if ( s . find ( arr [ i ] ) == s . end ( ) ) {	    	if ( ! set . count ( arr [ i ] ) ) {			  
      set . add ( arr [ i ] ) ;				      	    s . insert ( arr [ i ] ) ;				    	  set . insert ( arr [ i ] ) ;				  
      System . out . print ( arr [ i ] + " " ) ;	      	    cout << arr [ i ] << " " ;				    	  cout << arr [ i ] << " " ;				  
    }							      	  }							    	}							  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_WAYS_BREAK_STRING_BRACKET_FORM			      PRINT_WAYS_BREAK_STRING_BRACKET_FORM			    PRINT_WAYS_BREAK_STRING_BRACKET_FORM			  PRINT_WAYS_BREAK_STRING_BRACKET_FORM
--							      --							    --								  --
static void findCombinations ( String str , int index , Strin void findCombinations ( string str , int index , string out ) void findCombinations ( string str , int index , string out ) script_not_found : None
  if ( index == str . length ( ) ) System . out . println ( o 	if ( index == str . length ( ) ) cout << out << endl ;	      if ( index == str . length ( ) ) {			  
  for ( int i = index ;					      	for ( int i = index ;					    	cout << out << endl ;					  
  i < str . length ( ) ;				      	i < str . length ( ) ;					      }								  
  i ++ ) findCombinations ( str , i + 1 , out + "(" + str . s 	i ++ ) findCombinations ( str , i + 1 , out + "(" + str . s   for ( int i = index ;					  
}							      }								      i < str . length ( ) ;					  
							      								      i ++ ) {							  
							      								    	findCombinations ( str , i + 1 , out + "(" + str . substr 
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		      CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		    CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		  CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION
--							      --							    --								  --
static int findMinX ( int num [ ] , int rem [ ] , int k ) {   int findMinX ( int num [ ] , int rem [ ] , int k ) {	    int findMinX ( int num [ ] , int rem [ ] , int k ) {	  script_not_found : None
  int x = 1 ;						      	int x = 1 ;						      int x = 1 ;						  
  while ( true ) {					      	while ( true ) {					      while ( true ) {						  
    int j ;						      	  int j ;						    	int j ;							  
    for ( j = 0 ;					      	  for ( j = 0 ;						    	for ( j = 0 ;						  
    j < k ;						      	  j < k ;						    	j < k ;							  
    j ++ ) if ( x % num [ j ] != rem [ j ] ) break ;	      	  j ++ ) if ( x % num [ j ] != rem [ j ] ) break ;	    	j ++ ) if ( x % num [ j ] != rem [ j ] ) break ;	  
    if ( j == k ) return x ;				      	  if ( j == k ) return x ;				    	if ( j == k ) return x ;				  
    x ++ ;						      	  x ++ ;						    	x ++ ;							  
  }							      	}							      }								  
}							      	return x ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		      NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		    NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		  NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N
--							      --							    --								  --
static int countIntegralSolutions ( int n ) {		      int countIntegralSolutions ( int n ) {			    int countIntegralSolutions ( int n ) {			  success : identical to gold
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j <= n - i ;						      	j <= n - i ;						      j <= n - i ;						  
  j ++ ) for ( int k = 0 ;				      	j ++ ) for ( int k = 0 ;				      j ++ ) for ( int k = 0 ;					  
  k <= ( n - i - j ) ;					      	k <= ( n - i - j ) ;					      k <= ( n - i - j ) ;					  
  k ++ ) if ( i + j + k == n ) result ++ ;		      	k ++ ) if ( i + j + k == n ) result ++ ;		      k ++ ) if ( i + j + k == n ) result ++ ;			  
  return result ;					      	return result ;						      return result ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS	      MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS		    MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS		  MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS
--							      --							    --								  --
static long findMinSum ( long a [ ] , long b [ ] , long n ) { long long int findMinSum ( int a [ ] , int b [ ] , int n ) {  long long findMinSum ( long long a [ ] , long long b [ ] , lo script_not_found : None
  Arrays . sort ( a ) ;					      	sort ( a , a + n ) ;					      qsort ( a , n , sizeof ( long long ) ) ;			  
  Arrays . sort ( b ) ;					      	sort ( b , b + n ) ;					      qsort ( b , n , sizeof ( long long ) ) ;			  
  long sum = 0 ;					      	long long int sum = 0 ;					      long long sum = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ;	      	i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ) ;		      i ++ ) {							  
  return sum ;						      	return sum ;						    	sum = sum + abs ( a [ i ] - b [ i ] ) ;			  
}							      }								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K	      PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K		    PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K		  PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K
--							      --							    --								  --
static boolean isPossible ( Integer a [ ] , int b [ ] , int n bool isPossible ( int a [ ] , int b [ ] , int n , int k ) {   bool isPossible ( int32_t a [ ] , int32_t b [ ] , int32_t n , failure : #Results: 9, 10
  Arrays . sort ( a , Collections . reverseOrder ( ) ) ;      	sort ( a , a + n ) ;					      std :: sort ( a , a + n ) ;				  
  Arrays . sort ( b ) ;					      	sort ( b , b + n , greater < int > ( ) ) ;		      std :: sort ( b , b + n ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int32_t i = 0 ;					  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( a [ i ] + b [ i ] < k ) return false ;	      	i ++ ) if ( a [ i ] + b [ i ] < k ) return false ;	      i ++ ) if ( a [ i ] + b [ i ] < k ) return false ;	  
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI
--							      --							    --								  --
static int countNegative ( int M [ ] [ ] , int n , int m ) {  int countNegative ( int M [ ] [ 4 ] , int n , int m ) {	    int countNegative ( int M [ ] [ 2 ] , int n , int m ) {	  script_not_found : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < m ;						      	  j < m ;						    	j < m ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( M [ i ] [ j ] < 0 ) count += 1 ;		      	    if ( M [ i ] [ j ] < 0 ) count += 1 ;		    	  if ( M [ i ] [ j ] < 0 ) {				  
      else break ;					      	    else break ;					    	    count += 1 ;					  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  return count ;					      	return count ;						    	    break ;						  
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING	      CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING		    CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING		  CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING
--							      --							    --								  --
static int findSum ( String str ) {			      int findSum ( string str ) {				    int findSum ( string str ) {				  success : None
  String temp = "" ;					      	string temp = "" ;					      string temp ;						  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 0 ;					      	for ( char ch : str ) {					      for ( int i = 0 ;						  
  i < str . length ( ) ;				      	  if ( isdigit ( ch ) ) temp += ch ;			      i < str . length ( ) ;					  
  i ++ ) {						      	  else {						      i ++ ) {							  
    char ch = str . charAt ( i ) ;			      	    sum += atoi ( temp . c_str ( ) ) ;			    	char ch = str [ i ] ;					  
    if ( Character . isDigit ( ch ) ) temp += ch ;	      	    temp = "" ;						    	if ( isdigit ( ch ) ) {					  
    else {						      	  }							    	  temp += ch ;						  
      sum += Integer . parseInt ( temp ) ;		      	}							    	}							  
      temp = "0" ;					      	return sum + atoi ( temp . c_str ( ) ) ;		    	else {							  
    }							      }								    	  sum += atoi ( temp . c_str ( ) ) ;			  
  }							      								    	  temp = "0" ;						  
  return sum + Integer . parseInt ( temp ) ;		      								    	}							  
}							      								      }								  
							      								      return sum + atoi ( temp . c_str ( ) ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2
--							      --							    --								  --
static int numberOfPaths ( int m , int n ) {		      int numberOfPaths ( int m , int n ) {			    int numberOfPaths ( int m , int n ) {			  failure : #Results: 1, 10
  int [ ] dp = new int [ n ] ;				      	int dp [ n ] = {					      vector < int > dp ( n , 1 ) ;				  
  dp [ 0 ] = 1 ;					      	  1 }							      dp [ 0 ] = 1 ;						  
  for ( int i = 0 ;					      	  ;							      for ( int i = 0 ;						  
  i < m ;						      	  dp [ 0 ] = 1 ;					      i < m ;							  
  i ++ ) {						      	  for ( int i = 0 ;					      i ++ ) {							  
    for ( int j = 1 ;					      	  i < m ;						    	for ( int j = 1 ;					  
    j < n ;						      	  i ++ ) {						    	j < n ;							  
    j ++ ) {						      	    for ( int j = 1 ;					    	j ++ ) dp [ j ] += dp [ j - 1 ] ;			  
      dp [ j ] += dp [ j - 1 ] ;			      	    j < n ;						      }								  
    }							      	    j ++ ) {						      return dp [ n - 1 ] ;					  
  }							      	      dp [ j ] += dp [ j - 1 ] ;			    }								  
  return dp [ n - 1 ] ;					      	    }							    								  
}							      	  }							    								  
							      	  return dp [ n - 1 ] ;					    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GNOME_SORT_A_STUPID_ONE					      GNOME_SORT_A_STUPID_ONE					    GNOME_SORT_A_STUPID_ONE					  GNOME_SORT_A_STUPID_ONE
--							      --							    --								  --
static void gnomeSort ( int arr [ ] , int n ) {		      void gnomeSort ( int arr [ ] , int n ) {			    void gnomeSort ( int arr [ ] , int n ) {			  script_not_found : None
  int index = 0 ;					      	int index = 0 ;						      int index = 0 ;						  
  while ( index < n ) {					      	while ( index < n ) {					      while ( index < n ) {					  
    if ( index == 0 ) index ++ ;			      	  if ( index == 0 ) index ++ ;				    	if ( index == 0 ) index ++ ;				  
    if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ;      	  if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ;	    	if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ;	  
    else {						      	  else {						    	else {							  
      int temp = 0 ;					      	    swap ( arr [ index ] , arr [ index - 1 ] ) ;	    	  int temp = 0 ;					  
      temp = arr [ index ] ;				      	    index -- ;						    	  temp = arr [ index ] ;				  
      arr [ index ] = arr [ index - 1 ] ;		      	  }							    	  arr [ index ] = arr [ index - 1 ] ;			  
      arr [ index - 1 ] = temp ;			      	}							    	  arr [ index - 1 ] = temp ;				  
      index -- ;					      	return ;						    	  index -- ;						  
    }							      }								    	}							  
  }							      								      }								  
  return ;						      								      return ;							  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BUBBLE_SORT						      BUBBLE_SORT						    BUBBLE_SORT							  BUBBLE_SORT
--							      --							    --								  --
void bubbleSort ( int arr [ ] ) {			      void bubbleSort ( int arr [ ] , int n ) {			    void bubbleSort ( int arr [ ] ) {				  script_not_found : None
  int n = arr . length ;				      	int i , j ;						      int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  for ( int i = 0 ;					      	for ( i = 0 ;						      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( j = 0 ;					      i ++ ) for ( int j = 0 ;					  
  j < n - i - 1 ;					      	j < n - i - 1 ;						      j < n - i - 1 ;						  
  j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) {		      	j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) swap ( & arr [ j ]    j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) {			  
    int temp = arr [ j ] ;				      }								    	int temp = arr [ j ] ;					  
    arr [ j ] = arr [ j + 1 ] ;				      								    	arr [ j ] = arr [ j + 1 ] ;				  
    arr [ j + 1 ] = temp ;				      								    	arr [ j + 1 ] = temp ;					  
  }							      								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		      SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		    SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		  SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1
--							      --							    --								  --
static int insertSorted ( int arr [ ] , int n , int key , int int insertSorted ( int arr [ ] , int n , int key , int capaci int insertSorted ( int arr [ ] , int n , int key , int capaci success : None
  if ( n >= capacity ) return n ;			      	if ( n >= capacity ) return n ;				      if ( n >= capacity ) return n ;				  
  int i ;						      	int i ;							      int i ;							  
  for ( i = n - 1 ;					      	for ( i = n - 1 ;					      for ( i = n - 1 ;						  
  ( i >= 0 && arr [ i ] > key ) ;			      	( i >= 0 && arr [ i ] > key ) ;				      ( i >= 0 && arr [ i ] > key ) ;				  
  i -- ) arr [ i + 1 ] = arr [ i ] ;			      	i -- ) arr [ i + 1 ] = arr [ i ] ;			      i -- ) {							  
  arr [ i + 1 ] = key ;					      	arr [ i + 1 ] = key ;					    	arr [ i + 1 ] = arr [ i ] ;				  
  return ( n + 1 ) ;					      	return ( n + 1 ) ;					      }								  
}							      }								      arr [ i + 1 ] = key ;					  
							      								      return ( n + 1 ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY		      MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY		    MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY			  MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY
--							      --							    --								  --
static int solve ( int arr [ ] , int n ) {		      int solve ( int arr [ ] , int n ) {			    int solve ( int arr [ ] , int n ) {				  success : None
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  int a = 0 , b = 0 ;					      	int a = 0 , b = 0 ;					      int a = 0 , b = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ;		      	  if ( i & 1 ) a = a * 10 + arr [ i ] ;			    	if ( i % 2 != 0 ) {					  
    else b = b * 10 + arr [ i ] ;			      	  else b = b * 10 + arr [ i ] ;				    	  a = a * 10 + arr [ i ] ;				  
  }							      	}							    	}							  
  return a + b ;					      	return a + b ;						    	else {							  
}							      }								    	  b = b * 10 + arr [ i ] ;				  
							      								    	}							  
							      								      }								  
							      								      return a + b ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE			  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE
--							      --							    --								  --
public static String recursiveReverse ( char [ ] str ) {      void recursiveReverse ( string & str ) {			    string recursiveReverse ( string str ) {			  script_not_found : None
  Stack < Character > st = new Stack < > ( ) ;		      	stack < char > st ;					      stack < char > st ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < str . length ;					      	i < str . length ( ) ;					      i < str . length ( ) ;					  
  i ++ ) st . push ( str [ i ] ) ;			      	i ++ ) st . push ( str [ i ] ) ;			      i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	st . push ( str [ i ] ) ;				  
  i < str . length ;					      	i < str . length ( ) ;					      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 0 ;						  
    str [ i ] = st . peek ( ) ;				      	  str [ i ] = st . top ( ) ;				      i < str . length ( ) ;					  
    st . pop ( ) ;					      	  st . pop ( ) ;					      i ++ ) {							  
  }							      	}							    	str [ i ] = st . top ( ) ;				  
  return String . valueOf ( str ) ;			      }								    	st . pop ( ) ;						  
}							      								      }								  
							      								      return string ( str . begin ( ) , str . end ( ) ) ;	  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_CONWAY_SEQUENCE_1				      NEWMAN_CONWAY_SEQUENCE_1					    NEWMAN_CONWAY_SEQUENCE_1					  NEWMAN_CONWAY_SEQUENCE_1
--							      --							    --								  --
static int sequence ( int n ) {				      int sequence ( int n ) {					    int sequence ( int n ) {					  success : None
  int f [ ] = new int [ n + 1 ] ;			      	int f [ n + 1 ] ;					      int f [ n + 1 ] ;						  
  f [ 0 ] = 0 ;						      	int i ;							      f [ 0 ] = 0 ;						  
  f [ 1 ] = 1 ;						      	f [ 0 ] = 0 ;						      f [ 1 ] = 1 ;						  
  f [ 2 ] = 1 ;						      	f [ 1 ] = 1 ;						      f [ 2 ] = 1 ;						  
  int i ;						      	f [ 2 ] = 1 ;						      int i ;							  
  for ( i = 3 ;						      	for ( i = 3 ;						      for ( i = 3 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]  	i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]    i ++ ) {							  
  return f [ n ] ;					      	return f [ n ] ;					    	f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;	  
}							      }								      }								  
							      								      return f [ n ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES  FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES  FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES  FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES
--							      --							    --								  --
static int countSol ( int coeff [ ] , int start , int end , i int countSol ( int coeff [ ] , int start , int end , int rhs  int countSol ( int coeff [ ] , int start , int end , int rhs  script_not_found : None
  if ( rhs == 0 ) return 1 ;				      	if ( rhs == 0 ) return 1 ;				      if ( rhs == 0 ) return 1 ;				  
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  for ( int i = start ;					      	for ( int i = start ;					      for ( int i = start ;					  
  i <= end ;						      	i <= end ;						      i <= end ;						  
  i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff 	i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff   i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff 
  return result ;					      	return result ;						      return result ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS   GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS   GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS	  GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS
--							      --							    --								  --
static void generate ( int ones , int zeroes , String str , i void generate ( int ones , int zeroes , string str , int len  void generate ( int ones , int zeroes , string str , int len  script_not_found : None
  if ( len == str . length ( ) ) {			      	if ( len == str . length ( ) ) {			      if ( len == str . length ( ) ) {				  
    System . out . print ( str + " " ) ;		      	  cout << str << "  " ;					    	cout << str << " " ;					  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  generate ( ones + 1 , zeroes , str + "1" , len ) ;	      	generate ( ones + 1 , zeroes , str + "1" , len ) ;	      generate ( ones + 1 , zeroes , str + "1" , len ) ;	  
  if ( ones > zeroes ) {				      	if ( ones > zeroes ) generate ( ones , zeroes + 1 , str + "   if ( ones > zeroes ) generate ( ones , zeroes + 1 , str + " 
    generate ( ones , zeroes + 1 , str + "0" , len ) ;	      }								    }								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_INSERTION_SORT				      RECURSIVE_INSERTION_SORT					    RECURSIVE_INSERTION_SORT					  RECURSIVE_INSERTION_SORT
--							      --							    --								  --
static void insertionSortRecursive ( int arr [ ] , int n ) {  void insertionSortRecursive ( int arr [ ] , int n ) {	    void insertionSortRecursive ( int arr [ ] , int n ) {	  script_not_found : None
  if ( n <= 1 ) return ;				      	if ( n <= 1 ) return ;					      if ( n <= 1 ) return ;					  
  insertionSortRecursive ( arr , n - 1 ) ;		      	insertionSortRecursive ( arr , n - 1 ) ;		      insertionSortRecursive ( arr , n - 1 ) ;			  
  int last = arr [ n - 1 ] ;				      	int last = arr [ n - 1 ] ;				      int last = arr [ n - 1 ] ;				  
  int j = n - 2 ;					      	int j = n - 2 ;						      int j = n - 2 ;						  
  while ( j >= 0 && arr [ j ] > last ) {		      	while ( j >= 0 && arr [ j ] > last ) {			      while ( j >= 0 && arr [ j ] > last ) {			  
    arr [ j + 1 ] = arr [ j ] ;				      	  arr [ j + 1 ] = arr [ j ] ;				    	arr [ j + 1 ] = arr [ j ] ;				  
    j -- ;						      	  j -- ;						    	j -- ;							  
  }							      	}							      }								  
  arr [ j + 1 ] = last ;				      	arr [ j + 1 ] = last ;					      arr [ j + 1 ] = last ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S			      REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S			    REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S			  REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S
--							      --							    --								  --
static String replace ( String s , char c1 , char c2 ) {      string replace ( string s , char c1 , char c2 ) {		    string replace ( string s , char c1 , char c2 ) {		  error : REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S.cpp
  int l = s . length ( ) ;				      	int l = s . length ( ) ;				      int l = s . length ( ) ;					  : In function ‘std::__cxx11::string f_filled(std::
  char [ ] arr = s . toCharArray ( ) ;			      	for ( int i = 0 ;					      char * arr = s . c_str ( ) ;				  __cxx11::string, char, char)’: REPLACE_CHARACTER_C
  for ( int i = 0 ;					      	i < l ;							      for ( int i = 0 ;						  1_C2_C2_C1_STRING_S.cpp:30:26: error: invalid conv
  i < l ;						      	i ++ ) {						      i < l ;							  ersion from ‘const char*’ to ‘char*’ [-fpermissive
  i ++ ) {						      	  if ( s [ i ] == c1 ) s [ i ] = c2 ;			      i ++ ) {							  ]    char * arr = s . c_str ( ) ;
    if ( arr [ i ] == c1 ) arr [ i ] = c2 ;		      	  else if ( s [ i ] == c2 ) s [ i ] = c1 ;		    	if ( arr [ i ] == c1 ) {				  ~~~~~~~~~~^~~
    else if ( arr [ i ] == c2 ) arr [ i ] = c1 ;	      	}							    	  arr [ i ] = c2 ;					  
  }							      	return s ;						    	}							  
  return String . valueOf ( arr ) ;			      }								    	else if ( arr [ i ] == c2 ) {				  
}							      								    	  arr [ i ] = c1 ;					  
							      								    	}							  
							      								      }								  
							      								      return string ( arr , l ) ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO	      WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO	    WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO	  WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO
--							      --							    --								  --
static int xorZero ( String s ) {			      int xorZero ( string str ) {				    int xorZero ( string s ) {					  success : None
  int one_count = 0 , zero_count = 0 ;			      	int one_count = 0 , zero_count = 0 ;			      int one_count = 0 , zero_count = 0 ;			  
  char [ ] str = s . toCharArray ( ) ;			      	int n = str . length ( ) ;				      string :: size_type n = s . length ( ) ;			  
  int n = str . length ;				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  for ( int i = 0 ;					      	i < n ;							      i < n ;							  
  i < n ;						      	i ++ ) if ( str [ i ] == '1' ) one_count ++ ;		      i ++ ) if ( s [ i ] == '1' ) one_count ++ ;		  
  i ++ ) if ( str [ i ] == '1' ) one_count ++ ;		      	else zero_count ++ ;					      else zero_count ++ ;					  
  else zero_count ++ ;					      	if ( one_count % 2 == 0 ) return zero_count ;		      if ( one_count % 2 == 0 ) return zero_count ;		  
  if ( one_count % 2 == 0 ) return zero_count ;		      	return one_count ;					      return one_count ;					  
  return one_count ;					      }								    }								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI
--							      --							    --								  --
static int countNegative ( int M [ ] [ ] , int n , int m ) {  int countNegative ( int M [ ] [ 4 ] , int n , int m ) {	    int countNegative ( int M [ ] [ 2 ] , int n , int m ) {	  script_not_found : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  int j = m - 1 ;					      	int j = m - 1 ;						      int j = m - 1 ;						  
  while ( j >= 0 && i < n ) {				      	while ( j >= 0 && i < n ) {				      while ( j >= 0 && i < n ) {				  
    if ( M [ i ] [ j ] < 0 ) {				      	  if ( M [ i ] [ j ] < 0 ) {				    	if ( M [ i ] [ j ] < 0 ) {				  
      count += j + 1 ;					      	    count += j + 1 ;					    	  count += j + 1 ;					  
      i += 1 ;						      	    i += 1 ;						    	  i += 1 ;						  
    }							      	  }							    	}							  
    else j -= 1 ;					      	  else j -= 1 ;						    	else {							  
  }							      	}							    	  j -= 1 ;						  
  return count ;					      	return count ;						    	}							  
}							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LAST_NON_ZERO_DIGIT_FACTORIAL				      LAST_NON_ZERO_DIGIT_FACTORIAL				    LAST_NON_ZERO_DIGIT_FACTORIAL				  LAST_NON_ZERO_DIGIT_FACTORIAL
--							      --							    --								  --
static int lastNon0Digit ( int n ) {			      int lastNon0Digit ( int n ) {				    int lastNon0Digit ( int n ) {				  script_not_found : None
  if ( n < 10 ) return dig [ n ] ;			      	if ( n < 10 ) return dig [ n ] ;			      if ( n < 10 ) return dig [ n ] ;				  
  if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Di 	if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Di   if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Di 
  else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ]  	else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ]    else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ]  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION		      EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION		    EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION		  EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION
--							      --							    --								  --
static long exponentiation ( long base , long exp ) {	      long int exponentiation ( long int base , long int exp ) {    long long exponentiation ( long long base , long long exp ) { script_not_found : None
  if ( exp == 0 ) return 1 ;				      	if ( exp == 0 ) return 1 ;				      if ( exp == 0 ) return 1 ;				  
  if ( exp == 1 ) return base % N ;			      	if ( exp == 1 ) return base % N ;			      if ( exp == 1 ) return base % N ;				  
  long t = exponentiation ( base , exp / 2 ) ;		      	long int t = exponentiation ( base , exp / 2 ) ;	      long long t = exponentiation ( base , exp / 2 ) ;		  
  t = ( t * t ) % N ;					      	t = ( t * t ) % N ;					      t = ( t * t ) % N ;					  
  if ( exp % 2 == 0 ) return t ;			      	if ( exp % 2 == 0 ) return t ;				      if ( exp % 2 == 0 ) return t ;				  
  else return ( ( base % N ) * t ) % N ;		      	else return ( ( base % N ) * t ) % N ;			      else return ( ( base % N ) * t ) % N ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_PRINT_IDENTITY_MATRIX_1				      PROGRAM_PRINT_IDENTITY_MATRIX_1				    PROGRAM_PRINT_IDENTITY_MATRIX_1				  PROGRAM_PRINT_IDENTITY_MATRIX_1
--							      --							    --								  --
static boolean isIdentity ( int mat [ ] [ ] , int N ) {	      bool isIdentity ( int mat [ ] [ MAX ] , int N ) {		    bool isIdentity ( int mat [ ] [ N ] , int N ) {		  script_not_found : None
  for ( int row = 0 ;					      	for ( int row = 0 ;					      for ( int row = 0 ;					  
  row < N ;						      	row < N ;						      row < N ;							  
  row ++ ) {						      	row ++ ) {						      row ++ ) {						  
    for ( int col = 0 ;					      	  for ( int col = 0 ;					    	for ( int col = 0 ;					  
    col < N ;						      	  col < N ;						    	col < N ;						  
    col ++ ) {						      	  col ++ ) {						    	col ++ ) {						  
      if ( row == col && mat [ row ] [ col ] != 1 ) return fa 	    if ( row == col && mat [ row ] [ col ] != 1 ) return fa 	  if ( row == col && mat [ row ] [ col ] != 1 ) return fa 
      else if ( row != col && mat [ row ] [ col ] != 0 ) retu 	    else if ( row != col && mat [ row ] [ col ] != 0 ) retu 	  else if ( row != col && mat [ row ] [ col ] != 0 ) retu 
    }							      	  }							    	}							  
  }							      	}							      }								  
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ONE_EXTRA_CHARACTER_STRING_1			      FIND_ONE_EXTRA_CHARACTER_STRING_1				    FIND_ONE_EXTRA_CHARACTER_STRING_1				  FIND_ONE_EXTRA_CHARACTER_STRING_1
--							      --							    --								  --
static char findExtraCharcter ( String strA , String strB ) { char findExtraCharcter ( string strA , string strB ) {	    char findExtraCharcter ( string strA , string strB ) {	  success : None
  int res = 0 , i ;					      	int res = 0 , i ;					      int res = 0 , i ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < strA . length ( ) ;				      	i < strA . length ( ) ;					      i < strA . length ( ) ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) res ^= strA [ i ] ;				  
    res ^= strA . charAt ( i ) ;			      	  res ^= strA [ i ] ;					      for ( i = 0 ;						  
  }							      	}							      i < strB . length ( ) ;					  
  for ( i = 0 ;						      	for ( i = 0 ;						      i ++ ) res ^= strB [ i ] ;				  
  i < strB . length ( ) ;				      	i < strB . length ( ) ;					      return ( ( char ) ( res ) ) ;				  
  i ++ ) {						      	i ++ ) {						    }								  
    res ^= strB . charAt ( i ) ;			      	  res ^= strB [ i ] ;					    								  
  }							      	}							    								  
  return ( ( char ) ( res ) ) ;				      	return ( ( char ) ( res ) ) ;				    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	      WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	    WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	  WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS
--							      --							    --								  --
static int countWays ( int n ) {			      int countWays ( int n ) {					    int countWays ( int n ) {					  success : identical to gold
  int table [ ] = new int [ n + 1 ] ;			      	int table [ n + 1 ] ;					      int table [ n + 1 ] ;					  
  Arrays . fill ( table , 0 ) ;				      	memset ( table , 0 , sizeof ( table ) ) ;		      memset ( table , 0 , sizeof ( table ) ) ;			  
  table [ 0 ] = 1 ;					      	table [ 0 ] = 1 ;					      table [ 0 ] = 1 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = i ;				      	i ++ ) for ( int j = i ;				      i ++ ) for ( int j = i ;					  
  j <= n ;						      	j <= n ;						      j <= n ;							  
  j ++ ) table [ j ] += table [ j - i ] ;		      	j ++ ) table [ j ] += table [ j - i ] ;			      j ++ ) table [ j ] += table [ j - i ] ;			  
  return table [ n ] ;					      	return table [ n ] ;					      return table [ n ] ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS	      COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS	    COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS		  COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS
--							      --							    --								  --
static int countPairs ( String str ) {			      int countPairs ( string str ) {				    int countPairs ( string str ) {				  success : identical to gold
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) if ( Math . abs ( str . charAt ( i ) - str . charAt  	j ++ ) if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j )    j ++ ) if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j )  
  return result ;					      	return result ;						      return result ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_DIFFERENCE_PAIR				      FIND_MINIMUM_DIFFERENCE_PAIR				    FIND_MINIMUM_DIFFERENCE_PAIR				  FIND_MINIMUM_DIFFERENCE_PAIR
--							      --							    --								  --
static int findMinDiff ( int [ ] arr , int n ) {	      int findMinDiff ( int arr [ ] , int n ) {			    int findMinDiff ( int * arr , int n ) {			  success : None
  int diff = Integer . MAX_VALUE ;			      	int diff = INT_MAX ;					      int diff = INT_MAX ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff 	j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = a   j ++ ) if ( abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff 
  return diff ;						      	return diff ;						      return diff ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_DIFFERENCE_EQUAL_K				      COUNT_PAIRS_DIFFERENCE_EQUAL_K				    COUNT_PAIRS_DIFFERENCE_EQUAL_K				  COUNT_PAIRS_DIFFERENCE_EQUAL_K
--							      --							    --								  --
static int countPairsWithDiffK ( int arr [ ] , int n , int k  int countPairsWithDiffK ( int arr [ ] , int n , int k ) {	    int countPairsWithDiffK ( int arr [ ] , int n , int k ) {	  success : identical to gold
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr 	  j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr 	j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr 
  }							      	}							      }								  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY   CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY   CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY	  CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY
--							      --							    --								  --
static boolean checkIsAP ( int arr [ ] , int n ) {	      bool checkIsAP ( int arr [ ] , int n ) {			    bool checkIsAP ( int arr [ ] , int n ) {			  success : identical to gold
  if ( n == 1 ) return true ;				      	if ( n == 1 ) return true ;				      if ( n == 1 ) return true ;				  
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  int d = arr [ 1 ] - arr [ 0 ] ;			      	int d = arr [ 1 ] - arr [ 0 ] ;				      int d = arr [ 1 ] - arr [ 0 ] ;				  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; 	i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ;   i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; 
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION		      DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION			    DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION			  DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION
--							      --							    --								  --
static boolean distributingBalls ( long k , long n , String s bool distributingBalls ( int k , int n , string str ) {	    bool distributingBalls ( long long k , long long n , string s script_not_found : None
  int [ ] a = new int [ MAX_CHAR ] ;			      	int a [ MAX_CHAR ] = {					      vector < int > a ( MAX_CHAR , 0 ) ;			  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < n ;						      	  ;							      i < n ;							  
  i ++ ) {						      	  for ( int i = 0 ;					      i ++ ) a [ str [ i ] - 'a' ] ++ ;				  
    a [ str . charAt ( i ) - 'a' ] ++ ;			      	  i < n ;						      for ( int i = 0 ;						  
  }							      	  i ++ ) {						      i < MAX_CHAR ;						  
  for ( int i = 0 ;					      	    a [ str [ i ] - 'a' ] ++ ;				      i ++ ) if ( a [ i ] > k ) return false ;			  
  i < MAX_CHAR ;					      	  }							      return true ;						  
  i ++ ) if ( a [ i ] > k ) return false ;		      	  for ( int i = 0 ;					    }								  
  return true ;						      	  i < MAX_CHAR ;					    								  
}							      	  i ++ ) if ( a [ i ] > k ) return false ;		    								  
							      	  return true ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE
--							      --							    --								  --
static int search ( int arr [ ] , int n , int x ) {	      int search ( int arr [ ] , int n , int x ) {		    int search ( int arr [ ] , int n , int x ) {		  success : None
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  while ( i < n ) {					      	while ( i < n ) {					      while ( i < n ) {						  
    if ( arr [ i ] == x ) return i ;			      	  if ( arr [ i ] == x ) return i ;			    	if ( arr [ i ] == x ) return i ;			  
    i = i + Math . abs ( arr [ i ] - x ) ;		      	  i = i + abs ( arr [ i ] - x ) ;			    	i = i + abs ( arr [ i ] - x ) ;				  
  }							      	}							      }								  
  System . out . println ( "number is not" + " present!" ) ;  	cout << "number is not present!" ;			      cout << "number is not" << " present!" << endl ;		  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCHING_ARRAY_ADJACENT_DIFFER_K			      SEARCHING_ARRAY_ADJACENT_DIFFER_K				    SEARCHING_ARRAY_ADJACENT_DIFFER_K				  SEARCHING_ARRAY_ADJACENT_DIFFER_K
--							      --							    --								  --
static int search ( int arr [ ] , int n , int x , int k ) {   int search ( int arr [ ] , int n , int x , int k ) {	    int search ( int arr [ ] , int n , int x , int k ) {	  success : None
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  while ( i < n ) {					      	while ( i < n ) {					      while ( i < n ) {						  
    if ( arr [ i ] == x ) return i ;			      	  if ( arr [ i ] == x ) return i ;			    	if ( arr [ i ] == x ) return i ;			  
    i = i + Math . max ( 1 , Math . abs ( arr [ i ] - x ) / k 	  i = i + max ( 1 , abs ( arr [ i ] - x ) / k ) ;	    	i = i + max ( 1 , abs ( arr [ i ] - x ) / k ) ;		  
  }							      	}							      }								  
  System . out . println ( "number is " + "not present!" ) ;  	cout << "number is not present!" ;			      cout << "number is " << "not present!" << endl ;		  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SERIES_23_45_67_89_UPTO_N_TERMS			      SUM_SERIES_23_45_67_89_UPTO_N_TERMS			    SUM_SERIES_23_45_67_89_UPTO_N_TERMS				  SUM_SERIES_23_45_67_89_UPTO_N_TERMS
--							      --							    --								  --
static double seriesSum ( int n ) {			      double seriesSum ( int n ) {				    double seriesSum ( int n ) {				  success : identical to gold
  int i = 1 ;						      	int i = 1 ;						      int i = 1 ;						  
  double res = 0.0 ;					      	double res = 0.0 ;					      double res = 0.0 ;					  
  boolean sign = true ;					      	bool sign = true ;					      bool sign = true ;					  
  while ( n > 0 ) {					      	while ( n > 0 ) {					      while ( n > 0 ) {						  
    n -- ;						      	  n -- ;						    	n -- ;							  
    if ( sign ) {					      	  if ( sign ) {						    	if ( sign ) {						  
      sign = ! sign ;					      	    sign = ! sign ;					    	  sign = ! sign ;					  
      res = res + ( double ) ++ i / ++ i ;		      	    res = res + ( double ) ++ i / ++ i ;		    	  res = res + ( double ) ++ i / ++ i ;			  
    }							      	  }							    	}							  
    else {						      	  else {						    	else {							  
      sign = ! sign ;					      	    sign = ! sign ;					    	  sign = ! sign ;					  
      res = res - ( double ) ++ i / ++ i ;		      	    res = res - ( double ) ++ i / ++ i ;		    	  res = res - ( double ) ++ i / ++ i ;			  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			      FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			    FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			  FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM
--							      --							    --								  --
static int maxLen ( int arr [ ] , int n ) {		      int maxLen ( int arr [ ] , int n ) {			    int maxLen ( int arr [ ] , int n ) {			  success : None
  int max_len = 0 ;					      	int max_len = 0 ;					      int maxLen = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int curr_sum = 0 ;					      	  int curr_sum = 0 ;					    	int currSum = 0 ;					  
    for ( int j = i ;					      	  for ( int j = i ;					    	for ( int j = i ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      curr_sum += arr [ j ] ;				      	    curr_sum += arr [ j ] ;				    	  currSum += arr [ j ] ;				  
      if ( curr_sum == 0 ) max_len = Math . max ( max_len , j 	    if ( curr_sum == 0 ) max_len = max ( max_len , j - i +  	  if ( currSum == 0 ) {					  
    }							      	  }							    	    maxLen = max ( maxLen , j - i + 1 ) ;		  
  }							      	}							    	  }							  
  return max_len ;					      	return max_len ;					    	}							  
}							      }								      }								  
							      								      return maxLen ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			      FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			    FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			  FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2
--							      --							    --								  --
static int singleNumber ( int a [ ] , int n ) {		      int singleNumber ( int a [ ] , int n ) {			    int singleNumber ( int a [ ] , int n ) {			  error : FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2.cpp:
  HashSet < Integer > s = new HashSet < Integer > ( ) ;	      	unordered_set < int > s ( a , a + n ) ;			      set < int > s ;						  In function ‘int f_filled(int*, int)’: FIND_THE_EL
  for ( int i : a ) {					      	int arr_sum = accumulate ( a , a + n , 0 ) ;		      for ( int i : a ) s . insert ( i ) ;			  EMENT_THAT_APPEARS_ONCE_2.cpp:26:17: error: ‘begin
    s . add ( i ) ;					      	int set_sum = accumulate ( s . begin ( ) , s . end ( ) , 0    int arr_sum = 0 ;						  ’ was not declared in this scope    for ( int i :
  }							      	return ( 3 * set_sum - arr_sum ) / 2 ;			      for ( int i : a ) arr_sum += i ;				  a ) s . insert ( i ) ;		  ^ FIND_THE
  int arr_sum = 0 ;					      }								      int set_sum = 0 ;						  _ELEMENT_THAT_APPEARS_ONCE_2.cpp:26:17: note: sugg
  for ( int i : a ) {					      								      for ( set < int > :: iterator i = s . begin ( ) ;		  ested alternative: In file included from /usr/incl
    arr_sum += i ;					      								      i != s . end ( ) ;					  ude/c++/8/x86_64-redhat-linux/bits/stdc++.h:95,
  }							      								      i ++ ) set_sum += * i ;					  		 from FIND_THE_ELEMENT_THAT_APPEARS_
  int set_sum = 0 ;					      								      return ( 3 * set_sum - arr_sum ) / 2 ;			  ONCE_2.cpp:14: /usr/include/c++/8/valarray:1211:5:
  for ( int i : s ) {					      								    }								   note:   ‘std::begin’	     begin(const valarray<_T
    set_sum += i ;					      								    								  p>& __va)	 ^~~~~ FIND_THE_ELEMENT_THAT_APPEARS
  }							      								    								  _ONCE_2.cpp:26:17: error: ‘end’ was not declared i
  return ( 3 * set_sum - arr_sum ) / 2 ;		      								    								  n this scope	  for ( int i : a ) s . insert ( i )
}							      								    								   ;		      ^ FIND_THE_ELEMENT_THAT_APPEAR
							      								    								  S_ONCE_2.cpp:26:17: note: suggested alternative: I
							      								    								  n file included from /usr/include/c++/8/x86_64-red
							      								    								  hat-linux/bits/stdc++.h:95,		       from
							      								    								  FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2.cpp:14: /usr/
							      								    								  include/c++/8/valarray:1231:5: note:	 ‘std::end’
							      								    								       end(const valarray<_Tp>& __va)	   ^~~ FIND_
							      								    								  THE_ELEMENT_THAT_APPEARS_ONCE_2.cpp:28:17: error:
							      								    								  ‘begin’ was not declared in this scope    for ( in
							      								    								  t i : a ) arr_sum += i ;		    ^ FIND_T
							      								    								  HE_ELEMENT_THAT_APPEARS_ONCE_2.cpp:28:17: note: su
							      								    								  ggested alternative: In file included from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  		   from FIND_THE_ELEMENT_THAT_APPEAR
							      								    								  S_ONCE_2.cpp:14: /usr/include/c++/8/valarray:1211:
							      								    								  5: note:   ‘std::begin’      begin(const valarray<
							      								    								  _Tp>& __va)	   ^~~~~ FIND_THE_ELEMENT_THAT_APPEA
							      								    								  RS_ONCE_2.cpp:28:17: error: ‘end’ was not declared
							      								    								   in this scope    for ( int i : a ) arr_sum += i ;
							      								    								  		    ^ FIND_THE_ELEMENT_THAT_APPEARS_
							      								    								  ONCE_2.cpp:28:17: note: suggested alternative: In
							      								    								  file included from /usr/include/c++/8/x86_64-redha
							      								    								  t-linux/bits/stdc++.h:95,		     from FI
							      								    								  ND_THE_ELEMENT_THAT_APPEARS_ONCE_2.cpp:14: /usr/in
							      								    								  clude/c++/8/valarray:1231:5: note:   ‘std::end’
							      								    								     end(const valarray<_Tp>& __va)	 ^~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BINARY_SEARCH						      BINARY_SEARCH						    BINARY_SEARCH						  BINARY_SEARCH
--							      --							    --								  --
int binarySearch ( int arr [ ] , int l , int r , int x ) {    int binarySearch ( int arr [ ] , int l , int r , int x ) {    int binarySearch ( int arr [ ] , int l , int r , int x ) {	  success : identical to gold
  if ( r >= l ) {					      	if ( r >= l ) {						      if ( r >= l ) {						  
    int mid = l + ( r - l ) / 2 ;			      	  int mid = l + ( r - l ) / 2 ;				    	int mid = l + ( r - l ) / 2 ;				  
    if ( arr [ mid ] == x ) return mid ;		      	  if ( arr [ mid ] == x ) return mid ;			    	if ( arr [ mid ] == x ) return mid ;			  
    if ( arr [ mid ] > x ) return binarySearch ( arr , l , mi 	  if ( arr [ mid ] > x ) return binarySearch ( arr , l , mi 	if ( arr [ mid ] > x ) return binarySearch ( arr , l , mi 
    return binarySearch ( arr , mid + 1 , r , x ) ;	      	  return binarySearch ( arr , mid + 1 , r , x ) ;	    	return binarySearch ( arr , mid + 1 , r , x ) ;		  
  }							      	}							      }								  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B		      FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B		    FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B		  FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B
--							      --							    --								  --
static int computeLastDigit ( long A , long B ) {	      int computeLastDigit ( long long int A , long long int B ) {  int computeLastDigit ( long A , long B ) {			  success : None
  int variable = 1 ;					      	int variable = 1 ;					      int variable = 1 ;					  
  if ( A == B ) return 1 ;				      	if ( A == B ) return 1 ;				      if ( A == B ) return 1 ;					  
  else if ( ( B - A ) >= 5 ) return 0 ;			      	else if ( ( B - A ) >= 5 ) return 0 ;			      else if ( ( B - A ) >= 5 ) return 0 ;			  
  else {						      	else {							      else {							  
    for ( long i = A + 1 ;				      	  for ( long long int i = A + 1 ;			    	for ( long i = A + 1 ;					  
    i <= B ;						      	  i <= B ;						    	i <= B ;						  
    i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10  	  i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ;	    	i ++ ) {						  
    return variable % 10 ;				      	  return variable % 10 ;				    	  variable = ( int ) ( variable * ( i % 10 ) ) % 10 ;	  
  }							      	}							    	}							  
}							      }								    	return variable % 10 ;					  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		      FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		    FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		  FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES
--							      --							    --								  --
static int getOddOccurrence ( int arr [ ] , int arr_size ) {  int getOddOccurrence ( int arr [ ] , int arr_size ) {	    int getOddOccurrence ( int arr [ ] , int arr_size ) {	  success : None
  int i ;						      	for ( int i = 0 ;					      int i ;							  
  for ( i = 0 ;						      	i < arr_size ;						      for ( i = 0 ;						  
  i < arr_size ;					      	i ++ ) {						      i < arr_size ;						  
  i ++ ) {						      	  int count = 0 ;					      i ++ ) {							  
    int count = 0 ;					      	  for ( int j = 0 ;					    	int count = 0 ;						  
    for ( int j = 0 ;					      	  j < arr_size ;					    	for ( int j = 0 ;					  
    j < arr_size ;					      	  j ++ ) {						    	j < arr_size ;						  
    j ++ ) {						      	    if ( arr [ i ] == arr [ j ] ) count ++ ;		    	j ++ ) {						  
      if ( arr [ i ] == arr [ j ] ) count ++ ;		      	  }							    	  if ( arr [ i ] == arr [ j ] ) {			  
    }							      	  if ( count % 2 != 0 ) return arr [ i ] ;		    	    count ++ ;						  
    if ( count % 2 != 0 ) return arr [ i ] ;		      	}							    	  }							  
  }							      	return - 1 ;						    	}							  
  return - 1 ;						      }								    	if ( count % 2 != 0 ) {					  
}							      								    	  return arr [ i ] ;					  
							      								    	}							  
							      								      }								  
							      								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIRROR_CHARACTERS_STRING				      MIRROR_CHARACTERS_STRING					    MIRROR_CHARACTERS_STRING					  MIRROR_CHARACTERS_STRING
--							      --							    --								  --
static String compute ( String str , int n ) {		      string compute ( string str , int n ) {			    string compute ( string str , int n ) {			  error : /bin/bash: line 1: 3925745 Aborted
  String reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ;     	string reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ;	      string reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ;	  	   (core dumped) ./MIRROR_CHARACTERS_STRING_
  int l = str . length ( ) ;				      	int l = str . length ( ) ;				      int l = str . length ( ) ;				  cpp
  String answer = "" ;					      	for ( int i = n ;					      string answer ;						  
  for ( int i = 0 ;					      	i < l ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) str [ i ] = reverseAlphabet [ str [ i ] - 'a' ] ;      i < n ;							  
  i ++ ) answer = answer + str . charAt ( i ) ;		      	return str ;						      i ++ ) {							  
  for ( int i = n ;					      }								    	answer = answer + str [ i ] ;				  
  i < l ;						      								      }								  
  i ++ ) answer = answer + reverseAlphabet . charAt ( str . c 								      for ( int i = n ;						  
  return answer ;					      								      i < l ;							  
}							      								      i ++ ) {							  
							      								    	answer = answer + reverseAlphabet [ str [ i ] - 'a' ] ;	  
							      								      }								  
							      								      return answer ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			      SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			    SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			  SUM_MANHATTAN_DISTANCES_PAIRS_POINTS
--							      --							    --								  --
static int distancesum ( int x [ ] , int y [ ] , int n ) {    int distancesum ( int x [ ] , int y [ ] , int n ) {	    int distancesum ( int x [ ] , int y [ ] , int n ) {		  success : identical to gold
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . a 	j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] -   j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - 
  return sum ;						      	return sum ;						      return sum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT
--							      --							    --								  --
static boolean check ( String str ) {			      bool check ( string str ) {				    bool check ( string str ) {					  success : identical to gold
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  if ( n == 0 ) return false ;				      	if ( n == 0 ) return false ;				      if ( n == 0 ) return false ;				  
  if ( n == 1 ) return ( ( str . charAt ( 0 ) - '0' ) % 4 ==  	if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 4 == 0 ) ;	      if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 4 == 0 ) ;	  
  int last = str . charAt ( n - 1 ) - '0' ;		      	int last = str [ n - 1 ] - '0' ;			      int last = str [ n - 1 ] - '0' ;				  
  int second_last = str . charAt ( n - 2 ) - '0' ;	      	int second_last = str [ n - 2 ] - '0' ;			      int second_last = str [ n - 2 ] - '0' ;			  
  return ( ( second_last * 10 + last ) % 4 == 0 ) ;	      	return ( ( second_last * 10 + last ) % 4 == 0 ) ;	      return ( ( second_last * 10 + last ) % 4 == 0 ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			      CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			    CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			  CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT
--							      --							    --								  --
public static boolean areEqual ( int arr1 [ ] , int arr2 [ ]  bool areEqual ( int arr1 [ ] , int arr2 [ ] , int n , int m ) bool areEqual ( int arr1 [ ] , int arr2 [ ] ) {		  script_not_found : None
  int n = arr1 . length ;				      	if ( n != m ) return false ;				      int n = sizeof ( arr1 ) / sizeof ( int ) ;		  
  int m = arr2 . length ;				      	sort ( arr1 , arr1 + n ) ;				      int m = sizeof ( arr2 ) / sizeof ( int ) ;		  
  if ( n != m ) return false ;				      	sort ( arr2 , arr2 + m ) ;				      if ( n != m ) return false ;				  
  Arrays . sort ( arr1 ) ;				      	for ( int i = 0 ;					      sort ( arr1 , arr1 + n ) ;				  
  Arrays . sort ( arr2 ) ;				      	i < n ;							      sort ( arr2 , arr2 + m ) ;				  
  for ( int i = 0 ;					      	i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ;	      for ( int i = 0 ;						  
  i < n ;						      	return true ;						      i < n ;							  
  i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ;	      }								      i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ;	  
  return true ;						      								      return true ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		      FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		    FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		  FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY
--							      --							    --								  --
static int maxSubarrayXOR ( int arr [ ] , int n ) {	      int maxSubarrayXOR ( int arr [ ] , int n ) {		    int maxSubarrayXOR ( int arr [ ] , int n ) {		  success : None
  int ans = Integer . MIN_VALUE ;			      	int ans = INT_MIN ;					      int ans = INT_MIN ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int curr_xor = 0 ;					      	  int curr_xor = 0 ;					    	int currXor = 0 ;					  
    for ( int j = i ;					      	  for ( int j = i ;					    	for ( int j = i ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      curr_xor = curr_xor ^ arr [ j ] ;			      	    curr_xor = curr_xor ^ arr [ j ] ;			    	  currXor = currXor ^ arr [ j ] ;			  
      ans = Math . max ( ans , curr_xor ) ;		      	    ans = max ( ans , curr_xor ) ;			    	  ans = max ( ans , currXor ) ;				  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return ans ;						      	return ans ;						      return ans ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	      FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	    FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	  FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE
--							      --							    --								  --
static int minRadius ( int k , int [ ] x , int [ ] y , int n  int minRadius ( int k , int x [ ] , int y [ ] , int n ) {	    int minRadius ( int k , int * x , int * y , int n ) {	  success : None
  int [ ] dis = new int [ n ] ;				      	int dis [ n ] ;						      int dis [ n ] ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ;  	i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ;    i ++ ) {							  
  Arrays . sort ( dis ) ;				      	sort ( dis , dis + n ) ;				    	dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ;	  
  return dis [ k - 1 ] ;				      	return dis [ k - 1 ] ;					      }								  
}							      }								      std :: sort ( dis , dis + n ) ;				  
							      								      return dis [ k - 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1	      PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1	    PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1	  PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1
--							      --							    --								  --
static boolean isPrime ( int n ) {			      bool isPrime ( int n ) {					    bool isPrime ( int n ) {					  success : identical to gold
  if ( n <= 1 ) return false ;				      	if ( n <= 1 ) return false ;				      if ( n <= 1 ) return false ;				  
  if ( n <= 3 ) return true ;				      	if ( n <= 3 ) return true ;				      if ( n <= 3 ) return true ;				  
  if ( n % 2 == 0 || n % 3 == 0 ) return false ;	      	if ( n % 2 == 0 || n % 3 == 0 ) return false ;		      if ( n % 2 == 0 || n % 3 == 0 ) return false ;		  
  for ( int i = 5 ;					      	for ( int i = 5 ;					      for ( int i = 5 ;						  
  i * i <= n ;						      	i * i <= n ;						      i * i <= n ;						  
  i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return  	i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return    i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return  
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND	      GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND	    GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND	  GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND
--							      --							    --								  --
static boolean isSubSequence ( String str1 , String str2 , in bool isSubSequence ( char str1 [ ] , char str2 [ ] , int m ,  bool isSubSequence ( string str1 , string str2 , int m , int  success : None
  if ( m == 0 ) return true ;				      	if ( m == 0 ) return true ;				      if ( m == 0 ) return true ;				  
  if ( n == 0 ) return false ;				      	if ( n == 0 ) return false ;				      if ( n == 0 ) return false ;				  
  if ( str1 . charAt ( m - 1 ) == str2 . charAt ( n - 1 ) ) r 	if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequenc   if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequenc 
  return isSubSequence ( str1 , str2 , m , n - 1 ) ;	      	return isSubSequence ( str1 , str2 , m , n - 1 ) ;	      return isSubSequence ( str1 , str2 , m , n - 1 ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_NEXT_STRING				      LEXICOGRAPHICALLY_NEXT_STRING				    LEXICOGRAPHICALLY_NEXT_STRING				  LEXICOGRAPHICALLY_NEXT_STRING
--							      --							    --								  --
public static String nextWord ( String str ) {		      string nextWord ( string s ) {				    string nextWord ( string str ) {				  success : None
  if ( str == "" ) return "a" ;				      	if ( s == "" ) return "a" ;				      if ( str . empty ( ) ) return "a" ;			  
  int i = str . length ( ) - 1 ;			      	int i = s . length ( ) - 1 ;				      int i = str . length ( ) - 1 ;				  
  while ( str . charAt ( i ) == 'z' && i >= 0 ) i -- ;	      	while ( s [ i ] == 'z' && i >= 0 ) i -- ;		      while ( str [ i ] == 'z' && i >= 0 ) i -- ;		  
  if ( i == - 1 ) str = str + 'a' ;			      	if ( i == - 1 ) s = s + 'a' ;				      if ( i == - 1 ) str = str + 'a' ;				  
  else str = str . substring ( 0 , i ) + ( char ) ( ( int ) ( 	else s [ i ] ++ ;					      else str = str . substr ( 0 , i ) + char ( ( int ) ( str [  
  return str ;						      	return s ;						      return str ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_CONSECUTIVE_DUPLICATES_STRING			      REMOVE_CONSECUTIVE_DUPLICATES_STRING			    REMOVE_CONSECUTIVE_DUPLICATES_STRING			  REMOVE_CONSECUTIVE_DUPLICATES_STRING
--							      --							    --								  --
static void removeDuplicates ( char [ ] S ) {		      void removeDuplicates ( char S [ ] ) {			    void removeDuplicates ( string S ) {			  script_not_found : None
  int n = S . length ;					      	int n = strlen ( S ) ;					      int n = S . length ( ) ;					  
  if ( n < 2 ) {					      	if ( n < 2 ) return ;					      if ( n < 2 ) return ;					  
    return ;						      	int j = 0 ;						      int j = 0 ;						  
  }							      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  int j = 0 ;						      	i < n ;							      i < n ;							  
  for ( int i = 1 ;					      	i ++ ) {						      i ++ ) {							  
  i < n ;						      	  if ( S [ j ] != S [ i ] ) {				    	if ( S [ j ] != S [ i ] ) {				  
  i ++ ) {						      	    j ++ ;						    	  j ++ ;						  
    if ( S [ j ] != S [ i ] ) {				      	    S [ j ] = S [ i ] ;					    	  S [ j ] = S [ i ] ;					  
      j ++ ;						      	  }							    	}							  
      S [ j ] = S [ i ] ;				      	}							      }								  
    }							      	j ++ ;							      cout << string ( S . begin ( ) , S . end ( ) ) << endl ;	  
  }							      	S [ j ] = '\0' ;					    }								  
  System . out . println ( Arrays . copyOfRange ( S , 0 , j + }								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES		      AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES		    AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES		  AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES
--							      --							    --								  --
public static double polygonArea ( double X [ ] , double Y [  double polygonArea ( double X [ ] , double Y [ ] , int n ) {  double polygon_area ( double X [ ] , double Y [ ] , int n ) { script_not_found : None
  double area = 0.0 ;					      	double area = 0.0 ;					      double area = 0.0 ;					  
  int j = n - 1 ;					      	int j = n - 1 ;						      int j = n - 1 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;   	  area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;   	area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;	  
    j = i ;						      	  j = i ;						    	j = i ;							  
  }							      	}							      }								  
  return Math . abs ( area / 2.0 ) ;			      	return abs ( area / 2.0 ) ;				      return fabs ( area / 2.0 ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT			      CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT			    CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT			  CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT
--							      --							    --								  --
public static boolean isAnBn ( String s ) {		      bool isAnBn ( string str ) {				    bool isAnBn ( string s ) {					  success : None
  int l = s . length ( ) ;				      	int n = str . length ( ) ;				      int l = s . length ( ) ;					  
  if ( l % 2 == 1 ) {					      	int i ;							      if ( l % 2 == 1 ) return false ;				  
    return false ;					      	for ( i = 0 ;						      int i = 0 ;						  
  }							      	i < n ;							      int j = l - 1 ;						  
  int i = 0 ;						      	i ++ ) if ( str [ i ] != 'a' ) break ;			      while ( i < j ) {						  
  int j = l - 1 ;					      	if ( i * 2 != n ) return false ;			    	if ( s [ i ] != 'a' || s [ j ] != 'b' ) return false ;	  
  while ( i < j ) {					      	int j ;							    	i ++ ;							  
    if ( s . charAt ( i ) != 'a' || s . charAt ( j ) != 'b' ) 	for ( j = i ;						    	j -- ;							  
      return false ;					      	j < n ;							      }								  
    }							      	j ++ ) if ( str [ j ] != 'b' ) return false ;		      return true ;						  
    i ++ ;						      	return true ;						    }								  
    j -- ;						      }								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EQUILIBRIUM_INDEX_OF_AN_ARRAY_1				      EQUILIBRIUM_INDEX_OF_AN_ARRAY_1				    EQUILIBRIUM_INDEX_OF_AN_ARRAY_1				  EQUILIBRIUM_INDEX_OF_AN_ARRAY_1
--							      --							    --								  --
int equilibrium ( int arr [ ] , int n ) {		      int equilibrium ( int arr [ ] , int n ) {			    int equilibrium ( int arr [ ] , int n ) {			  success : None
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  int leftsum = 0 ;					      	int leftsum = 0 ;					      int leftsum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  ++ i ) sum += arr [ i ] ;				      	++ i ) sum += arr [ i ] ;				      ++ i ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	sum += arr [ i ] ;					  
  i < n ;						      	i < n ;							      }								  
  ++ i ) {						      	++ i ) {						      for ( int i = 0 ;						  
    sum -= arr [ i ] ;					      	  sum -= arr [ i ] ;					      i < n ;							  
    if ( leftsum == sum ) return i ;			      	  if ( leftsum == sum ) return i ;			      ++ i ) {							  
    leftsum += arr [ i ] ;				      	  leftsum += arr [ i ] ;				    	sum -= arr [ i ] ;					  
  }							      	}							    	if ( leftsum == sum ) return i ;			  
  return - 1 ;						      	return - 1 ;						    	leftsum += arr [ i ] ;					  
}							      }								      }								  
							      								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL	      MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL	    MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL		  MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL
--							      --							    --								  --
static int minOps ( int arr [ ] , int n , int k ) {	      int minOps ( int arr [ ] , int n , int k ) {		    int minOps ( int arr [ ] , int n , int k ) {		  success : None
  Arrays . sort ( arr ) ;				      	int max = * max_element ( arr , arr + n ) ;		      sort ( arr , arr + n ) ;					  
  int max = arr [ arr . length - 1 ] ;			      	int res = 0 ;						      int max = arr [ n - 1 ] ;					  
  int res = 0 ;						      	for ( int i = 0 ;					      int res = 0 ;						  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) {						      i < n ;							  
  i ++ ) {						      	  if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ;	      i ++ ) {							  
    if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ;	      	  else res += ( max - arr [ i ] ) / k ;			    	if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ;	  
    else res += ( max - arr [ i ] ) / k ;		      	}							    	else res += ( max - arr [ i ] ) / k ;			  
  }							      	return res ;						      }								  
  return res ;						      }								      return res ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1	      RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1	    RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1		  RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1
--							      --							    --								  --
static int breakSum ( int n ) {				      int breakSum ( int n ) {					    int breakSum ( int n ) {					  success : None
  int dp [ ] = new int [ n + 1 ] ;			      	int dp [ n + 1 ] ;					      int dp [ n + 1 ] ;					  
  dp [ 0 ] = 0 ;					      	dp [ 0 ] = 0 , dp [ 1 ] = 1 ;				      dp [ 0 ] = 0 ;						  
  dp [ 1 ] = 1 ;					      	for ( int i = 2 ;					      dp [ 1 ] = 1 ;						  
  for ( int i = 2 ;					      	i <= n ;						      for ( int i = 2 ;						  
  i <= n ;						      	i ++ ) dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [    i <= n ;							  
  i ++ ) dp [ i ] = Math . max ( dp [ i / 2 ] + dp [ i / 3 ]  	return dp [ n ] ;					      i ++ ) {							  
  return dp [ n ] ;					      }								    	dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 
}							      								      }								  
							      								      return dp [ n ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS		      MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS			    MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS			  MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS
--							      --							    --								  --
public static int subset ( int ar [ ] , int n ) {	      int subset ( int ar [ ] , int n ) {			    int subset ( int ar [ ] , int n ) {				  success : None
  int res = 0 ;						      	int res = 0 ;						      int res = 0 ;						  
  Arrays . sort ( ar ) ;				      	sort ( ar , ar + n ) ;					      sort ( ar , ar + n ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int count = 1 ;					      	  int count = 1 ;					    	int count = 1 ;						  
    for ( ;						      	  for ( ;						    	for ( ;							  
    i < n - 1 ;						      	  i < n - 1 ;						    	i < n - 1 ;						  
    i ++ ) {						      	  i ++ ) {						    	i ++ ) {						  
      if ( ar [ i ] == ar [ i + 1 ] ) count ++ ;	      	    if ( ar [ i ] == ar [ i + 1 ] ) count ++ ;		    	  if ( ar [ i ] == ar [ i + 1 ] ) {			  
      else break ;					      	    else break ;					    	    count ++ ;						  
    }							      	  }							    	  }							  
    res = Math . max ( res , count ) ;			      	  res = max ( res , count ) ;				    	  else {						  
  }							      	}							    	    break ;						  
  return res ;						      	return res ;						    	  }							  
}							      }								    	}							  
							      								    	res = max ( res , count ) ;				  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_WAVE_FORM_2_1				      SORT_ARRAY_WAVE_FORM_2_1					    SORT_ARRAY_WAVE_FORM_2_1					  SORT_ARRAY_WAVE_FORM_2_1
--							      --							    --								  --
void sortInWave ( int arr [ ] , int n ) {		      void sortInWave ( int arr [ ] , int n ) {			    void sortInWave ( int arr [ ] , int n ) {			  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i += 2 ) {						      	i += 2 ) {						      i += 2 ) {						  
    if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( arr , i  	  if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( & arr [  	if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) {		  
    if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( arr  	  if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( & ar 	  swap ( arr [ i - 1 ] , arr [ i ] ) ;			  
  }							      	}							    	}							  
}							      }								    	if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) {		  
							      								    	  swap ( arr [ i ] , arr [ i + 1 ] ) ;			  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_BITS_IN_A_GIVEN_NUMBER				      SWAP_BITS_IN_A_GIVEN_NUMBER				    SWAP_BITS_IN_A_GIVEN_NUMBER					  SWAP_BITS_IN_A_GIVEN_NUMBER
--							      --							    --								  --
static int swapBits ( int x , int p1 , int p2 , int n ) {     int swapBits ( unsigned int x , unsigned int p1 , unsigned in int swapBits ( int x , int p1 , int p2 , int n ) {		  error : SWAP_BITS_IN_A_GIVEN_NUMBER.cpp: In functi
  int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ;		      	unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ;	      int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ;		  on ‘int f_filled(int, int, int, int)’: SWAP_BITS_I
  int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ;		      	unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ;	      int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ;		  N_A_GIVEN_NUMBER.cpp:29:7: error: expected unquali
  int xor = ( set1 ^ set2 ) ;				      	unsigned int Xor = ( set1 ^ set2 ) ;			      int xor = ( set1 ^ set2 ) ;				  fied-id before ‘xor’ token	int xor = ( set1 ^ s
  xor = ( xor << p1 ) | ( xor << p2 ) ;			      	Xor = ( Xor << p1 ) | ( Xor << p2 ) ;			      xor = ( xor << p1 ) | ( xor << p2 ) ;			  et2 ) ;	 ^~~ SWAP_BITS_IN_A_GIVEN_NUMBER.cpp
  int result = x ^ xor ;				      	unsigned int result = x ^ Xor ;				      int result = x ^ xor ;					  :30:3: error: expected primary-expression before ‘
  return result ;					      	return result ;						      return result ;						  xor’ token	xor = ( xor << p1 ) | ( xor << p2 )
}							      }								    }								  ;    ^~~ SWAP_BITS_IN_A_GIVEN_NUMBER.cpp:30:7: err
							      								    								  or: expected primary-expression before ‘=’ token
							      								    								    xor = ( xor << p1 ) | ( xor << p2 ) ;	 ^ S
							      								    								  WAP_BITS_IN_A_GIVEN_NUMBER.cpp:30:11: error: expec
							      								    								  ted primary-expression before ‘xor’ token    xor =
							      								    								   ( xor << p1 ) | ( xor << p2 ) ;	      ^~~ SW
							      								    								  AP_BITS_IN_A_GIVEN_NUMBER.cpp:30:15: error: expect
							      								    								  ed primary-expression before ‘<<’ token    xor = (
							      								    								   xor << p1 ) | ( xor << p2 ) ;		^~ S
							      								    								  WAP_BITS_IN_A_GIVEN_NUMBER.cpp:30:27: error: expec
							      								    								  ted primary-expression before ‘xor’ token    xor =
							      								    								   ( xor << p1 ) | ( xor << p2 ) ;
							      								    								  	    ^~~ SWAP_BITS_IN_A_GIVEN_NUMBER.cpp:30:3
							      								    								  1: error: expected primary-expression before ‘<<’
							      								    								  token	   xor = ( xor << p1 ) | ( xor << p2 ) ;
							      								    								  			      ^~ SWAP_BITS_IN_A_GIVE
							      								    								  N_NUMBER.cpp:31:20: error: expected primary-expres
							      								    								  sion before ‘xor’ token    int result = x ^ xor ;
							      								    								  		      ^~~ SWAP_BITS_IN_A_GIVEN_NUMBE
							      								    								  R.cpp:31:24: error: expected primary-expression be
							      								    								  fore ‘;’ token    int result = x ^ xor ;
							      								    								  		 ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK			      MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK			    MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK			  MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK
--							      --							    --								  --
static int minRotation ( int input , int unlock_code ) {      int minRotation ( int input , int unlock_code ) {		    int minRotation ( int input , int unlock_code ) {		  success : None
  int rotation = 0 ;					      	int rotation = 0 ;					      int rotation = 0 ;					  
  int input_digit , code_digit ;			      	int input_digit , code_digit ;				      int input_digit , code_digit ;				  
  while ( input > 0 || unlock_code > 0 ) {		      	while ( input || unlock_code ) {			      while ( input > 0 || unlock_code > 0 ) {			  
    input_digit = input % 10 ;				      	  input_digit = input % 10 ;				    	input_digit = input % 10 ;				  
    code_digit = unlock_code % 10 ;			      	  code_digit = unlock_code % 10 ;			    	code_digit = unlock_code % 10 ;				  
    rotation += Math . min ( Math . abs ( input_digit - code_ 	  rotation += min ( abs ( input_digit - code_digit ) , 10 - 	rotation += min ( abs ( input_digit - code_digit ) , 10 - 
    input /= 10 ;					      	  input /= 10 ;						    	input /= 10 ;						  
    unlock_code /= 10 ;					      	  unlock_code /= 10 ;					    	unlock_code /= 10 ;					  
  }							      	}							      }								  
  return rotation ;					      	return rotation ;					      return rotation ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES		      PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES		    PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES			  PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES
--							      --							    --								  --
static void fib ( int n ) {				      void fib ( int n ) {					    void fib ( int n ) {					  script_not_found : None
  int a = 0 , b = 1 , c ;				      	int a = 0 , b = 1 , c ;					      int a = 0 , b = 1 , c ;					  
  if ( n >= 0 ) System . out . print ( a + " " ) ;	      	if ( n >= 0 ) cout << a << " " ;			      if ( n >= 0 ) {						  
  if ( n >= 1 ) System . out . print ( b + " " ) ;	      	if ( n >= 1 ) cout << b << " " ;			    	cout << a << " " ;					  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      }								  
  i <= n ;						      	i <= n ;						      if ( n >= 1 ) {						  
  i ++ ) {						      	i ++ ) {						    	cout << b << " " ;					  
    c = a + b ;						      	  c = a + b ;						      }								  
    System . out . print ( c + " " ) ;			      	  cout << c << " " ;					      for ( int i = 2 ;						  
    a = b ;						      	  a = b ;						      i <= n ;							  
    b = c ;						      	  b = c ;						      i ++ ) {							  
  }							      	}							    	c = a + b ;						  
}							      }								    	cout << c << " " ;					  
							      								    	a = b ;							  
							      								    	b = c ;							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EVEN_FIBONACCI_NUMBERS_SUM				      EVEN_FIBONACCI_NUMBERS_SUM				    EVEN_FIBONACCI_NUMBERS_SUM					  EVEN_FIBONACCI_NUMBERS_SUM
--							      --							    --								  --
static int evenFibSum ( int limit ) {			      int evenFibSum ( int limit ) {				    int evenFibSum ( int limit ) {				  success : None
  if ( limit < 2 ) return 0 ;				      	if ( limit < 2 ) return 0 ;				      if ( limit < 2 ) return 0 ;				  
  long ef1 = 0 , ef2 = 2 ;				      	long long int ef1 = 0 , ef2 = 2 ;			      long long ef1 = 0 , ef2 = 2 ;				  
  long sum = ef1 + ef2 ;				      	long long int sum = ef1 + ef2 ;				      long long sum = ef1 + ef2 ;				  
  while ( ef2 <= limit ) {				      	while ( ef2 <= limit ) {				      while ( ef2 <= limit ) {					  
    long ef3 = 4 * ef2 + ef1 ;				      	  long long int ef3 = 4 * ef2 + ef1 ;			    	long long ef3 = 4 * ef2 + ef1 ;				  
    if ( ef3 > limit ) break ;				      	  if ( ef3 > limit ) break ;				    	if ( ef3 > limit ) break ;				  
    ef1 = ef2 ;						      	  ef1 = ef2 ;						    	ef1 = ef2 ;						  
    ef2 = ef3 ;						      	  ef2 = ef3 ;						    	ef2 = ef3 ;						  
    sum += ef2 ;					      	  sum += ef2 ;						    	sum += ef2 ;						  
  }							      	}							      }								  
  return ( int ) sum ;					      	return sum ;						      return ( int ) sum ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1		      PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1		    PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1		  PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1
--							      --							    --								  --
static void fib ( int n ) {				      void fib ( int n ) {					    void fib ( int n ) {					  script_not_found : None
  int a = 0 , b = 1 ;					      	int a = 0 , b = 1 ;					      int a = 0 , b = 1 ;					  
  if ( n >= 0 ) System . out . print ( a + " " ) ;	      	if ( n >= 0 ) cout << a << " " ;			      if ( n >= 0 ) {						  
  if ( n >= 1 ) System . out . print ( b + " " ) ;	      	if ( n >= 1 ) cout << b << " " ;			    	cout << a << " " ;					  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      }								  
  i <= n ;						      	i <= n ;						      if ( n >= 1 ) {						  
  i ++ ) {						      	i ++ ) {						    	cout << b << " " ;					  
    System . out . print ( a + b + " " ) ;		      	  cout << a + b << " " ;				      }								  
    b = a + b ;						      	  b = a + b ;						      for ( int i = 2 ;						  
    a = b - a ;						      	  a = b - a ;						      i <= n ;							  
  }							      	}							      i ++ ) {							  
}							      }								    	cout << a + b << " " ;					  
							      								    	b = a + b ;						  
							      								    	a = b - a ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LARGEST_PRIME_FACTOR_NUMBER			      FIND_LARGEST_PRIME_FACTOR_NUMBER				    FIND_LARGEST_PRIME_FACTOR_NUMBER				  FIND_LARGEST_PRIME_FACTOR_NUMBER
--							      --							    --								  --
static long maxPrimeFactors ( long n ) {		      long long maxPrimeFactors ( long long n ) {		    long long maxPrimeFactors ( long long n ) {			  success : None
  long maxPrime = - 1 ;					      	long long maxPrime = - 1 ;				      long long maxPrime = - 1 ;				  
  while ( n % 2 == 0 ) {				      	while ( n % 2 == 0 ) {					      while ( n % 2 == 0 ) {					  
    maxPrime = 2 ;					      	  maxPrime = 2 ;					    	maxPrime = 2 ;						  
    n >>= 1 ;						      	  n >>= 1 ;						    	n >>= 1 ;						  
  }							      	}							      }								  
  for ( int i = 3 ;					      	for ( int i = 3 ;					      for ( int i = 3 ;						  
  i <= Math . sqrt ( n ) ;				      	i <= sqrt ( n ) ;					      i <= sqrt ( n ) ;						  
  i += 2 ) {						      	i += 2 ) {						      i += 2 ) {						  
    while ( n % i == 0 ) {				      	  while ( n % i == 0 ) {				    	while ( n % i == 0 ) {					  
      maxPrime = i ;					      	    maxPrime = i ;					    	  maxPrime = i ;					  
      n = n / i ;					      	    n = n / i ;						    	  n = n / i ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  if ( n > 2 ) maxPrime = n ;				      	if ( n > 2 ) maxPrime = n ;				      if ( n > 2 ) {						  
  return maxPrime ;					      	return maxPrime ;					    	maxPrime = n ;						  
}							      }								      }								  
							      								      return maxPrime ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI
--							      --							    --								  --
static boolean isLucky ( int n ) {			      bool isLucky ( int n ) {					    bool isLucky ( int n ) {					  success : None
  boolean arr [ ] = new boolean [ 10 ] ;		      	bool arr [ 10 ] ;					      bool arr [ 10 ] ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < 10 ;						      	i < 10 ;						      i < 10 ;							  
  i ++ ) arr [ i ] = false ;				      	i ++ ) arr [ i ] = false ;				      i ++ ) {							  
  while ( n > 0 ) {					      	while ( n > 0 ) {					    	arr [ i ] = false ;					  
    int digit = n % 10 ;				      	  int digit = n % 10 ;					      }								  
    if ( arr [ digit ] ) return false ;			      	  if ( arr [ digit ] ) return false ;			      while ( n > 0 ) {						  
    arr [ digit ] = true ;				      	  arr [ digit ] = true ;				    	int digit = n % 10 ;					  
    n = n / 10 ;					      	  n = n / 10 ;						    	if ( arr [ digit ] ) return false ;			  
  }							      	}							    	arr [ digit ] = true ;					  
  return true ;						      	return true ;						    	n = n / 10 ;						  
}							      }								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SINK_NODES_GRAPH					      NUMBER_SINK_NODES_GRAPH					    NUMBER_SINK_NODES_GRAPH					  NUMBER_SINK_NODES_GRAPH
--							      --							    --								  --
static int countSink ( int n , int m , int edgeFrom [ ] , int int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo script_not_found : None
  int [ ] mark = new int [ n + 1 ] ;			      	int mark [ n ] ;					      int mark [ n + 1 ] ;					  
  for ( int i = 0 ;					      	memset ( mark , 0 , sizeof mark ) ;			      for ( int i = 0 ;						  
  i < m ;						      	for ( int i = 0 ;					      i < m ;							  
  i ++ ) mark [ edgeFrom [ i ] ] = 1 ;			      	i < m ;							      i ++ ) {							  
  int count = 0 ;					      	i ++ ) mark [ edgeFrom [ i ] ] = 1 ;			    	mark [ edgeFrom [ i ] ] = 1 ;				  
  for ( int i = 1 ;					      	int count = 0 ;						      }								  
  i <= n ;						      	for ( int i = 1 ;					      int count = 0 ;						  
  i ++ ) if ( mark [ i ] == 0 ) count ++ ;		      	i <= n ;						      for ( int i = 1 ;						  
  return count ;					      	i ++ ) if ( ! mark [ i ] ) count ++ ;			      i <= n ;							  
}							      	return count ;						      i ++ ) if ( mark [ i ] == 0 ) count ++ ;			  
							      }								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING	      CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING	    CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING	  CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING
--							      --							    --								  --
static int calcMaxValue ( String str ) {		      int calcMaxValue ( string str ) {				    int calcMaxValue ( string str ) {				  success : None
  int res = str . charAt ( 0 ) - '0' ;			      	int res = str [ 0 ] - '0' ;				      int res = str [ 0 ] - '0' ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < str . length ( ) ;				      	i < str . length ( ) ;					      i < str . length ( ) ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( str . charAt ( i ) == '0' || str . charAt ( i ) == ' 	  if ( str [ i ] == '0' || str [ i ] == '1' || res < 2 ) re 	if ( str [ i ] == '0' || str [ i ] == '1' || res < 2 ) {  
    else res *= ( str . charAt ( i ) - '0' ) ;		      	  else res *= ( str [ i ] - '0' ) ;			    	  res += ( str [ i ] - '0' ) ;				  
  }							      	}							    	}							  
  return res ;						      	return res ;						    	else {							  
}							      }								    	  res *= ( str [ i ] - '0' ) ;				  
							      								    	}							  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1      HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1	    HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1	  HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1
--							      --							    --								  --
static boolean isHeap ( int arr [ ] , int n ) {		      bool isHeap ( int arr [ ] , int n ) {			    bool isHeap ( int arr [ ] , int n ) {			  success : identical to gold
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= ( n - 2 ) / 2 ;					      	i <= ( n - 2 ) / 2 ;					      i <= ( n - 2 ) / 2 ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ 2 * i + 1 ] > arr [ i ] ) {		      	  if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ;	    	if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ;	  
      return false ;					      	  if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) ret 	if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) ret 
    }							      	}							      }								  
    if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) {   	return true ;						      return true ;						  
      return false ;					      }								    }								  
    }							      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X   COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X   COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X	  COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X
--							      --							    --								  --
static int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n  int countPairs ( int * arr1 , int * arr2 , int m , int n , in success : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m ;						      	i < m ;							      i < m ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ;   	j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ;     j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ;	  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PATTERNS_101_GIVEN_STRING				      FIND_PATTERNS_101_GIVEN_STRING				    FIND_PATTERNS_101_GIVEN_STRING				  FIND_PATTERNS_101_GIVEN_STRING
--							      --							    --								  --
static int patternCount ( String str ) {		      int patternCount ( string str ) {				    int patternCount ( string str ) {				  success : None
  char last = str . charAt ( 0 ) ;			      	char last = str [ 0 ] ;					      char last = str [ 0 ] ;					  
  int i = 1 , counter = 0 ;				      	int i = 1 , counter = 0 ;				      int i = 1 , counter = 0 ;					  
  while ( i < str . length ( ) ) {			      	while ( i < str . size ( ) ) {				      while ( i < str . length ( ) ) {				  
    if ( str . charAt ( i ) == '0' && last == '1' ) {	      	  if ( str [ i ] == '0' && last == '1' ) {		    	if ( str [ i ] == '0' && last == '1' ) {		  
      while ( str . charAt ( i ) == '0' ) i ++ ;	      	    while ( str [ i ] == '0' ) i ++ ;			    	  while ( str [ i ] == '0' ) {				  
      if ( str . charAt ( i ) == '1' ) counter ++ ;	      	    if ( str [ i ] == '1' ) counter ++ ;		    	    i ++ ;						  
    }							      	  }							    	  }							  
    last = str . charAt ( i ) ;				      	  last = str [ i ] ;					    	  if ( str [ i ] == '1' ) {				  
    i ++ ;						      	  i ++ ;						    	    counter ++ ;					  
  }							      	}							    	  }							  
  return counter ;					      	return counter ;					    	}							  
}							      }								    	last = str [ i ] ;					  
							      								    	i ++ ;							  
							      								      }								  
							      								      return counter ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1	      COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1	    COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1	  COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1
--							      --							    --								  --
static int countPairs ( String str ) {			      int countPairs ( string str ) {				    int countPairs ( string str ) {				  script_not_found : None
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = 1 ;				      	i ++ ) for ( int j = 1 ;				      i ++ ) for ( int j = 1 ;					  
  ( i + j ) < n && j <= MAX_CHAR ;			      	( i + j ) < n && j <= MAX_CHAR ;			      ( i + j ) < n && j <= MAX_CHAR ;				  
  j ++ ) if ( ( Math . abs ( str . charAt ( i + j ) - str . c 	j ++ ) if ( ( abs ( str [ i + j ] - str [ i ] ) == j ) ) re   j ++ ) if ( ( abs ( str [ i + j ] - str [ i ] ) == j ) ) re 
  return result ;					      	return result ;						      return result ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY		    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY
--							      --							    --								  --
void printRepeating ( int arr [ ] , int size ) {	      void printRepeating ( int arr [ ] , int size ) {		    void printRepeating ( int arr [ ] , int size ) {		  script_not_found : None
  int i , j ;						      	int i , j ;						      int i , j ;						  
  System . out . println ( "Repeated Elements are :" ) ;      	printf ( " Repeating elements are " ) ;			      cout << "Repeated Elements are :" << endl ;		  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < size ;						      	i < size ;						      i < size ;						  
  i ++ ) {						      	i ++ ) for ( j = i + 1 ;				      i ++ ) {							  
    for ( j = i + 1 ;					      	j < size ;						    	for ( j = i + 1 ;					  
    j < size ;						      	j ++ ) if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " 	j < size ;						  
    j ++ ) {						      }								    	j ++ ) {						  
      if ( arr [ i ] == arr [ j ] ) System . out . print ( ar 								    	  if ( arr [ i ] == arr [ j ] ) {			  
    }							      								    	    cout << arr [ i ] << " " ;				  
  }							      								    	  }							  
}							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1		      MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1		    MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1			  MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1
--							      --							    --								  --
static int subset ( int arr [ ] , int n ) {		      int subset ( int arr [ ] , int n ) {			    int subset ( int arr [ ] , int n ) {			  success : None
  HashMap < Integer , Integer > mp = new HashMap < > ( ) ;    	unordered_map < int , int > mp ;			      unordered_map < int , int > mp ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == nul 	i ++ ) mp [ arr [ i ] ] ++ ;				      i ++ ) {							  
  int res = 0 ;						      	int res = 0 ;						    	mp [ arr [ i ] ] = mp [ arr [ i ] ] == 0 ? 1 : mp [ arr [ 
  for ( Map . Entry < Integer , Integer > entry : mp . entryS 	for ( auto x : mp ) res = max ( res , x . second ) ;	      }								  
  return res ;						      	return res ;						      int res = 0 ;						  
}							      }								      for ( unordered_map < int , int > :: iterator it = mp . beg 
							      								      it != mp . end ( ) ;					  
							      								      it ++ ) {							  
							      								    	res = max ( res , it -> second ) ;			  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_GREATER_ELEMENT					      NEXT_GREATER_ELEMENT					    NEXT_GREATER_ELEMENT					  NEXT_GREATER_ELEMENT
--							      --							    --								  --
static void printNGE ( int arr [ ] , int n ) {		      void printNGE ( int arr [ ] , int n ) {			    void printNGE ( int arr [ ] , int n ) {			  script_not_found : None
  int next , i , j ;					      	int next , i , j ;					      int next , i , j ;					  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    next = - 1 ;					      	  next = - 1 ;						    	next = - 1 ;						  
    for ( j = i + 1 ;					      	  for ( j = i + 1 ;					    	for ( j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( arr [ i ] < arr [ j ] ) {			      	    if ( arr [ i ] < arr [ j ] ) {			    	  if ( arr [ i ] < arr [ j ] ) {			  
	next = arr [ j ] ;				      	      next = arr [ j ] ;				    	    next = arr [ j ] ;					  
	break ;						      	      break ;						    	    break ;						  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
    System . out . println ( arr [ i ] + " -- " + next ) ;    	  cout << arr [ i ] << " -- " << next << endl ;		    	cout << arr [ i ] << " -- " << next << endl ;		  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_BALANCED_BINARY_TREES_HEIGHT_H			      COUNT_BALANCED_BINARY_TREES_HEIGHT_H			    COUNT_BALANCED_BINARY_TREES_HEIGHT_H			  COUNT_BALANCED_BINARY_TREES_HEIGHT_H
--							      --							    --								  --
public static long countBT ( int h ) {			      long long int countBT ( int h ) {				    long long countBT ( int h ) {				  script_not_found : None
  long [ ] dp = new long [ h + 1 ] ;			      	long long int dp [ h + 1 ] ;				      long long dp [ h + 1 ] ;					  
  dp [ 0 ] = 1 ;					      	dp [ 0 ] = dp [ 1 ] = 1 ;				      dp [ 0 ] = 1 ;						  
  dp [ 1 ] = 1 ;					      	for ( int i = 2 ;					      dp [ 1 ] = 1 ;						  
  for ( int i = 2 ;					      	i <= h ;						      for ( int i = 2 ;						  
  i <= h ;						      	i ++ ) {						      i <= h ;							  
  ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % 	  dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod    ++ i ) {							  
  return dp [ h ] ;					      	}							    	dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD  
}							      	return dp [ h ] ;					      }								  
							      }								      return dp [ h ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_ARRAY_MAJORITY_ELEMENT				      CHECK_ARRAY_MAJORITY_ELEMENT				    CHECK_ARRAY_MAJORITY_ELEMENT				  CHECK_ARRAY_MAJORITY_ELEMENT
--							      --							    --								  --
static boolean isMajority ( int a [ ] , int n ) {	      bool isMajority ( int a [ ] , int n ) {			    bool isMajority ( int a [ ] , int n ) {			  success : None
  HashMap < Integer , Integer > mp = new HashMap < Integer ,  	unordered_map < int , int > mp ;			      unordered_map < int , int > mp ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( mp . containsKey ( a [ i ] ) ) mp . put ( a [ i 	i ++ ) mp [ a [ i ] ] ++ ;				      i ++ ) if ( mp . count ( a [ i ] ) ) mp [ a [ i ] ] = mp [  
  else mp . put ( a [ i ] , 1 ) ;			      	for ( auto x : mp ) if ( x . second >= n / 2 ) return true    else mp [ a [ i ] ] = 1 ;					  
  for ( Map . Entry < Integer , Integer > x : mp . entrySet ( 	return false ;						      for ( unordered_map < int , int > :: iterator x = mp . begi 
  return false ;					      }								      x != mp . end ( ) ;					  
}							      								      x ++ ) if ( x -> second >= n / 2 ) return true ;		  
							      								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N  MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N  MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N  MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N
--							      --							    --								  --
static int getMinSquares ( int n ) {			      int getMinSquares ( unsigned int n ) {			    int getMinSquares ( int n ) {				  script_not_found : None
  if ( n <= 3 ) return n ;				      	if ( sqrt ( n ) - floor ( sqrt ( n ) ) == 0 ) return 1 ;      if ( n <= 3 ) return n ;					  
  int res = n ;						      	if ( n <= 3 ) return n ;				      int res = n ;						  
  for ( int x = 1 ;					      	int res = n ;						      for ( int x = 1 ;						  
  x <= n ;						      	for ( int x = 1 ;					      x <= n ;							  
  x ++ ) {						      	x <= n ;						      x ++ ) {							  
    int temp = x * x ;					      	x ++ ) {						    	int temp = x * x ;					  
    if ( temp > n ) break ;				      	  int temp = x * x ;					    	if ( temp > n ) break ;					  
    else res = Math . min ( res , 1 + getMinSquares ( n - tem 	  if ( temp > n ) break ;				    	else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; 
  }							      	  else res = min ( res , 1 + getMinSquares ( n - temp ) ) ;   }								  
  return res ;						      	}							      return res ;						  
}							      	return res ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS    REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS    REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS	  REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS
--							      --							    --								  --
public static void psuedoBinary ( int n ) {		      void psuedoBinary ( int n ) {				    void psuedoBinary ( int n ) {				  script_not_found : None
  while ( n != 0 ) {					      	while ( n > 0 ) {					      while ( n != 0 ) {					  
    int temp = n , m = 0 , p = 1 ;			      	  int temp = n , m = 0 , p = 1 ;			    	int temp = n , m = 0 , p = 1 ;				  
    while ( temp != 0 ) {				      	  while ( temp ) {					    	while ( temp != 0 ) {					  
      int rem = temp % 10 ;				      	    int rem = temp % 10 ;				    	  int rem = temp % 10 ;					  
      temp = temp / 10 ;				      	    temp = temp / 10 ;					    	  temp = temp / 10 ;					  
      if ( rem != 0 ) m += p ;				      	    if ( rem != 0 ) m += p ;				    	  if ( rem != 0 ) {					  
      p *= 10 ;						      	    p *= 10 ;						    	    m += p ;						  
    }							      	  }							    	  }							  
    System . out . print ( m + " " ) ;			      	  cout << m << " " ;					    	  p *= 10 ;						  
    n = n - m ;						      	  n = n - m ;						    	}							  
  }							      	}							    	cout << m << " " ;					  
  System . out . println ( " " ) ;			      }								    	n = n - m ;						  
}							      								      }								  
							      								      cout << " " ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER
--							      --							    --								  --
static boolean flipsPossible ( int [ ] a , int n ) {	      bool flipsPossible ( int a [ ] , int n ) {		    bool flipsPossible ( int * a , int n ) {			  success : None
  int count_odd = 0 , count_even = 0 ;			      	int count_odd = 0 , count_even = 0 ;			      int count_odd = 0 , count_even = 0 ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( ( a [ i ] & 1 ) == 1 ) count_odd ++ ;		      	  if ( a [ i ] & 1 ) count_odd ++ ;			    	if ( ( a [ i ] & 1 ) == 1 ) {				  
    else count_even ++ ;				      	  else count_even ++ ;					    	  count_odd ++ ;					  
  }							      	}							    	}							  
  if ( count_odd % 2 == 1 && count_even % 2 == 1 ) return fal 	if ( count_odd % 2 && count_even % 2 ) return false ;	    	else {							  
  else return true ;					      	else return true ;					    	  count_even ++ ;					  
}							      }								    	}							  
							      								      }								  
							      								      if ( count_odd % 2 == 1 && count_even % 2 == 1 ) {	  
							      								    	return false ;						  
							      								      }								  
							      								      else {							  
							      								    	return true ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N			      COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N			    COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N			  COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N
--							      --							    --								  --
static int countOfBinaryNumberLessThanN ( int N ) {	      int countOfBinaryNumberLessThanN ( int N ) {		    int countOfBinaryNumberLessThanN ( int N ) {		  success : None
  Queue < Integer > q = new LinkedList < > ( ) ;	      	queue < int > q ;					      queue < int > q ;						  
  q . add ( 1 ) ;					      	q . push ( 1 ) ;					      q . push ( 1 ) ;						  
  int cnt = 0 ;						      	int cnt = 0 ;						      int cnt = 0 ;						  
  int t ;						      	int t ;							      int t ;							  
  while ( q . size ( ) > 0 ) {				      	while ( ! q . empty ( ) ) {				      while ( q . size ( ) > 0 ) {				  
    t = q . peek ( ) ;					      	  t = q . front ( ) ;					    	t = q . front ( ) ;					  
    q . remove ( ) ;					      	  q . pop ( ) ;						    	q . pop ( ) ;						  
    if ( t <= N ) {					      	  if ( t <= N ) {					    	if ( t <= N ) {						  
      cnt ++ ;						      	    cnt ++ ;						    	  cnt ++ ;						  
      q . add ( t * 10 ) ;				      	    q . push ( t * 10 ) ;				    	  q . push ( t * 10 ) ;					  
      q . add ( t * 10 + 1 ) ;				      	    q . push ( t * 10 + 1 ) ;				    	  q . push ( t * 10 + 1 ) ;				  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return cnt ;						      	return cnt ;						      return cnt ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE    CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE    CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE	  CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE
--							      --							    --								  --
static String printSequence ( String arr [ ] , String input ) string printSequence ( string arr [ ] , string input ) {	    string printSequence ( string arr [ ] , string input ) {	  script_not_found : None
  String output = "" ;					      	string output = "" ;					      string output ;						  
  int n = input . length ( ) ;				      	int n = input . length ( ) ;				      int n = input . length ( ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( input . charAt ( i ) == ' ' ) output = output + "0"  	  if ( input [ i ] == ' ' ) output = output + "0" ;	    	if ( input [ i ] == ' ' ) {				  
    else {						      	  else {						    	  output = output + "0" ;				  
      int position = input . charAt ( i ) - 'A' ;	      	    int position = input [ i ] - 'A' ;			    	}							  
      output = output + arr [ position ] ;		      	    output = output + arr [ position ] ;		    	else {							  
    }							      	  }							    	  int position = input [ i ] - 'A' ;			  
  }							      	}							    	  output = output + arr [ position ] ;			  
  return output ;					      	return output ;						    	}							  
}							      }								      }								  
							      								      return output ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY		      SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY		    SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY			  SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY
--							      --							    --								  --
static int binarySearch ( int arr [ ] , int low , int high ,  int binarySearch ( int arr [ ] , int low , int high , int key int binarySearch ( int arr [ ] , int low , int high , int key success : identical to gold
  if ( high < low ) return - 1 ;			      	if ( high < low ) return - 1 ;				      if ( high < low ) return - 1 ;				  
  int mid = ( low + high ) / 2 ;			      	int mid = ( low + high ) / 2 ;				      int mid = ( low + high ) / 2 ;				  
  if ( key == arr [ mid ] ) return mid ;		      	if ( key == arr [ mid ] ) return mid ;			      if ( key == arr [ mid ] ) return mid ;			  
  if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid  	if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid    if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid  
  return binarySearch ( arr , low , ( mid - 1 ) , key ) ;     	return binarySearch ( arr , low , ( mid - 1 ) , key ) ;	      return binarySearch ( arr , low , ( mid - 1 ) , key ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS		      POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS		    POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS		  POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS
--							      --							    --								  --
static void rearrange ( int a [ ] , int size ) {	      void rearrange ( int a [ ] , int size ) {			    void rearrange ( int a [ ] , int size ) {			  success : None
  int positive = 0 , negative = 1 , temp ;		      	int positive = 0 , negative = 1 ;			      int positive = 0 , negative = 1 , temp ;			  
  while ( true ) {					      	while ( true ) {					      while ( true ) {						  
    while ( positive < size && a [ positive ] >= 0 ) positive 	  while ( positive < size && a [ positive ] >= 0 ) positive 	while ( positive < size && a [ positive ] >= 0 ) {	  
    while ( negative < size && a [ negative ] <= 0 ) negative 	  while ( negative < size && a [ negative ] <= 0 ) negative 	  positive += 2 ;					  
    if ( positive < size && negative < size ) {		      	  if ( positive < size && negative < size ) swap ( a [ posi 	}							  
      temp = a [ positive ] ;				      	  else break ;						    	while ( negative < size && a [ negative ] <= 0 ) {	  
      a [ positive ] = a [ negative ] ;			      	}							    	  negative += 2 ;					  
      a [ negative ] = temp ;				      }								    	}							  
    }							      								    	if ( positive < size && negative < size ) {		  
    else break ;					      								    	  temp = a [ positive ] ;				  
  }							      								    	  a [ positive ] = a [ negative ] ;			  
}							      								    	  a [ negative ] = temp ;				  
							      								    	}							  
							      								    	else {							  
							      								    	  break ;						  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_THAT_APPEARS_ONCE			      FIND_THE_ELEMENT_THAT_APPEARS_ONCE			    FIND_THE_ELEMENT_THAT_APPEARS_ONCE				  FIND_THE_ELEMENT_THAT_APPEARS_ONCE
--							      --							    --								  --
static int getSingle ( int arr [ ] , int n ) {		      int getSingle ( int arr [ ] , int n ) {			    int getSingle ( int arr [ ] , int n ) {			  success : identical to gold
  int ones = 0 , twos = 0 ;				      	int ones = 0 , twos = 0 ;				      int ones = 0 , twos = 0 ;					  
  int common_bit_mask ;					      	int common_bit_mask ;					      int common_bit_mask ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    twos = twos | ( ones & arr [ i ] ) ;		      	  twos = twos | ( ones & arr [ i ] ) ;			    	twos = twos | ( ones & arr [ i ] ) ;			  
    ones = ones ^ arr [ i ] ;				      	  ones = ones ^ arr [ i ] ;				    	ones = ones ^ arr [ i ] ;				  
    common_bit_mask = ~ ( ones & twos ) ;		      	  common_bit_mask = ~ ( ones & twos ) ;			    	common_bit_mask = ~ ( ones & twos ) ;			  
    ones &= common_bit_mask ;				      	  ones &= common_bit_mask ;				    	ones &= common_bit_mask ;				  
    twos &= common_bit_mask ;				      	  twos &= common_bit_mask ;				    	twos &= common_bit_mask ;				  
  }							      	}							      }								  
  return ones ;						      	return ones ;						      return ones ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I
--							      --							    --								  --
static void squareRoot ( int n , int p ) {		      void squareRoot ( int n , int p ) {			    void squareRoot ( int n , int p ) {				  script_not_found : None
  n = n % p ;						      	n = n % p ;						      n = n % p ;						  
  for ( int x = 2 ;					      	for ( int x = 2 ;					      for ( int x = 2 ;						  
  x < p ;						      	x < p ;							      x < p ;							  
  x ++ ) {						      	x ++ ) {						      x ++ ) {							  
    if ( ( x * x ) % p == n ) {				      	  if ( ( x * x ) % p == n ) {				    	if ( ( x * x ) % p == n ) {				  
      System . out . println ( "Square " + "root is " + x ) ; 	    cout << "Square root is " << x ;			    	  cout << "Square " << "root is " << x << endl ;	  
      return ;						      	    return ;						    	  return ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  System . out . println ( "Square root " + "doesn't exist" ) 	cout << "Square root doesn't exist" ;			      cout << "Square root " << "doesn't exist" << endl ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_X_Y_SATISFYING_AX_N				      FIND_X_Y_SATISFYING_AX_N					    FIND_X_Y_SATISFYING_AX_N					  FIND_X_Y_SATISFYING_AX_N
--							      --							    --								  --
static void solution ( int a , int b , int n ) {	      void solution ( int a , int b , int n ) {			    void solution ( int a , int b , int n ) {			  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i * a <= n ;						      	i * a <= n ;						      i * a <= n ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( ( n - ( i * a ) ) % b == 0 ) {			      	  if ( ( n - ( i * a ) ) % b == 0 ) {			    	if ( ( n - ( i * a ) ) % b == 0 ) {			  
      System . out . println ( "x = " + i + ", y = " + ( n -  	    cout << "x = " << i << ", y = " << ( n - ( i * a ) ) /  	  cout << "x = " << i << ", y = " << ( n - ( i * a ) ) /  
      return ;						      	    return ;						    	  return ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  System . out . println ( "No solution" ) ;		      	cout << "No solution" ;					      cout << "No solution" << endl ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES		      ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES			    ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES			  ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES
--							      --							    --								  --
static int winner ( int a [ ] , int n , int k ) {	      int winner ( int a [ ] , int n , int k ) {		    int winner ( int a [ ] , int n , int k ) {			  success : None
  if ( k >= n - 1 ) return n ;				      	if ( k >= n - 1 ) return n ;				      if ( k >= n - 1 ) return n ;				  
  int best = 0 , times = 0 ;				      	int best = 0 , times = 0 ;				      int best = 0 , times = 0 ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( a [ i ] > best ) {				      	  if ( a [ i ] > best ) {				    	if ( a [ i ] > best ) {					  
      best = a [ i ] ;					      	    best = a [ i ] ;					    	  best = a [ i ] ;					  
      if ( i == 1 ) times = 1 ;				      	    if ( i ) times = 1 ;				    	  if ( i == 1 ) times = 1 ;				  
    }							      	  }							    	}							  
    else times += 1 ;					      	  else times += 1 ;					    	else times += 1 ;					  
    if ( times >= k ) return best ;			      	  if ( times >= k ) return best ;			    	if ( times >= k ) return best ;				  
  }							      	}							      }								  
  return best ;						      	return best ;						      return best ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING	      MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING		    MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING		  MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING
--							      --							    --								  --
static int maxDP ( int n ) {				      int maxDP ( int n ) {					    int maxDP ( int n ) {					  success : None
  int res [ ] = new int [ n + 1 ] ;			      	int res [ n + 1 ] ;					      int res [ n + 1 ] ;					  
  res [ 0 ] = 0 ;					      	res [ 0 ] = 0 ;						      res [ 0 ] = 0 ;						  
  res [ 1 ] = 1 ;					      	res [ 1 ] = 1 ;						      res [ 1 ] = 1 ;						  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) res [ i ] = Math . max ( i , ( res [ i / 2 ] + res [ 	i ++ ) res [ i ] = max ( i , ( res [ i / 2 ] + res [ i / 3    i ++ ) {							  
  return res [ n ] ;					      	return res [ n ] ;					    	res [ i ] = max ( i , ( res [ i / 2 ] + res [ i / 3 ] + r 
}							      }								      }								  
							      								      return res [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION    SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION    SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION	  SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION
--							      --							    --								  --
static void printSorted ( int a , int b , int c ) {	      void printSorted ( int a , int b , int c ) {		    void print_sorted ( int a , int b , int c ) {		  script_not_found : None
  int get_max = Math . max ( a , Math . max ( b , c ) ) ;     	int get_max = max ( a , max ( b , c ) ) ;		      int get_max = max ( a , max ( b , c ) ) ;			  
  int get_min = - Math . max ( - a , Math . max ( - b , - c ) 	int get_min = - max ( - a , max ( - b , - c ) ) ;	      int get_min = - max ( - a , max ( - b , - c ) ) ;		  
  int get_mid = ( a + b + c ) - ( get_max + get_min ) ;	      	int get_mid = ( a + b + c ) - ( get_max + get_min ) ;	      int get_mid = ( a + b + c ) - ( get_max + get_min ) ;	  
  System . out . print ( get_min + " " + get_mid + " " + get_ 	cout << get_min << " " << get_mid << " " << get_max ;	      cout << get_min << " " << get_mid << " " << get_max << endl 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE
--							      --							    --								  --
static void printSubsequences ( int n ) {		      void printSubsequences ( int arr [ ] , int n ) {		    void printSubsequences ( int n ) {				  script_not_found : None
  int opsize = ( int ) Math . pow ( 2 , n ) ;		      	unsigned int opsize = pow ( 2 , n ) ;			      int opsize = ( int ) pow ( 2 , n ) ;			  
  for ( int counter = 1 ;				      	for ( int counter = 1 ;					      for ( int counter = 1 ;					  
  counter < opsize ;					      	counter < opsize ;					      counter < opsize ;					  
  counter ++ ) {					      	counter ++ ) {						      counter ++ ) {						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( BigInteger . valueOf ( counter ) . testBit ( j ) ) 	    if ( counter & ( 1 << j ) ) cout << arr [ j ] << " " ;  	  if ( isdigit ( counter ) ) {				  
    }							      	  }							    	    cout << arr [ j ] << " " ;				  
    System . out . println ( ) ;			      	  cout << endl ;					    	  }							  
  }							      	}							    	}							  
}							      }								    	cout << endl ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP   GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP   GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP	  GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP
--							      --							    --								  --
static boolean isMinHeap ( int [ ] level ) {		      bool isMinHeap ( int level [ ] , int n ) {		    bool isMinHeap ( vector < int > level ) {			  script_not_found : None
  int n = level . length - 1 ;				      	for ( int i = ( n / 2 - 1 ) ;				      int n = level . size ( ) - 1 ;				  
  for ( int i = ( n / 2 - 1 ) ;				      	i >= 0 ;						      for ( int i = ( n / 2 - 1 ) ;				  
  i >= 0 ;						      	i -- ) {						      i >= 0 ;							  
  i -- ) {						      	  if ( level [ i ] > level [ 2 * i + 1 ] ) return false ;     i -- ) {							  
    if ( level [ i ] > level [ 2 * i + 1 ] ) return false ;   	  if ( 2 * i + 2 < n ) {				    	if ( level [ i ] > level [ 2 * i + 1 ] ) return false ;	  
    if ( 2 * i + 2 < n ) {				      	    if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; 	if ( 2 * i + 2 < n ) {					  
      if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; 	  }							    	  if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; 
    }							      	}							    	}							  
  }							      	return true ;						      }								  
  return true ;						      }								      return true ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT
--							      --							    --								  --
static boolean check ( String str ) {			      int check ( string str ) {				    bool check ( string str ) {					  success : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  int oddDigSum = 0 , evenDigSum = 0 ;			      	int oddDigSum = 0 , evenDigSum = 0 ;			      int oddDigSum = 0 , evenDigSum = 0 ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( i % 2 == 0 ) oddDigSum += ( str . charAt ( i ) - '0' 	  if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ) ;	    	if ( i % 2 == 0 ) {					  
    else evenDigSum += ( str . charAt ( i ) - '0' ) ;	      	  else evenDigSum += ( str [ i ] - '0' ) ;		    	  oddDigSum += ( str [ i ] - '0' ) ;			  
  }							      	}							    	}							  
  return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ;	      	return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ;	    	else {							  
}							      }								    	  evenDigSum += ( str [ i ] - '0' ) ;			  
							      								    	}							  
							      								      }								  
							      								      return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ;		  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED	      WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED	    WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED		  WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED
--							      --							    --								  --
static int countWays ( int N ) {			      int countWays ( int arr [ ] , int m , int N ) {		    int countWays ( int N ) {					  script_not_found : None
  int count [ ] = new int [ N + 1 ] ;			      	int count [ N + 1 ] ;					      int count [ N + 1 ] ;					  
  count [ 0 ] = 1 ;					      	memset ( count , 0 , sizeof ( count ) ) ;		      count [ 0 ] = 1 ;						  
  for ( int i = 1 ;					      	count [ 0 ] = 1 ;					      for ( int i = 1 ;						  
  i <= N ;						      	for ( int i = 1 ;					      i <= N ;							  
  i ++ ) for ( int j = 0 ;				      	i <= N ;						      i ++ ) for ( int j = 0 ;					  
  j < arr . length ;					      	i ++ ) for ( int j = 0 ;				      j < sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr 	j < m ;							      j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr 
  return count [ N ] ;					      	j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr   return count [ N ] ;					  
}							      	return count [ N ] ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_COMMON_SUBSEQUENCE				      LONGEST_COMMON_SUBSEQUENCE				    LONGEST_COMMON_SUBSEQUENCE					  LONGEST_COMMON_SUBSEQUENCE
--							      --							    --								  --
int lcs ( char [ ] X , char [ ] Y , int m , int n ) {	      int lcs ( char * X , char * Y , int m , int n ) {		    int lcs ( char * X , char * Y , int m , int n ) {		  script_not_found : None
  if ( m == 0 || n == 0 ) return 0 ;			      	if ( m == 0 || n == 0 ) return 0 ;			      if ( m == 0 || n == 0 ) return 0 ;			  
  if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y ,  	if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y ,    if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y ,  
  else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , 	else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y ,   else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT			      CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT			    CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT			  CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT
--							      --							    --								  --
static int circle ( int x1 , int y1 , int x2 , int y2 , int r int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int success : identical to gold
  int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 	int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1   int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 
  int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ;		      	int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ;		      int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ;		  
  if ( distSq == radSumSq ) return 1 ;			      	if ( distSq == radSumSq ) return 1 ;			      if ( distSq == radSumSq ) return 1 ;			  
  else if ( distSq > radSumSq ) return - 1 ;		      	else if ( distSq > radSumSq ) return - 1 ;		      else if ( distSq > radSumSq ) return - 1 ;		  
  else return 0 ;					      	else return 0 ;						      else return 0 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING
--							      --							    --								  --
static void twoWaySort ( int arr [ ] , int n ) {	      void twoWaySort ( int arr [ ] , int n ) {			    void twoWaySort ( int arr [ ] , int n ) {			  success : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;     	i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ;		      i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;	  
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;     	i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ;		      i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY		      FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY			    FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY			  FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY
--							      --							    --								  --
static int findGreatest ( int [ ] arr , int n ) {	      int findGreatest ( int arr [ ] , int n ) {		    int findGreatest ( int * arr , int n ) {			  success : None
  int result = - 1 ;					      	int result = - 1 ;					      int result = - 1 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < n - 1 ;						      	j < n - 1 ;						      j < n - 1 ;						  
  j ++ ) for ( int k = j + 1 ;				      	j ++ ) for ( int k = j + 1 ;				      j ++ ) for ( int k = j + 1 ;				  
  k < n ;						      	k < n ;							      k < n ;							  
  k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = M 	k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = m   k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = m 
  return result ;					      	return result ;						      return result ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1      SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1	    SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1	  SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1
--							      --							    --								  --
static int findSum ( int n ) {				      int findSum ( int n ) {					    int findSum ( int n ) {					  success : None
  int ans = 0 , temp = 0 , num ;			      	int ans = 0 , temp = 0 , num ;				      int ans = 0 , temp = 0 , num ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n && temp < n ;					      	i <= n && temp < n ;					      i <= n && temp < n ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    temp = i - 1 ;					      	  temp = i - 1 ;					    	temp = i - 1 ;						  
    num = 1 ;						      	  num = 1 ;						    	num = 1 ;						  
    while ( temp < n ) {				      	  while ( temp < n ) {					    	while ( temp < n ) {					  
      if ( temp + i <= n ) ans += ( i * num ) ;		      	    if ( temp + i <= n ) ans += ( i * num ) ;		    	  if ( temp + i <= n ) {				  
      else ans += ( ( n - temp ) * num ) ;		      	    else ans += ( ( n - temp ) * num ) ;		    	    ans += ( i * num ) ;				  
      temp += i ;					      	    temp += i ;						    	  }							  
      num ++ ;						      	    num ++ ;						    	  else {						  
    }							      	  }							    	    ans += ( ( n - temp ) * num ) ;			  
  }							      	}							    	  }							  
  return ans ;						      	return ans ;						    	  temp += i ;						  
}							      }								    	  num ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES
--							      --							    --								  --
static String firstLetterWord ( String str ) {		      string firstLetterWord ( string str ) {			    string firstLetterWord ( string str ) {			  success : None
  String result = "" ;					      	string result = "" ;					      string result ;						  
  boolean v = true ;					      	bool v = true ;						      bool v = true ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < str . length ( ) ;				      	i < str . length ( ) ;					      i < str . length ( ) ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( str . charAt ( i ) == ' ' ) {			      	  if ( str [ i ] == ' ' ) v = true ;			    	if ( str [ i ] == ' ' ) v = true ;			  
      v = true ;					      	  else if ( str [ i ] != ' ' && v == true ) {		    	else if ( str [ i ] != ' ' && v == true ) {		  
    }							      	    result . push_back ( str [ i ] ) ;			    	  result += ( str [ i ] ) ;				  
    else if ( str . charAt ( i ) != ' ' && v == true ) {      	    v = false ;						    	  v = false ;						  
      result += ( str . charAt ( i ) ) ;		      	  }							    	}							  
      v = false ;					      	}							      }								  
    }							      	return result ;						      return result ;						  
  }							      }								    }								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER	      WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER	    WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER	  WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER
--							      --							    --								  --
static int countWays ( String s ) {			      int countWays ( string s ) {				    int countWays ( string s ) {				  script_not_found : None
  int count [ ] = new int [ 26 ] ;			      	int count [ 26 ] = {					      int count [ 26 ] ;					  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < s . length ( ) ;					      	  ;							      i < s . length ( ) ;					  
  i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ;		      	  for ( char x : s ) count [ x - 'a' ] ++ ;		      i ++ ) {							  
  count [ s . charAt ( 0 ) - 'a' ] = 1 ;		      	  count [ s [ 0 ] - 'a' ] = 1 ;				    	count [ s [ i ] - 'a' ] ++ ;				  
  int ans = 1 ;						      	  int ans = 1 ;						      }								  
  for ( int i = 0 ;					      	  for ( int i = 0 ;					      count [ s [ 0 ] - 'a' ] = 1 ;				  
  i < 26 ;						      	  i < 26 ;						      int ans = 1 ;						  
  ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ;	      	  ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ;	      for ( int i = 0 ;						  
  return ans ;						      	  return ans ;						      i < 26 ;							  
}							      	}							      ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ;	  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM			      REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM			    REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM			  REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM
--							      --							    --								  --
static void rearrange ( int [ ] arr , int n ) {		      void rearrange ( int arr [ ] , int n ) {			    void rearrange ( int * arr , int n ) {			  script_not_found : None
  int temp [ ] = new int [ n ] ;			      	int temp [ n ] ;					      int temp [ n ] ;						  
  int small = 0 , large = n - 1 ;			      	int small = 0 , large = n - 1 ;				      int small = 0 , large = n - 1 ;				  
  boolean flag = true ;					      	int flag = true ;					      bool flag = true ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( flag ) temp [ i ] = arr [ large -- ] ;		      	  if ( flag ) temp [ i ] = arr [ large -- ] ;		    	if ( flag ) {						  
    else temp [ i ] = arr [ small ++ ] ;		      	  else temp [ i ] = arr [ small ++ ] ;			    	  temp [ i ] = arr [ large -- ] ;			  
    flag = ! flag ;					      	  flag = ! flag ;					    	}							  
  }							      	}							    	else {							  
  arr = temp . clone ( ) ;				      	for ( int i = 0 ;					    	  temp [ i ] = arr [ small ++ ] ;			  
}							      	i < n ;							    	}							  
							      	i ++ ) arr [ i ] = temp [ i ] ;				    	flag = ! flag ;						  
							      }								      }								  
							      								      arr = temp ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_OPERATIONS_MAKE_STRINGAB_FREE			      COUNT_OPERATIONS_MAKE_STRINGAB_FREE			    COUNT_OPERATIONS_MAKE_STRINGAB_FREE				  COUNT_OPERATIONS_MAKE_STRINGAB_FREE
--							      --							    --								  --
static int abFree ( char [ ] s ) {			      int abFree ( string s ) {					    int abFree ( char * s ) {					  script_not_found : None
  int b_count = 0 ;					      	int n = s . length ( ) ;				      int b_count = 0 ;						  
  int res = 0 ;						      	char char_array [ n + 1 ] ;				      int res = 0 ;						  
  for ( int i = 0 ;					      	strcpy ( char_array , s . c_str ( ) ) ;			      for ( int i = 0 ;						  
  i < s . length ;					      	int b_count = 0 ;					      i < strlen ( s ) ;					  
  i ++ ) {						      	int res = 0 ;						      i ++ ) {							  
    if ( s [ s . length - i - 1 ] == 'a' ) {		      	for ( int i = 0 ;					    	if ( s [ strlen ( s ) - i - 1 ] == 'a' ) {		  
      res = ( res + b_count ) ;				      	i < n ;							    	  res = ( res + b_count ) ;				  
      b_count = ( b_count * 2 ) ;			      	i ++ ) {						    	  b_count = ( b_count * 2 ) ;				  
    }							      	  if ( char_array [ n - i - 1 ] == 'a' ) {		    	}							  
    else {						      	    res = ( res + b_count ) ;				    	else {							  
      b_count += 1 ;					      	    b_count = ( b_count * 2 ) ;				    	  b_count += 1 ;					  
    }							      	  }							    	}							  
  }							      	  else {						      }								  
  return res ;						      	    b_count += 1 ;					      return res ;						  
}							      	  }							    }								  
							      	}							    								  
							      	return res ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1			      FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1			    FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1			  FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1
--							      --							    --								  --
static int getSingle ( int arr [ ] , int n ) {		      int getSingle ( int arr [ ] , int n ) {			    int getSingle ( int arr [ ] , int n ) {			  script_not_found : None
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  int x , sum ;						      	int x , sum ;						      int x , sum ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < INT_SIZE ;					      	i < INT_SIZE ;						      i < INT_SIZE ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    sum = 0 ;						      	  sum = 0 ;						    	sum = 0 ;						  
    x = ( 1 << i ) ;					      	  x = ( 1 << i ) ;					    	x = ( 1 << i ) ;					  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( ( arr [ j ] & x ) == 0 ) sum ++ ;		      	    if ( arr [ j ] & x ) sum ++ ;			    	  if ( ( arr [ j ] & x ) == 0 ) {			  
    }							      	  }							    	    sum ++ ;						  
    if ( ( sum % 3 ) == 0 ) result |= x ;		      	  if ( sum % 3 ) result |= x ;				    	  }							  
  }							      	}							    	}							  
  return result ;					      	return result ;						    	if ( ( sum % 3 ) == 0 ) {				  
}							      }								    	  result |= x ;						  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY		      MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY		    MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY		  MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY
--							      --							    --								  --
static int maxDistance ( int [ ] arr , int n ) {	      int maxDistance ( int arr [ ] , int n ) {			    int maxDistance ( int * arr , int n ) {			  success : None
  HashMap < Integer , Integer > map = new HashMap < > ( ) ;   	unordered_map < int , int > mp ;			      unordered_map < int , int > map ;				  
  int max_dist = 0 ;					      	int max_dist = 0 ;					      int maxDist = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr  	  if ( mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ 	if ( ! map . count ( arr [ i ] ) ) {			  
    else max_dist = Math . max ( max_dist , i - map . get ( a 	  else max_dist = max ( max_dist , i - mp [ arr [ i ] ] ) ; 	  map [ arr [ i ] ] = i ;				  
  }							      	}							    	}							  
  return max_dist ;					      	return max_dist ;					    	else {							  
}							      }								    	  maxDist = max ( maxDist , i - map [ arr [ i ] ] ) ;	  
							      								    	}							  
							      								      }								  
							      								      return maxDist ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1			      MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1			    MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1			  MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1
--							      --							    --								  --
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] ,  int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , success : identical to gold
  int maxSum = 0 ;					      	int maxSum = 0 ;					      int maxSum = 0 ;						  
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + N ) ;				      sort ( arr , arr + N ) ;					  
  for ( int i = N - 1 ;					      	for ( int i = N - 1 ;					      for ( int i = N - 1 ;					  
  i > 0 ;						      	i > 0 ;							      i > 0 ;							  
  -- i ) {						      	-- i ) {						      -- i ) {							  
    if ( arr [ i ] - arr [ i - 1 ] < k ) {		      	  if ( arr [ i ] - arr [ i - 1 ] < k ) {		    	if ( arr [ i ] - arr [ i - 1 ] < k ) {			  
      maxSum += arr [ i ] ;				      	    maxSum += arr [ i ] ;				    	  maxSum += arr [ i ] ;					  
      maxSum += arr [ i - 1 ] ;				      	    maxSum += arr [ i - 1 ] ;				    	  maxSum += arr [ i - 1 ] ;				  
      -- i ;						      	    -- i ;						    	  -- i ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return maxSum ;					      	return maxSum ;						      return maxSum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT	      NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT	    NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT	  NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT
--							      --							    --								  --
static int sumEqualProduct ( int a [ ] , int n ) {	      int sumEqualProduct ( int a [ ] , int n ) {		    int sumEqualProduct ( int a [ ] , int n ) {			  success : None
  int zero = 0 , two = 0 ;				      	int zero = 0 , two = 0 ;				      int zero = 0 , two = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( a [ i ] == 0 ) {				      	  if ( a [ i ] == 0 ) {					    	if ( a [ i ] == 0 ) zero ++ ;				  
      zero ++ ;						      	    zero ++ ;						    	if ( a [ i ] == 2 ) two ++ ;				  
    }							      	  }							      }								  
    if ( a [ i ] == 2 ) {				      	  if ( a [ i ] == 2 ) {					      int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) 
      two ++ ;						      	    two ++ ;						      return cnt ;						  
    }							      	  }							    }								  
  }							      	}							    								  
  int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) 	int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) 								  
  return cnt ;						      	return cnt ;						    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1		      FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1		    FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1		  FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1
--							      --							    --								  --
static void findMissing ( int a [ ] , int b [ ] , int n , int void findMissing ( int a [ ] , int b [ ] , int n , int m ) {  void findMissing ( int a [ ] , int b [ ] , int n , int m ) {  script_not_found : None
  HashSet < Integer > s = new HashSet < > ( ) ;		      	unordered_set < int > s ;				      set < int > s ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m ;						      	i < m ;							      i < m ;							  
  i ++ ) s . add ( b [ i ] ) ;				      	i ++ ) s . insert ( b [ i ] ) ;				      i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	s . insert ( b [ i ] ) ;				  
  i < n ;						      	i < n ;							      }								  
  i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . pri 	i ++ ) if ( s . find ( a [ i ] ) == s . end ( ) ) cout << a   for ( int i = 0 ;						  
}							      }								      i < n ;							  
							      								      i ++ ) if ( ! s . count ( a [ i ] ) ) cout << a [ i ] << "  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE		      CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE		    CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE		  CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE
--							      --							    --								  --
static void convertOpposite ( StringBuffer str ) {	      void convertOpposite ( string & str ) {			    void convertOpposite ( string str ) {			  script_not_found : None
  int ln = str . length ( ) ;				      	int ln = str . length ( ) ;				      int ln = str . length ( ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < ln ;						      	i < ln ;						      i < ln ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    Character c = str . charAt ( i ) ;			      	  if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) str [ i ] = s 	char c = str [ i ] ;					  
    if ( Character . isLowerCase ( c ) ) str . replace ( i ,  	  else if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) str [ i  	if ( islower ( c ) ) {					  
    else str . replace ( i , i + 1 , Character . toLowerCase  	}							    	  str . replace ( i , i + 1 , toupper ( c ) + "" ) ;	  
  }							      }								    	}							  
}							      								    	else {							  
							      								    	  str . replace ( i , i + 1 , tolower ( c ) + "" ) ;	  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY		      MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY		    MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY		  MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY
--							      --							    --								  --
static int maxSum ( int arr [ ] , int n ) {		      int maxSum ( int arr [ ] , int n ) {			    int maxSum ( int arr [ ] , int n ) {			  success : None
  int res = Integer . MIN_VALUE ;			      	int res = INT_MIN ;					      int res = INT_MIN ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int curr_sum = 0 ;					      	  int curr_sum = 0 ;					    	int currSum = 0 ;					  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      int index = ( i + j ) % n ;			      	    int index = ( i + j ) % n ;				    	  int index = ( i + j ) % n ;				  
      curr_sum += j * arr [ index ] ;			      	    curr_sum += j * arr [ index ] ;			    	  currSum += j * arr [ index ] ;			  
    }							      	  }							    	}							  
    res = Math . max ( res , curr_sum ) ;		      	  res = max ( res , curr_sum ) ;			    	res = max ( res , currSum ) ;				  
  }							      	}							      }								  
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE		      ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE		    ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE		  ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE
--							      --							    --								  --
static int solveQuery ( int start , int end , int arr [ ] ) { int solveQuery ( int start , int end , int arr [ ] ) {	    int solveQuery ( int start , int end , int arr [ ] ) {	  error : ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VAL
  Map < Integer , Integer > mp = new HashMap < > ( ) ;	      	unordered_map < int , int > frequency ;			      map < int , int > mp ;					  UE.cpp: In function ‘int f_filled(int, int, int*)’
  for ( int i = start ;					      	for ( int i = start ;					      for ( int i = start ;					  : ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE.cpp
  i <= end ;						      	i <= end ;						      i <= end ;						  :37:37: error: ‘i’ was not declared in this scope
  i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == nul 	i ++ ) frequency [ arr [ i ] ] ++ ;			      i ++ ) {							     it ++ ) if ( it -> first == arr [ i ] ) count +
  int count = 0 ;					      	int count = 0 ;						    	mp [ arr [ i ] ] = mp [ arr [ i ] ] == 0 ? 1 : mp [ arr [ + ;					   ^ ARRAY_R
  for ( Map . Entry < Integer , Integer > entry : mp . entryS 	for ( auto x : frequency ) if ( x . first == x . second ) c   }								  ANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE.cpp:37:37: n
  return count ;					      	return count ;						      int count = 0 ;						  ote: suggested alternative: ‘it’    it ++ ) if ( i
}							      }								      for ( map < int , int > :: iterator it = mp . begin ( ) ;	  t -> first == arr [ i ] ) count ++ ;
							      								      it != mp . end ( ) ;					  			  ^
							      								      it ++ ) if ( it -> first == arr [ i ] ) count ++ ;	  	       it
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM			      DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM			    DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM			  DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM
--							      --							    --								  --
static boolean isSubsetSum ( int set [ ] , int n , int sum )  bool isSubsetSum ( int set [ ] , int n , int sum ) {	    bool isSubsetSum ( int set [ ] , int n , int sum ) {	  script_not_found : None
  if ( sum == 0 ) return true ;				      	if ( sum == 0 ) return true ;				      if ( sum == 0 ) return true ;				  
  if ( n == 0 && sum != 0 ) return false ;		      	if ( n == 0 && sum != 0 ) return false ;		      if ( n == 0 && sum != 0 ) return false ;			  
  if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 	if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1   if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 
  return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( s 	return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( s   return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( s 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIAGONALLY_DOMINANT_MATRIX				      DIAGONALLY_DOMINANT_MATRIX				    DIAGONALLY_DOMINANT_MATRIX					  DIAGONALLY_DOMINANT_MATRIX
--							      --							    --								  --
static boolean isDDM ( int m [ ] [ ] , int n ) {	      bool isDDM ( int m [ N ] [ N ] , int n ) {		    bool isDDM ( int m [ ] [ 2 ] , int n ) {			  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int sum = 0 ;					      	  int sum = 0 ;						    	int sum = 0 ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) sum += Math . abs ( m [ i ] [ j ] ) ;	      	  j ++ ) sum += abs ( m [ i ] [ j ] ) ;			    	j ++ ) {						  
    sum -= Math . abs ( m [ i ] [ i ] ) ;		      	  sum -= abs ( m [ i ] [ i ] ) ;			    	  sum += abs ( m [ i ] [ j ] ) ;			  
    if ( Math . abs ( m [ i ] [ i ] ) < sum ) return false ;  	  if ( abs ( m [ i ] [ i ] ) < sum ) return false ;	    	}							  
  }							      	}							    	sum -= abs ( m [ i ] [ i ] ) ;				  
  return true ;						      	return true ;						    	if ( abs ( m [ i ] [ i ] ) < sum ) return false ;	  
}							      }								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES
--							      --							    --								  --
static int countNum ( int [ ] arr , int n ) {		      int countNum ( int arr [ ] , int n ) {			    int countNum ( int * arr , int n ) {			  success : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr  	i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr    i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_DIFFERENCE_EQUAL_K_1			      COUNT_PAIRS_DIFFERENCE_EQUAL_K_1				    COUNT_PAIRS_DIFFERENCE_EQUAL_K_1				  COUNT_PAIRS_DIFFERENCE_EQUAL_K_1
--							      --							    --								  --
static int countPairsWithDiffK ( int arr [ ] , int n , int k  int countPairsWithDiffK ( int arr [ ] , int n , int k ) {	    int countPairsWithDiffK ( int arr [ ] , int n , int k ) {	  success : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  int l = 0 ;						      	int l = 0 ;						      int l = 0 ;						  
  int r = 0 ;						      	int r = 0 ;						      int r = 0 ;						  
  while ( r < n ) {					      	while ( r < n ) {					      while ( r < n ) {						  
    if ( arr [ r ] - arr [ l ] == k ) {			      	  if ( arr [ r ] - arr [ l ] == k ) {			    	if ( arr [ r ] - arr [ l ] == k ) {			  
      count ++ ;					      	    count ++ ;						    	  count ++ ;						  
      l ++ ;						      	    l ++ ;						    	  l ++ ;						  
      r ++ ;						      	    r ++ ;						    	  r ++ ;						  
    }							      	  }							    	}							  
    else if ( arr [ r ] - arr [ l ] > k ) l ++ ;	      	  else if ( arr [ r ] - arr [ l ] > k ) l ++ ;		    	else if ( arr [ r ] - arr [ l ] > k ) {			  
    else r ++ ;						      	  else r ++ ;						    	  l ++ ;						  
  }							      	}							    	}							  
  return count ;					      	return count ;						    	else {							  
}							      }								    	  r ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN
--							      --							    --								  --
static boolean checkDuplicatesWithinK ( int arr [ ] , int k ) bool checkDuplicatesWithinK ( int arr [ ] , int n , int k ) { bool checkDuplicatesWithinK ( int arr [ ] , int k ) {	  script_not_found : None
  HashSet < Integer > set = new HashSet < > ( ) ;	      	unordered_set < int > myset ;				      set < int > set ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < arr . length ;					      	i < n ;							      i < sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( set . contains ( arr [ i ] ) ) return true ;	      	  if ( myset . find ( arr [ i ] ) != myset . end ( ) ) retu 	if ( set . count ( arr [ i ] ) ) return true ;		  
    set . add ( arr [ i ] ) ;				      	  myset . insert ( arr [ i ] ) ;			    	set . insert ( arr [ i ] ) ;				  
    if ( i >= k ) set . remove ( arr [ i - k ] ) ;	      	  if ( i >= k ) myset . erase ( arr [ i - k ] ) ;	    	if ( i >= k ) set . erase ( arr [ i - k ] ) ;		  
  }							      	}							      }								  
  return false ;					      	return false ;						      return false ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_ROOT_NUMBER					      N_TH_ROOT_NUMBER						    N_TH_ROOT_NUMBER						  N_TH_ROOT_NUMBER
--							      --							    --								  --
static double nthRoot ( int A , int N ) {		      double nthRoot ( int A , int N ) {			    double nthRoot ( int A , int N ) {				  script_not_found : None
  double xPre = Math . random ( ) % 10 ;		      	double xPre = rand ( ) % 10 ;				      double xPre = rand ( ) % 10 ;				  
  double eps = 0.001 ;					      	double eps = 1e - 3 ;					      double eps = 0.001 ;					  
  double delX = 2147483647 ;				      	double delX = INT_MAX ;					      double delX = 2147483647 ;				  
  double xK = 0.0 ;					      	double xK ;						      double xK = 0.0 ;						  
  while ( delX > eps ) {				      	while ( delX > eps ) {					      while ( delX > eps ) {					  
    xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( x 	  xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N 	xK = ( ( N - 1.0 ) * xPre + double ( A ) / pow ( xPre , N 
    delX = Math . abs ( xK - xPre ) ;			      	  delX = abs ( xK - xPre ) ;				    	delX = fabs ( xK - xPre ) ;				  
    xPre = xK ;						      	  xPre = xK ;						    	xPre = xK ;						  
  }							      	}							      }								  
  return xK ;						      	return xK ;						      return xK ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEGREGATE_EVEN_ODD_NUMBERS_SET_3			      SEGREGATE_EVEN_ODD_NUMBERS_SET_3				    SEGREGATE_EVEN_ODD_NUMBERS_SET_3				  SEGREGATE_EVEN_ODD_NUMBERS_SET_3
--							      --							    --								  --
static void arrayEvenAndOdd ( int arr [ ] , int n ) {	      void arrayEvenAndOdd ( int arr [ ] , int n ) {		    void arrayEvenAndOdd ( int arr [ ] , int n ) {		  script_not_found : None
  int i = - 1 , j = 0 ;					      	int i = - 1 , j = 0 ;					      int i = - 1 , j = 0 ;					  
  while ( j != n ) {					      	int t ;							      while ( j != n ) {					  
    if ( arr [ j ] % 2 == 0 ) {				      	while ( j != n ) {					    	if ( arr [ j ] % 2 == 0 ) {				  
      i ++ ;						      	  if ( arr [ j ] % 2 == 0 ) {				    	  i ++ ;						  
      int temp = arr [ i ] ;				      	    i ++ ;						    	  int temp = arr [ i ] ;				  
      arr [ i ] = arr [ j ] ;				      	    swap ( arr [ i ] , arr [ j ] ) ;			    	  arr [ i ] = arr [ j ] ;				  
      arr [ j ] = temp ;				      	  }							    	  arr [ j ] = temp ;					  
    }							      	  j ++ ;						    	}							  
    j ++ ;						      	}							    	j ++ ;							  
  }							      	for ( int i = 0 ;					      }								  
  for ( int k = 0 ;					      	i < n ;							      for ( int k = 0 ;						  
  k < n ;						      	i ++ ) cout << arr [ i ] << " " ;			      k < n ;							  
  k ++ ) System . out . print ( arr [ k ] + " " ) ;	      }								      k ++ ) {							  
}							      								    	cout << arr [ k ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY		      COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY			    COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY			  COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY
--							      --							    --								  --
static int countPairs ( int arr [ ] , int n ) {		      int countPairs ( int arr [ ] , int n ) {			    int countPairs ( int arr [ ] , int n ) {			  success : identical to gold
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      int product = arr [ i ] * arr [ j ] ;		      	    int product = arr [ i ] * arr [ j ] ;		    	  int product = arr [ i ] * arr [ j ] ;			  
      for ( int k = 0 ;					      	    for ( int k = 0 ;					    	  for ( int k = 0 ;					  
      k < n ;						      	    k < n ;						    	  k < n ;						  
      k ++ ) {						      	    k ++ ) {						    	  k ++ ) {						  
	if ( arr [ k ] == product ) {			      	      if ( arr [ k ] == product ) {			    	    if ( arr [ k ] == product ) {			  
	  result ++ ;					      		result ++ ;					    	      result ++ ;					  
	  break ;					      		break ;						    	      break ;						  
	}						      	      }							    	    }							  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return result ;					      	return result ;						      return result ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_FUNCTIONS					      RECURSIVE_FUNCTIONS					    RECURSIVE_FUNCTIONS						  RECURSIVE_FUNCTIONS
--							      --							    --								  --
static void tower ( int n , char sourcePole , char destinatio void tower ( int n , char sourcePole , char destinationPole , void tower ( int n , char sourcePole , char destinationPole , script_not_found : None
  if ( 0 == n ) return ;				      	if ( 0 == n ) return ;					      if ( 0 == n ) return ;					  
  tower ( n - 1 , sourcePole , auxiliaryPole , destinationPol 	tower ( n - 1 , sourcePole , auxiliaryPole , destinationPol   tower ( n - 1 , sourcePole , auxiliaryPole , destinationPol 
  System . out . printf ( "Move the disk %d from %c to %c\n"  	cout << "Move the disk " << n << " from " << sourcePole <<    printf ( "Move the disk %d from %c to %c\n" , n , sourcePol 
  tower ( n - 1 , auxiliaryPole , destinationPole , sourcePol 	tower ( n - 1 , auxiliaryPole , destinationPole , sourcePol   tower ( n - 1 , auxiliaryPole , destinationPole , sourcePol 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C
--							      --							    --								  --
static void fitOrNotFit ( int R , int r , int x , int y , int void fitOrNotFit ( int R , int r , int x , int y , int rad )  void fitOrNotFit ( int R , int r , int x , int y , int rad )  script_not_found : None
  double val = Math . sqrt ( Math . pow ( x , 2 ) + Math . po 	double val = sqrt ( pow ( x , 2 ) + pow ( y , 2 ) ) ;	      double val = sqrt ( pow ( x , 2 ) + pow ( y , 2 ) ) ;	  
  if ( val + rad <= R && val - rad >= R - r ) System . out .  	if ( val + rad <= R && val - rad >= R - r ) cout << "Fits\n   if ( val + rad <= R && val - rad >= R - r ) {		  
  else System . out . println ( "Doesn't Fit" ) ;	      	else cout << "Doesn't Fit\n" ;				    	cout << "Fits" << endl ;				  
}							      }								      }								  
							      								      else {							  
							      								    	cout << "Doesn't Fit" << endl ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPETITIVE_ELEMENT_1_N_1_3				      FIND_REPETITIVE_ELEMENT_1_N_1_3				    FIND_REPETITIVE_ELEMENT_1_N_1_3				  FIND_REPETITIVE_ELEMENT_1_N_1_3
--							      --							    --								  --
static int findRepeating ( int arr [ ] , int n ) {	      int findRepeating ( int arr [ ] , int n ) {		    int findRepeating ( int arr [ ] , int n ) {			  script_not_found : None
  int missingElement = 0 ;				      	int missingElement = 0 ;				      int missingElement = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int element = arr [ Math . abs ( arr [ i ] ) ] ;	      	  int element = arr [ abs ( arr [ i ] ) ] ;		    	int element = arr [ abs ( arr [ i ] ) ] ;		  
    if ( element < 0 ) {				      	  if ( element < 0 ) {					    	if ( element < 0 ) {					  
      missingElement = arr [ i ] ;			      	    missingElement = arr [ i ] ;			    	  missingElement = arr [ i ] ;				  
      break ;						      	    break ;						    	  break ;						  
    }							      	  }							    	}							  
    arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( a 	  arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; 	arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; 
  }							      	}							      }								  
  return Math . abs ( missingElement ) ;		      	return abs ( missingElement ) ;				      return abs ( missingElement ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_GFG_SUBSEQUENCES_GIVEN_STRING			      COUNT_GFG_SUBSEQUENCES_GIVEN_STRING			    COUNT_GFG_SUBSEQUENCES_GIVEN_STRING				  COUNT_GFG_SUBSEQUENCES_GIVEN_STRING
--							      --							    --								  --
static void countSubsequence ( String s , int n ) {	      void countSubsequence ( char s [ ] , int n ) {		    void countSubsequence ( string s , int n ) {		  script_not_found : None
  int cntG = 0 , cntF = 0 , result = 0 , C = 0 ;	      	int cntG = 0 , cntF = 0 , result = 0 , C = 0 ;		      int cntG = 0 , cntF = 0 , result = 0 , C = 0 ;		  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    switch ( s . charAt ( i ) ) {			      	  switch ( s [ i ] ) {					    	switch ( s [ i ] ) {					  
      case 'G' : cntG ++ ;				      	    case 'G' : cntG ++ ;				    	  case 'G' : cntG ++ ;					  
      result += C ;					      	    result += C ;					    	  result += C ;						  
      break ;						      	    break ;						    	  break ;						  
      case 'F' : cntF ++ ;				      	    case 'F' : cntF ++ ;				    	  case 'F' : cntF ++ ;					  
      C += cntG ;					      	    C += cntG ;						    	  C += cntG ;						  
      break ;						      	    break ;						    	  break ;						  
      default : continue ;				      	    default : continue ;				    	  default : continue ;					  
    }							      	  }							    	}							  
  }							      	}							      }								  
  System . out . println ( result ) ;			      	cout << result << endl ;				      cout << result << endl ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER		      NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER		    NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER		  NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER
--							      --							    --								  --
static int minimumBox ( int [ ] arr , int n ) {		      int minimumBox ( int arr [ ] , int n ) {			    int minimumBox ( int * arr , int n ) {			  error : NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_AN
  Queue < Integer > q = new LinkedList < > ( ) ;	      	queue < int > q ;					      queue < int > q ;						  OTHER.cpp: In function ‘int f_filled(int*, int)’:
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      qsort ( arr , n , sizeof ( int ) ) ;			  NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER.cp
  q . add ( arr [ 0 ] ) ;				      	q . push ( arr [ 0 ] ) ;				      q . push ( arr [ 0 ] ) ;					  p:33:36: error: too few arguments to function ‘voi
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  d qsort(void*, size_t, size_t, __compar_fn_t)’
  i < n ;						      	i < n ;							      i < n ;							  qsort ( arr , n , sizeof ( int ) ) ;
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  			 ^ In file included from /us
    int now = q . element ( ) ;				      	  int now = q . front ( ) ;				    	int now = q . front ( ) ;				  r/include/c++/8/cstdlib:75,		       from
    if ( arr [ i ] >= 2 * now ) q . remove ( ) ;	      	  if ( arr [ i ] >= 2 * now ) q . pop ( ) ;		    	if ( arr [ i ] >= 2 * now ) {				  /usr/include/c++/8/ext/string_conversions.h:41,
    q . add ( arr [ i ] ) ;				      	  q . push ( arr [ i ] ) ;				    	  q . pop ( ) ;						  		 from /usr/include/c++/8/bits/basic_
  }							      	}							    	}							  string.h:6400,		  from /usr/include/
  return q . size ( ) ;					      	return q . size ( ) ;					    	q . push ( arr [ i ] ) ;				  c++/8/string:52,		    from /usr/includ
}							      }								      }								  e/c++/8/bits/locale_classes.h:40,
							      								      return q . size ( ) ;					   from /usr/include/c++/8/bits/ios_base.h:41,
							      								    }								  	      from /usr/include/c++/8/ios:42,
							      								    								  	     from /usr/include/c++/8/ostream:38,
							      								    								  		from /usr/include/c++/8/iostream:39,
							      								    								  		    from NUMBER_VISIBLE_BOXES_PUTTIN
							      								    								  G_ONE_INSIDE_ANOTHER.cpp:8: /usr/include/stdlib.h:
							      								    								  827:13: note: declared here  extern void qsort (vo
							      								    								  id *__base, size_t __nmemb, size_t __size,
							      								    								  	^~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S	      COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S	    COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S		  COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S
--							      --							    --								  --
static int countStrings ( int n ) {			      int countStrings ( int n ) {				    int countStrings ( int n ) {				  success : None
  int a [ ] = new int [ n ] ;				      	int a [ n ] , b [ n ] ;					      int a [ n ] ;						  
  int b [ ] = new int [ n ] ;				      	a [ 0 ] = b [ 0 ] = 1 ;					      int b [ n ] ;						  
  a [ 0 ] = b [ 0 ] = 1 ;				      	for ( int i = 1 ;					      a [ 0 ] = b [ 0 ] = 1 ;					  
  for ( int i = 1 ;					      	i < n ;							      for ( int i = 1 ;						  
  i < n ;						      	i ++ ) {						      i < n ;							  
  i ++ ) {						      	  a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;			      i ++ ) {							  
    a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;		      	  b [ i ] = a [ i - 1 ] ;				    	a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;			  
    b [ i ] = a [ i - 1 ] ;				      	}							    	b [ i ] = a [ i - 1 ] ;					  
  }							      	return a [ n - 1 ] + b [ n - 1 ] ;			      }								  
  return a [ n - 1 ] + b [ n - 1 ] ;			      }								      return a [ n - 1 ] + b [ n - 1 ] ;			  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS	      POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS	    POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS	  POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS
--							      --							    --								  --
static boolean isPresent ( String s , String q ) {	      bool isPresent ( string s , string q ) {			    bool isPresent ( string s , string q ) {			  script_not_found : None
  int [ ] freq = new int [ MAX_CHAR ] ;			      	int freq [ MAX_CHAR ] = {				      vector < int > freq ( MAX_CHAR , 0 ) ;			  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < s . length ( ) ;					      	  ;							      i < s . length ( ) ;					  
  i ++ ) freq [ s . charAt ( i ) ] ++ ;			      	  for ( int i = 0 ;					      i ++ ) {							  
  for ( int i = 0 ;					      	  i < s . length ( ) ;					    	freq [ s [ i ] ] ++ ;					  
  i < q . length ( ) ;					      	  i ++ ) freq [ s [ i ] ] ++ ;				      }								  
  i ++ ) {						      	  for ( int i = 0 ;					      for ( int i = 0 ;						  
    freq [ q . charAt ( i ) ] -- ;			      	  i < q . length ( ) ;					      i < q . length ( ) ;					  
    if ( freq [ q . charAt ( i ) ] < 0 ) return false ;	      	  i ++ ) {						      i ++ ) {							  
  }							      	    freq [ q [ i ] ] -- ;				    	freq [ q [ i ] ] -- ;					  
  return true ;						      	    if ( freq [ q [ i ] ] < 0 ) return false ;		    	if ( freq [ q [ i ] ] < 0 ) return false ;		  
}							      	  }							      }								  
							      	  return true ;						      return true ;						  
							      	}							    }								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS	      MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS	    MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS		  MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS
--							      --							    --								  --
public static int minProduct ( int [ ] arr , int n , int k )  int minProduct ( int arr [ ] , int n , int k ) {		    int minProduct ( int * arr , int n , int k ) {		  error : In file included from /usr/include/c++/8/q
  PriorityQueue < Integer > pq = new PriorityQueue < > ( ) ;  	priority_queue < int , vector < int > , greater < int >> pq   priority_queue < int , int , greater < int >> pq ;	  ueue:64,		    from /usr/include/c++/8/
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  x86_64-redhat-linux/bits/stdc++.h:86,
  i < n ;						      	i < n ;							      i < n ;							       from MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIV
  i ++ ) pq . add ( arr [ i ] ) ;			      	i ++ ) pq . push ( arr [ i ] ) ;			      i ++ ) {							  E_INTEGERS.cpp:14: /usr/include/c++/8/bits/stl_que
  int count = 0 , ans = 1 ;				      	int count = 0 , ans = 1 ;				    	pq . push ( arr [ i ] ) ;				  ue.h: In instantiation of ‘class std::priority_que
  while ( pq . isEmpty ( ) == false && count < k ) {	      	while ( pq . empty ( ) == false && count < k ) {	      }								  ue<int, int, std::greater<int> >’: MINIMUM_PRODUCT
    ans = ans * pq . element ( ) ;			      	  ans = ans * pq . top ( ) ;				      int count = 0 , ans = 1 ;					  _K_INTEGERS_ARRAY_POSITIVE_INTEGERS.cpp:32:49:   r
    pq . remove ( ) ;					      	  pq . pop ( ) ;					      while ( pq . empty ( ) == false && count < k ) {		  equired from here /usr/include/c++/8/bits/stl_queu
    count ++ ;						      	  count ++ ;						    	ans = ans * pq . top ( ) ;				  e.h:457:47: error: ‘int’ is not a class, struct, o
  }							      	}							    	pq . pop ( ) ;						  r union type	      typedef typename _Sequence::va
  return ans ;						      	return ans ;						    	count ++ ;						  lue_type  value_type;
}							      }								      }								  		     ^~~~~~~~~~ /usr/include/c++/8/b
							      								      return ans ;						  its/stl_queue.h:458:47: error: ‘int’ is not a clas
							      								    }								  s, struct, or union type	  typedef typename _
							      								    								  Sequence::reference	reference;
							      								    								  				^~~~~~~~~ /usr/inclu
							      								    								  de/c++/8/bits/stl_queue.h:459:54: error: ‘int’ is
							      								    								  not a class, struct, or union type	    typedef
							      								    								  typename _Sequence::const_reference	 const_refer
							      								    								  ence;
							      								    								  	    ^~~~~~~~~~~~~~~ /usr/include/c++/8/bits/
							      								    								  stl_queue.h:460:47: error: ‘int’ is not a class, s
							      								    								  truct, or union type	      typedef typename _Sequ
							      								    								  ence::size_type   size_type;
							      								    								  			    ^~~~~~~~~ MINIMUM_PRODUC
							      								    								  T_K_INTEGERS_ARRAY_POSITIVE_INTEGERS.cpp: In funct
							      								    								  ion ‘int f_filled(int*, int, int)’: MINIMUM_PRODUC
							      								    								  T_K_INTEGERS_ARRAY_POSITIVE_INTEGERS.cpp:36:10: er
							      								    								  ror: ‘class std::priority_queue<int, int, std::gre
							      								    								  ater<int> >’ has no member named ‘push’      pq .
							      								    								  push ( arr [ i ] ) ;		 ^~~~ MINIMUM_PRODUC
							      								    								  T_K_INTEGERS_ARRAY_POSITIVE_INTEGERS.cpp:40:22: er
							      								    								  ror: ‘class std::priority_queue<int, int, std::gre
							      								    								  ater<int> >’ has no member named ‘top’; did you me
							      								    								  an ‘pop’?	 ans = ans * pq . top ( ) ;
							      								    								  		^~~			  pop In fil
							      								    								  e included from /usr/include/c++/8/queue:64,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:86,		   from MINI
							      								    								  MUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS.cpp
							      								    								  :14: /usr/include/c++/8/bits/stl_queue.h: In insta
							      								    								  ntiation of ‘bool std::priority_queue<_Tp, _Sequen
							      								    								  ce, _Compare>::empty() const [with _Tp = int; _Seq
							      								    								  uence = int; _Compare = std::greater<int>]’: MINIM
							      								    								  UM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS.cpp:
							      								    								  39:24:   required from here /usr/include/c++/8/bit
							      								    								  s/stl_queue.h:584:18: error: request for member ‘e
							      								    								  mpty’ in ‘((const std::priority_queue<int, int, st
							      								    								  d::greater<int> >*)this)->std::priority_queue<int,
							      								    								   int, std::greater<int> >::c’, which is of non-cla
							      								    								  ss type ‘const int’	     { return c.empty(); }
							      								    								  		 ~~^~~~~ /usr/include/c++/8/bits/stl
							      								    								  _queue.h: In instantiation of ‘void std::priority_
							      								    								  queue<_Tp, _Sequence, _Compare>::pop() [with _Tp =
							      								    								   int; _Sequence = int; _Compare = std::greater<int
							      								    								  >]’: MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INT
							      								    								  EGERS.cpp:41:16:   required from here /usr/include
							      								    								  /c++/8/bits/stl_queue.h:649:18: error: request for
							      								    								   member ‘begin’ in ‘((std::priority_queue<int, int
							      								    								  , std::greater<int> >*)this)->std::priority_queue<
							      								    								  int, int, std::greater<int> >::c’, which is of non
							      								    								  -class type ‘int’   std::pop_heap(c.begin(), c.end
							      								    								  (), comp);		     ~~^~~~~ /usr/include/c+
							      								    								  +/8/bits/stl_queue.h:649:29: error: request for me
							      								    								  mber ‘end’ in ‘((std::priority_queue<int, int, std
							      								    								  ::greater<int> >*)this)->std::priority_queue<int,
							      								    								  int, std::greater<int> >::c’, which is of non-clas
							      								    								  s type ‘int’	 std::pop_heap(c.begin(), c.end(), c
							      								    								  omp);				   ~~^~~ /usr/includ
							      								    								  e/c++/8/bits/stl_queue.h:650:4: error: request for
							      								    								   member ‘pop_back’ in ‘((std::priority_queue<int,
							      								    								  int, std::greater<int> >*)this)->std::priority_que
							      								    								  ue<int, int, std::greater<int> >::c’, which is of
							      								    								  non-class type ‘int’	 c.pop_back();	 ~~^~~~~~~~
							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS	      GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS		    GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS		  GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS
--							      --							    --								  --
static void findMin ( int V ) {				      void findMin ( int V ) {					    void findMin ( int V ) {					  script_not_found : None
  Vector < Integer > ans = new Vector < > ( ) ;		      	vector < int > ans ;					      vector < int > ans ;					  
  for ( int i = n - 1 ;					      	for ( int i = n - 1 ;					      for ( int i = n - 1 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    while ( V >= deno [ i ] ) {				      	  while ( V >= deno [ i ] ) {				    	while ( V >= deno [ i ] ) {				  
      V -= deno [ i ] ;					      	    V -= deno [ i ] ;					    	  V -= deno [ i ] ;					  
      ans . add ( deno [ i ] ) ;			      	    ans . push_back ( deno [ i ] ) ;			    	  ans . push_back ( deno [ i ] ) ;			  
    }							      	  }							    	}							  
  }							      	}							      }								  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < ans . size ( ) ;					      	i < ans . size ( ) ;					      i < ans . size ( ) ;					  
  i ++ ) {						      	i ++ ) cout << ans [ i ] << "  " ;			      i ++ ) cout << " " << ans [ i ] << endl ;			  
    System . out . print ( " " + ans . elementAt ( i ) ) ;    }								    }								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE		      FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE		    FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE		  FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE
--							      --							    --								  --
static int minCoins ( int coins [ ] , int m , int V ) {	      int minCoins ( int coins [ ] , int m , int V ) {		    int minCoins ( int coins [ ] , int m , int V ) {		  script_not_found : None
  if ( V == 0 ) return 0 ;				      	if ( V == 0 ) return 0 ;				      if ( V == 0 ) return 0 ;					  
  int res = Integer . MAX_VALUE ;			      	int res = INT_MAX ;					      int res = INT_MAX ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m ;						      	i < m ;							      i < m ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( coins [ i ] <= V ) {				      	  if ( coins [ i ] <= V ) {				    	if ( coins [ i ] <= V ) {				  
      int sub_res = minCoins ( coins , m , V - coins [ i ] )  	    int sub_res = minCoins ( coins , m , V - coins [ i ] )  	  int sub_res = minCoins ( coins , m , V - coins [ i ] )  
      if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < re 	    if ( sub_res != INT_MAX && sub_res + 1 < res ) res = su 	  if ( sub_res != INT_MAX && sub_res + 1 < res ) {	  
    }							      	  }							    	    res = sub_res + 1 ;					  
  }							      	}							    	  }							  
  return res ;						      	return res ;						    	}							  
}							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N		      FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N		    FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N			  FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N
--							      --							    --								  --
static int findRepeatingElement ( int arr [ ] , int low , int int findRepeatingElement ( int arr [ ] , int low , int high ) int findRepeatingElement ( int arr [ ] , int low , int high ) success : identical to gold
  if ( low > high ) return - 1 ;			      	if ( low > high ) return - 1 ;				      if ( low > high ) return - 1 ;				  
  int mid = ( low + high ) / 2 ;			      	int mid = ( low + high ) / 2 ;				      int mid = ( low + high ) / 2 ;				  
  if ( arr [ mid ] != mid + 1 ) {			      	if ( arr [ mid ] != mid + 1 ) {				      if ( arr [ mid ] != mid + 1 ) {				  
    if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return m 	  if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return m 	if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return m 
    return findRepeatingElement ( arr , low , mid - 1 ) ;     	  return findRepeatingElement ( arr , low , mid - 1 ) ;	    	return findRepeatingElement ( arr , low , mid - 1 ) ;	  
  }							      	}							      }								  
  return findRepeatingElement ( arr , mid + 1 , high ) ;      	return findRepeatingElement ( arr , mid + 1 , high ) ;	      return findRepeatingElement ( arr , mid + 1 , high ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1	    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1
--							      --							    --								  --
void printRepeating ( int arr [ ] , int size ) {	      void printRepeating ( int arr [ ] , int size ) {		    void printRepeating ( int arr [ ] , int size ) {		  script_not_found : None
  int count [ ] = new int [ size ] ;			      	int * count = new int [ sizeof ( int ) * ( size - 2 ) ] ;     int count [ size ] ;					  
  int i ;						      	int i ;							      int i ;							  
  System . out . println ( "Repeated elements are : " ) ;     	cout << " Repeating elements are " ;			      cout << "Repeated elements are : " ;			  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < size ;						      	i < size ;						      i < size ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( count [ arr [ i ] ] == 1 ) System . out . print ( ar 	  if ( count [ arr [ i ] ] == 1 ) cout << arr [ i ] << " "  	if ( count [ arr [ i ] ] == 1 ) {			  
    else count [ arr [ i ] ] ++ ;			      	  else count [ arr [ i ] ] ++ ;				    	  cout << arr [ i ] << " " ;				  
  }							      	}							    	}							  
}							      }								    	else {							  
							      								    	  count [ arr [ i ] ] ++ ;				  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N		      COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N		    COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N		  COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N
--							      --							    --								  --
static int countSetBits ( int n ) {			      int countSetBits ( int n ) {				    int countSetBits ( int n ) {				  success : None
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  while ( ( 1 << i ) <= n ) {				      	while ( ( 1 << i ) <= n ) {				      while ( ( 1 << i ) <= n ) {				  
    boolean k = false ;					      	  bool k = 0 ;						    	bool k = false ;					  
    int change = 1 << i ;				      	  int change = 1 << i ;					    	int change = 1 << i ;					  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= n ;						      	  j <= n ;						    	j <= n ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( k == true ) ans += 1 ;			      	    ans += k ;						    	  if ( k == true ) {					  
      else ans += 0 ;					      	    if ( change == 1 ) {				    	    ans += 1 ;						  
      if ( change == 1 ) {				      	      k = ! k ;						    	  }							  
	k = ! k ;					      	      change = 1 << i ;					    	  else {						  
	change = 1 << i ;				      	    }							    	    ans += 0 ;						  
      }							      	    else {						    	  }							  
      else {						      	      change -- ;					    	  if ( change == 1 ) {					  
	change -- ;					      	    }							    	    k = ! k ;						  
      }							      	  }							    	    change = 1 << i ;					  
    }							      	  i ++ ;						    	  }							  
    i ++ ;						      	}							    	  else {						  
  }							      	return ans ;						    	    change -- ;						  
  return ans ;						      }								    	  }							  
}							      								    	}							  
							      								    	i ++ ;							  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I
--							      --							    --								  --
static int countDer ( int n ) {				      int countDer ( int n ) {					    int countDer ( int n ) {					  success : None
  int der [ ] = new int [ n + 1 ] ;			      	int der [ n + 1 ] ;					      int der [ n + 1 ] ;					  
  der [ 0 ] = 1 ;					      	der [ 0 ] = 1 ;						      der [ 0 ] = 1 ;						  
  der [ 1 ] = 0 ;					      	der [ 1 ] = 0 ;						      der [ 1 ] = 0 ;						  
  der [ 2 ] = 1 ;					      	der [ 2 ] = 1 ;						      der [ 2 ] = 1 ;						  
  for ( int i = 3 ;					      	for ( int i = 3 ;					      for ( int i = 3 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i -  	++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i -    ++ i ) {							  
  return der [ n ] ;					      	return der [ n ] ;					    	der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) 
}							      }								      }								  
							      								      return der [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_TRIPLET_SUM_ARRAY				      MAXIMUM_TRIPLET_SUM_ARRAY					    MAXIMUM_TRIPLET_SUM_ARRAY					  MAXIMUM_TRIPLET_SUM_ARRAY
--							      --							    --								  --
static int maxTripletSum ( int arr [ ] , int n ) {	      int maxTripletSum ( int arr [ ] , int n ) {		    int maxTripletSum ( int arr [ ] , int n ) {			  success : None
  int sum = - 1000000 ;					      	int sum = INT_MIN ;					      int sum = - 1000000 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) for ( int k = j + 1 ;				      	j ++ ) for ( int k = j + 1 ;				      j ++ ) for ( int k = j + 1 ;				  
  k < n ;						      	k < n ;							      k < n ;							  
  k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = 	k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum =   k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = 
  return sum ;						      	return sum ;						      return sum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_STRING_BINARY_SEQUENCE				      CONVERT_STRING_BINARY_SEQUENCE				    CONVERT_STRING_BINARY_SEQUENCE				  CONVERT_STRING_BINARY_SEQUENCE
--							      --							    --								  --
static void strToBinary ( String s ) {			      void strToBinary ( string s ) {				    void strToBinary ( string s ) {				  script_not_found : None
  int n = s . length ( ) ;				      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i <= n ;						      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int val = Integer . valueOf ( s . charAt ( i ) ) ;	      	  int val = int ( s [ i ] ) ;				    	int val = atoi ( s [ i ] . c_str ( ) ) ;		  
    String bin = "" ;					      	  string bin = "" ;					    	string bin ;						  
    while ( val > 0 ) {					      	  while ( val > 0 ) {					    	while ( val > 0 ) {					  
      if ( val % 2 == 1 ) {				      	    ( val % 2 ) ? bin . push_back ( '1' ) : bin . push_back 	  if ( val % 2 == 1 ) bin += '1' ;			  
	bin += '1' ;					      	    val /= 2 ;						    	  else bin += '0' ;					  
      }							      	  }							    	  val /= 2 ;						  
      else bin += '0' ;					      	  reverse ( bin . begin ( ) , bin . end ( ) ) ;		    	}							  
      val /= 2 ;					      	  cout << bin << " " ;					    	bin = reverse ( bin . begin ( ) , bin . end ( ) ) ;	  
    }							      	}							    	cout << bin << " " ;					  
    bin = reverse ( bin ) ;				      }								      }								  
    System . out . print ( bin + " " ) ;		      								    }								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	      DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	    DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	  DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1
--							      --							    --								  --
static boolean checkCount ( int arr [ ] , int n , int k ) {   bool checkCount ( int arr [ ] , int n , int k ) {		    bool checkCount ( int arr [ ] , int n , int k ) {		  success : None
  HashMap < Integer , Integer > hash = new HashMap < > ( ) ;  	unordered_map < int , int > hash ;			      unordered_map < int , int > hash ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) hash [ arr [ i ] ] ++ ;				      i ++ ) {							  
    if ( ! hash . containsKey ( arr [ i ] ) ) hash . put ( ar 	for ( auto x : hash ) if ( x . second > 2 * k ) return fals 	if ( ! hash . count ( arr [ i ] ) ) {			  
    hash . put ( arr [ i ] , hash . get ( arr [ i ] ) + 1 ) ; 	return true ;						    	  hash [ arr [ i ] ] = 0 ;				  
  }							      }								    	}							  
  for ( Map . Entry x : hash . entrySet ( ) ) if ( ( int ) x  								    	hash [ arr [ i ] ] = hash [ arr [ i ] ] + 1 ;		  
  return true ;						      								      }								  
}							      								      for ( unordered_map < int , int > :: const_iterator x = has 
							      								      x != hash . end ( ) ;					  
							      								      ++ x ) if ( ( * x ) . second > 2 * k ) return false ;	  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NON_REPEATING_ELEMENT_1					      NON_REPEATING_ELEMENT_1					    NON_REPEATING_ELEMENT_1					  NON_REPEATING_ELEMENT_1
--							      --							    --								  --
static int firstNonRepeating ( int arr [ ] , int n ) {	      int firstNonRepeating ( int arr [ ] , int n ) {		    int firstNonRepeating ( int arr [ ] , int n ) {		  success : None
  Map < Integer , Integer > m = new HashMap < > ( ) ;	      	unordered_map < int , int > mp ;			      map < int , int > m ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) mp [ arr [ i ] ] ++ ;				      i ++ ) {							  
    if ( m . containsKey ( arr [ i ] ) ) {		      	for ( int i = 0 ;					    	if ( m . find ( arr [ i ] ) != m . end ( ) ) m [ arr [ i  
      m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ;     	i < n ;							    	else m [ arr [ i ] ] = 1 ;				  
    }							      	i ++ ) if ( mp [ arr [ i ] ] == 1 ) return arr [ i ] ;	      }								  
    else {						      	return - 1 ;						      for ( int i = 0 ;						  
      m . put ( arr [ i ] , 1 ) ;			      }								      i < n ;							  
    }							      								      i ++ ) if ( m [ arr [ i ] ] == 1 ) return arr [ i ] ;	  
  }							      								      return - 1 ;						  
  for ( int i = 0 ;					      								    }								  
  i < n ;						      								    								  
  i ++ ) if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ; 								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY		      MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY		    MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY		  MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY
--							      --							    --								  --
static int findArea ( Integer arr [ ] , int n ) {	      int findArea ( int arr [ ] , int n ) {			    int findArea ( int32_t arr [ ] , int n ) {			  failure : #Results: 7, 10
  Arrays . sort ( arr , Collections . reverseOrder ( ) ) ;    	sort ( arr , arr + n , greater < int > ( ) ) ;		      sort ( arr , arr + n ) ;					  
  int [ ] dimension = {					      	int dimension [ 2 ] = {					      int32_t dimension [ 2 ] = {				  
    0 , 0 }						      	  0 , 0 }						    	0 , 0 }							  
    ;							      	  ;							    	;							  
    for ( int i = 0 , j = 0 ;				      	  for ( int i = 0 , j = 0 ;				    	for ( int i = 0 , j = 0 ;				  
    i < n - 1 && j < 2 ;				      	  i < n - 1 && j < 2 ;					    	i < n - 1 && j < 2 ;					  
    i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ 	  i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ 	i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ 
    return ( dimension [ 0 ] * dimension [ 1 ] ) ;	      	  return ( dimension [ 0 ] * dimension [ 1 ] ) ;	    	return ( dimension [ 0 ] * dimension [ 1 ] ) ;		  
  }							      	}							      }								  
  -							      	-							      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP	      HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP	    HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP	  HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP
--							      --							    --								  --
static boolean isHeap ( int arr [ ] , int i , int n ) {	      bool isHeap ( int arr [ ] , int i , int n ) {		    bool isHeap ( int arr [ ] , int i , int n ) {		  success : identical to gold
  if ( i > ( n - 2 ) / 2 ) {				      	if ( i > ( n - 2 ) / 2 ) return true ;			      if ( i > ( n - 2 ) / 2 ) return true ;			  
    return true ;					      	if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2   if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 
  }							      	return false ;						      return false ;						  
  if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 }								    }								  
    return true ;					      								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_COMMON_SUPERSEQUENCE				      SHORTEST_COMMON_SUPERSEQUENCE				    SHORTEST_COMMON_SUPERSEQUENCE				  SHORTEST_COMMON_SUPERSEQUENCE
--							      --							    --								  --
static int superSeq ( String X , String Y , int m , int n ) { int superSeq ( char * X , char * Y , int m , int n ) {	    int superSeq ( string X , string Y , int m , int n ) {	  script_not_found : None
  if ( m == 0 ) return n ;				      	if ( ! m ) return n ;					      if ( m == 0 ) return n ;					  
  if ( n == 0 ) return m ;				      	if ( ! n ) return m ;					      if ( n == 0 ) return m ;					  
  if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return  	if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X ,   if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , 
  return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , su 	return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq    return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y
--							      --							    --								  --
static int countSolutions ( int n ) {			      int countSolutions ( int n ) {				    int countSolutions ( int n ) {				  success : None
  int x = 0 , yCount , res = 0 ;			      	int x = 0 , yCount , res = 0 ;				      int x = 0 , yCount , res = 0 ;				  
  for ( yCount = 0 ;					      	for ( yCount = 0 ;					      for ( yCount = 0 ;					  
  yCount * yCount < n ;					      	yCount * yCount < n ;					      yCount * yCount < n ;					  
  yCount ++ ) ;						      	yCount ++ ) ;						      yCount ++ ) ;						  
  while ( yCount != 0 ) {				      	while ( yCount != 0 ) {					      while ( yCount != 0 ) {					  
    res += yCount ;					      	  res += yCount ;					    	res += yCount ;						  
    x ++ ;						      	  x ++ ;						    	x ++ ;							  
    while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCoun 	  while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCoun 	while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCoun 
  }							      	}							    	  yCount -- ;						  
  return res ;						      	return res ;						    	}							  
}							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_ FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_ FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_ FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_
--							      --							    --								  --
static int countSol ( int coeff [ ] , int n , int rhs ) {     int countSol ( int coeff [ ] , int n , int rhs ) {	    int countSol ( int coeff [ ] , int n , int rhs ) {		  script_not_found : None
  int dp [ ] = new int [ rhs + 1 ] ;			      	int dp [ rhs + 1 ] ;					      int dp [ rhs + 1 ] ;					  
  Arrays . fill ( dp , 0 ) ;				      	memset ( dp , 0 , sizeof ( dp ) ) ;			      memset ( dp , 0 , rhs + 1 ) ;				  
  dp [ 0 ] = 1 ;					      	dp [ 0 ] = 1 ;						      dp [ 0 ] = 1 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = coeff [ i ] ;			      	i ++ ) for ( int j = coeff [ i ] ;			      i ++ ) for ( int j = coeff [ i ] ;			  
  j <= rhs ;						      	j <= rhs ;						      j <= rhs ;						  
  j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ;		      	j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ;		      j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ;		  
  return dp [ rhs ] ;					      	return dp [ rhs ] ;					      return dp [ rhs ] ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE	      DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE	    DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE
--							      --							    --								  --
int lcs ( char [ ] X , char [ ] Y , int m , int n ) {	      int lcs ( char * X , char * Y , int m , int n ) {		    int lcs ( char * X , char * Y , int m , int n ) {		  script_not_found : None
  if ( m == 0 || n == 0 ) return 0 ;			      	if ( m == 0 || n == 0 ) return 0 ;			      if ( m == 0 || n == 0 ) return 0 ;			  
  if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y ,  	if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y ,    if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y ,  
  else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , 	else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y ,   else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBSEQUENCE_GCD_GREATER_1			      LARGEST_SUBSEQUENCE_GCD_GREATER_1				    LARGEST_SUBSEQUENCE_GCD_GREATER_1				  LARGEST_SUBSEQUENCE_GCD_GREATER_1
--							      --							    --								  --
static int largestGCDSubsequence ( int arr [ ] , int n ) {    int largestGCDSubsequence ( int arr [ ] , int n ) {	    int largestGCDSubsequence ( int arr [ ] , int n ) {		  failure : #Results: 9, 10
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( 	int maxele = * max_element ( arr , arr + n ) ;		      int maxele = std :: max ( arr [ 0 ] , arr [ 1 ] ) ;	  
  ;							      	for ( int i = 2 ;					      ;								  
  for ( int i = 2 ;					      	i <= maxele ;						      for ( int i = 2 ;						  
  i <= maxele ;						      	++ i ) {						      i <= maxele ;						  
  ++ i ) {						      	  int count = 0 ;					      ++ i ) {							  
    int count = 0 ;					      	  for ( int j = 0 ;					    	int count = 0 ;						  
    for ( int j = 0 ;					      	  j < n ;						    	for ( int j = 0 ;					  
    j < n ;						      	  ++ j ) {						    	j < n ;							  
    ++ j ) {						      	    if ( arr [ j ] % i == 0 ) ++ count ;		    	++ j ) {						  
      if ( arr [ j ] % i == 0 ) ++ count ;		      	  }							    	  if ( arr [ j ] % i == 0 ) ++ count ;			  
    }							      	  ans = max ( ans , count ) ;				    	}							  
    ans = Math . max ( ans , count ) ;			      	}							    	ans = std :: max ( ans , count ) ;			  
  }							      	return ans ;						      }								  
  return ans ;						      }								      return ans ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUPER_PRIME						      SUPER_PRIME						    SUPER_PRIME							  SUPER_PRIME
--							      --							    --								  --
static void SieveOfEratosthenes ( int n , boolean isPrime [ ] bool SieveOfEratosthenes ( int n , bool isPrime [ ] ) {	    void SieveOfEratosthenes ( int n , bool isPrime [ ] ) {	  script_not_found : None
  isPrime [ 0 ] = isPrime [ 1 ] = false ;		      	isPrime [ 0 ] = isPrime [ 1 ] = false ;			      isPrime [ 0 ] = isPrime [ 1 ] = false ;			  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) isPrime [ i ] = true ;				      	i ++ ) isPrime [ i ] = true ;				      i ++ ) {							  
  for ( int p = 2 ;					      	for ( int p = 2 ;					    	isPrime [ i ] = true ;					  
  p * p <= n ;						      	p * p <= n ;						      }								  
  p ++ ) {						      	p ++ ) {						      for ( int p = 2 ;						  
    if ( isPrime [ p ] == true ) {			      	  if ( isPrime [ p ] == true ) {			      p * p <= n ;						  
      for ( int i = p * 2 ;				      	    for ( int i = p * 2 ;				      p ++ ) {							  
      i <= n ;						      	    i <= n ;						    	if ( isPrime [ p ] == true ) {				  
      i += p ) isPrime [ i ] = false ;			      	    i += p ) isPrime [ i ] = false ;			    	  for ( int i = p * 2 ;					  
    }							      	  }							    	  i <= n ;						  
  }							      	}							    	  i += p ) {						  
}							      }								    	    isPrime [ i ] = false ;				  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HARDY_RAMANUJAN_THEOREM					      HARDY_RAMANUJAN_THEOREM					    HARDY_RAMANUJAN_THEOREM					  HARDY_RAMANUJAN_THEOREM
--							      --							    --								  --
static int exactPrimeFactorCount ( int n ) {		      int exactPrimeFactorCount ( int n ) {			    int exactPrimeFactorCount ( int n ) {			  success : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  if ( n % 2 == 0 ) {					      	if ( n % 2 == 0 ) {					      if ( n % 2 == 0 ) {					  
    count ++ ;						      	  count ++ ;						    	count ++ ;						  
    while ( n % 2 == 0 ) n = n / 2 ;			      	  while ( n % 2 == 0 ) n = n / 2 ;			    	while ( n % 2 == 0 ) {					  
  }							      	}							    	  n = n / 2 ;						  
  for ( int i = 3 ;					      	for ( int i = 3 ;					    	}							  
  i <= Math . sqrt ( n ) ;				      	i <= sqrt ( n ) ;					      }								  
  i = i + 2 ) {						      	i = i + 2 ) {						      for ( int i = 3 ;						  
    if ( n % i == 0 ) {					      	  if ( n % i == 0 ) {					      i <= sqrt ( n ) ;						  
      count ++ ;					      	    count ++ ;						      i = i + 2 ) {						  
      while ( n % i == 0 ) n = n / i ;			      	    while ( n % i == 0 ) n = n / i ;			    	if ( n % i == 0 ) {					  
    }							      	  }							    	  count ++ ;						  
  }							      	}							    	  while ( n % i == 0 ) {				  
  if ( n > 2 ) count ++ ;				      	if ( n > 2 ) count ++ ;					    	    n = n / i ;						  
  return count ;					      	return count ;						    	  }							  
}							      }								    	}							  
							      								      }								  
							      								      if ( n > 2 ) {						  
							      								    	count ++ ;						  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ARRANGEMENT_QUEUE_GIVEN_TIME			      FIND_ARRANGEMENT_QUEUE_GIVEN_TIME				    FIND_ARRANGEMENT_QUEUE_GIVEN_TIME				  FIND_ARRANGEMENT_QUEUE_GIVEN_TIME
--							      --							    --								  --
static void solve ( int n , int t , char s [ ] ) {	      void solve ( int n , int t , string s ) {			    void solve ( int n , int t , char s [ ] ) {			  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < t ;						      	i < t ;							      i < t ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < n - 1 ;						      	j < n - 1 ;						      j < n - 1 ;						  
  j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) {	      	j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) {	      j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) {	  
    char temp = s [ j ] ;				      	  char temp = s [ j ] ;					    	char temp = s [ j ] ;					  
    s [ j ] = s [ j + 1 ] ;				      	  s [ j ] = s [ j + 1 ] ;				    	s [ j ] = s [ j + 1 ] ;					  
    s [ j + 1 ] = temp ;				      	  s [ j + 1 ] = temp ;					    	s [ j + 1 ] = temp ;					  
    j ++ ;						      	  j ++ ;						    	j ++ ;							  
  }							      	}							      }								  
  System . out . print ( s ) ;				      	cout << s ;						      cout << s << endl ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1		      UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1		    UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1		  UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1
--							      --							    --								  --
static void printIntersection ( int arr1 [ ] , int arr2 [ ] , int printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , void print_intersection ( int arr1 [ ] , int arr2 [ ] , int m script_not_found : None
  int i = 0 , j = 0 ;					      	int i = 0 , j = 0 ;					      int i = 0 , j = 0 ;					  
  while ( i < m && j < n ) {				      	while ( i < m && j < n ) {				      while ( i < m && j < n ) {				  
    if ( arr1 [ i ] < arr2 [ j ] ) i ++ ;		      	  if ( arr1 [ i ] < arr2 [ j ] ) i ++ ;			    	if ( arr1 [ i ] < arr2 [ j ] ) {			  
    else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ;		      	  else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ;		    	  i ++ ;						  
    else {						      	  else {						    	}							  
      System . out . print ( arr2 [ j ++ ] + " " ) ;	      	    cout << arr2 [ j ] << " " ;				    	else if ( arr2 [ j ] < arr1 [ i ] ) {			  
      i ++ ;						      	    i ++ ;						    	  j ++ ;						  
    }							      	    j ++ ;						    	}							  
  }							      	  }							    	else {							  
}							      	}							    	  cout << arr2 [ j ++ ] << " " ;			  
							      }								    	  i ++ ;						  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROBABILITY_REACHING_POINT_2_3_STEPS_TIME		      PROBABILITY_REACHING_POINT_2_3_STEPS_TIME			    PROBABILITY_REACHING_POINT_2_3_STEPS_TIME			  PROBABILITY_REACHING_POINT_2_3_STEPS_TIME
--							      --							    --								  --
static float find_prob ( int N , float P ) {		      float find_prob ( int N , float P ) {			    float find_prob ( int N , float P ) {			  script_not_found : None
  double dp [ ] = new double [ N + 1 ] ;		      	double dp [ N + 1 ] ;					      double dp [ N + 1 ] ;					  
  dp [ 0 ] = 1 ;					      	dp [ 0 ] = 1 ;						      dp [ 0 ] = 1 ;						  
  dp [ 1 ] = 0 ;					      	dp [ 1 ] = 0 ;						      dp [ 1 ] = 0 ;						  
  dp [ 2 ] = P ;					      	dp [ 2 ] = P ;						      dp [ 2 ] = P ;						  
  dp [ 3 ] = 1 - P ;					      	dp [ 3 ] = 1 - P ;					      dp [ 3 ] = 1 - P ;					  
  for ( int i = 4 ;					      	for ( int i = 4 ;					      for ( int i = 4 ;						  
  i <= N ;						      	i <= N ;						      i <= N ;							  
  ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i 	++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i   ++ i ) {							  
  return ( ( float ) ( dp [ N ] ) ) ;			      	return dp [ N ] ;					    	dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3  
}							      }								      }								  
							      								      return ( ( float ) ( dp [ N ] ) ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_STRINGS_WITH_CONSECUTIVE_1S			      COUNT_STRINGS_WITH_CONSECUTIVE_1S				    COUNT_STRINGS_WITH_CONSECUTIVE_1S				  COUNT_STRINGS_WITH_CONSECUTIVE_1S
--							      --							    --								  --
static int countStrings ( int n ) {			      int countStrings ( int n ) {				    int countStrings ( int n ) {				  error : COUNT_STRINGS_WITH_CONSECUTIVE_1S.cpp: In
  int a [ ] = new int [ n ] , b [ ] = new int [ n ] ;	      	int a [ n ] , b [ n ] ;					      int a [ n ] , b [ n ] ;					  function ‘int f_filled(int)’: COUNT_STRINGS_WITH_C
  a [ 0 ] = b [ 0 ] = 1 ;				      	a [ 0 ] = b [ 0 ] = 1 ;					      a [ 0 ] = b [ 0 ] = 1 ;					  ONSECUTIVE_1S.cpp:38:3: error: ‘from’ was not decl
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  ared in this scope	from = 2 ^ n ;	  ^~~~ COUNT
  i < n ;						      	i < n ;							      i < n ;							  _STRINGS_WITH_CONSECUTIVE_1S.cpp:38:3: note: sugge
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  sted alternative: ‘fromfp’	from = 2 ^ n ;	  ^~
    a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;		      	  a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;			    	a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;			  ~~	fromfp
    b [ i ] = a [ i - 1 ] ;				      	  b [ i ] = a [ i - 1 ] ;				    	b [ i ] = a [ i - 1 ] ;					  
  }							      	}							      }								  
  from 2 ^ n return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ;  	return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ;		      from = 2 ^ n ;						  
}							      }								      return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ;		  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_AREA_TRIANGLE				      C_PROGRAM_FIND_AREA_TRIANGLE				    C_PROGRAM_FIND_AREA_TRIANGLE				  C_PROGRAM_FIND_AREA_TRIANGLE
--							      --							    --								  --
static float findArea ( float a , float b , float c ) {	      float findArea ( float a , float b , float c ) {		    float findArea ( float a , float b , float c ) {		  script_not_found : None
  if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <=  	if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <=    if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <=  
    System . out . println ( "Not a valid triangle" ) ;	      	  cout << "Not a valid trianglen" ;			    	cout << "Not a valid triangle" << endl ;		  
    System . exit ( 0 ) ;				      	  exit ( 0 ) ;						    	exit ( 0 ) ;						  
  }							      	}							      }								  
  float s = ( a + b + c ) / 2 ;				      	float s = ( a + b + c ) / 2 ;				      float s = ( a + b + c ) / 2 ;				  
  return ( float ) Math . sqrt ( s * ( s - a ) * ( s - b ) *  	return sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ;	      return ( float ) sqrt ( s * ( s - a ) * ( s - b ) * ( s - c 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S		      FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S		    FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S		  FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S
--							      --							    --								  --
static void findMax ( int arr [ ] [ ] ) {		      void findMax ( int arr [ ] [ N ] ) {			    void findMax ( int arr [ N ] [ N ] ) {			  script_not_found : None
  int row = 0 , i , j ;					      	int row = 0 , i , j ;					      int row = 0 , i , j ;					  
  for ( i = 0 , j = N - 1 ;				      	for ( i = 0 , j = N - 1 ;				      for ( i = 0 , j = N - 1 ;					  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    while ( j >= 0 && arr [ i ] [ j ] == 1 ) {		      	  while ( arr [ i ] [ j ] == 1 && j >= 0 ) {		    	while ( j >= 0 && arr [ i ] [ j ] == 1 ) {		  
      row = i ;						      	    row = i ;						    	  row = i ;						  
      j -- ;						      	    j -- ;						    	  j -- ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  System . out . print ( "Row number = " + ( row + 1 ) ) ;    	cout << "Row number = " << row + 1 ;			      cout << "Row number = " << ( row + 1 ) << endl ;		  
  System . out . print ( ", MaxCount = " + ( N - 1 - j ) ) ;  	cout << ", MaxCount = " << N - 1 - j ;			      cout << ", MaxCount = " << ( N - 1 - j ) << endl ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE		      DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE		    DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE		  DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE
--							      --							    --								  --
static int eggDrop ( int n , int k ) {			      int eggDrop ( int n , int k ) {				    int eggDrop ( int n , int k ) {				  script_not_found : None
  if ( k == 1 || k == 0 ) return k ;			      	if ( k == 1 || k == 0 ) return k ;			      if ( k == 1 || k == 0 ) return k ;			  
  if ( n == 1 ) return k ;				      	if ( n == 1 ) return k ;				      if ( n == 1 ) return k ;					  
  int min = Integer . MAX_VALUE ;			      	int min = INT_MAX , x , res ;				      int min = INT_MAX ;					  
  int x , res ;						      	for ( x = 1 ;						      int x , res ;						  
  for ( x = 1 ;						      	x <= k ;						      for ( x = 1 ;						  
  x <= k ;						      	x ++ ) {						      x <= k ;							  
  x ++ ) {						      	  res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k -   x ++ ) {							  
    res = Math . max ( eggDrop ( n - 1 , x - 1 ) , eggDrop (  	  if ( res < min ) min = res ;				    	res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - 
    if ( res < min ) min = res ;			      	}							    	if ( res < min ) min = res ;				  
  }							      	return min + 1 ;					      }								  
  return min + 1 ;					      }								      return min + 1 ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_1S_SORTED_BINARY_ARRAY				      COUNT_1S_SORTED_BINARY_ARRAY				    COUNT_1S_SORTED_BINARY_ARRAY				  COUNT_1S_SORTED_BINARY_ARRAY
--							      --							    --								  --
int countOnes ( bool arr [ ] , int low , int high ) {	      int countOnes ( bool arr [ ] , int low , int high ) {	    int countOnes ( bool arr [ ] , int low , int high ) {	  script_not_found : None
  if ( high >= low ) {					      	if ( high >= low ) {					      if ( high >= low ) {					  
    int mid = low + ( high - low ) / 2 ;		      	  int mid = low + ( high - low ) / 2 ;			    	int mid = low + ( high - low ) / 2 ;			  
    if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ m 	  if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ m 	if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ m 
    if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid +  	  if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid +  	if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid +  
    return countOnes ( arr , low , ( mid - 1 ) ) ;	      	  return countOnes ( arr , low , ( mid - 1 ) ) ;	    	return countOnes ( arr , low , ( mid - 1 ) ) ;		  
  }							      	}							      }								  
  return 0 ;						      	return 0 ;						      return 0 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_FIBONACCI_NUMBERS					      SUM_FIBONACCI_NUMBERS					    SUM_FIBONACCI_NUMBERS					  SUM_FIBONACCI_NUMBERS
--							      --							    --								  --
static int calculateSum ( int n ) {			      int calculateSum ( int n ) {				    int calculateSum ( int n ) {				  success : None
  if ( n <= 0 ) return 0 ;				      	if ( n <= 0 ) return 0 ;				      if ( n <= 0 ) return 0 ;					  
  int fibo [ ] = new int [ n + 1 ] ;			      	int fibo [ n + 1 ] ;					      int fibo [ n + 1 ] ;					  
  fibo [ 0 ] = 0 ;					      	fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ;			      fibo [ 0 ] = 0 ;						  
  fibo [ 1 ] = 1 ;					      	int sum = fibo [ 0 ] + fibo [ 1 ] ;			      fibo [ 1 ] = 1 ;						  
  int sum = fibo [ 0 ] + fibo [ 1 ] ;			      	for ( int i = 2 ;					      int sum = fibo [ 0 ] + fibo [ 1 ] ;			  
  for ( int i = 2 ;					      	i <= n ;						      for ( int i = 2 ;						  
  i <= n ;						      	i ++ ) {						      i <= n ;							  
  i ++ ) {						      	  fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;	      i ++ ) {							  
    fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;	      	  sum += fibo [ i ] ;					    	fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;		  
    sum += fibo [ i ] ;					      	}							    	sum += fibo [ i ] ;					  
  }							      	return sum ;						      }								  
  return sum ;						      }								      return sum ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY	      MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY	    MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY	  MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY
--							      --							    --								  --
static int minJumps ( int arr [ ] , int l , int h ) {	      int minJumps ( int arr [ ] , int n ) {			    int minJumps ( int arr [ ] , int l , int h ) {		  script_not_found : None
  if ( h == l ) return 0 ;				      	if ( n == 1 ) return 0 ;				      if ( h == l ) return 0 ;					  
  if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ;	      	int res = INT_MAX ;					      if ( arr [ l ] == 0 ) return INT_MAX ;			  
  int min = Integer . MAX_VALUE ;			      	for ( int i = n - 2 ;					      int min = INT_MAX ;					  
  for ( int i = l + 1 ;					      	i >= 0 ;						      for ( int i = l + 1 ;					  
  i <= h && i <= l + arr [ l ] ;			      	i -- ) {						      i <= h && i <= l + arr [ l ] ;				  
  i ++ ) {						      	  if ( i + arr [ i ] >= n - 1 ) {			      i ++ ) {							  
    int jumps = minJumps ( arr , i , h ) ;		      	    int sub_res = minJumps ( arr , i + 1 ) ;		    	int jumps = minJumps ( arr , i , h ) ;			  
    if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) mi 	    if ( sub_res != INT_MAX ) res = min ( res , sub_res + 1 	if ( jumps != INT_MAX && jumps + 1 < min ) {		  
  }							      	  }							    	  min = jumps + 1 ;					  
  return min ;						      	}							    	}							  
}							      	return res ;						      }								  
							      }								      return min ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES		      FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES		    FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES		  FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES
--							      --							    --								  --
static int findSDSFunc ( int n ) {			      int findSDSFunc ( int n ) {				    int findSDSFunc ( int n ) {					  success : None
  int DP [ ] = new int [ n + 1 ] ;			      	int DP [ n + 1 ] ;					      int DP [ n + 1 ] ;					  
  DP [ 0 ] = 0 ;					      	DP [ 0 ] = 0 ;						      DP [ 0 ] = 0 ;						  
  DP [ 1 ] = 1 ;					      	DP [ 1 ] = 1 ;						      DP [ 1 ] = 1 ;						  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ;		      	  if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ;		    	if ( i % 2 == 0 ) {					  
    else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 	  else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 	  DP [ i ] = DP [ i / 2 ] ;				  
  }							      	}							    	}							  
  return DP [ n ] ;					      	return DP [ n ] ;					    	else {							  
}							      }								    	  DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ]  
							      								    	}							  
							      								      }								  
							      								      return DP [ n ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS		      PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS			    PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS			  PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS
--							      --							    --								  --
public static void amendSentence ( String sstr ) {	      void amendSentence ( string str ) {			    void amendSentence ( string sstr ) {			  script_not_found : None
  char [ ] str = sstr . toCharArray ( ) ;		      	for ( int i = 0 ;					      string :: size_type pos = 0 ;				  
  for ( int i = 0 ;					      	i < str . length ( ) ;					      for ( string :: size_type i = 0 ;				  
  i < str . length ;					      	i ++ ) {						      i < sstr . length ( ) ;					  
  i ++ ) {						      	  if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {		      i ++ ) {							  
    if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {	      	    str [ i ] = str [ i ] + 32 ;			    	if ( sstr [ i ] >= 'A' && sstr [ i ] <= 'Z' ) {		  
      str [ i ] = ( char ) ( str [ i ] + 32 ) ;		      	    if ( i != 0 ) cout << " " ;				    	  pos = ( pos + 32 ) ;					  
      if ( i != 0 ) System . out . print ( " " ) ;	      	    cout << str [ i ] ;					    	  if ( i != 0 ) cout << " " ;				  
      System . out . print ( str [ i ] ) ;		      	  }							    	  cout << sstr [ i ] ;					  
    }							      	  else cout << str [ i ] ;				    	}							  
    else System . out . print ( str [ i ] ) ;		      	}							    	else cout << sstr [ i ] ;				  
  }							      }								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING		      SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING		    SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING		  SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING
--							      --							    --								  --
static int sumAtKthLevel ( String tree , int k ) {	      int sumAtKthLevel ( string tree , int k ) {		    int sumAtKthLevel ( string tree , int k ) {			  success : None
  int level = - 1 ;					      	int level = - 1 ;					      int level = - 1 ;						  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  int n = tree . length ( ) ;				      	int n = tree . length ( ) ;				      int n = tree . length ( ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( tree . charAt ( i ) == '(' ) level ++ ;	      	  if ( tree [ i ] == '(' ) level ++ ;			    	if ( tree [ i ] == '(' ) {				  
    else if ( tree . charAt ( i ) == ')' ) level -- ;	      	  else if ( tree [ i ] == ')' ) level -- ;		    	  level ++ ;						  
    else {						      	  else {						    	}							  
      if ( level == k ) sum += ( tree . charAt ( i ) - '0' )  	    if ( level == k ) sum += ( tree [ i ] - '0' ) ;	    	else if ( tree [ i ] == ')' ) {				  
    }							      	  }							    	  level -- ;						  
  }							      	}							    	}							  
  return sum ;						      	return sum ;						    	else {							  
}							      }								    	  if ( level == k ) {					  
							      								    	    sum += ( tree [ i ] - '0' ) ;			  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES		      NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES		    NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES		  NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES
--							      --							    --								  --
static int countOccurrences ( String s , int K ) {	      int countOccurrences ( string s , int K ) {		    int countOccurrences ( string s , int K ) {			  failure : #Results: 0, 10
  int n = s . length ( ) ;				      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
  int C = 0 , c1 = 0 , c2 = 0 ;				      	int C , c1 = 0 , c2 = 0 ;				      int C = 0 , c1 = 0 , c2 = 0 ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( s . charAt ( i ) == 'a' ) c1 ++ ;		      	  if ( s [ i ] == 'a' ) c1 ++ ;				    	if ( s [ i ] == 'a' ) {					  
    if ( s . charAt ( i ) == 'b' ) {			      	  if ( s [ i ] == 'b' ) {				    	  c1 ++ ;						  
      c2 ++ ;						      	    c2 ++ ;						    	}							  
      C += c1 ;						      	    C += c1 ;						    	if ( s [ i ] == 'b' ) {					  
    }							      	  }							    	  c2 ++ ;						  
  }							      	}							    	  C += c1 ;						  
  return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;	      	return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;	    	}							  
}							      }								      }								  
							      								      return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;		  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX			      CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX			    CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX				  CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX
--							      --							    --								  --
static boolean areSumSame ( int a [ ] [ ] , int n , int m ) { bool areSumSame ( int a [ ] [ MAX ] , int n , int m ) {	    bool areSumSame ( int a [ ] [ 2 ] , int n , int m ) {	  script_not_found : None
  int sum1 = 0 , sum2 = 0 ;				      	int sum1 = 0 , sum2 = 0 ;				      int sum1 = 0 , sum2 = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    sum1 = 0 ;						      	  sum1 = 0 , sum2 = 0 ;					    	sum1 = 0 ;						  
    sum2 = 0 ;						      	  for ( int j = 0 ;					    	sum2 = 0 ;						  
    for ( int j = 0 ;					      	  j < m ;						    	for ( int j = 0 ;					  
    j < m ;						      	  j ++ ) {						    	j < m ;							  
    j ++ ) {						      	    sum1 += a [ i ] [ j ] ;				    	j ++ ) {						  
      sum1 += a [ i ] [ j ] ;				      	    sum2 += a [ j ] [ i ] ;				    	  sum1 += a [ i ] [ j ] ;				  
      sum2 += a [ j ] [ i ] ;				      	  }							    	  sum2 += a [ j ] [ i ] ;				  
    }							      	  if ( sum1 == sum2 ) return true ;			    	}							  
    if ( sum1 == sum2 ) return true ;			      	}							    	if ( sum1 == sum2 ) return true ;			  
  }							      	return false ;						      }								  
  return false ;					      }								      return false ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL
--							      --							    --								  --
public static int nobleInteger ( int arr [ ] ) {	      int nobleInteger ( int arr [ ] , int n ) {		    int noble_integer ( int arr [ ] ) {				  script_not_found : None
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + sizeof ( arr ) / sizeof ( arr [ 0 ] ) )  
  int n = arr . length ;				      	for ( int i = 0 ;					      int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  for ( int i = 0 ;					      	i < n - 1 ;						      for ( int i = 0 ;						  
  i < n - 1 ;						      	i ++ ) {						      i < n - 1 ;						  
  i ++ ) {						      	  if ( arr [ i ] == arr [ i + 1 ] ) continue ;		      i ++ ) {							  
    if ( arr [ i ] == arr [ i + 1 ] ) continue ;	      	  if ( arr [ i ] == n - i - 1 ) return arr [ i ] ;	    	if ( arr [ i ] == arr [ i + 1 ] ) continue ;		  
    if ( arr [ i ] == n - i - 1 ) return arr [ i ] ;	      	}							    	if ( arr [ i ] == n - i - 1 ) return arr [ i ] ;	  
  }							      	if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ;	      }								  
  if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ;	      	return - 1 ;						      if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ;		  
  return - 1 ;						      }								      return - 1 ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE
--							      --							    --								  --
static int countWays ( int n , int m ) {		      int countWays ( int n , int m ) {				    int countWays ( int n , int m ) {				  success : None
  int count [ ] = new int [ n + 1 ] ;			      	int count [ n + 1 ] ;					      int count [ n + 1 ] ;					  
  count [ 0 ] = 0 ;					      	count [ 0 ] = 0 ;					      count [ 0 ] = 0 ;						  
  int i ;						      	for ( int i = 1 ;					      int i ;							  
  for ( i = 1 ;						      	i <= n ;						      for ( i = 1 ;						  
  i <= n ;						      	i ++ ) {						      i <= n ;							  
  i ++ ) {						      	  if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i -    i ++ ) {							  
    if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i -  	  else if ( i < m ) count [ i ] = 1 ;			    	if ( i > m ) {						  
    else if ( i < m ) count [ i ] = 1 ;			      	  else count [ i ] = 2 ;				    	  count [ i ] = count [ i - 1 ] + count [ i - m ] ;	  
    else count [ i ] = 2 ;				      	}							    	}							  
  }							      	return count [ n ] ;					    	else if ( i < m ) {					  
  return count [ n ] ;					      }								    	  count [ i ] = 1 ;					  
}							      								    	}							  
							      								    	else {							  
							      								    	  count [ i ] = 2 ;					  
							      								    	}							  
							      								      }								  
							      								      return count [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CAESAR_CIPHER						      CAESAR_CIPHER						    CAESAR_CIPHER						  CAESAR_CIPHER
--							      --							    --								  --
public static StringBuffer encrypt ( String text , int s ) {  string encrypt ( string text , int s ) {			    string encrypt ( string text , int s ) {			  success : None
  StringBuffer result = new StringBuffer ( ) ;		      	string result = "" ;					      string result ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < text . length ( ) ;				      	i < text . length ( ) ;					      i < text . length ( ) ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( Character . isUpperCase ( text . charAt ( i ) ) ) {  	  if ( isupper ( text [ i ] ) ) result += char ( int ( text 	if ( isupper ( text [ i ] ) ) {				  
      char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s  	  else result += char ( int ( text [ i ] + s - 97 ) % 26 +  	  char ch = ( char ) ( ( ( int ) text [ i ] + s - 65 ) %  
      result . append ( ch ) ;				      	}							    	  result += ch ;					  
    }							      	return result ;						    	}							  
    else {						      }								    	else {							  
      char ch = ( char ) ( ( ( int ) text . charAt ( i ) + s  								    	  char ch = ( char ) ( ( ( int ) text [ i ] + s - 97 ) %  
      result . append ( ch ) ;				      								    	  result += ch ;					  
    }							      								    	}							  
  }							      								      }								  
  return result ;					      								      return result ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1	      COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1	    COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1	  COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1
--							      --							    --								  --
static int countSubstringWithEqualEnds ( String s ) {	      int countSubstringWithEqualEnds ( string s ) {		    int countSubstringWithEqualEnds ( string s ) {		  script_not_found : None
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  int n = s . length ( ) ;				      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
  int [ ] count = new int [ MAX_CHAR ] ;		      	int count [ MAX_CHAR ] = {				      int count [ MAX_CHAR ] ;					  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < n ;						      	  ;							      i < n ;							  
  i ++ ) count [ s . charAt ( i ) - 'a' ] ++ ;		      	  for ( int i = 0 ;					      i ++ ) {							  
  for ( int i = 0 ;					      	  i < n ;						    	count [ s [ i ] - 'a' ] ++ ;				  
  i < MAX_CHAR ;					      	  i ++ ) count [ s [ i ] - 'a' ] ++ ;			      }								  
  i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 )  	  for ( int i = 0 ;					      for ( int i = 0 ;						  
  return result ;					      	  i < MAX_CHAR ;					      i < MAX_CHAR ;						  
}							      	  i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2    i ++ ) {							  
							      	  return result ;					    	result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ;	  
							      	}							      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1		      MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1		    MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1		  MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1
--							      --							    --								  --
static int maxDiff ( int [ ] arr , int n ) {		      int maxDiff ( int arr [ ] , int n ) {			    int maxDiff ( int * arr , int n ) {				  success : None
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs (  	  if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i 	if ( arr [ i ] != arr [ i + 1 ] ) {			  
    else i ++ ;						      	  else i ++ ;						    	  result += abs ( arr [ i ] ) ;				  
  }							      	}							    	}							  
  if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs  	if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += abs ( arr [ 	else {							  
  return result ;					      	return result ;						    	  i ++ ;						  
}							      }								    	}							  
							      								      }								  
							      								      if ( arr [ n - 2 ] != arr [ n - 1 ] ) {			  
							      								    	result += abs ( arr [ n - 1 ] ) ;			  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX		      MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX		    MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX		  MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX
--							      --							    --								  --
static int maxDecimalValue ( int mat [ ] [ ] , int i , int j  long long int maxDecimalValue ( int mat [ ] [ N ] , int i , i int maxDecimalValue ( int mat [ ] [ N ] , int i , int j , int script_not_found : None
  if ( i >= N || j >= N ) {				      	if ( i >= N || j >= N ) return 0 ;			      if ( i >= N || j >= N ) return 0 ;			  
    return 0 ;						      	int result = max ( maxDecimalValue ( mat , i , j + 1 , p +    int result = max ( maxDecimalValue ( mat , i , j + 1 , p +  
  }							      	if ( mat [ i ] [ j ] == 1 ) return pow ( 2 , p ) + result ;   if ( mat [ i ] [ j ] == 1 ) return ( int ) ( pow ( 2 , p )  
  int result = Math . max ( maxDecimalValue ( mat , i , j + 1 	else return result ;					      else return result ;					  
  if ( mat [ i ] [ j ] == 1 ) {				      }								    }								  
    return ( int ) ( Math . pow ( 2 , p ) + result ) ;	      								    								  
  }							      								    								  
  else {						      								    								  
    return result ;					      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING		      FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING		    FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING		  FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING
--							      --							    --								  --
static int count ( String a , String b , int m , int n ) {    int count ( string a , string b , int m , int n ) {	    int count ( string a , string b , int m , int n ) {		  script_not_found : None
  if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ;	      	if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ;	      if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ;		  
  if ( m == 0 ) return 0 ;				      	if ( m == 0 ) return 0 ;				      if ( m == 0 ) return 0 ;					  
  if ( a . charAt ( m - 1 ) == b . charAt ( n - 1 ) ) return  	if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m    if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m  
  else return count ( a , b , m - 1 , n ) ;		      	else return count ( a , b , m - 1 , n ) ;		      else return count ( a , b , m - 1 , n ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_ELEMENT_ROW_MATRIX				      FIND_MAXIMUM_ELEMENT_ROW_MATRIX				    FIND_MAXIMUM_ELEMENT_ROW_MATRIX				  FIND_MAXIMUM_ELEMENT_ROW_MATRIX
--							      --							    --								  --
public static void maxelement ( int no_of_rows , int [ ] [ ]  void maxelement ( int no_of_rows , int arr [ ] [ N ] ) {	    void maxelement ( int no_of_rows , vector < vector < int >> a script_not_found : None
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  int max = 0 ;						      	int max = 0 ;						      int max = 0 ;						  
  int [ ] result = new int [ no_of_rows ] ;		      	int result [ no_of_rows ] ;				      vector < int > result ;					  
  while ( i < no_of_rows ) {				      	while ( i < no_of_rows ) {				      result . reserve ( no_of_rows ) ;				  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      while ( i < no_of_rows ) {				  
    j < arr [ i ] . length ;				      	  j < N ;						    	for ( int j = 0 ;					  
    j ++ ) {						      	  j ++ ) {						    	j < arr [ i ] . size ( ) ;				  
      if ( arr [ i ] [ j ] > max ) {			      	    if ( arr [ i ] [ j ] > max ) {			    	j ++ ) {						  
	max = arr [ i ] [ j ] ;				      	      max = arr [ i ] [ j ] ;				    	  if ( arr [ i ] [ j ] > max ) max = arr [ i ] [ j ] ;	  
      }							      	    }							    	}							  
    }							      	  }							    	result . push_back ( max ) ;				  
    result [ i ] = max ;				      	  result [ i ] = max ;					    	max = 0 ;						  
    max = 0 ;						      	  max = 0 ;						    	i ++ ;							  
    i ++ ;						      	  i ++ ;						      }								  
  }							      	}							      print_vector ( result ) ;					  
  printArray ( result ) ;				      	printArray ( result , no_of_rows ) ;			    }								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_PRIME_FACTOR_GIVEN_NUMBER				      K_TH_PRIME_FACTOR_GIVEN_NUMBER				    K_TH_PRIME_FACTOR_GIVEN_NUMBER				  K_TH_PRIME_FACTOR_GIVEN_NUMBER
--							      --							    --								  --
static int kPrimeFactor ( int n , int k ) {		      int kPrimeFactor ( int n , int k ) {			    int kPrimeFactor ( int n , int k ) {			  success : identical to gold
  while ( n % 2 == 0 ) {				      	while ( n % 2 == 0 ) {					      while ( n % 2 == 0 ) {					  
    k -- ;						      	  k -- ;						    	k -- ;							  
    n = n / 2 ;						      	  n = n / 2 ;						    	n = n / 2 ;						  
    if ( k == 0 ) return 2 ;				      	  if ( k == 0 ) return 2 ;				    	if ( k == 0 ) return 2 ;				  
  }							      	}							      }								  
  for ( int i = 3 ;					      	for ( int i = 3 ;					      for ( int i = 3 ;						  
  i <= Math . sqrt ( n ) ;				      	i <= sqrt ( n ) ;					      i <= sqrt ( n ) ;						  
  i = i + 2 ) {						      	i = i + 2 ) {						      i = i + 2 ) {						  
    while ( n % i == 0 ) {				      	  while ( n % i == 0 ) {				    	while ( n % i == 0 ) {					  
      if ( k == 1 ) return i ;				      	    if ( k == 1 ) return i ;				    	  if ( k == 1 ) return i ;				  
      k -- ;						      	    k -- ;						    	  k -- ;						  
      n = n / i ;					      	    n = n / i ;						    	  n = n / i ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  if ( n > 2 && k == 1 ) return n ;			      	if ( n > 2 && k == 1 ) return n ;			      if ( n > 2 && k == 1 ) return n ;				  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EQUILIBRIUM_INDEX_OF_AN_ARRAY				      EQUILIBRIUM_INDEX_OF_AN_ARRAY				    EQUILIBRIUM_INDEX_OF_AN_ARRAY				  EQUILIBRIUM_INDEX_OF_AN_ARRAY
--							      --							    --								  --
int equilibrium ( int arr [ ] , int n ) {		      int equilibrium ( int arr [ ] , int n ) {			    int equilibrium ( int arr [ ] , int n ) {			  success : None
  int i , j ;						      	int i , j ;						      int i , j ;						  
  int leftsum , rightsum ;				      	int leftsum , rightsum ;				      int leftsum , rightsum ;					  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  ++ i ) {						      	++ i ) {						      ++ i ) {							  
    leftsum = 0 ;					      	  leftsum = 0 ;						    	leftsum = 0 ;						  
    for ( j = 0 ;					      	  for ( j = 0 ;						    	for ( j = 0 ;						  
    j < i ;						      	  j < i ;						    	j < i ;							  
    j ++ ) leftsum += arr [ j ] ;			      	  j ++ ) leftsum += arr [ j ] ;				    	j ++ ) {						  
    rightsum = 0 ;					      	  rightsum = 0 ;					    	  leftsum += arr [ j ] ;				  
    for ( j = i + 1 ;					      	  for ( j = i + 1 ;					    	}							  
    j < n ;						      	  j < n ;						    	rightsum = 0 ;						  
    j ++ ) rightsum += arr [ j ] ;			      	  j ++ ) rightsum += arr [ j ] ;			    	for ( j = i + 1 ;					  
    if ( leftsum == rightsum ) return i ;		      	  if ( leftsum == rightsum ) return i ;			    	j < n ;							  
  }							      	}							    	j ++ ) {						  
  return - 1 ;						      	return - 1 ;						    	  rightsum += arr [ j ] ;				  
}							      }								    	}							  
							      								    	if ( leftsum == rightsum ) {				  
							      								    	  return i ;						  
							      								    	}							  
							      								      }								  
							      								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG
--							      --							    --								  --
static void generate ( Set < String > st , String s ) {	      void generate ( set < string > & st , string s ) {	    void generate ( set < string > & st , string s ) {		  script_not_found : None
  if ( s . length ( ) == 0 ) {				      	if ( s . size ( ) == 0 ) return ;			      if ( s . length ( ) == 0 ) return ;			  
    return ;						      	if ( st . find ( s ) == st . end ( ) ) {		      if ( ! st . count ( s ) ) {				  
  }							      	  st . insert ( s ) ;					    	st . insert ( s ) ;					  
  if ( ! st . contains ( s ) ) {			      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
    st . add ( s ) ;					      	  i < s . size ( ) ;					    	i < s . length ( ) ;					  
    for ( int i = 0 ;					      	  i ++ ) {						    	i ++ ) {						  
    i < s . length ( ) ;				      	    string t = s ;					    	  string t = s ;					  
    i ++ ) {						      	    t . erase ( i , 1 ) ;				    	  t = t . substr ( 0 , i ) + t . substr ( i + 1 ) ;	  
      String t = s ;					      	    generate ( st , t ) ;				    	  generate ( st , t ) ;					  
      t = t . substring ( 0 , i ) + t . substring ( i + 1 ) ; 	  }							    	}							  
      generate ( st , t ) ;				      	}							      }								  
    }							      	return ;						      return ;							  
  }							      }								    }								  
  return ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION	      DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION	    DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION	  DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION
--							      --							    --								  --
static int MatrixChainOrder ( int p [ ] , int i , int j ) {   int MatrixChainOrder ( int p [ ] , int i , int j ) {	    int MatrixChainOrder ( int p [ ] , int i , int j ) {	  success : None
  if ( i == j ) return 0 ;				      	if ( i == j ) return 0 ;				      if ( i == j ) return 0 ;					  
  int min = Integer . MAX_VALUE ;			      	int k ;							      int min = INT_MAX ;					  
  for ( int k = i ;					      	int min = INT_MAX ;					      for ( int k = i ;						  
  k < j ;						      	int count ;						      k < j ;							  
  k ++ ) {						      	for ( k = i ;						      k ++ ) {							  
    int count = MatrixChainOrder ( p , i , k ) + MatrixChainO 	k < j ;							    	int count = MatrixChainOrder ( p , i , k ) + MatrixChainO 
    if ( count < min ) min = count ;			      	k ++ ) {						    	if ( count < min ) min = count ;			  
  }							      	  count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder   }								  
  return min ;						      	  if ( count < min ) min = count ;			      return min ;						  
}							      	}							    }								  
							      	return min ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY		      FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY		    FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY			  FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY
--							      --							    --								  --
static int maxProduct ( int [ ] arr , int n ) {		      int maxProduct ( int arr [ ] , int n ) {			    int maxProduct ( int * arr , int n ) {			  success : None
  if ( n < 3 ) return - 1 ;				      	if ( n < 3 ) return - 1 ;				      if ( n < 3 ) return - 1 ;					  
  int max_product = Integer . MIN_VALUE ;		      	int max_product = INT_MIN ;				      int maxProduct = INT_MIN ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 2 ;						      	i < n - 2 ;						      i < n - 2 ;						  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < n - 1 ;						      	j < n - 1 ;						      j < n - 1 ;						  
  j ++ ) for ( int k = j + 1 ;				      	j ++ ) for ( int k = j + 1 ;				      j ++ ) for ( int k = j + 1 ;				  
  k < n ;						      	k < n ;							      k < n ;							  
  k ++ ) max_product = Math . max ( max_product , arr [ i ] * 	k ++ ) max_product = max ( max_product , arr [ i ] * arr [    k ++ ) maxProduct = max ( maxProduct , arr [ i ] * arr [ j  
  return max_product ;					      	return max_product ;					      return maxProduct ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1		      PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1		    PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1		  PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1
--							      --							    --								  --
static boolean isScalarMatrix ( int mat [ ] [ ] ) {	      bool isScalarMatrix ( int mat [ N ] [ N ] ) {		    bool isScalarMatrix ( int mat [ N ] [ N ] ) {		  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < N ;						      	j < N ;							      j < N ;							  
  j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return 	j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return   j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) return f 
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N - 1 ;						      	i < N - 1 ;						      i < N - 1 ;						  
  i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) re 	i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) re   i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) re 
  return true ;						      	return true ;						      return true ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1			      LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1			    LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1			  LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1
--							      --							    --								  --
static int maxLength ( String s , int n ) {		      int maxLength ( char s [ ] , int n ) {			    int maxLength ( string s , int n ) {			  success : None
  int invalidOpenBraces = 0 ;				      	int invalidOpenBraces = 0 ;				      int invalidOpenBraces = 0 ;				  
  int invalidCloseBraces = 0 ;				      	int invalidCloseBraces = 0 ;				      int invalidCloseBraces = 0 ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( s . charAt ( i ) == '(' ) {			      	  if ( s [ i ] == '(' ) {				    	if ( s [ i ] == '(' ) invalidOpenBraces ++ ;		  
      invalidOpenBraces ++ ;				      	    invalidOpenBraces ++ ;				    	else {							  
    }							      	  }							    	  if ( invalidOpenBraces == 0 ) invalidCloseBraces ++ ;	  
    else {						      	  else {						    	  else invalidOpenBraces -- ;				  
      if ( invalidOpenBraces == 0 ) {			      	    if ( invalidOpenBraces == 0 ) {			    	}							  
	invalidCloseBraces ++ ;				      	      invalidCloseBraces ++ ;				      }								  
      }							      	    }							      return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; 
      else {						      	    else {						    }								  
	invalidOpenBraces -- ;				      	      invalidOpenBraces -- ;				    								  
      }							      	    }							    								  
    }							      	  }							    								  
  }							      	}							    								  
  return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; 	return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; 								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATE_PYTHAGOREAN_TRIPLETS				      GENERATE_PYTHAGOREAN_TRIPLETS				    GENERATE_PYTHAGOREAN_TRIPLETS				  GENERATE_PYTHAGOREAN_TRIPLETS
--							      --							    --								  --
static void pythagoreanTriplets ( int limit ) {		      void pythagoreanTriplets ( int limit ) {			    void pythagorean_triplets ( int limit ) {			  script_not_found : None
  int a , b , c = 0 ;					      	int a , b , c = 0 ;					      int a , b , c = 0 ;					  
  int m = 2 ;						      	int m = 2 ;						      int m = 2 ;						  
  while ( c < limit ) {					      	while ( c < limit ) {					      while ( c < limit ) {					  
    for ( int n = 1 ;					      	  for ( int n = 1 ;					    	for ( int n = 1 ;					  
    n < m ;						      	  n < m ;						    	n < m ;							  
    ++ n ) {						      	  ++ n ) {						    	++ n ) {						  
      a = m * m - n * n ;				      	    a = m * m - n * n ;					    	  a = m * m - n * n ;					  
      b = 2 * m * n ;					      	    b = 2 * m * n ;					    	  b = 2 * m * n ;					  
      c = m * m + n * n ;				      	    c = m * m + n * n ;					    	  c = m * m + n * n ;					  
      if ( c > limit ) break ;				      	    if ( c > limit ) break ;				    	  if ( c > limit ) break ;				  
      System . out . println ( a + " " + b + " " + c ) ;      	    printf ( "%d %d %d\n" , a , b , c ) ;		    	  cout << a << " " << b << " " << c << endl ;		  
    }							      	  }							    	}							  
    m ++ ;						      	  m ++ ;						    	m ++ ;							  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING	      RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING	    RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING	  RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING
--							      --							    --								  --
static char getMaxOccuringChar ( String str ) {		      char getMaxOccuringChar ( char * str ) {			    char getMaxOccuringChar ( const std :: string & str ) {	  script_not_found : None
  int count [ ] = new int [ ASCII_SIZE ] ;		      	int count [ ASCII_SIZE ] = {				      std :: vector < int > count ( ASCII_SIZE ) ;		  
  int len = str . length ( ) ;				      	  0 }							      std :: string :: size_type pos = 0 ;			  
  for ( int i = 0 ;					      	  ;							      for ( std :: string :: size_type i = 0 ;			  
  i < len ;						      	  int len = strlen ( str ) ;				      i < str . length ( ) ;					  
  i ++ ) count [ str . charAt ( i ) ] ++ ;		      	  int max = 0 ;						      i ++ ) {							  
  int max = - 1 ;					      	  char result ;						    	count [ str [ i ] ] ++ ;				  
  char result = ' ' ;					      	  for ( int i = 0 ;					      }								  
  for ( int i = 0 ;					      	  i < len ;						      int max = - 1 ;						  
  i < len ;						      	  i ++ ) {						      char result = ' ' ;					  
  i ++ ) {						      	    count [ str [ i ] ] ++ ;				      for ( std :: string :: size_type i = 0 ;			  
    if ( max < count [ str . charAt ( i ) ] ) {		      	    if ( max < count [ str [ i ] ] ) {			      i < str . length ( ) ;					  
      max = count [ str . charAt ( i ) ] ;		      	      max = count [ str [ i ] ] ;			      i ++ ) {							  
      result = str . charAt ( i ) ;			      	      result = str [ i ] ;				    	if ( max < count [ str [ i ] ] ) {			  
    }							      	    }							    	  max = count [ str [ i ] ] ;				  
  }							      	  }							    	  result = str [ i ] ;					  
  return result ;					      	  return result ;					    	}							  
}							      	}							      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS		      NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS		    NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS		  NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS
--							      --							    --								  --
static int snoob ( int x ) {				      uint_t snoob ( uint_t x ) {				    int snoob ( int x ) {					  script_not_found : None
  int rightOne , nextHigherOneBit , rightOnesPattern , next = 	uint_t rightOne ;					      int rightOne , nextHigherOneBit , rightOnesPattern , next = 
  if ( x > 0 ) {					      	uint_t nextHigherOneBit ;				      if ( x > 0 ) {						  
    rightOne = x & - x ;				      	uint_t rightOnesPattern ;				    	rightOne = x & - x ;					  
    nextHigherOneBit = x + rightOne ;			      	uint_t next = 0 ;					    	nextHigherOneBit = x + rightOne ;			  
    rightOnesPattern = x ^ nextHigherOneBit ;		      	if ( x ) {						    	rightOnesPattern = x ^ nextHigherOneBit ;		  
    rightOnesPattern = ( rightOnesPattern ) / rightOne ;      	  rightOne = x & - ( signed ) x ;			    	rightOnesPattern = ( rightOnesPattern ) / rightOne ;	  
    rightOnesPattern >>= 2 ;				      	  nextHigherOneBit = x + rightOne ;			    	rightOnesPattern >>= 2 ;				  
    next = nextHigherOneBit | rightOnesPattern ;	      	  rightOnesPattern = x ^ nextHigherOneBit ;		    	next = nextHigherOneBit | rightOnesPattern ;		  
  }							      	  rightOnesPattern = ( rightOnesPattern ) / rightOne ;	      }								  
  return next ;						      	  rightOnesPattern >>= 2 ;				      return next ;						  
}							      	  next = nextHigherOneBit | rightOnesPattern ;		    }								  
							      	}							    								  
							      	return next ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM		      SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM		    SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM			  SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM
--							      --							    --								  --
void computeLPSArray ( String pat , int M , int lps [ ] ) {   void computeLPSArray ( char * pat , int M , int * lps ) {	    void computeLPSArray ( string pat , int M , int lps [ ] ) {	  script_not_found : None
  int len = 0 ;						      	int len = 0 ;						      int len = 0 ;						  
  int i = 1 ;						      	lps [ 0 ] = 0 ;						      int i = 1 ;						  
  lps [ 0 ] = 0 ;					      	int i = 1 ;						      lps [ 0 ] = 0 ;						  
  while ( i < M ) {					      	while ( i < M ) {					      while ( i < M ) {						  
    if ( pat . charAt ( i ) == pat . charAt ( len ) ) {	      	  if ( pat [ i ] == pat [ len ] ) {			    	if ( pat [ i ] == pat [ len ] ) {			  
      len ++ ;						      	    len ++ ;						    	  len ++ ;						  
      lps [ i ] = len ;					      	    lps [ i ] = len ;					    	  lps [ i ] = len ;					  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
    }							      	  }							    	}							  
    else {						      	  else {						    	else {							  
      if ( len != 0 ) {					      	    if ( len != 0 ) {					    	  if ( len != 0 ) len = lps [ len - 1 ] ;		  
	len = lps [ len - 1 ] ;				      	      len = lps [ len - 1 ] ;				    	  else {						  
      }							      	    }							    	    lps [ i ] = len ;					  
      else {						      	    else {						    	    i ++ ;						  
	lps [ i ] = len ;				      	      lps [ i ] = 0 ;					    	  }							  
	i ++ ;						      	      i ++ ;						    	}							  
      }							      	    }							      }								  
    }							      	  }							    }								  
  }							      	}							    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY		      MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY		    MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY			  MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY
--							      --							    --								  --
public static int minOperation ( int arr [ ] , int n ) {      int minOperation ( int arr [ ] , int n ) {		    int minOperation ( int arr [ ] , int n ) {			  error : MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRA
  HashMap < Integer , Integer > hash = new HashMap < Integer  	unordered_map < int , int > hash ;			      unordered_map < int , int > hash ;			  Y.cpp: In function ‘int f_filled(int*, int)’: MINI
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  MUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:34:54:
  i < n ;						      	i < n ;							      i < n ;							   error: conversion from ‘_Node_iterator<std::pair<
  i ++ ) if ( hash . containsKey ( arr [ i ] ) ) hash . put ( 	i ++ ) hash [ arr [ i ] ] ++ ;				      i ++ ) if ( hash . count ( arr [ i ] ) == 0 ) hash [ arr [  const int, int>,false,[...]>’ to non-scalar type ‘
  else hash . put ( arr [ i ] , 1 ) ;			      	int max_count = 0 ;					      else hash [ arr [ i ] ] = 1 ;				  _Node_iterator<int,true,[...]>’ requested    unord
  int max_count = 0 ;					      	for ( auto i : hash ) if ( max_count < i . second ) max_cou   int max_count = 0 ;					  ered_set < int > :: iterator s = hash . begin ( )
  Set < Integer > s = hash . keySet ( ) ;		      	return ( n - max_count ) ;				      unordered_set < int > :: iterator s = hash . begin ( ) ;	  ;					     ~~~~~~~
  for ( int i : s ) if ( max_count < hash . get ( i ) ) max_c }								      for ( unordered_set < int > :: iterator i = hash . begin (  ~~~~~~^~~ MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_AR
  return ( n - max_count ) ;				      								      i != hash . end ( ) ;					  RAY.cpp:35:60: error: conversion from ‘_Node_itera
}							      								      i ++ ) if ( max_count < i -> second ) max_count = i -> seco tor<std::pair<const int, int>,false,[...]>’ to non
							      								      return ( n - max_count ) ;				  -scalar type ‘_Node_iterator<int,true,[...]>’ requ
							      								    }								  ested	   for ( unordered_set < int > :: iterator i
							      								    								   = hash . begin ( ) ;
							      								    								  		     ~~~~~~~~~~~~~^~~ MINIMUM_OPERAT
							      								    								  ION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:5: error: no
							      								    								  match for ‘operator!=’ (operand types are ‘std::un
							      								    								  ordered_set<int>::iterator’ {aka ‘std::__detail::_
							      								    								  Node_iterator<int, true, false>’} and ‘std::unorde
							      								    								  red_map<int, int>::iterator’ {aka ‘std::__detail::
							      								    								  _Node_iterator<std::pair<const int, int>, false, f
							      								    								  alse>’})    i != hash . end ( ) ;    ~~^~~~~~~~~~~
							      								    								  ~~~~~~ In file included from /usr/include/c++/8/re
							      								    								  gex:62,		   from /usr/include/c++/8/x
							      								    								  86_64-redhat-linux/bits/stdc++.h:110,
							      								    								       from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_AR
							      								    								  RAY.cpp:14: /usr/include/c++/8/bits/regex.h:991:5:
							      								    								   note: candidate: ‘template<class _BiIter> bool st
							      								    								  d::__cxx11::operator!=(const std::__cxx11::sub_mat
							      								    								  ch<_BiIter>&, const std::__cxx11::sub_match<_BiIte
							      								    								  r>&)’	     operator!=(const sub_match<_BiIter>& __
							      								    								  lhs, const sub_match<_BiIter>& __rhs)	     ^~~~~~~
							      								    								  ~ /usr/include/c++/8/bits/regex.h:991:5: note:   t
							      								    								  emplate argument deduction/substitution failed: MI
							      								    								  NIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:2
							      								    								  1: note:   ‘std::unordered_set<int>::iterator’ {ak
							      								    								  a ‘std::__detail::_Node_iterator<int, true, false>
							      								    								  ’} is not derived from ‘const std::__cxx11::sub_ma
							      								    								  tch<_BiIter>’	   i != hash . end ( ) ;
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/regex:62,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  	    from MINIMUM_OPERATION_MAKE_ELEMENTS_EQU
							      								    								  AL_ARRAY.cpp:14: /usr/include/c++/8/bits/regex.h:1
							      								    								  069:5: note: candidate: ‘template<class _Bi_iter,
							      								    								  class _Ch_traits, class _Ch_alloc> bool std::__cxx
							      								    								  11::operator!=(std::__cxx11::__sub_match_string<_B
							      								    								  i_iter, _Ch_traits, _Ch_alloc>&, const std::__cxx1
							      								    								  1::sub_match<_BiIter>&)’	operator!=(const __s
							      								    								  ub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>&
							      								    								  __lhs,      ^~~~~~~~ /usr/include/c++/8/bits/regex
							      								    								  .h:1069:5: note:   template argument deduction/sub
							      								    								  stitution failed: MINIMUM_OPERATION_MAKE_ELEMENTS_
							      								    								  EQUAL_ARRAY.cpp:36:21: note:	 ‘std::unordered_set
							      								    								  <int>::iterator’ {aka ‘std::__detail::_Node_iterat
							      								    								  or<int, true, false>’} is not derived from ‘std::_
							      								    								  _cxx11::__sub_match_string<_Bi_iter, _Ch_traits, _
							      								    								  Ch_alloc>’	i != hash . end ( ) ;
							      								    								  	 ^ In file included from /usr/include/c++/8/
							      								    								  regex:62,		     from /usr/include/c++/8
							      								    								  /x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  	 from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_
							      								    								  ARRAY.cpp:14: /usr/include/c++/8/bits/regex.h:1149
							      								    								  :5: note: candidate: ‘template<class _Bi_iter, cla
							      								    								  ss _Ch_traits, class _Ch_alloc> bool std::__cxx11:
							      								    								  :operator!=(const std::__cxx11::sub_match<_BiIter>
							      								    								  &, std::__cxx11::__sub_match_string<_Bi_iter, _Ch_
							      								    								  traits, _Ch_alloc>&)’	     operator!=(const sub_ma
							      								    								  tch<_Bi_iter>& __lhs,	     ^~~~~~~~ /usr/include/c
							      								    								  ++/8/bits/regex.h:1149:5: note:   template argumen
							      								    								  t deduction/substitution failed: MINIMUM_OPERATION
							      								    								  _MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	‘std
							      								    								  ::unordered_set<int>::iterator’ {aka ‘std::__detai
							      								    								  l::_Node_iterator<int, true, false>’} is not deriv
							      								    								  ed from ‘const std::__cxx11::sub_match<_BiIter>’
							      								    								    i != hash . end ( ) ;		       ^ In
							      								    								  file included from /usr/include/c++/8/regex:62,
							      								    								  		 from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:110,		       from
							      								    								  MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14
							      								    								  : /usr/include/c++/8/bits/regex.h:1226:5: note: ca
							      								    								  ndidate: ‘template<class _Bi_iter> bool std::__cxx
							      								    								  11::operator!=(const typename std::iterator_traits
							      								    								  <_Iter>::value_type*, const std::__cxx11::sub_matc
							      								    								  h<_BiIter>&)’	     operator!=(typename iterator_tr
							      								    								  aits<_Bi_iter>::value_type const* __lhs,	^~~~
							      								    								  ~~~~ /usr/include/c++/8/bits/regex.h:1226:5: note:
							      								    								     template argument deduction/substitution failed
							      								    								  : MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:
							      								    								  36:21: note:	 ‘std::unordered_map<int, int>::iter
							      								    								  ator’ {aka ‘std::__detail::_Node_iterator<std::pai
							      								    								  r<const int, int>, false, false>’} is not derived
							      								    								  from ‘const std::__cxx11::sub_match<_BiIter>’	   i
							      								    								   != hash . end ( ) ;			    ^ In fil
							      								    								  e included from /usr/include/c++/8/regex:62,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:110,		    from MIN
							      								    								  IMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /
							      								    								  usr/include/c++/8/bits/regex.h:1300:5: note: candi
							      								    								  date: ‘template<class _Bi_iter> bool std::__cxx11:
							      								    								  :operator!=(const std::__cxx11::sub_match<_BiIter>
							      								    								  &, const typename std::iterator_traits<_Iter>::val
							      								    								  ue_type*)’	  operator!=(const sub_match<_Bi_ite
							      								    								  r>& __lhs,	  ^~~~~~~~ /usr/include/c++/8/bits/r
							      								    								  egex.h:1300:5: note:	 template argument deduction
							      								    								  /substitution failed: MINIMUM_OPERATION_MAKE_ELEME
							      								    								  NTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std::unordered
							      								    								  _set<int>::iterator’ {aka ‘std::__detail::_Node_it
							      								    								  erator<int, true, false>’} is not derived from ‘co
							      								    								  nst std::__cxx11::sub_match<_BiIter>’	   i != hash
							      								    								   . end ( ) ;			    ^ In file includ
							      								    								  ed from /usr/include/c++/8/regex:62,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:110,		    from MINIMUM_OPE
							      								    								  RATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/incl
							      								    								  ude/c++/8/bits/regex.h:1377:5: note: candidate: ‘t
							      								    								  emplate<class _Bi_iter> bool std::__cxx11::operato
							      								    								  r!=(const typename std::iterator_traits<_Iter>::va
							      								    								  lue_type&, const std::__cxx11::sub_match<_BiIter>&
							      								    								  )’	  operator!=(typename iterator_traits<_Bi_it
							      								    								  er>::value_type const& __lhs,	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/regex.h:1377:5: note:   template
							      								    								   argument deduction/substitution failed: MINIMUM_O
							      								    								  PERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note
							      								    								  :   ‘std::unordered_map<int, int>::iterator’ {aka
							      								    								  ‘std::__detail::_Node_iterator<std::pair<const int
							      								    								  , int>, false, false>’} is not derived from ‘const
							      								    								   std::__cxx11::sub_match<_BiIter>’	i != hash .
							      								    								  end ( ) ;			 ^ In file included
							      								    								  from /usr/include/c++/8/regex:62,
							      								    								   from /usr/include/c++/8/x86_64-redhat-linux/bits/
							      								    								  stdc++.h:110,			 from MINIMUM_OPERAT
							      								    								  ION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/include
							      								    								  /c++/8/bits/regex.h:1457:5: note: candidate: ‘temp
							      								    								  late<class _Bi_iter> bool std::__cxx11::operator!=
							      								    								  (const std::__cxx11::sub_match<_BiIter>&, const ty
							      								    								  pename std::iterator_traits<_Iter>::value_type&)’
							      								    								       operator!=(const sub_match<_Bi_iter>& __lhs,
							      								    								       ^~~~~~~~ /usr/include/c++/8/bits/regex.h:1457
							      								    								  :5: note:   template argument deduction/substituti
							      								    								  on failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_A
							      								    								  RRAY.cpp:36:21: note:	  ‘std::unordered_set<int>::
							      								    								  iterator’ {aka ‘std::__detail::_Node_iterator<int,
							      								    								   true, false>’} is not derived from ‘const std::__
							      								    								  cxx11::sub_match<_BiIter>’	i != hash . end ( )
							      								    								  ;			 ^ In file included from /us
							      								    								  r/include/c++/8/regex:62,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :110,			 from MINIMUM_OPERATION_MAKE
							      								    								  _ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/b
							      								    								  its/regex.h:1981:5: note: candidate: ‘template<cla
							      								    								  ss _Bi_iter, class _Alloc> bool std::__cxx11::oper
							      								    								  ator!=(const std::__cxx11::match_results<_BiIter,
							      								    								  _Alloc>&, const std::__cxx11::match_results<_BiIte
							      								    								  r, _Alloc>&)’	     operator!=(const match_results<
							      								    								  _Bi_iter, _Alloc>& __m1,	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/regex.h:1981:5: note:   template argu
							      								    								  ment deduction/substitution failed: MINIMUM_OPERAT
							      								    								  ION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘
							      								    								  std::unordered_set<int>::iterator’ {aka ‘std::__de
							      								    								  tail::_Node_iterator<int, true, false>’} is not de
							      								    								  rived from ‘const std::__cxx11::match_results<_BiI
							      								    								  ter, _Alloc>’	   i != hash . end ( ) ;
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/iosfwd:40,			 from /usr/include/c
							      								    								  ++/8/ios:38,			from /usr/include/c+
							      								    								  +/8/ostream:38,		   from /usr/include
							      								    								  /c++/8/iostream:39,		       from MINIMUM_
							      								    								  OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:8: /usr/in
							      								    								  clude/c++/8/bits/postypes.h:221:5: note: candidate
							      								    								  : ‘template<class _StateT> bool std::operator!=(co
							      								    								  nst std::fpos<_StateT>&, const std::fpos<_StateT>&
							      								    								  )’	  operator!=(const fpos<_StateT>& __lhs, con
							      								    								  st fpos<_StateT>& __rhs)	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/postypes.h:221:5: note:	 template ar
							      								    								  gument deduction/substitution failed: MINIMUM_OPER
							      								    								  ATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:
							      								    								   ‘std::unordered_set<int>::iterator’ {aka ‘std::__
							      								    								  detail::_Node_iterator<int, true, false>’} is not
							      								    								  derived from ‘const std::fpos<_StateT>’    i != ha
							      								    								  sh . end ( ) ;		      ^ In file incl
							      								    								  uded from /usr/include/c++/8/bits/stl_algobase.h:6
							      								    								  4,		      from /usr/include/c++/8/bits/c
							      								    								  har_traits.h:39,		    from /usr/includ
							      								    								  e/c++/8/ios:40,		   from /usr/include
							      								    								  /c++/8/ostream:38,		      from /usr/incl
							      								    								  ude/c++/8/iostream:39,		  from MINIM
							      								    								  UM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:8: /usr
							      								    								  /include/c++/8/bits/stl_pair.h:461:5: note: candid
							      								    								  ate: ‘template<class _T1, class _T2> constexpr boo
							      								    								  l std::operator!=(const std::pair<_T1, _T2>&, cons
							      								    								  t std::pair<_T1, _T2>&)’	operator!=(const pai
							      								    								  r<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/stl_pair.h:461:5:
							      								    								   note:   template argument deduction/substitution
							      								    								  failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRA
							      								    								  Y.cpp:36:21: note:   ‘std::unordered_set<int>::ite
							      								    								  rator’ {aka ‘std::__detail::_Node_iterator<int, tr
							      								    								  ue, false>’} is not derived from ‘const std::pair<
							      								    								  _T1, _T2>’	i != hash . end ( ) ;
							      								    								  	 ^ In file included from /usr/include/c++/8/
							      								    								  bits/stl_algobase.h:67,		   from /usr
							      								    								  /include/c++/8/bits/char_traits.h:39,
							      								    								       from /usr/include/c++/8/ios:40,
							      								    								      from /usr/include/c++/8/ostream:38,
							      								    								  	 from /usr/include/c++/8/iostream:39,
							      								    								  	     from MINIMUM_OPERATION_MAKE_ELEMENTS_EQ
							      								    								  UAL_ARRAY.cpp:8: /usr/include/c++/8/bits/stl_itera
							      								    								  tor.h:314:5: note: candidate: ‘template<class _Ite
							      								    								  rator> bool std::operator!=(const std::reverse_ite
							      								    								  rator<_Iterator>&, const std::reverse_iterator<_It
							      								    								  erator>&)’	  operator!=(const reverse_iterator<
							      								    								  _Iterator>& __x,	^~~~~~~~ /usr/include/c++/8/
							      								    								  bits/stl_iterator.h:314:5: note:   template argume
							      								    								  nt deduction/substitution failed: MINIMUM_OPERATIO
							      								    								  N_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	 ‘st
							      								    								  d::unordered_set<int>::iterator’ {aka ‘std::__deta
							      								    								  il::_Node_iterator<int, true, false>’} is not deri
							      								    								  ved from ‘const std::reverse_iterator<_Iterator>’
							      								    								     i != hash . end ( ) ;			^ In
							      								    								   file included from /usr/include/c++/8/bits/stl_al
							      								    								  gobase.h:67,			from /usr/include/c+
							      								    								  +/8/bits/char_traits.h:39,		      from /
							      								    								  usr/include/c++/8/ios:40,		     from /u
							      								    								  sr/include/c++/8/ostream:38,			from
							      								    								   /usr/include/c++/8/iostream:39,
							      								    								  from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.c
							      								    								  pp:8: /usr/include/c++/8/bits/stl_iterator.h:352:5
							      								    								  : note: candidate: ‘template<class _IteratorL, cla
							      								    								  ss _IteratorR> bool std::operator!=(const std::rev
							      								    								  erse_iterator<_Iterator>&, const std::reverse_iter
							      								    								  ator<_IteratorR>&)’	   operator!=(const reverse_
							      								    								  iterator<_IteratorL>& __x,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/stl_iterator.h:352:5: note:   templ
							      								    								  ate argument deduction/substitution failed: MINIMU
							      								    								  M_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: n
							      								    								  ote:	 ‘std::unordered_set<int>::iterator’ {aka ‘s
							      								    								  td::__detail::_Node_iterator<int, true, false>’} i
							      								    								  s not derived from ‘const std::reverse_iterator<_I
							      								    								  terator>’    i != hash . end ( ) ;
							      								    								  	^ In file included from /usr/include/c++/8/b
							      								    								  its/stl_algobase.h:67,		  from /usr/
							      								    								  include/c++/8/bits/char_traits.h:39,
							      								    								      from /usr/include/c++/8/ios:40,
							      								    								     from /usr/include/c++/8/ostream:38,
							      								    								  	from /usr/include/c++/8/iostream:39,
							      								    								  	    from MINIMUM_OPERATION_MAKE_ELEMENTS_EQU
							      								    								  AL_ARRAY.cpp:8: /usr/include/c++/8/bits/stl_iterat
							      								    								  or.h:1127:5: note: candidate: ‘template<class _Ite
							      								    								  ratorL, class _IteratorR> bool std::operator!=(con
							      								    								  st std::move_iterator<_IteratorL>&, const std::mov
							      								    								  e_iterator<_IteratorR>&)’	 operator!=(const mo
							      								    								  ve_iterator<_IteratorL>& __x,	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/stl_iterator.h:1127:5: note:   t
							      								    								  emplate argument deduction/substitution failed: MI
							      								    								  NIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:2
							      								    								  1: note:   ‘std::unordered_set<int>::iterator’ {ak
							      								    								  a ‘std::__detail::_Node_iterator<int, true, false>
							      								    								  ’} is not derived from ‘const std::move_iterator<_
							      								    								  IteratorL>’	 i != hash . end ( ) ;
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /bits/stl_algobase.h:67,		    from /us
							      								    								  r/include/c++/8/bits/char_traits.h:39,
							      								    								  	from /usr/include/c++/8/ios:40,
							      								    								       from /usr/include/c++/8/ostream:38,
							      								    								  	  from /usr/include/c++/8/iostream:39,
							      								    								  	      from MINIMUM_OPERATION_MAKE_ELEMENTS_E
							      								    								  QUAL_ARRAY.cpp:8: /usr/include/c++/8/bits/stl_iter
							      								    								  ator.h:1133:5: note: candidate: ‘template<class _I
							      								    								  terator> bool std::operator!=(const std::move_iter
							      								    								  ator<_IteratorL>&, const std::move_iterator<_Itera
							      								    								  torL>&)’	operator!=(const move_iterator<_Iter
							      								    								  ator>& __x,	   ^~~~~~~~ /usr/include/c++/8/bits/
							      								    								  stl_iterator.h:1133:5: note:	 template argument d
							      								    								  eduction/substitution failed: MINIMUM_OPERATION_MA
							      								    								  KE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std::u
							      								    								  nordered_set<int>::iterator’ {aka ‘std::__detail::
							      								    								  _Node_iterator<int, true, false>’} is not derived
							      								    								  from ‘const std::move_iterator<_IteratorL>’	 i !
							      								    								  = hash . end ( ) ;			  ^ In file
							      								    								  included from /usr/include/c++/8/string:41,
							      								    								  	     from /usr/include/c++/8/bits/locale_cla
							      								    								  sses.h:40,		      from /usr/include/c++/
							      								    								  8/bits/ios_base.h:41,			 from /usr/i
							      								    								  nclude/c++/8/ios:42,			from /usr/in
							      								    								  clude/c++/8/ostream:38,		   from /usr
							      								    								  /include/c++/8/iostream:39,		       from
							      								    								  MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:8:
							      								    								   /usr/include/c++/8/bits/allocator.h:158:5: note:
							      								    								  candidate: ‘template<class _T1, class _T2> bool st
							      								    								  d::operator!=(const std::allocator<_CharT>&, const
							      								    								   std::allocator<_T2>&)’      operator!=(const allo
							      								    								  cator<_T1>&, const allocator<_T2>&)	   ^~~~~~~~
							      								    								  /usr/include/c++/8/bits/allocator.h:158:5: note:
							      								    								   template argument deduction/substitution failed:
							      								    								  MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36
							      								    								  :21: note:   ‘std::unordered_set<int>::iterator’ {
							      								    								  aka ‘std::__detail::_Node_iterator<int, true, fals
							      								    								  e>’} is not derived from ‘const std::allocator<_Ch
							      								    								  arT>’	   i != hash . end ( ) ;
							      								    								    ^ In file included from /usr/include/c++/8/strin
							      								    								  g:41,			 from /usr/include/c++/8/bit
							      								    								  s/locale_classes.h:40,		  from /usr/
							      								    								  include/c++/8/bits/ios_base.h:41,
							      								    								   from /usr/include/c++/8/ios:42,
							      								    								  from /usr/include/c++/8/ostream:38,
							      								    								     from /usr/include/c++/8/iostream:39,
							      								    								  	 from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_
							      								    								  ARRAY.cpp:8: /usr/include/c++/8/bits/allocator.h:1
							      								    								  64:5: note: candidate: ‘template<class _Tp> bool s
							      								    								  td::operator!=(const std::allocator<_CharT>&, cons
							      								    								  t std::allocator<_CharT>&)’	   operator!=(const
							      								    								  allocator<_Tp>&, const allocator<_Tp>&)      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/allocator.h:164:5: not
							      								    								  e:   template argument deduction/substitution fail
							      								    								  ed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cp
							      								    								  p:36:21: note:   ‘std::unordered_set<int>::iterato
							      								    								  r’ {aka ‘std::__detail::_Node_iterator<int, true,
							      								    								  false>’} is not derived from ‘const std::allocator
							      								    								  <_CharT>’    i != hash . end ( ) ;
							      								    								  	^ In file included from /usr/include/c++/8/s
							      								    								  tring:52,		     from /usr/include/c++/8
							      								    								  /bits/locale_classes.h:40,		      from /
							      								    								  usr/include/c++/8/bits/ios_base.h:41,
							      								    								       from /usr/include/c++/8/ios:42,
							      								    								      from /usr/include/c++/8/ostream:38,
							      								    								  	 from /usr/include/c++/8/iostream:39,
							      								    								  	     from MINIMUM_OPERATION_MAKE_ELEMENTS_EQ
							      								    								  UAL_ARRAY.cpp:8: /usr/include/c++/8/bits/basic_str
							      								    								  ing.h:6095:5: note: candidate: ‘template<class _Ch
							      								    								  arT, class _Traits, class _Alloc> bool std::operat
							      								    								  or!=(const std::__cxx11::basic_string<_CharT, _Tra
							      								    								  its, _Alloc>&, const std::__cxx11::basic_string<_C
							      								    								  harT, _Traits, _Alloc>&)’	 operator!=(const ba
							      								    								  sic_string<_CharT, _Traits, _Alloc>& __lhs,	   ^
							      								    								  ~~~~~~~ /usr/include/c++/8/bits/basic_string.h:609
							      								    								  5:5: note:   template argument deduction/substitut
							      								    								  ion failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_
							      								    								  ARRAY.cpp:36:21: note:   ‘std::unordered_set<int>:
							      								    								  :iterator’ {aka ‘std::__detail::_Node_iterator<int
							      								    								  , true, false>’} is not derived from ‘const std::_
							      								    								  _cxx11::basic_string<_CharT, _Traits, _Alloc>’
							      								    								  i != hash . end ( ) ;			     ^ In fi
							      								    								  le included from /usr/include/c++/8/string:52,
							      								    								  		from /usr/include/c++/8/bits/locale_
							      								    								  classes.h:40,			 from /usr/include/c
							      								    								  ++/8/bits/ios_base.h:41,		    from /us
							      								    								  r/include/c++/8/ios:42,		   from /usr
							      								    								  /include/c++/8/ostream:38,		      from /
							      								    								  usr/include/c++/8/iostream:39,		  fr
							      								    								  om MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp
							      								    								  :8: /usr/include/c++/8/bits/basic_string.h:6108:5:
							      								    								   note: candidate: ‘template<class _CharT, class _T
							      								    								  raits, class _Alloc> bool std::operator!=(const _C
							      								    								  harT*, const std::__cxx11::basic_string<_CharT, _T
							      								    								  raits, _Alloc>&)’	 operator!=(const _CharT* __
							      								    								  lhs,	    ^~~~~~~~ /usr/include/c++/8/bits/basic_s
							      								    								  tring.h:6108:5: note:	  template argument deductio
							      								    								  n/substitution failed: MINIMUM_OPERATION_MAKE_ELEM
							      								    								  ENTS_EQUAL_ARRAY.cpp:36:21: note:   mismatched typ
							      								    								  es ‘const _CharT*’ and ‘std::__detail::_Node_itera
							      								    								  tor<int, true, false>’    i != hash . end ( ) ;
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/string:52,		  from /usr/
							      								    								  include/c++/8/bits/locale_classes.h:40,
							      								    								  	 from /usr/include/c++/8/bits/ios_base.h:41,
							      								    								  		    from /usr/include/c++/8/ios:42,
							      								    								  		   from /usr/include/c++/8/ostream:3
							      								    								  8,		      from /usr/include/c++/8/iostre
							      								    								  am:39,		  from MINIMUM_OPERATION_MAK
							      								    								  E_ELEMENTS_EQUAL_ARRAY.cpp:8: /usr/include/c++/8/b
							      								    								  its/basic_string.h:6120:5: note: candidate: ‘templ
							      								    								  ate<class _CharT, class _Traits, class _Alloc> boo
							      								    								  l std::operator!=(const std::__cxx11::basic_string
							      								    								  <_CharT, _Traits, _Alloc>&, const _CharT*)’	   o
							      								    								  perator!=(const basic_string<_CharT, _Traits, _All
							      								    								  oc>& __lhs,	   ^~~~~~~~ /usr/include/c++/8/bits/
							      								    								  basic_string.h:6120:5: note:	 template argument d
							      								    								  eduction/substitution failed: MINIMUM_OPERATION_MA
							      								    								  KE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std::u
							      								    								  nordered_set<int>::iterator’ {aka ‘std::__detail::
							      								    								  _Node_iterator<int, true, false>’} is not derived
							      								    								  from ‘const std::__cxx11::basic_string<_CharT, _Tr
							      								    								  aits, _Alloc>’    i != hash . end ( ) ;
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/bits/ios_base.h:46,		   from /usr
							      								    								  /include/c++/8/ios:42,		  from /usr/
							      								    								  include/c++/8/ostream:38,		     from /u
							      								    								  sr/include/c++/8/iostream:39,			 fro
							      								    								  m MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:
							      								    								  8: /usr/include/c++/8/system_error:319:3: note: ca
							      								    								  ndidate: ‘bool std::operator!=(const std::error_co
							      								    								  de&, const std::error_code&)’	   operator!=(const
							      								    								  error_code& __lhs, const error_code& __rhs) noexce
							      								    								  pt	^~~~~~~~ /usr/include/c++/8/system_error:319
							      								    								  :3: note:   no known conversion for argument 1 fro
							      								    								  m ‘std::unordered_set<int>::iterator’ {aka ‘std::_
							      								    								  _detail::_Node_iterator<int, true, false>’} to ‘co
							      								    								  nst std::error_code&’ /usr/include/c++/8/system_er
							      								    								  ror:323:3: note: candidate: ‘bool std::operator!=(
							      								    								  const std::error_code&, const std::error_condition
							      								    								  &)’	 operator!=(const error_code& __lhs, const e
							      								    								  rror_condition& __rhs) noexcept    ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/system_error:323:3: note:   no known
							      								    								  conversion for argument 1 from ‘std::unordered_set
							      								    								  <int>::iterator’ {aka ‘std::__detail::_Node_iterat
							      								    								  or<int, true, false>’} to ‘const std::error_code&’
							      								    								   /usr/include/c++/8/system_error:327:3: note: cand
							      								    								  idate: ‘bool std::operator!=(const std::error_cond
							      								    								  ition&, const std::error_code&)’    operator!=(con
							      								    								  st error_condition& __lhs, const error_code& __rhs
							      								    								  ) noexcept	^~~~~~~~ /usr/include/c++/8/system_e
							      								    								  rror:327:3: note:   no known conversion for argume
							      								    								  nt 1 from ‘std::unordered_set<int>::iterator’ {aka
							      								    								   ‘std::__detail::_Node_iterator<int, true, false>’
							      								    								  } to ‘const std::error_condition&’ /usr/include/c+
							      								    								  +/8/system_error:331:3: note: candidate: ‘bool std
							      								    								  ::operator!=(const std::error_condition&, const st
							      								    								  d::error_condition&)’	   operator!=(const error_co
							      								    								  ndition& __lhs,    ^~~~~~~~ /usr/include/c++/8/sys
							      								    								  tem_error:331:3: note:   no known conversion for a
							      								    								  rgument 1 from ‘std::unordered_set<int>::iterator’
							      								    								   {aka ‘std::__detail::_Node_iterator<int, true, fa
							      								    								  lse>’} to ‘const std::error_condition&’ In file in
							      								    								  cluded from /usr/include/c++/8/bits/locale_facets.
							      								    								  h:48,			 from /usr/include/c++/8/bit
							      								    								  s/basic_ios.h:37,		     from /usr/inclu
							      								    								  de/c++/8/ios:44,		    from /usr/includ
							      								    								  e/c++/8/ostream:38,		       from /usr/inc
							      								    								  lude/c++/8/iostream:39,		   from MINI
							      								    								  MUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:8: /us
							      								    								  r/include/c++/8/bits/streambuf_iterator.h:209:5: n
							      								    								  ote: candidate: ‘template<class _CharT, class _Tra
							      								    								  its> bool std::operator!=(const std::istreambuf_it
							      								    								  erator<_CharT, _Traits>&, const std::istreambuf_it
							      								    								  erator<_CharT, _Traits>&)’	  operator!=(const i
							      								    								  streambuf_iterator<_CharT, _Traits>& __a,	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/bits/streambuf_iterator.h
							      								    								  :209:5: note:	  template argument deduction/substi
							      								    								  tution failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQU
							      								    								  AL_ARRAY.cpp:36:21: note:   ‘std::unordered_set<in
							      								    								  t>::iterator’ {aka ‘std::__detail::_Node_iterator<
							      								    								  int, true, false>’} is not derived from ‘const std
							      								    								  ::istreambuf_iterator<_CharT, _Traits>’    i != ha
							      								    								  sh . end ( ) ;		      ^ In file incl
							      								    								  uded from /usr/include/c++/8/vector:64,
							      								    								  	 from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_
							      								    								  ARRAY.cpp:11: /usr/include/c++/8/bits/stl_vector.h
							      								    								  :1777:5: note: candidate: ‘template<class _Tp, cla
							      								    								  ss _Alloc> bool std::operator!=(const std::vector<
							      								    								  _Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)’
							      								    								      operator!=(const vector<_Tp, _Alloc>& __x, con
							      								    								  st vector<_Tp, _Alloc>& __y)	    ^~~~~~~~ /usr/in
							      								    								  clude/c++/8/bits/stl_vector.h:1777:5: note:	temp
							      								    								  late argument deduction/substitution failed: MINIM
							      								    								  UM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21:
							      								    								  note:	  ‘std::unordered_set<int>::iterator’ {aka ‘
							      								    								  std::__detail::_Node_iterator<int, true, false>’}
							      								    								  is not derived from ‘const std::vector<_Tp, _Alloc
							      								    								  >’	i != hash . end ( ) ;			   ^
							      								    								   In file included from /usr/include/c++/8/tuple:39
							      								    								  ,		     from /usr/include/c++/8/bits/un
							      								    								  ique_ptr.h:37,		  from /usr/include/
							      								    								  c++/8/bits/locale_conv.h:41,			from
							      								    								   /usr/include/c++/8/locale:43,		  fr
							      								    								  om /usr/include/c++/8/iomanip:43,
							      								    								   from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.
							      								    								  cpp:13: /usr/include/c++/8/array:257:5: note: cand
							      								    								  idate: ‘template<class _Tp, long unsigned int _Nm>
							      								    								   bool std::operator!=(const std::array<_Tp, _Nm>&,
							      								    								   const std::array<_Tp, _Nm>&)’      operator!=(con
							      								    								  st array<_Tp, _Nm>& __one, const array<_Tp, _Nm>&
							      								    								  __two)      ^~~~~~~~ /usr/include/c++/8/array:257:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_AR
							      								    								  RAY.cpp:36:21: note:	 ‘std::unordered_set<int>::i
							      								    								  terator’ {aka ‘std::__detail::_Node_iterator<int,
							      								    								  true, false>’} is not derived from ‘const std::arr
							      								    								  ay<_Tp, _Nm>’	   i != hash . end ( ) ;
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/bits/unique_ptr.h:37,		    from /us
							      								    								  r/include/c++/8/bits/locale_conv.h:41,
							      								    								  	from /usr/include/c++/8/locale:43,
							      								    								  	  from /usr/include/c++/8/iomanip:43,
							      								    								  	     from MINIMUM_OPERATION_MAKE_ELEMENTS_EQ
							      								    								  UAL_ARRAY.cpp:13: /usr/include/c++/8/tuple:1439:5:
							      								    								   note: candidate: ‘template<class ... _TElements,
							      								    								  class ... _UElements> constexpr bool std::operator
							      								    								  !=(const std::tuple<_Tps ...>&, const std::tuple<_
							      								    								  Elements ...>&)’	operator!=(const tuple<_TEle
							      								    								  ments...>& __t,      ^~~~~~~~ /usr/include/c++/8/t
							      								    								  uple:1439:5: note:   template argument deduction/s
							      								    								  ubstitution failed: MINIMUM_OPERATION_MAKE_ELEMENT
							      								    								  S_EQUAL_ARRAY.cpp:36:21: note:   ‘std::unordered_s
							      								    								  et<int>::iterator’ {aka ‘std::__detail::_Node_iter
							      								    								  ator<int, true, false>’} is not derived from ‘cons
							      								    								  t std::tuple<_Tps ...>’    i != hash . end ( ) ;
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/bits/locale_conv.h:41,
							      								    								     from /usr/include/c++/8/locale:43,
							      								    								       from /usr/include/c++/8/iomanip:43,
							      								    								  	  from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL
							      								    								  _ARRAY.cpp:13: /usr/include/c++/8/bits/unique_ptr.
							      								    								  h:710:5: note: candidate: ‘template<class _Tp, cla
							      								    								  ss _Dp, class _Up, class _Ep> bool std::operator!=
							      								    								  (const std::unique_ptr<_Tp, _Dp>&, const std::uniq
							      								    								  ue_ptr<_Up, _Ep>&)’	   operator!=(const unique_p
							      								    								  tr<_Tp, _Dp>& __x,	  ^~~~~~~~ /usr/include/c++/
							      								    								  8/bits/unique_ptr.h:710:5: note:   template argume
							      								    								  nt deduction/substitution failed: MINIMUM_OPERATIO
							      								    								  N_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	 ‘st
							      								    								  d::unordered_set<int>::iterator’ {aka ‘std::__deta
							      								    								  il::_Node_iterator<int, true, false>’} is not deri
							      								    								  ved from ‘const std::unique_ptr<_Tp, _Dp>’	i !=
							      								    								   hash . end ( ) ;			 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/bits/locale_conv.h
							      								    								  :41,			from /usr/include/c++/8/loca
							      								    								  le:43,		  from /usr/include/c++/8/io
							      								    								  manip:43,		     from MINIMUM_OPERATION_
							      								    								  MAKE_ELEMENTS_EQUAL_ARRAY.cpp:13: /usr/include/c++
							      								    								  /8/bits/unique_ptr.h:716:5: note: candidate: ‘temp
							      								    								  late<class _Tp, class _Dp> bool std::operator!=(co
							      								    								  nst std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)’
							      								    								      operator!=(const unique_ptr<_Tp, _Dp>& __x, nu
							      								    								  llptr_t) noexcept	 ^~~~~~~~ /usr/include/c++/8
							      								    								  /bits/unique_ptr.h:716:5: note:   template argumen
							      								    								  t deduction/substitution failed: MINIMUM_OPERATION
							      								    								  _MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	‘std
							      								    								  ::unordered_set<int>::iterator’ {aka ‘std::__detai
							      								    								  l::_Node_iterator<int, true, false>’} is not deriv
							      								    								  ed from ‘const std::unique_ptr<_Tp, _Dp>’    i !=
							      								    								  hash . end ( ) ;			^ In file in
							      								    								  cluded from /usr/include/c++/8/bits/locale_conv.h:
							      								    								  41,		       from /usr/include/c++/8/local
							      								    								  e:43,			 from /usr/include/c++/8/iom
							      								    								  anip:43,		    from MINIMUM_OPERATION_M
							      								    								  AKE_ELEMENTS_EQUAL_ARRAY.cpp:13: /usr/include/c++/
							      								    								  8/bits/unique_ptr.h:721:5: note: candidate: ‘templ
							      								    								  ate<class _Tp, class _Dp> bool std::operator!=(std
							      								    								  ::nullptr_t, const std::unique_ptr<_Tp, _Dp>&)’
							      								    								     operator!=(nullptr_t, const unique_ptr<_Tp, _Dp
							      								    								  >& __x) noexcept	^~~~~~~~ /usr/include/c++/8/
							      								    								  bits/unique_ptr.h:721:5: note:   template argument
							      								    								   deduction/substitution failed: MINIMUM_OPERATION_
							      								    								  MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std:
							      								    								  :unordered_map<int, int>::iterator’ {aka ‘std::__d
							      								    								  etail::_Node_iterator<std::pair<const int, int>, f
							      								    								  alse, false>’} is not derived from ‘const std::uni
							      								    								  que_ptr<_Tp, _Dp>’	i != hash . end ( ) ;
							      								    								  		 ^ In file included from /usr/includ
							      								    								  e/c++/8/ccomplex:39,			from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:52,
							      								    								  		   from MINIMUM_OPERATION_MAKE_ELEME
							      								    								  NTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/complex
							      								    								  :476:5: note: candidate: ‘template<class _Tp> cons
							      								    								  texpr bool std::operator!=(const std::complex<_Tp>
							      								    								  &, const std::complex<_Tp>&)’	     operator!=(cons
							      								    								  t complex<_Tp>& __x, const complex<_Tp>& __y)
							      								    								   ^~~~~~~~ /usr/include/c++/8/complex:476:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:3
							      								    								  6:21: note:	‘std::unordered_set<int>::iterator’
							      								    								  {aka ‘std::__detail::_Node_iterator<int, true, fal
							      								    								  se>’} is not derived from ‘const std::complex<_Tp>
							      								    								  ’    i != hash . end ( ) ;			  ^
							      								    								  In file included from /usr/include/c++/8/ccomplex:
							      								    								  39,		       from /usr/include/c++/8/x86_6
							      								    								  4-redhat-linux/bits/stdc++.h:52,
							      								    								  from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.c
							      								    								  pp:14: /usr/include/c++/8/complex:481:5: note: can
							      								    								  didate: ‘template<class _Tp> constexpr bool std::o
							      								    								  perator!=(const std::complex<_Tp>&, const _Tp&)’
							      								    								      operator!=(const complex<_Tp>& __x, const _Tp&
							      								    								   __y)	     ^~~~~~~~ /usr/include/c++/8/complex:481
							      								    								  :5: note:   template argument deduction/substituti
							      								    								  on failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_A
							      								    								  RRAY.cpp:36:21: note:	  ‘std::unordered_set<int>::
							      								    								  iterator’ {aka ‘std::__detail::_Node_iterator<int,
							      								    								   true, false>’} is not derived from ‘const std::co
							      								    								  mplex<_Tp>’	 i != hash . end ( ) ;
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /ccomplex:39,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:52,
							      								    								  	    from MINIMUM_OPERATION_MAKE_ELEMENTS_EQU
							      								    								  AL_ARRAY.cpp:14: /usr/include/c++/8/complex:486:5:
							      								    								   note: candidate: ‘template<class _Tp> constexpr b
							      								    								  ool std::operator!=(const _Tp&, const std::complex
							      								    								  <_Tp>&)’	operator!=(const _Tp& __x, const com
							      								    								  plex<_Tp>& __y)      ^~~~~~~~ /usr/include/c++/8/c
							      								    								  omplex:486:5: note:	template argument deduction/
							      								    								  substitution failed: MINIMUM_OPERATION_MAKE_ELEMEN
							      								    								  TS_EQUAL_ARRAY.cpp:36:21: note:   ‘std::unordered_
							      								    								  map<int, int>::iterator’ {aka ‘std::__detail::_Nod
							      								    								  e_iterator<std::pair<const int, int>, false, false
							      								    								  >’} is not derived from ‘const std::complex<_Tp>’
							      								    								     i != hash . end ( ) ;			^ In
							      								    								   file included from /usr/include/c++/8/deque:64,
							      								    								  		  from /usr/include/c++/8/x86_64-red
							      								    								  hat-linux/bits/stdc++.h:68,		       from
							      								    								  MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14
							      								    								  : /usr/include/c++/8/bits/stl_deque.h:281:5: note:
							      								    								   candidate: ‘template<class _Tp, class _Ref, class
							      								    								   _Ptr> bool std::operator!=(const std::_Deque_iter
							      								    								  ator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator
							      								    								  <_Tp, _Ref, _Ptr>&)’	    operator!=(const _Deque_
							      								    								  iterator<_Tp, _Ref, _Ptr>& __x,      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/stl_deque.h:281:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: MINI
							      								    								  MUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21:
							      								    								   note:   ‘std::unordered_set<int>::iterator’ {aka
							      								    								  ‘std::__detail::_Node_iterator<int, true, false>’}
							      								    								   is not derived from ‘const std::_Deque_iterator<_
							      								    								  Tp, _Ref, _Ptr>’    i != hash . end ( ) ;
							      								    								  	       ^ In file included from /usr/include/
							      								    								  c++/8/deque:64,		   from /usr/include
							      								    								  /c++/8/x86_64-redhat-linux/bits/stdc++.h:68,
							      								    								  	      from MINIMUM_OPERATION_MAKE_ELEMENTS_E
							      								    								  QUAL_ARRAY.cpp:14: /usr/include/c++/8/bits/stl_deq
							      								    								  ue.h:288:5: note: candidate: ‘template<class _Tp,
							      								    								  class _RefL, class _PtrL, class _RefR, class _PtrR
							      								    								  > bool std::operator!=(const std::_Deque_iterator<
							      								    								  _Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp,
							      								    								   _RefR, _PtrR>&)’	 operator!=(const _Deque_ite
							      								    								  rator<_Tp, _RefL, _PtrL>& __x,      ^~~~~~~~ /usr/
							      								    								  include/c++/8/bits/stl_deque.h:288:5: note:	temp
							      								    								  late argument deduction/substitution failed: MINIM
							      								    								  UM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21:
							      								    								  note:	  ‘std::unordered_set<int>::iterator’ {aka ‘
							      								    								  std::__detail::_Node_iterator<int, true, false>’}
							      								    								  is not derived from ‘const std::_Deque_iterator<_T
							      								    								  p, _Ref, _Ptr>’    i != hash . end ( ) ;
							      								    								  	      ^ In file included from /usr/include/c
							      								    								  ++/8/deque:64,		  from /usr/include/
							      								    								  c++/8/x86_64-redhat-linux/bits/stdc++.h:68,
							      								    								  	     from MINIMUM_OPERATION_MAKE_ELEMENTS_EQ
							      								    								  UAL_ARRAY.cpp:14: /usr/include/c++/8/bits/stl_dequ
							      								    								  e.h:2303:5: note: candidate: ‘template<class _Tp,
							      								    								  class _Alloc> bool std::operator!=(const std::dequ
							      								    								  e<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)’
							      								    								       operator!=(const deque<_Tp, _Alloc>& __x,
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/stl_deque.h:230
							      								    								  3:5: note:   template argument deduction/substitut
							      								    								  ion failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_
							      								    								  ARRAY.cpp:36:21: note:   ‘std::unordered_set<int>:
							      								    								  :iterator’ {aka ‘std::__detail::_Node_iterator<int
							      								    								  , true, false>’} is not derived from ‘const std::d
							      								    								  eque<_Tp, _Alloc>’	i != hash . end ( ) ;
							      								    								  		 ^ In file included from /usr/includ
							      								    								  e/c++/8/functional:59,		  from /usr/
							      								    								  include/c++/8/x86_64-redhat-linux/bits/stdc++.h:71
							      								    								  ,		     from MINIMUM_OPERATION_MAKE_ELE
							      								    								  MENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bits/
							      								    								  std_function.h:763:5: note: candidate: ‘template<c
							      								    								  lass _Res, class ... _Args> bool std::operator!=(c
							      								    								  onst std::function<_Res(_ArgTypes ...)>&, std::nul
							      								    								  lptr_t)’	operator!=(const function<_Res(_Args
							      								    								  ...)>& __f, nullptr_t) noexcept      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/std_function.h:763:5: note:
							      								    								  template argument deduction/substitution failed: M
							      								    								  INIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:
							      								    								  21: note:   ‘std::unordered_set<int>::iterator’ {a
							      								    								  ka ‘std::__detail::_Node_iterator<int, true, false
							      								    								  >’} is not derived from ‘const std::function<_Res(
							      								    								  _ArgTypes ...)>’    i != hash . end ( ) ;
							      								    								  	       ^ In file included from /usr/include/
							      								    								  c++/8/functional:59,			from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:71,
							      								    								  		   from MINIMUM_OPERATION_MAKE_ELEME
							      								    								  NTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bits/st
							      								    								  d_function.h:769:5: note: candidate: ‘template<cla
							      								    								  ss _Res, class ... _Args> bool std::operator!=(std
							      								    								  ::nullptr_t, const std::function<_Res(_ArgTypes ..
							      								    								  .)>&)’      operator!=(nullptr_t, const function<_
							      								    								  Res(_Args...)>& __f) noexcept	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/std_function.h:769:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: MIN
							      								    								  IMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21
							      								    								  : note:   ‘std::unordered_map<int, int>::iterator’
							      								    								   {aka ‘std::__detail::_Node_iterator<std::pair<con
							      								    								  st int, int>, false, false>’} is not derived from
							      								    								  ‘const std::function<_Res(_ArgTypes ...)>’	i !=
							      								    								   hash . end ( ) ;			 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/iterator:66,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:77,		   from MINI
							      								    								  MUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /u
							      								    								  sr/include/c++/8/bits/stream_iterator.h:137:5: not
							      								    								  e: candidate: ‘template<class _Tp, class _CharT, c
							      								    								  lass _Traits, class _Dist> bool std::operator!=(co
							      								    								  nst std::istream_iterator<_Tp, _CharT, _Traits, _D
							      								    								  ist>&, const std::istream_iterator<_Tp, _CharT, _T
							      								    								  raits, _Dist>&)’	operator!=(const istream_ite
							      								    								  rator<_Tp, _CharT, _Traits, _Dist>& __x,	^~~~
							      								    								  ~~~~ /usr/include/c++/8/bits/stream_iterator.h:137
							      								    								  :5: note:   template argument deduction/substituti
							      								    								  on failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_A
							      								    								  RRAY.cpp:36:21: note:	  ‘std::unordered_set<int>::
							      								    								  iterator’ {aka ‘std::__detail::_Node_iterator<int,
							      								    								   true, false>’} is not derived from ‘const std::is
							      								    								  tream_iterator<_Tp, _CharT, _Traits, _Dist>’	  i
							      								    								  != hash . end ( ) ;			   ^ In file
							      								    								   included from /usr/include/c++/8/list:63,
							      								    								  	    from /usr/include/c++/8/x86_64-redhat-li
							      								    								  nux/bits/stdc++.h:79,			 from MINIMU
							      								    								  M_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr
							      								    								  /include/c++/8/bits/stl_list.h:350:5: note: candid
							      								    								  ate: ‘template<class _Val> bool std::operator!=(co
							      								    								  nst std::_List_iterator<_Tp>&, const std::_List_co
							      								    								  nst_iterator<_Tp>&)’	    operator!=(const _List_i
							      								    								  terator<_Val>& __x,	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/stl_list.h:350:5: note:   template argumen
							      								    								  t deduction/substitution failed: MINIMUM_OPERATION
							      								    								  _MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	‘std
							      								    								  ::unordered_set<int>::iterator’ {aka ‘std::__detai
							      								    								  l::_Node_iterator<int, true, false>’} is not deriv
							      								    								  ed from ‘const std::_List_iterator<_Tp>’    i != h
							      								    								  ash . end ( ) ;		       ^ In file inc
							      								    								  luded from /usr/include/c++/8/list:63,
							      								    								  	from /usr/include/c++/8/x86_64-redhat-linux/
							      								    								  bits/stdc++.h:79,		     from MINIMUM_OP
							      								    								  ERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/inc
							      								    								  lude/c++/8/bits/stl_list.h:2028:5: note: candidate
							      								    								  : ‘template<class _Tp, class _Alloc> bool std::ope
							      								    								  rator!=(const std::__cxx11::list<_Tp, _Alloc>&, co
							      								    								  nst std::__cxx11::list<_Tp, _Alloc>&)’      operat
							      								    								  or!=(const list<_Tp, _Alloc>& __x, const list<_Tp,
							      								    								   _Alloc>& __y)      ^~~~~~~~ /usr/include/c++/8/bi
							      								    								  ts/stl_list.h:2028:5: note:	template argument de
							      								    								  duction/substitution failed: MINIMUM_OPERATION_MAK
							      								    								  E_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std::un
							      								    								  ordered_set<int>::iterator’ {aka ‘std::__detail::_
							      								    								  Node_iterator<int, true, false>’} is not derived f
							      								    								  rom ‘const std::__cxx11::list<_Tp, _Alloc>’	 i !
							      								    								  = hash . end ( ) ;			  ^ In file
							      								    								  included from /usr/include/c++/8/map:60,
							      								    								  	  from /usr/include/c++/8/x86_64-redhat-linu
							      								    								  x/bits/stdc++.h:81,		       from MINIMUM_
							      								    								  OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/i
							      								    								  nclude/c++/8/bits/stl_tree.h:412:5: note: candidat
							      								    								  e: ‘template<class _Val> bool std::operator!=(cons
							      								    								  t std::_Rb_tree_iterator<_Tp>&, const std::_Rb_tre
							      								    								  e_const_iterator<_Val>&)’	 operator!=(const _R
							      								    								  b_tree_iterator<_Val>& __x,	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/stl_tree.h:412:5: note:   template
							      								    								   argument deduction/substitution failed: MINIMUM_O
							      								    								  PERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note
							      								    								  :   ‘std::unordered_set<int>::iterator’ {aka ‘std:
							      								    								  :__detail::_Node_iterator<int, true, false>’} is n
							      								    								  ot derived from ‘const std::_Rb_tree_iterator<_Tp>
							      								    								  ’    i != hash . end ( ) ;			  ^
							      								    								  In file included from /usr/include/c++/8/map:60,
							      								    								  		  from /usr/include/c++/8/x86_64-red
							      								    								  hat-linux/bits/stdc++.h:81,		       from
							      								    								  MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14
							      								    								  : /usr/include/c++/8/bits/stl_tree.h:1576:5: note:
							      								    								   candidate: ‘template<class _Key, class _Val, clas
							      								    								  s _KeyOfValue, class _Compare, class _Alloc> bool
							      								    								  std::operator!=(const std::_Rb_tree<_Key, _Val, _K
							      								    								  eyOfValue, _Compare, _Alloc>&, const std::_Rb_tree
							      								    								  <_Key, _Val, _KeyOfValue, _Compare, _Alloc>&)’
							      								    								    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValu
							      								    								  e, _Compare, _Alloc>& __x,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/stl_tree.h:1576:5: note:   template
							      								    								   argument deduction/substitution failed: MINIMUM_O
							      								    								  PERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note
							      								    								  :   ‘std::unordered_set<int>::iterator’ {aka ‘std:
							      								    								  :__detail::_Node_iterator<int, true, false>’} is n
							      								    								  ot derived from ‘const std::_Rb_tree<_Key, _Val, _
							      								    								  KeyOfValue, _Compare, _Alloc>’    i != hash . end
							      								    								  ( ) ;			     ^ In file included from
							      								    								   /usr/include/c++/8/map:61,		       from
							      								    								  /usr/include/c++/8/x86_64-redhat-linux/bits/stdc++
							      								    								  .h:81,		  from MINIMUM_OPERATION_MAK
							      								    								  E_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/
							      								    								  bits/stl_map.h:1458:5: note: candidate: ‘template<
							      								    								  class _Key, class _Tp, class _Compare, class _Allo
							      								    								  c> bool std::operator!=(const std::map<_Key, _Tp,
							      								    								  _Compare, _Alloc>&, const std::map<_Key, _Tp, _Com
							      								    								  pare, _Alloc>&)’	operator!=(const map<_Key, _
							      								    								  Tp, _Compare, _Alloc>& __x,	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/stl_map.h:1458:5: note:   template
							      								    								   argument deduction/substitution failed: MINIMUM_O
							      								    								  PERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note
							      								    								  :   ‘std::unordered_set<int>::iterator’ {aka ‘std:
							      								    								  :__detail::_Node_iterator<int, true, false>’} is n
							      								    								  ot derived from ‘const std::map<_Key, _Tp, _Compar
							      								    								  e, _Alloc>’	 i != hash . end ( ) ;
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /map:62,		    from /usr/include/c++/8/
							      								    								  x86_64-redhat-linux/bits/stdc++.h:81,
							      								    								       from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_AR
							      								    								  RAY.cpp:14: /usr/include/c++/8/bits/stl_multimap.h
							      								    								  :1122:5: note: candidate: ‘template<class _Key, cl
							      								    								  ass _Tp, class _Compare, class _Alloc> bool std::o
							      								    								  perator!=(const std::multimap<_Key, _Tp, _Compare,
							      								    								   _Alloc>&, const std::multimap<_Key, _Tp, _Compare
							      								    								  , _Alloc>&)’	    operator!=(const multimap<_Key,
							      								    								  _Tp, _Compare, _Alloc>& __x,	    ^~~~~~~~ /usr/in
							      								    								  clude/c++/8/bits/stl_multimap.h:1122:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: MIN
							      								    								  IMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21
							      								    								  : note:   ‘std::unordered_set<int>::iterator’ {aka
							      								    								   ‘std::__detail::_Node_iterator<int, true, false>’
							      								    								  } is not derived from ‘const std::multimap<_Key, _
							      								    								  Tp, _Compare, _Alloc>’    i != hash . end ( ) ;
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/bits/shared_ptr.h:52,
							      								    								   from /usr/include/c++/8/memory:81,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:82,		  from MINIMUM_OPERA
							      								    								  TION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/includ
							      								    								  e/c++/8/bits/shared_ptr_base.h:1426:5: note: candi
							      								    								  date: ‘template<class _Tp1, class _Tp2, __gnu_cxx:
							      								    								  :_Lock_policy _Lp> bool std::operator!=(const std:
							      								    								  :__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr
							      								    								  <_Tp2, _Lp>&)’      operator!=(const __shared_ptr<
							      								    								  _Tp1, _Lp>& __a,	^~~~~~~~ /usr/include/c++/8/
							      								    								  bits/shared_ptr_base.h:1426:5: note:	 template ar
							      								    								  gument deduction/substitution failed: MINIMUM_OPER
							      								    								  ATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:
							      								    								   ‘std::unordered_set<int>::iterator’ {aka ‘std::__
							      								    								  detail::_Node_iterator<int, true, false>’} is not
							      								    								  derived from ‘const std::__shared_ptr<_Tp1, _Lp>’
							      								    								     i != hash . end ( ) ;			^ In
							      								    								   file included from /usr/include/c++/8/bits/shared
							      								    								  _ptr.h:52,		      from /usr/include/c++/
							      								    								  8/memory:81,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:82,
							      								    								  	   from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUA
							      								    								  L_ARRAY.cpp:14: /usr/include/c++/8/bits/shared_ptr
							      								    								  _base.h:1432:5: note: candidate: ‘template<class _
							      								    								  Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operato
							      								    								  r!=(const std::__shared_ptr<_Tp, _Lp>&, std::nullp
							      								    								  tr_t)’      operator!=(const __shared_ptr<_Tp, _Lp
							      								    								  >& __a, nullptr_t) noexcept	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/shared_ptr_base.h:1432:5: note:
							      								    								  template argument deduction/substitution failed: M
							      								    								  INIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:
							      								    								  21: note:   ‘std::unordered_set<int>::iterator’ {a
							      								    								  ka ‘std::__detail::_Node_iterator<int, true, false
							      								    								  >’} is not derived from ‘const std::__shared_ptr<_
							      								    								  Tp, _Lp>’    i != hash . end ( ) ;
							      								    								  	^ In file included from /usr/include/c++/8/b
							      								    								  its/shared_ptr.h:52,			from /usr/in
							      								    								  clude/c++/8/memory:81,		  from /usr/
							      								    								  include/c++/8/x86_64-redhat-linux/bits/stdc++.h:82
							      								    								  ,		     from MINIMUM_OPERATION_MAKE_ELE
							      								    								  MENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bits/
							      								    								  shared_ptr_base.h:1437:5: note: candidate: ‘templa
							      								    								  te<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool st
							      								    								  d::operator!=(std::nullptr_t, const std::__shared_
							      								    								  ptr<_Tp, _Lp>&)’	operator!=(nullptr_t, const
							      								    								  __shared_ptr<_Tp, _Lp>& __a) noexcept	     ^~~~~~~
							      								    								  ~ /usr/include/c++/8/bits/shared_ptr_base.h:1437:5
							      								    								  : note:   template argument deduction/substitution
							      								    								   failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARR
							      								    								  AY.cpp:36:21: note:	‘std::unordered_map<int, int
							      								    								  >::iterator’ {aka ‘std::__detail::_Node_iterator<s
							      								    								  td::pair<const int, int>, false, false>’} is not d
							      								    								  erived from ‘const std::__shared_ptr<_Tp, _Lp>’
							      								    								   i != hash . end ( ) ;		      ^ In f
							      								    								  ile included from /usr/include/c++/8/memory:81,
							      								    								  		 from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:82,		      from M
							      								    								  INIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14:
							      								    								   /usr/include/c++/8/bits/shared_ptr.h:398:5: note:
							      								    								   candidate: ‘template<class _Tp, class _Up> bool s
							      								    								  td::operator!=(const std::shared_ptr<_Tp>&, const
							      								    								  std::shared_ptr<_Tp>&)’      operator!=(const shar
							      								    								  ed_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noex
							      								    								  cept	    ^~~~~~~~ /usr/include/c++/8/bits/shared_
							      								    								  ptr.h:398:5: note:   template argument deduction/s
							      								    								  ubstitution failed: MINIMUM_OPERATION_MAKE_ELEMENT
							      								    								  S_EQUAL_ARRAY.cpp:36:21: note:   ‘std::unordered_s
							      								    								  et<int>::iterator’ {aka ‘std::__detail::_Node_iter
							      								    								  ator<int, true, false>’} is not derived from ‘cons
							      								    								  t std::shared_ptr<_Tp>’    i != hash . end ( ) ;
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/memory:81,		   from /usr
							      								    								  /include/c++/8/x86_64-redhat-linux/bits/stdc++.h:8
							      								    								  2,		      from MINIMUM_OPERATION_MAKE_EL
							      								    								  EMENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bits
							      								    								  /shared_ptr.h:403:5: note: candidate: ‘template<cl
							      								    								  ass _Tp> bool std::operator!=(const std::shared_pt
							      								    								  r<_Tp>&, std::nullptr_t)’	 operator!=(const sh
							      								    								  ared_ptr<_Tp>& __a, nullptr_t) noexcept      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/shared_ptr.h:403:5: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.c
							      								    								  pp:36:21: note:   ‘std::unordered_set<int>::iterat
							      								    								  or’ {aka ‘std::__detail::_Node_iterator<int, true,
							      								    								   false>’} is not derived from ‘const std::shared_p
							      								    								  tr<_Tp>’    i != hash . end ( ) ;
							      								    								       ^ In file included from /usr/include/c++/8/me
							      								    								  mory:81,		    from /usr/include/c++/8/
							      								    								  x86_64-redhat-linux/bits/stdc++.h:82,
							      								    								       from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_AR
							      								    								  RAY.cpp:14: /usr/include/c++/8/bits/shared_ptr.h:4
							      								    								  08:5: note: candidate: ‘template<class _Tp> bool s
							      								    								  td::operator!=(std::nullptr_t, const std::shared_p
							      								    								  tr<_Tp>&)’	  operator!=(nullptr_t, const shared
							      								    								  _ptr<_Tp>& __a) noexcept	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/shared_ptr.h:408:5: note:   template
							      								    								  argument deduction/substitution failed: MINIMUM_OP
							      								    								  ERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:
							      								    								     ‘std::unordered_map<int, int>::iterator’ {aka ‘
							      								    								  std::__detail::_Node_iterator<std::pair<const int,
							      								    								   int>, false, false>’} is not derived from ‘const
							      								    								  std::shared_ptr<_Tp>’	   i != hash . end ( ) ;
							      								    								  		    ^ In file included from /usr/inc
							      								    								  lude/c++/8/queue:64,			from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:86,
							      								    								  		   from MINIMUM_OPERATION_MAKE_ELEME
							      								    								  NTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bits/st
							      								    								  l_queue.h:354:5: note: candidate: ‘template<class
							      								    								  _Tp, class _Seq> bool std::operator!=(const std::q
							      								    								  ueue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)’
							      								    								      operator!=(const queue<_Tp, _Seq>& __x, const
							      								    								  queue<_Tp, _Seq>& __y)      ^~~~~~~~ /usr/include/
							      								    								  c++/8/bits/stl_queue.h:354:5: note:	template arg
							      								    								  ument deduction/substitution failed: MINIMUM_OPERA
							      								    								  TION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:
							      								    								  ‘std::unordered_set<int>::iterator’ {aka ‘std::__d
							      								    								  etail::_Node_iterator<int, true, false>’} is not d
							      								    								  erived from ‘const std::queue<_Tp, _Seq>’    i !=
							      								    								  hash . end ( ) ;			^ In file in
							      								    								  cluded from /usr/include/c++/8/set:61,
							      								    								  	from /usr/include/c++/8/x86_64-redhat-linux/
							      								    								  bits/stdc++.h:87,		     from MINIMUM_OP
							      								    								  ERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/inc
							      								    								  lude/c++/8/bits/stl_set.h:982:5: note: candidate:
							      								    								  ‘template<class _Key, class _Compare, class _Alloc
							      								    								  > bool std::operator!=(const std::set<_Key, _Compa
							      								    								  re, _Alloc>&, const std::set<_Key, _Compare, _Allo
							      								    								  c>&)’	     operator!=(const set<_Key, _Compare, _A
							      								    								  lloc>& __x,	   ^~~~~~~~ /usr/include/c++/8/bits/
							      								    								  stl_set.h:982:5: note:   template argument deducti
							      								    								  on/substitution failed: MINIMUM_OPERATION_MAKE_ELE
							      								    								  MENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std::unorder
							      								    								  ed_set<int>::iterator’ {aka ‘std::__detail::_Node_
							      								    								  iterator<int, true, false>’} is not derived from ‘
							      								    								  const std::set<_Key, _Compare, _Alloc>’    i != ha
							      								    								  sh . end ( ) ;		      ^ In file incl
							      								    								  uded from /usr/include/c++/8/set:62,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:87,		   from MINIMUM_OPER
							      								    								  ATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/inclu
							      								    								  de/c++/8/bits/stl_multiset.h:967:5: note: candidat
							      								    								  e: ‘template<class _Key, class _Compare, class _Al
							      								    								  loc> bool std::operator!=(const std::multiset<_Key
							      								    								  , _Compare, _Alloc>&, const std::multiset<_Key, _C
							      								    								  ompare, _Alloc>&)’	  operator!=(const multiset<
							      								    								  _Key, _Compare, _Alloc>& __x,	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/stl_multiset.h:967:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: MIN
							      								    								  IMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21
							      								    								  : note:   ‘std::unordered_set<int>::iterator’ {aka
							      								    								   ‘std::__detail::_Node_iterator<int, true, false>’
							      								    								  } is not derived from ‘const std::multiset<_Key, _
							      								    								  Compare, _Alloc>’    i != hash . end ( ) ;
							      								    								  		^ In file included from /usr/include
							      								    								  /c++/8/stack:61,		    from /usr/includ
							      								    								  e/c++/8/x86_64-redhat-linux/bits/stdc++.h:89,
							      								    								  	       from MINIMUM_OPERATION_MAKE_ELEMENTS_
							      								    								  EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bits/stl_st
							      								    								  ack.h:329:5: note: candidate: ‘template<class _Tp,
							      								    								   class _Seq> bool std::operator!=(const std::stack
							      								    								  <_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)’
							      								    								  operator!=(const stack<_Tp, _Seq>& __x, const stac
							      								    								  k<_Tp, _Seq>& __y)	  ^~~~~~~~ /usr/include/c++/
							      								    								  8/bits/stl_stack.h:329:5: note:   template argumen
							      								    								  t deduction/substitution failed: MINIMUM_OPERATION
							      								    								  _MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	‘std
							      								    								  ::unordered_set<int>::iterator’ {aka ‘std::__detai
							      								    								  l::_Node_iterator<int, true, false>’} is not deriv
							      								    								  ed from ‘const std::stack<_Tp, _Seq>’	   i != hash
							      								    								   . end ( ) ;			    ^ In file includ
							      								    								  ed from /usr/include/c++/8/valarray:592,
							      								    								  	  from /usr/include/c++/8/x86_64-redhat-linu
							      								    								  x/bits/stdc++.h:95,		       from MINIMUM_
							      								    								  OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/i
							      								    								  nclude/c++/8/bits/valarray_after.h:415:5: note: ca
							      								    								  ndidate: ‘template<class _Dom1, class _Dom2> std::
							      								    								  _Expr<std::_BinClos<std::__not_equal_to, std::_Exp
							      								    								  r, std::_Expr, _Dom1, _Dom2>, typename std::__fun<
							      								    								  std::__not_equal_to, typename _Dom1::value_type>::
							      								    								  result_type> std::operator!=(const std::_Expr<_Dom
							      								    								  1, typename _Dom1::value_type>&, const std::_Expr<
							      								    								  _Dom2, typename _Dom2::value_type>&)’	     _DEFINE
							      								    								  _EXPR_BINARY_OPERATOR(!=, __not_equal_to)	 ^~~
							      								    								  ~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/bits/
							      								    								  valarray_after.h:415:5: note:	  template argument
							      								    								  deduction/substitution failed: MINIMUM_OPERATION_M
							      								    								  AKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std::
							      								    								  unordered_set<int>::iterator’ {aka ‘std::__detail:
							      								    								  :_Node_iterator<int, true, false>’} is not derived
							      								    								   from ‘const std::_Expr<_Dom1, typename _Dom1::val
							      								    								  ue_type>’    i != hash . end ( ) ;
							      								    								  	^ In file included from /usr/include/c++/8/v
							      								    								  alarray:592,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  	   from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUA
							      								    								  L_ARRAY.cpp:14: /usr/include/c++/8/bits/valarray_a
							      								    								  fter.h:415:5: note: candidate: ‘template<class _Do
							      								    								  m> std::_Expr<std::_BinClos<std::__not_equal_to, s
							      								    								  td::_Expr, std::_Constant, _Dom, typename _Dom::va
							      								    								  lue_type>, typename std::__fun<std::__not_equal_to
							      								    								  , typename _Dom1::value_type>::result_type> std::o
							      								    								  perator!=(const std::_Expr<_Dom1, typename _Dom1::
							      								    								  value_type>&, const typename _Dom::value_type&)’
							      								    								      _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_equal_t
							      								    								  o)	  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/include/
							      								    								  c++/8/bits/valarray_after.h:415:5: note:   templat
							      								    								  e argument deduction/substitution failed: MINIMUM_
							      								    								  OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: not
							      								    								  e:   ‘std::unordered_set<int>::iterator’ {aka ‘std
							      								    								  ::__detail::_Node_iterator<int, true, false>’} is
							      								    								  not derived from ‘const std::_Expr<_Dom1, typename
							      								    								   _Dom1::value_type>’	  i != hash . end ( ) ;
							      								    								  		   ^ In file included from /usr/incl
							      								    								  ude/c++/8/valarray:592,		   from /usr
							      								    								  /include/c++/8/x86_64-redhat-linux/bits/stdc++.h:9
							      								    								  5,		      from MINIMUM_OPERATION_MAKE_EL
							      								    								  EMENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bits
							      								    								  /valarray_after.h:415:5: note: candidate: ‘templat
							      								    								  e<class _Dom> std::_Expr<std::_BinClos<std::__not_
							      								    								  equal_to, std::_Constant, std::_Expr, typename _Do
							      								    								  m::value_type, _Dom>, typename std::__fun<std::__n
							      								    								  ot_equal_to, typename _Dom1::value_type>::result_t
							      								    								  ype> std::operator!=(const typename _Dom::value_ty
							      								    								  pe&, const std::_Expr<_Dom1, typename _Dom1::value
							      								    								  _type>&)’	 _DEFINE_EXPR_BINARY_OPERATOR(!=, __
							      								    								  not_equal_to)	     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /u
							      								    								  sr/include/c++/8/bits/valarray_after.h:415:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp
							      								    								  :36:21: note:	  ‘std::unordered_map<int, int>::ite
							      								    								  rator’ {aka ‘std::__detail::_Node_iterator<std::pa
							      								    								  ir<const int, int>, false, false>’} is not derived
							      								    								   from ‘const std::_Expr<_Dom1, typename _Dom1::val
							      								    								  ue_type>’    i != hash . end ( ) ;
							      								    								  	^ In file included from /usr/include/c++/8/v
							      								    								  alarray:592,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  	   from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUA
							      								    								  L_ARRAY.cpp:14: /usr/include/c++/8/bits/valarray_a
							      								    								  fter.h:415:5: note: candidate: ‘template<class _Do
							      								    								  m> std::_Expr<std::_BinClos<std::__not_equal_to, s
							      								    								  td::_Expr, std::_ValArray, _Dom, typename _Dom::va
							      								    								  lue_type>, typename std::__fun<std::__not_equal_to
							      								    								  , typename _Dom1::value_type>::result_type> std::o
							      								    								  perator!=(const std::_Expr<_Dom1, typename _Dom1::
							      								    								  value_type>&, const std::valarray<typename _Dom::v
							      								    								  alue_type>&)’	     _DEFINE_EXPR_BINARY_OPERATOR(!=
							      								    								  , __not_equal_to)	 ^~~~~~~~~~~~~~~~~~~~~~~~~~~
							      								    								  ~ /usr/include/c++/8/bits/valarray_after.h:415:5:
							      								    								  note:	  template argument deduction/substitution f
							      								    								  ailed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY
							      								    								  .cpp:36:21: note:   ‘std::unordered_set<int>::iter
							      								    								  ator’ {aka ‘std::__detail::_Node_iterator<int, tru
							      								    								  e, false>’} is not derived from ‘const std::_Expr<
							      								    								  _Dom1, typename _Dom1::value_type>’	 i != hash .
							      								    								   end ( ) ;			  ^ In file included
							      								    								   from /usr/include/c++/8/valarray:592,
							      								    								  	from /usr/include/c++/8/x86_64-redhat-linux/
							      								    								  bits/stdc++.h:95,		     from MINIMUM_OP
							      								    								  ERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/inc
							      								    								  lude/c++/8/bits/valarray_after.h:415:5: note: cand
							      								    								  idate: ‘template<class _Dom> std::_Expr<std::_BinC
							      								    								  los<std::__not_equal_to, std::_ValArray, std::_Exp
							      								    								  r, typename _Dom::value_type, _Dom>, typename std:
							      								    								  :__fun<std::__not_equal_to, typename _Dom1::value_
							      								    								  type>::result_type> std::operator!=(const std::val
							      								    								  array<typename _Dom::value_type>&, const std::_Exp
							      								    								  r<_Dom1, typename _Dom1::value_type>&)’      _DEFI
							      								    								  NE_EXPR_BINARY_OPERATOR(!=, __not_equal_to)	   ^
							      								    								  ~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/bit
							      								    								  s/valarray_after.h:415:5: note:   template argumen
							      								    								  t deduction/substitution failed: MINIMUM_OPERATION
							      								    								  _MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	‘std
							      								    								  ::unordered_map<int, int>::iterator’ {aka ‘std::__
							      								    								  detail::_Node_iterator<std::pair<const int, int>,
							      								    								  false, false>’} is not derived from ‘const std::_E
							      								    								  xpr<_Dom1, typename _Dom1::value_type>’    i != ha
							      								    								  sh . end ( ) ;		      ^ In file incl
							      								    								  uded from /usr/include/c++/8/x86_64-redhat-linux/b
							      								    								  its/stdc++.h:95,		    from MINIMUM_OPE
							      								    								  RATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/incl
							      								    								  ude/c++/8/valarray:1185:1: note: candidate: ‘templ
							      								    								  ate<class _Tp> std::_Expr<std::_BinClos<std::__not
							      								    								  _equal_to, std::_ValArray, std::_ValArray, _Tp, _T
							      								    								  p>, typename std::__fun<std::__not_equal_to, _Tp>:
							      								    								  :result_type> std::operator!=(const std::valarray<
							      								    								  _Tp>&, const std::valarray<_Tp>&)’  _DEFINE_BINARY
							      								    								  _OPERATOR(!=, __not_equal_to)	 ^~~~~~~~~~~~~~~~~~~
							      								    								  ~~~~ /usr/include/c++/8/valarray:1185:1: note:   t
							      								    								  emplate argument deduction/substitution failed: MI
							      								    								  NIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:2
							      								    								  1: note:   ‘std::unordered_set<int>::iterator’ {ak
							      								    								  a ‘std::__detail::_Node_iterator<int, true, false>
							      								    								  ’} is not derived from ‘const std::valarray<_Tp>’
							      								    								     i != hash . end ( ) ;			^ In
							      								    								   file included from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:95,		      from M
							      								    								  INIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14:
							      								    								   /usr/include/c++/8/valarray:1185:1: note: candida
							      								    								  te: ‘template<class _Tp> std::_Expr<std::_BinClos<
							      								    								  std::__not_equal_to, std::_ValArray, std::_Constan
							      								    								  t, _Tp, _Tp>, typename std::__fun<std::__not_equal
							      								    								  _to, _Tp>::result_type> std::operator!=(const std:
							      								    								  :valarray<_Tp>&, const _Tp&)’	 _DEFINE_BINARY_OPER
							      								    								  ATOR(!=, __not_equal_to)  ^~~~~~~~~~~~~~~~~~~~~~~
							      								    								  /usr/include/c++/8/valarray:1185:1: note:   templa
							      								    								  te argument deduction/substitution failed: MINIMUM
							      								    								  _OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: no
							      								    								  te:	‘std::unordered_set<int>::iterator’ {aka ‘st
							      								    								  d::__detail::_Node_iterator<int, true, false>’} is
							      								    								   not derived from ‘const std::valarray<_Tp>’	  i
							      								    								  != hash . end ( ) ;			   ^ In file
							      								    								   included from /usr/include/c++/8/x86_64-redhat-li
							      								    								  nux/bits/stdc++.h:95,			 from MINIMU
							      								    								  M_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr
							      								    								  /include/c++/8/valarray:1185:1: note: candidate: ‘
							      								    								  template<class _Tp> std::_Expr<std::_BinClos<std::
							      								    								  __not_equal_to, std::_Constant, std::_ValArray, _T
							      								    								  p, _Tp>, typename std::__fun<std::__not_equal_to,
							      								    								  _Tp>::result_type> std::operator!=(const _Tp&, con
							      								    								  st std::valarray<_Tp>&)’  _DEFINE_BINARY_OPERATOR(
							      								    								  !=, __not_equal_to)  ^~~~~~~~~~~~~~~~~~~~~~~ /usr/
							      								    								  include/c++/8/valarray:1185:1: note:	 template ar
							      								    								  gument deduction/substitution failed: MINIMUM_OPER
							      								    								  ATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:
							      								    								   ‘std::unordered_map<int, int>::iterator’ {aka ‘st
							      								    								  d::__detail::_Node_iterator<std::pair<const int, i
							      								    								  nt>, false, false>’} is not derived from ‘const st
							      								    								  d::valarray<_Tp>’    i != hash . end ( ) ;
							      								    								  		^ In file included from /usr/include
							      								    								  /c++/8/forward_list:38,		   from /usr
							      								    								  /include/c++/8/x86_64-redhat-linux/bits/stdc++.h:1
							      								    								  04,		       from MINIMUM_OPERATION_MAKE_E
							      								    								  LEMENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bit
							      								    								  s/forward_list.h:281:5: note: candidate: ‘template
							      								    								  <class _Tp> bool std::operator!=(const std::_Fwd_l
							      								    								  ist_iterator<_Tp>&, const std::_Fwd_list_const_ite
							      								    								  rator<_Tp>&)’	     operator!=(const _Fwd_list_iter
							      								    								  ator<_Tp>& __x,      ^~~~~~~~ /usr/include/c++/8/b
							      								    								  its/forward_list.h:281:5: note:   template argumen
							      								    								  t deduction/substitution failed: MINIMUM_OPERATION
							      								    								  _MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	‘std
							      								    								  ::unordered_set<int>::iterator’ {aka ‘std::__detai
							      								    								  l::_Node_iterator<int, true, false>’} is not deriv
							      								    								  ed from ‘const std::_Fwd_list_iterator<_Tp>’	  i
							      								    								  != hash . end ( ) ;			   ^ In file
							      								    								   included from /usr/include/c++/8/forward_list:38,
							      								    								  		    from /usr/include/c++/8/x86_64-r
							      								    								  edhat-linux/bits/stdc++.h:104,		  fr
							      								    								  om MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp
							      								    								  :14: /usr/include/c++/8/bits/forward_list.h:1440:5
							      								    								  : note: candidate: ‘template<class _Tp, class _All
							      								    								  oc> bool std::operator!=(const std::forward_list<_
							      								    								  Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>
							      								    								  &)’	   operator!=(const forward_list<_Tp, _Alloc
							      								    								  >& __lx,	^~~~~~~~ /usr/include/c++/8/bits/for
							      								    								  ward_list.h:1440:5: note:   template argument dedu
							      								    								  ction/substitution failed: MINIMUM_OPERATION_MAKE_
							      								    								  ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	  ‘std::unor
							      								    								  dered_set<int>::iterator’ {aka ‘std::__detail::_No
							      								    								  de_iterator<int, true, false>’} is not derived fro
							      								    								  m ‘const std::forward_list<_Tp, _Alloc>’    i != h
							      								    								  ash . end ( ) ;		       ^ In file inc
							      								    								  luded from /usr/include/c++/8/future:39,
							      								    								  	  from /usr/include/c++/8/x86_64-redhat-linu
							      								    								  x/bits/stdc++.h:105,			from MINIMUM
							      								    								  _OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/
							      								    								  include/c++/8/thread:287:3: note: candidate: ‘bool
							      								    								   std::operator!=(std::thread::id, std::thread::id)
							      								    								  ’    operator!=(thread::id __x, thread::id __y) no
							      								    								  except    ^~~~~~~~ /usr/include/c++/8/thread:287:3
							      								    								  : note:   no known conversion for argument 1 from
							      								    								  ‘std::unordered_set<int>::iterator’ {aka ‘std::__d
							      								    								  etail::_Node_iterator<int, true, false>’} to ‘std:
							      								    								  :thread::id’ In file included from /usr/include/c+
							      								    								  +/8/random:49,		  from /usr/include/
							      								    								  c++/8/x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	      from MINIMUM_OPERATION_MAKE_ELEMENTS_E
							      								    								  QUAL_ARRAY.cpp:14: /usr/include/c++/8/bits/random.
							      								    								  h:397:5: note: candidate: ‘template<class _UIntTyp
							      								    								  e, _UIntType __a, _UIntType __c, _UIntType __m> bo
							      								    								  ol std::operator!=(const std::linear_congruential_
							      								    								  engine<_UIntType, __a, __c, __m>&, const std::line
							      								    								  ar_congruential_engine<_UIntType, __a, __c, __m>&)
							      								    								  ’	 operator!=(const std::linear_congruential_e
							      								    								  ngine<_UIntType, __a,	     ^~~~~~~~ /usr/include/c
							      								    								  ++/8/bits/random.h:397:5: note:   template argumen
							      								    								  t deduction/substitution failed: MINIMUM_OPERATION
							      								    								  _MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	‘std
							      								    								  ::unordered_set<int>::iterator’ {aka ‘std::__detai
							      								    								  l::_Node_iterator<int, true, false>’} is not deriv
							      								    								  ed from ‘const std::linear_congruential_engine<_UI
							      								    								  ntType, __a, __c, __m>’    i != hash . end ( ) ;
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/random:49,		   from /usr
							      								    								  /include/c++/8/x86_64-redhat-linux/bits/stdc++.h:1
							      								    								  08,		       from MINIMUM_OPERATION_MAKE_E
							      								    								  LEMENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bit
							      								    								  s/random.h:629:5: note: candidate: ‘template<class
							      								    								   _UIntType, long unsigned int __w, long unsigned i
							      								    								  nt __n, long unsigned int __m, long unsigned int _
							      								    								  _r, _UIntType __a, long unsigned int __u, _UIntTyp
							      								    								  e __d, long unsigned int __s, _UIntType __b, long
							      								    								  unsigned int __t, _UIntType __c, long unsigned int
							      								    								   __l, _UIntType __f> bool std::operator!=(const st
							      								    								  d::mersenne_twister_engine<_UIntType, __w, __n, __
							      								    								  m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __
							      								    								  f>&, const std::mersenne_twister_engine<_UIntType,
							      								    								   __w, __n, __m, __r, __a, __u, __d, __s, __b, __t,
							      								    								   __c, __l, __f>&)’	  operator!=(const std::mers
							      								    								  enne_twister_engine<_UIntType, __w, __n, __m,
							      								    								   ^~~~~~~~ /usr/include/c++/8/bits/random.h:629:5:
							      								    								  note:	  template argument deduction/substitution f
							      								    								  ailed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY
							      								    								  .cpp:36:21: note:   ‘std::unordered_set<int>::iter
							      								    								  ator’ {aka ‘std::__detail::_Node_iterator<int, tru
							      								    								  e, false>’} is not derived from ‘const std::mersen
							      								    								  ne_twister_engine<_UIntType, __w, __n, __m, __r, _
							      								    								  _a, __u, __d, __s, __b, __t, __c, __l, __f>’	  i
							      								    								  != hash . end ( ) ;			   ^ In file
							      								    								   included from /usr/include/c++/8/random:49,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:108,		    from MIN
							      								    								  IMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /
							      								    								  usr/include/c++/8/bits/random.h:825:5: note: candi
							      								    								  date: ‘template<class _UIntType, long unsigned int
							      								    								   __w, long unsigned int __s, long unsigned int __r
							      								    								  > bool std::operator!=(const std::subtract_with_ca
							      								    								  rry_engine<_UIntType, __w, __s, __r>&, const std::
							      								    								  subtract_with_carry_engine<_UIntType, __w, __s, __
							      								    								  r>&)’	     operator!=(const std::subtract_with_car
							      								    								  ry_engine<_UIntType, __w,	 ^~~~~~~~ /usr/inclu
							      								    								  de/c++/8/bits/random.h:825:5: note:	template arg
							      								    								  ument deduction/substitution failed: MINIMUM_OPERA
							      								    								  TION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:
							      								    								  ‘std::unordered_set<int>::iterator’ {aka ‘std::__d
							      								    								  etail::_Node_iterator<int, true, false>’} is not d
							      								    								  erived from ‘const std::subtract_with_carry_engine
							      								    								  <_UIntType, __w, __s, __r>’	 i != hash . end ( )
							      								    								   ;			  ^ In file included from /u
							      								    								  sr/include/c++/8/random:49,		       from
							      								    								  /usr/include/c++/8/x86_64-redhat-linux/bits/stdc++
							      								    								  .h:108,		   from MINIMUM_OPERATION_MA
							      								    								  KE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8
							      								    								  /bits/random.h:1047:5: note: candidate: ‘template<
							      								    								  class _RandomNumberEngine, long unsigned int __p,
							      								    								  long unsigned int __r> bool std::operator!=(const
							      								    								  std::discard_block_engine<_RandomNumberEngine, __p
							      								    								  , __r>&, const std::discard_block_engine<_RandomNu
							      								    								  mberEngine, __p, __r>&)’	operator!=(const std
							      								    								  ::discard_block_engine<_RandomNumberEngine, __p,
							      								    								      ^~~~~~~~ /usr/include/c++/8/bits/random.h:1047
							      								    								  :5: note:   template argument deduction/substituti
							      								    								  on failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_A
							      								    								  RRAY.cpp:36:21: note:	  ‘std::unordered_set<int>::
							      								    								  iterator’ {aka ‘std::__detail::_Node_iterator<int,
							      								    								   true, false>’} is not derived from ‘const std::di
							      								    								  scard_block_engine<_RandomNumberEngine, __p, __r>’
							      								    								      i != hash . end ( ) ;			 ^ I
							      								    								  n file included from /usr/include/c++/8/random:49,
							      								    								  		    from /usr/include/c++/8/x86_64-r
							      								    								  edhat-linux/bits/stdc++.h:108,		  fr
							      								    								  om MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp
							      								    								  :14: /usr/include/c++/8/bits/random.h:1243:5: note
							      								    								  : candidate: ‘template<class _RandomNumberEngine,
							      								    								  long unsigned int __w, class _UIntType> bool std::
							      								    								  operator!=(const std::independent_bits_engine<_Ran
							      								    								  domNumberEngine, __w, _UIntType>&, const std::inde
							      								    								  pendent_bits_engine<_RandomNumberEngine, __w, _UIn
							      								    								  tType>&)’	 operator!=(const std::independent_b
							      								    								  its_engine<_RandomNumberEngine, __w,	    ^~~~~~~~
							      								    								   /usr/include/c++/8/bits/random.h:1243:5: note:
							      								    								  template argument deduction/substitution failed: M
							      								    								  INIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:
							      								    								  21: note:   ‘std::unordered_set<int>::iterator’ {a
							      								    								  ka ‘std::__detail::_Node_iterator<int, true, false
							      								    								  >’} is not derived from ‘const std::independent_bi
							      								    								  ts_engine<_RandomNumberEngine, __w, _UIntType>’
							      								    								   i != hash . end ( ) ;		      ^ In f
							      								    								  ile included from /usr/include/c++/8/random:49,
							      								    								  		 from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:108,		       from
							      								    								  MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14
							      								    								  : /usr/include/c++/8/bits/random.h:1495:5: note: c
							      								    								  andidate: ‘template<class _RandomNumberEngine, lon
							      								    								  g unsigned int __k> bool std::operator!=(const std
							      								    								  ::shuffle_order_engine<_RandomNumberEngine, __k>&,
							      								    								   const std::shuffle_order_engine<_RandomNumberEngi
							      								    								  ne, __k>&)’	   operator!=(const std::shuffle_ord
							      								    								  er_engine<_RandomNumberEngine,      ^~~~~~~~ /usr/
							      								    								  include/c++/8/bits/random.h:1495:5: note:   templa
							      								    								  te argument deduction/substitution failed: MINIMUM
							      								    								  _OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: no
							      								    								  te:	‘std::unordered_set<int>::iterator’ {aka ‘st
							      								    								  d::__detail::_Node_iterator<int, true, false>’} is
							      								    								   not derived from ‘const std::shuffle_order_engine
							      								    								  <_RandomNumberEngine, __k>’	 i != hash . end ( )
							      								    								   ;			  ^ In file included from /u
							      								    								  sr/include/c++/8/random:49,		       from
							      								    								  /usr/include/c++/8/x86_64-redhat-linux/bits/stdc++
							      								    								  .h:108,		   from MINIMUM_OPERATION_MA
							      								    								  KE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8
							      								    								  /bits/random.h:1660:5: note: candidate: ‘template<
							      								    								  class _IntType> bool std::operator!=(const std::un
							      								    								  iform_int_distribution<_IntType>&, const std::unif
							      								    								  orm_int_distribution<_IntType>&)’	 operator!=(
							      								    								  const std::uniform_int_distribution<_IntType>& __d
							      								    								  1,	  ^~~~~~~~ /usr/include/c++/8/bits/random.h:
							      								    								  1660:5: note:	  template argument deduction/substi
							      								    								  tution failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQU
							      								    								  AL_ARRAY.cpp:36:21: note:   ‘std::unordered_set<in
							      								    								  t>::iterator’ {aka ‘std::__detail::_Node_iterator<
							      								    								  int, true, false>’} is not derived from ‘const std
							      								    								  ::uniform_int_distribution<_IntType>’	   i != hash
							      								    								   . end ( ) ;			    ^ In file includ
							      								    								  ed from /usr/include/c++/8/random:49,
							      								    								       from /usr/include/c++/8/x86_64-redhat-linux/b
							      								    								  its/stdc++.h:108,		     from MINIMUM_OP
							      								    								  ERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/inc
							      								    								  lude/c++/8/bits/random.h:1874:5: note: candidate:
							      								    								  ‘template<class _IntType> bool std::operator!=(con
							      								    								  st std::uniform_real_distribution<_IntType>&, cons
							      								    								  t std::uniform_real_distribution<_IntType>&)’
							      								    								   operator!=(const std::uniform_real_distribution<_
							      								    								  IntType>& __d1,      ^~~~~~~~ /usr/include/c++/8/b
							      								    								  its/random.h:1874:5: note:   template argument ded
							      								    								  uction/substitution failed: MINIMUM_OPERATION_MAKE
							      								    								  _ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std::uno
							      								    								  rdered_set<int>::iterator’ {aka ‘std::__detail::_N
							      								    								  ode_iterator<int, true, false>’} is not derived fr
							      								    								  om ‘const std::uniform_real_distribution<_IntType>
							      								    								  ’    i != hash . end ( ) ;			  ^
							      								    								  In file included from /usr/include/c++/8/random:49
							      								    								  ,		     from /usr/include/c++/8/x86_64-
							      								    								  redhat-linux/bits/stdc++.h:108,		   f
							      								    								  rom MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cp
							      								    								  p:14: /usr/include/c++/8/bits/random.h:2128:5: not
							      								    								  e: candidate: ‘template<class _RealType> bool std:
							      								    								  :operator!=(const std::normal_distribution<_RealTy
							      								    								  pe>&, const std::normal_distribution<_RealType>&)’
							      								    								  	operator!=(const std::normal_distribution<_R
							      								    								  ealType>& __d1,      ^~~~~~~~ /usr/include/c++/8/b
							      								    								  its/random.h:2128:5: note:   template argument ded
							      								    								  uction/substitution failed: MINIMUM_OPERATION_MAKE
							      								    								  _ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std::uno
							      								    								  rdered_set<int>::iterator’ {aka ‘std::__detail::_N
							      								    								  ode_iterator<int, true, false>’} is not derived fr
							      								    								  om ‘const std::normal_distribution<_RealType>’
							      								    								  i != hash . end ( ) ;			     ^ In fi
							      								    								  le included from /usr/include/c++/8/random:49,
							      								    								  		from /usr/include/c++/8/x86_64-redha
							      								    								  t-linux/bits/stdc++.h:108,		      from M
							      								    								  INIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14:
							      								    								   /usr/include/c++/8/bits/random.h:2337:5: note: ca
							      								    								  ndidate: ‘template<class _RealType> bool std::oper
							      								    								  ator!=(const std::lognormal_distribution<_RealType
							      								    								  >&, const std::lognormal_distribution<_RealType>&)
							      								    								  ’	 operator!=(const std::lognormal_distributio
							      								    								  n<_RealType>& __d1,	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/random.h:2337:5: note:   template argument
							      								    								   deduction/substitution failed: MINIMUM_OPERATION_
							      								    								  MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std:
							      								    								  :unordered_set<int>::iterator’ {aka ‘std::__detail
							      								    								  ::_Node_iterator<int, true, false>’} is not derive
							      								    								  d from ‘const std::lognormal_distribution<_RealTyp
							      								    								  e>’	 i != hash . end ( ) ;
							      								    								  ^ In file included from /usr/include/c++/8/random:
							      								    								  49,		       from /usr/include/c++/8/x86_6
							      								    								  4-redhat-linux/bits/stdc++.h:108,
							      								    								   from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.
							      								    								  cpp:14: /usr/include/c++/8/bits/random.h:2562:6: n
							      								    								  ote: candidate: ‘template<class _RealType> bool st
							      								    								  d::operator!=(const std::gamma_distribution<_RealT
							      								    								  ype>&, const std::gamma_distribution<_RealType>&)’
							      								    								  	 operator!=(const std::gamma_distribution<_R
							      								    								  ealType>& __d1,	^~~~~~~~ /usr/include/c++/8/
							      								    								  bits/random.h:2562:6: note:	template argument de
							      								    								  duction/substitution failed: MINIMUM_OPERATION_MAK
							      								    								  E_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std::un
							      								    								  ordered_set<int>::iterator’ {aka ‘std::__detail::_
							      								    								  Node_iterator<int, true, false>’} is not derived f
							      								    								  rom ‘const std::gamma_distribution<_RealType>’
							      								    								  i != hash . end ( ) ;			     ^ In fi
							      								    								  le included from /usr/include/c++/8/random:49,
							      								    								  		from /usr/include/c++/8/x86_64-redha
							      								    								  t-linux/bits/stdc++.h:108,		      from M
							      								    								  INIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14:
							      								    								   /usr/include/c++/8/bits/random.h:2782:5: note: ca
							      								    								  ndidate: ‘template<class _RealType> bool std::oper
							      								    								  ator!=(const std::chi_squared_distribution<_RealTy
							      								    								  pe>&, const std::chi_squared_distribution<_RealTyp
							      								    								  e>&)’	     operator!=(const std::chi_squared_distr
							      								    								  ibution<_RealType>& __d1,	 ^~~~~~~~ /usr/inclu
							      								    								  de/c++/8/bits/random.h:2782:5: note:	 template ar
							      								    								  gument deduction/substitution failed: MINIMUM_OPER
							      								    								  ATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:
							      								    								   ‘std::unordered_set<int>::iterator’ {aka ‘std::__
							      								    								  detail::_Node_iterator<int, true, false>’} is not
							      								    								  derived from ‘const std::chi_squared_distribution<
							      								    								  _RealType>’	 i != hash . end ( ) ;
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /random:49,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	   from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUA
							      								    								  L_ARRAY.cpp:14: /usr/include/c++/8/bits/random.h:2
							      								    								  954:5: note: candidate: ‘template<class _RealType>
							      								    								   bool std::operator!=(const std::cauchy_distributi
							      								    								  on<_RealType>&, const std::cauchy_distribution<_Re
							      								    								  alType>&)’	  operator!=(const std::cauchy_distr
							      								    								  ibution<_RealType>& __d1,	 ^~~~~~~~ /usr/inclu
							      								    								  de/c++/8/bits/random.h:2954:5: note:	 template ar
							      								    								  gument deduction/substitution failed: MINIMUM_OPER
							      								    								  ATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:
							      								    								   ‘std::unordered_set<int>::iterator’ {aka ‘std::__
							      								    								  detail::_Node_iterator<int, true, false>’} is not
							      								    								  derived from ‘const std::cauchy_distribution<_Real
							      								    								  Type>’    i != hash . end ( ) ;
							      								    								     ^ In file included from /usr/include/c++/8/rand
							      								    								  om:49,		  from /usr/include/c++/8/x8
							      								    								  6_64-redhat-linux/bits/stdc++.h:108,
							      								    								      from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARR
							      								    								  AY.cpp:14: /usr/include/c++/8/bits/random.h:3215:5
							      								    								  : note: candidate: ‘template<class _RealType> bool
							      								    								   std::operator!=(const std::fisher_f_distribution<
							      								    								  _RealType>&, const std::fisher_f_distribution<_Rea
							      								    								  lType>&)’	 operator!=(const std::fisher_f_dist
							      								    								  ribution<_RealType>& __d1,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/random.h:3215:5: note:	  template a
							      								    								  rgument deduction/substitution failed: MINIMUM_OPE
							      								    								  RATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:
							      								    								    ‘std::unordered_set<int>::iterator’ {aka ‘std::_
							      								    								  _detail::_Node_iterator<int, true, false>’} is not
							      								    								   derived from ‘const std::fisher_f_distribution<_R
							      								    								  ealType>’    i != hash . end ( ) ;
							      								    								  	^ In file included from /usr/include/c++/8/r
							      								    								  andom:49,		     from /usr/include/c++/8
							      								    								  /x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	 from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_
							      								    								  ARRAY.cpp:14: /usr/include/c++/8/bits/random.h:343
							      								    								  3:5: note: candidate: ‘template<class _RealType> b
							      								    								  ool std::operator!=(const std::student_t_distribut
							      								    								  ion<_RealType>&, const std::student_t_distribution
							      								    								  <_RealType>&)’      operator!=(const std::student_
							      								    								  t_distribution<_RealType>& __d1,	^~~~~~~~ /us
							      								    								  r/include/c++/8/bits/random.h:3433:5: note:	temp
							      								    								  late argument deduction/substitution failed: MINIM
							      								    								  UM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21:
							      								    								  note:	  ‘std::unordered_set<int>::iterator’ {aka ‘
							      								    								  std::__detail::_Node_iterator<int, true, false>’}
							      								    								  is not derived from ‘const std::student_t_distribu
							      								    								  tion<_RealType>’    i != hash . end ( ) ;
							      								    								  	       ^ In file included from /usr/include/
							      								    								  c++/8/random:49,		    from /usr/includ
							      								    								  e/c++/8/x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  		from MINIMUM_OPERATION_MAKE_ELEMENTS
							      								    								  _EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bits/rando
							      								    								  m.h:3614:3: note: candidate: ‘bool std::operator!=
							      								    								  (const std::bernoulli_distribution&, const std::be
							      								    								  rnoulli_distribution&)’    operator!=(const std::b
							      								    								  ernoulli_distribution& __d1,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/random.h:3614:3: note:	  no known c
							      								    								  onversion for argument 1 from ‘std::unordered_set<
							      								    								  int>::iterator’ {aka ‘std::__detail::_Node_iterato
							      								    								  r<int, true, false>’} to ‘const std::bernoulli_dis
							      								    								  tribution&’ /usr/include/c++/8/bits/random.h:3885:
							      								    								  5: note: candidate: ‘template<class _IntType> bool
							      								    								   std::operator!=(const std::binomial_distribution<
							      								    								  _IntType>&, const std::binomial_distribution<_IntT
							      								    								  ype>&)’      operator!=(const std::binomial_distri
							      								    								  bution<_IntType>& __d1,      ^~~~~~~~ /usr/include
							      								    								  /c++/8/bits/random.h:3885:5: note:   template argu
							      								    								  ment deduction/substitution failed: MINIMUM_OPERAT
							      								    								  ION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘
							      								    								  std::unordered_set<int>::iterator’ {aka ‘std::__de
							      								    								  tail::_Node_iterator<int, true, false>’} is not de
							      								    								  rived from ‘const std::binomial_distribution<_IntT
							      								    								  ype>’	   i != hash . end ( ) ;
							      								    								    ^ In file included from /usr/include/c++/8/rando
							      								    								  m:49,			 from /usr/include/c++/8/x86
							      								    								  _64-redhat-linux/bits/stdc++.h:108,
							      								    								     from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRA
							      								    								  Y.cpp:14: /usr/include/c++/8/bits/random.h:4059:5:
							      								    								   note: candidate: ‘template<class _IntType> bool s
							      								    								  td::operator!=(const std::geometric_distribution<_
							      								    								  IntType>&, const std::geometric_distribution<_IntT
							      								    								  ype>&)’      operator!=(const std::geometric_distr
							      								    								  ibution<_IntType>& __d1,	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/random.h:4059:5: note:	template arg
							      								    								  ument deduction/substitution failed: MINIMUM_OPERA
							      								    								  TION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:
							      								    								  ‘std::unordered_set<int>::iterator’ {aka ‘std::__d
							      								    								  etail::_Node_iterator<int, true, false>’} is not d
							      								    								  erived from ‘const std::geometric_distribution<_In
							      								    								  tType>’    i != hash . end ( ) ;
							      								    								      ^ In file included from /usr/include/c++/8/ran
							      								    								  dom:49,		   from /usr/include/c++/8/x
							      								    								  86_64-redhat-linux/bits/stdc++.h:108,
							      								    								       from MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_AR
							      								    								  RAY.cpp:14: /usr/include/c++/8/bits/random.h:4309:
							      								    								  5: note: candidate: ‘template<class _IntType> bool
							      								    								   std::operator!=(const std::negative_binomial_dist
							      								    								  ribution<_IntType>&, const std::negative_binomial_
							      								    								  distribution<_IntType>&)’	 operator!=(const st
							      								    								  d::negative_binomial_distribution<_IntType>& __d1,
							      								    								  	^~~~~~~~ /usr/include/c++/8/bits/random.h:43
							      								    								  09:5: note:	template argument deduction/substitu
							      								    								  tion failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL
							      								    								  _ARRAY.cpp:36:21: note:   ‘std::unordered_set<int>
							      								    								  ::iterator’ {aka ‘std::__detail::_Node_iterator<in
							      								    								  t, true, false>’} is not derived from ‘const std::
							      								    								  negative_binomial_distribution<_IntType>’    i !=
							      								    								  hash . end ( ) ;			^ In file in
							      								    								  cluded from /usr/include/c++/8/random:49,
							      								    								  	   from /usr/include/c++/8/x86_64-redhat-lin
							      								    								  ux/bits/stdc++.h:108,			 from MINIMU
							      								    								  M_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr
							      								    								  /include/c++/8/bits/random.h:4530:5: note: candida
							      								    								  te: ‘template<class _IntType> bool std::operator!=
							      								    								  (const std::poisson_distribution<_IntType>&, const
							      								    								   std::poisson_distribution<_IntType>&)’      opera
							      								    								  tor!=(const std::poisson_distribution<_IntType>& _
							      								    								  _d1,	    ^~~~~~~~ /usr/include/c++/8/bits/random.
							      								    								  h:4530:5: note:   template argument deduction/subs
							      								    								  titution failed: MINIMUM_OPERATION_MAKE_ELEMENTS_E
							      								    								  QUAL_ARRAY.cpp:36:21: note:	‘std::unordered_set<
							      								    								  int>::iterator’ {aka ‘std::__detail::_Node_iterato
							      								    								  r<int, true, false>’} is not derived from ‘const s
							      								    								  td::poisson_distribution<_IntType>’	 i != hash .
							      								    								   end ( ) ;			  ^ In file included
							      								    								   from /usr/include/c++/8/random:49,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:108,		   from MINIMUM_OPER
							      								    								  ATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/inclu
							      								    								  de/c++/8/bits/random.h:4713:5: note: candidate: ‘t
							      								    								  emplate<class _RealType> bool std::operator!=(cons
							      								    								  t std::exponential_distribution<_RealType>&, const
							      								    								   std::exponential_distribution<_RealType>&)’
							      								    								  operator!=(const std::exponential_distribution<_Re
							      								    								  alType>& __d1,      ^~~~~~~~ /usr/include/c++/8/bi
							      								    								  ts/random.h:4713:5: note:   template argument dedu
							      								    								  ction/substitution failed: MINIMUM_OPERATION_MAKE_
							      								    								  ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	  ‘std::unor
							      								    								  dered_set<int>::iterator’ {aka ‘std::__detail::_No
							      								    								  de_iterator<int, true, false>’} is not derived fro
							      								    								  m ‘const std::exponential_distribution<_RealType>’
							      								    								      i != hash . end ( ) ;			 ^ I
							      								    								  n file included from /usr/include/c++/8/random:49,
							      								    								  		    from /usr/include/c++/8/x86_64-r
							      								    								  edhat-linux/bits/stdc++.h:108,		  fr
							      								    								  om MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp
							      								    								  :14: /usr/include/c++/8/bits/random.h:4921:5: note
							      								    								  : candidate: ‘template<class _RealType> bool std::
							      								    								  operator!=(const std::weibull_distribution<_RealTy
							      								    								  pe>&, const std::weibull_distribution<_RealType>&)
							      								    								  ’	 operator!=(const std::weibull_distribution<
							      								    								  _RealType>& __d1,	 ^~~~~~~~ /usr/include/c++/8
							      								    								  /bits/random.h:4921:5: note:	 template argument d
							      								    								  eduction/substitution failed: MINIMUM_OPERATION_MA
							      								    								  KE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:   ‘std::u
							      								    								  nordered_set<int>::iterator’ {aka ‘std::__detail::
							      								    								  _Node_iterator<int, true, false>’} is not derived
							      								    								  from ‘const std::weibull_distribution<_RealType>’
							      								    								     i != hash . end ( ) ;			^ In
							      								    								   file included from /usr/include/c++/8/random:49,
							      								    								  		   from /usr/include/c++/8/x86_64-re
							      								    								  dhat-linux/bits/stdc++.h:108,			 fro
							      								    								  m MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:
							      								    								  14: /usr/include/c++/8/bits/random.h:5129:5: note:
							      								    								   candidate: ‘template<class _RealType> bool std::o
							      								    								  perator!=(const std::extreme_value_distribution<_R
							      								    								  ealType>&, const std::extreme_value_distribution<_
							      								    								  RealType>&)’	    operator!=(const std::extreme_va
							      								    								  lue_distribution<_RealType>& __d1,	  ^~~~~~~~ /
							      								    								  usr/include/c++/8/bits/random.h:5129:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: MIN
							      								    								  IMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21
							      								    								  : note:   ‘std::unordered_set<int>::iterator’ {aka
							      								    								   ‘std::__detail::_Node_iterator<int, true, false>’
							      								    								  } is not derived from ‘const std::extreme_value_di
							      								    								  stribution<_RealType>’    i != hash . end ( ) ;
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/random:49,		  from /usr/
							      								    								  include/c++/8/x86_64-redhat-linux/bits/stdc++.h:10
							      								    								  8,		      from MINIMUM_OPERATION_MAKE_EL
							      								    								  EMENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bits
							      								    								  /random.h:5394:5: note: candidate: ‘template<class
							      								    								   _IntType> bool std::operator!=(const std::discret
							      								    								  e_distribution<_IntType>&, const std::discrete_dis
							      								    								  tribution<_IntType>&)’      operator!=(const std::
							      								    								  discrete_distribution<_IntType>& __d1,      ^~~~~~
							      								    								  ~~ /usr/include/c++/8/bits/random.h:5394:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:3
							      								    								  6:21: note:	‘std::unordered_set<int>::iterator’
							      								    								  {aka ‘std::__detail::_Node_iterator<int, true, fal
							      								    								  se>’} is not derived from ‘const std::discrete_dis
							      								    								  tribution<_IntType>’	  i != hash . end ( ) ;
							      								    								  		   ^ In file included from /usr/incl
							      								    								  ude/c++/8/random:49,			from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  		    from MINIMUM_OPERATION_MAKE_ELEM
							      								    								  ENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bits/r
							      								    								  andom.h:5666:5: note: candidate: ‘template<class _
							      								    								  RealType> bool std::operator!=(const std::piecewis
							      								    								  e_constant_distribution<_RealType>&, const std::pi
							      								    								  ecewise_constant_distribution<_RealType>&)’	   o
							      								    								  perator!=(const std::piecewise_constant_distributi
							      								    								  on<_RealType>& __d1,	    ^~~~~~~~ /usr/include/c+
							      								    								  +/8/bits/random.h:5666:5: note:   template argumen
							      								    								  t deduction/substitution failed: MINIMUM_OPERATION
							      								    								  _MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: note:	‘std
							      								    								  ::unordered_set<int>::iterator’ {aka ‘std::__detai
							      								    								  l::_Node_iterator<int, true, false>’} is not deriv
							      								    								  ed from ‘const std::piecewise_constant_distributio
							      								    								  n<_RealType>’	   i != hash . end ( ) ;
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/random:49,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	     from MINIMUM_OPERATION_MAKE_ELEMENTS_EQ
							      								    								  UAL_ARRAY.cpp:14: /usr/include/c++/8/bits/random.h
							      								    								  :5940:5: note: candidate: ‘template<class _RealTyp
							      								    								  e> bool std::operator!=(const std::piecewise_linea
							      								    								  r_distribution<_RealType>&, const std::piecewise_l
							      								    								  inear_distribution<_RealType>&)’	operator!=(c
							      								    								  onst std::piecewise_linear_distribution<_RealType>
							      								    								  & __d1,      ^~~~~~~~ /usr/include/c++/8/bits/rand
							      								    								  om.h:5940:5: note:   template argument deduction/s
							      								    								  ubstitution failed: MINIMUM_OPERATION_MAKE_ELEMENT
							      								    								  S_EQUAL_ARRAY.cpp:36:21: note:   ‘std::unordered_s
							      								    								  et<int>::iterator’ {aka ‘std::__detail::_Node_iter
							      								    								  ator<int, true, false>’} is not derived from ‘cons
							      								    								  t std::piecewise_linear_distribution<_RealType>’
							      								    								    i != hash . end ( ) ;		       ^ In
							      								    								  file included from /usr/include/c++/8/x86_64-redha
							      								    								  t-linux/bits/stdc++.h:111,		      from M
							      								    								  INIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14:
							      								    								   /usr/include/c++/8/scoped_allocator:468:5: note:
							      								    								  candidate: ‘template<class _OutA1, class _OutA2, c
							      								    								  lass ... _InA> bool std::operator!=(const std::sco
							      								    								  ped_allocator_adaptor<_OutA1, _InA ...>&, const st
							      								    								  d::scoped_allocator_adaptor<_InnerHead, _InnerTail
							      								    								   ...>&)’	operator!=(const scoped_allocator_ad
							      								    								  aptor<_OutA1, _InA...>& __a,	    ^~~~~~~~ /usr/in
							      								    								  clude/c++/8/scoped_allocator:468:5: note:   templa
							      								    								  te argument deduction/substitution failed: MINIMUM
							      								    								  _OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: no
							      								    								  te:	‘std::unordered_set<int>::iterator’ {aka ‘st
							      								    								  d::__detail::_Node_iterator<int, true, false>’} is
							      								    								   not derived from ‘const std::scoped_allocator_ada
							      								    								  ptor<_OutA1, _InA ...>’    i != hash . end ( ) ;
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/unordered_map:47,		  fr
							      								    								  om /usr/include/c++/8/x86_64-redhat-linux/bits/std
							      								    								  c++.h:117,		      from MINIMUM_OPERATION
							      								    								  _MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/include/c+
							      								    								  +/8/bits/unordered_map.h:2063:5: note: candidate:
							      								    								  ‘template<class _Key, class _Tp, class _Hash, clas
							      								    								  s _Pred, class _Alloc> bool std::operator!=(const
							      								    								  std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc
							      								    								  >&, const std::unordered_map<_Key, _Tp, _Hash, _Pr
							      								    								  ed, _Alloc>&)’      operator!=(const unordered_map
							      								    								  <_Key, _Tp, _Hash, _Pred, _Alloc>& __x,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/unordered_map.h:2063:5
							      								    								  : note:   template argument deduction/substitution
							      								    								   failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARR
							      								    								  AY.cpp:36:21: note:	‘std::unordered_set<int>::it
							      								    								  erator’ {aka ‘std::__detail::_Node_iterator<int, t
							      								    								  rue, false>’} is not derived from ‘const std::unor
							      								    								  dered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’	 i !
							      								    								  = hash . end ( ) ;			  ^ In file
							      								    								  included from /usr/include/c++/8/unordered_map:47,
							      								    								  		    from /usr/include/c++/8/x86_64-r
							      								    								  edhat-linux/bits/stdc++.h:117,		  fr
							      								    								  om MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp
							      								    								  :14: /usr/include/c++/8/bits/unordered_map.h:2075:
							      								    								  5: note: candidate: ‘template<class _Key, class _T
							      								    								  p, class _Hash, class _Pred, class _Alloc> bool st
							      								    								  d::operator!=(const std::unordered_multimap<_Key,
							      								    								  _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_
							      								    								  multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)’
							      								    								  operator!=(const unordered_multimap<_Key, _Tp, _Ha
							      								    								  sh, _Pred, _Alloc>& __x,	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/unordered_map.h:2075:5: note:   templ
							      								    								  ate argument deduction/substitution failed: MINIMU
							      								    								  M_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:36:21: n
							      								    								  ote:	 ‘std::unordered_set<int>::iterator’ {aka ‘s
							      								    								  td::__detail::_Node_iterator<int, true, false>’} i
							      								    								  s not derived from ‘const std::unordered_multimap<
							      								    								  _Key, _Tp, _Hash, _Pred, _Alloc>’    i != hash . e
							      								    								  nd ( ) ;			^ In file included f
							      								    								  rom /usr/include/c++/8/unordered_set:47,
							      								    								  	  from /usr/include/c++/8/x86_64-redhat-linu
							      								    								  x/bits/stdc++.h:118,			from MINIMUM
							      								    								  _OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/
							      								    								  include/c++/8/bits/unordered_set.h:1675:5: note: c
							      								    								  andidate: ‘template<class _Value, class _Hash, cla
							      								    								  ss _Pred, class _Alloc> bool std::operator!=(const
							      								    								   std::unordered_set<_Value, _Hash, _Pred, _Alloc>&
							      								    								  , const std::unordered_set<_Value, _Hash, _Pred, _
							      								    								  Alloc>&)’	 operator!=(const unordered_set<_Val
							      								    								  ue, _Hash, _Pred, _Alloc>& __x,      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/unordered_set.h:1675:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:3
							      								    								  6:21: note:	‘std::unordered_set<int>::iterator’
							      								    								  {aka ‘std::__detail::_Node_iterator<int, true, fal
							      								    								  se>’} is not derived from ‘const std::unordered_se
							      								    								  t<_Value, _Hash, _Pred, _Alloc>’    i != hash . en
							      								    								  d ( ) ;		       ^ In file included fr
							      								    								  om /usr/include/c++/8/unordered_set:47,
							      								    								  	 from /usr/include/c++/8/x86_64-redhat-linux
							      								    								  /bits/stdc++.h:118,		       from MINIMUM_
							      								    								  OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/i
							      								    								  nclude/c++/8/bits/unordered_set.h:1687:5: note: ca
							      								    								  ndidate: ‘template<class _Value, class _Hash, clas
							      								    								  s _Pred, class _Alloc> bool std::operator!=(const
							      								    								  std::unordered_multiset<_Value, _Hash, _Pred, _All
							      								    								  oc>&, const std::unordered_multiset<_Value, _Hash,
							      								    								   _Pred, _Alloc>&)’	  operator!=(const unordered
							      								    								  _multiset<_Value, _Hash, _Pred, _Alloc>& __x,
							      								    								   ^~~~~~~~ /usr/include/c++/8/bits/unordered_set.h:
							      								    								  1687:5: note:	  template argument deduction/substi
							      								    								  tution failed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQU
							      								    								  AL_ARRAY.cpp:36:21: note:   ‘std::unordered_set<in
							      								    								  t>::iterator’ {aka ‘std::__detail::_Node_iterator<
							      								    								  int, true, false>’} is not derived from ‘const std
							      								    								  ::unordered_multiset<_Value, _Hash, _Pred, _Alloc>
							      								    								  ’    i != hash . end ( ) ;			  ^
							      								    								  In file included from /usr/include/c++/8/bits/hash
							      								    								  table.h:35,		       from /usr/include/c++
							      								    								  /8/unordered_map:46,			from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:117,
							      								    								  		    from MINIMUM_OPERATION_MAKE_ELEM
							      								    								  ENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bits/h
							      								    								  ashtable_policy.h:312:5: note: candidate: ‘templat
							      								    								  e<class _Value, bool _Cache_hash_code> bool std::_
							      								    								  _detail::operator!=(const std::__detail::_Node_ite
							      								    								  rator_base<_Value, _Cache_hash_code>&, const std::
							      								    								  __detail::_Node_iterator_base<_Value, _Cache_hash_
							      								    								  code>&)’	operator!=(const _Node_iterator_base
							      								    								  <_Value, _Cache_hash_code>& __x,	^~~~~~~~ /us
							      								    								  r/include/c++/8/bits/hashtable_policy.h:312:5: not
							      								    								  e:   template argument deduction/substitution fail
							      								    								  ed: MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cp
							      								    								  p:36:21: note:   deduced conflicting types for par
							      								    								  ameter ‘_Value’ (‘int’ and ‘std::pair<const int, i
							      								    								  nt>’)	   i != hash . end ( ) ;
							      								    								    ^ In file included from /usr/include/c++/8/bits/
							      								    								  hashtable.h:35,		   from /usr/include
							      								    								  /c++/8/unordered_map:46,		    from /us
							      								    								  r/include/c++/8/x86_64-redhat-linux/bits/stdc++.h:
							      								    								  117,			from MINIMUM_OPERATION_MAKE_
							      								    								  ELEMENTS_EQUAL_ARRAY.cpp:14: /usr/include/c++/8/bi
							      								    								  ts/hashtable_policy.h:1647:5: note: candidate: ‘te
							      								    								  mplate<class _Key, class _Value, class _ExtractKey
							      								    								  , class _H1, class _H2, class _Hash, bool __cache>
							      								    								   bool std::__detail::operator!=(const std::__detai
							      								    								  l::_Local_iterator_base<_Key, _Value, _ExtractKey,
							      								    								   _H1, _H2, _Hash, __cache>&, const std::__detail::
							      								    								  _Local_iterator_base<_Key, _Value, _ExtractKey, _H
							      								    								  1, _H2, _Hash, __cache>&)’	  operator!=(const _
							      								    								  Local_iterator_base<_Key, _Value, _ExtractKey,
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/hashtable_polic
							      								    								  y.h:1647:5: note:   template argument deduction/su
							      								    								  bstitution failed: MINIMUM_OPERATION_MAKE_ELEMENTS
							      								    								  _EQUAL_ARRAY.cpp:36:21: note:	  ‘std::unordered_se
							      								    								  t<int>::iterator’ {aka ‘std::__detail::_Node_itera
							      								    								  tor<int, true, false>’} is not derived from ‘const
							      								    								   std::__detail::_Local_iterator_base<_Key, _Value,
							      								    								   _ExtractKey, _H1, _H2, _Hash, __cache>’    i != h
							      								    								  ash . end ( ) ;		       ^ MINIMUM_OPE
							      								    								  RATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:37:32: error:
							      								    								   request for member ‘second’ in ‘* i.std::__detail
							      								    								  ::_Node_iterator<int, true, false>::operator->()’,
							      								    								   which is of non-class type ‘const int’    i ++ )
							      								    								  if ( max_count < i -> second ) max_count = i -> se
							      								    								  cond ;				 ^~~~~~ MINI
							      								    								  MUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:37:58:
							      								    								   error: request for member ‘second’ in ‘* i.std::_
							      								    								  _detail::_Node_iterator<int, true, false>::operato
							      								    								  r->()’, which is of non-class type ‘const int’
							      								    								  i ++ ) if ( max_count < i -> second ) max_count =
							      								    								  i -> second ;
							      								    								  			^~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS			      NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS			    NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS			  NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS
--							      --							    --								  --
static int numberOfPermWithKInversion ( int N , int K ) {     int numberOfPermWithKInversion ( int N , int K ) {	    int numberOfPermWithKInversion ( int N , int K ) {		  script_not_found : None
  if ( N == 0 ) return 0 ;				      	if ( N == 0 ) return 0 ;				      if ( N == 0 ) return 0 ;					  
  if ( K == 0 ) return 1 ;				      	if ( K == 0 ) return 1 ;				      if ( K == 0 ) return 1 ;					  
  if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ;      	if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ;	      if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ;	  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= K ;						      	i <= K ;						      i <= K ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 	  if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 	if ( i <= N - 1 ) {					  
  }							      	}							    	  sum += numberOfPermWithKInversion ( N - 1 , K - i ) ;	  
  memo [ N ] [ K ] = sum ;				      	memo [ N ] [ K ] = sum ;				    	}							  
  return sum ;						      	return sum ;						      }								  
}							      }								      memo [ N ] [ K ] = sum ;					  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KNAPSACK_PROBLEM					      KNAPSACK_PROBLEM						    KNAPSACK_PROBLEM						  KNAPSACK_PROBLEM
--							      --							    --								  --
static int knapSack ( int W , int wt [ ] , int val [ ] , int  int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {   int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {	  script_not_found : None
  if ( n == 0 || W == 0 ) return 0 ;			      	if ( n == 0 || W == 0 ) return 0 ;			      if ( n == 0 || W == 0 ) return 0 ;			  
  if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n  	if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n    if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n  
  else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 	else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1   else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE			      FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE			    FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE				  FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE
--							      --							    --								  --
static String Dragon_Curve_Sequence ( int n ) {		      string Dragon_Curve_Sequence ( int n ) {			    string Dragon_Curve_Sequence ( int n ) {			  script_not_found : None
  String s = "1" ;					      	string s = "1" ;					      string s = "1" ;						  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    String temp = "1" ;					      	  string temp = "1" ;					    	string temp = "1" ;					  
    char prev = '1' , zero = '0' , one = '1' ;		      	  char prev = '1' , zero = '0' , one = '1' ;		    	char prev = '1' , zero = '0' , one = '1' ;		  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < s . length ( ) ;				      	  j < s . length ( ) ;					    	j < s . length ( ) ;					  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      temp += s . charAt ( j ) ;			      	    temp += s [ j ] ;					    	  temp += s [ j ] ;					  
      if ( prev == '0' ) {				      	    if ( prev == '0' ) {				    	  if ( prev == '0' ) {					  
	temp += one ;					      	      temp += one ;					    	    temp += one ;					  
	prev = one ;					      	      prev = one ;					    	    prev = one ;					  
      }							      	    }							    	  }							  
      else {						      	    else {						    	  else {						  
	temp += zero ;					      	      temp += zero ;					    	    temp += zero ;					  
	prev = zero ;					      	      prev = zero ;					    	    prev = zero ;					  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
    s = temp ;						      	  s = temp ;						    	s = temp ;						  
  }							      	}							      }								  
  return s ;						      	return s ;						      return s ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2	      PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2		    PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2		  PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2
--							      --							    --								  --
static void printSubsequences ( String s ) {		      void printSubsequences ( string str ) {			    void printSubsequences ( string s ) {			  script_not_found : None
  char [ ] str = s . toCharArray ( ) ;			      	int n = str . length ( ) ;				      string :: size_type pos = s . find ( " " ) ;		  
  int n = str . length ;				      	unsigned int opsize = pow ( 2 , n - 1 ) ;		      if ( pos != string :: npos ) {				  
  int opsize = ( int ) ( Math . pow ( 2 , n - 1 ) ) ;	      	for ( int counter = 0 ;					    	int n = s . length ( ) ;				  
  for ( int counter = 0 ;				      	counter < opsize ;					    	int opsize = ( int ) ( pow ( 2 , n - 1 ) ) ;		  
  counter < opsize ;					      	counter ++ ) {						    	for ( int counter = 0 ;					  
  counter ++ ) {					      	  for ( int j = 0 ;					    	counter < opsize ;					  
    for ( int j = 0 ;					      	  j < n ;						    	counter ++ ) {						  
    j < n ;						      	  j ++ ) {						    	  for ( int j = 0 ;					  
    j ++ ) {						      	    cout << str [ j ] ;					    	  j < n ;						  
      System . out . print ( str [ j ] ) ;		      	    if ( counter & ( 1 << j ) ) cout << " " ;		    	  j ++ ) {						  
      if ( ( counter & ( 1 << j ) ) > 0 ) System . out . prin 	  }							    	    cout << s [ pos + j ] ;				  
    }							      	  cout << endl ;					    	    if ( ( counter & ( 1 << j ) ) > 0 ) {		  
    System . out . println ( ) ;			      	}							    	      cout << " " ;					  
  }							      }								    	    }							  
}							      								    	  }							  
							      								    	  cout << endl ;					  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY			      FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY			    FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY			  FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY
--							      --							    --								  --
static int firstElement ( int arr [ ] , int n , int k ) {     int firstElement ( int arr [ ] , int n , int k ) {	    int firstElement ( int arr [ ] , int n , int k ) {		  success : None
  HashMap < Integer , Integer > count_map = new HashMap < > ( 	unordered_map < int , int > count_map ;			      unordered_map < int , int > count_map ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) count_map [ arr [ i ] ] ++ ;			      i ++ ) {							  
    int a = 0 ;						      	for ( int i = 0 ;					    	int a = 0 ;						  
    if ( count_map . get ( arr [ i ] ) != null ) {	      	i < n ;							    	if ( count_map . find ( arr [ i ] ) != count_map . end (  
      a = count_map . get ( arr [ i ] ) ;		      	i ++ ) if ( count_map [ arr [ i ] ] == k ) return arr [ i ] 	count_map [ arr [ i ] ] = a + 1 ;			  
    }							      	return - 1 ;						      }								  
    count_map . put ( arr [ i ] , a + 1 ) ;		      }								      for ( int i = 0 ;						  
  }							      								      i < n ;							  
  for ( int i = 0 ;					      								      i ++ ) {							  
  i < n ;						      								    	if ( count_map [ arr [ i ] ] == k ) return arr [ i ] ;	  
  i ++ ) {						      								      }								  
    if ( count_map . get ( arr [ i ] ) == k ) {		      								      return - 1 ;						  
      return arr [ i ] ;				      								    }								  
    }							      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVIDE_LARGE_NUMBER_REPRESENTED_STRING			      DIVIDE_LARGE_NUMBER_REPRESENTED_STRING			    DIVIDE_LARGE_NUMBER_REPRESENTED_STRING			  DIVIDE_LARGE_NUMBER_REPRESENTED_STRING
--							      --							    --								  --
static String longDivision ( String number , int divisor ) {  string longDivision ( string number , int divisor ) {	    string longDivision ( string number , int divisor ) {	  error : /bin/bash: line 1: 3925997 Aborted
  String ans = "" ;					      	string ans ;						      string ans ;						  	   (core dumped) ./DIVIDE_LARGE_NUMBER_REPRE
  int idx = 0 ;						      	int idx = 0 ;						      int idx = 0 ;						  SENTED_STRING_cpp
  char [ ] num = number . toCharArray ( ) ;		      	int temp = number [ idx ] - '0' ;			      string num = number ;					  
  int temp = num [ idx ] - '0' ;			      	while ( temp < divisor ) temp = temp * 10 + ( number [ ++ i   int temp = num [ idx ] - '0' ;				  
  while ( temp < divisor ) temp = temp * 10 + ( num [ ++ idx  	while ( number . size ( ) > idx ) {			      while ( temp < divisor ) {				  
  idx += 1 ;						      	  ans += ( temp / divisor ) + '0' ;			    	temp = temp * 10 + ( num [ ++ idx ] - '0' ) ;		  
  while ( num . length > idx ) {			      	  temp = ( temp % divisor ) * 10 + number [ ++ idx ] - '0'    }								  
    ans += ( temp / divisor ) ;				      	}							      idx += 1 ;						  
    temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' ;   	if ( ans . length ( ) == 0 ) return "0" ;		      while ( num . length ( ) > idx ) {			  
  }							      	return ans ;						    	ans += ( temp / divisor ) ;				  
  if ( ans . length ( ) == 0 ) return "0" ;		      }								    	temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' ;	  
  return ans ;						      								      }								  
}							      								      if ( ans . length ( ) == 0 ) return "0" ;			  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1	      MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1		    MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1		  MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1
--							      --							    --								  --
static char maxRepeating ( String str ) {		      char maxRepeating ( string str ) {			    char maxRepeating ( string str ) {				  success : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  char res = str . charAt ( 0 ) ;			      	char res = str [ 0 ] ;					      char res = str [ 0 ] ;					  
  int cur_count = 1 ;					      	int cur_count = 1 ;					      int cur_count = 1 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( i < n - 1 && str . charAt ( i ) == str . charAt ( i  	  if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count  	if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) {	  
    else {						      	  else {						    	  cur_count ++ ;					  
      if ( cur_count > count ) {			      	    if ( cur_count > count ) {				    	}							  
	count = cur_count ;				      	      count = cur_count ;				    	else {							  
	res = str . charAt ( i ) ;			      	      res = str [ i ] ;					    	  if ( cur_count > count ) {				  
      }							      	    }							    	    count = cur_count ;					  
      cur_count = 1 ;					      	    cur_count = 1 ;					    	    res = str [ i ] ;					  
    }							      	  }							    	  }							  
  }							      	}							    	  cur_count = 1 ;					  
  return res ;						      	return res ;						    	}							  
}							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_BONACCI_NUMBERS_1					      N_BONACCI_NUMBERS_1					    N_BONACCI_NUMBERS_1						  N_BONACCI_NUMBERS_1
--							      --							    --								  --
static void bonacciseries ( int n , int m ) {		      void bonacciseries ( long n , int m ) {			    void bonacciseries ( int n , int m ) {			  script_not_found : None
  int a [ ] = new int [ m ] ;				      	int a [ m ] = {						      int a [ m ] ;						  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < m ;						      	  ;							      i < m ;							  
  i ++ ) a [ i ] = 0 ;					      	  a [ n - 1 ] = 1 ;					      i ++ ) {							  
  a [ n - 1 ] = 1 ;					      	  a [ n ] = 1 ;						    	a [ i ] = 0 ;						  
  a [ n ] = 1 ;						      	  for ( int i = n + 1 ;					      }								  
  for ( int i = n + 1 ;					      	  i < m ;						      a [ n - 1 ] = 1 ;						  
  i < m ;						      	  i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ;	      a [ n ] = 1 ;						  
  i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ;	      	  for ( int i = 0 ;					      for ( int i = n + 1 ;					  
  for ( int i = 0 ;					      	  i < m ;						      i < m ;							  
  i < m ;						      	  i ++ ) cout << a [ i ] << " " ;			      i ++ ) {							  
  i ++ ) System . out . print ( a [ i ] + " " ) ;	      	}							    	a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ;		  
}							      								      }								  
							      								      for ( int i = 0 ;						  
							      								      i < m ;							  
							      								      i ++ ) {							  
							      								    	cout << a [ i ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_TRIANGLES_POSSIBLE			      FIND_NUMBER_OF_TRIANGLES_POSSIBLE				    FIND_NUMBER_OF_TRIANGLES_POSSIBLE				  FIND_NUMBER_OF_TRIANGLES_POSSIBLE
--							      --							    --								  --
static int findNumberOfTriangles ( int arr [ ] ) {	      int findNumberOfTriangles ( int arr [ ] , int n ) {	    int findNumberOfTriangles ( int arr [ ] ) {			  script_not_found : None
  int n = arr . length ;				      	qsort ( arr , n , sizeof ( arr [ 0 ] ) , comp ) ;	      int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  Arrays . sort ( arr ) ;				      	int count = 0 ;						      sort ( arr , arr + n ) ;					  
  int count = 0 ;					      	for ( int i = 0 ;					      int count = 0 ;						  
  for ( int i = 0 ;					      	i < n - 2 ;						      for ( int i = 0 ;						  
  i < n - 2 ;						      	++ i ) {						      i < n - 2 ;						  
  ++ i ) {						      	  int k = i + 2 ;					      ++ i ) {							  
    int k = i + 2 ;					      	  for ( int j = i + 1 ;					    	int k = i + 2 ;						  
    for ( int j = i + 1 ;				      	  j < n ;						    	for ( int j = i + 1 ;					  
    j < n ;						      	  ++ j ) {						    	j < n ;							  
    ++ j ) {						      	    while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ 	++ j ) {						  
      while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ 	    if ( k > j ) count += k - j - 1 ;			    	  while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ 
      if ( k > j ) count += k - j - 1 ;			      	  }							    	  if ( k > j ) count += k - j - 1 ;			  
    }							      	}							    	}							  
  }							      	return count ;						      }								  
  return count ;					      }								      return count ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS     SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS	    SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS	  SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS
--							      --							    --								  --
static int findSum ( int n ) {				      int findSum ( int n ) {					    int findSum ( int n ) {					  success : None
  int [ ] [ ] arr = new int [ n ] [ n ] ;		      	int arr [ n ] [ n ] ;					      vector < vector < int >> arr ( n , vector < int > ( n , 0 ) 
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ;	      	j ++ ) arr [ i ] [ j ] = abs ( i - j ) ;		      j ++ ) arr [ i ] [ j ] = abs ( i - j ) ;			  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) sum += arr [ i ] [ j ] ;			      	j ++ ) sum += arr [ i ] [ j ] ;				      j ++ ) sum += arr [ i ] [ j ] ;				  
  return sum ;						      	return sum ;						      return sum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU
--							      --							    --								  --
static boolean canMakeStr2 ( String str1 , String str2 ) {    bool canMakeStr2 ( string str1 , string str2 ) {		    bool canMakeStr2 ( string str1 , string str2 ) {		  script_not_found : None
  int [ ] count = new int [ MAX ] ;			      	int count [ MAX ] = {					      int count [ MAX ] ;					  
  char [ ] str3 = str1 . toCharArray ( ) ;		      	  0 }							      string :: size_type str3 = str1 . size ( ) ;		  
  for ( int i = 0 ;					      	  ;							      for ( int i = 0 ;						  
  i < str3 . length ;					      	  for ( int i = 0 ;					      i < str3 ;						  
  i ++ ) count [ str3 [ i ] ] ++ ;			      	  i < str1 . length ( ) ;				      i ++ ) {							  
  char [ ] str4 = str2 . toCharArray ( ) ;		      	  i ++ ) count [ str1 [ i ] ] ++ ;			    	count [ str3 ] ++ ;					  
  for ( int i = 0 ;					      	  for ( int i = 0 ;					      }								  
  i < str4 . length ;					      	  i < str2 . length ( ) ;				      string :: size_type str4 = str2 . size ( ) ;		  
  i ++ ) {						      	  i ++ ) {						      for ( int i = 0 ;						  
    if ( count [ str4 [ i ] ] == 0 ) return false ;	      	    if ( count [ str2 [ i ] ] == 0 ) return false ;	      i < str4 ;						  
    count [ str4 [ i ] ] -- ;				      	    count [ str2 [ i ] ] -- ;				      i ++ ) {							  
  }							      	  }							    	if ( count [ str4 ] == 0 ) return false ;		  
  return true ;						      	  return true ;						    	count [ str4 ] -- ;					  
}							      	}							      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND		      EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND		    EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND		  EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND
--							      --							    --								  --
public static int calculateSum ( String arr [ ] , int n ) {   int calculateSum ( string arr [ ] , int n ) {		    int calculateSum ( string arr [ ] , int n ) {		  script_not_found : None
  if ( n == 0 ) return 0 ;				      	if ( n == 0 ) return 0 ;				      if ( n == 0 ) return 0 ;					  
  String s = arr [ 0 ] ;				      	string s = arr [ 0 ] ;					      string s = arr [ 0 ] ;					  
  int value = Integer . parseInt ( s ) ;		      	int value = stoi ( s ) ;				      int value = atoi ( s . c_str ( ) ) ;			  
  int sum = value ;					      	int sum = value ;					      int sum = value ;						  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i = i + 2 ) {						      	i = i + 2 ) {						      i = i + 2 ) {						  
    s = arr [ i ] ;					      	  s = arr [ i ] ;					    	s = arr [ i ] ;						  
    value = Integer . parseInt ( s ) ;			      	  int value = stoi ( s ) ;				    	value = atoi ( s . c_str ( ) ) ;			  
    char operation = arr [ i - 1 ] . charAt ( 0 ) ;	      	  char operation = arr [ i - 1 ] [ 0 ] ;		    	char operation = arr [ i - 1 ] [ 0 ] ;			  
    if ( operation == '+' ) sum += value ;		      	  if ( operation == '+' ) sum += value ;		    	if ( operation == '+' ) {				  
    else sum -= value ;					      	  else sum -= value ;					    	  sum += value ;					  
  }							      	}							    	}							  
  return sum ;						      	return sum ;						    	else {							  
}							      }								    	  sum -= value ;					  
							      								    	}							  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAYS_DISTINCT_ELEMENTS				      SUBARRAYS_DISTINCT_ELEMENTS				    SUBARRAYS_DISTINCT_ELEMENTS					  SUBARRAYS_DISTINCT_ELEMENTS
--							      --							    --								  --
public static int sumoflength ( int [ ] arr , int n ) {	      int sumoflength ( int arr [ ] , int n ) {			    int sumoflength ( int * arr , int n ) {			  failure : #Results: 4, 10
  Set < Integer > s = new HashSet < > ( ) ;		      	unordered_set < int > s ;				      set < int > s ;						  
  int j = 0 , ans = 0 ;					      	int j = 0 , ans = 0 ;					      int j = 0 , ans = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    while ( j < n && ! s . contains ( arr [ j ] ) ) {	      	  while ( j < n && s . find ( arr [ j ] ) == s . end ( ) )  	while ( j < n && ! s . count ( arr [ j ] ) ) {		  
      s . add ( arr [ i ] ) ;				      	    s . insert ( arr [ j ] ) ;				    	  s . insert ( arr [ i ] ) ;				  
      j ++ ;						      	    j ++ ;						    	  j ++ ;						  
    }							      	  }							    	}							  
    ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;		      	  ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;		    	ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;		  
    s . remove ( arr [ i ] ) ;				      	  s . erase ( arr [ i ] ) ;				    	s . erase ( arr [ i ] ) ;				  
  }							      	}							      }								  
  return ans ;						      	return ans ;						      return ans ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE	      FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE	    FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE	  FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE
--							      --							    --								  --
static int findMinNumber ( int n ) {			      int findMinNumber ( int n ) {				    int findMinNumber ( int n ) {				  success : None
  int count = 0 , ans = 1 ;				      	int count = 0 , ans = 1 ;				      int count = 0 , ans = 1 ;					  
  while ( n % 2 == 0 ) {				      	while ( n % 2 == 0 ) {					      while ( n % 2 == 0 ) {					  
    count ++ ;						      	  count ++ ;						    	count ++ ;						  
    n /= 2 ;						      	  n /= 2 ;						    	n /= 2 ;						  
  }							      	}							      }								  
  if ( count % 2 == 1 ) ans *= 2 ;			      	if ( count % 2 ) ans *= 2 ;				      if ( count % 2 == 1 ) {					  
  for ( int i = 3 ;					      	for ( int i = 3 ;					    	ans *= 2 ;						  
  i <= Math . sqrt ( n ) ;				      	i <= sqrt ( n ) ;					      }								  
  i += 2 ) {						      	i += 2 ) {						      for ( int i = 3 ;						  
    count = 0 ;						      	  count = 0 ;						      i <= sqrt ( n ) ;						  
    while ( n % i == 0 ) {				      	  while ( n % i == 0 ) {				      i += 2 ) {						  
      count ++ ;					      	    count ++ ;						    	count = 0 ;						  
      n /= i ;						      	    n /= i ;						    	while ( n % i == 0 ) {					  
    }							      	  }							    	  count ++ ;						  
    if ( count % 2 == 1 ) ans *= i ;			      	  if ( count % 2 ) ans *= i ;				    	  n /= i ;						  
  }							      	}							    	}							  
  if ( n > 2 ) ans *= n ;				      	if ( n > 2 ) ans *= n ;					    	if ( count % 2 == 1 ) {					  
  return ans ;						      	return ans ;						    	  ans *= i ;						  
}							      }								    	}							  
							      								      }								  
							      								      if ( n > 2 ) {						  
							      								    	ans *= n ;						  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS     RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS	    RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS	  RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS
--							      --							    --								  --
static int countSubstrs ( String str , int i , int j , int n  int countSubstrs ( string str , int i , int j , int n ) {	    int countSubstrs ( string str , int i , int j , int n ) {	  script_not_found : None
  if ( n == 1 ) return 1 ;				      	if ( n == 1 ) return 1 ;				      if ( n == 1 ) return 1 ;					  
  if ( n <= 0 ) return 0 ;				      	if ( n <= 0 ) return 0 ;				      if ( n <= 0 ) return 0 ;					  
  int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countS 	int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countS   int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countS 
  if ( str . charAt ( i ) == str . charAt ( j ) ) res ++ ;    	if ( str [ i ] == str [ j ] ) res ++ ;			      if ( str [ i ] == str [ j ] ) res ++ ;			  
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3	    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3
--							      --							    --								  --
void printRepeating ( int arr [ ] , int size ) {	      void printRepeating ( int arr [ ] , int size ) {		    void printRepeating ( int arr [ ] , int size ) {		  script_not_found : None
  int i ;						      	int i ;							      int i ;							  
  System . out . println ( "The repeating elements are : " )  	cout << "The repeating elements are" ;			      cout << "The repeating elements are : " << endl ;		  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < size ;						      	i < size ;						      i < size ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math .  	  if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i  	if ( arr [ abs ( arr [ i ] ) ] > 0 ) {			  
    else System . out . print ( Math . abs ( arr [ i ] ) + "  	  else cout << " " << abs ( arr [ i ] ) << " " ;	    	  arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] 
  }							      	}							    	}							  
}							      }								    	else {							  
							      								    	  cout << abs ( arr [ i ] ) << " " ;			  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DELETE_CONSECUTIVE_WORDS_SEQUENCE_1			      DELETE_CONSECUTIVE_WORDS_SEQUENCE_1			    DELETE_CONSECUTIVE_WORDS_SEQUENCE_1				  DELETE_CONSECUTIVE_WORDS_SEQUENCE_1
--							      --							    --								  --
static int removeConsecutiveSame ( Vector < String > v ) {    int removeConsecutiveSame ( vector < string > v ) {	    int removeConsecutiveSame ( const Vector < char > & v ) {	  script_not_found : None
  Stack < String > st = new Stack < > ( ) ;		      	stack < string > st ;					      Vector < char > st ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < v . size ( ) ;					      	i < v . size ( ) ;					      i < v . size ( ) ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( st . empty ( ) ) st . push ( v . get ( i ) ) ;	      	  if ( st . empty ( ) ) st . push ( v [ i ] ) ;		    	if ( st . empty ( ) ) {					  
    else {						      	  else {						    	  st . push ( v [ i ] ) ;				  
      String str = st . peek ( ) ;			      	    string str = st . top ( ) ;				    	}							  
      if ( str . equals ( v . get ( i ) ) ) st . pop ( ) ;    	    if ( str . compare ( v [ i ] ) == 0 ) st . pop ( ) ;    	else {							  
      else st . push ( v . get ( i ) ) ;		      	    else st . push ( v [ i ] ) ;			    	  char str = st . top ( ) ;				  
    }							      	  }							    	  if ( strcmp ( str , v [ i ] ) == 0 ) {		  
  }							      	}							    	    st . pop ( ) ;					  
  return st . size ( ) ;				      	return st . size ( ) ;					    	  }							  
}							      }								    	  else {						  
							      								    	    st . push ( v [ i ] ) ;				  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return st . size ( ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES	      COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES		    COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES		  COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES
--							      --							    --								  --
public static int countarray ( int n , int k , int x ) {      int countarray ( int n , int k , int x ) {		    int countarray ( int n , int k , int x ) {			  script_not_found : None
  int [ ] dp = new int [ 109 ] ;			      	int dp [ MAXN ] = {					      int dp [ 109 ] ;						  
  dp [ 0 ] = 0 ;					      	  0 }							      dp [ 0 ] = 0 ;						  
  dp [ 1 ] = 1 ;					      	  ;							      dp [ 1 ] = 1 ;						  
  for ( int i = 2 ;					      	  dp [ 0 ] = 0 ;					      for ( int i = 2 ;						  
  i < n ;						      	  dp [ 1 ] = 1 ;					      i < n ;							  
  i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp 	  for ( int i = 2 ;					      i ++ ) {							  
  return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) 	  i < n ;						    	dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i  
}							      	  i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) *    }								  
							      	  return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ]   return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) 
							      	}							    }								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1		      REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1		    REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1		  REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1
--							      --							    --								  --
static void reorder ( ) {				      void reorder ( int arr [ ] , int index [ ] , int n ) {	    void reorder ( ) {						  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < arr . length ;					      	i < n ;							      i < sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    while ( index [ i ] != i ) {			      	  while ( index [ i ] != i ) {				    	while ( index [ i ] != i ) {				  
      int oldTargetI = index [ index [ i ] ] ;		      	    int oldTargetI = index [ index [ i ] ] ;		    	  int oldTargetI = index [ i ] ;			  
      char oldTargetE = ( char ) arr [ index [ i ] ] ;	      	    char oldTargetE = arr [ index [ i ] ] ;		    	  char oldTargetE = ( char ) arr [ index [ i ] ] ;	  
      arr [ index [ i ] ] = arr [ i ] ;			      	    arr [ index [ i ] ] = arr [ i ] ;			    	  arr [ index [ i ] ] = arr [ i ] ;			  
      index [ index [ i ] ] = index [ i ] ;		      	    index [ index [ i ] ] = index [ i ] ;		    	  index [ i ] = index [ i ] ;				  
      index [ i ] = oldTargetI ;			      	    index [ i ] = oldTargetI ;				    	  index [ i ] = oldTargetI ;				  
      arr [ i ] = oldTargetE ;				      	    arr [ i ] = oldTargetE ;				    	  arr [ i ] = oldTargetE ;				  
    }							      	  }							    	}							  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS			      LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS			    LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS				  LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS
--							      --							    --								  --
static int longestCommonSum ( int n ) {			      int longestCommonSum ( bool arr1 [ ] , bool arr2 [ ] , int n  int longestCommonSum ( int n ) {				  script_not_found : None
  int maxLen = 0 ;					      	int maxLen = 0 ;					      int maxLen = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int sum1 = 0 , sum2 = 0 ;				      	  int sum1 = 0 , sum2 = 0 ;				    	int sum1 = 0 , sum2 = 0 ;				  
    for ( int j = i ;					      	  for ( int j = i ;					    	for ( int j = i ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      sum1 += arr1 [ j ] ;				      	    sum1 += arr1 [ j ] ;				    	  sum1 += arr1 [ j ] ;					  
      sum2 += arr2 [ j ] ;				      	    sum2 += arr2 [ j ] ;				    	  sum2 += arr2 [ j ] ;					  
      if ( sum1 == sum2 ) {				      	    if ( sum1 == sum2 ) {				    	  if ( sum1 == sum2 ) {					  
	int len = j - i + 1 ;				      	      int len = j - i + 1 ;				    	    int len = j - i + 1 ;				  
	if ( len > maxLen ) maxLen = len ;		      	      if ( len > maxLen ) maxLen = len ;		    	    if ( len > maxLen ) {				  
      }							      	    }							    	      maxLen = len ;					  
    }							      	  }							    	    }							  
  }							      	}							    	  }							  
  return maxLen ;					      	return maxLen ;						    	}							  
}							      }								      }								  
							      								      return maxLen ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_PAIRS_ARRAY_XOR_0_1				      FIND_NUMBER_PAIRS_ARRAY_XOR_0_1				    FIND_NUMBER_PAIRS_ARRAY_XOR_0_1				  FIND_NUMBER_PAIRS_ARRAY_XOR_0_1
--							      --							    --								  --
static int calculate ( int a [ ] , int n ) {		      int calculate ( int a [ ] , int n ) {			    int calculate ( int a [ ] , int n ) {			  script_not_found : None
  int maximum = Arrays . stream ( a ) . max ( ) . getAsInt (  	int * maximum = max_element ( a , a + 5 ) ;		      int maximum = std :: max ( a , a [ n ] ) ;		  
  int frequency [ ] = new int [ maximum + 1 ] ;		      	int frequency [ * maximum + 1 ] = {			      int frequency [ maximum + 1 ] ;				  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < n ;						      	  ;							      i < n ;							  
  i ++ ) {						      	  for ( int i = 0 ;					      i ++ ) frequency [ a [ i ] ] += 1 ;			  
    frequency [ a [ i ] ] += 1 ;			      	  i < n ;						      int answer = 0 ;						  
  }							      	  i ++ ) {						      for ( int i = 0 ;						  
  int answer = 0 ;					      	    frequency [ a [ i ] ] += 1 ;			      i < ( maximum ) + 1 ;					  
  for ( int i = 0 ;					      	  }							      i ++ ) answer = answer + frequency [ i ] * ( frequency [ i  
  i < ( maximum ) + 1 ;					      	  int answer = 0 ;					      return answer / 2 ;					  
  i ++ ) {						      	  for ( int i = 0 ;					    }								  
    answer = answer + frequency [ i ] * ( frequency [ i ] - 1 	  i < ( * maximum ) + 1 ;				    								  
  }							      	  i ++ ) {						    								  
  return answer / 2 ;					      	    answer = answer + frequency [ i ] * ( frequency [ i ] - 								  
}							      	  }							    								  
							      	  return answer / 2 ;					    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_AN_ARRAY_OF_0S_1S_AND_2S				      SORT_AN_ARRAY_OF_0S_1S_AND_2S				    SORT_AN_ARRAY_OF_0S_1S_AND_2S				  SORT_AN_ARRAY_OF_0S_1S_AND_2S
--							      --							    --								  --
static void sort012 ( int a [ ] , int arr_size ) {	      void sort012 ( int a [ ] , int arr_size ) {		    void sort012 ( int a [ ] , int arr_size ) {			  script_not_found : None
  int lo = 0 ;						      	int lo = 0 ;						      int lo = 0 ;						  
  int hi = arr_size - 1 ;				      	int hi = arr_size - 1 ;					      int hi = arr_size - 1 ;					  
  int mid = 0 , temp = 0 ;				      	int mid = 0 ;						      int mid = 0 , temp = 0 ;					  
  while ( mid <= hi ) {					      	while ( mid <= hi ) {					      while ( mid <= hi ) {					  
    switch ( a [ mid ] ) {				      	  switch ( a [ mid ] ) {				    	switch ( a [ mid ] ) {					  
      case 0 : {					      	    case 0 : swap ( a [ lo ++ ] , a [ mid ++ ] ) ;	    	  case 0 : {						  
	temp = a [ lo ] ;				      	    break ;						    	    temp = a [ lo ] ;					  
	a [ lo ] = a [ mid ] ;				      	    case 1 : mid ++ ;					    	    a [ lo ] = a [ mid ] ;				  
	a [ mid ] = temp ;				      	    break ;						    	    a [ mid ] = temp ;					  
	lo ++ ;						      	    case 2 : swap ( a [ mid ] , a [ hi -- ] ) ;		    	    lo ++ ;						  
	mid ++ ;					      	    break ;						    	    mid ++ ;						  
	break ;						      	  }							    	    break ;						  
      }							      	}							    	  }							  
      case 1 : mid ++ ;					      }								    	  case 1 : mid ++ ;					  
      break ;						      								    	  break ;						  
      case 2 : {					      								    	  case 2 : {						  
	temp = a [ mid ] ;				      								    	    temp = a [ mid ] ;					  
	a [ mid ] = a [ hi ] ;				      								    	    a [ mid ] = a [ hi ] ;				  
	a [ hi ] = temp ;				      								    	    a [ hi ] = temp ;					  
	hi -- ;						      								    	    hi -- ;						  
	break ;						      								    	    break ;						  
      }							      								    	  }							  
    }							      								    	}							  
  }							      								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS			      K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS			    K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS			  K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS
--							      --							    --								  --
static void KMaxCombinations ( int A [ ] , int B [ ] , int N  void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K script_not_found : None
  PriorityQueue < Integer > pq = new PriorityQueue < Integer  	priority_queue < int > pq ;				      priority_queue < int , vector < int > , greater < int >> pq 
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < N ;						      	j < N ;							      j < N ;							  
  j ++ ) pq . add ( A [ i ] + B [ j ] ) ;		      	j ++ ) pq . push ( A [ i ] + B [ j ] ) ;		      j ++ ) pq . push ( A [ i ] + B [ j ] ) ;			  
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  while ( count < K ) {					      	while ( count < K ) {					      while ( count < K ) {					  
    System . out . println ( pq . peek ( ) ) ;		      	  cout << pq . top ( ) << endl ;			    	cout << pq . top ( ) << endl ;				  
    pq . remove ( ) ;					      	  pq . pop ( ) ;					    	pq . pop ( ) ;						  
    count ++ ;						      	  count ++ ;						    	count ++ ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3		      NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3		    NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3		  NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3
--							      --							    --								  --
static int divisible ( String num ) {			      int divisible ( string num ) {				    int divisible ( string num ) {				  success : None
  int n = num . length ( ) ;				      	int n = num . length ( ) ;				      int n = num . length ( ) ;				  
  int sum = 0 ;						      	int sum = accumulate ( begin ( num ) , end ( num ) , 0 ) -    int sum = 0 ;						  
  for ( int i = 0 ;					      	if ( sum % 3 == 0 ) return 0 ;				      for ( int i = 0 ;						  
  i < n ;						      	if ( n == 1 ) return - 1 ;				      i < n ;							  
  i ++ ) sum += ( int ) ( num . charAt ( i ) ) ;	      	for ( int i = 0 ;					      i ++ ) {							  
  if ( sum % 3 == 0 ) return 0 ;			      	i < n ;							    	sum += ( int ) ( num [ i ] ) ;				  
  if ( n == 1 ) return - 1 ;				      	i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ;   }								  
  for ( int i = 0 ;					      	if ( n == 2 ) return - 1 ;				      if ( sum % 3 == 0 ) return 0 ;				  
  i < n ;						      	return 2 ;						      if ( n == 1 ) return - 1 ;				  
  i ++ ) if ( sum % 3 == ( num . charAt ( i ) - '0' ) % 3 ) r }								      for ( int i = 0 ;						  
  if ( n == 2 ) return - 1 ;				      								      i < n ;							  
  return 2 ;						      								      i ++ ) {							  
}							      								    	if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ;	  
							      								      }								  
							      								      if ( n == 2 ) return - 1 ;				  
							      								      return 2 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1 COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1 COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1 COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1
--							      --							    --								  --
static int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n  int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n  success : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  HashSet < Integer > us = new HashSet < Integer > ( ) ;      	unordered_set < int > us ;				      set < int > us ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m ;						      	i < m ;							      i < m ;							  
  i ++ ) us . add ( arr1 [ i ] ) ;			      	i ++ ) us . insert ( arr1 [ i ] ) ;			      i ++ ) {							  
  for ( int j = 0 ;					      	for ( int j = 0 ;					    	us . insert ( arr1 [ i ] ) ;				  
  j < n ;						      	j < n ;							      }								  
  j ++ ) if ( us . contains ( x - arr2 [ j ] ) ) count ++ ;   	j ++ ) if ( us . find ( x - arr2 [ j ] ) != us . end ( ) )    for ( int j = 0 ;						  
  return count ;					      	return count ;						      j < n ;							  
}							      }								      j ++ ) {							  
							      								    	if ( us . find ( x - arr2 [ j ] ) != us . end ( ) ) {	  
							      								    	  count ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TILING_WITH_DOMINOES					      TILING_WITH_DOMINOES					    TILING_WITH_DOMINOES					  TILING_WITH_DOMINOES
--							      --							    --								  --
static int countWays ( int n ) {			      int countWays ( int n ) {					    int countWays ( int n ) {					  success : None
  int [ ] A = new int [ n + 1 ] ;			      	int A [ n + 1 ] , B [ n + 1 ] ;				      int A [ n + 1 ] ;						  
  int [ ] B = new int [ n + 1 ] ;			      	A [ 0 ] = 1 , A [ 1 ] = 0 , B [ 0 ] = 0 , B [ 1 ] = 1 ;	      int B [ n + 1 ] ;						  
  A [ 0 ] = 1 ;						      	for ( int i = 2 ;					      A [ 0 ] = 1 ;						  
  A [ 1 ] = 0 ;						      	i <= n ;						      A [ 1 ] = 0 ;						  
  B [ 0 ] = 0 ;						      	i ++ ) {						      B [ 0 ] = 0 ;						  
  B [ 1 ] = 1 ;						      	  A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ;		      B [ 1 ] = 1 ;						  
  for ( int i = 2 ;					      	  B [ i ] = A [ i - 1 ] + B [ i - 2 ] ;			      for ( int i = 2 ;						  
  i <= n ;						      	}							      i <= n ;							  
  i ++ ) {						      	return A [ n ] ;					      i ++ ) {							  
    A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ;		      }								    	A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ;		  
    B [ i ] = A [ i - 1 ] + B [ i - 2 ] ;		      								    	B [ i ] = A [ i - 1 ] + B [ i - 2 ] ;			  
  }							      								      }								  
  return A [ n ] ;					      								      return A [ n ] ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION     MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION	    MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION	  MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION
--							      --							    --								  --
static int maxSubArraySumRepeated ( int a [ ] , int n , int k int maxSubArraySumRepeated ( int a [ ] , int n , int k ) {    int maxSubArraySumRepeated ( int a [ ] , int n , int k ) {	  error : MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATE
  int max_so_far = 0 ;					      	int max_so_far = INT_MIN , max_ending_here = 0 ;	      int max_so_far = 0 ;					  D_CONCATENATION.cpp: In function ‘int f_filled(int
  int INT_MIN , max_ending_here = 0 ;			      	for ( int i = 0 ;					      int INT_MIN , max_ending_here = 0 ;			  *, int, int)’: MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_
  for ( int i = 0 ;					      	i < n * k ;						      for ( int i = 0 ;						  REPEATED_CONCATENATION.cpp:31:17: error: ‘max_endi
  i < n * k ;						      	i ++ ) {						      i < n * k ;						  ng_here’ was not declared in this scope    int INT
  i ++ ) {						      	  max_ending_here = max_ending_here + a [ i % n ] ;	      i ++ ) {							  _MIN , max_ending_here = 0 ;			^~~~
    max_ending_here = max_ending_here + a [ i % n ] ;	      	  if ( max_so_far < max_ending_here ) max_so_far = max_endi 	max_ending_here = max_ending_here + a [ i % n ] ;	  ~~~~~~~~~~~
    if ( max_so_far < max_ending_here ) max_so_far = max_endi 	  if ( max_ending_here < 0 ) max_ending_here = 0 ;	    	if ( max_so_far < max_ending_here ) {			  
    if ( max_ending_here < 0 ) max_ending_here = 0 ;	      	}							    	  max_so_far = max_ending_here ;			  
  }							      	return max_so_far ;					    	}							  
  return max_so_far ;					      }								    	if ( max_ending_here < 0 ) {				  
}							      								    	  max_ending_here = 0 ;					  
							      								    	}							  
							      								      }								  
							      								      return max_so_far ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_1_N_SWAPPING_ADJACENT_ELEMENTS			      SORT_1_N_SWAPPING_ADJACENT_ELEMENTS			    SORT_1_N_SWAPPING_ADJACENT_ELEMENTS				  SORT_1_N_SWAPPING_ADJACENT_ELEMENTS
--							      --							    --								  --
static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] ,  bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) {	    bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) {	  script_not_found : None
  int i , j ;						      	int i , j ;						      int i , j ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( B [ i ] ) {					      	  if ( B [ i ] ) {					    	if ( B [ i ] ) {					  
      j = i ;						      	    j = i ;						    	  j = i ;						  
      while ( B [ j ] ) {				      	    while ( B [ j ] ) j ++ ;				    	  while ( B [ j ] ) j ++ ;				  
	j ++ ;						      	    sort ( A + i , A + 1 + j ) ;			    	  qsort ( A + i , 1 + j , sizeof ( int ) * j ) ;	  
      }							      	    i = j ;						    	  i = j ;						  
      Arrays . sort ( A , i , 1 + j ) ;			      	  }							    	}							  
      i = j ;						      	}							      }								  
    }							      	for ( i = 0 ;						      for ( i = 0 ;						  
  }							      	i < n ;							      i < n ;							  
  for ( i = 0 ;						      	i ++ ) {						      i ++ ) {							  
  i < n ;						      	  if ( A [ i ] != i + 1 ) return false ;		    	if ( A [ i ] != i + 1 ) return false ;			  
  i ++ ) {						      	}							      }								  
    if ( A [ i ] != i + 1 ) {				      	return true ;						      return true ;						  
      return false ;					      }								    }								  
    }							      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING	      SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING	    SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING		  SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING
--							      --							    --								  --
static void sortByPattern ( char [ ] str , char [ ] pat ) {   void sortByPattern ( string & str , string pat ) {	    void sortByPattern ( char * str , char * pat ) {		  script_not_found : None
  int count [ ] = new int [ MAX_CHAR ] ;		      	int count [ MAX_CHAR ] = {				      int count [ MAX_CHAR ] ;					  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < str . length ;					      	  ;							      i < strlen ( str ) ;					  
  i ++ ) {						      	  for ( int i = 0 ;					      i ++ ) count [ str [ i ] - 'a' ] ++ ;			  
    count [ str [ i ] - 'a' ] ++ ;			      	  i < str . length ( ) ;				      int index = 0 ;						  
  }							      	  i ++ ) count [ str [ i ] - 'a' ] ++ ;			      for ( int i = 0 ;						  
  int index = 0 ;					      	  int index = 0 ;					      i < strlen ( pat ) ;					  
  for ( int i = 0 ;					      	  for ( int i = 0 ;					      i ++ ) {							  
  i < pat . length ;					      	  i < pat . length ( ) ;				    	for ( int j = 0 ;					  
  i ++ ) {						      	  i ++ ) for ( int j = 0 ;				    	j < count [ pat [ i ] - 'a' ] ;				  
    for ( int j = 0 ;					      	  j < count [ pat [ i ] - 'a' ] ;			    	j ++ ) str [ index ++ ] = pat [ i ] ;			  
    j < count [ pat [ i ] - 'a' ] ;			      	  j ++ ) str [ index ++ ] = pat [ i ] ;			      }								  
    j ++ ) {						      	}							    }								  
      str [ index ++ ] = pat [ i ] ;			      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU
--							      --							    --								  --
static int nCrModp ( int n , int r , int p ) {		      int nCrModp ( int n , int r , int p ) {			    int nCrModp ( int n , int r , int p ) {			  success : None
  int C [ ] = new int [ r + 1 ] ;			      	int C [ r + 1 ] ;					      int C [ r + 1 ] ;						  
  Arrays . fill ( C , 0 ) ;				      	memset ( C , 0 , sizeof ( C ) ) ;			      memset ( C , 0 , sizeof ( C ) ) ;				  
  C [ 0 ] = 1 ;						      	C [ 0 ] = 1 ;						      C [ 0 ] = 1 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = Math . min ( i , r ) ;		      	  for ( int j = min ( i , r ) ;				    	for ( int j = min ( i , r ) ;				  
    j > 0 ;						      	  j > 0 ;						    	j > 0 ;							  
    j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ;	      	  j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ;	    	j -- ) {						  
  }							      	}							    	  C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ;		  
  return C [ r ] ;					      	return C [ r ] ;					    	}							  
}							      }								      }								  
							      								      return C [ r ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL
--							      --							    --								  --
public static int findMinimumAngle ( int arr [ ] , int n ) {  int findMinimumAngle ( int arr [ ] , int n ) {		    int findMinimumAngle ( int arr [ ] , int n ) {		  success : identical to gold
  int l = 0 , sum = 0 , ans = 360 ;			      	int l = 0 , sum = 0 , ans = 360 ;			      int l = 0 , sum = 0 , ans = 360 ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    sum += arr [ i ] ;					      	  sum += arr [ i ] ;					    	sum += arr [ i ] ;					  
    while ( sum >= 180 ) {				      	  while ( sum >= 180 ) {				    	while ( sum >= 180 ) {					  
      ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) 	    ans = min ( ans , 2 * abs ( 180 - sum ) ) ;		    	  ans = min ( ans , 2 * abs ( 180 - sum ) ) ;		  
      sum -= arr [ l ] ;				      	    sum -= arr [ l ] ;					    	  sum -= arr [ l ] ;					  
      l ++ ;						      	    l ++ ;						    	  l ++ ;						  
    }							      	  }							    	}							  
    ans = Math . min ( ans , 2 * Math . abs ( 180 - sum ) ) ; 	  ans = min ( ans , 2 * abs ( 180 - sum ) ) ;		    	ans = min ( ans , 2 * abs ( 180 - sum ) ) ;		  
  }							      	}							      }								  
  return ans ;						      	return ans ;						      return ans ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_ODD_FACTORS_NUMBER				      FIND_SUM_ODD_FACTORS_NUMBER				    FIND_SUM_ODD_FACTORS_NUMBER					  FIND_SUM_ODD_FACTORS_NUMBER
--							      --							    --								  --
static int sumofoddFactors ( int n ) {			      int sumofoddFactors ( int n ) {				    int sumofoddFactors ( int n ) {				  success : None
  int res = 1 ;						      	int res = 1 ;						      int res = 1 ;						  
  while ( n % 2 == 0 ) n = n / 2 ;			      	while ( n % 2 == 0 ) n = n / 2 ;			      while ( n % 2 == 0 ) {					  
  for ( int i = 3 ;					      	for ( int i = 3 ;					    	n = n / 2 ;						  
  i <= Math . sqrt ( n ) ;				      	i <= sqrt ( n ) ;					      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 3 ;						  
    int count = 0 , curr_sum = 1 ;			      	  int count = 0 , curr_sum = 1 ;			      i <= sqrt ( n ) ;						  
    int curr_term = 1 ;					      	  int curr_term = 1 ;					      i ++ ) {							  
    while ( n % i == 0 ) {				      	  while ( n % i == 0 ) {				    	int count = 0 , curr_sum = 1 ;				  
      count ++ ;					      	    count ++ ;						    	int curr_term = 1 ;					  
      n = n / i ;					      	    n = n / i ;						    	while ( n % i == 0 ) {					  
      curr_term *= i ;					      	    curr_term *= i ;					    	  count ++ ;						  
      curr_sum += curr_term ;				      	    curr_sum += curr_term ;				    	  n = n / i ;						  
    }							      	  }							    	  curr_term *= i ;					  
    res *= curr_sum ;					      	  res *= curr_sum ;					    	  curr_sum += curr_term ;				  
  }							      	}							    	}							  
  if ( n >= 2 ) res *= ( 1 + n ) ;			      	if ( n >= 2 ) res *= ( 1 + n ) ;			    	res *= curr_sum ;					  
  return res ;						      	return res ;						      }								  
}							      }								      if ( n >= 2 ) {						  
							      								    	res *= ( 1 + n ) ;					  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF
--							      --							    --								  --
static int isMultipleOf3 ( int n ) {			      int isMultipleOf3 ( int n ) {				    int isMultipleOf3 ( int n ) {				  success : None
  int odd_count = 0 ;					      	int odd_count = 0 ;					      int odd_count = 0 ;					  
  int even_count = 0 ;					      	int even_count = 0 ;					      int even_count = 0 ;					  
  if ( n < 0 ) n = - n ;				      	if ( n < 0 ) n = - n ;					      if ( n < 0 ) n = - n ;					  
  if ( n == 0 ) return 1 ;				      	if ( n == 0 ) return 1 ;				      if ( n == 0 ) return 1 ;					  
  if ( n == 1 ) return 0 ;				      	if ( n == 1 ) return 0 ;				      if ( n == 1 ) return 0 ;					  
  while ( n != 0 ) {					      	while ( n ) {						      while ( n != 0 ) {					  
    if ( ( n & 1 ) != 0 ) odd_count ++ ;		      	  if ( n & 1 ) odd_count ++ ;				    	if ( ( n & 1 ) != 0 ) odd_count ++ ;			  
    if ( ( n & 2 ) != 0 ) even_count ++ ;		      	  if ( n & 2 ) even_count ++ ;				    	if ( ( n & 2 ) != 0 ) even_count ++ ;			  
    n = n >> 2 ;					      	  n = n >> 2 ;						    	n = n >> 2 ;						  
  }							      	}							      }								  
  return isMultipleOf3 ( Math . abs ( odd_count - even_count  	return isMultipleOf3 ( abs ( odd_count - even_count ) ) ;     return isMultipleOf3 ( abs ( odd_count - even_count ) ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1	      SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1	    SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1		  SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1
--							      --							    --								  --
static int KnapSack ( int val [ ] , int wt [ ] , int n , int  int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) {   int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) {	  failure : #Results: 2, 10
  int [ ] dp = new int [ W + 1 ] ;			      	int dp [ W + 1 ] ;					      int dp [ W + 1 ] ;					  
  Arrays . fill ( dp , 0 ) ;				      	memset ( dp , 0 , sizeof ( dp ) ) ;			      memset ( dp , 0 , W + 1 ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = W ;				      	i ++ ) for ( int j = W ;				      i ++ ) for ( int j = W ;					  
  j >= wt [ i ] ;					      	j >= wt [ i ] ;						      j >= wt [ i ] ;						  
  j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [  	j -- ) dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt    j -- ) dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt  
  return dp [ W ] ;					      	return dp [ W ] ;					      return dp [ W ] ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2	      FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2		    FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2		  FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2
--							      --							    --								  --
static void findElements ( int arr [ ] , int n ) {	      void findElements ( int arr [ ] , int n ) {		    void findElements ( int arr [ ] , int n ) {			  script_not_found : None
  int first = Integer . MIN_VALUE ;			      	int first = INT_MIN , second = INT_MIN ;		      int first = std :: numeric_limits < int > :: min ( ) ;	  
  int second = Integer . MAX_VALUE ;			      	for ( int i = 0 ;					      int second = std :: numeric_limits < int > :: max ( ) ;	  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) {						      i < n ;							  
  i ++ ) {						      	  if ( arr [ i ] > first ) {				      i ++ ) {							  
    if ( arr [ i ] > first ) {				      	    second = first ;					    	if ( arr [ i ] > first ) {				  
      second = first ;					      	    first = arr [ i ] ;					    	  second = first ;					  
      first = arr [ i ] ;				      	  }							    	  first = arr [ i ] ;					  
    }							      	  else if ( arr [ i ] > second ) second = arr [ i ] ;	    	}							  
    else if ( arr [ i ] > second ) second = arr [ i ] ;	      	}							    	else if ( arr [ i ] > second ) {			  
  }							      	for ( int i = 0 ;					    	  second = arr [ i ] ;					  
  for ( int i = 0 ;					      	i < n ;							    	}							  
  i < n ;						      	i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << " " ;   }								  
  i ++ ) if ( arr [ i ] < second ) System . out . print ( arr }								      for ( int i = 0 ;						  
}							      								      i < n ;							  
							      								      i ++ ) if ( arr [ i ] < second ) std :: cout << arr [ i ] < 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FREQUENCY_ELEMENT_UNSORTED_ARRAY_1			      FREQUENCY_ELEMENT_UNSORTED_ARRAY_1			    FREQUENCY_ELEMENT_UNSORTED_ARRAY_1				  FREQUENCY_ELEMENT_UNSORTED_ARRAY_1
--							      --							    --								  --
static void countFreq ( int a [ ] , int n ) {		      void countFreq ( int a [ ] , int n ) {			    void countFreq ( int a [ ] , int n ) {			  script_not_found : None
  int hm [ ] = new int [ n ] ;				      	unordered_map < int , int > hm ;			      int hm [ n ] ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) hm [ a [ i ] ] ++ ;				      	i ++ ) hm [ a [ i ] ] ++ ;				      i ++ ) {							  
  int cumul = 0 ;					      	int cumul = 0 ;						    	hm [ a [ i ] ] ++ ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      }								  
  i < n ;						      	i < n ;							      int cumul = 0 ;						  
  i ++ ) {						      	i ++ ) {						      for ( int i = 0 ;						  
    cumul += hm [ a [ i ] ] ;				      	  cumul += hm [ a [ i ] ] ;				      i < n ;							  
    if ( hm [ a [ i ] ] != 0 ) {			      	  if ( hm [ a [ i ] ] ) {				      i ++ ) {							  
      System . out . println ( a [ i ] + "->" + cumul ) ;     	    cout << a [ i ] << "->" << cumul << endl ;		    	cumul += hm [ a [ i ] ] ;				  
    }							      	  }							    	if ( hm [ a [ i ] ] != 0 ) cout << a [ i ] << "->" << cum 
    hm [ a [ i ] ] = 0 ;				      	  hm [ a [ i ] ] = 0 ;					    	hm [ a [ i ] ] = 0 ;					  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1			      SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1			    SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1			  SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1
--							      --							    --								  --
static int sortedAfterSwap ( int [ ] A , int [ ] B , int n )  bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) {	    int sortedAfterSwap ( int * A , int * B , int n ) {		  script_not_found : None
  int t = 0 ;						      	for ( int i = 0 ;					      int t = 0 ;						  
  for ( int i = 0 ;					      	i < n - 1 ;						      for ( int i = 0 ;						  
  i < n - 1 ;						      	i ++ ) {						      i < n - 1 ;						  
  i ++ ) {						      	  if ( B [ i ] ) {					      i ++ ) {							  
    if ( B [ i ] != 0 ) {				      	    if ( A [ i ] != i + 1 ) swap ( A [ i ] , A [ i + 1 ] )  	if ( B [ i ] != 0 ) {					  
      if ( A [ i ] != i + 1 ) t = A [ i ] ;		      	  }							    	  if ( A [ i ] != i + 1 ) {				  
      A [ i ] = A [ i + 1 ] ;				      	}							    	    t = A [ i ] ;					  
      A [ i + 1 ] = t ;					      	for ( int i = 0 ;					    	  }							  
    }							      	i < n ;							    	  A [ i ] = A [ i + 1 ] ;				  
  }							      	i ++ ) {						    	  A [ i + 1 ] = t ;					  
  for ( int i = 0 ;					      	  if ( A [ i ] != i + 1 ) return false ;		    	}							  
  i < n ;						      	}							      }								  
  i ++ ) {						      	return true ;						      for ( int i = 0 ;						  
    if ( A [ i ] != i + 1 ) return 0 ;			      }								      i < n ;							  
  }							      								      i ++ ) {							  
  return 1 ;						      								    	if ( A [ i ] != i + 1 ) {				  
}							      								    	  return 0 ;						  
							      								    	}							  
							      								      }								  
							      								      return 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE			      PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE			    PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE			  PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE
--							      --							    --								  --
public static void sequence ( int n ) {			      void sequence ( int n ) {					    void sequence ( int n ) {					  script_not_found : None
  int f [ ] = new int [ n + 1 ] ;			      	int f [ n + 1 ] ;					      int f [ n + 1 ] ;						  
  f [ 0 ] = 0 ;						      	f [ 0 ] = 0 ;						      f [ 0 ] = 0 ;						  
  f [ 1 ] = 1 ;						      	f [ 1 ] = 1 ;						      f [ 1 ] = 1 ;						  
  f [ 2 ] = 1 ;						      	f [ 2 ] = 1 ;						      f [ 2 ] = 1 ;						  
  System . out . print ( f [ 1 ] + " " + f [ 2 ] + " " ) ;    	cout << f [ 1 ] << " " << f [ 2 ] << " " ;		      cout << f [ 1 ] << " " << f [ 2 ] << " " ;		  
  for ( int i = 3 ;					      	for ( int i = 3 ;					      for ( int i = 3 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;     	  f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;	    	f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;	  
    System . out . print ( f [ i ] + " " ) ;		      	  cout << f [ i ] << " " ;				    	cout << f [ i ] << " " ;				  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION			      PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION			    PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION			  PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION
--							      --							    --								  --
static void decToHexa ( int n ) {			      void decToHexa ( int n ) {				    void decToHexa ( int n ) {					  script_not_found : None
  char [ ] hexaDeciNum = new char [ 100 ] ;		      	char hexaDeciNum [ 100 ] ;				      char hexaDeciNum [ 100 ] ;				  
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  while ( n != 0 ) {					      	while ( n != 0 ) {					      while ( n != 0 ) {					  
    int temp = 0 ;					      	  int temp = 0 ;					    	int temp = 0 ;						  
    temp = n % 16 ;					      	  temp = n % 16 ;					    	temp = n % 16 ;						  
    if ( temp < 10 ) {					      	  if ( temp < 10 ) {					    	if ( temp < 10 ) {					  
      hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ;	      	    hexaDeciNum [ i ] = temp + 48 ;			    	  hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ;		  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
    }							      	  }							    	}							  
    else {						      	  else {						    	else {							  
      hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ;	      	    hexaDeciNum [ i ] = temp + 55 ;			    	  hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ;		  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
    }							      	  }							    	}							  
    n = n / 16 ;					      	  n = n / 16 ;						    	n = n / 16 ;						  
  }							      	}							      }								  
  for ( int j = i - 1 ;					      	for ( int j = i - 1 ;					      for ( int j = i - 1 ;					  
  j >= 0 ;						      	j >= 0 ;						      j >= 0 ;							  
  j -- ) System . out . print ( hexaDeciNum [ j ] ) ;	      	j -- ) cout << hexaDeciNum [ j ] ;			      j -- ) {							  
}							      }								    	cout << hexaDeciNum [ j ] ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT		      FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT			    FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT			  FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT
--							      --							    --								  --
static boolean findDuplicateparenthesis ( String s ) {	      bool findDuplicateparenthesis ( string str ) {		    bool findDuplicateparenthesis ( string s ) {		  success : None
  Stack < Character > Stack = new Stack < > ( ) ;	      	stack < char > Stack ;					      stack < char > stack ;					  
  char [ ] str = s . toCharArray ( ) ;			      	for ( char ch : str ) {					      string :: size_type pos = 0 ;				  
  for ( char ch : str ) {				      	  if ( ch == ')' ) {					      for ( char ch : s ) {					  
    if ( ch == ')' ) {					      	    char top = Stack . top ( ) ;			    	if ( ch == ')' ) {					  
      char top = Stack . peek ( ) ;			      	    Stack . pop ( ) ;					    	  char top = stack . top ( ) ;				  
      Stack . pop ( ) ;					      	    int elementsInside = 0 ;				    	  stack . pop ( ) ;					  
      int elementsInside = 0 ;				      	    while ( top != '(' ) {				    	  int elementsInside = 0 ;				  
      while ( top != '(' ) {				      	      elementsInside ++ ;				    	  while ( top != '(' ) {				  
	elementsInside ++ ;				      	      top = Stack . top ( ) ;				    	    elementsInside ++ ;					  
	top = Stack . peek ( ) ;			      	      Stack . pop ( ) ;					    	    top = stack . top ( ) ;				  
	Stack . pop ( ) ;				      	    }							    	    stack . pop ( ) ;					  
      }							      	    if ( elementsInside < 1 ) {				    	  }							  
      if ( elementsInside < 1 ) {			      	      return 1 ;					    	  if ( elementsInside < 1 ) return true ;		  
	return true ;					      	    }							    	}							  
      }							      	  }							    	else stack . push ( ch ) ;				  
    }							      	  else Stack . push ( ch ) ;				      }								  
    else {						      	}							      return false ;						  
      Stack . push ( ch ) ;				      	return false ;						    }								  
    }							      }								    								  
  }							      								    								  
  return false ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS	      COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS		    COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS		  COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS
--							      --							    --								  --
static int countWords ( String str [ ] , int n ) {	      int countWords ( string str [ ] , int n ) {		    int countWords ( string str [ ] , int n ) {			  failure : #Results: 1, 10
  HashMap < String , Integer > m = new HashMap < > ( ) ;      	unordered_map < string , int > m ;			      unordered_map < string , int > m ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) m [ str [ i ] ] += 1 ;				      i ++ ) {							  
    if ( m . containsKey ( str [ i ] ) ) {		      	int res = 0 ;						    	if ( m . count ( str [ i ] ) == 0 ) {			  
      int get = m . get ( str [ i ] ) ;			      	for ( auto it = m . begin ( ) ;				    	  int get = m [ str [ i ] ] ;				  
      m . put ( str [ i ] , get + 1 ) ;			      	it != m . end ( ) ;					    	  m [ str [ i ] ] = get + 1 ;				  
    }							      	it ++ ) if ( ( it -> second == 2 ) ) res ++ ;		    	}							  
    else {						      	return res ;						    	else {							  
      m . put ( str [ i ] , 1 ) ;			      }								    	  m [ str [ i ] ] = 1 ;					  
    }							      								    	}							  
  }							      								      }								  
  int res = 0 ;						      								      int res = 0 ;						  
  for ( Map . Entry < String , Integer > it : m . entrySet (  								      for ( unordered_map < string , int > :: iterator it = m . b 
    if ( it . getValue ( ) == 2 ) res ++ ;		      								      it != m . end ( ) ;					  
  }							      								      it ++ ) {							  
  return res ;						      								    	if ( it -> second == 2 ) {				  
}							      								    	  res ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE
--							      --							    --								  --
static int find ( int a [ ] , int b [ ] , int k , int n1 , in int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 )  int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 )  script_not_found : None
  LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ;   	unordered_set < int > s ;				      unordered_set < int > s ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n2 ;						      	i < n2 ;						      i < n2 ;							  
  i ++ ) s . add ( b [ i ] ) ;				      	i ++ ) s . insert ( b [ i ] ) ;				      i ++ ) {							  
  int missing = 0 ;					      	int missing = 0 ;					    	s . insert ( b [ i ] ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      }								  
  i < n1 ;						      	i < n1 ;						      int missing = 0 ;						  
  i ++ ) {						      	i ++ ) {						      for ( int i = 0 ;						  
    if ( ! s . contains ( a [ i ] ) ) missing ++ ;	      	  if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ;     i < n1 ;							  
    if ( missing == k ) return a [ i ] ;		      	  if ( missing == k ) return a [ i ] ;			      i ++ ) {							  
  }							      	}							    	if ( ! s . count ( a [ i ] ) ) {			  
  return - 1 ;						      	return - 1 ;						    	  missing ++ ;						  
}							      }								    	}							  
							      								    	if ( missing == k ) {					  
							      								    	  return a [ i ] ;					  
							      								    	}							  
							      								      }								  
							      								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND			      CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND			    CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND			  CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND
--							      --							    --								  --
static int calcAngle ( double h , double m ) {		      int calcAngle ( double h , double m ) {			    int calcAngle ( double h , double m ) {			  success : None
  if ( h < 0 || m < 0 || h > 12 || m > 60 ) System . out . pr 	if ( h < 0 || m < 0 || h > 12 || m > 60 ) printf ( "Wrong i   if ( h < 0 || m < 0 || h > 12 || m > 60 ) cout << "Wrong in 
  if ( h == 12 ) h = 0 ;				      	if ( h == 12 ) h = 0 ;					      if ( h == 12 ) h = 0 ;					  
  if ( m == 60 ) m = 0 ;				      	if ( m == 60 ) m = 0 ;					      if ( m == 60 ) m = 0 ;					  
  int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ;	      	int hour_angle = 0.5 * ( h * 60 + m ) ;			      int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ;	  
  int minute_angle = ( int ) ( 6 * m ) ;		      	int minute_angle = 6 * m ;				      int minute_angle = ( int ) ( 6 * m ) ;			  
  int angle = Math . abs ( hour_angle - minute_angle ) ;      	int angle = abs ( hour_angle - minute_angle ) ;		      int angle = abs ( hour_angle - minute_angle ) ;		  
  angle = Math . min ( 360 - angle , angle ) ;		      	angle = min ( 360 - angle , angle ) ;			      angle = min ( 360 - angle , angle ) ;			  
  return angle ;					      	return angle ;						      return angle ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1		      COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1			    COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1			  COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1
--							      --							    --								  --
public static int countPairs ( int arr [ ] , int n ) {	      int countPairs ( int arr [ ] , int n ) {			    int countPairs ( int arr [ ] , int n ) {			  failure : #Results: 4, 10
  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;    	unordered_map < int , int > mp ;			      unordered_map < int , int > hm ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) mp [ arr [ i ] ] ++ ;				      i ++ ) {							  
    if ( hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i  	int ans = 0 ;						    	if ( hm . count ( arr [ i ] ) == 0 ) {			  
    else hm . put ( arr [ i ] , 1 ) ;			      	for ( auto it = mp . begin ( ) ;			    	  hm [ arr [ i ] ] = hm [ arr [ i ] ] + 1 ;		  
  }							      	it != mp . end ( ) ;					    	}							  
  int ans = 0 ;						      	it ++ ) {						    	else {							  
  for ( Map . Entry < Integer , Integer > it : hm . entrySet  	  int count = it -> second ;				    	  hm [ arr [ i ] ] = 1 ;				  
    int count = it . getValue ( ) ;			      	  ans += ( count * ( count - 1 ) ) / 2 ;		    	}							  
    ans += ( count * ( count - 1 ) ) / 2 ;		      	}							      }								  
  }							      	return ans ;						      int ans = 0 ;						  
  return ans ;						      }								      for ( unordered_map < int , int > :: iterator it = hm . beg 
}							      								      it != hm . end ( ) ;					  
							      								      it ++ ) {							  
							      								    	int count = it -> second ;				  
							      								    	ans += ( count * ( count - 1 ) ) / 2 ;			  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMAINDER_7_LARGE_NUMBERS				      REMAINDER_7_LARGE_NUMBERS					    REMAINDER_7_LARGE_NUMBERS					  REMAINDER_7_LARGE_NUMBERS
--							      --							    --								  --
static int remainderWith7 ( String num ) {		      int remainderWith7 ( string num ) {			    int remainderWith7 ( string num ) {				  success : None
  int series [ ] = {					      	int series [ ] = {					      int series [ ] = {					  
    1 , 3 , 2 , - 1 , - 3 , - 2 }			      	  1 , 3 , 2 , - 1 , - 3 , - 2 }				    	1 , 3 , 2 , - 1 , - 3 , - 2 }				  
    ;							      	  ;							    	;							  
    int series_index = 0 ;				      	  int series_index = 0 ;				    	int series_index = 0 ;					  
    int result = 0 ;					      	  int result = 0 ;					    	int result = 0 ;					  
    for ( int i = num . length ( ) - 1 ;		      	  for ( int i = num . size ( ) - 1 ;			    	for ( int i = num . length ( ) - 1 ;			  
    i >= 0 ;						      	  i >= 0 ;						    	i >= 0 ;						  
    i -- ) {						      	  i -- ) {						    	i -- ) {						  
      int digit = num . charAt ( i ) - '0' ;		      	    int digit = num [ i ] - '0' ;			    	  int digit = num [ i ] - '0' ;				  
      result += digit * series [ series_index ] ;	      	    result += digit * series [ series_index ] ;		    	  result += digit * series [ series_index ] ;		  
      series_index = ( series_index + 1 ) % 6 ;		      	    series_index = ( series_index + 1 ) % 6 ;		    	  series_index = ( series_index + 1 ) % 6 ;		  
      result %= 7 ;					      	    result %= 7 ;					    	  result %= 7 ;						  
    }							      	  }							    	}							  
    if ( result < 0 ) result = ( result + 7 ) % 7 ;	      	  if ( result < 0 ) result = ( result + 7 ) % 7 ;	    	if ( result < 0 ) {					  
    return result ;					      	  return result ;					    	  result = ( result + 7 ) % 7 ;				  
  }							      	}							    	}							  
							      								    	return result ;						  
							      								      }								  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_ LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_ LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_ LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_
--							      --							    --								  --
static void longestSubseqWithK ( String str , int k ) {	      void longestSubseqWithK ( string str , int k ) {		    void longestSubseqWithK ( string str , int k ) {		  script_not_found : None
  int n = str . length ( ) ;				      	int n = str . size ( ) ;				      int n = str . length ( ) ;				  
  int freq [ ] = new int [ MAX_CHARS ] ;		      	int freq [ MAX_CHARS ] = {				      vector < int > freq ( MAX_CHARS , 0 ) ;			  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < n ;						      	  ;							      i < n ;							  
  i ++ ) {						      	  for ( int i = 0 ;					      i ++ ) freq [ str [ i ] - 'a' ] ++ ;			  
    freq [ str . charAt ( i ) - 'a' ] ++ ;		      	  i < n ;						      for ( int i = 0 ;						  
  }							      	  i ++ ) freq [ str [ i ] - 'a' ] ++ ;			      i < n ;							  
  for ( int i = 0 ;					      	  for ( int i = 0 ;					      i ++ ) {							  
  i < n ;						      	  i < n ;						    	if ( freq [ str [ i ] - 'a' ] >= k ) cout << str [ i ] ;  
  i ++ ) {						      	  i ++ ) if ( freq [ str [ i ] - 'a' ] >= k ) cout << str [   }								  
    if ( freq [ str . charAt ( i ) - 'a' ] >= k ) {	      	}							    }								  
      System . out . print ( str . charAt ( i ) ) ;	      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES	      COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES	    COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES	  COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES
--							      --							    --								  --
int countwalks ( int graph [ ] [ ] , int u , int v , int k )  int countwalks ( int graph [ ] [ V ] , int u , int v , int k  int countwalks ( int graph [ V ] [ V ] , int u , int v , int  script_not_found : None
  if ( k == 0 && u == v ) return 1 ;			      	if ( k == 0 && u == v ) return 1 ;			      if ( k == 0 && u == v ) return 1 ;			  
  if ( k == 1 && graph [ u ] [ v ] == 1 ) return 1 ;	      	if ( k == 1 && graph [ u ] [ v ] ) return 1 ;		      if ( k == 1 && graph [ u ] [ v ] == 1 ) return 1 ;	  
  if ( k <= 0 ) return 0 ;				      	if ( k <= 0 ) return 0 ;				      if ( k <= 0 ) return 0 ;					  
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < V ;						      	i < V ;							      i < V ;							  
  i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks (  	i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks (    i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks (  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MIDDLE_ROW_COLUMN_MATRIX				      SUM_MIDDLE_ROW_COLUMN_MATRIX				    SUM_MIDDLE_ROW_COLUMN_MATRIX				  SUM_MIDDLE_ROW_COLUMN_MATRIX
--							      --							    --								  --
static void middlesum ( int mat [ ] [ ] , int n ) {	      void middlesum ( int mat [ ] [ MAX ] , int n ) {		    void middlesum ( int mat [ ] [ 2 ] , int n ) {		  script_not_found : None
  int row_sum = 0 , col_sum = 0 ;			      	int row_sum = 0 , col_sum = 0 ;				      int row_sum = 0 , col_sum = 0 ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) row_sum += mat [ n / 2 ] [ i ] ;		      	i ++ ) row_sum += mat [ n / 2 ] [ i ] ;			      i ++ ) {							  
  System . out . println ( "Sum of middle row = " + row_sum ) 	cout << "Sum of middle row = " << row_sum << endl ;	    	row_sum += mat [ n / 2 ] [ i ] ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      }								  
  i < n ;						      	i < n ;							      cout << "Sum of middle row = " << row_sum << endl ;	  
  i ++ ) col_sum += mat [ i ] [ n / 2 ] ;		      	i ++ ) col_sum += mat [ i ] [ n / 2 ] ;			      for ( int i = 0 ;						  
  System . out . println ( "Sum of middle column = " + col_su 	cout << "Sum of middle column = " << col_sum ;		      i < n ;							  
}							      }								      i ++ ) {							  
							      								    	col_sum += mat [ i ] [ n / 2 ] ;			  
							      								      }								  
							      								      cout << "Sum of middle column = " << col_sum << endl ;	  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES	      COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES		    COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES		  COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES
--							      --							    --								  --
static int countOfSubstringWithKOnes ( String s , int K ) {   int countOfSubstringWithKOnes ( string s , int K ) {	    int countOfSubstringWithKOnes ( string s , int K ) {	  script_not_found : None
  int N = s . length ( ) ;				      	int N = s . length ( ) ;				      int N = s . length ( ) ;					  
  int res = 0 ;						      	int res = 0 ;						      int res = 0 ;						  
  int countOfOne = 0 ;					      	int countOfOne = 0 ;					      int countOfOne = 0 ;					  
  int [ ] freq = new int [ N + 1 ] ;			      	int freq [ N + 1 ] = {					      vector < int > freq ( N + 1 , 1 ) ;			  
  freq [ 0 ] = 1 ;					      	  0 }							      freq [ 0 ] = 1 ;						  
  for ( int i = 0 ;					      	  ;							      for ( int i = 0 ;						  
  i < N ;						      	  freq [ 0 ] = 1 ;					      i < N ;							  
  i ++ ) {						      	  for ( int i = 0 ;					      i ++ ) {							  
    countOfOne += ( s . charAt ( i ) - '0' ) ;		      	  i < N ;						    	countOfOne += ( s [ i ] - '0' ) ;			  
    if ( countOfOne >= K ) {				      	  i ++ ) {						    	if ( countOfOne >= K ) res += freq [ countOfOne - K ] ;	  
      res += freq [ countOfOne - K ] ;			      	    countOfOne += ( s [ i ] - '0' ) ;			    	freq [ countOfOne ] ++ ;				  
    }							      	    if ( countOfOne >= K ) {				      }								  
    freq [ countOfOne ] ++ ;				      	      res += freq [ countOfOne - K ] ;			      return res ;						  
  }							      	    }							    }								  
  return res ;						      	    freq [ countOfOne ] ++ ;				    								  
}							      	  }							    								  
							      	  return res ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTISTAGE_GRAPH_SHORTEST_PATH				      MULTISTAGE_GRAPH_SHORTEST_PATH				    MULTISTAGE_GRAPH_SHORTEST_PATH				  MULTISTAGE_GRAPH_SHORTEST_PATH
--							      --							    --								  --
public static int shortestDist ( int [ ] [ ] graph ) {	      INT_MAX int shortestDist ( int graph [ N ] [ N ] ) {	    int shortestDist ( int * * graph ) {			  script_not_found : None
  int [ ] dist = new int [ N ] ;			      	int dist [ N ] ;					      int dist [ N ] ;						  
  dist [ N - 1 ] = 0 ;					      	dist [ N - 1 ] = 0 ;					      dist [ N - 1 ] = 0 ;					  
  for ( int i = N - 2 ;					      	for ( int i = N - 2 ;					      for ( int i = N - 2 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    dist [ i ] = INF ;					      	  dist [ i ] = INF ;					    	dist [ i ] = INF ;					  
    for ( int j = i ;					      	  for ( int j = i ;					    	for ( int j = i ;					  
    j < N ;						      	  j < N ;						    	j < N ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( graph [ i ] [ j ] == INF ) {			      	    if ( graph [ i ] [ j ] == INF ) continue ;		    	  if ( graph [ i ] [ j ] == INF ) continue ;		  
	continue ;					      	    dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dis 	  dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dis 
      }							      	  }							    	}							  
      dist [ i ] = Math . min ( dist [ i ] , graph [ i ] [ j  	}							      }								  
    }							      	return dist [ 0 ] ;					      return dist [ 0 ] ;					  
  }							      }								    }								  
  return dist [ 0 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE   MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE   MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE	  MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE
--							      --							    --								  --
static int findMinRooms ( String slots [ ] , int n , int m )  int findMinRooms ( string slots [ ] , int n , int m ) {	    int findMinRooms ( string slots [ ] , int n , int m ) {	  error : /bin/bash: line 1: 3926297 Aborted
  int counts [ ] = new int [ m ] ;			      	int counts [ m ] = {					      vector < int > counts ( m , 0 ) ;				  	   (core dumped) ./MINIMUM_ROOMS_FOR_M_EVENT
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  S_OF_N_BATCHES_WITH_GIVEN_SCHEDULE_cpp
  i < m ;						      	  ;							      i < m ;							  
  i ++ ) counts [ i ] = 0 ;				      	  for ( int i = 0 ;					      i ++ ) {							  
  for ( int i = 0 ;					      	  i < n ;						    	counts [ i ] = 0 ;					  
  i < n ;						      	  i ++ ) for ( int j = 0 ;				      }								  
  i ++ ) for ( int j = 0 ;				      	  j < m ;						      for ( int i = 0 ;						  
  j < m ;						      	  j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ;    i < n ;							  
  j ++ ) if ( slots [ i ] . charAt ( j ) == '1' ) counts [ j  	  return * max_element ( counts , counts + m ) ;	      i ++ ) for ( int j = 0 ;					  
  int max = - 1 ;					      	}							      j < m ;							  
  for ( int i = 0 ;					      								      j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ;	  
  i < m ;						      								      int max = - 1 ;						  
  i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ;	      								      for ( int i = 0 ;						  
  return max ;						      								      i < m ;							  
}							      								      i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ;	  
							      								      return max ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STOOGE_SORT						      STOOGE_SORT						    STOOGE_SORT							  STOOGE_SORT
--							      --							    --								  --
static void stoogesort ( int arr [ ] , int l , int h ) {      void stoogesort ( int arr [ ] , int l , int h ) {		    void stoogesort ( int arr [ ] , int l , int h ) {		  success : None
  if ( l >= h ) return ;				      	if ( l >= h ) return ;					      if ( l >= h ) return ;					  
  if ( arr [ l ] > arr [ h ] ) {			      	if ( arr [ l ] > arr [ h ] ) swap ( arr [ l ] , arr [ h ] )   if ( arr [ l ] > arr [ h ] ) {				  
    int t = arr [ l ] ;					      	if ( h - l + 1 > 2 ) {					    	int t = arr [ l ] ;					  
    arr [ l ] = arr [ h ] ;				      	  int t = ( h - l + 1 ) / 3 ;				    	arr [ l ] = arr [ h ] ;					  
    arr [ h ] = t ;					      	  stoogesort ( arr , l , h - t ) ;			    	arr [ h ] = t ;						  
  }							      	  stoogesort ( arr , l + t , h ) ;			      }								  
  if ( h - l + 1 > 2 ) {				      	  stoogesort ( arr , l , h - t ) ;			      if ( h - l + 1 > 2 ) {					  
    int t = ( h - l + 1 ) / 3 ;				      	}							    	int t = ( h - l + 1 ) / 3 ;				  
    stoogesort ( arr , l , h - t ) ;			      }								    	stoogesort ( arr , l , h - t ) ;			  
    stoogesort ( arr , l + t , h ) ;			      								    	stoogesort ( arr , l + t , h ) ;			  
    stoogesort ( arr , l , h - t ) ;			      								    	stoogesort ( arr , l , h - t ) ;			  
  }							      								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1			      FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1			    FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1				  FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1
--							      --							    --								  --
static void CountTriangles ( int [ ] A ) {		      void CountTriangles ( vector < int > A ) {		    void CountTriangles ( vector < int > A ) {			  script_not_found : None
  int n = A . length ;					      	int n = A . size ( ) ;					      int n = A . size ( ) ;					  
  Arrays . sort ( A ) ;					      	sort ( A . begin ( ) , A . end ( ) ) ;			      sort ( A . begin ( ) , A . end ( ) ) ;			  
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = n - 1 ;					      	for ( int i = n - 1 ;					      for ( int i = n - 1 ;					  
  i >= 1 ;						      	i >= 1 ;						      i >= 1 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    int l = 0 , r = i - 1 ;				      	  int l = 0 , r = i - 1 ;				    	int l = 0 , r = i - 1 ;					  
    while ( l < r ) {					      	  while ( l < r ) {					    	while ( l < r ) {					  
      if ( A [ l ] + A [ r ] > A [ i ] ) {		      	    if ( A [ l ] + A [ r ] > A [ i ] ) {		    	  if ( A [ l ] + A [ r ] > A [ i ] ) {			  
	count += r - l ;				      	      count += r - l ;					    	    count += r - l ;					  
	r -- ;						      	      r -- ;						    	    r -- ;						  
      }							      	    }							    	  }							  
      else {						      	    else l ++ ;						    	  else {						  
	l ++ ;						      	  }							    	    l ++ ;						  
      }							      	}							    	  }							  
    }							      	cout << "No of possible solutions: " << count ;		    	}							  
  }							      }								      }								  
  System . out . print ( "No of possible solutions: " + count 								      cout << "No of possible solutions: " << count << endl ;	  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1		      SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1		    SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1			  SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1
--							      --							    --								  --
static void minheapify ( int [ ] a , int index ) {	      void minheapify ( int a [ ] , int index ) {		    void minheapify ( int * a , int index ) {			  script_not_found : None
  int small = index ;					      	int small = index ;					      int small = index ;					  
  int l = 2 * index + 1 ;				      	int l = 2 * index + 1 ;					      int l = 2 * index + 1 ;					  
  int r = 2 * index + 2 ;				      	int r = 2 * index + 2 ;					      int r = 2 * index + 2 ;					  
  if ( l < n && a [ l ] < a [ small ] ) small = l ;	      	if ( l < n && a [ l ] < a [ small ] ) small = l ;	      if ( l < n && a [ l ] < a [ small ] ) {			  
  if ( r < n && a [ r ] < a [ small ] ) small = r ;	      	if ( r < n && a [ r ] < a [ small ] ) small = r ;	    	small = l ;						  
  if ( small != index ) {				      	if ( small != index ) {					      }								  
    int t = a [ small ] ;				      	  swap ( a [ small ] , a [ index ] ) ;			      if ( r < n && a [ r ] < a [ small ] ) {			  
    a [ small ] = a [ index ] ;				      	  minheapify ( a , small ) ;				    	small = r ;						  
    a [ index ] = t ;					      	}							      }								  
    minheapify ( a , small ) ;				      }								      if ( small != index ) {					  
  }							      								    	int t = a [ small ] ;					  
}							      								    	a [ small ] = a [ index ] ;				  
							      								    	a [ index ] = t ;					  
							      								    	minheapify ( a , small ) ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECAMANS_SEQUENCE_1					      RECAMANS_SEQUENCE_1					    RECAMANS_SEQUENCE_1						  RECAMANS_SEQUENCE_1
--							      --							    --								  --
static void recaman ( int n ) {				      void recaman ( int n ) {					    void recaman ( int n ) {					  script_not_found : None
  if ( n <= 0 ) return ;				      	if ( n <= 0 ) return ;					      if ( n <= 0 ) return ;					  
  System . out . printf ( "%d, " , 0 ) ;		      	printf ( "%d, " , 0 ) ;					      printf ( "%d, " , 0 ) ;					  
  HashSet < Integer > s = new HashSet < Integer > ( ) ;	      	unordered_set < int > s ;				      set < int > s ;						  
  s . add ( 0 ) ;					      	s . insert ( 0 ) ;					      s . insert ( 0 ) ;					  
  int prev = 0 ;					      	int prev = 0 ;						      int prev = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int curr = prev - i ;				      	  int curr = prev - i ;					    	int curr = prev - i ;					  
    if ( curr < 0 || s . contains ( curr ) ) curr = prev + i  	  if ( curr < 0 || s . find ( curr ) != s . end ( ) ) curr  	if ( curr < 0 || s . count ( curr ) == 0 ) curr = prev +  
    s . add ( curr ) ;					      	  s . insert ( curr ) ;					    	s . insert ( curr ) ;					  
    System . out . printf ( "%d, " , curr ) ;		      	  printf ( "%d, " , curr ) ;				    	printf ( "%d, " , curr ) ;				  
    prev = curr ;					      	  prev = curr ;						    	prev = curr ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS      COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS	    COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS	  COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS
--							      --							    --								  --
static int chordCnt ( int A ) {				      int chordCnt ( int A ) {					    int chordCnt ( int A ) {					  failure : #Results: 0, 10
  int n = 2 * A ;					      	int n = 2 * A ;						      int n = 2 * A ;						  
  int [ ] dpArray = new int [ n + 1 ] ;			      	int dpArray [ n + 1 ] = {				      int dpArray [ n + 1 ] ;					  
  dpArray [ 0 ] = 1 ;					      	  0 }							      dpArray [ 0 ] = 1 ;					  
  dpArray [ 2 ] = 1 ;					      	  ;							      dpArray [ 2 ] = 1 ;					  
  for ( int i = 4 ;					      	  dpArray [ 0 ] = 1 ;					      for ( int i = 4 ;						  
  i <= n ;						      	  dpArray [ 2 ] = 1 ;					      i <= n ;							  
  i += 2 ) {						      	  for ( int i = 4 ;					      i += 2 ) {						  
    for ( int j = 0 ;					      	  i <= n ;						    	for ( int j = 0 ;					  
    j < i - 1 ;						      	  i += 2 ) {						    	j < i - 1 ;						  
    j += 2 ) {						      	    for ( int j = 0 ;					    	j += 2 ) dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 
      dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j  	    j < i - 1 ;						      }								  
    }							      	    j += 2 ) {						      return dpArray [ n ] ;					  
  }							      	      dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 -  }								  
  return dpArray [ n ] ;				      	    }							    								  
}							      	  }							    								  
							      	  return dpArray [ n ] ;				    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE	      COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE		    COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE		  COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE
--							      --							    --								  --
static int countIslands ( int mat [ ] [ ] , int m , int n ) { int countIslands ( int mat [ ] [ N ] ) {			    int countIslands ( int mat [ ] [ 2 ] , int m , int n ) {	  script_not_found : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m ;						      	i < M ;							      i < m ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < N ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( mat [ i ] [ j ] == 'X' ) {			      	    if ( mat [ i ] [ j ] == 'X' ) {			    	  if ( mat [ i ] [ j ] == 'X' ) {			  
	if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j  	      if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j  	    if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j  
      }							      	    }							    	      count ++ ;					  
    }							      	  }							    	    }							  
  }							      	}							    	  }							  
  return count ;					      	return count ;						    	}							  
}							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1	      CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1		    CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1		  CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1
--							      --							    --								  --
static boolean checkCorrectOrNot ( String s ) {		      bool checkCorrectOrNot ( string s ) {			    bool checkCorrectOrNot ( string s ) {			  script_not_found : None
  int [ ] count = new int [ MAX_CHAR ] ;		      	int count [ MAX_CHAR ] = {				      vector < int > count ( MAX_CHAR , 0 ) ;			  
  int n = s . length ( ) ;				      	  0 }							      int n = s . length ( ) ;					  
  if ( n == 1 ) return true ;				      	  ;							      if ( n == 1 ) return true ;				  
  for ( int i = 0 , j = n - 1 ;				      	  int n = s . length ( ) ;				      for ( int i = 0 , j = n - 1 ;				  
  i < j ;						      	  if ( n == 1 ) return true ;				      i < j ;							  
  i ++ , j -- ) {					      	  for ( int i = 0 , j = n - 1 ;				      i ++ , j -- ) {						  
    count [ s . charAt ( i ) - 'a' ] ++ ;		      	  i < j ;						    	count [ s [ i ] - 'a' ] ++ ;				  
    count [ s . charAt ( j ) - 'a' ] -- ;		      	  i ++ , j -- ) {					    	count [ s [ j ] - 'a' ] -- ;				  
  }							      	    count [ s [ i ] - 'a' ] ++ ;			      }								  
  for ( int i = 0 ;					      	    count [ s [ j ] - 'a' ] -- ;			      for ( int i = 0 ;						  
  i < MAX_CHAR ;					      	  }							      i < MAX_CHAR ;						  
  i ++ ) if ( count [ i ] != 0 ) return false ;		      	  for ( int i = 0 ;					      i ++ ) if ( count [ i ] != 0 ) return false ;		  
  return true ;						      	  i < MAX_CHAR ;					      return true ;						  
}							      	  i ++ ) if ( count [ i ] != 0 ) return false ;		    }								  
							      	  return true ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
JUMP_SEARCH						      JUMP_SEARCH						    JUMP_SEARCH							  JUMP_SEARCH
--							      --							    --								  --
public static int jumpSearch ( int [ ] arr , int x ) {	      int jumpSearch ( int arr [ ] , int x , int n ) {		    int jumpSearch ( vector < int > arr , int x ) {		  script_not_found : None
  int n = arr . length ;				      	int step = sqrt ( n ) ;					      int n = arr . size ( ) ;					  
  int step = ( int ) Math . floor ( Math . sqrt ( n ) ) ;     	int prev = 0 ;						      int step = ( int ) floor ( sqrt ( n ) ) ;			  
  int prev = 0 ;					      	while ( arr [ min ( step , n ) - 1 ] < x ) {		      int prev = 0 ;						  
  while ( arr [ Math . min ( step , n ) - 1 ] < x ) {	      	  prev = step ;						      while ( arr [ min ( step , n ) - 1 ] < x ) {		  
    prev = step ;					      	  step += sqrt ( n ) ;					    	prev = step ;						  
    step += ( int ) Math . floor ( Math . sqrt ( n ) ) ;      	  if ( prev >= n ) return - 1 ;				    	step += ( int ) floor ( sqrt ( n ) ) ;			  
    if ( prev >= n ) return - 1 ;			      	}							    	if ( prev >= n ) return - 1 ;				  
  }							      	while ( arr [ prev ] < x ) {				      }								  
  while ( arr [ prev ] < x ) {				      	  prev ++ ;						      while ( arr [ prev ] < x ) {				  
    prev ++ ;						      	  if ( prev == min ( step , n ) ) return - 1 ;		    	prev ++ ;						  
    if ( prev == Math . min ( step , n ) ) return - 1 ;	      	}							    	if ( prev == min ( step , n ) ) return - 1 ;		  
  }							      	if ( arr [ prev ] == x ) return prev ;			      }								  
  if ( arr [ prev ] == x ) return prev ;		      	return - 1 ;						      if ( arr [ prev ] == x ) return prev ;			  
  return - 1 ;						      }								      return - 1 ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FITTING_SHELVES_PROBLEM					      FITTING_SHELVES_PROBLEM					    FITTING_SHELVES_PROBLEM					  FITTING_SHELVES_PROBLEM
--							      --							    --								  --
static void minSpacePreferLarge ( int wall , int m , int n )  void minSpacePreferLarge ( int wall , int m , int n ) {	    void minSpacePreferLarge ( int wall , int m , int n ) {	  script_not_found : None
  int num_m = 0 , num_n = 0 , min_empty = wall ;	      	int num_m = 0 , num_n = 0 , min_empty = wall ;		      int num_m = 0 , num_n = 0 , min_empty = wall ;		  
  int p = 0 , q = 0 , rem ;				      	int p = 0 , q = 0 , rem ;				      int p = 0 , q = 0 , rem ;					  
  while ( wall >= n ) {					      	while ( wall >= n ) {					      while ( wall >= n ) {					  
    p = wall / m ;					      	  p = wall / m ;					    	p = wall / m ;						  
    rem = wall % m ;					      	  rem = wall % m ;					    	rem = wall % m ;					  
    if ( rem <= min_empty ) {				      	  if ( rem <= min_empty ) {				    	if ( rem <= min_empty ) {				  
      num_m = p ;					      	    num_m = p ;						    	  num_m = p ;						  
      num_n = q ;					      	    num_n = q ;						    	  num_n = q ;						  
      min_empty = rem ;					      	    min_empty = rem ;					    	  min_empty = rem ;					  
    }							      	  }							    	}							  
    q += 1 ;						      	  q += 1 ;						    	q += 1 ;						  
    wall = wall - n ;					      	  wall = wall - n ;					    	wall = wall - n ;					  
  }							      	}							      }								  
  System . out . println ( num_m + " " + num_n + " " + min_em 	cout << num_m << " " << num_n << " " << min_empty << endl ;   cout << num_m << " " << num_n << " " << min_empty << endl ; 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1		      COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1		    COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1			  COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1
--							      --							    --								  --
static int countPairs ( int arr [ ] , int n ) {		      int countPairs ( int arr [ ] , int n ) {			    int countPairs ( int arr [ ] , int n ) {			  success : None
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  HashSet < Integer > Hash = new HashSet < > ( ) ;	      	set < int > Hash ;					      unordered_set < int > Hash ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) Hash . insert ( arr [ i ] ) ;			      i ++ ) Hash . insert ( arr [ i ] ) ;			  
    Hash . add ( arr [ i ] ) ;				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  }							      	i < n ;							      i < n ;							  
  for ( int i = 0 ;					      	i ++ ) {						      i ++ ) {							  
  i < n ;						      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
  i ++ ) {						      	  j < n ;						    	j < n ;							  
    for ( int j = i + 1 ;				      	  j ++ ) {						    	j ++ ) {						  
    j < n ;						      	    int product = arr [ i ] * arr [ j ] ;		    	  int product = arr [ i ] * arr [ j ] ;			  
    j ++ ) {						      	    if ( Hash . find ( product ) != Hash . end ( ) ) result 	  if ( Hash . find ( product ) != Hash . end ( ) ) result 
      int product = arr [ i ] * arr [ j ] ;		      	  }							    	}							  
      if ( Hash . contains ( product ) ) {		      	}							      }								  
	result ++ ;					      	return result ;						      return result ;						  
      }							      }								    }								  
    }							      								    								  
  }							      								    								  
  return result ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAJORITY_ELEMENT					      MAJORITY_ELEMENT						    MAJORITY_ELEMENT						  MAJORITY_ELEMENT
--							      --							    --								  --
static void findMajority ( int arr [ ] , int n ) {	      void findMajority ( int arr [ ] , int n ) {		    void findMajority ( int arr [ ] , int n ) {			  script_not_found : None
  int maxCount = 0 ;					      	int maxCount = 0 ;					      int maxCount = 0 ;					  
  int index = - 1 ;					      	int index = - 1 ;					      int index = - 1 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int count = 0 ;					      	  int count = 0 ;					    	int count = 0 ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( arr [ i ] == arr [ j ] ) count ++ ;		      	    if ( arr [ i ] == arr [ j ] ) count ++ ;		    	  if ( arr [ i ] == arr [ j ] ) {			  
    }							      	  }							    	    count ++ ;						  
    if ( count > maxCount ) {				      	  if ( count > maxCount ) {				    	  }							  
      maxCount = count ;				      	    maxCount = count ;					    	}							  
      index = i ;					      	    index = i ;						    	if ( count > maxCount ) {				  
    }							      	  }							    	  maxCount = count ;					  
  }							      	}							    	  index = i ;						  
  if ( maxCount > n / 2 ) System . out . println ( arr [ inde 	if ( maxCount > n / 2 ) cout << arr [ index ] << endl ;	    	}							  
  else System . out . println ( "No Majority Element" ) ;     	else cout << "No Majority Element" << endl ;		      }								  
}							      }								      if ( maxCount > n / 2 ) {					  
							      								    	cout << arr [ index ] << endl ;				  
							      								      }								  
							      								      else {							  
							      								    	cout << "No Majority Element" << endl ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL		      CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL		    CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL			  CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL
--							      --							    --								  --
static void substringConversions ( String str , int k , int b int substringConversions ( string str , int k , int b ) {	    void substring_conversions ( string str , int k , int b ) {	  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i + k <= str . length ( ) ;				      	i + k <= str . size ( ) ;				      i + k <= str . length ( ) ;				  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    String sub = str . substring ( i , i + k ) ;	      	  string sub = str . substr ( i , k ) ;			    	string sub = str . substr ( i , k ) ;			  
    int sum = 0 , counter = 0 ;				      	  int sum = 0 , counter = 0 ;				    	int sum = 0 , counter = 0 ;				  
    for ( int j = sub . length ( ) - 1 ;		      	  for ( int i = sub . size ( ) - 1 ;			    	for ( int j = sub . length ( ) - 1 ;			  
    j >= 0 ;						      	  i >= 0 ;						    	j >= 0 ;						  
    j -- ) {						      	  i -- ) {						    	j -- ) {						  
      sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) *  	    sum = sum + ( ( sub . at ( i ) - '0' ) * pow ( b , coun 	  sum = ( int ) ( sum + ( ( sub [ j ] - '0' ) * pow ( b , 
      counter ++ ;					      	    counter ++ ;					    	  counter ++ ;						  
    }							      	  }							    	}							  
    System . out . print ( sum + " " ) ;		      	  cout << sum << " " ;					    	cout << sum << " " ;					  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR
--							      --							    --								  --
static void alternateSubarray ( boolean arr [ ] , int n ) {   void alternateSubarray ( bool arr [ ] , int n ) {		    void alternate_subarray ( bool arr [ ] , int n ) {		  script_not_found : None
  int len [ ] = new int [ n ] ;				      	int len [ n ] ;						      int len [ n ] ;						  
  len [ n - 1 ] = 1 ;					      	len [ n - 1 ] = 1 ;					      len [ n - 1 ] = 1 ;					  
  for ( int i = n - 2 ;					      	for ( int i = n - 2 ;					      for ( int i = n - 2 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  -- i ) {						      	-- i ) {						      -- i ) {							  
    if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len  	  if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i 	if ( arr [ i ] ^ arr [ i + 1 ] == true ) {		  
    else len [ i ] = 1 ;				      	  else len [ i ] = 1 ;					    	  len [ i ] = len [ i + 1 ] + 1 ;			  
  }							      	}							    	}							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	else {							  
  i < n ;						      	i < n ;							    	  len [ i ] = 1 ;					  
  ++ i ) System . out . print ( len [ i ] + " " ) ;	      	++ i ) cout << len [ i ] << " " ;			    	}							  
}							      }								      }								  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      ++ i ) {							  
							      								    	cout << len [ i ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI
--							      --							    --								  --
boolean canRepresentBST ( int pre [ ] , int n ) {	      bool canRepresentBST ( int pre [ ] , int n ) {		    bool canRepresentBST ( int pre [ ] , int n ) {		  success : identical to gold
  Stack < Integer > s = new Stack < Integer > ( ) ;	      	stack < int > s ;					      stack < int > s ;						  
  int root = Integer . MIN_VALUE ;			      	int root = INT_MIN ;					      int root = INT_MIN ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( pre [ i ] < root ) {				      	  if ( pre [ i ] < root ) return false ;		    	if ( pre [ i ] < root ) return false ;			  
      return false ;					      	  while ( ! s . empty ( ) && s . top ( ) < pre [ i ] ) {    	while ( ! s . empty ( ) && s . top ( ) < pre [ i ] ) {	  
    }							      	    root = s . top ( ) ;				    	  root = s . top ( ) ;					  
    while ( ! s . empty ( ) && s . peek ( ) < pre [ i ] ) {   	    s . pop ( ) ;					    	  s . pop ( ) ;						  
      root = s . peek ( ) ;				      	  }							    	}							  
      s . pop ( ) ;					      	  s . push ( pre [ i ] ) ;				    	s . push ( pre [ i ] ) ;				  
    }							      	}							      }								  
    s . push ( pre [ i ] ) ;				      	return true ;						      return true ;						  
  }							      }								    }								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM		      DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM		    DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM		  DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM
--							      --							    --								  --
static int knapSack ( int W , int wt [ ] , int val [ ] , int  int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {   int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {	  success : identical to gold
  if ( n == 0 || W == 0 ) return 0 ;			      	if ( n == 0 || W == 0 ) return 0 ;			      if ( n == 0 || W == 0 ) return 0 ;			  
  if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n  	if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n    if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n  
  else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 	else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1   else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY
--							      --							    --								  --
public static void longestAlternating ( int arr [ ] , int n ) void longestAlternating ( int arr [ ] , int n ) {		    int longestAlternating ( int arr [ ] , int n ) {		  script_not_found : None
  int [ ] count = new int [ n ] ;			      	int count [ n ] ;					      int count [ n ] ;						  
  count [ n - 1 ] = 1 ;					      	count [ n - 1 ] = 1 ;					      count [ n - 1 ] = 1 ;					  
  for ( int i = n - 2 ;					      	for ( int i = n - 2 ;					      for ( int i = n - 2 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count  	  if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count  	if ( arr [ i ] * arr [ i + 1 ] < 0 ) {			  
    else count [ i ] = 1 ;				      	  else count [ i ] = 1 ;				    	  count [ i ] = count [ i + 1 ] + 1 ;			  
  }							      	}							    	}							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	else {							  
  i < n ;						      	i < n ;							    	  count [ i ] = 1 ;					  
  i ++ ) System . out . print ( count [ i ] + " " ) ;	      	i ++ ) cout << count [ i ] << " " ;			    	}							  
}							      }								      }								  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) {							  
							      								    	cout << count [ i ] << " " ;				  
							      								      }								  
							      								      return count [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORTING_USING_TRIVIAL_HASH_FUNCTION			      SORTING_USING_TRIVIAL_HASH_FUNCTION			    SORTING_USING_TRIVIAL_HASH_FUNCTION				  SORTING_USING_TRIVIAL_HASH_FUNCTION
--							      --							    --								  --
static void sortUsingHash ( int a [ ] , int n ) {	      void sortUsingHash ( int a [ ] , int n ) {		    void sortUsingHash ( int a [ ] , int n ) {			  script_not_found : None
  int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ;  	int max = * std :: max_element ( a , a + n ) ;		      int max = std :: max ( a , a + n ) ;			  
  int hash [ ] = new int [ max + 1 ] ;			      	int hash [ max + 1 ] = {				      int hash [ max + 1 ] ;					  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < n ;						      	  ;							      i < n ;							  
  i ++ ) hash [ a [ i ] ] += 1 ;			      	  for ( int i = 0 ;					      i ++ ) {							  
  for ( int i = 0 ;					      	  i < n ;						    	hash [ a [ i ] ] += 1 ;					  
  i <= max ;						      	  i ++ ) hash [ a [ i ] ] += 1 ;			      }								  
  i ++ ) {						      	  for ( int i = 0 ;					      for ( int i = 0 ;						  
    if ( hash [ i ] != 0 ) {				      	  i <= max ;						      i <= max ;						  
      for ( int j = 0 ;					      	  i ++ ) {						      i ++ ) {							  
      j < hash [ i ] ;					      	    if ( hash [ i ] ) {					    	if ( hash [ i ] != 0 ) {				  
      j ++ ) {						      	      for ( int j = 0 ;					    	  for ( int j = 0 ;					  
	System . out . print ( i + " " ) ;		      	      j < hash [ i ] ;					    	  j < hash [ i ] ;					  
      }							      	      j ++ ) {						    	  j ++ ) {						  
    }							      		cout << i << " " ;				    	    cout << i << " " ;					  
  }							      	      }							    	  }							  
}							      	    }							    	}							  
							      	  }							      }								  
							      	}							    }								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PASCAL_TRIANGLE						      PASCAL_TRIANGLE						    PASCAL_TRIANGLE						  PASCAL_TRIANGLE
--							      --							    --								  --
public static void printPascal ( int n ) {		      void printPascal ( int n ) {				    void printPascal ( int n ) {				  script_not_found : None
  int [ ] [ ] arr = new int [ n ] [ n ] ;		      	int arr [ n ] [ n ] ;					      vector < vector < int >> arr ( n , vector < int > ( n , 0 ) 
  for ( int line = 0 ;					      	for ( int line = 0 ;					      for ( int line = 0 ;					  
  line < n ;						      	line < n ;						      line < n ;						  
  line ++ ) {						      	line ++ ) {						      line ++ ) {						  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
    i <= line ;						      	  i <= line ;						    	i <= line ;						  
    i ++ ) {						      	  i ++ ) {						    	i ++ ) {						  
      if ( line == i || i == 0 ) arr [ line ] [ i ] = 1 ;     	    if ( line == i || i == 0 ) arr [ line ] [ i ] = 1 ;	    	  if ( line == i || i == 0 ) {				  
      else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] +  	    else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] +  	    arr [ line ] [ i ] = 1 ;				  
      System . out . print ( arr [ line ] [ i ] ) ;	      	    cout << arr [ line ] [ i ] << " " ;			    	  }							  
    }							      	  }							    	  else {						  
    System . out . println ( "" ) ;			      	  cout << "\n" ;					    	    arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr 
  }							      	}							    	  }							  
}							      }								    	  cout << arr [ line ] [ i ] ;				  
							      								    	}							  
							      								    	cout << "\n" ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PATH_SUM_TRIANGLE				      MAXIMUM_PATH_SUM_TRIANGLE					    MAXIMUM_PATH_SUM_TRIANGLE					  MAXIMUM_PATH_SUM_TRIANGLE
--							      --							    --								  --
static int maxPathSum ( int tri [ ] [ ] , int m , int n ) {   int maxPathSum ( int tri [ ] [ N ] , int m , int n ) {	    int maxPathSum ( int tri [ ] [ 3 ] , int m , int n ) {	  script_not_found : None
  for ( int i = m - 1 ;					      	for ( int i = m - 1 ;					      for ( int i = m - 1 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= i ;						      	  j <= i ;						    	j <= i ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tr 	    if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tr 	  if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) {  
      else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ;	      	    else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ;	    	    tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ;		  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  return tri [ 0 ] [ 0 ] ;				      	return tri [ 0 ] [ 0 ] ;				    	    tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ;	  
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return tri [ 0 ] [ 0 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS		      FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS		    FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS		  FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS
--							      --							    --								  --
int minDist ( int arr [ ] , int n , int x , int y ) {	      int minDist ( int arr [ ] , int n , int x , int y ) {	    int minDist ( int arr [ ] , int n , int x , int y ) {	  success : identical to gold
  int i , j ;						      	int i , j ;						      int i , j ;						  
  int min_dist = Integer . MAX_VALUE ;			      	int min_dist = INT_MAX ;				      int min_dist = INT_MAX ;					  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( j = i + 1 ;					      	  for ( j = i + 1 ;					    	for ( j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i 	    if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i 	  if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i 
    }							      	      min_dist = abs ( i - j ) ;			    	    min_dist = abs ( i - j ) ;				  
  }							      	    }							    	  }							  
  return min_dist ;					      	  }							    	}							  
}							      	}							      }								  
							      	return min_dist ;					      return min_dist ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS	      HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS	    HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS	  HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS
--							      --							    --								  --
static int findoptimal ( int N ) {			      int findoptimal ( int N ) {				    int findoptimal ( int N ) {					  success : None
  if ( N <= 6 ) return N ;				      	if ( N <= 6 ) return N ;				      if ( N <= 6 ) return N ;					  
  int [ ] screen = new int [ N ] ;			      	int screen [ N ] ;					      int screen [ N ] ;					  
  int b ;						      	int b ;							      int b ;							  
  int n ;						      	int n ;							      int n ;							  
  for ( n = 1 ;						      	for ( n = 1 ;						      for ( n = 1 ;						  
  n <= 6 ;						      	n <= 6 ;						      n <= 6 ;							  
  n ++ ) screen [ n - 1 ] = n ;				      	n ++ ) screen [ n - 1 ] = n ;				      n ++ ) {							  
  for ( n = 7 ;						      	for ( n = 7 ;						    	screen [ n - 1 ] = n ;					  
  n <= N ;						      	n <= N ;						      }								  
  n ++ ) {						      	n ++ ) {						      for ( n = 7 ;						  
    screen [ n - 1 ] = Math . max ( 2 * screen [ n - 4 ] , Ma 	  screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 *   n <= N ;							  
  }							      	}							      n ++ ) {							  
  return screen [ N - 1 ] ;				      	return screen [ N - 1 ] ;				    	screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * 
}							      }								      }								  
							      								      return screen [ N - 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N		      PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N		    PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N		  PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N
--							      --							    --								  --
static void findConsecutive ( int N ) {			      void findConsecutive ( int N ) {				    void findConsecutive ( int N ) {				  script_not_found : None
  int start = 1 ;					      	int start = 1 , end = ( N + 1 ) / 2 ;			      int start = 1 ;						  
  int end = ( N + 1 ) / 2 ;				      	while ( start < end ) {					      int end = ( N + 1 ) / 2 ;					  
  while ( start < end ) {				      	  int sum = 0 ;						      while ( start < end ) {					  
    int sum = 0 ;					      	  for ( int i = start ;					    	int sum = 0 ;						  
    for ( int i = start ;				      	  i <= end ;						    	for ( int i = start ;					  
    i <= end ;						      	  i ++ ) {						    	i <= end ;						  
    i ++ ) {						      	    sum = sum + i ;					    	i ++ ) {						  
      sum = sum + i ;					      	    if ( sum == N ) {					    	  sum = sum + i ;					  
      if ( sum == N ) {					      	      for ( int j = start ;				    	  if ( sum == N ) {					  
	for ( int j = start ;				      	      j <= i ;						    	    for ( int j = start ;				  
	j <= i ;					      	      j ++ ) printf ( "%d " , j ) ;			    	    j <= i ;						  
	j ++ ) System . out . print ( j + " " ) ;	      	      printf ( "\n" ) ;					    	    j ++ ) {						  
	System . out . println ( ) ;			      	      break ;						    	      cout << j << " " ;				  
	break ;						      	    }							    	    }							  
      }							      	    if ( sum > N ) break ;				    	    cout << endl ;					  
      if ( sum > N ) break ;				      	  }							    	    break ;						  
    }							      	  sum = 0 ;						    	  }							  
    sum = 0 ;						      	  start ++ ;						    	  if ( sum > N ) break ;				  
    start ++ ;						      	}							    	}							  
  }							      }								    	sum = 0 ;						  
}							      								    	start ++ ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_REVERSE_STRING_REMOVING_VOWELS			      PRINT_REVERSE_STRING_REMOVING_VOWELS			    PRINT_REVERSE_STRING_REMOVING_VOWELS			  PRINT_REVERSE_STRING_REMOVING_VOWELS
--							      --							    --								  --
static void replaceOriginal ( String s , int n ) {	      void replaceOriginal ( string s , int n ) {		    void replaceOriginal ( string s , int n ) {			  script_not_found : None
  char r [ ] = new char [ n ] ;				      	string r ( n , ' ' ) ;					      string r ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    r [ i ] = s . charAt ( n - 1 - i ) ;		      	  r [ i ] = s [ n - 1 - i ] ;				    	r += s [ n - 1 - i ] ;					  
    if ( s . charAt ( i ) != 'a' && s . charAt ( i ) != 'e' & 	  if ( s [ i ] != 'a' && s [ i ] != 'e' && s [ i ] != 'i' & 	if ( s [ i ] != 'a' && s [ i ] != 'e' && s [ i ] != 'i' & 
      System . out . print ( r [ i ] ) ;		      	    cout << r [ i ] ;					      }								  
    }							      	  }							      cout << "\n" ;						  
  }							      	}							    }								  
  System . out . println ( "" ) ;			      	cout << endl ;						    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FREQUENT_ELEMENT_ARRAY_1				      FREQUENT_ELEMENT_ARRAY_1					    FREQUENT_ELEMENT_ARRAY_1					  FREQUENT_ELEMENT_ARRAY_1
--							      --							    --								  --
static int mostFrequent ( int arr [ ] , int n ) {	      int mostFrequent ( int arr [ ] , int n ) {		    int mostFrequent ( int arr [ ] , int n ) {			  failure : #Results: 6, 10
  Map < Integer , Integer > hp = new HashMap < Integer , Inte 	unordered_map < int , int > hash ;			      map < int , int > hp ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) hash [ arr [ i ] ] ++ ;				      i ++ ) {							  
    int key = arr [ i ] ;				      	int max_count = 0 , res = - 1 ;				    	int key = arr [ i ] ;					  
    if ( hp . containsKey ( key ) ) {			      	for ( auto i : hash ) {					    	if ( hp . find ( key ) != hp . end ( ) ) {		  
      int freq = hp . get ( key ) ;			      	  if ( max_count < i . second ) {			    	  int freq = hp [ key ] ;				  
      freq ++ ;						      	    res = i . first ;					    	  freq ++ ;						  
      hp . put ( key , freq ) ;				      	    max_count = i . second ;				    	  hp [ key ] = freq ;					  
    }							      	  }							    	}							  
    else {						      	}							    	else hp [ key ] = 1 ;					  
      hp . put ( key , 1 ) ;				      	return res ;						      }								  
    }							      }								      int maxCount = 0 , res = - 1 ;				  
  }							      								      for ( map < int , int > :: iterator val = hp . begin ( ) ;  
  int max_count = 0 , res = - 1 ;			      								      val != hp . end ( ) ;					  
  for ( Entry < Integer , Integer > val : hp . entrySet ( ) ) 								      val ++ ) {						  
    if ( max_count < val . getValue ( ) ) {		      								    	if ( maxCount < val -> second ) {			  
      res = val . getKey ( ) ;				      								    	  res = val -> first ;					  
      max_count = val . getValue ( ) ;			      								    	  maxCount = val -> second ;				  
    }							      								    	}							  
  }							      								      }								  
  return res ;						      								      return res ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BRESENHAMS_LINE_GENERATION_ALGORITHM			      BRESENHAMS_LINE_GENERATION_ALGORITHM			    BRESENHAMS_LINE_GENERATION_ALGORITHM			  BRESENHAMS_LINE_GENERATION_ALGORITHM
--							      --							    --								  --
static void bresenham ( int x1 , int y1 , int x2 , int y2 ) { void bresenham ( int x1 , int y1 , int x2 , int y2 ) {	    void bresenham ( int x1 , int y1 , int x2 , int y2 ) {	  script_not_found : None
  int m_new = 2 * ( y2 - y1 ) ;				      	int m_new = 2 * ( y2 - y1 ) ;				      int m_new = 2 * ( y2 - y1 ) ;				  
  int slope_error_new = m_new - ( x2 - x1 ) ;		      	int slope_error_new = m_new - ( x2 - x1 ) ;		      int slope_error_new = m_new - ( x2 - x1 ) ;		  
  for ( int x = x1 , y = y1 ;				      	for ( int x = x1 , y = y1 ;				      for ( int x = x1 , y = y1 ;				  
  x <= x2 ;						      	x <= x2 ;						      x <= x2 ;							  
  x ++ ) {						      	x ++ ) {						      x ++ ) {							  
    System . out . print ( "(" + x + "," + y + ")\n" ) ;      	  cout << "(" << x << "," << y << ")\n" ;		    	cout << "(" << x << "," << y << ")\n" ;			  
    slope_error_new += m_new ;				      	  slope_error_new += m_new ;				    	slope_error_new += m_new ;				  
    if ( slope_error_new >= 0 ) {			      	  if ( slope_error_new >= 0 ) {				    	if ( slope_error_new >= 0 ) {				  
      y ++ ;						      	    y ++ ;						    	  y ++ ;						  
      slope_error_new -= 2 * ( x2 - x1 ) ;		      	    slope_error_new -= 2 * ( x2 - x1 ) ;		    	  slope_error_new -= 2 * ( x2 - x1 ) ;			  
    }							      	  }							    	}							  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_BRACKET_NUMBER					      PRINT_BRACKET_NUMBER					    PRINT_BRACKET_NUMBER					  PRINT_BRACKET_NUMBER
--							      --							    --								  --
static void printBracketNumber ( String exp , int n ) {	      void printBracketNumber ( string exp , int n ) {		    void printBracketNumber ( string exp , int n ) {		  script_not_found : None
  int left_bnum = 1 ;					      	int left_bnum = 1 ;					      int leftBnum = 1 ;					  
  Stack < Integer > right_bnum = new Stack < Integer > ( ) ;  	stack < int > right_bnum ;				      stack < int > rightBnum ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( exp . charAt ( i ) == '(' ) {			      	  if ( exp [ i ] == '(' ) {				    	if ( exp [ i ] == '(' ) {				  
      System . out . print ( left_bnum + " " ) ;	      	    cout << left_bnum << " " ;				    	  cout << leftBnum << " " ;				  
      right_bnum . push ( left_bnum ) ;			      	    right_bnum . push ( left_bnum ) ;			    	  rightBnum . push ( leftBnum ) ;			  
      left_bnum ++ ;					      	    left_bnum ++ ;					    	  leftBnum ++ ;						  
    }							      	  }							    	}							  
    else if ( exp . charAt ( i ) == ')' ) {		      	  else if ( exp [ i ] == ')' ) {			    	else if ( exp [ i ] == ')' ) {				  
      System . out . print ( right_bnum . peek ( ) + " " ) ;  	    cout << right_bnum . top ( ) << " " ;		    	  cout << rightBnum . top ( ) << " " ;			  
      right_bnum . pop ( ) ;				      	    right_bnum . pop ( ) ;				    	  rightBnum . pop ( ) ;					  
    }							      	  }							    	}							  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1			      MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1			    MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1			  MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1
--							      --							    --								  --
public static int calculateEnergy ( int mat [ ] [ ] , int n ) int calculateEnergy ( int mat [ SIZE ] [ SIZE ] , int n ) {   int calculateEnergy ( int mat [ ] [ 2 ] , int n ) {		  script_not_found : None
  int i_des , j_des , q ;				      	int i_des , j_des , q ;					      int i_des , j_des , q ;					  
  int tot_energy = 0 ;					      	int tot_energy = 0 ;					      int tot_energy = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      q = mat [ i ] [ j ] / n ;				      	    q = mat [ i ] [ j ] / n ;				    	  q = mat [ i ] [ j ] / n ;				  
      i_des = q ;					      	    i_des = q ;						    	  i_des = q ;						  
      j_des = mat [ i ] [ j ] - ( n * q ) ;		      	    j_des = mat [ i ] [ j ] - ( n * q ) ;		    	  j_des = mat [ i ] [ j ] - ( n * q ) ;			  
      tot_energy += Math . abs ( i_des - i ) + Math . abs ( j 	    tot_energy += abs ( i_des - i ) + abs ( j_des - j ) ;   	  tot_energy += abs ( i_des - i ) + abs ( j_des - j ) ;	  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return tot_energy ;					      	return tot_energy ;					      return tot_energy ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME		      COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME			    COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME			  COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME
--							      --							    --								  --
static int count ( int n ) {				      int count ( int n ) {					    int count ( int n ) {					  success : None
  int table [ ] = new int [ n + 1 ] , i ;		      	int table [ n + 1 ] , i ;				      int table [ n + 1 ] , i ;					  
  Arrays . fill ( table , 0 ) ;				      	for ( int j = 0 ;					      memset ( table , 0 , sizeof ( table ) ) ;			  
  table [ 0 ] = 1 ;					      	j < n + 1 ;						      table [ 0 ] = 1 ;						  
  for ( i = 3 ;						      	j ++ ) table [ j ] = 0 ;				      for ( i = 3 ;						  
  i <= n ;						      	table [ 0 ] = 1 ;					      i <= n ;							  
  i ++ ) table [ i ] += table [ i - 3 ] ;		      	for ( i = 3 ;						      i ++ ) {							  
  for ( i = 5 ;						      	i <= n ;						    	table [ i ] += table [ i - 3 ] ;			  
  i <= n ;						      	i ++ ) table [ i ] += table [ i - 3 ] ;			      }								  
  i ++ ) table [ i ] += table [ i - 5 ] ;		      	for ( i = 5 ;						      for ( i = 5 ;						  
  for ( i = 10 ;					      	i <= n ;						      i <= n ;							  
  i <= n ;						      	i ++ ) table [ i ] += table [ i - 5 ] ;			      i ++ ) {							  
  i ++ ) table [ i ] += table [ i - 10 ] ;		      	for ( i = 10 ;						    	table [ i ] += table [ i - 5 ] ;			  
  return table [ n ] ;					      	i <= n ;						      }								  
}							      	i ++ ) table [ i ] += table [ i - 10 ] ;		      for ( i = 10 ;						  
							      	return table [ n ] ;					      i <= n ;							  
							      }								      i ++ ) {							  
							      								    	table [ i ] += table [ i - 10 ] ;			  
							      								      }								  
							      								      return table [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY  DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY  DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY  DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY
--							      --							    --								  --
static int findDiff ( int arr [ ] , int n ) {		      int findDiff ( int arr [ ] , int n ) {			    int findDiff ( int arr [ ] , int n ) {			  success : identical to gold
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  int count = 0 , max_count = 0 , min_count = n ;	      	int count = 0 , max_count = 0 , min_count = n ;		      int count = 0 , max_count = 0 , min_count = n ;		  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < ( n - 1 ) ;					      	i < ( n - 1 ) ;						      i < ( n - 1 ) ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] == arr [ i + 1 ] ) {			      	  if ( arr [ i ] == arr [ i + 1 ] ) {			    	if ( arr [ i ] == arr [ i + 1 ] ) {			  
      count += 1 ;					      	    count += 1 ;					    	  count += 1 ;						  
      continue ;					      	    continue ;						    	  continue ;						  
    }							      	  }							    	}							  
    else {						      	  else {						    	else {							  
      max_count = Math . max ( max_count , count ) ;	      	    max_count = max ( max_count , count ) ;		    	  max_count = max ( max_count , count ) ;		  
      min_count = Math . min ( min_count , count ) ;	      	    min_count = min ( min_count , count ) ;		    	  min_count = min ( min_count , count ) ;		  
      count = 0 ;					      	    count = 0 ;						    	  count = 0 ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return ( max_count - min_count ) ;			      	return ( max_count - min_count ) ;			      return ( max_count - min_count ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE			      CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE			    CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE			  CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE
--							      --							    --								  --
boolean areConsecutive ( int arr [ ] , int n ) {	      bool areConsecutive ( int arr [ ] , int n ) {		    bool areConsecutive ( int arr [ ] , int n ) {		  script_not_found : None
  if ( n < 1 ) return false ;				      	if ( n < 1 ) return false ;				      if ( n < 1 ) return false ;				  
  int min = getMin ( arr , n ) ;			      	int min = getMin ( arr , n ) ;				      int min = getMin ( arr , n ) ;				  
  int max = getMax ( arr , n ) ;			      	int max = getMax ( arr , n ) ;				      int max = getMax ( arr , n ) ;				  
  if ( max - min + 1 == n ) {				      	if ( max - min + 1 == n ) {				      if ( max - min + 1 == n ) {				  
    boolean visited [ ] = new boolean [ n ] ;		      	  bool * visited = ( bool * ) calloc ( n , sizeof ( bool )  	bool visited [ n ] ;					  
    int i ;						      	  int i ;						    	int i ;							  
    for ( i = 0 ;					      	  for ( i = 0 ;						    	for ( i = 0 ;						  
    i < n ;						      	  i < n ;						    	i < n ;							  
    i ++ ) {						      	  i ++ ) {						    	i ++ ) {						  
      if ( visited [ arr [ i ] - min ] != false ) return fals 	    if ( visited [ arr [ i ] - min ] != false ) return fals 	  if ( visited [ arr [ i ] - min ] != false ) return fals 
      visited [ arr [ i ] - min ] = true ;		      	    visited [ arr [ i ] - min ] = true ;		    	  visited [ arr [ i ] - min ] = true ;			  
    }							      	  }							    	}							  
    return true ;					      	  return true ;						    	return true ;						  
  }							      	}							      }								  
  return false ;					      	return false ;						      return false ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHIFT_MATRIX_ELEMENTS_K					      SHIFT_MATRIX_ELEMENTS_K					    SHIFT_MATRIX_ELEMENTS_K					  SHIFT_MATRIX_ELEMENTS_K
--							      --							    --								  --
static void shiftMatrixByK ( int [ ] [ ] mat , int k ) {      void shiftMatrixByK ( int mat [ N ] [ N ] , int k ) {	    void shiftMatrixByK ( int * * mat , int k ) {		  script_not_found : None
  if ( k > N ) {					      	if ( k > N ) {						      if ( k > N ) {						  
    System . out . print ( "Shifting is" + " not possible" )  	  cout << "shifting is not possible" << endl ;		    	cout << "Shifting is" << " not possible" << endl ;	  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  int j = 0 ;						      	int j = 0 ;						      int j = 0 ;						  
  while ( j < N ) {					      	while ( j < N ) {					      while ( j < N ) {						  
    for ( int i = k ;					      	  for ( int i = k ;					    	for ( int i = k ;					  
    i < N ;						      	  i < N ;						    	i < N ;							  
    i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ;   	  i ++ ) cout << mat [ j ] [ i ] << " " ;		    	i ++ ) {						  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					    	  cout << mat [ j ] [ i ] << " " ;			  
    i < k ;						      	  i < k ;						    	}							  
    i ++ ) System . out . print ( mat [ j ] [ i ] + " " ) ;   	  i ++ ) cout << mat [ j ] [ i ] << " " ;		    	for ( int i = 0 ;					  
    System . out . println ( ) ;			      	  cout << endl ;					    	i < k ;							  
    j ++ ;						      	  j ++ ;						    	i ++ ) {						  
  }							      	}							    	  cout << mat [ j ] [ i ] << " " ;			  
}							      }								    	}							  
							      								    	cout << endl ;						  
							      								    	j ++ ;							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1	      COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1		    COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1		  COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1
--							      --							    --								  --
int getInvCount ( int arr [ ] , int n ) {		      int getInvCount ( int arr [ ] , int n ) {			    int getInvCount ( int arr [ ] , int n ) {			  success : None
  int invcount = 0 ;					      	int invcount = 0 ;					      int invcount = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 1 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int small = 0 ;					      	  int small = 0 ;					    	int small = 0 ;						  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ;	      	  j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ;	    	j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ;		  
    int great = 0 ;					      	  int great = 0 ;					    	int great = 0 ;						  
    for ( int j = i - 1 ;				      	  for ( int j = i - 1 ;					    	for ( int j = i - 1 ;					  
    j >= 0 ;						      	  j >= 0 ;						    	j >= 0 ;						  
    j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ;	      	  j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ;	    	j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ;		  
    invcount += great * small ;				      	  invcount += great * small ;				    	invcount += great * small ;				  
  }							      	}							      }								  
  return invcount ;					      	return invcount ;					      return invcount ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_ COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_ COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_ COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_
--							      --							    --								  --
private static void findCount ( int n , int sum ) {	      void findCount ( int n , int sum ) {			    static void findCount ( int n , int sum ) {			  script_not_found : None
  int start = ( int ) Math . pow ( 10 , n - 1 ) ;	      	int start = pow ( 10 , n - 1 ) ;			      int start = ( int ) pow ( 10 , n - 1 ) ;			  
  int end = ( int ) Math . pow ( 10 , n ) - 1 ;		      	int end = pow ( 10 , n ) - 1 ;				      int end = ( int ) pow ( 10 , n ) - 1 ;			  
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  int i = start ;					      	int i = start ;						      int i = start ;						  
  while ( i < end ) {					      	while ( i <= end ) {					      while ( i < end ) {					  
    int cur = 0 ;					      	  int cur = 0 ;						    	int cur = 0 ;						  
    int temp = i ;					      	  int temp = i ;					    	int temp = i ;						  
    while ( temp != 0 ) {				      	  while ( temp != 0 ) {					    	while ( temp != 0 ) {					  
      cur += temp % 10 ;				      	    cur += temp % 10 ;					    	  cur += temp % 10 ;					  
      temp = temp / 10 ;				      	    temp = temp / 10 ;					    	  temp = temp / 10 ;					  
    }							      	  }							    	}							  
    if ( cur == sum ) {					      	  if ( cur == sum ) {					    	if ( cur == sum ) {					  
      count ++ ;					      	    count ++ ;						    	  count ++ ;						  
      i += 9 ;						      	    i += 9 ;						    	  i += 9 ;						  
    }							      	  }							    	}							  
    else i ++ ;						      	  else i ++ ;						    	else {							  
  }							      	}							    	  i ++ ;						  
  System . out . println ( count ) ;			      	cout << count ;						    	}							  
}							      }								      }								  
							      								      cout << count << endl ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA
--							      --							    --								  --
public static String noAdjacentDup ( String s1 ) {	      string noAdjacentDup ( string s ) {			    string noAdjacentDup ( string s1 ) {			  error : PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTA
  int n = s1 . length ( ) ;				      	int n = s . length ( ) ;				      int n = s1 . length ( ) ;					  IN_ADJACENT_DUPLICATES.cpp: In function ‘std::__cx
  char [ ] s = s1 . toCharArray ( ) ;			      	for ( int i = 1 ;					      string :: size_type pos = 0 ;				  x11::string f_filled(std::__cxx11::string)’: PRINT
  for ( int i = 1 ;					      	i < n ;							      for ( int i = 1 ;						  _A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_D
  i < n ;						      	i ++ ) {						      i < n ;							  UPLICATES.cpp:37:10: error: ‘s’ was not declared i
  i ++ ) {						      	  if ( s [ i ] == s [ i - 1 ] ) {			      i ++ ) {							  n this scope	    if ( s [ pos ] == s [ pos - 1 ]
    if ( s [ i ] == s [ i - 1 ] ) {			      	    s [ i ] = 'a' ;					    	if ( s [ pos ] == s [ pos - 1 ] ) {			  ) {		^ PRINT_A_CLOSEST_STRING_THAT_DOES_N
      s [ i ] = 'a' ;					      	    while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i  	  s [ pos ] = 'a' ;					  OT_CONTAIN_ADJACENT_DUPLICATES.cpp:45:21: error: ‘
      while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i  	    i ++ ;						    	  while ( s [ pos ] == s [ pos - 1 ] || ( pos + 1 < n &&  s’ was not declared in this scope    return ( stri
      i ++ ;						      	  }							    	    pos ++ ;						  ng ( s , pos ) ) ;			  ^
    }							      	}							    	  }							  
  }							      	return s ;						    	  pos ++ ;						  
  return ( new String ( s ) ) ;				      }								    	}							  
}							      								      }								  
							      								      return ( string ( s , pos ) ) ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_SPECIFIC_PAIR_IN_MATRIX				      FIND_A_SPECIFIC_PAIR_IN_MATRIX				    FIND_A_SPECIFIC_PAIR_IN_MATRIX				  FIND_A_SPECIFIC_PAIR_IN_MATRIX
--							      --							    --								  --
static int findMaxValue ( int N , int mat [ ] [ ] ) {	      int findMaxValue ( int mat [ ] [ N ] ) {			    int findMaxValue ( int N , int mat [ ] [ N ] ) {		  script_not_found : None
  int maxValue = Integer . MIN_VALUE ;			      	int maxValue = INT_MIN ;				      int maxValue = INT_MIN ;					  
  for ( int a = 0 ;					      	for ( int a = 0 ;					      for ( int a = 0 ;						  
  a < N - 1 ;						      	a < N - 1 ;						      a < N - 1 ;						  
  a ++ ) for ( int b = 0 ;				      	a ++ ) for ( int b = 0 ;				      a ++ ) for ( int b = 0 ;					  
  b < N - 1 ;						      	b < N - 1 ;						      b < N - 1 ;						  
  b ++ ) for ( int d = a + 1 ;				      	b ++ ) for ( int d = a + 1 ;				      b ++ ) for ( int d = a + 1 ;				  
  d < N ;						      	d < N ;							      d < N ;							  
  d ++ ) for ( int e = b + 1 ;				      	d ++ ) for ( int e = b + 1 ;				      d ++ ) for ( int e = b + 1 ;				  
  e < N ;						      	e < N ;							      e < N ;							  
  e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ]  	e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ]    e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ]  
  return maxValue ;					      	return maxValue ;					      return maxValue ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED		      MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED		    MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED		  MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED
--							      --							    --								  --
static void segregateElements ( int arr [ ] , int n ) {	      void segregateElements ( int arr [ ] , int n ) {		    void segregateElements ( int arr [ ] , int n ) {		  script_not_found : None
  int temp [ ] = new int [ n ] ;			      	int temp [ n ] ;					      int temp [ n ] ;						  
  int j = 0 ;						      	int j = 0 ;						      int j = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ;    	i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ;      i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ;	  
  if ( j == n || j == 0 ) return ;			      	if ( j == n || j == 0 ) return ;			      if ( j == n || j == 0 ) return ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ;     	i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ;	      i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ;	  
  for ( int i = 0 ;					      	memcpy ( arr , temp , sizeof ( temp ) ) ;		      for ( int i = 0 ;						  
  i < n ;						      }								      i < n ;							  
  i ++ ) arr [ i ] = temp [ i ] ;			      								      i ++ ) arr [ i ] = temp [ i ] ;				  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SIZE_SUBARRAY_MAXIMUM_SUM				      SIZE_SUBARRAY_MAXIMUM_SUM					    SIZE_SUBARRAY_MAXIMUM_SUM					  SIZE_SUBARRAY_MAXIMUM_SUM
--							      --							    --								  --
static int maxSubArraySum ( int a [ ] , int size ) {	      int maxSubArraySum ( int a [ ] , int size ) {		    int maxSubArraySum ( int a [ ] , int size ) {		  failure : #Results: 2, 10
  int max_so_far = Integer . MIN_VALUE , max_ending_here = 0  	int max_so_far = INT_MIN , max_ending_here = 0 , start = 0    int max_so_far = INT_MAX , max_ending_here = 0 , start = 0  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < size ;						      	i < size ;						      i < size ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    max_ending_here += a [ i ] ;			      	  max_ending_here += a [ i ] ;				    	max_ending_here += a [ i ] ;				  
    if ( max_so_far < max_ending_here ) {		      	  if ( max_so_far < max_ending_here ) {			    	if ( max_so_far < max_ending_here ) {			  
      max_so_far = max_ending_here ;			      	    max_so_far = max_ending_here ;			    	  max_so_far = max_ending_here ;			  
      start = s ;					      	    start = s ;						    	  start = s ;						  
      end = i ;						      	    end = i ;						    	  end = i ;						  
    }							      	  }							    	}							  
    if ( max_ending_here < 0 ) {			      	  if ( max_ending_here < 0 ) {				    	if ( max_ending_here < 0 ) {				  
      max_ending_here = 0 ;				      	    max_ending_here = 0 ;				    	  max_ending_here = 0 ;					  
      s = i + 1 ;					      	    s = i + 1 ;						    	  s = i + 1 ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return ( end - start + 1 ) ;				      	return ( end - start + 1 ) ;				      return ( end - start + 1 ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD
--							      --							    --								  --
static void assign ( int a [ ] , int n ) {		      void assign ( int a [ ] , int n ) {			    void assign ( int a [ ] , int n ) {				  script_not_found : None
  Arrays . sort ( a ) ;					      	sort ( a , a + n ) ;					      sort ( a , a + n ) ;					  
  int ans [ ] = new int [ n ] ;				      	int ans [ n ] ;						      int ans [ n ] ;						  
  int p = 0 , q = n - 1 ;				      	int p = 0 , q = n - 1 ;					      int p = 0 , q = n - 1 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ;	      	  if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ;	    	if ( ( i + 1 ) % 2 == 0 ) {				  
    else ans [ i ] = a [ p ++ ] ;			      	  else ans [ i ] = a [ p ++ ] ;				    	  ans [ i ] = a [ q -- ] ;				  
  }							      	}							    	}							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	else {							  
  i < n ;						      	i < n ;							    	  ans [ i ] = a [ p ++ ] ;				  
  i ++ ) System . out . print ( ans [ i ] + " " ) ;	      	i ++ ) cout << ans [ i ] << " " ;			    	}							  
}							      }								      }								  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) {							  
							      								    	cout << ans [ i ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS		      FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS		    FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS			  FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS
--							      --							    --								  --
static void printFirstRepeating ( int arr [ ] ) {	      void printFirstRepeating ( int arr [ ] , int n ) {	    void printFirstRepeating ( int arr [ ] ) {			  script_not_found : None
  int min = - 1 ;					      	int min = - 1 ;						      int min = - 1 ;						  
  HashSet < Integer > set = new HashSet < > ( ) ;	      	set < int > myset ;					      set < int > set ;						  
  for ( int i = arr . length - 1 ;			      	for ( int i = n - 1 ;					      for ( int i = arr [ arr . size ( ) - 1 ] ;		  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    if ( set . contains ( arr [ i ] ) ) min = i ;	      	  if ( myset . find ( arr [ i ] ) != myset . end ( ) ) min  	if ( set . find ( arr [ i ] ) != set . end ( ) ) {	  
    else set . add ( arr [ i ] ) ;			      	  else myset . insert ( arr [ i ] ) ;			    	  min = i ;						  
  }							      	}							    	}							  
  if ( min != - 1 ) System . out . println ( "The first repea 	if ( min != - 1 ) cout << "The first repeating element is " 	else {							  
  else System . out . println ( "There are no repeating eleme 	else cout << "There are no repeating elements" ;	    	  set . insert ( arr [ i ] ) ;				  
}							      }								    	}							  
							      								      }								  
							      								      if ( min != - 1 ) {					  
							      								    	cout << "The first repeating element is " << arr [ min ]  
							      								      }								  
							      								      else {							  
							      								    	cout << "There are no repeating elements" << endl ;	  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES      PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES	    PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES	  PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES
--							      --							    --								  --
static void printString ( String str , char ch , int count )  void printString ( string str , char ch , int count ) {	    void print_string ( string str , char ch , int count ) {	  script_not_found : None
  int occ = 0 , i ;					      	int occ = 0 , i ;					      int occ = 0 , i ;						  
  if ( count == 0 ) {					      	if ( count == 0 ) {					      if ( count == 0 ) {					  
    System . out . println ( str ) ;			      	  cout << str ;						    	cout << str << endl ;					  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < str . length ( ) ;				      	i < str . length ( ) ;					      i < str . length ( ) ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( str . charAt ( i ) == ch ) occ ++ ;		      	  if ( str [ i ] == ch ) occ ++ ;			    	if ( str [ i ] == ch ) {				  
    if ( occ == count ) break ;				      	  if ( occ == count ) break ;				    	  occ ++ ;						  
  }							      	}							    	}							  
  if ( i < str . length ( ) - 1 ) System . out . println ( st 	if ( i < str . length ( ) - 1 ) cout << str . substr ( i +  	if ( occ == count ) {					  
  else System . out . println ( "Empty string" ) ;	      	else cout << "Empty string" ;				    	  break ;						  
}							      }								    	}							  
							      								      }								  
							      								      if ( i < str . length ( ) - 1 ) {				  
							      								    	cout << str . substr ( i + 1 ) << endl ;		  
							      								      }								  
							      								      else {							  
							      								    	cout << "Empty string" << endl ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3	  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3
--							      --							    --								  --
static int findLength ( String str , int n ) {		      int findLength ( string str , int n ) {			    int findLength ( string str , int n ) {			  script_not_found : None
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n - 2 ;						      	i <= n - 2 ;						      i <= n - 2 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int l = i , r = i + 1 ;				      	  int l = i , r = i + 1 ;				    	int l = i , r = i + 1 ;					  
    int lsum = 0 , rsum = 0 ;				      	  int lsum = 0 , rsum = 0 ;				    	int lsum = 0 , rsum = 0 ;				  
    while ( r < n && l >= 0 ) {				      	  while ( r < n && l >= 0 ) {				    	while ( r < n && l >= 0 ) {				  
      lsum += str . charAt ( l ) - '0' ;		      	    lsum += str [ l ] - '0' ;				    	  lsum += str [ l ] - '0' ;				  
      rsum += str . charAt ( r ) - '0' ;		      	    rsum += str [ r ] - '0' ;				    	  rsum += str [ r ] - '0' ;				  
      if ( lsum == rsum ) {				      	    if ( lsum == rsum ) ans = max ( ans , r - l + 1 ) ;	    	  if ( lsum == rsum ) ans = max ( ans , r - l + 1 ) ;	  
	ans = Math . max ( ans , r - l + 1 ) ;		      	    l -- ;						    	  l -- ;						  
      }							      	    r ++ ;						    	  r ++ ;						  
      l -- ;						      	  }							    	}							  
      r ++ ;						      	}							      }								  
    }							      	return ans ;						      return ans ;						  
  }							      }								    }								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_INCREASING_SUBSEQUENCE_1			      LONGEST_INCREASING_SUBSEQUENCE_1				    LONGEST_INCREASING_SUBSEQUENCE_1				  LONGEST_INCREASING_SUBSEQUENCE_1
--							      --							    --								  --
static int lis ( int arr [ ] , int n ) {		      int lis ( int arr [ ] , int n ) {				    int lis ( int arr [ ] , int n ) {				  success : None
  int lis [ ] = new int [ n ] ;				      	int lis [ n ] ;						      int lis [ n ] ;						  
  int i , j , max = 0 ;					      	lis [ 0 ] = 1 ;						      int i , j , max = 0 ;					  
  for ( i = 0 ;						      	for ( int i = 1 ;					      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) lis [ i ] = 1 ;				      	i ++ ) {						      i ++ ) {							  
  for ( i = 1 ;						      	  lis [ i ] = 1 ;					    	lis [ i ] = 1 ;						  
  i < n ;						      	  for ( int j = 0 ;					      }								  
  i ++ ) for ( j = 0 ;					      	  j < i ;						      for ( i = 1 ;						  
  j < i ;						      	  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j    i < n ;							  
  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ]  	}							      i ++ ) for ( j = 0 ;					  
  for ( i = 0 ;						      	return * max_element ( lis , lis + n ) ;		      j < i ;							  
  i < n ;						      }								      j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ]  
  i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;	      								      for ( i = 0 ;						  
  return max ;						      								      i < n ;							  
}							      								      i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;		  
							      								      return max ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_EVEN_FACTORS_NUMBER				      FIND_SUM_EVEN_FACTORS_NUMBER				    FIND_SUM_EVEN_FACTORS_NUMBER				  FIND_SUM_EVEN_FACTORS_NUMBER
--							      --							    --								  --
public static int sumofFactors ( int n ) {		      int sumofFactors ( int n ) {				    int sumof_factors ( int n ) {				  success : None
  if ( n % 2 != 0 ) return 0 ;				      	if ( n % 2 != 0 ) return 0 ;				      if ( n % 2 != 0 ) return 0 ;				  
  int res = 1 ;						      	int res = 1 ;						      int res = 1 ;						  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= Math . sqrt ( n ) ;				      	i <= sqrt ( n ) ;					      i <= sqrt ( n ) ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int count = 0 , curr_sum = 1 ;			      	  int count = 0 , curr_sum = 1 , curr_term = 1 ;	    	int count = 0 , curr_sum = 1 ;				  
    int curr_term = 1 ;					      	  while ( n % i == 0 ) {				    	int curr_term = 1 ;					  
    while ( n % i == 0 ) {				      	    count ++ ;						    	while ( n % i == 0 ) {					  
      count ++ ;					      	    n = n / i ;						    	  count ++ ;						  
      n = n / i ;					      	    if ( i == 2 && count == 1 ) curr_sum = 0 ;		    	  n = n / i ;						  
      if ( i == 2 && count == 1 ) curr_sum = 0 ;	      	    curr_term *= i ;					    	  if ( i == 2 && count == 1 ) curr_sum = 0 ;		  
      curr_term *= i ;					      	    curr_sum += curr_term ;				    	  curr_term *= i ;					  
      curr_sum += curr_term ;				      	  }							    	  curr_sum += curr_term ;				  
    }							      	  res *= curr_sum ;					    	}							  
    res *= curr_sum ;					      	}							    	res *= curr_sum ;					  
  }							      	if ( n >= 2 ) res *= ( 1 + n ) ;			      }								  
  if ( n >= 2 ) res *= ( 1 + n ) ;			      	return res ;						      if ( n >= 2 ) res *= ( 1 + n ) ;				  
  return res ;						      }								      return res ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS	      MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS		    MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS		  MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS
--							      --							    --								  --
static int maxSum ( int arr [ ] , int N , int k ) {	      int maxSum ( int arr [ ] , int N , int k ) {		    int maxSum ( int arr [ ] , int N , int k ) {		  success : None
  int MS [ ] = new int [ N ] ;				      	int MS [ N ] ;						      int MS [ N ] ;						  
  MS [ N - 1 ] = arr [ N - 1 ] ;			      	MS [ N - 1 ] = arr [ N - 1 ] ;				      MS [ N - 1 ] = arr [ N - 1 ] ;				  
  for ( int i = N - 2 ;					      	for ( int i = N - 2 ;					      for ( int i = N - 2 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    if ( i + k + 1 >= N ) MS [ i ] = Math . max ( arr [ i ] , 	  if ( i + k + 1 >= N ) MS [ i ] = max ( arr [ i ] , MS [ i 	if ( i + k + 1 >= N ) {					  
    else MS [ i ] = Math . max ( arr [ i ] + MS [ i + k + 1 ] 	  else MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ 	  MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) ;		  
  }							      	}							    	}							  
  return MS [ 0 ] ;					      	return MS [ 0 ] ;					    	else {							  
}							      }								    	  MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i  
							      								    	}							  
							      								      }								  
							      								      return MS [ 0 ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1		      FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1		    FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1			  FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1
--							      --							    --								  --
static int findMaxAverage ( int arr [ ] , int n , int k ) {   int findMaxAverage ( int arr [ ] , int n , int k ) {	    int findMaxAverage ( int arr [ ] , int n , int k ) {	  failure : #Results: 9, 10
  if ( k > n ) return - 1 ;				      	if ( k > n ) return - 1 ;				      if ( k > n ) return - 1 ;					  
  int sum = arr [ 0 ] ;					      	int sum = arr [ 0 ] ;					      int sum = arr [ 0 ] ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < k ;						      	i < k ;							      i < k ;							  
  i ++ ) sum += arr [ i ] ;				      	i ++ ) sum += arr [ i ] ;				      i ++ ) {							  
  int max_sum = sum , max_end = k - 1 ;			      	int max_sum = sum , max_end = k - 1 ;			    	sum += arr [ i ] ;					  
  for ( int i = k ;					      	for ( int i = k ;					      }								  
  i < n ;						      	i < n ;							      int max_sum = sum , max_end = k - 1 ;			  
  i ++ ) {						      	i ++ ) {						      for ( int i = k ;						  
    sum = sum + arr [ i ] - arr [ i - k ] ;		      	  int sum = sum + arr [ i ] - arr [ i - k ] ;		      i < n ;							  
    if ( sum > max_sum ) {				      	  if ( sum > max_sum ) {				      i ++ ) {							  
      max_sum = sum ;					      	    max_sum = sum ;					    	sum = sum + arr [ i ] - arr [ i - k ] ;			  
      max_end = i ;					      	    max_end = i ;					    	if ( sum > max_sum ) {					  
    }							      	  }							    	  max_sum = sum ;					  
  }							      	}							    	  max_end = i ;						  
  return max_end - k + 1 ;				      	return max_end - k + 1 ;				    	}							  
}							      }								      }								  
							      								      return max_end - k + 1 ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE			      FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE			    FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE			  FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE
--							      --							    --								  --
static void findDimen ( int H , int A ) {		      void findDimen ( int H , int A ) {			    void findDimen ( int H , int A ) {				  script_not_found : None
  if ( H * H < 4 * A ) {				      	if ( H * H < 4 * A ) {					      if ( H * H < 4 * A ) {					  
    System . out . println ( "Not Possible" ) ;		      	  cout << "Not Possible\n" ;				    	cout << "Not Possible" << endl ;			  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  double apb = Math . sqrt ( H * H + 4 * A ) ;		      	double apb = sqrt ( H * H + 4 * A ) ;			      double apb = sqrt ( H * H + 4 * A ) ;			  
  double asb = Math . sqrt ( H * H - 4 * A ) ;		      	double asb = sqrt ( H * H - 4 * A ) ;			      double asb = sqrt ( H * H - 4 * A ) ;			  
  System . out . println ( "P = " + Math . round ( ( ( apb -  	cout . precision ( 2 ) ;				      double print = 0 ;					  
  System . out . print ( "B = " + Math . round ( ( ( apb + as 	cout << "P = " << fixed << ( apb - asb ) / 2.0 << "\n" ;      for ( int i = 0 ;						  
}							      	cout << "B = " << ( apb + asb ) / 2.0 ;			      i < H ;							  
							      }								      i ++ ) {							  
							      								    	print += ( ( ( apb - asb ) / 2.0 ) * 100.0 ) / 100.0 ;	  
							      								      }								  
							      								      cout << "P = " << round ( ( ( apb - asb ) / 2.0 ) * 100.0 ) 
							      								      cout << "B = " << round ( ( ( apb + asb ) / 2.0 ) * 100.0 ) 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH		      REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH		    REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH		  REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH
--							      --							    --								  --
static void rearrange ( int arr [ ] , int n ) {		      void GFG :: rearrange ( int arr [ ] , int n ) {		    void rearrange ( int arr [ ] , int n ) {			  script_not_found : None
  int i = - 1 , temp = 0 ;				      	int i = - 1 ;						      int i = - 1 , temp = 0 ;					  
  for ( int j = 0 ;					      	for ( int j = 0 ;					      for ( int j = 0 ;						  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) {						      	j ++ ) {						      j ++ ) {							  
    if ( arr [ j ] < 0 ) {				      	  if ( arr [ j ] < 0 ) {				    	if ( arr [ j ] < 0 ) {					  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
      temp = arr [ i ] ;				      	    swap ( & arr [ i ] , & arr [ j ] ) ;		    	  temp = arr [ i ] ;					  
      arr [ i ] = arr [ j ] ;				      	  }							    	  arr [ i ] = arr [ j ] ;				  
      arr [ j ] = temp ;				      	}							    	  arr [ j ] = temp ;					  
    }							      	int pos = i + 1 , neg = 0 ;				    	}							  
  }							      	while ( pos < n && neg < pos && arr [ neg ] < 0 ) {	      }								  
  int pos = i + 1 , neg = 0 ;				      	  swap ( & arr [ neg ] , & arr [ pos ] ) ;		      int pos = i + 1 , neg = 0 ;				  
  while ( pos < n && neg < pos && arr [ neg ] < 0 ) {	      	  pos ++ ;						      while ( pos < n && neg < pos && arr [ neg ] < 0 ) {	  
    temp = arr [ neg ] ;				      	  neg += 2 ;						    	temp = arr [ neg ] ;					  
    arr [ neg ] = arr [ pos ] ;				      	}							    	arr [ neg ] = arr [ pos ] ;				  
    arr [ pos ] = temp ;				      }								    	arr [ pos ] = temp ;					  
    pos ++ ;						      								    	pos ++ ;						  
    neg += 2 ;						      								    	neg += 2 ;						  
  }							      								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT	      GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT	    GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT	  GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT
--							      --							    --								  --
static void findSymPairs ( int arr [ ] [ ] ) {		      void findSymPairs ( int arr [ ] [ 2 ] , int row ) {	    void findSymPairs ( int arr [ ] [ 2 ] ) {			  script_not_found : None
  HashMap < Integer , Integer > hM = new HashMap < Integer ,  	unordered_map < int , int > hM ;			      unordered_map < int , int > hM ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < arr . length ;					      	i < row ;						      i < sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int first = arr [ i ] [ 0 ] ;			      	  int first = arr [ i ] [ 0 ] ;				    	int first = arr [ i ] [ 0 ] ;				  
    int sec = arr [ i ] [ 1 ] ;				      	  int sec = arr [ i ] [ 1 ] ;				    	int sec = arr [ i ] [ 1 ] ;				  
    Integer val = hM . get ( sec ) ;			      	  if ( hM . find ( sec ) != hM . end ( ) && hM [ sec ] == f 	int val = hM . find ( sec ) ;				  
    if ( val != null && val == first ) System . out . println 	  else hM [ first ] = sec ;				    	if ( val != hM . end ( ) && val == first ) {		  
    else hM . put ( first , sec ) ;			      	}							    	  cout << "(" << sec << ", " << first << ")" << endl ;	  
  }							      }								    	}							  
}							      								    	else {							  
							      								    	  hM [ first ] = sec ;					  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS	      SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS	    SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS		  SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS
--							      --							    --								  --
static int findSmallestDifference ( int A [ ] , int B [ ] , i int findSmallestDifference ( int A [ ] , int B [ ] , int m ,  int findSmallestDifference ( int A [ ] , int B [ ] , int m ,  success : None
  Arrays . sort ( A ) ;					      	sort ( A , A + m ) ;					      sort ( A , A + m ) ;					  
  Arrays . sort ( B ) ;					      	sort ( B , B + n ) ;					      sort ( B , B + n ) ;					  
  int a = 0 , b = 0 ;					      	int a = 0 , b = 0 ;					      int a = 0 , b = 0 ;					  
  int result = Integer . MAX_VALUE ;			      	int result = INT_MAX ;					      int result = INT_MAX ;					  
  while ( a < m && b < n ) {				      	while ( a < m && b < n ) {				      while ( a < m && b < n ) {				  
    if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = 	  if ( abs ( A [ a ] - B [ b ] ) < result ) result = abs (  	if ( abs ( A [ a ] - B [ b ] ) < result ) {		  
    if ( A [ a ] < B [ b ] ) a ++ ;			      	  if ( A [ a ] < B [ b ] ) a ++ ;			    	  result = abs ( A [ a ] - B [ b ] ) ;			  
    else b ++ ;						      	  else b ++ ;						    	}							  
  }							      	}							    	if ( A [ a ] < B [ b ] ) {				  
  return result ;					      	return result ;						    	  a ++ ;						  
}							      }								    	}							  
							      								    	else {							  
							      								    	  b ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STERN_BROCOT_SEQUENCE					      STERN_BROCOT_SEQUENCE					    STERN_BROCOT_SEQUENCE					  STERN_BROCOT_SEQUENCE
--							      --							    --								  --
static void SternSequenceFunc ( Vector < Integer > BrocotSequ void SternSequenceFunc ( vector < int > & BrocotSequence , in void SternSequenceFunc ( Vector < int > BrocotSequence , int  script_not_found : None
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  BrocotSequence . size ( ) < n ;			      	BrocotSequence . size ( ) < n ;				      BrocotSequence . size ( ) < n ;				  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int considered_element = BrocotSequence . get ( i ) ;     	  int considered_element = BrocotSequence [ i ] ;	    	int considered_element = BrocotSequence [ i ] ;		  
    int precedent = BrocotSequence . get ( i - 1 ) ;	      	  int precedent = BrocotSequence [ i - 1 ] ;		    	int precedent = BrocotSequence [ i - 1 ] ;		  
    BrocotSequence . add ( considered_element + precedent ) ; 	  BrocotSequence . push_back ( considered_element + precede 	BrocotSequence . push_back ( considered_element + precede 
    BrocotSequence . add ( considered_element ) ;	      	  BrocotSequence . push_back ( considered_element ) ;	    	BrocotSequence . push_back ( considered_element ) ;	  
  }							      	}							      }								  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < 15 ;						      	i < 15 ;						      i < 15 ;							  
  ++ i ) System . out . print ( BrocotSequence . get ( i ) +  	++ i ) cout << BrocotSequence [ i ] << " " ;		      ++ i ) {							  
}							      }								    	cout << BrocotSequence [ i ] << " " ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS	      NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS	    NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS	  NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS
--							      --							    --								  --
int countTriangle ( int graph [ ] [ ] , boolean isDirected )  int countTriangle ( int graph [ V ] [ V ] , bool isDirected ) int countTriangle ( int graph [ V ] [ V ] , bool isDirected ) script_not_found : None
  int count_Triangle = 0 ;				      	int count_Triangle = 0 ;				      int count_Triangle = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < V ;						      	i < V ;							      i < V ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < V ;						      	  j < V ;						    	j < V ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      for ( int k = 0 ;					      	    for ( int k = 0 ;					    	  for ( int k = 0 ;					  
      k < V ;						      	    k < V ;						    	  k < V ;						  
      k ++ ) {						      	    k ++ ) {						    	  k ++ ) {						  
	if ( graph [ i ] [ j ] == 1 && graph [ j ] [ k ] == 1 	      if ( graph [ i ] [ j ] && graph [ j ] [ k ] && graph  	    if ( graph [ i ] [ j ] == 1 && graph [ j ] [ k ] == 1 
      }							      	    }							    	      count_Triangle ++ ;				  
    }							      	  }							    	    }							  
  }							      	}							    	  }							  
  if ( isDirected == true ) {				      	isDirected ? count_Triangle /= 3 : count_Triangle /= 6 ;    	}							  
    count_Triangle /= 3 ;				      	return count_Triangle ;					      }								  
  }							      }								      if ( isDirected == true ) count_Triangle /= 3 ;		  
  else {						      								      else count_Triangle /= 6 ;				  
    count_Triangle /= 6 ;				      								      return count_Triangle ;					  
  }							      								    }								  
  return count_Triangle ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STEINS_ALGORITHM_FOR_FINDING_GCD			      STEINS_ALGORITHM_FOR_FINDING_GCD				    STEINS_ALGORITHM_FOR_FINDING_GCD				  STEINS_ALGORITHM_FOR_FINDING_GCD
--							      --							    --								  --
static int gcd ( int a , int b ) {			      int gcd ( int a , int b ) {				    int gcd ( int a , int b ) {					  script_not_found : None
  if ( a == 0 ) return b ;				      	if ( a == 0 ) return b ;				      if ( a == 0 ) return b ;					  
  if ( b == 0 ) return a ;				      	if ( b == 0 ) return a ;				      if ( b == 0 ) return a ;					  
  int k ;						      	int k ;							      int k ;							  
  for ( k = 0 ;						      	for ( k = 0 ;						      for ( k = 0 ;						  
  ( ( a | b ) & 1 ) == 0 ;				      	( ( a | b ) && 1 ) == 0 ;				      ( ( a | b ) & 1 ) == 0 ;					  
  ++ k ) {						      	++ k ) {						      ++ k ) {							  
    a >>= 1 ;						      	  a >>= 1 ;						    	a >>= 1 ;						  
    b >>= 1 ;						      	  b >>= 1 ;						    	b >>= 1 ;						  
  }							      	}							      }								  
  while ( ( a & 1 ) == 0 ) a >>= 1 ;			      	while ( ( a > 1 ) == 0 ) a >>= 1 ;			      while ( ( a & 1 ) == 0 ) a >>= 1 ;			  
  do {							      	do {							      do {							  
    while ( ( b & 1 ) == 0 ) b >>= 1 ;			      	  while ( ( b > 1 ) == 0 ) b >>= 1 ;			    	while ( ( b & 1 ) == 0 ) b >>= 1 ;			  
    if ( a > b ) {					      	  if ( a > b ) swap ( a , b ) ;				    	if ( a > b ) {						  
      int temp = a ;					      	  b = ( b - a ) ;					    	  int temp = a ;					  
      a = b ;						      	}							    	  a = b ;						  
      b = temp ;					      	while ( b != 0 ) ;					    	  b = temp ;						  
    }							      	return a << k ;						    	}							  
    b = ( b - a ) ;					      }								    	b = ( b - a ) ;						  
  }							      								      }								  
  while ( b != 0 ) ;					      								      while ( b != 0 ) ;					  
  return a << k ;					      								      return a << k ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A
--							      --							    --								  --
static int findmin ( Point p [ ] , int n ) {		      int findmin ( Point p [ ] , int n ) {			    int findmin ( const Point p [ ] , int n ) {			  script_not_found : None
  int a = 0 , b = 0 , c = 0 , d = 0 ;			      	int a = 0 , b = 0 , c = 0 , d = 0 ;			      int a = 0 , b = 0 , c = 0 , d = 0 ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( p [ i ] . x <= 0 ) a ++ ;			      	  if ( p [ i ] . x <= 0 ) a ++ ;			    	if ( p [ i ] . x <= 0 ) a ++ ;				  
    else if ( p [ i ] . x >= 0 ) b ++ ;			      	  else if ( p [ i ] . x >= 0 ) b ++ ;			    	else if ( p [ i ] . x >= 0 ) b ++ ;			  
    if ( p [ i ] . y >= 0 ) c ++ ;			      	  if ( p [ i ] . y >= 0 ) c ++ ;			    	if ( p [ i ] . y >= 0 ) c ++ ;				  
    else if ( p [ i ] . y <= 0 ) d ++ ;			      	  else if ( p [ i ] . y <= 0 ) d ++ ;			    	else if ( p [ i ] . y <= 0 ) d ++ ;			  
  }							      	}							      }								  
  return Math . min ( Math . min ( a , b ) , Math . min ( c , 	return min ( {						      return min ( min ( a , b ) , min ( c , d ) ) ;		  
}							      	  a , b , c , d }					    }								  
							      	  ) ;							    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1	      PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1	    PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1	  PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1
--							      --							    --								  --
static boolean isProduct ( int arr [ ] , int n , int x ) {    bool isProduct ( int arr [ ] , int n , int x ) {		    bool isProduct ( int arr [ ] , int n , int x ) {		  success : None
  HashSet < Integer > hset = new HashSet < > ( ) ;	      	if ( n < 2 ) return false ;				      set < int > hset ;					  
  if ( n < 2 ) return false ;				      	unordered_set < int > s ;				      if ( n < 2 ) return false ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] == 0 ) {				      	  if ( arr [ i ] == 0 ) {				    	if ( arr [ i ] == 0 ) {					  
      if ( x == 0 ) return true ;			      	    if ( x == 0 ) return true ;				    	  if ( x == 0 ) return true ;				  
      else continue ;					      	    else continue ;					    	  else continue ;					  
    }							      	  }							    	}							  
    if ( x % arr [ i ] == 0 ) {				      	  if ( x % arr [ i ] == 0 ) {				    	if ( x % arr [ i ] == 0 ) {				  
      if ( hset . contains ( x / arr [ i ] ) ) return true ;  	    if ( s . find ( x / arr [ i ] ) != s . end ( ) ) return 	  if ( hset . find ( x / arr [ i ] ) != hset . end ( ) )  
      hset . add ( arr [ i ] ) ;			      	    s . insert ( arr [ i ] ) ;				    	  hset . insert ( arr [ i ] ) ;				  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return false ;					      	return false ;						      return false ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE	      GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE	    GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE	  GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE
--							      --							    --								  --
static void printGrouped ( String str ) {		      void printGrouped ( string str ) {			    void printGrouped ( string str ) {				  script_not_found : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  int count [ ] = new int [ MAX_CHAR ] ;		      	int count [ MAX_CHAR ] = {				      int count [ MAX_CHAR ] ;					  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < n ;						      	  ;							      i < n ;							  
  i ++ ) count [ str . charAt ( i ) - 'a' ] ++ ;	      	  for ( int i = 0 ;					      i ++ ) {							  
  for ( int i = 0 ;					      	  i < n ;						    	count [ str [ i ] - 'a' ] ++ ;				  
  i < n ;						      	  i ++ ) count [ str [ i ] - 'a' ] ++ ;			      }								  
  i ++ ) {						      	  for ( int i = 0 ;					      for ( int i = 0 ;						  
    while ( count [ str . charAt ( i ) - 'a' ] != 0 ) {	      	  i < n ;						      i < n ;							  
      System . out . print ( str . charAt ( i ) ) ;	      	  i ++ ) {						      i ++ ) {							  
      count [ str . charAt ( i ) - 'a' ] -- ;		      	    while ( count [ str [ i ] - 'a' ] -- ) cout << str [ i  	while ( count [ str [ i ] - 'a' ] != 0 ) {		  
    }							      	    count [ str [ i ] - 'a' ] = 0 ;			    	  cout << str [ i ] ;					  
    count [ str . charAt ( i ) - 'a' ] = 0 ;		      	  }							    	  count [ str [ i ] - 'a' ] -- ;			  
  }							      	}							    	}							  
}							      								    	count [ str [ i ] - 'a' ] = 0 ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS		      COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS		    COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS		  COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS
--							      --							    --								  --
static int countNums ( int n , int x , int y ) {	      int countNums ( int n , int x , int y ) {			    int countNums ( int n , int x , int y ) {			  failure : #Results: 3, 10
  boolean [ ] arr = new boolean [ n + 1 ] ;		      	vector < bool > arr ( n + 1 , false ) ;			      bool arr [ n + 1 ] ;					  
  if ( x <= n ) arr [ x ] = true ;			      	if ( x <= n ) arr [ x ] = true ;			      if ( x <= n ) {						  
  if ( y <= n ) arr [ y ] = true ;			      	if ( y <= n ) arr [ y ] = true ;			    	arr [ x ] = true ;					  
  int result = 0 ;					      	int result = 0 ;					      }								  
  for ( int i = Math . min ( x , y ) ;			      	for ( int i = min ( x , y ) ;				      if ( y <= n ) {						  
  i <= n ;						      	i <= n ;						    	arr [ y ] = true ;					  
  i ++ ) {						      	i ++ ) {						      }								  
    if ( arr [ i ] ) {					      	  if ( arr [ i ] ) {					      int result = 0 ;						  
      if ( i + x <= n ) arr [ i + x ] = true ;		      	    if ( i + x <= n ) arr [ i + x ] = true ;		      for ( int i = min ( x , y ) ;				  
      if ( i + y <= n ) arr [ i + y ] = true ;		      	    if ( i + y <= n ) arr [ i + y ] = true ;		      i <= n ;							  
      result ++ ;					      	    result ++ ;						      i ++ ) {							  
    }							      	  }							    	if ( arr [ i ] ) {					  
  }							      	}							    	  if ( i + x <= n ) {					  
  return result ;					      	return result ;						    	    arr [ i + x ] = true ;				  
}							      }								    	  }							  
							      								    	  if ( i + y <= n ) {					  
							      								    	    arr [ i + y ] = true ;				  
							      								    	  }							  
							      								    	  result ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX		      RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX		    RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX		  RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX
--							      --							    --								  --
static StringBuilder findLeft ( StringBuilder str ) {	      string findLeft ( string str ) {				    string findLeft ( string str ) {				  script_not_found : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  while ( n > 0 ) {					      	while ( n -- ) {					      while ( n > 0 ) {						  
    n -- ;						      	  if ( str [ n ] == 'd' ) {				    	n -- ;							  
    if ( str . charAt ( n ) == 'd' ) {			      	    str [ n ] = 'c' ;					    	if ( str [ n ] == 'd' ) {				  
      str . setCharAt ( n , 'c' ) ;			      	    break ;						    	  str [ n ] = 'c' ;					  
      break ;						      	  }							    	  break ;						  
    }							      	  if ( str [ n ] == 'b' ) {				    	}							  
    if ( str . charAt ( n ) == 'b' ) {			      	    str [ n ] = 'a' ;					    	if ( str [ n ] == 'b' ) {				  
      str . setCharAt ( n , 'a' ) ;			      	    break ;						    	  str [ n ] = 'a' ;					  
      break ;						      	  }							    	  break ;						  
    }							      	  if ( str [ n ] == 'a' ) str [ n ] = 'b' ;		    	}							  
    if ( str . charAt ( n ) == 'a' ) str . setCharAt ( n , 'b 	  else if ( str [ n ] == 'c' ) str [ n ] = 'd' ;	    	if ( str [ n ] == 'a' ) {				  
    else if ( str . charAt ( n ) == 'c' ) str . setCharAt ( n 	}							    	  str [ n ] = 'b' ;					  
  }							      	return str ;						    	}							  
  return str ;						      }								    	else if ( str [ n ] == 'c' ) {				  
}							      								    	  str [ n ] = 'd' ;					  
							      								    	}							  
							      								      }								  
							      								      return str ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE			      PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE			    PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE			  PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE
--							      --							    --								  --
static String censor ( String text , String word ) {	      string censor ( string text , string word ) {		    string censor ( string text , string word ) {		  script_not_found : None
  String [ ] word_list = text . split ( "\\s+" ) ;	      	vector < string > word_list ;				      string :: size_type wordPos = text . find ( word ) ;	  
  String result = "" ;					      	boost :: split ( word_list , text , boost :: is_any_of ( "\   string result ;						  
  String stars = "" ;					      	string result = "" ;					      string stars ;						  
  for ( int i = 0 ;					      	string stars = "" ;					      for ( int i = 0 ;						  
  i < word . length ( ) ;				      	for ( int i = 0 ;					      i < word . length ( ) ;					  
  i ++ ) stars += '*' ;					      	i < word . size ( ) ;					      i ++ ) {							  
  int index = 0 ;					      	i ++ ) stars += '*' ;					    	stars += '*' ;						  
  for ( String i : word_list ) {			      	int index = 0 ;						      }								  
    if ( i . compareTo ( word ) == 0 ) word_list [ index ] =  	for ( string i : word_list ) {				      int index = 0 ;						  
    index ++ ;						      	  if ( i . compare ( word ) == 0 ) {			      for ( string :: size_type i = 0 ;				  
  }							      	    word_list [ index ] = stars ;			      i < wordPos ;						  
  for ( String i : word_list ) result += i + ' ' ;	      	  }							      i ++ ) {							  
  return result ;					      	  index ++ ;						    	if ( word . substr ( i , wordPos - i ) == word ) {	  
}							      	}							    	  wordPos = i + 1 ;					  
							      	for ( string i : word_list ) {				    	}							  
							      	  result += i + ' ' ;					    	index ++ ;						  
							      	}							      }								  
							      	return result ;						      for ( string :: size_type i = wordPos ;			  
							      }								      i < wordPos ;						  
							      								      i ++ ) {							  
							      								    	result += word . substr ( i , wordPos - i ) + ' ' ;	  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY	      FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY	    FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY	  FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY
--							      --							    --								  --
static void findPair ( int [ ] arr , int n ) {		      void findPair ( int arr [ ] , int n ) {			    void findPair ( int * arr , int n ) {			  script_not_found : None
  boolean found = false ;				      	bool found = false ;					      bool found = false ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      for ( int k = 0 ;					      	    for ( int k = 0 ;					    	  for ( int k = 0 ;					  
      k < n ;						      	    k < n ;						    	  k < n ;						  
      k ++ ) {						      	    k ++ ) {						    	  k ++ ) {						  
	if ( arr [ i ] + arr [ j ] == arr [ k ] ) {	      	      if ( arr [ i ] + arr [ j ] == arr [ k ] ) {	    	    if ( arr [ i ] + arr [ j ] == arr [ k ] ) {		  
	  System . out . println ( arr [ i ] + " " + arr [ j  		cout << arr [ i ] << " " << arr [ j ] << endl ;	    	      cout << arr [ i ] << " " << arr [ j ] << endl ;	  
	  found = true ;				      		found = true ;					    	      found = true ;					  
	}						      	      }							    	    }							  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
  }							      	}							      }								  
  if ( found == false ) System . out . println ( "Not exist"  	if ( found == false ) cout << "Not exist" << endl ;	      if ( found == false ) {					  
}							      }								    	cout << "Not exist" << endl ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAJORITY_ELEMENT_1					      MAJORITY_ELEMENT_1					    MAJORITY_ELEMENT_1						  MAJORITY_ELEMENT_1
--							      --							    --								  --
private static void findMajority ( int [ ] arr ) {	      void findMajority ( int arr [ ] , int size ) {		    static void findMajority ( int * arr ) {			  script_not_found : None
  HashMap < Integer , Integer > map = new HashMap < Integer , 	unordered_map < int , int > m ;				      unordered_map < int , int > :: iterator it ;		  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( it = arr -> begin ( ) ;				  
  i < arr . length ;					      	i < size ;						      it != arr -> end ( ) ;					  
  i ++ ) {						      	i ++ ) m [ arr [ i ] ] ++ ;				      it ++ ) {							  
    if ( map . containsKey ( arr [ i ] ) ) {		      	int count = 0 ;						    	if ( it -> first == arr -> first ) {			  
      int count = map . get ( arr [ i ] ) + 1 ;		      	for ( auto i : m ) {					    	  int count = it -> second + 1 ;			  
      if ( count > arr . length / 2 ) {			      	  if ( i . second > size / 2 ) {			    	  if ( count > it -> second / 2 ) {			  
	System . out . println ( "Majority found :- " + arr [ 	    count = 1 ;						    	    cout << "Majority found :- " << it -> first << endl ; 
	return ;					      	    cout << "Majority found :- " << i . first << endl ;	    	    return ;						  
      }							      	    break ;						    	  }							  
      else map . put ( arr [ i ] , count ) ;		      	  }							    	  else {						  
    }							      	}							    	    it -> second = count ;				  
    else map . put ( arr [ i ] , 1 ) ;			      	if ( count == 0 ) cout << "No Majority element" << endl ;   	  }							  
  }							      }								    	}							  
  System . out . println ( " No Majority element" ) ;	      								    	else {							  
}							      								    	  it -> second = 1 ;					  
							      								    	}							  
							      								      }								  
							      								      cout << " No Majority element" << endl ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER		      C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER			    C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER			  C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER
--							      --							    --								  --
static char getSecondMostFreq ( String str ) {		      char getSecondMostFreq ( string str ) {			    char getSecondMostFreq ( string str ) {			  script_not_found : None
  int [ ] count = new int [ NO_OF_CHARS ] ;		      	int count [ NO_OF_CHARS ] = {				      vector < int > count ( NO_OF_CHARS , 0 ) ;		  
  int i ;						      	  0 }							      int i ;							  
  for ( i = 0 ;						      	  , i ;							      for ( i = 0 ;						  
  i < str . length ( ) ;				      	  for ( i = 0 ;						      i < str . length ( ) ;					  
  i ++ ) ( count [ str . charAt ( i ) ] ) ++ ;		      	  str [ i ] ;						      i ++ ) {							  
  int first = 0 , second = 0 ;				      	  i ++ ) ( count [ str [ i ] ] ) ++ ;			    	( count [ str [ i ] ] ) ++ ;				  
  for ( i = 0 ;						      	  int first = 0 , second = 0 ;				      }								  
  i < NO_OF_CHARS ;					      	  for ( i = 0 ;						      int first = 0 , second = 0 ;				  
  i ++ ) {						      	  i < NO_OF_CHARS ;					      for ( i = 0 ;						  
    if ( count [ i ] > count [ first ] ) {		      	  i ++ ) {						      i < NO_OF_CHARS ;						  
      second = first ;					      	    if ( count [ i ] > count [ first ] ) {		      i ++ ) {							  
      first = i ;					      	      second = first ;					    	if ( count [ i ] > count [ first ] ) {			  
    }							      	      first = i ;					    	  second = first ;					  
    else if ( count [ i ] > count [ second ] && count [ i ] ! 	    }							    	  first = i ;						  
  }							      	    else if ( count [ i ] > count [ second ] && count [ i ] 	}							  
  return ( char ) second ;				      	  }							    	else if ( count [ i ] > count [ second ] && count [ i ] ! 
}							      	  return second ;					    	  second = i ;						  
							      	}							    	}							  
							      								      }								  
							      								      return ( char ) second ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT		      REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT		    REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT		  REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT
--							      --							    --								  --
static int solve ( int dp [ ] [ ] , int a [ ] , int low , int int solve ( int dp [ ] [ MAX ] , int a [ ] , int low , int hi int solve ( int dp [ ] [ 2 ] , int a [ ] , int low , int high script_not_found : None
  if ( low == high ) {					      	if ( low == high ) return a [ low ] * turn ;		      if ( low == high ) return a [ low ] * turn ;		  
    return a [ low ] * turn ;				      	if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ]    if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ]  
  }							      	dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp ,   dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , 
  if ( dp [ low ] [ high ] != 0 ) {			      	return dp [ low ] [ high ] ;				      return dp [ low ] [ high ] ;				  
    return dp [ low ] [ high ] ;			      }								    }								  
  }							      								    								  
  dp [ low ] [ high ] = Math . max ( a [ low ] * turn + solve 								    								  
  return dp [ low ] [ high ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS		      MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS		    MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS		  MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS
--							      --							    --								  --
static int maximumSum ( int arr [ ] , int n , int k ) {	      int maximumSum ( int arr [ ] , int n , int k ) {		    int maximumSum ( int arr [ ] , int n , int k ) {		  script_not_found : None
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= k ;						      	i <= k ;						      i <= k ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int min = + 2147483647 ;				      	  int min = INT_MAX ;					    	int min = + 2147483647 ;				  
    int index = - 1 ;					      	  int index = - 1 ;					    	int index = - 1 ;					  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( arr [ j ] < min ) {				      	    if ( arr [ j ] < min ) {				    	  if ( arr [ j ] < min ) {				  
	min = arr [ j ] ;				      	      min = arr [ j ] ;					    	    min = arr [ j ] ;					  
	index = j ;					      	      index = j ;					    	    index = j ;						  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
    if ( min == 0 ) break ;				      	  if ( min == 0 ) break ;				    	if ( min == 0 ) break ;					  
    arr [ index ] = - arr [ index ] ;			      	  arr [ index ] = - arr [ index ] ;			    	arr [ index ] = - arr [ index ] ;			  
  }							      	}							      }								  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) sum += arr [ i ] ;				      	i ++ ) sum += arr [ i ] ;				      i ++ ) {							  
  return sum ;						      	return sum ;						    	sum += arr [ i ] ;					  
}							      }								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1		      SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1		    SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1		  SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1
--							      --							    --								  --
static int sumAtKthLevel ( String tree , int k , int level )  int sumAtKthLevel ( string tree , int k , int & i , int level int sumAtKthLevel ( string tree , int k , int level ) {	  script_not_found : None
  if ( tree . charAt ( i ++ ) == '(' ) {		      	if ( tree [ i ++ ] == '(' ) {				      if ( tree [ i ++ ] == '(' ) {				  
    if ( tree . charAt ( i ) == ')' ) return 0 ;	      	  if ( tree [ i ] == ')' ) return 0 ;			    	if ( tree [ i ] == ')' ) return 0 ;			  
    int sum = 0 ;					      	  int sum = 0 ;						    	int sum = 0 ;						  
    if ( level == k ) sum = tree . charAt ( i ) - '0' ;	      	  if ( level == k ) sum = tree [ i ] - '0' ;		    	if ( level == k ) sum = tree [ i ] - '0' ;		  
    ++ i ;						      	  int leftsum = sumAtKthLevel ( tree , k , ++ i , level + 1 	++ i ;							  
    int leftsum = sumAtKthLevel ( tree , k , level + 1 ) ;    	  int rightsum = sumAtKthLevel ( tree , k , ++ i , level +  	int leftsum = sumAtKthLevel ( tree , k , level + 1 ) ;	  
    ++ i ;						      	  ++ i ;						    	++ i ;							  
    int rightsum = sumAtKthLevel ( tree , k , level + 1 ) ;   	  return sum + leftsum + rightsum ;			    	int rightsum = sumAtKthLevel ( tree , k , level + 1 ) ;	  
    ++ i ;						      	}							    	++ i ;							  
    return sum + leftsum + rightsum ;			      }								    	return sum + leftsum + rightsum ;			  
  }							      								      }								  
  return Integer . MIN_VALUE ;				      								      return numeric_limits < int > :: min ( ) ;		  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT		      MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT		    MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT		  MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT
--							      --							    --								  --
public static int maxSum ( int grid [ ] [ ] , int n ) {	      int maxSum ( int grid [ 2 ] [ MAX ] , int n ) {		    int maxSum ( int grid [ ] [ 2 ] , int n ) {			  script_not_found : None
  int incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] 	int incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ;      int incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ;	  
  int excl = 0 , excl_new ;				      	int excl = 0 , excl_new ;				      int excl = 0 , excl_new ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    excl_new = Math . max ( excl , incl ) ;		      	  excl_new = max ( excl , incl ) ;			    	excl_new = max ( excl , incl ) ;			  
    incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ]  	  incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) 	incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) 
    excl = excl_new ;					      	  excl = excl_new ;					    	excl = excl_new ;					  
  }							      	}							      }								  
  return Math . max ( excl , incl ) ;			      	return max ( excl , incl ) ;				      return max ( excl , incl ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY		      MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY			    MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY			  MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY
--							      --							    --								  --
static int findLongestConseqSubseq ( int arr [ ] , int n ) {  int findLongestConseqSubseq ( int arr [ ] , int n ) {	    int findLongestConseqSubseq ( int arr [ ] , int n ) {	  success : None
  HashSet < Integer > S = new HashSet < Integer > ( ) ;	      	unordered_set < int > S ;				      set < int > S ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) S . add ( arr [ i ] ) ;			      	i ++ ) S . insert ( arr [ i ] ) ;			      i ++ ) {							  
  int ans = 0 ;						      	int ans = 0 ;						    	S . insert ( arr [ i ] ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      }								  
  i < n ;						      	i < n ;							      int ans = 0 ;						  
  i ++ ) {						      	i ++ ) {						      for ( int i = 0 ;						  
    if ( S . contains ( arr [ i ] ) ) {			      	  if ( S . find ( arr [ i ] - 1 ) == S . end ( ) ) {	      i < n ;							  
      int j = arr [ i ] ;				      	    int j = arr [ i ] ;					      i ++ ) {							  
      while ( S . contains ( j ) ) j ++ ;		      	    while ( S . find ( j ) != S . end ( ) ) j ++ ;	    	if ( S . find ( arr [ i ] ) != S . end ( ) ) {		  
      ans = Math . max ( ans , j - arr [ i ] ) ;	      	    ans = max ( ans , j - arr [ i ] ) ;			    	  int j = arr [ i ] ;					  
    }							      	  }							    	  while ( S . find ( j ) != S . end ( ) ) {		  
  }							      	}							    	    j ++ ;						  
  return ans ;						      	return ans ;						    	  }							  
}							      }								    	  ans = max ( ans , j - arr [ i ] ) ;			  
							      								    	}							  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C		      LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C		    LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C			  LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C
--							      --							    --								  --
static boolean prevPermutation ( char [ ] str ) {	      bool prevPermutation ( string & str ) {			    bool prevPermutation ( string str ) {			  script_not_found : None
  int n = str . length - 1 ;				      	int n = str . length ( ) - 1 ;				      int n = str . length ( ) - 1 ;				  
  int i = n ;						      	int i = n ;						      int i = n ;						  
  while ( i > 0 && str [ i - 1 ] <= str [ i ] ) {	      	while ( i > 0 && str [ i - 1 ] <= str [ i ] ) i -- ;	      while ( i > 0 && str [ i - 1 ] <= str [ i ] ) i -- ;	  
    i -- ;						      	if ( i <= 0 ) return false ;				      if ( i <= 0 ) return false ;				  
  }							      	int j = i - 1 ;						      int j = i - 1 ;						  
  if ( i <= 0 ) {					      	while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) j ++   while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) j ++ 
    return false ;					      	swap ( str [ i - 1 ] , str [ j ] ) ;			      swap ( str [ i - 1 ] , str [ j ] ) ;			  
  }							      	reverse ( str . begin ( ) + i , str . end ( ) ) ;	      string result = string ( str . begin ( ) , str . end ( ) )  
  int j = i - 1 ;					      	return true ;						      result . reverse ( ) ;					  
  while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) {    }								      str = result ;						  
    j ++ ;						      								      return true ;						  
  }							      								    }								  
  swap ( str , i - 1 , j ) ;				      								    								  
  StringBuilder sb = new StringBuilder ( String . valueOf ( s 								    								  
  sb . reverse ( ) ;					      								    								  
  str = sb . toString ( ) . toCharArray ( ) ;		      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER	      COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER	    COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER	  COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER
--							      --							    --								  --
static int countNumber ( int n ) {			      int countNumber ( int n ) {				    int countNumber ( int n ) {					  success : identical to gold
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= 9 ;						      	i <= 9 ;						      i <= 9 ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    Stack < Integer > s = new Stack < > ( ) ;		      	  stack < int > s ;					    	stack < int > s ;					  
    if ( i <= n ) {					      	  if ( i <= n ) {					    	if ( i <= n ) {						  
      s . push ( i ) ;					      	    s . push ( i ) ;					    	  s . push ( i ) ;					  
      result ++ ;					      	    result ++ ;						    	  result ++ ;						  
    }							      	  }							    	}							  
    while ( ! s . empty ( ) ) {				      	  while ( ! s . empty ( ) ) {				    	while ( ! s . empty ( ) ) {				  
      int tp = s . peek ( ) ;				      	    int tp = s . top ( ) ;				    	  int tp = s . top ( ) ;				  
      s . pop ( ) ;					      	    s . pop ( ) ;					    	  s . pop ( ) ;						  
      for ( int j = tp % 10 ;				      	    for ( int j = tp % 10 ;				    	  for ( int j = tp % 10 ;				  
      j <= 9 ;						      	    j <= 9 ;						    	  j <= 9 ;						  
      j ++ ) {						      	    j ++ ) {						    	  j ++ ) {						  
	int x = tp * 10 + j ;				      	      int x = tp * 10 + j ;				    	    int x = tp * 10 + j ;				  
	if ( x <= n ) {					      	      if ( x <= n ) {					    	    if ( x <= n ) {					  
	  s . push ( x ) ;				      		s . push ( x ) ;				    	      s . push ( x ) ;					  
	  result ++ ;					      		result ++ ;					    	      result ++ ;					  
	}						      	      }							    	    }							  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return result ;					      	return result ;						      return result ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1		      FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1		    FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1			  FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1
--							      --							    --								  --
static int countRotations ( int arr [ ] , int low , int high  int countRotations ( int arr [ ] , int low , int high ) {	    int countRotations ( int arr [ ] , int low , int high ) {	  success : identical to gold
  if ( high < low ) return 0 ;				      	if ( high < low ) return 0 ;				      if ( high < low ) return 0 ;				  
  if ( high == low ) return low ;			      	if ( high == low ) return low ;				      if ( high == low ) return low ;				  
  int mid = low + ( high - low ) / 2 ;			      	int mid = low + ( high - low ) / 2 ;			      int mid = low + ( high - low ) / 2 ;			  
  if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( 	if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return (   if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( 
  if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mi 	if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mi   if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mi 
  if ( arr [ high ] > arr [ mid ] ) return countRotations ( a 	if ( arr [ high ] > arr [ mid ] ) return countRotations ( a   if ( arr [ high ] > arr [ mid ] ) return countRotations ( a 
  return countRotations ( arr , mid + 1 , high ) ;	      	return countRotations ( arr , mid + 1 , high ) ;	      return countRotations ( arr , mid + 1 , high ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN
--							      --							    --								  --
static void printMaxOfMin ( int n ) {			      void printMaxOfMin ( int arr [ ] , int n ) {		    void printMaxOfMin ( int n ) {				  script_not_found : None
  for ( int k = 1 ;					      	for ( int k = 1 ;					      for ( int k = 1 ;						  
  k <= n ;						      	k <= n ;						      k <= n ;							  
  k ++ ) {						      	k ++ ) {						      k ++ ) {							  
    int maxOfMin = Integer . MIN_VALUE ;		      	  int maxOfMin = INT_MIN ;				    	int maxOfMin = INT_MAX ;				  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
    i <= n - k ;					      	  i <= n - k ;						    	i <= n - k ;						  
    i ++ ) {						      	  i ++ ) {						    	i ++ ) {						  
      int min = arr [ i ] ;				      	    int min = arr [ i ] ;				    	  int min = arr [ i ] ;					  
      for ( int j = 1 ;					      	    for ( int j = 1 ;					    	  for ( int j = 1 ;					  
      j < k ;						      	    j < k ;						    	  j < k ;						  
      j ++ ) {						      	    j ++ ) {						    	  j ++ ) {						  
	if ( arr [ i + j ] < min ) min = arr [ i + j ] ;      	      if ( arr [ i + j ] < min ) min = arr [ i + j ] ;	    	    if ( arr [ i + j ] < min ) {			  
      }							      	    }							    	      min = arr [ i + j ] ;				  
      if ( min > maxOfMin ) maxOfMin = min ;		      	    if ( min > maxOfMin ) maxOfMin = min ;		    	    }							  
    }							      	  }							    	  }							  
    System . out . print ( maxOfMin + " " ) ;		      	  cout << maxOfMin << " " ;				    	  if ( min > maxOfMin ) {				  
  }							      	}							    	    maxOfMin = min ;					  
}							      }								    	  }							  
							      								    	}							  
							      								    	cout << maxOfMin << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION		      MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION		    MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION		  MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION
--							      --							    --								  --
static int getMinSteps ( int n ) {			      int getMinSteps ( int n ) {				    int getMinSteps ( int n ) {					  success : None
  int table [ ] = new int [ n + 1 ] ;			      	int table [ n + 1 ] ;					      int table [ n + 1 ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) table [ i ] = n - i ;				      	i ++ ) table [ i ] = n - i ;				      i ++ ) {							  
  for ( int i = n ;					      	for ( int i = n ;					    	table [ i ] = n - i ;					  
  i >= 1 ;						      	i >= 1 ;						      }								  
  i -- ) {						      	i -- ) {						      for ( int i = n ;						  
    if ( ! ( i % 2 > 0 ) ) table [ i / 2 ] = Math . min ( tab 	  if ( ! ( i % 2 ) ) table [ i / 2 ] = min ( table [ i ] +    i >= 1 ;							  
    if ( ! ( i % 3 > 0 ) ) table [ i / 3 ] = Math . min ( tab 	  if ( ! ( i % 3 ) ) table [ i / 3 ] = min ( table [ i ] +    i -- ) {							  
  }							      	}							    	if ( ! ( i % 2 > 0 ) ) {				  
  return table [ 1 ] ;					      	return table [ 1 ] ;					    	  table [ i / 2 ] = min ( table [ i ] + 1 , table [ i / 2 
							      								    	}							  
							      								    	if ( ! ( i % 3 > 0 ) ) {				  
							      								    	  table [ i / 3 ] = min ( table [ i ] + 1 , table [ i / 3 
							      								    	}							  
							      								      }								  
							      								      return table [ 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE		      NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE		    NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE		  NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE
--							      --							    --								  --
static int getNumStrictMonotone ( int len ) {		      int getNumStrictMonotone ( int len ) {			    int getNumStrictMonotone ( int len ) {			  script_not_found : None
  int [ ] [ ] DP = new int [ len ] [ DP_s ] ;		      	int DP [ len ] [ DP_s ] ;				      vector < vector < int >> DP ( len , vector < int > ( DP_s , 
  for ( int i = 0 ;					      	memset ( DP , 0 , sizeof ( DP ) ) ;			      for ( int i = 0 ;						  
  i < DP_s ;						      	for ( int i = 0 ;					      i < DP_s ;						  
  ++ i ) DP [ 0 ] [ i ] = i + 1 ;			      	i < DP_s ;						      ++ i ) {							  
  for ( int i = 1 ;					      	++ i ) DP [ 0 ] [ i ] = i + 1 ;				    	DP [ 0 ] [ i ] = i + 1 ;				  
  i < len ;						      	for ( int i = 1 ;					      }								  
  ++ i ) for ( int j = 1 ;				      	i < len ;						      for ( int i = 1 ;						  
  j < DP_s ;						      	++ i ) for ( int j = 1 ;				      i < len ;							  
  ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ 	j < DP_s ;						      ++ i ) {							  
  return DP [ len - 1 ] [ DP_s - 1 ] ;			      	++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ 	for ( int j = 1 ;					  
}							      	return DP [ len - 1 ] [ DP_s - 1 ] ;			    	j < DP_s ;						  
							      }								    	++ j ) {						  
							      								    	  DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j  
							      								    	}							  
							      								      }								  
							      								      return DP [ len - 1 ] [ DP_s - 1 ] ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_DIVISIBLE_PAIRS_SUBSET				      LARGEST_DIVISIBLE_PAIRS_SUBSET				    LARGEST_DIVISIBLE_PAIRS_SUBSET				  LARGEST_DIVISIBLE_PAIRS_SUBSET
--							      --							    --								  --
static int largestSubset ( int [ ] a , int n ) {	      int largestSubset ( int a [ ] , int n ) {			    int largestSubset ( int * a , int n ) {			  script_not_found : None
  Arrays . sort ( a ) ;					      	sort ( a , a + n ) ;					      sort ( a , a + n ) ;					  
  int [ ] dp = new int [ n ] ;				      	int dp [ n ] ;						      int dp [ n ] ;						  
  dp [ n - 1 ] = 1 ;					      	dp [ n - 1 ] = 1 ;					      dp [ n - 1 ] = 1 ;					  
  for ( int i = n - 2 ;					      	for ( int i = n - 2 ;					      for ( int i = n - 2 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    int mxm = 0 ;					      	  int mxm = 0 ;						    	int mxm = 0 ;						  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) if ( a [ j ] % a [ i ] == 0 ) mxm = max ( mxm , dp 	j ++ ) {						  
      if ( a [ j ] % a [ i ] == 0 ) {			      	  dp [ i ] = 1 + mxm ;					    	  if ( a [ j ] % a [ i ] == 0 ) mxm = max ( mxm , dp [ j  
	mxm = Math . max ( mxm , dp [ j ] ) ;		      	}							    	}							  
      }							      	return * max_element ( dp , dp + n ) ;			    	dp [ i ] = 1 + mxm ;					  
    }							      }								      }								  
    dp [ i ] = 1 + mxm ;				      								      return max ( dp , dp + n ) ;				  
  }							      								    }								  
  return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ;    								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1    DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1    DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1	  DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1
--							      --							    --								  --
static int lis ( int arr [ ] , int n ) {		      int lis ( int arr [ ] , int n ) {				    int lis ( int arr [ ] , int n ) {				  failure : #Results: 9, 10
  int lis [ ] = new int [ n ] ;				      	int lis [ n ] ;						      int lis [ n ] ;						  
  int i , j , max = 0 ;					      	lis [ 0 ] = 1 ;						      int i , j , max = 0 ;					  
  for ( i = 0 ;						      	for ( int i = 1 ;					      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) lis [ i ] = 1 ;				      	i ++ ) {						      i ++ ) {							  
  for ( i = 1 ;						      	  lis [ i ] = 1 ;					    	lis [ i ] = 1 ;						  
  i < n ;						      	  for ( int j = 0 ;					      }								  
  i ++ ) for ( j = 0 ;					      	  j < i ;						      for ( i = 1 ;						  
  j < i ;						      	  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j    i < n ;							  
  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ]  	}							      i ++ ) for ( j = 0 ;					  
  for ( i = 0 ;						      	return * max_element ( lis , lis + n ) ;		      j < i ;							  
  i < n ;						      }								      j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ]  
  i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;	      								      for ( i = 0 ;						  
  return max ;						      								      i < n ;							  
}							      								      i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;		  
							      								      return max ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY		      FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY			    FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY			  FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY
--							      --							    --								  --
static int findSubarraySum ( int [ ] arr , int n ) {	      long long int findSubarraySum ( int arr [ ] , int n ) {	    int findSubarraySum ( int * arr , int n ) {			  success : None
  int res = 0 ;						      	int res = 0 ;						      int res = 0 ;						  
  HashMap < Integer , Integer > m = new HashMap < Integer , I 	unordered_map < int , int > m ;				      unordered_map < int , int > m ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int sum = 0 ;					      	  int sum = 0 ;						    	int sum = 0 ;						  
    for ( int j = i ;					      	  for ( int j = i ;					    	for ( int j = i ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      sum += arr [ j ] ;				      	    sum += arr [ j ] ;					    	  sum += arr [ j ] ;					  
      if ( m . containsKey ( sum ) ) {			      	    m [ sum ] ++ ;					    	  if ( m . find ( sum ) != m . end ( ) ) m [ sum ] = m [  
	m . put ( sum , m . get ( sum ) + 1 ) ;		      	  }							    	  else m [ sum ] = 1 ;					  
      }							      	}							    	}							  
      else {						      	for ( auto x : m ) if ( x . second == 1 ) res += x . first    }								  
	m . put ( sum , 1 ) ;				      	return res ;						      for ( unordered_map < int , int > :: iterator x = m . begin 
      }							      }								      x != m . end ( ) ;					  
    }							      								      x ++ ) if ( x -> second == 1 ) res += x -> first ;	  
  }							      								      return res ;						  
  for ( Map . Entry < Integer , Integer > x : m . entrySet (  								    }								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN
--							      --							    --								  --
static int findMinInsertions ( char str [ ] , int l , int h ) int findMinInsertions ( char str [ ] , int l , int h ) {	    int findMinInsertions ( char str [ ] , int l , int h ) {	  success : identical to gold
  if ( l > h ) return Integer . MAX_VALUE ;		      	if ( l > h ) return INT_MAX ;				      if ( l > h ) return INT_MAX ;				  
  if ( l == h ) return 0 ;				      	if ( l == h ) return 0 ;				      if ( l == h ) return 0 ;					  
  if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 	if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1   if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1 
  return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str 	return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str   return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_ MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_ MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_ MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_
--							      --							    --								  --
static int countManipulations ( String s1 , String s2 ) {     int countManipulations ( string s1 , string s2 ) {	    int countManipulations ( string s1 , string s2 ) {		  script_not_found : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  int char_count [ ] = new int [ 26 ] ;			      	int char_count [ 26 ] ;					      int char_count [ 26 ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < s1 . length ( ) ;					      	i < 26 ;						      i < s1 . length ( ) ;					  
  i ++ ) char_count [ s1 . charAt ( i ) - 'a' ] ++ ;	      	i ++ ) {						      i ++ ) {							  
  for ( int i = 0 ;					      	  char_count [ i ] = 0 ;				    	char_count [ s1 [ i ] - 'a' ] ++ ;			  
  i < s2 . length ( ) ;					      	}							      }								  
  i ++ ) if ( char_count [ s2 . charAt ( i ) - 'a' ] -- <= 0  	for ( int i = 0 ;					      for ( int i = 0 ;						  
  return count ;					      	i < s1 . length ( ) ;					      i < s2 . length ( ) ;					  
}							      	i ++ ) char_count [ s1 [ i ] - 'a' ] ++ ;		      i ++ ) {							  
							      	for ( int i = 0 ;					    	if ( char_count [ s2 [ i ] - 'a' ] -- <= 0 ) {		  
							      	i < s2 . length ( ) ;					    	  count ++ ;						  
							      	i ++ ) {						    	}							  
							      	  char_count [ s2 [ i ] - 'a' ] -- ;			      }								  
							      	  if ( char_count [ s2 [ i ] - 'a' ] < 0 ) count ++ ;	      return count ;						  
							      	}							    }								  
							      	return count ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER	      SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER	    SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER	  SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER
--							      --							    --								  --
public static int sumOfSubstrings ( String num ) {	      int sumOfSubstrings ( string num ) {			    int sumOfSubstrings ( string num ) {			  script_not_found : None
  int n = num . length ( ) ;				      	int n = num . length ( ) ;				      int n = num . length ( ) ;				  
  int sumofdigit [ ] = new int [ n ] ;			      	int sumofdigit [ n ] ;					      int sumofdigit [ n ] ;					  
  sumofdigit [ 0 ] = num . charAt ( 0 ) - '0' ;		      	sumofdigit [ 0 ] = toDigit ( num [ 0 ] ) ;		      sumofdigit [ 0 ] = num [ 0 ] - '0' ;			  
  int res = sumofdigit [ 0 ] ;				      	int res = sumofdigit [ 0 ] ;				      int res = sumofdigit [ 0 ] ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int numi = num . charAt ( i ) - '0' ;		      	  int numi = toDigit ( num [ i ] ) ;			    	int numi = num [ i ] - '0' ;				  
    sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i 	  sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i 	sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i 
    res += sumofdigit [ i ] ;				      	  res += sumofdigit [ i ] ;				    	res += sumofdigit [ i ] ;				  
  }							      	}							      }								  
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2		      FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2		    FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2			  FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2
--							      --							    --								  --
static void printDivisors ( int n ) {			      void printDivisors ( int n ) {				    void printDivisors ( int n ) {				  script_not_found : None
  Vector < Integer > v = new Vector < > ( ) ;		      	vector < int > v ;					      vector < int > v ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= Math . sqrt ( n ) ;				      	i <= sqrt ( n ) ;					      i <= sqrt ( n ) ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( n % i == 0 ) {					      	  if ( n % i == 0 ) {					    	if ( n % i == 0 ) {					  
      if ( n / i == i ) System . out . printf ( "%d " , i ) ; 	    if ( n / i == i ) printf ( "%d " , i ) ;		    	  if ( n / i == i ) {					  
      else {						      	    else {						    	    cout << i << " " ;					  
	System . out . printf ( "%d " , i ) ;		      	      printf ( "%d " , i ) ;				    	  }							  
	v . add ( n / i ) ;				      	      v . push_back ( n / i ) ;				    	  else {						  
      }							      	    }							    	    cout << i << " " ;					  
    }							      	  }							    	    v . push_back ( n / i ) ;				  
  }							      	}							    	  }							  
  for ( int i = v . size ( ) - 1 ;			      	for ( int i = v . size ( ) - 1 ;			    	}							  
  i >= 0 ;						      	i >= 0 ;						      }								  
  i -- ) System . out . printf ( "%d " , v . get ( i ) ) ;    	i -- ) printf ( "%d " , v [ i ] ) ;			      for ( int i = v . size ( ) - 1 ;				  
}							      }								      i >= 0 ;							  
							      								      i -- ) {							  
							      								    	cout << v [ i ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS		      COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS			    COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS			  COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS
--							      --							    --								  --
static long countWays ( int n ) {			      long countWays ( int n ) {				    long long countWays ( int n ) {				  success : None
  long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ;		      	long dp [ 2 ] [ n + 1 ] ;				      long long dp [ 2 ] [ n + 1 ] ;				  
  dp [ 0 ] [ 1 ] = 1 ;					      	dp [ 0 ] [ 1 ] = 1 ;					      dp [ 0 ] [ 1 ] = 1 ;					  
  dp [ 1 ] [ 1 ] = 2 ;					      	dp [ 1 ] [ 1 ] = 2 ;					      dp [ 1 ] [ 1 ] = 2 ;					  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ]  	  dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ]  	dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ]  
    dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i -  	  dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i -  	dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i -  
  }							      	}							      }								  
  return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;		      	return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;		      return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECAMANS_SEQUENCE					      RECAMANS_SEQUENCE						    RECAMANS_SEQUENCE						  RECAMANS_SEQUENCE
--							      --							    --								  --
static void recaman ( int n ) {				      int recaman ( int n ) {					    void recaman ( int n ) {					  script_not_found : None
  int arr [ ] = new int [ n ] ;				      	int arr [ n ] ;						      int arr [ n ] ;						  
  arr [ 0 ] = 0 ;					      	arr [ 0 ] = 0 ;						      arr [ 0 ] = 0 ;						  
  System . out . print ( arr [ 0 ] + " ," ) ;		      	printf ( "%d, " , arr [ 0 ] ) ;				      cout << arr [ 0 ] << " ," ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int curr = arr [ i - 1 ] - i ;			      	  int curr = arr [ i - 1 ] - i ;			    	int curr = arr [ i - 1 ] - i ;				  
    int j ;						      	  int j ;						    	int j ;							  
    for ( j = 0 ;					      	  for ( j = 0 ;						    	for ( j = 0 ;						  
    j < i ;						      	  j < i ;						    	j < i ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( ( arr [ j ] == curr ) || curr < 0 ) {	      	    if ( ( arr [ j ] == curr ) || curr < 0 ) {		    	  if ( ( arr [ j ] == curr ) || curr < 0 ) {		  
	curr = arr [ i - 1 ] + i ;			      	      curr = arr [ i - 1 ] + i ;			    	    curr = arr [ i - 1 ] + i ;				  
	break ;						      	      break ;						    	    break ;						  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
    arr [ i ] = curr ;					      	  arr [ i ] = curr ;					    	arr [ i ] = curr ;					  
    System . out . print ( arr [ i ] + ", " ) ;		      	  printf ( "%d, " , arr [ i ] ) ;			    	cout << arr [ i ] << ", " ;				  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP			      PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP			    PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP				  PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP
--							      --							    --								  --
static void printAllAPTriplets ( int [ ] arr , int n ) {      void printAllAPTriplets ( int arr [ ] , int n ) {		    void printAllAPTriplets ( int * arr , int n ) {		  script_not_found : None
  ArrayList < Integer > s = new ArrayList < Integer > ( ) ;   	unordered_set < int > s ;				      vector < int > s ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      int diff = arr [ j ] - arr [ i ] ;		      	    int diff = arr [ j ] - arr [ i ] ;			    	  int diff = arr [ j ] - arr [ i ] ;			  
      boolean exists = s . contains ( arr [ i ] - diff ) ;    	    if ( s . find ( arr [ i ] - diff ) != s . end ( ) ) cou 	  bool exists = s . find ( arr [ i ] - diff ) != s . end  
      if ( exists ) System . out . println ( arr [ i ] - diff 	  }							    	  if ( exists ) {					  
    }							      	  s . insert ( arr [ i ] ) ;				    	    cout << arr [ i ] - diff << " " << arr [ i ] << " " < 
    s . add ( arr [ i ] ) ;				      	}							    	  }							  
  }							      }								    	}							  
}							      								    	s . push_back ( arr [ i ] ) ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIME_FACTORS_BIG_NUMBER				      PRIME_FACTORS_BIG_NUMBER					    PRIME_FACTORS_BIG_NUMBER					  PRIME_FACTORS_BIG_NUMBER
--							      --							    --								  --
static void factorize ( long n ) {			      void factorize ( long long n ) {				    void factorize ( long n ) {					  script_not_found : None
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  while ( ! ( n % 2 > 0 ) ) {				      	while ( ! ( n % 2 ) ) {					      while ( ! ( n % 2 > 0 ) ) {				  
    n >>= 1 ;						      	  n >>= 1 ;						    	n >>= 1 ;						  
    count ++ ;						      	  count ++ ;						    	count ++ ;						  
  }							      	}							      }								  
  if ( count > 0 ) {					      	if ( count ) cout << 2 << "  " << count << endl ;	      if ( count > 0 ) cout << "2" << " " << count << endl ;	  
    System . out . println ( "2" + " " + count ) ;	      	for ( long long i = 3 ;					      for ( long i = 3 ;					  
  }							      	i <= sqrt ( n ) ;					      i <= ( long ) sqrt ( n ) ;				  
  for ( long i = 3 ;					      	i += 2 ) {						      i += 2 ) {						  
  i <= ( long ) Math . sqrt ( n ) ;			      	  count = 0 ;						    	count = 0 ;						  
  i += 2 ) {						      	  while ( n % i == 0 ) {				    	while ( n % i == 0 ) {					  
    count = 0 ;						      	    count ++ ;						    	  count ++ ;						  
    while ( n % i == 0 ) {				      	    n = n / i ;						    	  n = n / i ;						  
      count ++ ;					      	  }							    	}							  
      n = n / i ;					      	  if ( count ) cout << i << "  " << count << endl ;	    	if ( count > 0 ) cout << i << " " << count << endl ;	  
    }							      	}							      }								  
    if ( count > 0 ) {					      	if ( n > 2 ) cout << n << "  " << 1 << endl ;		      if ( n > 2 ) cout << n << " " << "1" << endl ;		  
      System . out . println ( i + " " + count ) ;	      }								    }								  
    }							      								    								  
  }							      								    								  
  if ( n > 2 ) {					      								    								  
    System . out . println ( n + " " + "1" ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI
--							      --							    --								  --
static int stringReduction ( String str ) {		      int stringReduction ( string str ) {			    int stringReduction ( string str ) {			  script_not_found : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  int count [ ] = new int [ 3 ] ;			      	int count [ 3 ] = {					      int count [ 3 ] ;						  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < n ;						      	  ;							      i < n ;							  
  ++ i ) {						      	  for ( int i = 0 ;					      ++ i ) count [ str [ i ] - 'a' ] ++ ;			  
    count [ str . charAt ( i ) - 'a' ] ++ ;		      	  i < n ;						      if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == 
  }							      	  ++ i ) count [ str [ i ] - 'a' ] ++ ;			      if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count  
  if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ] == 	  if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ]    return 1 ;						  
    return n ;						      	  if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( coun }								  
  }							      	  return 1 ;						    								  
  if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count  	}							    								  
    return 2 ;						      								    								  
  }							      								    								  
  return 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1   REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1   REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1	  REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1
--							      --							    --								  --
static void translate ( char str [ ] ) {		      void translate ( char * str ) {				    void translate ( char str [ ] ) {				  script_not_found : None
  int len = str . length ;				      	int len = strlen ( str ) ;				      int len = strlen ( str ) ;				  
  if ( len < 2 ) return ;				      	if ( len < 2 ) return ;					      if ( len < 2 ) return ;					  
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  int j = 0 ;						      	int j = 0 ;						      int j = 0 ;						  
  while ( j < len - 1 ) {				      	while ( j < len - 1 ) {					      while ( j < len - 1 ) {					  
    if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) {	      	  if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) {	    	if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) {	  
      j = j + 2 ;					      	    j = j + 2 ;						    	  j = j + 2 ;						  
      str [ i ++ ] = 'C' ;				      	    str [ i ++ ] = 'C' ;				    	  str [ i ++ ] = 'C' ;					  
      continue ;					      	    continue ;						    	  continue ;						  
    }							      	  }							    	}							  
    str [ i ++ ] = str [ j ++ ] ;			      	  str [ i ++ ] = str [ j ++ ] ;				    	str [ i ++ ] = str [ j ++ ] ;				  
  }							      	}							      }								  
  if ( j == len - 1 ) str [ i ++ ] = str [ j ] ;	      	if ( j == len - 1 ) str [ i ++ ] = str [ j ] ;		      if ( j == len - 1 ) str [ i ++ ] = str [ j ] ;		  
  str [ i ] = ' ' ;					      	str [ i ] = ' ' ;					      str [ i ] = ' ' ;						  
  str [ len - 1 ] = ' ' ;				      }								      str [ len - 1 ] = ' ' ;					  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU
--							      --							    --								  --
static int returnMaxSum ( int A [ ] , int B [ ] , int n ) {   int returnMaxSum ( int A [ ] , int B [ ] , int n ) {	    int returnMaxSum ( int A [ ] , int B [ ] , int n ) {	  success : None
  Set < Integer > mp = new HashSet < Integer > ( ) ;	      	unordered_set < int > mp ;				      set < int > mp ;						  
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  int curr_sum = 0 , curr_begin = 0 ;			      	int curr_sum = 0 , curr_begin = 0 ;			      int currSum = 0 , currBegin = 0 ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  ++ i ) {						      	++ i ) {						      ++ i ) {							  
    while ( mp . contains ( A [ i ] ) ) {		      	  while ( mp . find ( A [ i ] ) != mp . end ( ) ) {	    	while ( mp . find ( A [ i ] ) != mp . end ( ) ) {	  
      mp . remove ( A [ curr_begin ] ) ;		      	    mp . erase ( A [ curr_begin ] ) ;			    	  mp . erase ( A [ currBegin ] ) ;			  
      curr_sum -= B [ curr_begin ] ;			      	    curr_sum -= B [ curr_begin ] ;			    	  currSum -= B [ currBegin ] ;				  
      curr_begin ++ ;					      	    curr_begin ++ ;					    	  currBegin ++ ;					  
    }							      	  }							    	}							  
    mp . add ( A [ i ] ) ;				      	  mp . insert ( A [ i ] ) ;				    	mp . insert ( A [ i ] ) ;				  
    curr_sum += B [ i ] ;				      	  curr_sum += B [ i ] ;					    	currSum += B [ i ] ;					  
    result = Integer . max ( result , curr_sum ) ;	      	  result = max ( result , curr_sum ) ;			    	result = max ( result , currSum ) ;			  
  }							      	}							      }								  
  return result ;					      	return result ;						      return result ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_ALMOST_SORTED_ARRAY				      SEARCH_ALMOST_SORTED_ARRAY				    SEARCH_ALMOST_SORTED_ARRAY					  SEARCH_ALMOST_SORTED_ARRAY
--							      --							    --								  --
int binarySearch ( int arr [ ] , int l , int r , int x ) {    int binarySearch ( int arr [ ] , int l , int r , int x ) {    int binarySearch ( int arr [ ] , int l , int r , int x ) {	  success : identical to gold
  if ( r >= l ) {					      	if ( r >= l ) {						      if ( r >= l ) {						  
    int mid = l + ( r - l ) / 2 ;			      	  int mid = l + ( r - l ) / 2 ;				    	int mid = l + ( r - l ) / 2 ;				  
    if ( arr [ mid ] == x ) return mid ;		      	  if ( arr [ mid ] == x ) return mid ;			    	if ( arr [ mid ] == x ) return mid ;			  
    if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) 	  if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) 	if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) 
    if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) 	  if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) 	if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) 
    if ( arr [ mid ] > x ) return binarySearch ( arr , l , mi 	  if ( arr [ mid ] > x ) return binarySearch ( arr , l , mi 	if ( arr [ mid ] > x ) return binarySearch ( arr , l , mi 
    return binarySearch ( arr , mid + 2 , r , x ) ;	      	  return binarySearch ( arr , mid + 2 , r , x ) ;	    	return binarySearch ( arr , mid + 2 , r , x ) ;		  
  }							      	}							      }								  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE
--							      --							    --								  --
static void solve ( int i , int par , int a [ ] , int n , int void solve ( int i , int par , int a [ ] , int n , int k , in void solve ( int i , int par , int a [ ] , int n , int k , in script_not_found : None
  if ( par > k ) return ;				      	if ( par > k ) return ;					      if ( par > k ) return ;					  
  if ( par == k && i == n - 1 ) {			      	if ( par == k && i == n - 1 ) {				      if ( par == k && i == n - 1 ) {				  
    ans = Math . min ( ans , current_ans ) ;		      	  ans = min ( ans , current_ans ) ;			    	ans = min ( ans , current_ans ) ;			  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  for ( int j = i + 1 ;					      	for ( int j = i + 1 ;					      for ( int j = i + 1 ;					  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a  	j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a    j ++ ) {							  
}							      }								    	solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] 
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1			      FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1			    FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1			  FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1
--							      --							    --								  --
static int maxLen ( int arr [ ] ) {			      int maxLen ( int arr [ ] , int n ) {			    int maxLen ( int arr [ ] ) {				  script_not_found : None
  HashMap < Integer , Integer > hM = new HashMap < Integer ,  	unordered_map < int , int > presum ;			      unordered_map < int , int > hM ;				  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  int max_len = 0 ;					      	int max_len = 0 ;					      int maxLen = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < arr . length ;					      	i < n ;							      i < sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    sum += arr [ i ] ;					      	  sum += arr [ i ] ;					    	sum += arr [ i ] ;					  
    if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ;	      	  if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ;	    	if ( arr [ i ] == 0 && maxLen == 0 ) maxLen = 1 ;	  
    if ( sum == 0 ) max_len = i + 1 ;			      	  if ( sum == 0 ) max_len = i + 1 ;			    	if ( sum == 0 ) maxLen = i + 1 ;			  
    Integer prev_i = hM . get ( sum ) ;			      	  if ( presum . find ( sum ) != presum . end ( ) ) {	    	int prevI = hM . find ( sum ) ;				  
    if ( prev_i != null ) max_len = Math . max ( max_len , i  	    max_len = max ( max_len , i - presum [ sum ] ) ;	    	if ( prevI != hM . end ( ) ) maxLen = max ( maxLen , i -  
    else hM . put ( sum , i ) ;				      	  }							    	else hM [ sum ] = i ;					  
  }							      	  else {						      }								  
  return max_len ;					      	    presum [ sum ] = i ;				      return maxLen ;						  
}							      	  }							    }								  
							      	}							    								  
							      	return max_len ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES    CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES    CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES	  CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES
--							      --							    --								  --
static boolean isRotated ( String str1 , String str2 ) {      bool isRotated ( string str1 , string str2 ) {		    bool isRotated ( string str1 , string str2 ) {		  success : None
  if ( str1 . length ( ) != str2 . length ( ) ) return false  	if ( str1 . length ( ) != str2 . length ( ) ) return false    if ( str1 . length ( ) != str2 . length ( ) ) return false  
  String clock_rot = "" ;				      	string clock_rot = "" ;					      string clock_rot ;					  
  String anticlock_rot = "" ;				      	string anticlock_rot = "" ;				      string anticlock_rot ;					  
  int len = str2 . length ( ) ;				      	int len = str2 . length ( ) ;				      int len = str2 . length ( ) ;				  
  anticlock_rot = anticlock_rot + str2 . substring ( len - 2  	anticlock_rot = anticlock_rot + str2 . substr ( len - 2 , 2   anticlock_rot = anticlock_rot + str2 . substr ( len - 2 , 2 
  clock_rot = clock_rot + str2 . substring ( 2 ) + str2 . sub 	clock_rot = clock_rot + str2 . substr ( 2 ) + str2 . substr   clock_rot = clock_rot + str2 . substr ( 2 ) + str2 . substr 
  return ( str1 . equals ( clock_rot ) || str1 . equals ( ant 	return ( str1 . compare ( clock_rot ) == 0 || str1 . compar   return ( str1 == clock_rot || str1 == anticlock_rot ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1	      MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1		    MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1		  MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1
--							      --							    --								  --
static int smallestSubWithSum ( int arr [ ] , int n , int x ) int smallestSubWithSum ( int arr [ ] , int n , int x ) {	    int smallestSubWithSum ( int arr [ ] , int n , int x ) {	  success : None
  int curr_sum = 0 , min_len = n + 1 ;			      	int curr_sum = 0 , min_len = n + 1 ;			      int currSum = 0 , minLen = n + 1 ;			  
  int start = 0 , end = 0 ;				      	int start = 0 , end = 0 ;				      int start = 0 , end = 0 ;					  
  while ( end < n ) {					      	while ( end < n ) {					      while ( end < n ) {					  
    while ( curr_sum <= x && end < n ) {		      	  while ( curr_sum <= x && end < n ) {			    	while ( currSum <= x && end < n ) {			  
      if ( curr_sum <= 0 && x > 0 ) {			      	    if ( curr_sum <= 0 && x > 0 ) {			    	  if ( currSum <= 0 && x > 0 ) {			  
	start = end ;					      	      start = end ;					    	    start = end ;					  
	curr_sum = 0 ;					      	      curr_sum = 0 ;					    	    currSum = 0 ;					  
      }							      	    }							    	  }							  
      curr_sum += arr [ end ++ ] ;			      	    curr_sum += arr [ end ++ ] ;			    	  currSum += arr [ end ++ ] ;				  
    }							      	  }							    	}							  
    while ( curr_sum > x && start < n ) {		      	  while ( curr_sum > x && start < n ) {			    	while ( currSum > x && start < n ) {			  
      if ( end - start < min_len ) min_len = end - start ;    	    if ( end - start < min_len ) min_len = end - start ;    	  if ( end - start < minLen ) {				  
      curr_sum -= arr [ start ++ ] ;			      	    curr_sum -= arr [ start ++ ] ;			    	    minLen = end - start ;				  
    }							      	  }							    	  }							  
  }							      	}							    	  currSum -= arr [ start ++ ] ;				  
  return min_len ;					      	return min_len ;					    	}							  
}							      }								      }								  
							      								      return minLen ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STEINS_ALGORITHM_FOR_FINDING_GCD_1			      STEINS_ALGORITHM_FOR_FINDING_GCD_1			    STEINS_ALGORITHM_FOR_FINDING_GCD_1				  STEINS_ALGORITHM_FOR_FINDING_GCD_1
--							      --							    --								  --
static int gcd ( int a , int b ) {			      int gcd ( int a , int b ) {				    int gcd ( int a , int b ) {					  success : None
  if ( a == b ) return a ;				      	if ( a == b ) return a ;				      if ( a == b ) return a ;					  
  if ( a == 0 ) return b ;				      	if ( a == 0 ) return b ;				      if ( a == 0 ) return b ;					  
  if ( b == 0 ) return a ;				      	if ( b == 0 ) return a ;				      if ( b == 0 ) return a ;					  
  if ( ( ~ a & 1 ) == 1 ) {				      	if ( ~ a & 1 ) {					      if ( ( ~ a & 1 ) == 1 ) {					  
    if ( ( b & 1 ) == 1 ) return gcd ( a >> 1 , b ) ;	      	  if ( b & 1 ) return gcd ( a >> 1 , b ) ;		    	if ( ( b & 1 ) == 1 ) return gcd ( a >> 1 , b ) ;	  
    else return gcd ( a >> 1 , b >> 1 ) << 1 ;		      	  else return gcd ( a >> 1 , b >> 1 ) << 1 ;		    	else return gcd ( a >> 1 , b >> 1 ) << 1 ;		  
  }							      	}							      }								  
  if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ;	      	if ( ~ b & 1 ) return gcd ( a , b >> 1 ) ;		      if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ;	  
  if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ;	      	if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ;	      if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ;		  
  return gcd ( ( b - a ) >> 1 , a ) ;			      	return gcd ( ( b - a ) >> 1 , a ) ;			      return gcd ( ( b - a ) >> 1 , a ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER		      CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER		    CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER		  CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER
--							      --							    --								  --
static boolean checkCorrectOrNot ( String s ) {		      bool checkCorrectOrNot ( string s ) {			    bool checkCorrectOrNot ( string s ) {			  script_not_found : None
  int [ ] count1 = new int [ MAX_CHAR ] ;		      	int count1 [ MAX_CHAR ] = {				      vector < int > count1 ;					  
  int [ ] count2 = new int [ MAX_CHAR ] ;		      	  0 }							      vector < int > count2 ;					  
  int n = s . length ( ) ;				      	  ;							      int n = s . length ( ) ;					  
  if ( n == 1 ) return true ;				      	  int count2 [ MAX_CHAR ] = {				      if ( n == 1 ) return true ;				  
  for ( int i = 0 , j = n - 1 ;				      	    0 }							      for ( int i = 0 , j = n - 1 ;				  
  i < j ;						      	    ;							      i < j ;							  
  i ++ , j -- ) {					      	    int n = s . length ( ) ;				      i ++ , j -- ) {						  
    count1 [ s . charAt ( i ) - 'a' ] ++ ;		      	    if ( n == 1 ) return true ;				    	count1 [ s [ i ] - 'a' ] ++ ;				  
    count2 [ s . charAt ( j ) - 'a' ] ++ ;		      	    for ( int i = 0 , j = n - 1 ;			    	count2 [ s [ j ] - 'a' ] ++ ;				  
  }							      	    i < j ;						      }								  
  for ( int i = 0 ;					      	    i ++ , j -- ) {					      for ( int i = 0 ;						  
  i < MAX_CHAR ;					      	      count1 [ s [ i ] - 'a' ] ++ ;			      i < MAX_CHAR ;						  
  i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ;   	      count2 [ s [ j ] - 'a' ] ++ ;			      i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ;	  
  return true ;						      	    }							      return true ;						  
}							      	    for ( int i = 0 ;					    }								  
							      	    i < MAX_CHAR ;					    								  
							      	    i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false 								  
							      	    return true ;					    								  
							      	  }							    								  
-							      	  -							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING		      LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING		    LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING		  LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING
--							      --							    --								  --
static String lexicographicSubConcat ( String s ) {	      string lexicographicSubConcat ( string s ) {		    string lexicographicSubConcat ( string s ) {		  success : None
  int n = s . length ( ) ;				      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
  int sub_count = n * ( n + 1 ) / 2 ;			      	int sub_count = n * ( n + 1 ) / 2 ;			      int sub_count = n * ( n + 1 ) / 2 ;			  
  String [ ] arr = new String [ sub_count ] ;		      	string arr [ sub_count ] ;				      string arr [ sub_count ] ;				  
  int index = 0 ;					      	int index = 0 ;						      int index = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int len = 1 ;				      	i ++ ) for ( int len = 1 ;				      i ++ ) for ( int len = 1 ;				  
  len <= n - i ;					      	len <= n - i ;						      len <= n - i ;						  
  len ++ ) {						      	len ++ ) arr [ index ++ ] = s . substr ( i , len ) ;	      len ++ ) arr [ index ++ ] = s . substr ( i , len ) ;	  
    arr [ index ++ ] = s . substring ( i , i + len ) ;	      	sort ( arr , arr + sub_count ) ;			      std :: sort ( arr , arr + sub_count ) ;			  
  }							      	string res = "" ;					      string res ;						  
  Arrays . sort ( arr ) ;				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  String res = "" ;					      	i < sub_count ;						      i < sub_count ;						  
  for ( int i = 0 ;					      	i ++ ) res += arr [ i ] ;				      i ++ ) res += arr [ i ] ;					  
  i < sub_count ;					      	return res ;						      return res ;						  
  i ++ ) res += arr [ i ] ;				      }								    }								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_N_DIGITS_NON_DECREASING_INTEGERS			      NUMBER_N_DIGITS_NON_DECREASING_INTEGERS			    NUMBER_N_DIGITS_NON_DECREASING_INTEGERS			  NUMBER_N_DIGITS_NON_DECREASING_INTEGERS
--							      --							    --								  --
static int nonDecNums ( int n ) {			      int nonDecNums ( int n ) {				    int nonDecNums ( int n ) {					  success : None
  int [ ] [ ] a = new int [ n + 1 ] [ 10 ] ;		      	int a [ n + 1 ] [ 10 ] ;				      vector < vector < int >> a ( n + 1 , vector < int > ( 10 ,  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= 9 ;						      	i <= 9 ;						      i <= 9 ;							  
  i ++ ) a [ 0 ] [ i ] = 1 ;				      	i ++ ) a [ 0 ] [ i ] = 1 ;				      i ++ ) {							  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	a [ 0 ] [ i ] = 1 ;					  
  i <= n ;						      	i <= n ;						      }								  
  i ++ ) a [ i ] [ 9 ] = 1 ;				      	i ++ ) a [ i ] [ 9 ] = 1 ;				      for ( int i = 1 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      i <= n ;							  
  i <= n ;						      	i <= n ;						      i ++ ) {							  
  i ++ ) for ( int j = 8 ;				      	i ++ ) for ( int j = 8 ;				    	a [ i ] [ 9 ] = 1 ;					  
  j >= 0 ;						      	j >= 0 ;						      }								  
  j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1  	j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1    for ( int i = 1 ;						  
  return a [ n ] [ 0 ] ;				      	return a [ n ] [ 0 ] ;					      i <= n ;							  
}							      }								      i ++ ) {							  
							      								    	for ( int j = 8 ;					  
							      								    	j >= 0 ;						  
							      								    	j -- ) {						  
							      								    	  a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; 
							      								    	}							  
							      								      }								  
							      								      return a [ n ] [ 0 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT
--							      --							    --								  --
static int minCost ( int cost [ ] [ ] ) {		      INT_MAX int minCost ( int cost [ ] [ N ] ) {		    int minCost ( int cost [ N ] [ N ] ) {			  script_not_found : None
  int dist [ ] = new int [ N ] ;			      	int dist [ N ] ;					      int dist [ N ] ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) dist [ i ] = INF ;				      	i ++ ) dist [ i ] = INF ;				      i ++ ) {							  
  dist [ 0 ] = 0 ;					      	dist [ 0 ] = 0 ;					    	dist [ i ] = INF ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      }								  
  i < N ;						      	i < N ;							      dist [ 0 ] = 0 ;						  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      for ( int i = 0 ;						  
  j < N ;						      	j < N ;							      i < N ;							  
  j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) di 	j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) di   i ++ ) for ( int j = i + 1 ;				  
  return dist [ N - 1 ] ;				      	return dist [ N - 1 ] ;					      j < N ;							  
}							      }								      j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) di 
							      								      return dist [ N - 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K     GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K	    GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K	  GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K
--							      --							    --								  --
static void printSumSimple ( int mat [ ] [ ] , int k ) {      void printSumSimple ( int mat [ ] [ n ] , int k ) {	    void print_sum_simple ( int mat [ ] [ 3 ] , int k ) {	  script_not_found : None
  if ( k > n ) return ;					      	if ( k > n ) return ;					      if ( k > n ) return ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - k + 1 ;					      	i < n - k + 1 ;						      i < n - k + 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n - k + 1 ;					      	  j < n - k + 1 ;					    	j < n - k + 1 ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      int sum = 0 ;					      	    int sum = 0 ;					    	  int sum = 0 ;						  
      for ( int p = i ;					      	    for ( int p = i ;					    	  for ( int p = i ;					  
      p < k + i ;					      	    p < k + i ;						    	  p < k + i ;						  
      p ++ ) for ( int q = j ;				      	    p ++ ) for ( int q = j ;				    	  p ++ ) for ( int q = j ;				  
      q < k + j ;					      	    q < k + j ;						    	  q < k + j ;						  
      q ++ ) sum += mat [ p ] [ q ] ;			      	    q ++ ) sum += mat [ p ] [ q ] ;			    	  q ++ ) sum += mat [ p ] [ q ] ;			  
      System . out . print ( sum + " " ) ;		      	    cout << sum << "  " ;				    	  cout << sum << " " ;					  
    }							      	  }							    	}							  
    System . out . println ( ) ;			      	  cout << endl ;					    	cout << endl ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT			      KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT			    KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT			  KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT
--							      --							    --								  --
static void printkthnode ( Vector < pair > adj [ ] , int wt [ void printkthnode ( vector < pair < int , int >> adj [ ] , in void printkthnode ( vector < pair > adj , int wt [ ] , int n  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) Collections . sort ( adj [ i ] , new Comparator < pa 	i ++ ) sort ( adj [ i ] . begin ( ) , adj [ i ] . end ( ) )   i ++ ) {							  
    public int compare ( pair p1 , pair p2 ) {		      	for ( int i = 0 ;					    	sort ( adj [ i ] . begin ( ) , adj [ i ] . end ( ) , [ ]  
      return p1 . first - p2 . first ;			      	i < n ;							    	  return p1 . first < p2 . first ;			  
    }							      	i ++ ) {						    	}							  
  }							      	  if ( adj [ i ] . size ( ) >= k ) cout << adj [ i ] [ adj  	) ;							  
  ) ;							      	  else cout << "-1" ;					      }								  
  for ( int i = 0 ;					      	}							      for ( int i = 0 ;						  
  i < n ;						      }								      i < n ;							  
  i ++ ) {						      								      i ++ ) {							  
    if ( adj [ i ] . size ( ) >= k ) System . out . print ( a 								    	if ( adj [ i ] . size ( ) >= k ) {			  
    else System . out . print ( "-1" ) ;		      								    	  cout << adj [ i ] [ adj [ i ] . size ( ) - k ] . second 
  }							      								    	}							  
}							      								    	else {							  
							      								    	  cout << "-1" ;					  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1		      FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1			    FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1			  FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1
--							      --							    --								  --
static String getMinNumberForPattern ( String seq ) {	      string getMinNumberForPattern ( string seq ) {		    string getMinNumberForPattern ( string seq ) {		  failure : #Results: 2, 10
  int n = seq . length ( ) ;				      	int n = seq . length ( ) ;				      int n = seq . length ( ) ;				  
  if ( n >= 9 ) return "-1" ;				      	if ( n >= 9 ) return "-1" ;				      if ( n >= 9 ) return "-1" ;				  
  char result [ ] = new char [ n + 1 ] ;		      	string result ( n + 1 , ' ' ) ;				      string result ;						  
  int count = 1 ;					      	int count = 1 ;						      result . reserve ( n + 1 ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      int count = 1 ;						  
  i <= n ;						      	i <= n ;						      for ( int i = 0 ;						  
  i ++ ) {						      	i ++ ) {						      i <= n ;							  
    if ( i == n || seq . charAt ( i ) == 'I' ) {	      	  if ( i == n || seq [ i ] == 'I' ) {			      i ++ ) {							  
      for ( int j = i - 1 ;				      	    for ( int j = i - 1 ;				    	if ( i == n || seq [ i ] == 'I' ) {			  
      j >= - 1 ;					      	    j >= - 1 ;						    	  for ( int j = i - 1 ;					  
      j -- ) {						      	    j -- ) {						    	  j >= - 1 ;						  
	result [ j + 1 ] = ( char ) ( ( int ) '0' + count ++  	      result [ j + 1 ] = '0' + count ++ ;		    	  j -- ) {						  
	if ( j >= 0 && seq . charAt ( j ) == 'I' ) break ;    	      if ( j >= 0 && seq [ j ] == 'I' ) break ;		    	    result += ( char ) ( ( int ) '0' + count ++ ) ;	  
      }							      	    }							    	    if ( j >= 0 && seq [ j ] == 'I' ) break ;		  
    }							      	  }							    	  }							  
  }							      	}							    	}							  
  return new String ( result ) ;			      	return result ;						      }								  
}							      }								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DICE_THROW_PROBLEM					      DICE_THROW_PROBLEM					    DICE_THROW_PROBLEM						  DICE_THROW_PROBLEM
--							      --							    --								  --
public static long findWays ( int m , int n , int x ) {	      int findWays ( int m , int n , int x ) {			    long long findWays ( int m , int n , int x ) {		  failure : #Results: 0, 10
  long [ ] [ ] table = new long [ n + 1 ] [ x + 1 ] ;	      	int table [ n + 1 ] [ x + 1 ] ;				      long long table [ n + 1 ] [ x + 1 ] ;			  
  for ( int j = 1 ;					      	memset ( table , 0 , sizeof ( table ) ) ;		      for ( int j = 1 ;						  
  j <= m && j <= x ;					      	for ( int j = 1 ;					      j <= m && j <= x ;					  
  j ++ ) table [ 1 ] [ j ] = 1 ;			      	j <= m && j <= x ;					      j ++ ) {							  
  for ( int i = 2 ;					      	j ++ ) table [ 1 ] [ j ] = 1 ;				    	table [ 1 ] [ j ] = 1 ;					  
  i <= n ;						      	for ( int i = 2 ;					      }								  
  i ++ ) {						      	i <= n ;						      for ( int i = 2 ;						  
    for ( int j = 1 ;					      	i ++ ) for ( int j = 1 ;				      i <= n ;							  
    j <= x ;						      	j <= x ;						      i ++ ) {							  
    j ++ ) {						      	j ++ ) for ( int k = 1 ;				    	for ( int j = 1 ;					  
      for ( int k = 1 ;					      	k <= m && k < j ;					    	j <= x ;						  
      k < j && k <= m ;					      	k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;	    	j ++ ) {						  
      k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; 	return table [ n ] [ x ] ;				    	  for ( int k = 1 ;					  
    }							      }								    	  k < j && k <= m ;					  
  }							      								    	  k ++ ) {						  
  return table [ n ] [ x ] ;				      								    	    table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;	  
}							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return table [ n ] [ x ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_DECIMAL_FRACTION_BINARY_NUMBER			      CONVERT_DECIMAL_FRACTION_BINARY_NUMBER			    CONVERT_DECIMAL_FRACTION_BINARY_NUMBER			  CONVERT_DECIMAL_FRACTION_BINARY_NUMBER
--							      --							    --								  --
static String decimalToBinary ( double num , int k_prec ) {   string decimalToBinary ( double num , int k_prec ) {	    string decimalToBinary ( double num , int k_prec ) {	  error : CONVERT_DECIMAL_FRACTION_BINARY_NUMBER.cpp
  String binary = "" ;					      	string binary = "" ;					      string binary ;						  : In function ‘std::__cxx11::string f_filled(doubl
  int Integral = ( int ) num ;				      	int Integral = num ;					      int Integral = ( int ) num ;				  e, int)’: CONVERT_DECIMAL_FRACTION_BINARY_NUMBER.c
  double fractional = num - Integral ;			      	double fractional = num - Integral ;			      double fractional = num - Integral ;			  pp:49:60: error: no match for ‘operator=’ (operand
  while ( Integral > 0 ) {				      	while ( Integral ) {					      while ( Integral > 0 ) {					   types are ‘std::__cxx11::string’ {aka ‘std::__cxx
    int rem = Integral % 2 ;				      	  int rem = Integral % 2 ;				    	int rem = Integral % 2 ;				  11::basic_string<char>’} and ‘void’)	  binary = r
    binary += ( ( char ) ( rem + '0' ) ) ;		      	  binary . push_back ( rem + '0' ) ;			    	binary += ( ( char ) ( rem + '0' ) ) ;			  everse ( binary . begin ( ) , binary . end ( ) ) ;
    Integral /= 2 ;					      	  Integral /= 2 ;					    	Integral /= 2 ;						  
  }							      	}							      }								  	     ^ In file included from /usr/include/c+
  binary = reverse ( binary ) ;				      	reverse ( binary . begin ( ) , binary . end ( ) ) ;	      binary = reverse ( binary . begin ( ) , binary . end ( ) )  +/8/string:52,		  from /usr/include/
  binary += ( '.' ) ;					      	binary . push_back ( '.' ) ;				      binary += ( '.' ) ;					  c++/8/bits/locale_classes.h:40,		   f
  while ( k_prec -- > 0 ) {				      	while ( k_prec -- ) {					      while ( k_prec -- > 0 ) {					  rom /usr/include/c++/8/bits/ios_base.h:41,
    fractional *= 2 ;					      	  fractional *= 2 ;					    	fractional *= 2 ;					  	    from /usr/include/c++/8/ios:42,
    int fract_bit = ( int ) fractional ;		      	  int fract_bit = fractional ;				    	int fract_bit = ( int ) fractional ;			  	   from /usr/include/c++/8/ostream:38,
    if ( fract_bit == 1 ) {				      	  if ( fract_bit == 1 ) {				    	if ( fract_bit == 1 ) {					  	      from /usr/include/c++/8/iostream:39,
      fractional -= fract_bit ;				      	    fractional -= fract_bit ;				    	  fractional -= fract_bit ;				  		  from CONVERT_DECIMAL_FRACTION_BINA
      binary += ( char ) ( 1 + '0' ) ;			      	    binary . push_back ( 1 + '0' ) ;			    	  binary += ( char ) ( 1 + '0' ) ;			  RY_NUMBER.cpp:8: /usr/include/c++/8/bits/basic_str
    }							      	  }							    	}							  ing.h:664:7: note: candidate: ‘std::__cxx11::basic
    else {						      	  else binary . push_back ( 0 + '0' ) ;			    	else {							  _string<_CharT, _Traits, _Alloc>& std::__cxx11::ba
      binary += ( char ) ( 0 + '0' ) ;			      	}							    	  binary += ( char ) ( 0 + '0' ) ;			  sic_string<_CharT, _Traits, _Alloc>::operator=(con
    }							      	return binary ;						    	}							  st std::__cxx11::basic_string<_CharT, _Traits, _Al
  }							      }								      }								  loc>&) [with _CharT = char; _Traits = std::char_tr
  return binary ;					      								      return binary ;						  aits<char>; _Alloc = std::allocator<char>]’
}							      								    }								   operator=(const basic_string& __str)	       ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/basic_string.h:664:7:
							      								    								  note:	  no known conversion for argument 1 from ‘v
							      								    								  oid’ to ‘const std::__cxx11::basic_string<char>&’
							      								    								  /usr/include/c++/8/bits/basic_string.h:703:7: note
							      								    								  : candidate: ‘std::__cxx11::basic_string<_CharT, _
							      								    								  Traits, _Alloc>& std::__cxx11::basic_string<_CharT
							      								    								  , _Traits, _Alloc>::operator=(const _CharT*) [with
							      								    								   _CharT = char; _Traits = std::char_traits<char>;
							      								    								  _Alloc = std::allocator<char>]’	 operator=(c
							      								    								  onst _CharT* __s)	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/basic_string.h:703:7: note:	no known con
							      								    								  version for argument 1 from ‘void’ to ‘const char*
							      								    								  ’ /usr/include/c++/8/bits/basic_string.h:714:7: no
							      								    								  te: candidate: ‘std::__cxx11::basic_string<_CharT,
							      								    								   _Traits, _Alloc>& std::__cxx11::basic_string<_Cha
							      								    								  rT, _Traits, _Alloc>::operator=(_CharT) [with _Cha
							      								    								  rT = char; _Traits = std::char_traits<char>; _Allo
							      								    								  c = std::allocator<char>]’	    operator=(_CharT
							      								    								   __c)	       ^~~~~~~~ /usr/include/c++/8/bits/basi
							      								    								  c_string.h:714:7: note:   no known conversion for
							      								    								  argument 1 from ‘void’ to ‘char’ /usr/include/c++/
							      								    								  8/bits/basic_string.h:732:7: note: candidate: ‘std
							      								    								  ::__cxx11::basic_string<_CharT, _Traits, _Alloc>&
							      								    								  std::__cxx11::basic_string<_CharT, _Traits, _Alloc
							      								    								  >::operator=(std::__cxx11::basic_string<_CharT, _T
							      								    								  raits, _Alloc>&&) [with _CharT = char; _Traits = s
							      								    								  td::char_traits<char>; _Alloc = std::allocator<cha
							      								    								  r>]’	      operator=(basic_string&& __str)
							      								    								   ^~~~~~~~ /usr/include/c++/8/bits/basic_string.h:7
							      								    								  32:7: note:	no known conversion for argument 1 f
							      								    								  rom ‘void’ to ‘std::__cxx11::basic_string<char>&&’
							      								    								   /usr/include/c++/8/bits/basic_string.h:795:7: not
							      								    								  e: candidate: ‘std::__cxx11::basic_string<_CharT,
							      								    								  _Traits, _Alloc>& std::__cxx11::basic_string<_Char
							      								    								  T, _Traits, _Alloc>::operator=(std::initializer_li
							      								    								  st<_Tp>) [with _CharT = char; _Traits = std::char_
							      								    								  traits<char>; _Alloc = std::allocator<char>]’
							      								    								     operator=(initializer_list<_CharT> __l)
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/basic_string.h:79
							      								    								  5:7: note:   no known conversion for argument 1 fr
							      								    								  om ‘void’ to ‘std::initializer_list<char>’
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_PATH_TRIANGLE				      MINIMUM_SUM_PATH_TRIANGLE					    MINIMUM_SUM_PATH_TRIANGLE					  MINIMUM_SUM_PATH_TRIANGLE
--							      --							    --								  --
static int minSumPath ( ) {				      int minSumPath ( vector < vector < int >> & A ) {		    int minSumPath ( ) {					  script_not_found : None
  int [ ] memo = new int [ A . length ] ;		      	int memo [ A . size ( ) ] ;				      vector < int > memo ( A . size ( ) , 0 ) ;		  
  int n = A . length - 1 ;				      	int n = A . size ( ) - 1 ;				      int n = A . size ( ) - 1 ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < A [ n ] . length ;				      	i < A [ n ] . size ( ) ;				      i < A [ n ] . size ( ) ;					  
  i ++ ) memo [ i ] = A [ n ] [ i ] ;			      	i ++ ) memo [ i ] = A [ n ] [ i ] ;			      i ++ ) {							  
  for ( int i = A . length - 2 ;			      	for ( int i = A . size ( ) - 2 ;			    	memo [ i ] = A [ n ] [ i ] ;				  
  i >= 0 ;						      	i >= 0 ;						      }								  
  i -- ) for ( int j = 0 ;				      	i -- ) for ( int j = 0 ;				      for ( int i = A . size ( ) - 2 ;				  
  j < A [ i ] . length ;				      	j < A [ i ] . size ( ) ;				      i >= 0 ;							  
  j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . min ( me 	j ++ ) memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo   i -- ) for ( int j = 0 ;					  
  return memo [ 0 ] ;					      	return memo [ 0 ] ;					      j < A [ i ] . size ( ) ;					  
}							      }								      j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) min ( memo [ j  
							      								      return memo [ 0 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TEMPLE_OFFERINGS					      TEMPLE_OFFERINGS						    TEMPLE_OFFERINGS						  TEMPLE_OFFERINGS
--							      --							    --								  --
static int offeringNumber ( int n , int templeHeight [ ] ) {  int offeringNumber ( int n , int templeHeight [ ] ) {	    int offeringNumber ( int n , int templeHeight [ ] ) {	  success : None
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  ++ i ) {						      	++ i ) {						      ++ i ) {							  
    int left = 0 , right = 0 ;				      	  int left = 0 , right = 0 ;				    	int left = 0 , right = 0 ;				  
    for ( int j = i - 1 ;				      	  for ( int j = i - 1 ;					    	for ( int j = i - 1 ;					  
    j >= 0 ;						      	  j >= 0 ;						    	j >= 0 ;						  
    -- j ) {						      	  -- j ) {						    	-- j ) {						  
      if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ l 	    if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ l 	  if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) {	  
      else break ;					      	    else break ;					    	    ++ left ;						  
    }							      	  }							    	  }							  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	  else {						  
    j < n ;						      	  j < n ;						    	    break ;						  
    ++ j ) {						      	  ++ j ) {						    	  }							  
      if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ r 	    if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ r 	}							  
      else break ;					      	    else break ;					    	for ( int j = i + 1 ;					  
    }							      	  }							    	j < n ;							  
    sum += Math . max ( right , left ) + 1 ;		      	  sum += max ( right , left ) + 1 ;			    	++ j ) {						  
  }							      	}							    	  if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) {	  
  return sum ;						      	return sum ;						    	    ++ right ;						  
}							      }								    	  }							  
							      								    	  else {						  
							      								    	    break ;						  
							      								    	  }							  
							      								    	}							  
							      								    	sum += max ( right , left ) + 1 ;			  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_ DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_ DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_ DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_
--							      --							    --								  --
static int findDiff ( int arr [ ] , int n ) {		      int findDiff ( int arr [ ] , int n ) {			    int findDiff ( int arr [ ] , int n ) {			  success : None
  Map < Integer , Integer > mp = new HashMap < > ( ) ;	      	unordered_map < int , int > hm ;			      map < int , int > mp ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) hm [ arr [ i ] ] ++ ;				      i ++ ) {							  
    if ( mp . containsKey ( arr [ i ] ) ) {		      	int max_count = 0 , min_count = n ;			    	if ( mp . find ( arr [ i ] ) != mp . end ( ) ) mp [ arr [ 
      mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ;   	for ( auto x : hm ) {					    	else mp [ arr [ i ] ] = 1 ;				  
    }							      	  max_count = max ( max_count , x . second ) ;		      }								  
    else {						      	  min_count = min ( min_count , x . second ) ;		      int maxCount = 0 , minCount = n ;				  
      mp . put ( arr [ i ] , 1 ) ;			      	}							      for ( map < int , int > :: iterator x = mp . begin ( ) ;	  
    }							      	return ( max_count - min_count ) ;			      x != mp . end ( ) ;					  
  }							      }								      x ++ ) {							  
  int max_count = 0 , min_count = n ;			      								    	maxCount = max ( maxCount , x -> second ) ;		  
  for ( Map . Entry < Integer , Integer > x : mp . entrySet ( 								    	minCount = min ( minCount , x -> second ) ;		  
    max_count = Math . max ( max_count , x . getValue ( ) ) ; 								      }								  
    min_count = Math . min ( min_count , x . getValue ( ) ) ; 								      return ( maxCount - minCount ) ;				  
  }							      								    }								  
  return ( max_count - min_count ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_WITH_GIVEN_SUM_1				      COUNT_PAIRS_WITH_GIVEN_SUM_1				    COUNT_PAIRS_WITH_GIVEN_SUM_1				  COUNT_PAIRS_WITH_GIVEN_SUM_1
--							      --							    --								  --
static int getPairsCount ( int n , int sum ) {		      int getPairsCount ( int arr [ ] , int n , int sum ) {	    int getPairsCount ( int n , int sum ) {			  script_not_found : None
  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;    	unordered_map < int , int > m ;				      unordered_map < int , int > hm ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) m [ arr [ i ] ] ++ ;				      i ++ ) {							  
    if ( ! hm . containsKey ( arr [ i ] ) ) hm . put ( arr [  	int twice_count = 0 ;					    	if ( ! hm . count ( arr [ i ] ) ) hm [ arr [ i ] ] = 0 ;  
    hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ;     	for ( int i = 0 ;					    	hm [ arr [ i ] ] = hm [ arr [ i ] ] + 1 ;		  
  }							      	i < n ;							      }								  
  int twice_count = 0 ;					      	i ++ ) {						      int twice_count = 0 ;					  
  for ( int i = 0 ;					      	  twice_count += m [ sum - arr [ i ] ] ;		      for ( int i = 0 ;						  
  i < n ;						      	  if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ;	      i < n ;							  
  i ++ ) {						      	}							      i ++ ) {							  
    if ( hm . get ( sum - arr [ i ] ) != null ) twice_count + 	return twice_count / 2 ;				    	if ( hm [ sum - arr [ i ] ] ) twice_count += hm [ sum - a 
    if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ;      }								    	if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ;	  
  }							      								      }								  
  return twice_count / 2 ;				      								      return twice_count / 2 ;					  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR
--							      --							    --								  --
static void bitonicGenerator ( int arr [ ] , int n ) {	      void bitonicGenerator ( int arr [ ] , int n ) {		    void bitonicGenerator ( int arr [ ] , int n ) {		  script_not_found : None
  int i = 1 ;						      	int i = 1 ;						      int i = 1 ;						  
  int j = n - 1 ;					      	int j = n - 1 ;						      int j = n - 1 ;						  
  if ( j % 2 != 0 ) j -- ;				      	if ( j % 2 != 0 ) j -- ;				      if ( j % 2 != 0 ) {					  
  while ( i < j ) {					      	while ( i < j ) {					    	j -- ;							  
    arr = swap ( arr , i , j ) ;			      	  swap ( arr [ i ] , arr [ j ] ) ;			      }								  
    i += 2 ;						      	  i += 2 ;						      while ( i < j ) {						  
    j -= 2 ;						      	  j -= 2 ;						    	arr = swap ( arr [ i ] , arr [ j ] ) ;			  
  }							      	}							    	i += 2 ;						  
  Arrays . sort ( arr , 0 , ( n + 1 ) / 2 ) ;		      	sort ( arr , arr + ( n + 1 ) / 2 ) ;			    	j -= 2 ;						  
  Arrays . sort ( arr , ( n + 1 ) / 2 , n ) ;		      	sort ( arr + ( n + 1 ) / 2 , arr + n , greater < int > ( )    }								  
  int low = ( n + 1 ) / 2 , high = n - 1 ;		      }								      sort ( arr , arr + ( n + 1 ) / 2 ) ;			  
  while ( low < high ) {				      								      sort ( arr + ( n + 1 ) / 2 , arr + n ) ;			  
    Integer temp = arr [ low ] ;			      								      int low = ( n + 1 ) / 2 , high = n - 1 ;			  
    arr [ low ] = arr [ high ] ;			      								      while ( low < high ) {					  
    arr [ high ] = temp ;				      								    	int temp = arr [ low ] ;				  
    low ++ ;						      								    	arr [ low ] = arr [ high ] ;				  
    high -- ;						      								    	arr [ high ] = temp ;					  
  }							      								    	low ++ ;						  
}							      								    	high -- ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_ISBN					      PROGRAM_CHECK_ISBN					    PROGRAM_CHECK_ISBN						  PROGRAM_CHECK_ISBN
--							      --							    --								  --
static boolean isValidISBN ( String isbn ) {		      bool isValidISBN ( string & isbn ) {			    bool isValidISBN ( string isbn ) {				  success : None
  int n = isbn . length ( ) ;				      	int n = isbn . length ( ) ;				      int n = isbn . length ( ) ;				  
  if ( n != 10 ) return false ;				      	if ( n != 10 ) return false ;				      if ( n != 10 ) return false ;				  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < 9 ;						      	i < 9 ;							      i < 9 ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int digit = isbn . charAt ( i ) - '0' ;		      	  int digit = isbn [ i ] - '0' ;			    	int digit = isbn [ i ] - '0' ;				  
    if ( 0 > digit || 9 < digit ) return false ;	      	  if ( 0 > digit || 9 < digit ) return false ;		    	if ( 0 > digit || 9 < digit ) return false ;		  
    sum += ( digit * ( 10 - i ) ) ;			      	  sum += ( digit * ( 10 - i ) ) ;			    	sum += ( digit * ( 10 - i ) ) ;				  
  }							      	}							      }								  
  char last = isbn . charAt ( 9 ) ;			      	char last = isbn [ 9 ] ;				      char last = isbn [ 9 ] ;					  
  if ( last != 'X' && ( last < '0' || last > '9' ) ) return f 	if ( last != 'X' && ( last < '0' || last > '9' ) ) return f   if ( last != 'X' && ( last < '0' || last > '9' ) ) return f 
  sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ;	      	sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ;	      sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ;	  
  return ( sum % 11 == 0 ) ;				      	return ( sum % 11 == 0 ) ;				      return ( sum % 11 == 0 ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT			      FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT			    FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT				  FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT
--							      --							    --								  --
static void possibleOrNot ( long a1 , long a2 , long b1 , lon void possibleOrNot ( long long a1 , long long a2 , long long  void possibleOrNot ( long a1 , long a2 , long b1 , long b2 ,  script_not_found : None
  long dis1 = ( long ) Math . pow ( b1 - a1 , 2 ) + ( long )  	long long dis1 = pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 )    long dis1 = ( long ) pow ( b1 - a1 , 2 ) + ( long ) pow ( b 
  long dis2 = ( long ) Math . pow ( c1 - b1 , 2 ) + ( long )  	long long dis2 = pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 )    long dis2 = ( long ) pow ( c1 - b1 , 2 ) + ( long ) pow ( c 
  if ( dis1 != dis2 ) System . out . print ( "No" ) ;	      	if ( dis1 != dis2 ) cout << "No" ;			      if ( dis1 != dis2 ) {					  
  else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2  	else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2  	cout << "No" ;						  
  else System . out . print ( "Yes" ) ;			      	else cout << "Yes" ;					      }								  
}							      }								      else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2  
							      								    	cout << "No" ;						  
							      								      }								  
							      								      else {							  
							      								    	cout << "Yes" ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX	      MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX	    MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX	  MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX
--							      --							    --								  --
static int minOperation ( boolean arr [ ] [ ] ) {	      int minOperation ( bool arr [ N ] [ M ] ) {		    int minOperation ( bool arr [ ] [ N ] ) {			  script_not_found : None
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  for ( int i = N - 1 ;					      	for ( int i = N - 1 ;					      for ( int i = N - 1 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    for ( int j = M - 1 ;				      	  for ( int j = M - 1 ;					    	for ( int j = M - 1 ;					  
    j >= 0 ;						      	  j >= 0 ;						    	j >= 0 ;						  
    j -- ) {						      	  j -- ) {						    	j -- ) {						  
      if ( arr [ i ] [ j ] == false ) {			      	    if ( arr [ i ] [ j ] == 0 ) {			    	  if ( arr [ i ] [ j ] == false ) {			  
	ans ++ ;					      	      ans ++ ;						    	    ans ++ ;						  
	for ( int k = 0 ;				      	      for ( int k = 0 ;					    	    for ( int k = 0 ;					  
	k <= i ;					      	      k <= i ;						    	    k <= i ;						  
	k ++ ) {					      	      k ++ ) {						    	    k ++ ) {						  
	  for ( int h = 0 ;				      		for ( int h = 0 ;				    	      for ( int h = 0 ;					  
	  h <= j ;					      		h <= j ;					    	      h <= j ;						  
	  h ++ ) {					      		h ++ ) {					    	      h ++ ) {						  
	    if ( arr [ k ] [ h ] == true ) {		      		  if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0 ; 		if ( arr [ k ] [ h ] == true ) arr [ k ] [ h ] =  
	      arr [ k ] [ h ] = false ;			      		  else arr [ k ] [ h ] = 1 ;			    		else arr [ k ] [ h ] = true ;			  
	    }						      		}						    	      }							  
	    else {					      	      }							    	    }							  
	      arr [ k ] [ h ] = true ;			      	    }							    	  }							  
	    }						      	  }							    	}							  
	  }						      	}							      }								  
	}						      	return ans ;						      return ans ;						  
      }							      }								    }								  
    }							      								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM			      MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM			    MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM			  MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM
--							      --							    --								  --
static int maximumSumSubarray ( int arr [ ] , int n ) {	      int maximumSumSubarray ( int arr [ ] , int n ) {		    int maximumSumSubarray ( int arr [ ] , int n ) {		  success : None
  int min_prefix_sum = 0 ;				      	int min_prefix_sum = 0 ;				      int min_prefix_sum = 0 ;					  
  int res = Integer . MIN_VALUE ;			      	int res = numeric_limits < int > :: min ( ) ;		      int res = INT_MIN ;					  
  int prefix_sum [ ] = new int [ n ] ;			      	int prefix_sum [ n ] ;					      int prefix_sum [ n ] ;					  
  prefix_sum [ 0 ] = arr [ 0 ] ;			      	prefix_sum [ 0 ] = arr [ 0 ] ;				      prefix_sum [ 0 ] = arr [ 0 ] ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ]  	i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ]    i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ;	  
  i < n ;						      	i < n ;							      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 0 ;						  
    res = Math . max ( res , prefix_sum [ i ] - min_prefix_su 	  res = max ( res , prefix_sum [ i ] - min_prefix_sum ) ;     i < n ;							  
    min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum 	  min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ]    i ++ ) {							  
  }							      	}							    	res = max ( res , prefix_sum [ i ] - min_prefix_sum ) ;	  
  return res ;						      	return res ;						    	min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ]  
}							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER			      DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER			    DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER			  DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER
--							      --							    --								  --
static boolean isDvisibleBy12 ( String num ) {		      bool isDvisibleBy12 ( string num ) {			    bool isDvisibleBy12 ( string num ) {			  success : None
  if ( num . length ( ) >= 3 ) {			      	if ( num . length ( ) >= 3 ) {				      if ( num . length ( ) >= 3 ) {				  
    int d1 = ( int ) num . charAt ( num . length ( ) - 1 ) ;  	  int d1 = ( int ) num [ num . length ( ) - 1 ] ;	    	int d1 = ( int ) num [ num . length ( ) - 1 ] ;		  
    if ( d1 % 2 != 0 ) return false ;			      	  if ( d1 % 2 != 0 ) return ( 0 ) ;			    	if ( d1 % 2 != 0 ) return false ;			  
    int d2 = ( int ) num . charAt ( num . length ( ) - 2 ) ;  	  int d2 = ( int ) num [ num . length ( ) - 2 ] ;	    	int d2 = ( int ) num [ num . length ( ) - 2 ] ;		  
    int sum = 0 ;					      	  int sum = 0 ;						    	int sum = 0 ;						  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
    i < num . length ( ) ;				      	  i < num . length ( ) ;				    	i < num . length ( ) ;					  
    i ++ ) sum += num . charAt ( i ) ;			      	  i ++ ) sum += num [ i ] ;				    	i ++ ) {						  
    return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ;    	  return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ;    	  sum += num [ i ] ;					  
  }							      	}							    	}							  
  else {						      	else {							    	return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ;	  
    int number = Integer . parseInt ( num ) ;		      	  int number = stoi ( num ) ;				      }								  
    return ( number % 12 == 0 ) ;			      	  return ( number % 12 == 0 ) ;				      else {							  
  }							      	}							    	int number = atoi ( num . c_str ( ) ) ;			  
}							      }								    	return ( number % 12 == 0 ) ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM   REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM   REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM	  REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM
--							      --							    --								  --
static int remAnagram ( String str1 , String str2 ) {	      int remAnagram ( string str1 , string str2 ) {		    int remAnagram ( string str1 , string str2 ) {		  script_not_found : None
  int count1 [ ] = new int [ 26 ] ;			      	int count1 [ CHARS ] = {				      int count1 [ 26 ] ;					  
  int count2 [ ] = new int [ 26 ] ;			      	  0 }							      int count2 [ 26 ] ;					  
  for ( int i = 0 ;					      	  , count2 [ CHARS ] = {				      for ( int i = 0 ;						  
  i < str1 . length ( ) ;				      	    0 }							      i < str1 . length ( ) ;					  
  i ++ ) count1 [ str1 . charAt ( i ) - 'a' ] ++ ;	      	    ;							      i ++ ) {							  
  for ( int i = 0 ;					      	    for ( int i = 0 ;					    	count1 [ str1 [ i ] - 'a' ] ++ ;			  
  i < str2 . length ( ) ;				      	    str1 [ i ] != '\0' ;				      }								  
  i ++ ) count2 [ str2 . charAt ( i ) - 'a' ] ++ ;	      	    i ++ ) count1 [ str1 [ i ] - 'a' ] ++ ;		      for ( int i = 0 ;						  
  int result = 0 ;					      	    for ( int i = 0 ;					      i < str2 . length ( ) ;					  
  for ( int i = 0 ;					      	    str2 [ i ] != '\0' ;				      i ++ ) {							  
  i < 26 ;						      	    i ++ ) count2 [ str2 [ i ] - 'a' ] ++ ;		    	count2 [ str2 [ i ] - 'a' ] ++ ;			  
  i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) 	    int result = 0 ;					      }								  
  return result ;					      	    for ( int i = 0 ;					      int result = 0 ;						  
}							      	    i < 26 ;						      for ( int i = 0 ;						  
							      	    i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ;    i < 26 ;							  
							      	    return result ;					      i ++ ) {							  
							      	  }							    	result += abs ( count1 [ i ] - count2 [ i ] ) ;		  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS	      LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS	    LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS	  LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS
--							      --							    --								  --
static void minimizeWithKSwaps ( int arr [ ] , int n , int k  void minimizeWithKSwaps ( int arr [ ] , int n , int k ) {	    void minimizeWithKSwaps ( int arr [ ] , int n , int k ) {	  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 && k > 0 ;					      	i < n - 1 && k > 0 ;					      i < n - 1 && k > 0 ;					  
  ++ i ) {						      	++ i ) {						      ++ i ) {							  
    int pos = i ;					      	  int pos = i ;						    	int pos = i ;						  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    ++ j ) {						      	  ++ j ) {						    	++ j ) {						  
      if ( j - i > k ) break ;				      	    if ( j - i > k ) break ;				    	  if ( j - i > k ) break ;				  
      if ( arr [ j ] < arr [ pos ] ) pos = j ;		      	    if ( arr [ j ] < arr [ pos ] ) pos = j ;		    	  if ( arr [ j ] < arr [ pos ] ) pos = j ;		  
    }							      	  }							    	}							  
    int temp ;						      	  for ( int j = pos ;					    	int temp ;						  
    for ( int j = pos ;					      	  j > i ;						    	for ( int j = pos ;					  
    j > i ;						      	  -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ;		    	j > i ;							  
    -- j ) {						      	  k -= pos - i ;					    	-- j ) {						  
      temp = arr [ j ] ;				      	}							    	  temp = arr [ j ] ;					  
      arr [ j ] = arr [ j - 1 ] ;			      }								    	  arr [ j ] = arr [ j - 1 ] ;				  
      arr [ j - 1 ] = temp ;				      								    	  arr [ j - 1 ] = temp ;				  
    }							      								    	}							  
    k -= pos - i ;					      								    	k -= pos - i ;						  
  }							      								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS		      FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS		    FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS			  FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS
--							      --							    --								  --
static void relativeComplement ( int arr1 [ ] , int arr2 [ ]  void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n void relative_complement ( int arr1 [ ] , int arr2 [ ] , int  script_not_found : None
  int i = 0 , j = 0 ;					      	int i = 0 , j = 0 ;					      int i = 0 , j = 0 ;					  
  while ( i < n && j < m ) {				      	while ( i < n && j < m ) {				      while ( i < n && j < m ) {				  
    if ( arr1 [ i ] < arr2 [ j ] ) {			      	  if ( arr1 [ i ] < arr2 [ j ] ) {			    	if ( arr1 [ i ] < arr2 [ j ] ) {			  
      System . out . print ( arr1 [ i ] + " " ) ;	      	    cout << arr1 [ i ] << " " ;				    	  cout << arr1 [ i ] << " " ;				  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
    }							      	  }							    	}							  
    else if ( arr1 [ i ] > arr2 [ j ] ) {		      	  else if ( arr1 [ i ] > arr2 [ j ] ) {			    	else if ( arr1 [ i ] > arr2 [ j ] ) {			  
      j ++ ;						      	    j ++ ;						    	  j ++ ;						  
    }							      	  }							    	}							  
    else if ( arr1 [ i ] == arr2 [ j ] ) {		      	  else if ( arr1 [ i ] == arr2 [ j ] ) {		    	else if ( arr1 [ i ] == arr2 [ j ] ) {			  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
      j ++ ;						      	    j ++ ;						    	  j ++ ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  while ( i < n ) System . out . print ( arr1 [ i ] + " " ) ; 	while ( i < n ) cout << arr1 [ i ] << " " ;		      while ( i < n ) {						  
}							      }								    	cout << arr1 [ i ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY	      FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY	    FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY		  FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY
--							      --							    --								  --
static int findMin ( int arr [ ] , int low , int high ) {     int findMin ( int arr [ ] , int low , int high ) {	    int findMin ( int arr [ ] , int low , int high ) {		  success : identical to gold
  if ( high < low ) return arr [ 0 ] ;			      	if ( high < low ) return arr [ 0 ] ;			      if ( high < low ) return arr [ 0 ] ;			  
  if ( high == low ) return arr [ low ] ;		      	if ( high == low ) return arr [ low ] ;			      if ( high == low ) return arr [ low ] ;			  
  int mid = low + ( high - low ) / 2 ;			      	int mid = low + ( high - low ) / 2 ;			      int mid = low + ( high - low ) / 2 ;			  
  if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return a 	if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return a   if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return a 
  if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return ar 	if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return ar   if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return ar 
  if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , lo 	if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , lo   if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , lo 
  return findMin ( arr , mid + 1 , high ) ;		      	return findMin ( arr , mid + 1 , high ) ;		      return findMin ( arr , mid + 1 , high ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
INTERPOLATION_SEARCH					      INTERPOLATION_SEARCH					    INTERPOLATION_SEARCH					  INTERPOLATION_SEARCH
--							      --							    --								  --
static int interpolationSearch ( int x ) {		      int interpolationSearch ( int arr [ ] , int n , int x ) {	    int interpolationSearch ( int x ) {				  script_not_found : None
  int lo = 0 , hi = ( arr . length - 1 ) ;		      	int lo = 0 , hi = ( n - 1 ) ;				      int lo = 0 , hi = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) - 
  while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {  	while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {    while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {  
    if ( lo == hi ) {					      	  if ( lo == hi ) {					    	if ( lo == hi ) {					  
      if ( arr [ lo ] == x ) return lo ;		      	    if ( arr [ lo ] == x ) return lo ;			    	  if ( arr [ lo ] == x ) return lo ;			  
      return - 1 ;					      	    return - 1 ;					    	  return - 1 ;						  
    }							      	  }							    	}							  
    int pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo  	  int pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ]  	int pos = lo + ( ( ( hi - lo ) / ( arr [ hi ] - arr [ lo  
    if ( arr [ pos ] == x ) return pos ;		      	  if ( arr [ pos ] == x ) return pos ;			    	if ( arr [ pos ] == x ) return pos ;			  
    if ( arr [ pos ] < x ) lo = pos + 1 ;		      	  if ( arr [ pos ] < x ) lo = pos + 1 ;			    	if ( arr [ pos ] < x ) lo = pos + 1 ;			  
    else hi = pos - 1 ;					      	  else hi = pos - 1 ;					    	else hi = pos - 1 ;					  
  }							      	}							      }								  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1			      SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1			    SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1			  SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1
--							      --							    --								  --
static void diagonalsquare ( int mat [ ] [ ] , int row , int  void diagonalsquare ( int mat [ ] [ MAX ] , int row , int col void diagonalsquare ( int mat [ ] [ 2 ] , int row , int colum script_not_found : None
  System . out . print ( " Diagonal one : " ) ;		      	cout << " \nDiagonal one : " ;				      cout << "Diagonal one : " ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < row ;						      	i < row ;						      i < row ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) cout << mat [ i ] [ i ] * mat [ i ] [ i ] << " " ;	  
    System . out . print ( mat [ i ] [ i ] * mat [ i ] [ i ]  	  cout << mat [ i ] [ i ] * mat [ i ] [ i ] << " " ;	      cout << endl ;						  
  }							      	}							      cout << "Diagonal two : " ;				  
  System . out . println ( ) ;				      	cout << " \n\nDiagonal two : " ;			      for ( int i = 0 ;						  
  System . out . print ( " Diagonal two : " ) ;		      	for ( int i = 0 ;					      i < row ;							  
  for ( int i = 0 ;					      	i < row ;						      i ++ ) cout << mat [ i ] [ row - i - 1 ] * mat [ i ] [ row  
  i < row ;						      	i ++ ) {						    }								  
  i ++ ) {						      	  cout << mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i - 								  
    System . out . print ( mat [ i ] [ row - i - 1 ] * mat [  	}							    								  
  }							      }								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_ PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_ PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_ PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_
--							      --							    --								  --
static void swapUpperToLower ( int arr [ ] [ ] ) {	      void swapUpperToLower ( int arr [ n ] [ n ] ) {		    void swapUpperToLower ( int arr [ ] [ n ] ) {		  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      int temp = arr [ i ] [ j ] ;			      	    int temp = arr [ i ] [ j ] ;			    	  int temp = arr [ i ] [ j ] ;				  
      arr [ i ] [ j ] = arr [ j ] [ i ] ;		      	    arr [ i ] [ j ] = arr [ j ] [ i ] ;			    	  arr [ i ] [ j ] = arr [ j ] [ i ] ;			  
      arr [ j ] [ i ] = temp ;				      	    arr [ j ] [ i ] = temp ;				    	  arr [ j ] [ i ] = temp ;				  
    }							      	  }							    	}							  
  }							      	}							      }								  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) System . out . print ( arr [ i ] [ j ] + " " ) ;   	  j ++ ) cout << arr [ i ] [ j ] << " " ;		    	j ++ ) {						  
    System . out . println ( ) ;			      	  cout << endl ;					    	  cout << arr [ i ] [ j ] << " " ;			  
  }							      	}							    	}							  
}							      }								    	cout << endl ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
OVERLAPPING_SUM_TWO_ARRAY				      OVERLAPPING_SUM_TWO_ARRAY					    OVERLAPPING_SUM_TWO_ARRAY					  OVERLAPPING_SUM_TWO_ARRAY
--							      --							    --								  --
static int findSum ( int [ ] A , int [ ] B , int n ) {	      int findSum ( int A [ ] , int B [ ] , int n ) {		    int findSum ( int * A , int * B , int n ) {			  error : OVERLAPPING_SUM_TWO_ARRAY.cpp: In function
  HashMap < Integer , Integer > hash = new HashMap < > ( ) ;  	unordered_map < int , int > hash ;			      unordered_map < int , int > hash ;			   ‘int f_filled(int*, int*, int)’: OVERLAPPING_SUM_
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  TWO_ARRAY.cpp:52:37: error: request for member ‘c_
  i < n ;						      	i < n ;							      i < n ;							  str’ in ‘it.std::__detail::_Node_iterator<std::pai
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  r<const int, int>, false, false>::operator*().std:
    if ( hash . containsKey ( A [ i ] ) ) hash . put ( A [ i  	  hash [ A [ i ] ] ++ ;					    	if ( hash . count ( A [ i ] ) == 1 ) {			  :pair<const int, int>::second’, which is of non-cl
    else hash . put ( A [ i ] , 1 ) ;			      	  hash [ B [ i ] ] ++ ;					    	  hash [ A [ i ] ] = 1 + hash [ A [ i ] ] ;		  ass type ‘int’      if ( atoi ( ( * it ) . second
    if ( hash . containsKey ( B [ i ] ) ) hash . put ( B [ i  	}							    	}							  . c_str ( ) ) == 1 ) {
    else hash . put ( B [ i ] , 1 ) ;			      	int sum = 0 ;						    	else {							  	    ^~~~~ OVERLAPPING_SUM_TWO_ARRAY.cpp:53:4
  }							      	for ( auto x : hash ) if ( x . second == 1 ) sum += x . fir 	  hash [ A [ i ] ] = 1 ;				  0: error: request for member ‘c_str’ in ‘it.std::_
  int sum = 0 ;						      	return sum ;						    	}							  _detail::_Node_iterator<std::pair<const int, int>,
  for ( Map . Entry entry : hash . entrySet ( ) ) {	      }								    	if ( hash . count ( B [ i ] ) == 1 ) {			   false, false>::operator*().std::pair<const int, i
    if ( Integer . parseInt ( ( entry . getValue ( ) ) . toSt 								    	  hash [ B [ i ] ] = 1 + hash [ B [ i ] ] ;		  nt>::first’, which is of non-class type ‘const int
  }							      								    	}							  ’	   sum += atoi ( ( * it ) . first . c_str (
  return sum ;						      								    	else {							  ) ) ;						^~~~
}							      								    	  hash [ B [ i ] ] = 1 ;				  ~
							      								    	}							  
							      								      }								  
							      								      int sum = 0 ;						  
							      								      for ( unordered_map < int , int > :: iterator it = hash . b 
							      								      it != hash . end ( ) ;					  
							      								      it ++ ) {							  
							      								    	if ( atoi ( ( * it ) . second . c_str ( ) ) == 1 ) {	  
							      								    	  sum += atoi ( ( * it ) . first . c_str ( ) ) ;	  
							      								    	}							  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S	      FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S		    FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S		  FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S
--							      --							    --								  --
static int MaxDotProduct ( int A [ ] , int B [ ] , int m , in long long int MaxDotProduct ( int A [ ] , int B [ ] , int m , int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { error : FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERT
  int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;	      	long long int dp [ n + 1 ] [ m + 1 ] ;			      int dp [ n + 1 ] [ m + 1 ] ;				  ION_0S.cpp: In function ‘int f_filled(int*, int*,
  for ( int [ ] row : dp ) Arrays . fill ( row , 0 ) ;	      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int * row = dp ;					  int, int)’: FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_IN
  for ( int i = 1 ;					      	for ( int i = 1 ;					      row [ n ] [ m ] != 0 ;					  SERTION_0S.cpp:30:21: error: cannot convert ‘int (
  i <= n ;						      	i <= n ;						      row ++ ) {						  *)[(m + 1)]’ to ‘int*’ in initialization    for (
  i ++ ) for ( int j = i ;				      	i ++ ) for ( int j = i ;				    	memset ( row , 0 , sizeof ( int ) * n + 1 ) ;		  int * row = dp ;			^~ FIND_MAXI
  j <= m ;						      	j <= m ;						      }								  MUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S.cpp:31:17:
  j ++ ) dp [ i ] [ j ] = Math . max ( ( dp [ i - 1 ] [ j - 1 	j ++ ) dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + (    for ( int i = 1 ;						   error: invalid types ‘int[int]’ for array subscri
  return dp [ n ] [ m ] ;				      	return dp [ n ] [ m ] ;					      i <= n ;							  pt	row [ n ] [ m ] != 0 ;			^
}							      }								      i ++ ) for ( int j = i ;					  
							      								      j <= m ;							  
							      								      j ++ ) dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + (  
							      								      return dp [ n ] [ m ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M	      DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M	    DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M		  DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M
--							      --							    --								  --
static int numberofways ( int n , int m ) {		      int numberofways ( int n , int m ) {			    int numberofways ( int n , int m ) {			  failure : #Results: 9, 10
  int dp [ ] [ ] = new int [ n + 2 ] [ n + 2 ] ;	      	int dp [ n + 2 ] [ n + 2 ] ;				      int dp [ n + 2 ] [ n + 2 ] ;				  
  dp [ 0 ] [ n + 1 ] = 1 ;				      	memset ( dp , 0 , sizeof ( dp ) ) ;			      dp [ 0 ] [ n + 1 ] = 1 ;					  
  for ( int k = n ;					      	dp [ 0 ] [ n + 1 ] = 1 ;				      for ( int k = n ;						  
  k >= m ;						      	for ( int k = n ;					      k >= m ;							  
  k -- ) {						      	k >= m ;						      k -- ) {							  
    for ( int i = 0 ;					      	k -- ) {						    	for ( int i = 0 ;					  
    i <= n ;						      	  for ( int i = 0 ;					    	i <= n ;						  
    i ++ ) {						      	  i <= n ;						    	i ++ ) {						  
      dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ;		      	  i ++ ) {						    	  dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ;			  
      if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + d 	    dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ;		    	  if ( i - k >= 0 ) {					  
    }							      	    if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + d 	    dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k  
  }							      	  }							    	  }							  
  return dp [ n ] [ m ] ;				      	}							    	}							  
}							      	return dp [ n ] [ m ] ;					      }								  
							      }								      return dp [ n ] [ m ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2			      PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2			    PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2				  PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2
--							      --							    --								  --
public static int fib ( int n ) {			      int fib ( int n ) {					    int fib ( int n ) {						  script_not_found : None
  if ( n == 0 ) return 0 ;				      	if ( n == 0 ) return 0 ;				      if ( n == 0 ) return 0 ;					  
  if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ;	      	if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ;	      if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ;		  
  if ( f [ n ] != 0 ) return f [ n ] ;			      	if ( f [ n ] ) return f [ n ] ;				      if ( f [ n ] ) return f [ n ] ;				  
  int k = ( n & 1 ) == 1 ? ( n + 1 ) / 2 : n / 2 ;	      	int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 ;		      int k = ( n & 1 ) == 1 ? ( n + 1 ) / 2 : n / 2 ;		  
  f [ n ] = ( n & 1 ) == 1 ? ( fib ( k ) * fib ( k ) + fib (  	f [ n ] = ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1   f [ n ] = ( n & 1 ) == 1 ? ( fib ( k ) * fib ( k ) + fib (  
  return f [ n ] ;					      	return f [ n ] ;					      return f [ n ] ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_PREFIX_ALSO_SUFFIX_1				      LONGEST_PREFIX_ALSO_SUFFIX_1				    LONGEST_PREFIX_ALSO_SUFFIX_1				  LONGEST_PREFIX_ALSO_SUFFIX_1
--							      --							    --								  --
static int longestPrefixSuffix ( String s ) {		      int longestPrefixSuffix ( string s ) {			    int longestPrefixSuffix ( string s ) {			  success : None
  int n = s . length ( ) ;				      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
  int lps [ ] = new int [ n ] ;				      	int lps [ n ] ;						      int lps [ n ] ;						  
  lps [ 0 ] = 0 ;					      	lps [ 0 ] = 0 ;						      lps [ 0 ] = 0 ;						  
  int len = 0 ;						      	int len = 0 ;						      int len = 0 ;						  
  int i = 1 ;						      	int i = 1 ;						      int i = 1 ;						  
  while ( i < n ) {					      	while ( i < n ) {					      while ( i < n ) {						  
    if ( s . charAt ( i ) == s . charAt ( len ) ) {	      	  if ( s [ i ] == s [ len ] ) {				    	if ( s [ i ] == s [ len ] ) {				  
      len ++ ;						      	    len ++ ;						    	  len ++ ;						  
      lps [ i ] = len ;					      	    lps [ i ] = len ;					    	  lps [ i ] = len ;					  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
    }							      	  }							    	}							  
    else {						      	  else {						    	else {							  
      if ( len != 0 ) {					      	    if ( len != 0 ) {					    	  if ( len != 0 ) len = lps [ len - 1 ] ;		  
	len = lps [ len - 1 ] ;				      	      len = lps [ len - 1 ] ;				    	  else {						  
      }							      	    }							    	    lps [ i ] = 0 ;					  
      else {						      	    else {						    	    i ++ ;						  
	lps [ i ] = 0 ;					      	      lps [ i ] = 0 ;					    	  }							  
	i ++ ;						      	      i ++ ;						    	}							  
      }							      	    }							      }								  
    }							      	  }							      int res = lps [ n - 1 ] ;					  
  }							      	}							      return ( res > n / 2 ) ? n / 2 : res ;			  
  int res = lps [ n - 1 ] ;				      	int res = lps [ n - 1 ] ;				    }								  
  return ( res > n / 2 ) ? n / 2 : res ;		      	return ( res > n / 2 ) ? n / 2 : res ;			    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1
--							      --							    --								  --
static int numberOfPaths ( int m , int n ) {		      int numberOfPaths ( int m , int n ) {			    int numberOfPaths ( int m , int n ) {			  success : None
  int count [ ] [ ] = new int [ m ] [ n ] ;		      	int count [ m ] [ n ] ;					      vector < vector < int >> count ( m , vector < int > ( n , 0 
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m ;						      	i < m ;							      i < m ;							  
  i ++ ) count [ i ] [ 0 ] = 1 ;			      	i ++ ) count [ i ] [ 0 ] = 1 ;				      i ++ ) {							  
  for ( int j = 0 ;					      	for ( int j = 0 ;					    	count [ i ] [ 0 ] = 1 ;					  
  j < n ;						      	j < n ;							      }								  
  j ++ ) count [ 0 ] [ j ] = 1 ;			      	j ++ ) count [ 0 ] [ j ] = 1 ;				      for ( int j = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      j < n ;							  
  i < m ;						      	i < m ;							      j ++ ) {							  
  i ++ ) {						      	i ++ ) {						    	count [ 0 ] [ j ] = 1 ;					  
    for ( int j = 1 ;					      	  for ( int j = 1 ;					      }								  
    j < n ;						      	  j < n ;						      for ( int i = 1 ;						  
    j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count  	  j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count    i < m ;							  
  }							      	}							      i ++ ) {							  
  return count [ m - 1 ] [ n - 1 ] ;			      	return count [ m - 1 ] [ n - 1 ] ;			    	for ( int j = 1 ;					  
}							      }								    	j < n ;							  
							      								    	j ++ ) {						  
							      								    	  count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] 
							      								    	}							  
							      								      }								  
							      								      return count [ m - 1 ] [ n - 1 ] ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE     REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE	    REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE	  REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE
--							      --							    --								  --
public static void rearrange ( int arr [ ] , int n ) {	      void rearrange ( int arr [ ] , int n ) {			    void rearrange ( int arr [ ] , int n ) {			  success : None
  int max_idx = n - 1 , min_idx = 0 ;			      	int max_idx = n - 1 , min_idx = 0 ;			      int max_idx = n - 1 , min_idx = 0 ;			  
  int max_elem = arr [ n - 1 ] + 1 ;			      	int max_elem = arr [ n - 1 ] + 1 ;			      int max_elem = arr [ n - 1 ] + 1 ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( i % 2 == 0 ) {					      	  if ( i % 2 == 0 ) {					    	if ( i % 2 == 0 ) {					  
      arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem  	    arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem  	  arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem  
      max_idx -- ;					      	    max_idx -- ;					    	  max_idx -- ;						  
    }							      	  }							    	}							  
    else {						      	  else {						    	else {							  
      arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem  	    arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem  	  arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem  
      min_idx ++ ;					      	    min_idx ++ ;					    	  min_idx ++ ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) arr [ i ] = arr [ i ] / max_elem ;		      	i ++ ) arr [ i ] = arr [ i ] / max_elem ;		      i ++ ) {							  
}							      }								    	arr [ i ] = arr [ i ] / max_elem ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1	      FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1		    FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1		  FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1
--							      --							    --								  --
static int minCoins ( int coins [ ] , int m , int V ) {	      int minCoins ( int coins [ ] , int m , int V ) {		    int minCoins ( int coins [ ] , int m , int V ) {		  success : None
  int table [ ] = new int [ V + 1 ] ;			      	int table [ V + 1 ] ;					      int table [ V + 1 ] ;					  
  table [ 0 ] = 0 ;					      	table [ 0 ] = 0 ;					      table [ 0 ] = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= V ;						      	i <= V ;						      i <= V ;							  
  i ++ ) table [ i ] = Integer . MAX_VALUE ;		      	i ++ ) table [ i ] = INT_MAX ;				      i ++ ) {							  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	table [ i ] = INT_MAX ;					  
  i <= V ;						      	i <= V ;						      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 1 ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      i <= V ;							  
    j < m ;						      	  j < m ;						      i ++ ) {							  
    j ++ ) if ( coins [ j ] <= i ) {			      	  j ++ ) if ( coins [ j ] <= i ) {			    	for ( int j = 0 ;					  
      int sub_res = table [ i - coins [ j ] ] ;		      	    int sub_res = table [ i - coins [ j ] ] ;		    	j < m ;							  
      if ( sub_res != Integer . MAX_VALUE && sub_res + 1 < ta 	    if ( sub_res != INT_MAX && sub_res + 1 < table [ i ] )  	j ++ ) if ( coins [ j ] <= i ) {			  
    }							      	  }							    	  int sub_res = table [ i - coins [ j ] ] ;		  
  }							      	}							    	  if ( sub_res != INT_MAX && sub_res + 1 < table [ i ] )  
  return table [ V ] ;					      	return table [ V ] ;					    	    table [ i ] = sub_res + 1 ;				  
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return table [ V ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUBARRAY_WITH_GIVEN_SUM				      FIND_SUBARRAY_WITH_GIVEN_SUM				    FIND_SUBARRAY_WITH_GIVEN_SUM				  FIND_SUBARRAY_WITH_GIVEN_SUM
--							      --							    --								  --
int subArraySum ( int arr [ ] , int n , int sum ) {	      int subArraySum ( int arr [ ] , int n , int sum ) {	    int subArraySum ( int arr [ ] , int n , int sum ) {		  success : None
  int curr_sum , i , j ;				      	int curr_sum , i , j ;					      int curr_sum , i , j ;					  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    curr_sum = arr [ i ] ;				      	  curr_sum = arr [ i ] ;				    	curr_sum = arr [ i ] ;					  
    for ( j = i + 1 ;					      	  for ( j = i + 1 ;					    	for ( j = i + 1 ;					  
    j <= n ;						      	  j <= n ;						    	j <= n ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( curr_sum == sum ) {				      	    if ( curr_sum == sum ) {				    	  if ( curr_sum == sum ) {				  
	int p = j - 1 ;					      	      cout << "Sum found between indexes " << i << " and "  	    int p = j - 1 ;					  
	System . out . println ( "Sum found between indexes " 	      return 1 ;					    	    cout << "Sum found between indexes " << i << " and "  
	return 1 ;					      	    }							    	    return 1 ;						  
      }							      	    if ( curr_sum > sum || j == n ) break ;		    	  }							  
      if ( curr_sum > sum || j == n ) break ;		      	    curr_sum = curr_sum + arr [ j ] ;			    	  if ( curr_sum > sum || j == n ) break ;		  
      curr_sum = curr_sum + arr [ j ] ;			      	  }							    	  curr_sum = curr_sum + arr [ j ] ;			  
    }							      	}							    	}							  
  }							      	cout << "No subarray found" ;				      }								  
  System . out . println ( "No subarray found" ) ;	      	return 0 ;						      cout << "No subarray found" << endl ;			  
  return 0 ;						      }								      return 0 ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_SUBSEQUENCES				      COUNT_DISTINCT_SUBSEQUENCES				    COUNT_DISTINCT_SUBSEQUENCES					  COUNT_DISTINCT_SUBSEQUENCES
--							      --							    --								  --
static int countSub ( String str ) {			      int countSub ( string str ) {				    int countSub ( string str ) {				  script_not_found : None
  int [ ] last = new int [ MAX_CHAR ] ;			      	vector < int > last ( MAX_CHAR , - 1 ) ;		      vector < int > last ;					  
  Arrays . fill ( last , - 1 ) ;			      	int n = str . length ( ) ;				      memset ( last . begin ( ) , - 1 , sizeof ( last ) ) ;	  
  int n = str . length ( ) ;				      	int dp [ n + 1 ] ;					      int n = str . length ( ) ;				  
  int [ ] dp = new int [ n + 1 ] ;			      	dp [ 0 ] = 1 ;						      vector < int > dp ( n + 1 , 0 ) ;				  
  dp [ 0 ] = 1 ;					      	for ( int i = 1 ;					      dp [ 0 ] = 1 ;						  
  for ( int i = 1 ;					      	i <= n ;						      for ( int i = 1 ;						  
  i <= n ;						      	i ++ ) {						      i <= n ;							  
  i ++ ) {						      	  dp [ i ] = 2 * dp [ i - 1 ] ;				      i ++ ) {							  
    dp [ i ] = 2 * dp [ i - 1 ] ;			      	  if ( last [ str [ i - 1 ] ] != - 1 ) dp [ i ] = dp [ i ]  	dp [ i ] = 2 * dp [ i - 1 ] ;				  
    if ( last [ ( int ) str . charAt ( i - 1 ) ] != - 1 ) dp  	  last [ str [ i - 1 ] ] = ( i - 1 ) ;			    	if ( last [ ( int ) str [ i - 1 ] ] != - 1 ) {		  
    last [ ( int ) str . charAt ( i - 1 ) ] = ( i - 1 ) ;     	}							    	  dp [ i ] = dp [ i ] - dp [ last [ ( int ) str [ i - 1 ] 
  }							      	return dp [ n ] ;					    	}							  
  return dp [ n ] ;					      }								    	last [ ( int ) str [ i - 1 ] ] = ( i - 1 ) ;		  
}							      								      }								  
							      								      return dp [ n ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT
--							      --							    --								  --
static int minTimeForWritingChars ( int N , int insert , int  int minTimeForWritingChars ( int N , int insert , int remove  int minTimeForWritingChars ( int N , int insert , int remove  failure : #Results: 4, 10
  if ( N == 0 ) return 0 ;				      	if ( N == 0 ) return 0 ;				      if ( N == 0 ) return 0 ;					  
  if ( N == 1 ) return insert ;				      	if ( N == 1 ) return insert ;				      if ( N == 1 ) return insert ;				  
  int dp [ ] = new int [ N + 1 ] ;			      	int dp [ N + 1 ] ;					      int dp [ N + 1 ] ;					  
  for ( int i = 1 ;					      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int i = 1 ;						  
  i <= N ;						      	for ( int i = 1 ;					      i <= N ;							  
  i ++ ) {						      	i <= N ;						      i ++ ) {							  
    if ( i % 2 == 0 ) dp [ i ] = Math . min ( dp [ i - 1 ] +  	i ++ ) {						    	if ( i % 2 == 0 ) {					  
    else dp [ i ] = Math . min ( dp [ i - 1 ] + insert , dp [ 	  if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insert  	  dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ i / 2 ] + 
  }							      	  else dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i +  	}							  
  return dp [ N ] ;					      	}							    	else {							  
}							      	return dp [ N ] ;					    	  dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i + 1 ) 
							      }								    	}							  
							      								      }								  
							      								      return dp [ N ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING    SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING    SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING	  SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING
--							      --							    --								  --
static void splitString ( String str ) {		      void splitString ( string str ) {				    void splitString ( string str ) {				  script_not_found : None
  StringBuffer alpha = new StringBuffer ( ) , num = new Strin 	string alpha , num , special ;				      string alpha , num , special ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < str . length ( ) ;				      	i < str . length ( ) ;					      i < str . length ( ) ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( Character . isDigit ( str . charAt ( i ) ) ) num . a 	  if ( isdigit ( str [ i ] ) ) num . push_back ( str [ i ]  	if ( isdigit ( str [ i ] ) ) {				  
    else if ( Character . isAlphabetic ( str . charAt ( i ) ) 	  else if ( ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) || ( s 	  num += str [ i ] ;					  
    else special . append ( str . charAt ( i ) ) ;	      	  else special . push_back ( str [ i ] ) ;		    	}							  
  }							      	}							    	else if ( isalpha ( str [ i ] ) ) {			  
  System . out . println ( alpha ) ;			      	cout << alpha << endl ;					    	  alpha += str [ i ] ;					  
  System . out . println ( num ) ;			      	cout << num << endl ;					    	}							  
  System . out . println ( special ) ;			      	cout << special << endl ;				    	else {							  
}							      }								    	  special += str [ i ] ;				  
							      								    	}							  
							      								      }								  
							      								      cout << alpha << endl ;					  
							      								      cout << num << endl ;					  
							      								      cout << special << endl ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1	      MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1	    MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1	  MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1
--							      --							    --								  --
private static int minJumps ( int [ ] arr , int n ) {	      int minJumps ( int arr [ ] , int n ) {			    int min_jumps ( int * arr , int n ) {			  success : None
  int jumps [ ] = new int [ n ] ;			      	int * jumps = new int [ n ] ;				      int jumps [ n ] ;						  
  int i , j ;						      	int i , j ;						      int i , j ;						  
  if ( n == 0 || arr [ 0 ] == 0 ) return Integer . MAX_VALUE  	if ( n == 0 || arr [ 0 ] == 0 ) return INT_MAX ;	      if ( n == 0 || arr [ 0 ] == 0 ) return INT_MAX ;		  
  jumps [ 0 ] = 0 ;					      	jumps [ 0 ] = 0 ;					      jumps [ 0 ] = 0 ;						  
  for ( i = 1 ;						      	for ( i = 1 ;						      for ( i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    jumps [ i ] = Integer . MAX_VALUE ;			      	  jumps [ i ] = INT_MAX ;				    	jumps [ i ] = INT_MAX ;					  
    for ( j = 0 ;					      	  for ( j = 0 ;						    	for ( j = 0 ;						  
    j < i ;						      	  j < i ;						    	j < i ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( i <= j + arr [ j ] && jumps [ j ] != Integer . MAX 	    if ( i <= j + arr [ j ] && jumps [ j ] != INT_MAX ) {   	  if ( i <= j + arr [ j ] && jumps [ j ] != INT_MAX ) {	  
	jumps [ i ] = Math . min ( jumps [ i ] , jumps [ j ]  	      jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) ; 	    jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) ; 
	break ;						      	      break ;						    	    break ;						  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return jumps [ n - 1 ] ;				      	return jumps [ n - 1 ] ;				      return jumps [ n - 1 ] ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FREQUENCY_ELEMENT_UNSORTED_ARRAY			      FREQUENCY_ELEMENT_UNSORTED_ARRAY				    FREQUENCY_ELEMENT_UNSORTED_ARRAY				  FREQUENCY_ELEMENT_UNSORTED_ARRAY
--							      --							    --								  --
static void countFreq ( int [ ] a , int n ) {		      void countFreq ( int a [ ] , int n ) {			    void countFreq ( int a [ ] , int n ) {			  script_not_found : None
  HashMap < Integer , Integer > hm = new HashMap < > ( ) ;    	unordered_map < int , int > hm ;			      unordered_map < int , int > hm ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) == null ?  	i ++ ) hm [ a [ i ] ] ++ ;				      i ++ ) {							  
  SortedMap < Integer , Integer > st = new TreeMap < > ( ) ;  	set < pair < int , int >> st ;				    	hm [ a [ i ] ] = hm [ a [ i ] ] == 0 ? 1 : hm [ a [ i ] ] 
  for ( HashMap . Entry < Integer , Integer > x : hm . entryS 	for ( auto x : hm ) {					      }								  
    st . put ( x . getKey ( ) , x . getValue ( ) ) ;	      	  st . insert ( {					      unordered_map < int , int > :: iterator st = hm . begin ( ) 
  }							      	    x . first , x . second }				      for ( int x : hm ) st ++ ;				  
  int cumul = 0 ;					      	    ) ;							      int cumul = 0 ;						  
  for ( SortedMap . Entry < Integer , Integer > x : st . entr 	  }							      for ( int x : st ) {					  
    cumul += x . getValue ( ) ;				      	  int cumul = 0 ;					    	cumul += x ;						  
    System . out . println ( x . getKey ( ) + " " + cumul ) ; 	  for ( auto x : st ) {					    	cout << x << " " << cumul << endl ;			  
  }							      	    cumul += x . second ;				      }								  
}							      	    cout << x . first << " " << cumul << endl ;		    }								  
							      	  }							    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE	      CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE	    CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE	  CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE
--							      --							    --								  --
static int isChangeable ( int notes [ ] , int n ) {	      int isChangeable ( int notes [ ] , int n ) {		    int isChangeable ( int notes [ ] , int n ) {		  success : None
  int fiveCount = 0 ;					      	int fiveCount = 0 ;					      int fiveCount = 0 ;					  
  int tenCount = 0 ;					      	int tenCount = 0 ;					      int tenCount = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( notes [ i ] == 5 ) fiveCount ++ ;		      	  if ( notes [ i ] == 5 ) fiveCount ++ ;		    	if ( notes [ i ] == 5 ) {				  
    else if ( notes [ i ] == 10 ) {			      	  else if ( notes [ i ] == 10 ) {			    	  fiveCount ++ ;					  
      if ( fiveCount > 0 ) {				      	    if ( fiveCount > 0 ) {				    	}							  
	fiveCount -- ;					      	      fiveCount -- ;					    	else if ( notes [ i ] == 10 ) {				  
	tenCount ++ ;					      	      tenCount ++ ;					    	  if ( fiveCount > 0 ) {				  
      }							      	    }							    	    fiveCount -- ;					  
      else return 0 ;					      	    else return 0 ;					    	    tenCount ++ ;					  
    }							      	  }							    	  }							  
    else {						      	  else {						    	  else {						  
      if ( fiveCount > 0 && tenCount > 0 ) {		      	    if ( fiveCount > 0 && tenCount > 0 ) {		    	    return 0 ;						  
	fiveCount -- ;					      	      fiveCount -- ;					    	  }							  
	tenCount -- ;					      	      tenCount -- ;					    	}							  
      }							      	    }							    	else {							  
      else if ( fiveCount >= 3 ) {			      	    else if ( fiveCount >= 3 ) {			    	  if ( fiveCount > 0 && tenCount > 0 ) {		  
	fiveCount -= 3 ;				      	      fiveCount -= 3 ;					    	    fiveCount -- ;					  
      }							      	    }							    	    tenCount -- ;					  
      else return 0 ;					      	    else return 0 ;					    	  }							  
    }							      	  }							    	  else if ( fiveCount >= 3 ) {				  
  }							      	}							    	    fiveCount -= 3 ;					  
  return 1 ;						      	return 1 ;						    	  }							  
}							      }								    	  else {						  
							      								    	    return 0 ;						  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_INSERTIONS_SORT_ARRAY				      MINIMUM_INSERTIONS_SORT_ARRAY				    MINIMUM_INSERTIONS_SORT_ARRAY				  MINIMUM_INSERTIONS_SORT_ARRAY
--							      --							    --								  --
static int minInsertionStepToSortArray ( int arr [ ] , int N  int minInsertionStepToSortArray ( int arr [ ] , int N ) {	    int minInsertionStepToSortArray ( int arr [ ] , int N ) {	  success : None
  int [ ] lis = new int [ N ] ;				      	int lis [ N ] ;						      int lis [ N ] ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) lis [ i ] = 1 ;				      	i ++ ) lis [ i ] = 1 ;					      i ++ ) {							  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	lis [ i ] = 1 ;						  
  i < N ;						      	i < N ;							      }								  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      for ( int i = 1 ;						  
  j < i ;						      	j < i ;							      i < N ;							  
  j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] 	j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ]   i ++ ) for ( int j = 0 ;					  
  int max = 0 ;						      	int max = 0 ;						      j < i ;							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] 
  i < N ;						      	i < N ;							      int max = 0 ;						  
  i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;	      	i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;		      for ( int i = 0 ;						  
  return ( N - max ) ;					      	return ( N - max ) ;					      i < N ;							  
}							      }								      i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;		  
							      								      return ( N - max ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1		      COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1		    COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1		  COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1
--							      --							    --								  --
static int countDecodingDP ( char digits [ ] , int n ) {      int countDecodingDP ( char * digits , int n ) {		    int countDecodingDP ( char digits [ ] , int n ) {		  script_not_found : None
  int count [ ] = new int [ n + 1 ] ;			      	int count [ n + 1 ] ;					      int count [ n + 1 ] ;					  
  count [ 0 ] = 1 ;					      	count [ 0 ] = 1 ;					      count [ 0 ] = 1 ;						  
  count [ 1 ] = 1 ;					      	count [ 1 ] = 1 ;					      count [ 1 ] = 1 ;						  
  if ( digits [ 0 ] == '0' ) return 0 ;			      	if ( digits [ 0 ] == '0' ) return 0 ;			      if ( digits [ 0 ] == '0' ) return 0 ;			  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    count [ i ] = 0 ;					      	  count [ i ] = 0 ;					    	count [ i ] = 0 ;					  
    if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 	  if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 	if ( digits [ i - 1 ] > '0' ) {				  
    if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' 	  if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' 	  count [ i ] = count [ i - 1 ] ;			  
  }							      	}							    	}							  
  return count [ n ] ;					      	return count [ n ] ;					    	if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2' 
}							      }								    	  count [ i ] += count [ i - 2 ] ;			  
							      								    	}							  
							      								      }								  
							      								      return count [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_BINOMIAL_COEFFICIENTS				      SUM_BINOMIAL_COEFFICIENTS					    SUM_BINOMIAL_COEFFICIENTS					  SUM_BINOMIAL_COEFFICIENTS
--							      --							    --								  --
static int binomialCoeffSum ( int n ) {			      int binomialCoeffSum ( int n ) {				    int binomialCoeffSum ( int n ) {				  success : None
  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;		      	int C [ n + 1 ] [ n + 1 ] ;				      int C [ n + 1 ] [ n + 1 ] ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= Math . min ( i , n ) ;				      	  j <= min ( i , n ) ;					    	j <= min ( i , n ) ;					  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;	      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  if ( j == 0 || j == i ) {				  
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	    else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	    C [ i ] [ j ] = 1 ;					  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  int sum = 0 ;						      	int sum = 0 ;						    	    C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ 
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	  }							  
  i <= n ;						      	i <= n ;						    	}							  
  i ++ ) sum += C [ n ] [ i ] ;				      	i ++ ) sum += C [ n ] [ i ] ;				      }								  
  return sum ;						      	return sum ;						      int sum = 0 ;						  
}							      }								      for ( int i = 0 ;						  
							      								      i <= n ;							  
							      								      i ++ ) {							  
							      								    	sum += C [ n ] [ i ] ;					  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY		      PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY		    PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY		  PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY
--							      --							    --								  --
public static void printPairs ( int arr [ ] , int n ) {	      void printPairs ( int arr [ ] , int n ) {			    void printPairs ( int arr [ ] , int n ) {			  script_not_found : None
  Vector < Integer > v = new Vector < Integer > ( ) ;	      	vector < int > v ;					      vector < int > v ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) if ( Math . abs ( arr [ i ] ) == Math . abs ( arr [  	j ++ ) if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . pu   j ++ ) if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . pu 
  if ( v . size ( ) == 0 ) return ;			      	if ( v . size ( ) == 0 ) return ;			      if ( v . size ( ) == 0 ) return ;				  
  Collections . sort ( v ) ;				      	sort ( v . begin ( ) , v . end ( ) ) ;			      sort ( v . begin ( ) , v . end ( ) ) ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < v . size ( ) ;					      	i < v . size ( ) ;					      i < v . size ( ) ;					  
  i ++ ) System . out . print ( - v . get ( i ) + " " + v . g 	i ++ ) cout << - v [ i ] << " " << v [ i ] ;		      i ++ ) cout << - v [ i ] << " " << v [ i ] << endl ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PANGRAM_CHECKING					      PANGRAM_CHECKING						    PANGRAM_CHECKING						  PANGRAM_CHECKING
--							      --							    --								  --
public static boolean checkPangram ( String str ) {	      bool checkPangram ( string & str ) {			    bool checkPangram ( string str ) {				  success : None
  boolean [ ] mark = new boolean [ 26 ] ;		      	vector < bool > mark ( 26 , false ) ;			      bool mark [ 26 ] ;					  
  int index = 0 ;					      	int index ;						      int index = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < str . length ( ) ;				      	i < str . length ( ) ;					      i < str . length ( ) ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( 'A' <= str . charAt ( i ) && str . charAt ( i ) <= ' 	  if ( 'A' <= str [ i ] && str [ i ] <= 'Z' ) index = str [ 	if ( 'A' <= str [ i ] && str [ i ] <= 'Z' ) {		  
    else if ( 'a' <= str . charAt ( i ) && str . charAt ( i ) 	  else if ( 'a' <= str [ i ] && str [ i ] <= 'z' ) index =  	  index = str [ i ] - 'A' ;				  
    mark [ index ] = true ;				      	  mark [ index ] = true ;				    	}							  
  }							      	}							    	else if ( 'a' <= str [ i ] && str [ i ] <= 'z' ) {	  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	  index = str [ i ] - 'a' ;				  
  i <= 25 ;						      	i <= 25 ;						    	}							  
  i ++ ) if ( mark [ i ] == false ) return ( false ) ;	      	i ++ ) if ( mark [ i ] == false ) return ( false ) ;	    	mark [ index ] = true ;					  
  return ( true ) ;					      	return ( true ) ;					      }								  
}							      }								      for ( int i = 0 ;						  
							      								      i <= 25 ;							  
							      								      i ++ ) if ( mark [ i ] == false ) return ( false ) ;	  
							      								      return ( true ) ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES
--							      --							    --								  --
static int countNum ( int arr [ ] , int n ) {		      int countNum ( int arr [ ] , int n ) {			    int countNum ( int arr [ ] , int n ) {			  script_not_found : None
  HashSet < Integer > s = new HashSet < > ( ) ;		      	unordered_set < int > s ;				      set < int > s ;						  
  int count = 0 , maxm = Integer . MIN_VALUE , minm = Integer 	int count = 0 , maxm = INT_MIN , minm = INT_MAX ;	      int count = 0 , maxm = INT_MIN , minm = INT_MAX ;		  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    s . add ( arr [ i ] ) ;				      	  s . insert ( arr [ i ] ) ;				    	s . insert ( arr [ i ] ) ;				  
    if ( arr [ i ] < minm ) minm = arr [ i ] ;		      	  if ( arr [ i ] < minm ) minm = arr [ i ] ;		    	if ( arr [ i ] < minm ) minm = arr [ i ] ;		  
    if ( arr [ i ] > maxm ) maxm = arr [ i ] ;		      	  if ( arr [ i ] > maxm ) maxm = arr [ i ] ;		    	if ( arr [ i ] > maxm ) maxm = arr [ i ] ;		  
  }							      	}							      }								  
  for ( int i = minm ;					      	for ( int i = minm ;					      for ( int i = minm ;					  
  i <= maxm ;						      	i <= maxm ;						      i <= maxm ;						  
  i ++ ) if ( ! s . contains ( i ) ) count ++ ;		      	i ++ ) if ( s . find ( arr [ i ] ) == s . end ( ) ) count +   i ++ ) if ( ! s . count ( i ) ) count ++ ;		  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS
--							      --							    --								  --
static int countGroups ( int position , int previous_sum , in int countGroups ( int position , int previous_sum , int lengt int countGroups ( int position , int previous_sum , int lengt script_not_found : None
  if ( position == length ) return 1 ;			      	if ( position == length ) return 1 ;			      if ( position == length ) return 1 ;			  
  if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [  	if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [    if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [  
  dp [ position ] [ previous_sum ] = 0 ;		      	dp [ position ] [ previous_sum ] = 0 ;			      dp [ position ] [ previous_sum ] = 0 ;			  
  int res = 0 ;						      	int res = 0 ;						      int res = 0 ;						  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = position ;				      	for ( int i = position ;				      for ( int i = position ;					  
  i < length ;						      	i < length ;						      i < length ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    sum += ( num [ i ] - '0' ) ;			      	  sum += ( num [ i ] - '0' ) ;				    	sum += ( num [ i ] - '0' ) ;				  
    if ( sum >= previous_sum ) res += countGroups ( i + 1 , s 	  if ( sum >= previous_sum ) res += countGroups ( i + 1 , s 	if ( sum >= previous_sum ) {				  
  }							      	}							    	  res += countGroups ( i + 1 , sum , length , num ) ;	  
  dp [ position ] [ previous_sum ] = res ;		      	dp [ position ] [ previous_sum ] = res ;		    	}							  
  return res ;						      	return res ;						      }								  
}							      }								      dp [ position ] [ previous_sum ] = res ;			  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S			      LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S			    LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S			  LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S
--							      --							    --								  --
static int lenOfLongSubarr ( int arr [ ] , int n ) {	      int lenOfLongSubarr ( int arr [ ] , int n ) {		    int lenOfLongSubarr ( int arr [ ] , int n ) {		  success : None
  HashMap < Integer , Integer > um = new HashMap < Integer ,  	unordered_map < int , int > um ;			      unordered_map < int , int > um ;				  
  int sum = 0 , maxLen = 0 ;				      	int sum = 0 , maxLen = 0 ;				      int sum = 0 , maxLen = 0 ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    sum += arr [ i ] == 0 ? - 1 : 1 ;			      	  sum += arr [ i ] == 0 ? - 1 : 1 ;			    	sum += arr [ i ] == 0 ? - 1 : 1 ;			  
    if ( sum == 1 ) maxLen = i + 1 ;			      	  if ( sum == 1 ) maxLen = i + 1 ;			    	if ( sum == 1 ) maxLen = i + 1 ;			  
    else if ( ! um . containsKey ( sum ) ) um . put ( sum , i 	  else if ( um . find ( sum ) == um . end ( ) ) um [ sum ]  	else if ( ! um . count ( sum ) ) um [ sum ] = i ;	  
    if ( um . containsKey ( sum - 1 ) ) {		      	  if ( um . find ( sum - 1 ) != um . end ( ) ) {	    	if ( um . count ( sum - 1 ) ) {				  
      if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i 	    if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um  	  if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return maxLen ;					      	return maxLen ;						      return maxLen ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS	      LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS	    LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS	  LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS
--							      --							    --								  --
public static void findFibSubset ( Integer [ ] x ) {	      void findFibSubset ( int arr [ ] , int n ) {		    void findFibSubset ( int32_t * x ) {			  script_not_found : None
  Integer max = Collections . max ( Arrays . asList ( x ) ) ; 	int max = * std :: max_element ( arr , arr + n ) ;	      int32_t max = std :: max ( * x , * x + max ) ;		  
  List < Integer > fib = new ArrayList < Integer > ( ) ;      	int a = 0 , b = 1 ;					      std :: vector < int32_t > fib ;				  
  List < Integer > result = new ArrayList < Integer > ( ) ;   	unordered_set < int > hash ;				      std :: vector < int32_t > result ;			  
  Integer a = 0 ;					      	hash . insert ( a ) ;					      int32_t a = 0 ;						  
  Integer b = 1 ;					      	hash . insert ( b ) ;					      int32_t b = 1 ;						  
  while ( b < max ) {					      	while ( b < max ) {					      while ( b < max ) {					  
    Integer c = a + b ;					      	  int c = a + b ;					    	int32_t c = a + b ;					  
    a = b ;						      	  a = b ;						    	a = b ;							  
    b = c ;						      	  b = c ;						    	b = c ;							  
    fib . add ( c ) ;					      	  hash . insert ( b ) ;					    	fib . push_back ( c ) ;					  
  }							      	}							      }								  
  for ( Integer i = 0 ;					      	for ( int i = 0 ;					      for ( int32_t i = 0 ;					  
  i < x . length ;					      	i < n ;							      i < x [ 0 ] ;						  
  i ++ ) {						      	i ++ ) if ( hash . find ( arr [ i ] ) != hash . end ( ) ) p   i ++ ) {							  
    if ( fib . contains ( x [ i ] ) ) {			      }								    	if ( fib . find ( x [ i ] ) != fib . end ( ) ) result . p 
      result . add ( x [ i ] ) ;			      								      }								  
    }							      								      std :: cout << result << std :: endl ;			  
  }							      								    }								  
  System . out . println ( result ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUBARRAY_WITH_GIVEN_SUM_1				      FIND_SUBARRAY_WITH_GIVEN_SUM_1				    FIND_SUBARRAY_WITH_GIVEN_SUM_1				  FIND_SUBARRAY_WITH_GIVEN_SUM_1
--							      --							    --								  --
int subArraySum ( int arr [ ] , int n , int sum ) {	      int subArraySum ( int arr [ ] , int n , int sum ) {	    int subArraySum ( int arr [ ] , int n , int sum ) {		  success : None
  int curr_sum = arr [ 0 ] , start = 0 , i ;		      	int curr_sum = arr [ 0 ] , start = 0 , i ;		      int currSum = arr [ 0 ] , start = 0 , i ;			  
  for ( i = 1 ;						      	for ( i = 1 ;						      for ( i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    while ( curr_sum > sum && start < i - 1 ) {		      	  while ( curr_sum > sum && start < i - 1 ) {		    	while ( currSum > sum && start < i - 1 ) {		  
      curr_sum = curr_sum - arr [ start ] ;		      	    curr_sum = curr_sum - arr [ start ] ;		    	  currSum = currSum - arr [ start ] ;			  
      start ++ ;					      	    start ++ ;						    	  start ++ ;						  
    }							      	  }							    	}							  
    if ( curr_sum == sum ) {				      	  if ( curr_sum == sum ) {				    	if ( currSum == sum ) {					  
      int p = i - 1 ;					      	    cout << "Sum found between indexes " << start << " and  	  int p = i - 1 ;					  
      System . out . println ( "Sum found between indexes " + 	    return 1 ;						    	  cout << "Sum found between indexes " << start << " and  
      return 1 ;					      	  }							    	  return 1 ;						  
    }							      	  if ( i < n ) curr_sum = curr_sum + arr [ i ] ;	    	}							  
    if ( i < n ) curr_sum = curr_sum + arr [ i ] ;	      	}							    	if ( i < n ) {						  
  }							      	cout << "No subarray found" ;				    	  currSum = currSum + arr [ i ] ;			  
  System . out . println ( "No subarray found" ) ;	      	return 0 ;						    	}							  
  return 0 ;						      }								      }								  
}							      								      cout << "No subarray found" << endl ;			  
							      								      return 0 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE			      MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE			    MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE			  MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE
--							      --							    --								  --
static int lis ( int [ ] arr , int n ) {		      ll lis ( ll arr [ ] , ll n ) {				    int lis ( int * arr , int n ) {				  script_not_found : None
  int [ ] mpis = new int [ n ] ;			      	ll mpis [ n ] ;						      int mpis [ n ] ;						  
  int max = Integer . MIN_VALUE ;			      	for ( int i = 0 ;					      int max = INT_MIN ;					  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) mpis [ i ] = arr [ i ] ;				      i < n ;							  
  i ++ ) mpis [ i ] = arr [ i ] ;			      	for ( int i = 1 ;					      i ++ ) {							  
  for ( int i = 1 ;					      	i < n ;							    	mpis [ i ] = arr [ i ] ;				  
  i < n ;						      	i ++ ) for ( int j = 0 ;				      }								  
  i ++ ) for ( int j = 0 ;				      	j < i ;							      for ( int i = 1 ;						  
  j < i ;						      	j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [    i < n ;							  
  j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [  	return * max_element ( mpis , mpis + n ) ;		      i ++ ) for ( int j = 0 ;					  
  for ( int k = 0 ;					      }								      j < i ;							  
  k < mpis . length ;					      								      j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [  
  k ++ ) {						      								      for ( int k = 0 ;						  
    if ( mpis [ k ] > max ) {				      								      k < mpis [ 0 ] ;						  
      max = mpis [ k ] ;				      								      k ++ ) {							  
    }							      								    	if ( mpis [ k ] > max ) max = mpis [ k ] ;		  
  }							      								      }								  
  return max ;						      								      return max ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ENTRINGER_NUMBER_1					      ENTRINGER_NUMBER_1					    ENTRINGER_NUMBER_1						  ENTRINGER_NUMBER_1
--							      --							    --								  --
static int zigzag ( int n , int k ) {			      int zigzag ( int n , int k ) {				    int zigzag ( int n , int k ) {				  script_not_found : None
  int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ;	      	int dp [ n + 1 ] [ k + 1 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( k +  
  dp [ 0 ] [ 0 ] = 1 ;					      	memset ( dp , 0 , sizeof ( dp ) ) ;			      dp [ 0 ] [ 0 ] = 1 ;					  
  for ( int i = 1 ;					      	dp [ 0 ] [ 0 ] = 1 ;					      for ( int i = 1 ;						  
  i <= n ;						      	for ( int i = 1 ;					      i <= n ;							  
  i ++ ) dp [ i ] [ 0 ] = 0 ;				      	i <= n ;						      i ++ ) {							  
  for ( int i = 1 ;					      	i ++ ) dp [ i ] [ 0 ] = 0 ;				    	dp [ i ] [ 0 ] = 0 ;					  
  i <= n ;						      	for ( int i = 1 ;					      }								  
  i ++ ) {						      	i <= n ;						      for ( int i = 1 ;						  
    for ( int j = 1 ;					      	i ++ ) {						      i <= n ;							  
    j <= Math . min ( i , k ) ;				      	  for ( int j = 1 ;					      i ++ ) {							  
    j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] 	  j <= i ;						    	for ( int j = 1 ;					  
  }							      	  j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] 	j <= min ( i , k ) ;					  
  return dp [ n ] [ k ] ;				      	  return dp [ n ] [ k ] ;				    	j ++ ) {						  
}							      	}							    	  dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i  
							      	int main ( ) {						    	}							  
							      	  int n = 4 , k = 3 ;					      }								  
							      	  cout << zigzag ( n , k ) << endl ;			      return dp [ n ] [ k ] ;					  
							      	  return 0 ;						    }								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE		      FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE			    FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE			  FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE
--							      --							    --								  --
boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { bool find3Numbers ( int A [ ] , int arr_size , int sum ) {    bool find3Numbers ( int A [ ] , int arr_size , int sum ) {	  success : None
  int l , r ;						      	int l , r ;						      int l , r ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < arr_size - 2 ;					      	i < arr_size - 2 ;					      i < arr_size - 2 ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < arr_size - 1 ;					      	  j < arr_size - 1 ;					    	j < arr_size - 1 ;					  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      for ( int k = j + 1 ;				      	    for ( int k = j + 1 ;				    	  for ( int k = j + 1 ;					  
      k < arr_size ;					      	    k < arr_size ;					    	  k < arr_size ;					  
      k ++ ) {						      	    k ++ ) {						    	  k ++ ) {						  
	if ( A [ i ] + A [ j ] + A [ k ] == sum ) {	      	      if ( A [ i ] + A [ j ] + A [ k ] == sum ) {	    	    if ( A [ i ] + A [ j ] + A [ k ] == sum ) {		  
	  System . out . print ( "Triplet is " + A [ i ] + ", 		cout << "Triplet is " << A [ i ] << ", " << A [ j ] 	      cout << "Triplet is " << A [ i ] << ", " << A [ j ] 
	  return true ;					      		return true ;					    	      return true ;					  
	}						      	      }							    	    }							  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return false ;					      	return false ;						      return false ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE	      FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE	    FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE	  FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE
--							      --							    --								  --
private static void printDuplicates ( int [ ] arr , int n ) { void printDuplicates ( int arr [ ] , int n ) {		    static void printDuplicates ( int * arr , int n ) {		  script_not_found : None
  Map < Integer , Integer > map = new HashMap < > ( ) ;	      	unordered_map < int , int > freq ;			      map < int , int > map ;					  
  int count = 0 ;					      	for ( int i = 0 ;					      int count = 0 ;						  
  boolean dup = false ;					      	i < n ;							      bool dup = false ;					  
  for ( int i = 0 ;					      	i ++ ) freq [ arr [ i ] ] ++ ;				      for ( int i = 0 ;						  
  i < n ;						      	bool dup = false ;					      i < n ;							  
  i ++ ) {						      	unordered_map < int , int > :: iterator itr ;		      i ++ ) {							  
    if ( map . containsKey ( arr [ i ] ) ) {		      	for ( itr = freq . begin ( ) ;				    	if ( map . find ( arr [ i ] ) != map . end ( ) ) {	  
      count = map . get ( arr [ i ] ) ;			      	itr != freq . end ( ) ;					    	  count = map [ arr [ i ] ] ;				  
      map . put ( arr [ i ] , count + 1 ) ;		      	itr ++ ) {						    	  map [ arr [ i ] ] = count + 1 ;			  
    }							      	  if ( itr -> second > 1 ) {				    	}							  
    else {						      	    cout << itr -> first << " " ;			    	else {							  
      map . put ( arr [ i ] , 1 ) ;			      	    dup = true ;					    	  map [ arr [ i ] ] = 1 ;				  
    }							      	  }							    	}							  
  }							      	}							      }								  
  for ( Entry < Integer , Integer > entry : map . entrySet (  	if ( dup == false ) cout << "-1" ;			      for ( map . find ( arr [ n ] ) != map . end ( ) ) {	  
    if ( entry . getValue ( ) > 1 ) {			      }								    	if ( map [ arr [ n ] ] > 1 ) {				  
      System . out . print ( entry . getKey ( ) + " " ) ;     								    	  cout << map [ arr [ n ] ] << " " ;			  
      dup = true ;					      								    	  dup = true ;						  
    }							      								    	}							  
  }							      								      }								  
  if ( ! dup ) {					      								      if ( ! dup ) cout << "-1" ;				  
    System . out . println ( "-1" ) ;			      								    }								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DELANNOY_NUMBER_1					      DELANNOY_NUMBER_1						    DELANNOY_NUMBER_1						  DELANNOY_NUMBER_1
--							      --							    --								  --
static int dealnnoy ( int n , int m ) {			      int dealnnoy ( int n , int m ) {				    int dealnnoy ( int n , int m ) {				  error : double free or corruption (out) /bin/bash:
  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	int dp [ m + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( m + 1 , vector < int > ( n +   line 1: 3926456 Aborted		   (core dum
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  ped) ./DELANNOY_NUMBER_1_cpp
  i <= m ;						      	i <= m ;						      i <= m ;							  
  i ++ ) dp [ i ] [ 0 ] = 1 ;				      	i ++ ) dp [ i ] [ 0 ] = 1 ;				      i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	dp [ i ] [ 0 ] = 1 ;					  
  i < m ;						      	i <= m ;						      }								  
  i ++ ) dp [ 0 ] [ i ] = 1 ;				      	i ++ ) dp [ 0 ] [ i ] = 1 ;				      for ( int i = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      i < m ;							  
  i <= m ;						      	i <= m ;						      i ++ ) {							  
  i ++ ) for ( int j = 1 ;				      	i ++ ) for ( int j = 1 ;				    	dp [ 0 ] [ i ] = 1 ;					  
  j <= n ;						      	j <= n ;						      }								  
  j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ 	j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [   for ( int i = 1 ;						  
  return dp [ m ] [ n ] ;				      	return dp [ m ] [ n ] ;					      i <= m ;							  
}							      }								      i ++ ) for ( int j = 1 ;					  
							      								      j <= n ;							  
							      								      j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ 
							      								      return dp [ m ] [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1			      FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1			    FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1			  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
--							      --							    --								  --
static boolean isRectangle ( int m [ ] [ ] ) {		      bool isRectangle ( const vector < vector < int >> & m ) {	    bool isRectangle ( int m [ ] [ 2 ] ) {			  error : FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1.cpp
  int rows = m . length ;				      	int rows = m . size ( ) ;				      int rows = m [ 0 ] [ 0 ] ;				  : In function ‘int main()’: FIND_RECTANGLE_BINARY_
  if ( rows == 0 ) return false ;			      	if ( rows == 0 ) return false ;				      if ( rows == 0 ) return false ;				  MATRIX_CORNERS_1.cpp:61:30: error: cannot convert
  int columns = m [ 0 ] . length ;			      	int columns = m [ 0 ] . size ( ) ;			      int columns = m [ 0 ] [ 1 ] ;				  ‘__gnu_cxx::__alloc_traits<std::allocator<std::vec
  for ( int y1 = 0 ;					      	for ( int y1 = 0 ;					      for ( int y1 = 0 ;					  tor<std::vector<int> > >, std::vector<std::vector<
  y1 < rows ;						      	y1 < rows ;						      y1 < rows ;						  int> > >::value_type’ {aka ‘std::vector<std::vecto
  y1 ++ ) for ( int x1 = 0 ;				      	y1 ++ ) for ( int x1 = 0 ;				      y1 ++ ) for ( int x1 = 0 ;				  r<int> >’} to ‘int (*)[2]’	      if(f_filled(pa
  x1 < columns ;					      	x1 < columns ;						      x1 < columns ;						  ram0[i]) == f_gold(param0[i]))
  x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ; 	x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ;   x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ; 	     ^ FIND_RECTANGLE_BINARY_MATRIX_CORNERS_
  y2 < rows ;						      	y2 < rows ;						      y2 < rows ;						  1.cpp:33:21: note:   initializing argument 1 of ‘b
  y2 ++ ) for ( int x2 = x1 + 1 ;			      	y2 ++ ) for ( int x2 = x1 + 1 ;				      y2 ++ ) for ( int x2 = x1 + 1 ;				  ool f_filled(int (*)[2])’  bool f_filled ( int m [
  x2 < columns ;					      	x2 < columns ;						      x2 < columns ;						   ] [ 2 ] ) {			~~~~^~~~~~~~~~~
  x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 & 	x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 &   x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 & 
  return false ;					      	return false ;						      return false ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF		  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF
--							      --							    --								  --
static int findLength ( String str ) {			      int findLength ( char * str ) {				    int findLength ( string str ) {				  script_not_found : None
  int n = str . length ( ) ;				      	int n = strlen ( str ) ;				      int n = str . length ( ) ;				  
  int maxlen = 0 ;					      	int maxlen = 0 ;					      int maxlen = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j += 2 ) {						      	  j += 2 ) {						    	j += 2 ) {						  
      int length = j - i + 1 ;				      	    int length = j - i + 1 ;				    	  int length = j - i + 1 ;				  
      int leftsum = 0 , rightsum = 0 ;			      	    int leftsum = 0 , rightsum = 0 ;			    	  int leftsum = 0 , rightsum = 0 ;			  
      for ( int k = 0 ;					      	    for ( int k = 0 ;					    	  for ( int k = 0 ;					  
      k < length / 2 ;					      	    k < length / 2 ;					    	  k < length / 2 ;					  
      k ++ ) {						      	    k ++ ) {						    	  k ++ ) {						  
	leftsum += ( str . charAt ( i + k ) - '0' ) ;	      	      leftsum += ( str [ i + k ] - '0' ) ;		    	    leftsum += ( str [ i + k ] - '0' ) ;		  
	rightsum += ( str . charAt ( i + k + length / 2 ) - ' 	      rightsum += ( str [ i + k + length / 2 ] - '0' ) ;    	    rightsum += ( str [ i + k + length / 2 ] - '0' ) ;	  
      }							      	    }							    	  }							  
      if ( leftsum == rightsum && maxlen < length ) maxlen =  	    if ( leftsum == rightsum && maxlen < length ) maxlen =  	  if ( leftsum == rightsum && maxlen < length ) {	  
    }							      	  }							    	    maxlen = length ;					  
  }							      	}							    	  }							  
  return maxlen ;					      	return maxlen ;						    	}							  
}							      }								      }								  
							      								      return maxlen ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS		      COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS		    COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS		  COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS
--							      --							    --								  --
static int countSubarrays ( int [ ] arr , int n ) {	      int countSubarrays ( int arr [ ] , int n ) {		    int countSubarrays ( int * arr , int n ) {			  failure : #Results: 6, 10
  int difference = 0 ;					      	int difference = 0 ;					      int difference = 0 ;					  
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  int [ ] hash_positive = new int [ n + 1 ] ;		      	int hash_positive [ n + 1 ] , hash_negative [ n + 1 ] ;	      int hash_positive [ n + 1 ] ;				  
  int [ ] hash_negative = new int [ n + 1 ] ;		      	fill_n ( hash_positive , n + 1 , 0 ) ;			      int hash_negative [ n + 1 ] ;				  
  hash_positive [ 0 ] = 1 ;				      	fill_n ( hash_negative , n + 1 , 0 ) ;			      hash_positive [ 0 ] = 1 ;					  
  for ( int i = 0 ;					      	hash_positive [ 0 ] = 1 ;				      for ( int i = 0 ;						  
  i < n ;						      	for ( int i = 0 ;					      i < n ;							  
  i ++ ) {						      	i < n ;							      i ++ ) {							  
    if ( ( arr [ i ] & 1 ) == 1 ) {			      	i ++ ) {						    	if ( ( arr [ i ] & 1 ) == 1 ) difference ++ ;		  
      difference ++ ;					      	  if ( arr [ i ] & 1 == 1 ) difference ++ ;		    	else difference -- ;					  
    }							      	  else difference -- ;					    	if ( difference < 0 ) {					  
    else {						      	  if ( difference < 0 ) {				    	  ans += hash_negative [ - difference ] ;		  
      difference -- ;					      	    ans += hash_negative [ - difference ] ;		    	  hash_negative [ - difference ] ++ ;			  
    }							      	    hash_negative [ - difference ] ++ ;			    	}							  
    if ( difference < 0 ) {				      	  }							    	else {							  
      ans += hash_negative [ - difference ] ;		      	  else {						    	  ans += hash_positive [ difference ] ;			  
      hash_negative [ - difference ] ++ ;		      	    ans += hash_positive [ difference ] ;		    	  hash_positive [ difference ] ++ ;			  
    }							      	    hash_positive [ difference ] ++ ;			    	}							  
    else {						      	  }							      }								  
      ans += hash_positive [ difference ] ;		      	}							      return ans ;						  
      hash_positive [ difference ] ++ ;			      	return ans ;						    }								  
    }							      }								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY	      INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY	    INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY	  INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY
--							      --							    --								  --
static int findInteger ( int arr [ ] , int n ) {	      int findInteger ( int arr [ ] , int n ) {			    int findInteger ( int arr [ ] , int n ) {			  success : None
  HashMap < Integer , Integer > hash = new HashMap < > ( ) ;  	unordered_map < int , int > hash ;			      unordered_map < int , int > hash ;			  
  int maximum = 0 ;					      	int maximum = 0 ;					      int maximum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] < 0 ) hash . put ( Math . abs ( arr [ i ]  	  if ( arr [ i ] < 0 ) hash [ abs ( arr [ i ] ) ] -= 1 ;    	if ( arr [ i ] < 0 ) {					  
    else hash . put ( Math . abs ( arr [ i ] ) , ( hash . get 	  else hash [ arr [ i ] ] += 1 ;			    	  hash [ abs ( arr [ i ] ) ] = ( hash . find ( abs ( arr  
  }							      	}							    	}							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	else {							  
  i < n ;						      	i < n ;							    	  hash [ abs ( arr [ i ] ) ] = ( hash . find ( abs ( arr  
  i ++ ) if ( hash . get ( arr [ i ] ) > 0 ) return arr [ i ] 	i ++ ) if ( hash [ arr [ i ] ] != 0 ) return arr [ i ] ;    	}							  
  return - 1 ;						      	return - 1 ;						      }								  
}							      }								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) if ( hash [ arr [ i ] ] > 0 ) return arr [ i ] ;	  
							      								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS		      FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS			    FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS			  FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS
--							      --							    --								  --
static int evenSum ( int n ) {				      int evenSum ( int n ) {					    int evenSum ( int n ) {					  success : None
  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;		      	int C [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> C ( n + 1 , vector < int > ( n + 1 
  int i , j ;						      	int i , j ;						      int i , j ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( j = 0 ;					      	  for ( j = 0 ;						    	for ( j = 0 ;						  
    j <= Math . min ( i , n ) ;				      	  j <= min ( i , n ) ;					    	j <= min ( i , n ) ;					  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;	      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  if ( j == 0 || j == i ) {				  
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	    else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	    C [ i ] [ j ] = 1 ;					  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  int sum = 0 ;						      	int sum = 0 ;						    	    C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ 
  for ( i = 0 ;						      	for ( int i = 0 ;					    	  }							  
  i <= n ;						      	i <= n ;						    	}							  
  i += 2 ) sum += C [ n ] [ i ] ;			      	i += 2 ) sum += C [ n ] [ i ] ;				      }								  
  return sum ;						      	return sum ;						      int sum = 0 ;						  
}							      }								      for ( i = 0 ;						  
							      								      i <= n ;							  
							      								      i += 2 ) {						  
							      								    	sum += C [ n ] [ i ] ;					  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT		      CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT		    CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT		  CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT
--							      --							    --								  --
static void checkPoint ( int radius , int x , int y , float p void checkPoint ( int radius , int x , int y , float percent  void checkPoint ( int radius , int x , int y , float percent  script_not_found : None
  float endAngle = 360 / percent + startAngle ;		      	float endAngle = 360 / percent + startAngle ;		      float endAngle = 360 / percent + startAngle ;		  
  double polarradius = Math . sqrt ( x * x + y * y ) ;	      	float polarradius = sqrt ( x * x + y * y ) ;		      double polarradius = sqrt ( x * x + y * y ) ;		  
  double Angle = Math . atan ( y / x ) ;		      	float Angle = atan ( y / x ) ;				      double Angle = atan ( y / x ) ;				  
  if ( Angle >= startAngle && Angle <= endAngle && polarradiu 	if ( Angle >= startAngle && Angle <= endAngle && polarradiu   if ( Angle >= startAngle && Angle <= endAngle && polarradiu 
  else System . out . print ( "Point" + "(" + x + "," + y + " 	else printf ( "Point (%d, %d) does not exist in the circle  	cout << "Point" << "(" << x << "," << y << ")" << " exist 
}							      }								      }								  
							      								      else {							  
							      								    	cout << "Point" << "(" << x << "," << y << ")" << " exist 
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_MAXIMUM_GCD_ARRAY_1				      FIND_PAIR_MAXIMUM_GCD_ARRAY_1				    FIND_PAIR_MAXIMUM_GCD_ARRAY_1				  FIND_PAIR_MAXIMUM_GCD_ARRAY_1
--							      --							    --								  --
public static int findMaxGCD ( int arr [ ] , int n ) {	      int findMaxGCD ( int arr [ ] , int n ) {			    int findMaxGCD ( int arr [ ] , int n ) {			  failure : #Results: 4, 10
  int high = 0 ;					      	int high = 0 ;						      int high = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) high = Math . max ( high , arr [ i ] ) ;	      	i ++ ) high = max ( high , arr [ i ] ) ;		      i ++ ) {							  
  int count [ ] = new int [ high + 1 ] ;		      	int count [ high + 1 ] = {				    	high = max ( high , arr [ i ] ) ;			  
  for ( int i = 0 ;					      	  0 }							      }								  
  i < n ;						      	  ;							      int count [ high + 1 ] ;					  
  i ++ ) count [ arr [ i ] ] ++ ;			      	  for ( int i = 0 ;					      for ( int i = 0 ;						  
  int counter = 0 ;					      	  i < n ;						      i < n ;							  
  for ( int i = high ;					      	  i ++ ) count [ arr [ i ] ] ++ ;			      i ++ ) {							  
  i >= 1 ;						      	  int counter = 0 ;					    	count [ arr [ i ] ] ++ ;				  
  i -- ) {						      	  for ( int i = high ;					      }								  
    int j = i ;						      	  i >= 1 ;						      int counter = 0 ;						  
    while ( j <= high ) {				      	  i -- ) {						      for ( int i = high ;					  
      if ( count [ j ] > 0 ) counter += count [ j ] ;	      	    int j = i ;						      i >= 1 ;							  
      j += i ;						      	    counter = 0 ;					      i -- ) {							  
      if ( counter == 2 ) return i ;			      	    while ( j <= high ) {				    	int j = i ;						  
    }							      	      if ( count [ j ] >= 2 ) return j ;		    	while ( j <= high ) {					  
    counter = 0 ;					      	      else if ( count [ j ] == 1 ) counter ++ ;		    	  if ( count [ j ] > 0 ) {				  
  }							      	      j += i ;						    	    counter += count [ j ] ;				  
  return 1 ;						      	      if ( counter == 2 ) return i ;			    	  }							  
}							      	    }							    	  j += i ;						  
							      	  }							    	  if ( counter == 2 ) {					  
							      	}							    	    return i ;						  
							      								    	  }							  
							      								    	}							  
							      								    	counter = 0 ;						  
							      								      }								  
							      								      return 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1	      FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1	    FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1	  FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1
--							      --							    --								  --
public static void findPair ( int [ ] arr , int n ) {	      void findPair ( int arr [ ] , int n ) {			    void findPair ( int * arr , int n ) {			  script_not_found : None
  HashSet < Integer > s = new HashSet < Integer > ( ) ;	      	unordered_set < int > s ;				      set < int > s ;						  
  for ( Integer i : arr ) {				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    s . add ( i ) ;					      	i < n ;							      i < arr [ 0 ] ;						  
  }							      	i ++ ) s . insert ( arr [ i ] ) ;			      i ++ ) s . insert ( arr [ i ] ) ;				  
  boolean found = false ;				      	bool found = false ;					      bool found = false ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n ;							      i < n - 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      int sum = arr [ i ] + arr [ j ] ;			      	    if ( s . find ( arr [ i ] + arr [ j ] ) != s . end ( )  	  int sum = arr [ i ] + arr [ j ] ;			  
      if ( s . contains ( sum ) ) {			      	      cout << arr [ i ] << " " << arr [ j ] << endl ;	    	  if ( s . find ( sum ) != s . end ( ) ) {		  
	found = true ;					      	      found = true ;					    	    found = true ;					  
	System . out . println ( arr [ i ] + " " + arr [ j ]  	    }							    	    cout << arr [ i ] << " " << arr [ j ] << endl ;	  
      }							      	  }							    	  }							  
    }							      	}							    	}							  
  }							      	if ( found == false ) cout << "Not exist" << endl ;	      }								  
  if ( found == false ) System . out . println ( "Not Exist " }								      if ( found == false ) cout << "Not Exist " << endl ;	  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_ELEMENT_TWO_SORTED_ARRAYS				      K_TH_ELEMENT_TWO_SORTED_ARRAYS				    K_TH_ELEMENT_TWO_SORTED_ARRAYS				  K_TH_ELEMENT_TWO_SORTED_ARRAYS
--							      --							    --								  --
static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n  int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k success : None
  int [ ] sorted1 = new int [ m + n ] ;			      	int sorted1 [ m + n ] ;					      int sorted1 [ m + n ] ;					  
  int i = 0 , j = 0 , d = 0 ;				      	int i = 0 , j = 0 , d = 0 ;				      int i = 0 , j = 0 , d = 0 ;				  
  while ( i < m && j < n ) {				      	while ( i < m && j < n ) {				      while ( i < m && j < n ) {				  
    if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [  	  if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [  	if ( arr1 [ i ] < arr2 [ j ] ) {			  
    else sorted1 [ d ++ ] = arr2 [ j ++ ] ;		      	  else sorted1 [ d ++ ] = arr2 [ j ++ ] ;		    	  sorted1 [ d ++ ] = arr1 [ i ++ ] ;			  
  }							      	}							    	}							  
  while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ;	      	while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ;	    	else {							  
  while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ;	      	while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ;	    	  sorted1 [ d ++ ] = arr2 [ j ++ ] ;			  
  return sorted1 [ k - 1 ] ;				      	return sorted1 [ k - 1 ] ;				    	}							  
}							      }								      }								  
							      								      while ( i < m ) {						  
							      								    	sorted1 [ d ++ ] = arr1 [ i ++ ] ;			  
							      								      }								  
							      								      while ( j < n ) {						  
							      								    	sorted1 [ d ++ ] = arr2 [ j ++ ] ;			  
							      								      }								  
							      								      return sorted1 [ k - 1 ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
A_PRODUCT_ARRAY_PUZZLE_1				      A_PRODUCT_ARRAY_PUZZLE_1					    A_PRODUCT_ARRAY_PUZZLE_1					  A_PRODUCT_ARRAY_PUZZLE_1
--							      --							    --								  --
void productArray ( int arr [ ] , int n ) {		      void productArray ( int arr [ ] , int n ) {		    void productArray ( int arr [ ] , int n ) {			  script_not_found : None
  if ( n == 1 ) {					      	if ( n == 1 ) {						      if ( n == 1 ) {						  
    System . out . print ( "0" ) ;			      	  cout << 0 ;						    	cout << "0" << endl ;					  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  int i , temp = 1 ;					      	int i , temp = 1 ;					      int i , temp = 1 ;					  
  int prod [ ] = new int [ n ] ;			      	int * prod = new int [ ( sizeof ( int ) * n ) ] ;	      int prod [ n ] ;						  
  for ( int j = 0 ;					      	memset ( prod , 1 , n ) ;				      for ( int j = 0 ;						  
  j < n ;						      	for ( i = 0 ;						      j < n ;							  
  j ++ ) prod [ j ] = 1 ;				      	i < n ;							      j ++ ) {							  
  for ( i = 0 ;						      	i ++ ) {						    	prod [ j ] = 1 ;					  
  i < n ;						      	  prod [ i ] = temp ;					      }								  
  i ++ ) {						      	  temp *= arr [ i ] ;					      for ( i = 0 ;						  
    prod [ i ] = temp ;					      	}							      i < n ;							  
    temp *= arr [ i ] ;					      	temp = 1 ;						      i ++ ) {							  
  }							      	for ( i = n - 1 ;					    	prod [ i ] = temp ;					  
  temp = 1 ;						      	i >= 0 ;						    	temp *= arr [ i ] ;					  
  for ( i = n - 1 ;					      	i -- ) {						      }								  
  i >= 0 ;						      	  prod [ i ] *= temp ;					      temp = 1 ;						  
  i -- ) {						      	  temp *= arr [ i ] ;					      for ( i = n - 1 ;						  
    prod [ i ] *= temp ;				      	}							      i >= 0 ;							  
    temp *= arr [ i ] ;					      	for ( i = 0 ;						      i -- ) {							  
  }							      	i < n ;							    	prod [ i ] *= temp ;					  
  for ( i = 0 ;						      	i ++ ) cout << prod [ i ] << " " ;			    	temp *= arr [ i ] ;					  
  i < n ;						      	return ;						      }								  
  i ++ ) System . out . print ( prod [ i ] + " " ) ;	      }								      for ( i = 0 ;						  
  return ;						      								      i < n ;							  
}							      								      i ++ ) {							  
							      								    	cout << prod [ i ] << " " ;				  
							      								      }								  
							      								      return ;							  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX		      COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX		    COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX		  COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX
--							      --							    --								  --
static void printCommonElements ( int mat [ ] [ ] ) {	      void printCommonElements ( int mat [ M ] [ N ] ) {	    void printCommonElements ( int mat [ M ] [ N ] ) {		  script_not_found : None
  Map < Integer , Integer > mp = new HashMap < > ( ) ;	      	unordered_map < int , int > mp ;			      map < int , int > mp ;					  
  for ( int j = 0 ;					      	for ( int j = 0 ;					      for ( int j = 0 ;						  
  j < N ;						      	j < N ;							      j < N ;							  
  j ++ ) mp . put ( mat [ 0 ] [ j ] , 1 ) ;		      	j ++ ) mp [ mat [ 0 ] [ j ] ] = 1 ;			      j ++ ) {							  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	mp [ mat [ 0 ] [ j ] ] = 1 ;				  
  i < M ;						      	i < M ;							      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 1 ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      i < M ;							  
    j < N ;						      	  j < N ;						      i ++ ) {							  
    j ++ ) {						      	  j ++ ) {						    	for ( int j = 0 ;					  
      if ( mp . get ( mat [ i ] [ j ] ) != null && mp . get ( 	    if ( mp [ mat [ i ] [ j ] ] == i ) {		    	j < N ;							  
	mp . put ( mat [ i ] [ j ] , i + 1 ) ;		      	      mp [ mat [ i ] [ j ] ] = i + 1 ;			    	j ++ ) {						  
	if ( i == M - 1 ) System . out . print ( mat [ i ] [  	      if ( i == M - 1 ) cout << mat [ i ] [ j ] << " " ;    	  if ( mp [ mat [ i ] [ j ] ] != 0 && mp [ mat [ i ] [ j  
      }							      	    }							    	    mp [ mat [ i ] [ j ] ] = i + 1 ;			  
    }							      	  }							    	    if ( i == M - 1 ) {					  
  }							      	}							    	      cout << mat [ i ] [ j ] << " " ;			  
}							      }								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH
--							      --							    --								  --
static int findElement ( int [ ] arr , int n ) {	      int findElement ( int arr [ ] , int n ) {			    int findElement ( int arr [ ] , int n ) {			  success : None
  int [ ] leftMax = new int [ n ] ;			      	int leftMax [ n ] ;					      int left_max [ n ] ;					  
  leftMax [ 0 ] = Integer . MIN_VALUE ;			      	leftMax [ 0 ] = INT_MIN ;				      left_max [ 0 ] = INT_MIN ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) leftMax [ i ] = Math . max ( leftMax [ i - 1 ] , arr 	i ++ ) leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i -    i ++ ) {							  
  int rightMin = Integer . MAX_VALUE ;			      	int rightMin = INT_MAX ;				    	left_max [ i ] = max ( left_max [ i - 1 ] , arr [ i - 1 ] 
  for ( int i = n - 1 ;					      	for ( int i = n - 1 ;					      }								  
  i >= 0 ;						      	i >= 0 ;						      int right_min = INT_MAX ;					  
  i -- ) {						      	i -- ) {						      for ( int i = n - 1 ;					  
    if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] )  	  if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] )    i >= 0 ;							  
    rightMin = Math . min ( rightMin , arr [ i ] ) ;	      	  rightMin = min ( rightMin , arr [ i ] ) ;		      i -- ) {							  
  }							      	}							    	if ( left_max [ i ] < arr [ i ] && right_min > arr [ i ]  
  return - 1 ;						      	return - 1 ;						    	right_min = min ( right_min , arr [ i ] ) ;		  
}							      }								      }								  
							      								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PETERSON_GRAPH						      PETERSON_GRAPH						    PETERSON_GRAPH						  PETERSON_GRAPH
--							      --							    --								  --
static boolean findthepath ( char [ ] S , int v ) {	      bool findthepath ( char * S , int v ) {			    bool findthepath ( string S , int v ) {			  script_not_found : None
  result [ 0 ] = ( char ) ( v + '0' ) ;			      	result [ 0 ] = v + '0' ;				      result [ 0 ] = ( char ) ( v + '0' ) ;			  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < ( int ) S . length ;				      	S [ i ] ;						      i < ( int ) S . length ( ) ;				  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( adj [ v ] [ S [ i ] - 'A' ] || adj [ S [ i ] - 'A' ] 	  if ( adj [ v ] [ S [ i ] - 'A' ] || adj [ S [ i ] - 'A' ] 	if ( adj [ v ] [ S [ i ] - 'A' ] || adj [ S [ i ] - 'A' ] 
      v = S [ i ] - 'A' ;				      	    v = S [ i ] - 'A' ;					    	else if ( adj [ v ] [ S [ i ] - 'A' + 5 ] || adj [ S [ i  
    }							      	  }							    	else return false ;					  
    else if ( adj [ v ] [ S [ i ] - 'A' + 5 ] || adj [ S [ i  	  else if ( adj [ v ] [ S [ i ] - 'A' + 5 ] || adj [ S [ i  	result [ i ] = ( char ) ( v + '0' ) ;			  
      v = S [ i ] - 'A' + 5 ;				      	    v = S [ i ] - 'A' + 5 ;				      }								  
    }							      	  }							      return true ;						  
    else return false ;					      	  else return false ;					    }								  
    result [ i ] = ( char ) ( v + '0' ) ;		      	  result [ i ] = v + '0' ;				    								  
  }							      	}							    								  
  return true ;						      	return true ;						    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1		      MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1		    MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1		  MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1
--							      --							    --								  --
static int maxSum ( int arr [ ] , int n ) {		      int maxSum ( int arr [ ] , int n ) {			    int maxSum ( int arr [ ] , int n ) {			  success : None
  int cum_sum = 0 ;					      	int cum_sum = 0 ;					      int cum_sum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) cum_sum += arr [ i ] ;				      	i ++ ) cum_sum += arr [ i ] ;				      i ++ ) {							  
  int curr_val = 0 ;					      	int curr_val = 0 ;					    	cum_sum += arr [ i ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      }								  
  i < n ;						      	i < n ;							      int curr_val = 0 ;					  
  i ++ ) curr_val += i * arr [ i ] ;			      	i ++ ) curr_val += i * arr [ i ] ;			      for ( int i = 0 ;						  
  int res = curr_val ;					      	int res = curr_val ;					      i < n ;							  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      i ++ ) {							  
  i < n ;						      	i < n ;							    	curr_val += i * arr [ i ] ;				  
  i ++ ) {						      	i ++ ) {						      }								  
    int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + a 	  int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + a   int res = curr_val ;					  
    curr_val = next_val ;				      	  curr_val = next_val ;					      for ( int i = 1 ;						  
    res = Math . max ( res , next_val ) ;		      	  res = max ( res , next_val ) ;			      i < n ;							  
  }							      	}							      i ++ ) {							  
  return res ;						      	return res ;						    	int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + a 
}							      }								    	curr_val = next_val ;					  
							      								    	res = max ( res , next_val ) ;				  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE			      FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE			    FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE				  FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE
--							      --							    --								  --
static void printOtherSides ( int n ) {			      void printOtherSides ( int n ) {				    void print_other_sides ( int n ) {				  script_not_found : None
  if ( n % 2 != 0 ) {					      	if ( n & 1 ) {						      if ( n % 2 != 0 ) {					  
    if ( n == 1 ) System . out . println ( "-1" ) ;	      	  if ( n == 1 ) cout << - 1 << endl ;			    	if ( n == 1 ) {						  
    else {						      	  else {						    	  cout << "-1" << endl ;				  
      int b = ( n * n - 1 ) / 2 ;			      	    int b = ( n * n - 1 ) / 2 ;				    	}							  
      int c = ( n * n + 1 ) / 2 ;			      	    int c = ( n * n + 1 ) / 2 ;				    	else {							  
      System . out . println ( "b = " + b + ", c = " + c ) ;  	    cout << "b = " << b << ", c = " << c << endl ;	    	  int b = ( n * n - 1 ) / 2 ;				  
    }							      	  }							    	  int c = ( n * n + 1 ) / 2 ;				  
  }							      	}							    	  cout << "b = " << b << ", c = " << c << endl ;	  
  else {						      	else {							    	}							  
    if ( n == 2 ) System . out . println ( "-1" ) ;	      	  if ( n == 2 ) cout << - 1 << endl ;			      }								  
    else {						      	  else {						      else {							  
      int b = n * n / 4 - 1 ;				      	    int b = n * n / 4 - 1 ;				    	if ( n == 2 ) {						  
      int c = n * n / 4 + 1 ;				      	    int c = n * n / 4 + 1 ;				    	  cout << "-1" << endl ;				  
      System . out . println ( "b = " + b + ", c = " + c ) ;  	    cout << "b = " << b << ", c = " << c << endl ;	    	}							  
    }							      	  }							    	else {							  
  }							      	}							    	  int b = n * n / 4 - 1 ;				  
}							      }								    	  int c = n * n / 4 + 1 ;				  
							      								    	  cout << "b = " << b << ", c = " << c << endl ;	  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES	      CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES		    CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES		  CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES
--							      --							    --								  --
static int minRemove ( int arr [ ] , int n ) {		      int minRemove ( int arr [ ] , int n ) {			    int minRemove ( int arr [ ] , int n ) {			  success : None
  int LIS [ ] = new int [ n ] ;				      	int LIS [ n ] , len = 0 ;				      int LIS [ n ] ;						  
  int len = 0 ;						      	for ( int i = 0 ;					      int len = 0 ;						  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) LIS [ i ] = 1 ;					      i < n ;							  
  i ++ ) LIS [ i ] = 1 ;				      	for ( int i = 1 ;					      i ++ ) {							  
  for ( int i = 1 ;					      	i < n ;							    	LIS [ i ] = 1 ;						  
  i < n ;						      	i ++ ) {						      }								  
  i ++ ) {						      	  for ( int j = 0 ;					      for ( int i = 1 ;						  
    for ( int j = 0 ;					      	  j < i ;						      i < n ;							  
    j < i ;						      	  j ++ ) {						      i ++ ) {							  
    j ++ ) {						      	    if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ]  	for ( int j = 0 ;					  
      if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ]  	      LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) ;	    	j < i ;							  
    }							      	    }							    	j ++ ) {						  
    len = Math . max ( len , LIS [ i ] ) ;		      	  }							    	  if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ]  
  }							      	  len = max ( len , LIS [ i ] ) ;			    	    LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) ;	  
  return n - len ;					      	}							    	  }							  
}							      	return n - len ;					    	}							  
							      }								    	len = max ( len , LIS [ i ] ) ;				  
							      								      }								  
							      								      return n - len ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_TWO_NUMBERS_B_FIND_X_X_B				      GIVEN_TWO_NUMBERS_B_FIND_X_X_B				    GIVEN_TWO_NUMBERS_B_FIND_X_X_B				  GIVEN_TWO_NUMBERS_B_FIND_X_X_B
--							      --							    --								  --
static void modularEquation ( int a , int b ) {		      void modularEquation ( int a , int b ) {			    void modularEquation ( int a , int b ) {			  script_not_found : None
  if ( a < b ) {					      	if ( a < b ) {						      if ( a < b ) {						  
    System . out . println ( "No solution possible " ) ;      	  cout << "No solution possible " << endl ;		    	cout << "No solution possible " << endl ;		  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( a == b ) {					      	if ( a == b ) {						      if ( a == b ) {						  
    System . out . println ( "Infinite Solution possible " )  	  cout << "Infinite Solution possible " << endl ;	    	cout << "Infinite Solution possible " << endl ;		  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  int n = a - b ;					      	int n = a - b ;						      int n = a - b ;						  
  int y = ( int ) Math . sqrt ( a - b ) ;		      	int y = sqrt ( a - b ) ;				      int y = ( int ) sqrt ( a - b ) ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= y ;						      	i <= y ;						      i <= y ;							  
  ++ i ) {						      	++ i ) {						      ++ i ) {							  
    if ( n % i == 0 ) {					      	  if ( n % i == 0 ) {					    	if ( n % i == 0 ) {					  
      if ( n / i > b ) count ++ ;			      	    if ( n / i > b ) count ++ ;				    	  if ( n / i > b ) {					  
      if ( i > b ) count ++ ;				      	    if ( i > b ) count ++ ;				    	    count ++ ;						  
    }							      	  }							    	  }							  
  }							      	}							    	  if ( i > b ) {					  
  if ( y * y == n && y > b ) count -- ;			      	if ( y * y == n && y > b ) count -- ;			    	    count ++ ;						  
  System . out . println ( count ) ;			      	cout << count << endl ;					    	  }							  
}							      }								    	}							  
							      								      }								  
							      								      if ( y * y == n && y > b ) {				  
							      								    	count -- ;						  
							      								      }								  
							      								      cout << count << endl ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY		      SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY		    SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY		  SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY
--							      --							    --								  --
static int search ( int arr [ ] , int l , int h , int key ) { int search ( int arr [ ] , int l , int h , int key ) {	    int search ( int arr [ ] , int l , int h , int key ) {	  success : identical to gold
  if ( l > h ) return - 1 ;				      	if ( l > h ) return - 1 ;				      if ( l > h ) return - 1 ;					  
  int mid = ( l + h ) / 2 ;				      	int mid = ( l + h ) / 2 ;				      int mid = ( l + h ) / 2 ;					  
  if ( arr [ mid ] == key ) return mid ;		      	if ( arr [ mid ] == key ) return mid ;			      if ( arr [ mid ] == key ) return mid ;			  
  if ( arr [ l ] <= arr [ mid ] ) {			      	if ( arr [ l ] <= arr [ mid ] ) {			      if ( arr [ l ] <= arr [ mid ] ) {				  
    if ( key >= arr [ l ] && key <= arr [ mid ] ) return sear 	  if ( key >= arr [ l ] && key <= arr [ mid ] ) return sear 	if ( key >= arr [ l ] && key <= arr [ mid ] ) return sear 
    return search ( arr , mid + 1 , h , key ) ;		      	  return search ( arr , mid + 1 , h , key ) ;		    	return search ( arr , mid + 1 , h , key ) ;		  
  }							      	}							      }								  
  if ( key >= arr [ mid ] && key <= arr [ h ] ) return search 	if ( key >= arr [ mid ] && key <= arr [ h ] ) return search   if ( key >= arr [ mid ] && key <= arr [ h ] ) return search 
  return search ( arr , l , mid - 1 , key ) ;		      	return search ( arr , l , mid - 1 , key ) ;		      return search ( arr , l , mid - 1 , key ) ;		  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CEILING_IN_A_SORTED_ARRAY_1				      CEILING_IN_A_SORTED_ARRAY_1				    CEILING_IN_A_SORTED_ARRAY_1					  CEILING_IN_A_SORTED_ARRAY_1
--							      --							    --								  --
static int ceilSearch ( int arr [ ] , int low , int high , in int ceilSearch ( int arr [ ] , int low , int high , int x ) { int ceilSearch ( int arr [ ] , int low , int high , int x ) { success : identical to gold
  int mid ;						      	int mid ;						      int mid ;							  
  if ( x <= arr [ low ] ) return low ;			      	if ( x <= arr [ low ] ) return low ;			      if ( x <= arr [ low ] ) return low ;			  
  if ( x > arr [ high ] ) return - 1 ;			      	if ( x > arr [ high ] ) return - 1 ;			      if ( x > arr [ high ] ) return - 1 ;			  
  mid = ( low + high ) / 2 ;				      	mid = ( low + high ) / 2 ;				      mid = ( low + high ) / 2 ;				  
  if ( arr [ mid ] == x ) return mid ;			      	if ( arr [ mid ] == x ) return mid ;			      if ( arr [ mid ] == x ) return mid ;			  
  else if ( arr [ mid ] < x ) {				      	else if ( arr [ mid ] < x ) {				      else if ( arr [ mid ] < x ) {				  
    if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid 	  if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid 	if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid 
    else return ceilSearch ( arr , mid + 1 , high , x ) ;     	  else return ceilSearch ( arr , mid + 1 , high , x ) ;	    	else return ceilSearch ( arr , mid + 1 , high , x ) ;	  
  }							      	}							      }								  
  else {						      	else {							      else {							  
    if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; 	  if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; 	if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; 
    else return ceilSearch ( arr , low , mid - 1 , x ) ;      	  else return ceilSearch ( arr , low , mid - 1 , x ) ;	    	else return ceilSearch ( arr , low , mid - 1 , x ) ;	  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS		      MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS		    MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS		  MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS
--							      --							    --								  --
static int maximumSum ( int a [ ] [ ] , int n ) {	      int maximumSum ( int a [ ] [ M ] , int n ) {		    int maximumSum ( int a [ ] [ 2 ] , int n ) {		  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) sort ( a , i , n ) ;				      	i ++ ) sort ( a [ i ] , a [ i ] + M ) ;			      i ++ ) {							  
  int sum = a [ n - 1 ] [ M - 1 ] ;			      	int sum = a [ n - 1 ] [ M - 1 ] ;			    	sort ( a , a + n ) ;					  
  int prev = a [ n - 1 ] [ M - 1 ] ;			      	int prev = a [ n - 1 ] [ M - 1 ] ;			      }								  
  int i , j ;						      	int i , j ;						      int sum = a [ n - 1 ] [ M - 1 ] ;				  
  for ( i = n - 2 ;					      	for ( i = n - 2 ;					      int prev = a [ n - 1 ] [ M - 1 ] ;			  
  i >= 0 ;						      	i >= 0 ;						      int i , j ;						  
  i -- ) {						      	i -- ) {						      for ( i = n - 2 ;						  
    for ( j = M - 1 ;					      	  for ( j = M - 1 ;					      i >= 0 ;							  
    j >= 0 ;						      	  j >= 0 ;						      i -- ) {							  
    j -- ) {						      	  j -- ) {						    	for ( j = M - 1 ;					  
      if ( a [ i ] [ j ] < prev ) {			      	    if ( a [ i ] [ j ] < prev ) {			    	j >= 0 ;						  
	prev = a [ i ] [ j ] ;				      	      prev = a [ i ] [ j ] ;				    	j -- ) {						  
	sum += prev ;					      	      sum += prev ;					    	  if ( a [ i ] [ j ] < prev ) {				  
	break ;						      	      break ;						    	    prev = a [ i ] [ j ] ;				  
      }							      	    }							    	    sum += prev ;					  
    }							      	  }							    	    break ;						  
    if ( j == - 1 ) return 0 ;				      	  if ( j == - 1 ) return 0 ;				    	  }							  
  }							      	}							    	}							  
  return sum ;						      	return sum ;						    	if ( j == - 1 ) return 0 ;				  
}							      }								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_LINE_PASSING_2_POINTS			      PROGRAM_FIND_LINE_PASSING_2_POINTS			    PROGRAM_FIND_LINE_PASSING_2_POINTS				  PROGRAM_FIND_LINE_PASSING_2_POINTS
--							      --							    --								  --
static void lineFromPoints ( Pair P , Pair Q ) {	      pair < double , double > void lineFromPoints ( pdd P , pdd Q  void lineFromPoints ( pair < int , int > P , pair < int , int script_not_found : None
  int a = Q . second - P . second ;			      	double a = Q . second - P . second ;			      int a = Q [ 1 ] - P [ 1 ] ;				  
  int b = P . first - Q . first ;			      	double b = P . first - Q . first ;			      int b = P [ 0 ] - Q [ 0 ] ;				  
  int c = a * ( P . first ) + b * ( P . second ) ;	      	double c = a * ( P . first ) + b * ( P . second ) ;	      int c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) ;		  
  if ( b < 0 ) {					      	if ( b < 0 ) {						      if ( b < 0 ) cout << "The line passing through points P and 
    System . out . println ( "The line passing through points 	  cout << "The line passing through points P and Q is: " <<   else cout << "The line passing through points P and Q is: " 
  }							      	}							    }								  
  else {						      	else {							    								  
    System . out . println ( "The line passing through points 	  cout << "The line passing through points P and Q is: " << 								  
  }							      	}							    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SORTED_ROWS_MATRIX				      COUNT_SORTED_ROWS_MATRIX					    COUNT_SORTED_ROWS_MATRIX					  COUNT_SORTED_ROWS_MATRIX
--							      --							    --								  --
static int sortedCount ( int mat [ ] [ ] , int r , int c ) {  int sortedCount ( int mat [ ] [ MAX ] , int r , int c ) {	    int sortedCount ( int mat [ ] [ 2 ] , int r , int c ) {	  script_not_found : None
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < r ;						      	i < r ;							      i < r ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int j ;						      	  int j ;						    	int j ;							  
    for ( j = 0 ;					      	  for ( j = 0 ;						    	for ( j = 0 ;						  
    j < c - 1 ;						      	  j < c - 1 ;						    	j < c - 1 ;						  
    j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) brea 	  j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) brea 	j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) brea 
    if ( j == c - 1 ) result ++ ;			      	  if ( j == c - 1 ) result ++ ;				    	if ( j == c - 1 ) result ++ ;				  
  }							      	}							      }								  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < r ;						      	i < r ;							      i < r ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int j ;						      	  int j ;						    	int j ;							  
    for ( j = c - 1 ;					      	  for ( j = c - 1 ;					    	for ( j = c - 1 ;					  
    j > 0 ;						      	  j > 0 ;						    	j > 0 ;							  
    j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) brea 	  j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) brea 	j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) brea 
    if ( c > 1 && j == 0 ) result ++ ;			      	  if ( c > 1 && j == 0 ) result ++ ;			    	if ( c > 1 && j == 0 ) result ++ ;			  
  }							      	}							      }								  
  return result ;					      	return result ;						      return result ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY		      MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY		    MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY		  MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY
--							      --							    --								  --
static int maxDiff ( int [ ] arr , int n ) {		      int maxDiff ( int arr [ ] , int n ) {			    int maxDiff ( int * arr , int n ) {				  success : None
  int SubsetSum_1 = 0 , SubsetSum_2 = 0 ;		      	int SubsetSum_1 = 0 , SubsetSum_2 = 0 ;			      int SubsetSum_1 = 0 , SubsetSum_2 = 0 ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n - 1 ;						      	i <= n - 1 ;						      i <= n - 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    boolean isSingleOccurance = true ;			      	  bool isSingleOccurance = true ;			    	bool isSingleOccurance = true ;				  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j <= n - 1 ;					      	  j <= n - 1 ;						    	j <= n - 1 ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( arr [ i ] == arr [ j ] ) {			      	    if ( arr [ i ] == arr [ j ] ) {			    	  if ( arr [ i ] == arr [ j ] ) {			  
	isSingleOccurance = false ;			      	      isSingleOccurance = false ;			    	    isSingleOccurance = false ;				  
	arr [ i ] = arr [ j ] = 0 ;			      	      arr [ i ] = arr [ j ] = 0 ;			    	    arr [ i ] = arr [ j ] = 0 ;				  
	break ;						      	      break ;						    	    break ;						  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
    if ( isSingleOccurance ) {				      	  if ( isSingleOccurance ) {				    	if ( isSingleOccurance ) {				  
      if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ;	      	    if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ;	    	  if ( arr [ i ] > 0 ) {				  
      else SubsetSum_2 += arr [ i ] ;			      	    else SubsetSum_2 += arr [ i ] ;			    	    SubsetSum_1 += arr [ i ] ;				  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ;	      	return abs ( SubsetSum_1 - SubsetSum_2 ) ;		    	    SubsetSum_2 += arr [ i ] ;				  
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return abs ( SubsetSum_1 - SubsetSum_2 ) ;		  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY		      COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY		    COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY			  COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY
--							      --							    --								  --
static int countMinOperations ( int n ) {		      int countMinOperations ( unsigned int target [ ] , int n ) {  int countMinOperations ( int n ) {				  script_not_found : None
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  while ( true ) {					      	while ( 1 ) {						      while ( true ) {						  
    int zero_count = 0 ;				      	  int zero_count = 0 ;					    	int zero_count = 0 ;					  
    int i ;						      	  int i ;						    	int i ;							  
    for ( i = 0 ;					      	  for ( i = 0 ;						    	for ( i = 0 ;						  
    i < n ;						      	  i < n ;						    	i < n ;							  
    i ++ ) {						      	  i ++ ) {						    	i ++ ) {						  
      if ( arr [ i ] % 2 == 1 ) break ;			      	    if ( target [ i ] & 1 ) break ;			    	  if ( arr [ i ] % 2 == 1 ) break ;			  
      else if ( arr [ i ] == 0 ) zero_count ++ ;	      	    else if ( target [ i ] == 0 ) zero_count ++ ;	    	  else if ( arr [ i ] == 0 ) zero_count ++ ;		  
    }							      	  }							    	}							  
    if ( zero_count == n ) return result ;		      	  if ( zero_count == n ) return result ;		    	if ( zero_count == n ) return result ;			  
    if ( i == n ) {					      	  if ( i == n ) {					    	if ( i == n ) {						  
      for ( int j = 0 ;					      	    for ( int j = 0 ;					    	  for ( int j = 0 ;					  
      j < n ;						      	    j < n ;						    	  j < n ;						  
      j ++ ) arr [ j ] = arr [ j ] / 2 ;		      	    j ++ ) target [ j ] = target [ j ] / 2 ;		    	  j ++ ) {						  
      result ++ ;					      	    result ++ ;						    	    arr [ j ] = arr [ j ] / 2 ;				  
    }							      	  }							    	  }							  
    for ( int j = i ;					      	  for ( int j = i ;					    	  result ++ ;						  
    j < n ;						      	  j < n ;						    	}							  
    j ++ ) {						      	  j ++ ) {						    	for ( int j = i ;					  
      if ( arr [ j ] % 2 == 1 ) {			      	    if ( target [ j ] & 1 ) {				    	j < n ;							  
	arr [ j ] -- ;					      	      target [ j ] -- ;					    	j ++ ) {						  
	result ++ ;					      	      result ++ ;					    	  if ( arr [ j ] % 2 == 1 ) {				  
      }							      	    }							    	    arr [ j ] -- ;					  
    }							      	  }							    	    result ++ ;						  
  }							      	}							    	  }							  
}							      }								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS			      SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS			    SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS			  SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS
--							      --							    --								  --
static void minRange ( int arr [ ] , int n , int k ) {	      void minRange ( int arr [ ] , int n , int k ) {		    void minRange ( int arr [ ] , int n , int k ) {		  script_not_found : None
  int l = 0 , r = n ;					      	int l = 0 , r = n ;					      int l = 0 , r = n ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    Set < Integer > s = new HashSet < Integer > ( ) ;	      	  unordered_set < int > s ;				    	set < int > s ;						  
    int j ;						      	  int j ;						    	int j ;							  
    for ( j = i ;					      	  for ( j = i ;						    	for ( j = i ;						  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      s . add ( arr [ j ] ) ;				      	    s . insert ( arr [ j ] ) ;				    	  s . insert ( arr [ j ] ) ;				  
      if ( s . size ( ) == k ) {			      	    if ( s . size ( ) == k ) {				    	  if ( s . size ( ) == k ) {				  
	if ( ( j - i ) < ( r - l ) ) {			      	      if ( ( j - i ) < ( r - l ) ) {			    	    if ( ( j - i ) < ( r - l ) ) {			  
	  r = j ;					      		r = j ;						    	      r = j ;						  
	  l = i ;					      		l = i ;						    	      l = i ;						  
	}						      	      }							    	    }							  
	break ;						      	      break ;						    	    break ;						  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
    if ( j == n ) break ;				      	  if ( j == n ) break ;					    	if ( j == n ) break ;					  
  }							      	}							      }								  
  if ( l == 0 && r == n ) System . out . println ( "Invalid k 	if ( l == 0 && r == n ) cout << "Invalid k" ;		      if ( l == 0 && r == n ) cout << "Invalid k" << endl ;	  
  else System . out . println ( l + " " + r ) ;		      	else cout << l << " " << r ;				      else cout << l << " " << r << endl ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE			      MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE			    MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE			  MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE
--							      --							    --								  --
static int maxcoefficientvalue ( int n ) {		      int maxcoefficientvalue ( int n ) {			    int maxcoefficientvalue ( int n ) {				  success : None
  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;		      	int C [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> C ( n + 1 , vector < int > ( n + 1 
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= Math . min ( i , n ) ;				      	  j <= min ( i , n ) ;					    	j <= min ( i , n ) ;					  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;	      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  if ( j == 0 || j == i ) {				  
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	    else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	    C [ i ] [ j ] = 1 ;					  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  int maxvalue = 0 ;					      	int maxvalue = 0 ;					    	    C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ 
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	  }							  
  i <= n ;						      	i <= n ;						    	}							  
  i ++ ) maxvalue = Math . max ( maxvalue , C [ n ] [ i ] ) ; 	i ++ ) maxvalue = max ( maxvalue , C [ n ] [ i ] ) ;	      }								  
  return maxvalue ;					      	return maxvalue ;					      int maxvalue = 0 ;					  
}							      }								      for ( int i = 0 ;						  
							      								      i <= n ;							  
							      								      i ++ ) {							  
							      								    	maxvalue = max ( maxvalue , C [ n ] [ i ] ) ;		  
							      								      }								  
							      								      return maxvalue ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_DERANGEMENT_SEQUENCE				      SMALLEST_DERANGEMENT_SEQUENCE				    SMALLEST_DERANGEMENT_SEQUENCE				  SMALLEST_DERANGEMENT_SEQUENCE
--							      --							    --								  --
static void generate_derangement ( int N ) {		      void generate_derangement ( int N ) {			    void generate_derangement ( int N ) {			  script_not_found : None
  int S [ ] = new int [ N + 1 ] ;			      	int S [ N + 1 ] ;					      int S [ N + 1 ] ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= N ;						      	i <= N ;						      i <= N ;							  
  i ++ ) S [ i ] = i ;					      	i ++ ) S [ i ] = i ;					      i ++ ) {							  
  int D [ ] = new int [ N + 1 ] ;			      	int D [ N + 1 ] ;					    	S [ i ] = i ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      }								  
  i <= N ;						      	i <= N ;						      int D [ N + 1 ] ;						  
  i += 2 ) {						      	i += 2 ) {						      for ( int i = 1 ;						  
    if ( i == N ) {					      	  if ( i == N && i % N != 0 ) {				      i <= N ;							  
      D [ N ] = S [ N - 1 ] ;				      	    int temp = D [ N ] D [ N ] = D [ N - 1 ] ;		      i += 2 ) {						  
      D [ N - 1 ] = S [ N ] ;				      	    D [ N - 1 ] = temp ;				    	if ( i == N ) {						  
    }							      	  }							    	  D [ N ] = S [ N - 1 ] ;				  
    else {						      	  else {						    	  D [ N - 1 ] = S [ N ] ;				  
      D [ i ] = i + 1 ;					      	    D [ i ] = i + 1 ;					    	}							  
      D [ i + 1 ] = i ;					      	    D [ i + 1 ] = i ;					    	else {							  
    }							      	  }							    	  D [ i ] = i + 1 ;					  
  }							      	}							    	  D [ i + 1 ] = i ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	}							  
  i <= N ;						      	i <= N ;						      }								  
  i ++ ) System . out . print ( D [ i ] + " " ) ;	      	i ++ ) printf ( "%d " , D [ i ] ) ;			      for ( int i = 1 ;						  
  System . out . println ( ) ;				      	printf ( "\n" ) ;					      i <= N ;							  
}							      }								      i ++ ) {							  
							      								    	cout << D [ i ] << " " ;				  
							      								      }								  
							      								      cout << endl ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUBARRAY_LEAST_AVERAGE				      FIND_SUBARRAY_LEAST_AVERAGE				    FIND_SUBARRAY_LEAST_AVERAGE					  FIND_SUBARRAY_LEAST_AVERAGE
--							      --							    --								  --
static void findMinAvgSubarray ( int n , int k ) {	      void findMinAvgSubarray ( int arr [ ] , int n , int k ) {	    void findMinAvgSubarray ( int n , int k ) {			  script_not_found : None
  if ( n < k ) return ;					      	if ( n < k ) return ;					      if ( n < k ) return ;					  
  int res_index = 0 ;					      	int res_index = 0 ;					      int resIndex = 0 ;					  
  int curr_sum = 0 ;					      	int curr_sum = 0 ;					      int currSum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < k ;						      	i < k ;							      i < k ;							  
  i ++ ) curr_sum += arr [ i ] ;			      	i ++ ) curr_sum += arr [ i ] ;				      i ++ ) {							  
  int min_sum = curr_sum ;				      	int min_sum = curr_sum ;				    	currSum += arr [ i ] ;					  
  for ( int i = k ;					      	for ( int i = k ;					      }								  
  i < n ;						      	i < n ;							      int minSum = currSum ;					  
  i ++ ) {						      	i ++ ) {						      for ( int i = k ;						  
    curr_sum += arr [ i ] - arr [ i - k ] ;		      	  curr_sum += arr [ i ] - arr [ i - k ] ;		      i < n ;							  
    if ( curr_sum < min_sum ) {				      	  if ( curr_sum < min_sum ) {				      i ++ ) {							  
      min_sum = curr_sum ;				      	    min_sum = curr_sum ;				    	currSum += arr [ i ] - arr [ i - k ] ;			  
      res_index = ( i - k + 1 ) ;			      	    res_index = ( i - k + 1 ) ;				    	if ( currSum < minSum ) {				  
    }							      	  }							    	  minSum = currSum ;					  
  }							      	}							    	  resIndex = ( i - k + 1 ) ;				  
  System . out . println ( "Subarray between [" + res_index + 	cout << "Subarray between [" << res_index << ", " << res_in 	}							  
}							      }								      }								  
							      								      cout << "Subarray between [" << resIndex << ", " << ( resIn 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_ MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_ MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_ MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_
--							      --							    --								  --
static int getMinSquares ( int n ) {			      int getMinSquares ( int n ) {				    int getMinSquares ( int n ) {				  success : None
  if ( n <= 3 ) return n ;				      	int * dp = new int [ n + 1 ] ;				      if ( n <= 3 ) return n ;					  
  int dp [ ] = new int [ n + 1 ] ;			      	dp [ 0 ] = 0 ;						      int dp [ n + 1 ] ;					  
  dp [ 0 ] = 0 ;					      	dp [ 1 ] = 1 ;						      dp [ 0 ] = 0 ;						  
  dp [ 1 ] = 1 ;					      	dp [ 2 ] = 2 ;						      dp [ 1 ] = 1 ;						  
  dp [ 2 ] = 2 ;					      	dp [ 3 ] = 3 ;						      dp [ 2 ] = 2 ;						  
  dp [ 3 ] = 3 ;					      	for ( int i = 4 ;					      dp [ 3 ] = 3 ;						  
  for ( int i = 4 ;					      	i <= n ;						      for ( int i = 4 ;						  
  i <= n ;						      	i ++ ) {						      i <= n ;							  
  i ++ ) {						      	  dp [ i ] = i ;					      i ++ ) {							  
    dp [ i ] = i ;					      	  for ( int x = 1 ;					    	dp [ i ] = i ;						  
    for ( int x = 1 ;					      	  x <= ceil ( sqrt ( i ) ) ;				    	for ( int x = 1 ;					  
    x <= Math . ceil ( Math . sqrt ( i ) ) ;		      	  x ++ ) {						    	x <= ceil ( sqrt ( i ) ) ;				  
    x ++ ) {						      	    int temp = x * x ;					    	x ++ ) {						  
      int temp = x * x ;				      	    if ( temp > i ) break ;				    	  int temp = x * x ;					  
      if ( temp > i ) break ;				      	    else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] )  	  if ( temp > i ) break ;				  
      else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - te 	  }							    	  else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] )  
    }							      	}							    	}							  
  }							      	int res = dp [ n ] ;					      }								  
  int res = dp [ n ] ;					      	delete [ ] dp ;						      int res = dp [ n ] ;					  
  return res ;						      	return res ;						      return res ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1
--							      --							    --								  --
static int maxSumWO3Consec ( int n ) {			      int maxSumWO3Consec ( int n ) {				    int maxSumWO3Consec ( int n ) {				  script_not_found : None
  if ( sum [ n ] != - 1 ) return sum [ n ] ;		      	if ( sum [ n ] != - 1 ) return sum [ n ] ;		      if ( sum [ n ] != - 1 ) return sum [ n ] ;		  
  if ( n == 0 ) return sum [ n ] = 0 ;			      	if ( n == 0 ) return sum [ n ] = 0 ;			      if ( n == 0 ) return sum [ n ] = 0 ;			  
  if ( n == 1 ) return sum [ n ] = arr [ 0 ] ;		      	if ( n == 1 ) return sum [ n ] = arr [ 0 ] ;		      if ( n == 1 ) return sum [ n ] = arr [ 0 ] ;		  
  if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ;    	if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ;      if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ;	  
  return sum [ n ] = Math . max ( Math . max ( maxSumWO3Conse 	return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) ,    return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) ,  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SQUARES_BINOMIAL_COEFFICIENTS			      SUM_SQUARES_BINOMIAL_COEFFICIENTS				    SUM_SQUARES_BINOMIAL_COEFFICIENTS				  SUM_SQUARES_BINOMIAL_COEFFICIENTS
--							      --							    --								  --
static int sumofsquare ( int n ) {			      int sumofsquare ( int n ) {				    int sumofsquare ( int n ) {					  success : None
  int [ ] [ ] C = new int [ n + 1 ] [ n + 1 ] ;		      	int C [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> C ( n + 1 , vector < int > ( n + 1 
  int i , j ;						      	int i , j ;						      int i , j ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( j = 0 ;					      	  for ( j = 0 ;						    	for ( j = 0 ;						  
    j <= min ( i , n ) ;				      	  j <= min ( i , n ) ;					    	j <= min ( i , n ) ;					  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;	      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  if ( j == 0 || j == i ) {				  
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	    else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	    C [ i ] [ j ] = 1 ;					  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  int sum = 0 ;						      	int sum = 0 ;						    	    C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ 
  for ( i = 0 ;						      	for ( int i = 0 ;					    	  }							  
  i <= n ;						      	i <= n ;						    	}							  
  i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ;	      	i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ;	      }								  
  return sum ;						      	return sum ;						      int sum = 0 ;						  
}							      }								      for ( i = 0 ;						  
							      								      i <= n ;							  
							      								      i ++ ) {							  
							      								    	sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ;		  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DISTANCE_TWO_POINTS_EARTH			      PROGRAM_DISTANCE_TWO_POINTS_EARTH				    PROGRAM_DISTANCE_TWO_POINTS_EARTH				  PROGRAM_DISTANCE_TWO_POINTS_EARTH
--							      --							    --								  --
public static double distance ( double lat1 , double lat2 , d long double distance ( long double lat1 , long double long1 , double distance ( double lat1 , double lat2 , double lon1 , d script_not_found : None
  lon1 = Math . toRadians ( lon1 ) ;			      	lat1 = toRadians ( lat1 ) ;				      lon1 = radians ( lon1 ) ;					  
  lon2 = Math . toRadians ( lon2 ) ;			      	long1 = toRadians ( long1 ) ;				      lon2 = radians ( lon2 ) ;					  
  lat1 = Math . toRadians ( lat1 ) ;			      	lat2 = toRadians ( lat2 ) ;				      lat1 = radians ( lat1 ) ;					  
  lat2 = Math . toRadians ( lat2 ) ;			      	long2 = toRadians ( long2 ) ;				      lat2 = radians ( lat2 ) ;					  
  double dlon = lon2 - lon1 ;				      	long double dlong = long2 - long1 ;			      double dlon = lon2 - lon1 ;				  
  double dlat = lat2 - lat1 ;				      	long double dlat = lat2 - lat1 ;			      double dlat = lat2 - lat1 ;				  
  double a = Math . pow ( Math . sin ( dlat / 2 ) , 2 ) + Mat 	long double ans = pow ( sin ( dlat / 2 ) , 2 ) + cos ( lat1   double a = pow ( sin ( dlat / 2 ) , 2 ) + cos ( lat1 ) * co 
  double c = 2 * Math . asin ( Math . sqrt ( a ) ) ;	      	ans = 2 * asin ( sqrt ( ans ) ) ;			      double c = 2 * asin ( sqrt ( a ) ) ;			  
  double r = 6371 ;					      	long double R = 6371 ;					      double r = 6371 ;						  
  return ( c * r ) ;					      	ans = ans * R ;						      return ( c * r ) ;					  
}							      	return ans ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_VALID_SEQUENCE_DIVISIBLE_M_1			      CHECK_VALID_SEQUENCE_DIVISIBLE_M_1			    CHECK_VALID_SEQUENCE_DIVISIBLE_M_1				  CHECK_VALID_SEQUENCE_DIVISIBLE_M_1
--							      --							    --								  --
static int isPossible ( int n , int index , int modulo , int  int isPossible ( int n , int index , int modulo , int M , int int isPossible ( int n , int index , int modulo , int M , int script_not_found : None
  modulo = ( ( modulo % M ) + M ) % M ;			      	modulo = ( ( modulo % M ) + M ) % M ;			      modulo = ( ( modulo % M ) + M ) % M ;			  
  if ( index == n ) {					      	if ( index == n ) {					      if ( index == n ) {					  
    if ( modulo == 0 ) {				      	  if ( modulo == 0 ) return 1 ;				    	if ( modulo == 0 ) return 1 ;				  
      return 1 ;					      	  return 0 ;						    	return 0 ;						  
    }							      	}							      }								  
    return 0 ;						      	if ( dp [ index ] [ modulo ] != - 1 ) return dp [ index ] [   if ( dp [ index ] [ modulo ] != - 1 ) return dp [ index ] [ 
  }							      	int placeAdd = isPossible ( n , index + 1 , modulo + arr [    int placeAdd = isPossible ( n , index + 1 , modulo + arr [  
  if ( dp [ index ] [ modulo ] != - 1 ) {		      	int placeMinus = isPossible ( n , index + 1 , modulo - arr    int placeMinus = isPossible ( n , index + 1 , modulo - arr  
    return dp [ index ] [ modulo ] ;			      	bool res = ( placeAdd || placeMinus ) ;			      int res = placeAdd ;					  
  }							      	dp [ index ] [ modulo ] = res ;				      dp [ index ] [ modulo ] = res ;				  
  int placeAdd = isPossible ( n , index + 1 , modulo + arr [  	return res ;						      return res ;						  
  int placeMinus = isPossible ( n , index + 1 , modulo - arr  }								    }								  
  int res = placeAdd ;					      								    								  
  dp [ index ] [ modulo ] = res ;			      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MEDIAN_OF_TWO_SORTED_ARRAYS				      MEDIAN_OF_TWO_SORTED_ARRAYS				    MEDIAN_OF_TWO_SORTED_ARRAYS					  MEDIAN_OF_TWO_SORTED_ARRAYS
--							      --							    --								  --
static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) {  int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) {	    int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) {	  success : identical to gold
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  int j = 0 ;						      	int j = 0 ;						      int j = 0 ;						  
  int count ;						      	int count ;						      int count ;						  
  int m1 = - 1 , m2 = - 1 ;				      	int m1 = - 1 , m2 = - 1 ;				      int m1 = - 1 , m2 = - 1 ;					  
  for ( count = 0 ;					      	for ( count = 0 ;					      for ( count = 0 ;						  
  count <= n ;						      	count <= n ;						      count <= n ;						  
  count ++ ) {						      	count ++ ) {						      count ++ ) {						  
    if ( i == n ) {					      	  if ( i == n ) {					    	if ( i == n ) {						  
      m1 = m2 ;						      	    m1 = m2 ;						    	  m1 = m2 ;						  
      m2 = ar2 [ 0 ] ;					      	    m2 = ar2 [ 0 ] ;					    	  m2 = ar2 [ 0 ] ;					  
      break ;						      	    break ;						    	  break ;						  
    }							      	  }							    	}							  
    else if ( j == n ) {				      	  else if ( j == n ) {					    	else if ( j == n ) {					  
      m1 = m2 ;						      	    m1 = m2 ;						    	  m1 = m2 ;						  
      m2 = ar1 [ 0 ] ;					      	    m2 = ar1 [ 0 ] ;					    	  m2 = ar1 [ 0 ] ;					  
      break ;						      	    break ;						    	  break ;						  
    }							      	  }							    	}							  
    if ( ar1 [ i ] < ar2 [ j ] ) {			      	  if ( ar1 [ i ] < ar2 [ j ] ) {			    	if ( ar1 [ i ] < ar2 [ j ] ) {				  
      m1 = m2 ;						      	    m1 = m2 ;						    	  m1 = m2 ;						  
      m2 = ar1 [ i ] ;					      	    m2 = ar1 [ i ] ;					    	  m2 = ar1 [ i ] ;					  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
    }							      	  }							    	}							  
    else {						      	  else {						    	else {							  
      m1 = m2 ;						      	    m1 = m2 ;						    	  m1 = m2 ;						  
      m2 = ar2 [ j ] ;					      	    m2 = ar2 [ j ] ;					    	  m2 = ar2 [ j ] ;					  
      j ++ ;						      	    j ++ ;						    	  j ++ ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return ( m1 + m2 ) / 2 ;				      	return ( m1 + m2 ) / 2 ;				      return ( m1 + m2 ) / 2 ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8	      GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8	    GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8	  GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8
--							      --							    --								  --
static boolean isSubSeqDivisible ( String str ) {	      bool isSubSeqDivisible ( string str ) {			    bool isSubSeqDivisible ( string str ) {			  script_not_found : None
  int i , j , k , l = str . length ( ) ;		      	for ( int i = 0 ;					      int i , j , k , l = str . length ( ) ;			  
  int arr [ ] = new int [ l ] ;				      	i < l ;							      int arr [ l ] ;						  
  for ( i = 0 ;						      	i ++ ) {						      for ( i = 0 ;						  
  i < l ;						      	  for ( int j = i ;					      i < l ;							  
  i ++ ) {						      	  j < l ;						      i ++ ) {							  
    for ( j = i ;					      	  j ++ ) {						    	for ( j = i ;						  
    j < l ;						      	    for ( int k = j ;					    	j < l ;							  
    j ++ ) {						      	    k < l ;						    	j ++ ) {						  
      for ( k = j ;					      	    k ++ ) {						    	  for ( k = j ;						  
      k < l ;						      	      if ( arr [ i ] % 8 == 0 ) return true ;		    	  k < l ;						  
      k ++ ) {						      	      else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 &&  	  k ++ ) {						  
	if ( arr [ i ] % 8 == 0 ) return true ;		      	      else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [  	    if ( arr [ i ] % 8 == 0 ) return true ;		  
	else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 &&  	    }							    	    else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 &&  
	else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [  	  }							    	    else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [  
      }							      	}							    	  }							  
    }							      	return false ;						    	}							  
  }							      }								      }								  
  return false ;					      								      return false ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_ LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_ LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_ LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_
--							      --							    --								  --
static void subsequence ( char s [ ] , char t [ ] , int n , i void subsequence ( char s [ ] , char t [ ] , int n , int k )  void subsequence ( char s [ ] , char t [ ] , int n , int k )  script_not_found : None
  int last = 0 , cnt = 0 , new_last = 0 , size = 0 ;	      	int last = 0 , cnt = 0 , new_last = 0 , size = 0 ;	      int last = 0 , cnt = 0 , new_last = 0 , size = 0 ;	  
  for ( char ch = 'z' ;					      	for ( char ch = 'z' ;					      for ( char ch = 'z' ;					  
  ch >= 'a' ;						      	ch >= 'a' ;						      ch >= 'a' ;						  
  ch -- ) {						      	ch -- ) {						      ch -- ) {							  
    cnt = 0 ;						      	  cnt = 0 ;						    	cnt = 0 ;						  
    for ( int i = last ;				      	  for ( int i = last ;					    	for ( int i = last ;					  
    i < n ;						      	  i < n ;						    	i < n ;							  
    i ++ ) {						      	  i ++ ) {						    	i ++ ) {						  
      if ( s [ i ] == ch ) cnt ++ ;			      	    if ( s [ i ] == ch ) cnt ++ ;			    	  if ( s [ i ] == ch ) {				  
    }							      	  }							    	    cnt ++ ;						  
    if ( cnt >= k ) {					      	  if ( cnt >= k ) {					    	  }							  
      for ( int i = last ;				      	    for ( int i = last ;				    	}							  
      i < n ;						      	    i < n ;						    	if ( cnt >= k ) {					  
      i ++ ) {						      	    i ++ ) {						    	  for ( int i = last ;					  
	if ( s [ i ] == ch ) {				      	      if ( s [ i ] == ch ) {				    	  i < n ;						  
	  t [ size ++ ] = ch ;				      		t [ size ++ ] = ch ;				    	  i ++ ) {						  
	  new_last = i ;				      		new_last = i ;					    	    if ( s [ i ] == ch ) {				  
	}						      	      }							    	      t [ size ++ ] = ch ;				  
      }							      	    }							    	      new_last = i ;					  
      last = new_last ;					      	    last = new_last ;					    	    }							  
    }							      	  }							    	  }							  
  }							      	}							    	  last = new_last ;					  
  t [ size ] = '\0' ;					      	t [ size ] = '\0' ;					    	}							  
}							      }								      }								  
							      								      t [ size ] = '\0' ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ROTATIONS_DIVISIBLE_4				      COUNT_ROTATIONS_DIVISIBLE_4				    COUNT_ROTATIONS_DIVISIBLE_4					  COUNT_ROTATIONS_DIVISIBLE_4
--							      --							    --								  --
static int countRotations ( String n ) {		      int countRotations ( string n ) {				    int countRotations ( string n ) {				  success : None
  int len = n . length ( ) ;				      	int len = n . length ( ) ;				      int len = n . length ( ) ;				  
  if ( len == 1 ) {					      	if ( len == 1 ) {					      if ( len == 1 ) {						  
    int oneDigit = n . charAt ( 0 ) - '0' ;		      	  int oneDigit = n . at ( 0 ) - '0' ;			    	int oneDigit = n [ 0 ] - '0' ;				  
    if ( oneDigit % 4 == 0 ) return 1 ;			      	  if ( oneDigit % 4 == 0 ) return 1 ;			    	if ( oneDigit % 4 == 0 ) return 1 ;			  
    return 0 ;						      	  return 0 ;						    	return 0 ;						  
  }							      	}							      }								  
  int twoDigit , count = 0 ;				      	int twoDigit , count = 0 ;				      int twoDigit , count = 0 ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < ( len - 1 ) ;					      	i < ( len - 1 ) ;					      i < ( len - 1 ) ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    twoDigit = ( n . charAt ( i ) - '0' ) * 10 + ( n . charAt 	  twoDigit = ( n . at ( i ) - '0' ) * 10 + ( n . at ( i + 1 	twoDigit = ( n [ i ] - '0' ) * 10 + ( n [ i + 1 ] - '0' ) 
    if ( twoDigit % 4 == 0 ) count ++ ;			      	  if ( twoDigit % 4 == 0 ) count ++ ;			    	if ( twoDigit % 4 == 0 ) count ++ ;			  
  }							      	}							      }								  
  twoDigit = ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . ch 	twoDigit = ( n . at ( len - 1 ) - '0' ) * 10 + ( n . at ( 0   twoDigit = ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) 
  if ( twoDigit % 4 == 0 ) count ++ ;			      	if ( twoDigit % 4 == 0 ) count ++ ;			      if ( twoDigit % 4 == 0 ) count ++ ;			  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT
--							      --							    --								  --
static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int error : FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_AR
  HashSet < Integer > s = new HashSet < Integer > ( ) ;	      	unordered_set < int > s ;				      set < int > s ;						  RAYS_SUCH_THAT_THAT_A_B_C_K_1.cpp: In function ‘bo
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  ol f_filled(int*, int*, int*, int, int, int, int)’
  i < n1 ;						      	i < n1 ;						      i < n1 ;							  : FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_S
  i ++ ) {						      	i ++ ) s . insert ( a1 [ i ] ) ;			      i ++ ) s . insert ( a1 [ i ] ) ;				  UCH_THAT_THAT_A_B_C_K_1.cpp:46:17: error: ‘class s
    s . add ( a1 [ i ] ) ;				      	for ( int i = 0 ;					      vector < int > al ( s . begin ( ) , s . end ( ) ) ;	  td::vector<int>’ has no member named ‘find’; did y
  }							      	i < n2 ;						      for ( int i = 0 ;						  ou mean ‘end’?	if ( al . find ( sum - a2 [
  ArrayList < Integer > al = new ArrayList < > ( s ) ;	      	i ++ ) {						      i < n2 ;							  i ] - a3 [ j ] ) != al . end ( ) & al . find ( sum
  for ( int i = 0 ;					      	  for ( int j = 0 ;					      i ++ ) {							   - a2 [ i ] - a3 [ j ] ) != al . end ( ) ) return
  i < n2 ;						      	  j < n3 ;						    	for ( int j = 0 ;					  true ;		  ^~~~			end
  i ++ ) {						      	  j ++ ) {						    	j < n3 ;						  FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUC
    for ( int j = 0 ;					      	    if ( s . find ( sum - a2 [ i ] - a3 [ j ] ) != s . end  	j ++ ) {						  H_THAT_THAT_A_B_C_K_1.cpp:46:75: error: ‘class std
    j < n3 ;						      	  }							    	  if ( al . find ( sum - a2 [ i ] - a3 [ j ] ) != al . en ::vector<int>’ has no member named ‘find’; did you
    j ++ ) {						      	}							    	}							   mean ‘end’?	      if ( al . find ( sum - a2 [ i
      if ( al . contains ( sum - a2 [ i ] - a3 [ j ] ) & al . 	return false ;						      }								  ] - a3 [ j ] ) != al . end ( ) & al . find ( sum -
	return true ;					      }								      return false ;						   a2 [ i ] - a3 [ j ] ) != al . end ( ) ) return tr
      }							      								    }								  ue ;
    }							      								    								  				^~~~
  }							      								    								  
  return false ;					      								    								  	    end
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1   SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1   SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1	  SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1
--							      --							    --								  --
static int getTotalNumberOfSequences ( int m , int n ) {      int getTotalNumberOfSequences ( int m , int n ) {		    int getTotalNumberOfSequences ( int m , int n ) {		  success : None
  int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;		      	int T [ m + 1 ] [ n + 1 ] ;				      int T [ m + 1 ] [ n + 1 ] ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m + 1 ;						      	i < m + 1 ;						      i < m + 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n + 1 ;						      	  j < n + 1 ;						    	j < n + 1 ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ;	      	    if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ;		    	  if ( i == 0 || j == 0 ) {				  
      else if ( i < j ) T [ i ] [ j ] = 0 ;		      	    else if ( i < j ) T [ i ] [ j ] = 0 ;		    	    T [ i ] [ j ] = 0 ;					  
      else if ( j == 1 ) T [ i ] [ j ] = i ;		      	    else if ( j == 1 ) T [ i ] [ j ] = i ;		    	  }							  
      else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [  	    else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [  	  else if ( i < j ) {					  
    }							      	  }							    	    T [ i ] [ j ] = 0 ;					  
  }							      	}							    	  }							  
  return T [ m ] [ n ] ;				      	return T [ m ] [ n ] ;					    	  else if ( j == 1 ) {					  
}							      }								    	    T [ i ] [ j ] = i ;					  
							      								    	  }							  
							      								    	  else {						  
							      								    	    T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return T [ m ] [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K		      MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K		    MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K		  MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K
--							      --							    --								  --
static void pairs ( int arr [ ] , int n , int k ) {	      void pairs ( int arr [ ] , int n , int k ) {		    void pairs ( int arr [ ] , int n , int k ) {		  script_not_found : None
  int smallest = Integer . MAX_VALUE ;			      	int smallest = INT_MAX ;				      int smallest = INT_MAX ;					  
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = i + 1 ;				      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) {						      	j ++ ) {						      j ++ ) {							  
    if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest  	  if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) {	    	if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) {	  
      smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ;   	    smallest = abs ( arr [ i ] + arr [ j ] - k ) ;	    	  smallest = abs ( arr [ i ] + arr [ j ] - k ) ;	  
      count = 1 ;					      	    count = 1 ;						    	  count = 1 ;						  
    }							      	  }							    	}							  
    else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == sma 	  else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) 	else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) 
  }							      	}							    	  count ++ ;						  
  System . out . println ( "Minimal Value = " + smallest ) ;  	cout << "Minimal Value = " << smallest << "\n" ;	    	}							  
  System . out . println ( "Total Pairs = " + count ) ;	      	cout << "Total Pairs = " << count << "\n" ;		      }								  
}							      }								      cout << "Minimal Value = " << smallest << endl ;		  
							      								      cout << "Total Pairs = " << count << endl ;		  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST
--							      --							    --								  --
static void printClosest ( int arr [ ] , int n , int x ) {    void printClosest ( int arr [ ] , int n , int x ) {	    void print_closest ( int arr [ ] , int n , int x ) {	  script_not_found : None
  int res_l = 0 , res_r = 0 ;				      	int res_l , res_r ;					      int res_l = 0 , res_r = 0 ;				  
  int l = 0 , r = n - 1 , diff = Integer . MAX_VALUE ;	      	int l = 0 , r = n - 1 , diff = INT_MAX ;		      int l = 0 , r = n - 1 , diff = INT_MAX ;			  
  while ( r > l ) {					      	while ( r > l ) {					      while ( r > l ) {						  
    if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) {  	  if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) {	    	if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) {	  
      res_l = l ;					      	    res_l = l ;						    	  res_l = l ;						  
      res_r = r ;					      	    res_r = r ;						    	  res_r = r ;						  
      diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ;	      	    diff = abs ( arr [ l ] + arr [ r ] - x ) ;		    	  diff = abs ( arr [ l ] + arr [ r ] - x ) ;		  
    }							      	  }							    	}							  
    if ( arr [ l ] + arr [ r ] > x ) r -- ;		      	  if ( arr [ l ] + arr [ r ] > x ) r -- ;		    	if ( arr [ l ] + arr [ r ] > x ) {			  
    else l ++ ;						      	  else l ++ ;						    	  r -- ;						  
  }							      	}							    	}							  
  System . out . println ( " The closest pair is " + arr [ re 	cout << " The closest pair is " << arr [ res_l ] << " and " 	else {							  
}							      }								    	  l ++ ;						  
							      								    	}							  
							      								      }								  
							      								      cout << " The closest pair is " << arr [ res_l ] << " and " 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA			      FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA			    FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA			  FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA
--							      --							    --								  --
static void parabola ( float a , float b , float c ) {	      void parabola ( float a , float b , float c ) {		    void parabola ( float a , float b , float c ) {		  script_not_found : None
  System . out . println ( "Vertex: (" + ( - b / ( 2 * a ) )  	cout << "Vertex: (" << ( - b / ( 2 * a ) ) << ", " << ( ( (   cout << "Vertex: (" << ( - b / ( 2 * a ) ) << ", " << ( ( ( 
  System . out . println ( "Focus: (" + ( - b / ( 2 * a ) ) + 	cout << "Focus: (" << ( - b / ( 2 * a ) ) << ", " << ( ( (    cout << "Focus: (" << ( - b / ( 2 * a ) ) << ", " << ( ( (  
  System . out . println ( "Directrix:" + " y=" + ( int ) ( c 	cout << "Directrix: y=" << c - ( ( b * b ) + 1 ) * 4 * a <<   cout << "Directrix:" << " y=" << ( int ) ( c - ( ( b * b )  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE			      MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE			    MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE			  MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE
--							      --							    --								  --
static int maxSumPairWithDifferenceLessThanK ( int arr [ ] ,  int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , success : None
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + N ) ;				      sort ( arr , arr + N ) ;					  
  int dp [ ] = new int [ N ] ;				      	int dp [ N ] ;						      int dp [ N ] ;						  
  dp [ 0 ] = 0 ;					      	dp [ 0 ] = 0 ;						      dp [ 0 ] = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    dp [ i ] = dp [ i - 1 ] ;				      	  dp [ i ] = dp [ i - 1 ] ;				    	dp [ i ] = dp [ i - 1 ] ;				  
    if ( arr [ i ] - arr [ i - 1 ] < K ) {		      	  if ( arr [ i ] - arr [ i - 1 ] < K ) {		    	if ( arr [ i ] - arr [ i - 1 ] < K ) {			  
      if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i 	    if ( i >= 2 ) dp [ i ] = max ( dp [ i ] , dp [ i - 2 ]  	  if ( i >= 2 ) {					  
      else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr 	    else dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i -  	    dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ]  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  return dp [ N - 1 ] ;					      	return dp [ N - 1 ] ;					    	    dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] 
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return dp [ N - 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T
--							      --							    --								  --
static int maxDifference ( int arr [ ] , int N , int k ) {    int maxDifference ( int arr [ ] , int N , int k ) {	    int maxDifference ( int arr [ ] , int N , int k ) {		  success : None
  int M , S = 0 , S1 = 0 , max_difference = 0 ;		      	int M , S = 0 , S1 = 0 , max_difference = 0 ;		      int M , S = 0 , S1 = 0 , maxDifference = 0 ;		  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) S += arr [ i ] ;				      	i ++ ) S += arr [ i ] ;					      i ++ ) {							  
  int temp ;						      	sort ( arr , arr + N , greater < int > ( ) ) ;		    	S += arr [ i ] ;					  
  for ( int i = 0 ;					      	M = max ( k , N - k ) ;					      }								  
  i < N ;						      	for ( int i = 0 ;					      int temp ;						  
  i ++ ) {						      	i < M ;							      for ( int i = 0 ;						  
    for ( int j = i + 1 ;				      	i ++ ) S1 += arr [ i ] ;				      i < N ;							  
    j < N ;						      	max_difference = S1 - ( S - S1 ) ;			      i ++ ) {							  
    j ++ ) {						      	return max_difference ;					    	for ( int j = i + 1 ;					  
      if ( arr [ i ] < arr [ j ] ) {			      }								    	j < N ;							  
	temp = arr [ i ] ;				      								    	j ++ ) {						  
	arr [ i ] = arr [ j ] ;				      								    	  if ( arr [ i ] < arr [ j ] ) {			  
	arr [ j ] = temp ;				      								    	    temp = arr [ i ] ;					  
      }							      								    	    arr [ i ] = arr [ j ] ;				  
    }							      								    	    arr [ j ] = temp ;					  
  }							      								    	  }							  
  M = Math . max ( k , N - k ) ;			      								    	}							  
  for ( int i = 0 ;					      								      }								  
  i < M ;						      								      M = max ( k , N - k ) ;					  
  i ++ ) S1 += arr [ i ] ;				      								      for ( int i = 0 ;						  
  max_difference = S1 - ( S - S1 ) ;			      								      i < M ;							  
  return max_difference ;				      								      i ++ ) {							  
}							      								    	S1 += arr [ i ] ;					  
							      								      }								  
							      								      maxDifference = S1 - ( S - S1 ) ;				  
							      								      return maxDifference ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2	  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2
--							      --							    --								  --
static int findLength ( String str , int n ) {		      int findLength ( string str , int n ) {			    int findLength ( string str , int n ) {			  script_not_found : None
  int sum [ ] = new int [ n + 1 ] ;			      	int sum [ n + 1 ] ;					      vector < int > sum ( n + 1 , 0 ) ;			  
  sum [ 0 ] = 0 ;					      	sum [ 0 ] = 0 ;						      sum [ 0 ] = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) sum [ i ] = ( sum [ i - 1 ] + str . charAt ( i - 1 ) 	i ++ ) sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] - '0' )    i ++ ) {							  
  int ans = 0 ;						      	int ans = 0 ;						    	sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] - '0' ) ;	  
  for ( int len = 2 ;					      	for ( int len = 2 ;					      }								  
  len <= n ;						      	len <= n ;						      int ans = 0 ;						  
  len += 2 ) {						      	len += 2 ) {						      for ( int len = 2 ;					  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					      len <= n ;						  
    i <= n - len ;					      	  i <= n - len ;					      len += 2 ) {						  
    i ++ ) {						      	  i ++ ) {						    	for ( int i = 0 ;					  
      int j = i + len - 1 ;				      	    int j = i + len - 1 ;				    	i <= n - len ;						  
      if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] 	    if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] 	i ++ ) {						  
    }							      	  }							    	  int j = i + len - 1 ;					  
  }							      	}							    	  if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] 
  return ans ;						      	return ans ;						    	    ans = max ( ans , len ) ;				  
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH		      FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH			    FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH			  FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH
--							      --							    --								  --
static int findMaxAverage ( int [ ] arr , int n , int k ) {   int findMaxAverage ( int arr [ ] , int n , int k ) {	    int findMaxAverage ( int * arr , int n , int k ) {		  success : None
  if ( k > n ) return - 1 ;				      	if ( k > n ) return - 1 ;				      if ( k > n ) return - 1 ;					  
  int [ ] csum = new int [ n ] ;			      	int * csum = new int [ n ] ;				      int csum [ n ] ;						  
  csum [ 0 ] = arr [ 0 ] ;				      	csum [ 0 ] = arr [ 0 ] ;				      csum [ 0 ] = arr [ 0 ] ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ;	      	i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ;	      i ++ ) {							  
  int max_sum = csum [ k - 1 ] , max_end = k - 1 ;	      	int max_sum = csum [ k - 1 ] , max_end = k - 1 ;	    	csum [ i ] = csum [ i - 1 ] + arr [ i ] ;		  
  for ( int i = k ;					      	for ( int i = k ;					      }								  
  i < n ;						      	i < n ;							      int max_sum = csum [ k - 1 ] , max_end = k - 1 ;		  
  i ++ ) {						      	i ++ ) {						      for ( int i = k ;						  
    int curr_sum = csum [ i ] - csum [ i - k ] ;	      	  int curr_sum = csum [ i ] - csum [ i - k ] ;		      i < n ;							  
    if ( curr_sum > max_sum ) {				      	  if ( curr_sum > max_sum ) {				      i ++ ) {							  
      max_sum = curr_sum ;				      	    max_sum = curr_sum ;				    	int curr_sum = csum [ i ] - csum [ i - k ] ;		  
      max_end = i ;					      	    max_end = i ;					    	if ( curr_sum > max_sum ) {				  
    }							      	  }							    	  max_sum = curr_sum ;					  
  }							      	}							    	  max_end = i ;						  
  return max_end - k + 1 ;				      	delete [ ] csum ;					    	}							  
}							      	return max_end - k + 1 ;				      }								  
							      }								      return max_end - k + 1 ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1		      FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1		    FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1			  FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1
--							      --							    --								  --
static void findTriplets ( int arr [ ] , int n ) {	      void findTriplets ( int arr [ ] , int n ) {		    void findTriplets ( int arr [ ] , int n ) {			  script_not_found : None
  boolean found = false ;				      	bool found = false ;					      bool found = false ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    HashSet < Integer > s = new HashSet < Integer > ( ) ;     	  unordered_set < int > s ;				    	set < int > s ;						  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      int x = - ( arr [ i ] + arr [ j ] ) ;		      	    int x = - ( arr [ i ] + arr [ j ] ) ;		    	  int x = - ( arr [ i ] + arr [ j ] ) ;			  
      if ( s . contains ( x ) ) {			      	    if ( s . find ( x ) != s . end ( ) ) {		    	  if ( s . find ( x ) != s . end ( ) ) {		  
	System . out . printf ( "%d %d %d\n" , x , arr [ i ]  	      printf ( "%d %d %d\n" , x , arr [ i ] , arr [ j ] ) ; 	    cout << x << " " << arr [ i ] << " " << arr [ j ] <<  
	found = true ;					      	      found = true ;					    	    found = true ;					  
      }							      	    }							    	  }							  
      else {						      	    else s . insert ( arr [ j ] ) ;			    	  else s . insert ( arr [ j ] ) ;			  
	s . add ( arr [ j ] ) ;				      	  }							    	}							  
      }							      	}							      }								  
    }							      	if ( found == false ) cout << " No Triplet Found" << endl ;   if ( found == false ) cout << " No Triplet Found" << endl ; 
  }							      }								    }								  
  if ( found == false ) {				      								    								  
    System . out . printf ( " No Triplet Found\n" ) ;	      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE
--							      --							    --								  --
public static int maxLenSub ( int arr [ ] , int n ) {	      int maxLenSub ( int arr [ ] , int n ) {			    int maxLenSub ( int arr [ ] , int n ) {			  success : None
  int mls [ ] = new int [ n ] , max = 0 ;		      	int mls [ n ] , max = 0 ;				      int mls [ n ] , max = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) mls [ i ] = 1 ;				      	i ++ ) mls [ i ] = 1 ;					      i ++ ) {							  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	mls [ i ] = 1 ;						  
  i < n ;						      	i < n ;							      }								  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      for ( int i = 1 ;						  
  j < i ;						      	j < i ;							      i < n ;							  
  j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && ml 	j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ]   i ++ ) for ( int j = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      j < i ;							  
  i < n ;						      	i < n ;							      j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] 
  i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ;	      	i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ;		      for ( int i = 0 ;						  
  return max ;						      	return max ;						      i < n ;							  
}							      }								      i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ;		  
							      								      return max ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS		      LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS			    LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS			  LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS
--							      --							    --								  --
static void longest ( int a [ ] , int n , int k ) {	      void longest ( int a [ ] , int n , int k ) {		    void longest ( int a [ ] , int n , int k ) {		  script_not_found : None
  int [ ] freq = new int [ 7 ] ;			      	unordered_map < int , int > freq ;			      int freq [ 7 ] ;						  
  int start = 0 , end = 0 , now = 0 , l = 0 ;		      	int start = 0 , end = 0 , now = 0 , l = 0 ;		      int start = 0 , end = 0 , now = 0 , l = 0 ;		  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    freq [ a [ i ] ] ++ ;				      	  freq [ a [ i ] ] ++ ;					    	freq [ a [ i ] ] ++ ;					  
    if ( freq [ a [ i ] ] == 1 ) now ++ ;		      	  if ( freq [ a [ i ] ] == 1 ) now ++ ;			    	if ( freq [ a [ i ] ] == 1 ) now ++ ;			  
    while ( now > k ) {					      	  while ( now > k ) {					    	while ( now > k ) {					  
      freq [ a [ l ] ] -- ;				      	    freq [ a [ l ] ] -- ;				    	  freq [ a [ l ] ] -- ;					  
      if ( freq [ a [ l ] ] == 0 ) now -- ;		      	    if ( freq [ a [ l ] ] == 0 ) now -- ;		    	  if ( freq [ a [ l ] ] == 0 ) now -- ;			  
      l ++ ;						      	    l ++ ;						    	  l ++ ;						  
    }							      	  }							    	}							  
    if ( i - l + 1 >= end - start + 1 ) {		      	  if ( i - l + 1 >= end - start + 1 ) end = i , start = l ; 	if ( i - l + 1 >= end - start + 1 ) {			  
      end = i ;						      	}							    	  end = i ;						  
      start = l ;					      	for ( int i = start ;					    	  start = l ;						  
    }							      	i <= end ;						    	}							  
  }							      	i ++ ) cout << a [ i ] << " " ;				      }								  
  for ( int i = start ;					      }								      for ( int i = start ;					  
  i <= end ;						      								      i <= end ;						  
  i ++ ) System . out . print ( a [ i ] + " " ) ;	      								      i ++ ) {							  
}							      								    	cout << a [ i ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA
--							      --							    --								  --
static int possibleStrings ( int n , int r , int b , int g )  int possibleStrings ( int n , int r , int b , int g ) {	    int possibleStrings ( int n , int r , int b , int g ) {	  script_not_found : None
  int fact [ ] = new int [ n + 1 ] ;			      	int fact [ n + 1 ] ;					      int fact [ n + 1 ] ;					  
  fact [ 0 ] = 1 ;					      	fact [ 0 ] = 1 ;					      fact [ 0 ] = 1 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) fact [ i ] = fact [ i - 1 ] * i ;		      	i ++ ) fact [ i ] = fact [ i - 1 ] * i ;		      i ++ ) {							  
  int left = n - ( r + g + b ) ;			      	int left = n - ( r + g + b ) ;				    	fact [ i ] = fact [ i - 1 ] * i ;			  
  int sum = 0 ;						      	int sum = 0 ;						      }								  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      int left = n - ( r + g + b ) ;				  
  i <= left ;						      	i <= left ;						      int sum = 0 ;						  
  i ++ ) {						      	i ++ ) {						      for ( int i = 0 ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      i <= left ;						  
    j <= left - i ;					      	  j <= left - i ;					      i ++ ) {							  
    j ++ ) {						      	  j ++ ) {						    	for ( int j = 0 ;					  
      int k = left - ( i + j ) ;			      	    int k = left - ( i + j ) ;				    	j <= left - i ;						  
      sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j +  	    sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j +  	j ++ ) {						  
    }							      	  }							    	  int k = left - ( i + j ) ;				  
  }							      	}							    	  sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j +  
  return sum ;						      	return sum ;						    	}							  
}							      }								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS		      MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS		    MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS			  MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS
--							      --							    --								  --
static void find ( Vector < String > list1 , Vector < String  void find ( vector < string > list1 , vector < string > list2 void find ( vector < string > list1 , vector < string > list2 script_not_found : None
  Vector < String > res = new Vector < > ( ) ;		      	vector < string > res ;					      vector < string > res ;					  
  int max_possible_sum = list1 . size ( ) + list2 . size ( )  	int max_possible_sum = list1 . size ( ) + list2 . size ( )    int max_possible_sum = list1 . size ( ) + list2 . size ( )  
  for ( int sum = 0 ;					      	for ( int sum = 0 ;					      for ( int sum = 0 ;					  
  sum <= max_possible_sum ;				      	sum <= max_possible_sum ;				      sum <= max_possible_sum ;					  
  sum ++ ) {						      	sum ++ ) {						      sum ++ ) {						  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
    i <= sum ;						      	  i <= sum ;						    	i <= sum ;						  
    i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . 	  i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . 	i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . 
    if ( res . size ( ) > 0 ) break ;			      	  if ( res . size ( ) > 0 ) break ;			    	if ( res . size ( ) > 0 ) break ;			  
  }							      	}							      }								  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < res . size ( ) ;					      	i < res . size ( ) ;					      i < res . size ( ) ;					  
  i ++ ) System . out . print ( res . get ( i ) + " " ) ;     	i ++ ) cout << res [ i ] << " " ;			      i ++ ) cout << res [ i ] << " " ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1		      THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1		    THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1		  THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1
--							      --							    --								  --
static void thirdLargest ( int arr [ ] , int arr_size ) {     void thirdLargest ( int arr [ ] , int arr_size ) {	    void thirdLargest ( int arr [ ] , int arr_size ) {		  script_not_found : None
  if ( arr_size < 3 ) {					      	if ( arr_size < 3 ) {					      if ( arr_size < 3 ) {					  
    System . out . printf ( " Invalid Input " ) ;	      	  printf ( " Invalid Input " ) ;			    	printf ( " Invalid Input " ) ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  int first = arr [ 0 ] , second = Integer . MIN_VALUE , thir 	int first = arr [ 0 ] , second = INT_MIN , third = INT_MIN    int first = arr [ 0 ] , second = INT_MAX , third = INT_MAX  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < arr_size ;					      	i < arr_size ;						      i < arr_size ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] > first ) {				      	  if ( arr [ i ] > first ) {				    	if ( arr [ i ] > first ) {				  
      third = second ;					      	    third = second ;					    	  third = second ;					  
      second = first ;					      	    second = first ;					    	  second = first ;					  
      first = arr [ i ] ;				      	    first = arr [ i ] ;					    	  first = arr [ i ] ;					  
    }							      	  }							    	}							  
    else if ( arr [ i ] > second ) {			      	  else if ( arr [ i ] > second ) {			    	else if ( arr [ i ] > second ) {			  
      third = second ;					      	    third = second ;					    	  third = second ;					  
      second = arr [ i ] ;				      	    second = arr [ i ] ;				    	  second = arr [ i ] ;					  
    }							      	  }							    	}							  
    else if ( arr [ i ] > third ) {			      	  else if ( arr [ i ] > third ) third = arr [ i ] ;	    	else if ( arr [ i ] > third ) third = arr [ i ] ;	  
      third = arr [ i ] ;				      	}							      }								  
    }							      	printf ( "The third Largest element is %d\n" , third ) ;      printf ( "The third Largest element is %d\n" , third ) ;	  
  }							      }								    }								  
  System . out . printf ( "The third Largest element is %d\n" 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_MAXIMUM_GCD_ARRAY				      FIND_PAIR_MAXIMUM_GCD_ARRAY				    FIND_PAIR_MAXIMUM_GCD_ARRAY					  FIND_PAIR_MAXIMUM_GCD_ARRAY
--							      --							    --								  --
public static int findMaxGCD ( int arr [ ] , int n ) {	      int findMaxGCD ( int arr [ ] , int n ) {			    int findMaxGCD ( int arr [ ] , int n ) {			  failure : #Results: 2, 10
  int high = 0 ;					      	int high = 0 ;						      int high = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) high = Math . max ( high , arr [ i ] ) ;	      	i ++ ) high = max ( high , arr [ i ] ) ;		      i ++ ) {							  
  int divisors [ ] = new int [ high + 1 ] ;		      	int divisors [ high + 1 ] = {				    	high = max ( high , arr [ i ] ) ;			  
  for ( int i = 0 ;					      	  0 }							      }								  
  i < n ;						      	  ;							      int divisors [ high + 1 ] ;				  
  i ++ ) {						      	  for ( int i = 0 ;					      for ( int i = 0 ;						  
    for ( int j = 1 ;					      	  i < n ;						      i < n ;							  
    j <= Math . sqrt ( arr [ i ] ) ;			      	  i ++ ) {						      i ++ ) {							  
    j ++ ) {						      	    for ( int j = 1 ;					    	for ( int j = 1 ;					  
      if ( arr [ i ] % j == 0 ) {			      	    j <= sqrt ( arr [ i ] ) ;				    	j <= sqrt ( arr [ i ] ) ;				  
	divisors [ j ] ++ ;				      	    j ++ ) {						    	j ++ ) {						  
	if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ]  	      if ( arr [ i ] % j == 0 ) {			    	  if ( arr [ i ] % j == 0 ) {				  
      }							      		divisors [ j ] ++ ;				    	    divisors [ j ] ++ ;					  
    }							      		if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j  	    if ( j != arr [ i ] / j ) {				  
  }							      	      }							    	      divisors [ arr [ i ] / j ] ++ ;			  
  for ( int i = high ;					      	    }							    	    }							  
  i >= 1 ;						      	  }							    	  }							  
  i -- ) if ( divisors [ i ] > 1 ) return i ;		      	  for ( int i = high ;					    	}							  
  return 1 ;						      	  i >= 1 ;						      }								  
}							      	  i -- ) if ( divisors [ i ] > 1 ) return i ;		      for ( int i = high ;					  
							      	}							      i >= 1 ;							  
							      								      i -- ) if ( divisors [ i ] > 1 ) return i ;		  
							      								      return 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_AREA_RECTANGLES_POSSIBLE_ARRAY			      SUM_AREA_RECTANGLES_POSSIBLE_ARRAY			    SUM_AREA_RECTANGLES_POSSIBLE_ARRAY				  SUM_AREA_RECTANGLES_POSSIBLE_ARRAY
--							      --							    --								  --
static int MaxTotalRectangleArea ( int [ ] a , int n ) {      int MaxTotalRectangleArea ( int a [ ] , int n ) {		    int MaxTotalRectangleArea ( int * a , int n ) {		  failure : #Results: 6, 10
  Arrays . sort ( a ) ;					      	sort ( a , a + n , greater < int > ( ) ) ;		      sort ( a , a + n ) ;					  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  boolean flag = false ;				      	bool flag = false ;					      bool flag = false ;					  
  int len = 0 ;						      	int len ;						      int len = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 	  if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 	if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 
      flag = true ;					      	    flag = true ;					    	  flag = true ;						  
      len = a [ i + 1 ] ;				      	    len = a [ i + 1 ] ;					    	  len = a [ i + 1 ] ;					  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
    }							      	  }							    	}							  
    else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 	  else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 	else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 
      sum = sum + a [ i + 1 ] * len ;			      	    sum = sum + a [ i + 1 ] * len ;			    	  sum = sum + a [ i + 1 ] * len ;			  
      flag = false ;					      	    flag = false ;					    	  flag = false ;					  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return sum ;						      	return sum ;						      return sum ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH	      SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH	    SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH	  SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH
--							      --							    --								  --
int shortestPath ( int graph [ ] [ ] , int u , int v , int k  INT_MAX int shortestPath ( int graph [ ] [ V ] , int u , int  int shortestPath ( int graph [ ] [ V ] , int u , int v , int  script_not_found : None
  if ( k == 0 && u == v ) return 0 ;			      	if ( k == 0 && u == v ) return 0 ;			      if ( k == 0 && u == v ) return 0 ;			  
  if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u  	if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u    if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u  
  if ( k <= 0 ) return INF ;				      	if ( k <= 0 ) return INF ;				      if ( k <= 0 ) return INF ;				  
  int res = INF ;					      	int res = INF ;						      int res = INF ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < V ;						      	i < V ;							      i < V ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( graph [ u ] [ i ] != INF && u != i && v != i ) {     	  if ( graph [ u ] [ i ] != INF && u != i && v != i ) {	    	if ( graph [ u ] [ i ] != INF && u != i && v != i ) {	  
      int rec_res = shortestPath ( graph , i , v , k - 1 ) ;  	    int rec_res = shortestPath ( graph , i , v , k - 1 ) ;  	  int rec_res = shortestPath ( graph , i , v , k - 1 ) ;  
      if ( rec_res != INF ) res = Math . min ( res , graph [  	    if ( rec_res != INF ) res = min ( res , graph [ u ] [ i 	  if ( rec_res != INF ) {				  
    }							      	  }							    	    res = min ( res , graph [ u ] [ i ] + rec_res ) ;	  
  }							      	}							    	  }							  
  return res ;						      	return res ;						    	}							  
}							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES	      REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES		    REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES		  REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES
--							      --							    --								  --
static void arrangeString ( String str , int x , int y ) {    void arrangeString ( string str , int x , int y ) {	    void arrangeString ( string str , int x , int y ) {		  script_not_found : None
  int count_0 = 0 ;					      	int count_0 = 0 ;					      int count_0 = 0 ;						  
  int count_1 = 0 ;					      	int count_1 = 0 ;					      int count_1 = 0 ;						  
  int len = str . length ( ) ;				      	int len = str . length ( ) ;				      int len = str . length ( ) ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < len ;						      	i < len ;						      i < len ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( str . charAt ( i ) == '0' ) count_0 ++ ;	      	  if ( str [ i ] == '0' ) count_0 ++ ;			    	if ( str [ i ] == '0' ) {				  
    else count_1 ++ ;					      	  else count_1 ++ ;					    	  count_0 ++ ;						  
  }							      	}							    	}							  
  while ( count_0 > 0 || count_1 > 0 ) {		      	while ( count_0 > 0 || count_1 > 0 ) {			    	else {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	  count_1 ++ ;						  
    j < x && count_0 > 0 ;				      	  j < x && count_0 > 0 ;				    	}							  
    j ++ ) {						      	  j ++ ) {						      }								  
      if ( count_0 > 0 ) {				      	    if ( count_0 > 0 ) {				      while ( count_0 > 0 || count_1 > 0 ) {			  
	System . out . print ( "0" ) ;			      	      cout << "0" ;					    	for ( int j = 0 ;					  
	count_0 -- ;					      	      count_0 -- ;					    	j < x && count_0 > 0 ;					  
      }							      	    }							    	j ++ ) {						  
    }							      	  }							    	  if ( count_0 > 0 ) {					  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	    cout << "0" ;					  
    j < y && count_1 > 0 ;				      	  j < y && count_1 > 0 ;				    	    count_0 -- ;					  
    j ++ ) {						      	  j ++ ) {						    	  }							  
      if ( count_1 > 0 ) {				      	    if ( count_1 > 0 ) {				    	}							  
	System . out . print ( "1" ) ;			      	      cout << "1" ;					    	for ( int j = 0 ;					  
	count_1 -- ;					      	      count_1 -- ;					    	j < y && count_1 > 0 ;					  
      }							      	    }							    	j ++ ) {						  
    }							      	  }							    	  if ( count_1 > 0 ) {					  
  }							      	}							    	    cout << "1" ;					  
}							      }								    	    count_1 -- ;					  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1      COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1	    COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1	  COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1
--							      --							    --								  --
static int countP ( int n , int k ) {			      int countP ( int n , int k ) {				    int countP ( int n , int k ) {				  script_not_found : None
  int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ;	      	int dp [ n + 1 ] [ k + 1 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( k +  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) dp [ i ] [ 0 ] = 0 ;				      	i ++ ) dp [ i ] [ 0 ] = 0 ;				      i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	dp [ i ] [ 0 ] = 0 ;					  
  i <= k ;						      	i <= k ;						      }								  
  i ++ ) dp [ 0 ] [ k ] = 0 ;				      	i ++ ) dp [ 0 ] [ k ] = 0 ;				      for ( int i = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      i <= k ;							  
  i <= n ;						      	i <= n ;						      i ++ ) {							  
  i ++ ) for ( int j = 1 ;				      	i ++ ) for ( int j = 1 ;				    	dp [ 0 ] [ k ] = 0 ;					  
  j <= k ;						      	j <= i ;						      }								  
  j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ;	      	j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ;	      for ( int i = 1 ;						  
  else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] 	else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ]   i <= n ;							  
  return dp [ n ] [ k ] ;				      	return dp [ n ] [ k ] ;					      i ++ ) for ( int j = 1 ;					  
}							      }								      j <= k ;							  
							      								      j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ;	  
							      								      else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] 
							      								      return dp [ n ] [ k ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE
--							      --							    --								  --
static int maxSumIS ( int arr [ ] , int n ) {		      int maxSumIS ( int arr [ ] , int n ) {			    int maxSumIS ( int arr [ ] , int n ) {			  success : None
  int i , j , max = 0 ;					      	int i , j , max = 0 ;					      int i , j , max = 0 ;					  
  int msis [ ] = new int [ n ] ;			      	int msis [ n ] ;					      int msis [ n ] ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) msis [ i ] = arr [ i ] ;			      	i ++ ) msis [ i ] = arr [ i ] ;				      i ++ ) {							  
  for ( i = 1 ;						      	for ( i = 1 ;						    	msis [ i ] = arr [ i ] ;				  
  i < n ;						      	i < n ;							      }								  
  i ++ ) for ( j = 0 ;					      	i ++ ) for ( j = 0 ;					      for ( i = 1 ;						  
  j < i ;						      	j < i ;							      i < n ;							  
  j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j  	j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j    i ++ ) for ( j = 0 ;					  
  for ( i = 0 ;						      	for ( i = 0 ;						      j < i ;							  
  i < n ;						      	i < n ;							      j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j  
  i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ;	      	i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ;	      for ( i = 0 ;						  
  return max ;						      	return max ;						      i < n ;							  
}							      }								      i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ;		  
							      								      return max ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F
--							      --							    --								  --
static int CountSubstring ( char str [ ] , int n ) {	      int CountSubstring ( char str [ ] , int n ) {		    int CountSubstring ( char str [ ] , int n ) {		  success : identical to gold
  int ans = ( n * ( n + 1 ) ) / 2 ;			      	int ans = ( n * ( n + 1 ) ) / 2 ;			      int ans = ( n * ( n + 1 ) ) / 2 ;				  
  int a_index = 0 ;					      	int a_index = 0 ;					      int a_index = 0 ;						  
  int b_index = 0 ;					      	int b_index = 0 ;					      int b_index = 0 ;						  
  int c_index = 0 ;					      	int c_index = 0 ;					      int c_index = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( str [ i ] == 'a' ) {				      	  if ( str [ i ] == 'a' ) {				    	if ( str [ i ] == 'a' ) {				  
      a_index = i + 1 ;					      	    a_index = i + 1 ;					    	  a_index = i + 1 ;					  
      ans -= Math . min ( b_index , c_index ) ;		      	    ans -= min ( b_index , c_index ) ;			    	  ans -= min ( b_index , c_index ) ;			  
    }							      	  }							    	}							  
    else if ( str [ i ] == 'b' ) {			      	  else if ( str [ i ] == 'b' ) {			    	else if ( str [ i ] == 'b' ) {				  
      b_index = i + 1 ;					      	    b_index = i + 1 ;					    	  b_index = i + 1 ;					  
      ans -= Math . min ( a_index , c_index ) ;		      	    ans -= min ( a_index , c_index ) ;			    	  ans -= min ( a_index , c_index ) ;			  
    }							      	  }							    	}							  
    else {						      	  else {						    	else {							  
      c_index = i + 1 ;					      	    c_index = i + 1 ;					    	  c_index = i + 1 ;					  
      ans -= Math . min ( a_index , b_index ) ;		      	    ans -= min ( a_index , b_index ) ;			    	  ans -= min ( a_index , b_index ) ;			  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return ans ;						      	return ans ;						      return ans ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_WAYS_JUMP_REACH_END			      COUNT_NUMBER_WAYS_JUMP_REACH_END				    COUNT_NUMBER_WAYS_JUMP_REACH_END				  COUNT_NUMBER_WAYS_JUMP_REACH_END
--							      --							    --								  --
static void countWaysToJump ( int arr [ ] , int n ) {	      void countWaysToJump ( int arr [ ] , int n ) {		    void countWaysToJump ( int arr [ ] , int n ) {		  script_not_found : None
  int count_jump [ ] = new int [ n ] ;			      	int count_jump [ n ] ;					      int count_jump [ n ] ;					  
  Arrays . fill ( count_jump , 0 ) ;			      	memset ( count_jump , 0 , sizeof ( count_jump ) ) ;	      memset ( count_jump , 0 , sizeof ( count_jump ) ) ;	  
  for ( int i = n - 2 ;					      	for ( int i = n - 2 ;					      for ( int i = n - 2 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ;	      	  if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ;	    	if ( arr [ i ] >= n - i - 1 ) {				  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	  count_jump [ i ] ++ ;					  
    j < n - 1 && j <= arr [ i ] + i ;			      	  j < n - 1 && j <= arr [ i ] + i ;			    	}							  
    j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += 	  j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += 	for ( int j = i + 1 ;					  
    if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ;     	  if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ;	    	j < n - 1 && j <= arr [ i ] + i ;			  
  }							      	}							    	j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += 
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ;	  
  i < n ;						      	i < n ;							      }								  
  i ++ ) System . out . print ( count_jump [ i ] + " " ) ;    	i ++ ) cout << count_jump [ i ] << " " ;		      for ( int i = 0 ;						  
}							      }								      i < n ;							  
							      								      i ++ ) cout << count_jump [ i ] << " " ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
UNIQUE_CELLS_BINARY_MATRIX				      UNIQUE_CELLS_BINARY_MATRIX				    UNIQUE_CELLS_BINARY_MATRIX					  UNIQUE_CELLS_BINARY_MATRIX
--							      --							    --								  --
static int countUnique ( int mat [ ] [ ] , int n , int m ) {  int countUnique ( int mat [ ] [ MAX ] , int n , int m ) {	    int countUnique ( int mat [ ] [ 2 ] , int n , int m ) {	  script_not_found : None
  int [ ] rowsum = new int [ n ] ;			      	int rowsum [ n ] , colsum [ m ] ;			      int rowsum [ n ] ;					  
  int [ ] colsum = new int [ m ] ;			      	memset ( colsum , 0 , sizeof ( colsum ) ) ;		      int colsum [ m ] ;					  
  for ( int i = 0 ;					      	memset ( rowsum , 0 , sizeof ( rowsum ) ) ;		      for ( int i = 0 ;						  
  i < n ;						      	for ( int i = 0 ;					      i < n ;							  
  i ++ ) for ( int j = 0 ;				      	i < n ;							      i ++ ) for ( int j = 0 ;					  
  j < m ;						      	i ++ ) for ( int j = 0 ;				      j < m ;							  
  j ++ ) if ( mat [ i ] [ j ] != 0 ) {			      	j < m ;							      j ++ ) if ( mat [ i ] [ j ] != 0 ) {			  
    rowsum [ i ] ++ ;					      	j ++ ) if ( mat [ i ] [ j ] ) {				    	rowsum [ i ] ++ ;					  
    colsum [ j ] ++ ;					      	  rowsum [ i ] ++ ;					    	colsum [ j ] ++ ;					  
  }							      	  colsum [ j ] ++ ;					      }								  
  int uniquecount = 0 ;					      	}							      int uniquecount = 0 ;					  
  for ( int i = 0 ;					      	int uniquecount = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	for ( int i = 0 ;					      i < n ;							  
  i ++ ) for ( int j = 0 ;				      	i < n ;							      i ++ ) for ( int j = 0 ;					  
  j < m ;						      	i ++ ) for ( int j = 0 ;				      j < m ;							  
  j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && co 	j < m ;							      j ++ ) if ( mat [ i ] [ j ] != 0 && rowsum [ i ] == 1 && co 
  return uniquecount ;					      	j ++ ) if ( mat [ i ] [ j ] && rowsum [ i ] == 1 && colsum    return uniquecount ;					  
}							      	return uniquecount ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU
--							      --							    --								  --
static String arrangeString ( String str ) {		      string arrangeString ( string str ) {			    string arrangeString ( string str ) {			  script_not_found : None
  int char_count [ ] = new int [ MAX_CHAR ] ;		      	int char_count [ MAX_CHAR ] = {				      int char_count [ MAX_CHAR ] ;				  
  int sum = 0 ;						      	  0 }							      int sum = 0 ;						  
  for ( int i = 0 ;					      	  ;							      for ( int i = 0 ;						  
  i < str . length ( ) ;				      	  int sum = 0 ;						      i < str . length ( ) ;					  
  i ++ ) {						      	  for ( int i = 0 ;					      i ++ ) {							  
    if ( Character . isUpperCase ( str . charAt ( i ) ) ) cha 	  i < str . length ( ) ;				    	if ( isupper ( str [ i ] ) ) {				  
    else sum = sum + ( str . charAt ( i ) - '0' ) ;	      	  i ++ ) {						    	  char_count [ str [ i ] - 'A' ] ++ ;			  
  }							      	    if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) char_count  	}							  
  String res = "" ;					      	    else sum = sum + ( str [ i ] - '0' ) ;		    	else {							  
  for ( int i = 0 ;					      	  }							    	  sum = sum + ( str [ i ] - '0' ) ;			  
  i < MAX_CHAR ;					      	  string res = "" ;					    	}							  
  i ++ ) {						      	  for ( int i = 0 ;					      }								  
    char ch = ( char ) ( 'A' + i ) ;			      	  i < MAX_CHAR ;					      string res ;						  
    while ( char_count [ i ] -- != 0 ) res = res + ch ;	      	  i ++ ) {						      for ( int i = 0 ;						  
  }							      	    char ch = ( char ) ( 'A' + i ) ;			      i < MAX_CHAR ;						  
  if ( sum > 0 ) res = res + sum ;			      	    while ( char_count [ i ] -- ) res = res + ch ;	      i ++ ) {							  
  return res ;						      	  }							    	char ch = ( char ) ( 'A' + i ) ;			  
}							      	  if ( sum > 0 ) res = res + to_string ( sum ) ;	    	while ( char_count [ i ] -- != 0 ) {			  
							      	  return res ;						    	  res = res + ch ;					  
							      	}							    	}							  
							      								      }								  
							      								      if ( sum > 0 ) {						  
							      								    	res = res + sum ;					  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_COMMON_SUBSTRING				      LONGEST_COMMON_SUBSTRING					    LONGEST_COMMON_SUBSTRING					  LONGEST_COMMON_SUBSTRING
--							      --							    --								  --
static int LCSubStr ( char X [ ] , char Y [ ] , int m , int n int LCSubStr ( char * X , char * Y , int m , int n ) {	    int LCSubStr ( char X [ ] , char Y [ ] , int m , int n ) {	  script_not_found : None
  int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	int LCSuff [ m + 1 ] [ n + 1 ] ;			      int LCStuff [ m + 1 ] [ n + 1 ] ;				  
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= m ;						      	i <= m ;						      i <= m ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= n ;						      	  j <= n ;						    	j <= n ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( i == 0 || j == 0 ) LCStuff [ i ] [ j ] = 0 ;	      	    if ( i == 0 || j == 0 ) LCSuff [ i ] [ j ] = 0 ;	    	  if ( i == 0 || j == 0 ) {				  
      else if ( X [ i - 1 ] == Y [ j - 1 ] ) {		      	    else if ( X [ i - 1 ] == Y [ j - 1 ] ) {		    	    LCStuff [ i ] [ j ] = 0 ;				  
	LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 	      LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; 	  }							  
	result = Integer . max ( result , LCStuff [ i ] [ j ] 	      result = max ( result , LCSuff [ i ] [ j ] ) ;	    	  else if ( X [ i - 1 ] == Y [ j - 1 ] ) {		  
      }							      	    }							    	    LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 
      else LCStuff [ i ] [ j ] = 0 ;			      	    else LCSuff [ i ] [ j ] = 0 ;			    	    result = max ( result , LCStuff [ i ] [ j ] ) ;	  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  return result ;					      	return result ;						    	    LCStuff [ i ] [ j ] = 0 ;				  
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SERIES_LARGEST_GCD_SUM_EQUALS_N				      SERIES_LARGEST_GCD_SUM_EQUALS_N				    SERIES_LARGEST_GCD_SUM_EQUALS_N				  SERIES_LARGEST_GCD_SUM_EQUALS_N
--							      --							    --								  --
static void print_sequence ( int n , int k ) {		      void print_sequence ( int n , int k ) {			    void print_sequence ( int n , int k ) {			  script_not_found : None
  int b = n / ( k * ( k + 1 ) / 2 ) ;			      	int b = n / ( k * ( k + 1 ) / 2 ) ;			      int b = n / ( k * ( k + 1 ) / 2 ) ;			  
  if ( b == 0 ) {					      	if ( b == 0 ) {						      if ( b == 0 ) cout << "-1" << endl ;			  
    System . out . println ( "-1" ) ;			      	  cout << - 1 << endl ;					      else {							  
  }							      	}							    	int r = 1 ;						  
  else {						      	else {							    	for ( int x = 1 ;					  
    int r = 1 ;						      	  int r = 1 ;						    	x * x <= n ;						  
    for ( int x = 1 ;					      	  for ( int x = 1 ;					    	x ++ ) {						  
    x * x <= n ;					      	  x * x <= n ;						    	  if ( n % x != 0 ) continue ;				  
    x ++ ) {						      	  x ++ ) {						    	  if ( x <= b && x > r ) r = x ;			  
      if ( n % x != 0 ) continue ;			      	    if ( n % x != 0 ) continue ;			    	  if ( n / x <= b && n / x > r ) r = n / x ;		  
      if ( x <= b && x > r ) r = x ;			      	    if ( x <= b && x > r ) r = x ;			    	}							  
      if ( n / x <= b && n / x > r ) r = n / x ;	      	    if ( n / x <= b && n / x > r ) r = n / x ;		    	for ( int i = 1 ;					  
    }							      	  }							    	i < k ;							  
    for ( int i = 1 ;					      	  for ( int i = 1 ;					    	i ++ ) cout << r * i << " " ;				  
    i < k ;						      	  i < k ;						    	int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ;		  
    i ++ ) System . out . print ( r * i + " " ) ;	      	  i ++ ) cout << r * i << " " ;				    	cout << res << endl ;					  
    int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ;	      	  int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ;		      }								  
    System . out . println ( res ) ;			      	  cout << res << endl ;					    }								  
  }							      	}							    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D		      FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D			    FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D			  FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D
--							      --							    --								  --
static int findLargestd ( int [ ] S , int n ) {		      int findLargestd ( int S [ ] , int n ) {			    int findLargestd ( int * S , int n ) {			  failure : #Results: 8, 10
  boolean found = false ;				      	bool found = false ;					      bool found = false ;					  
  Arrays . sort ( S ) ;					      	sort ( S , S + n ) ;					      sort ( S , S + n ) ;					  
  for ( int i = n - 1 ;					      	for ( int i = n - 1 ;					      for ( int i = n - 1 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( i == j ) continue ;				      	    if ( i == j ) continue ;				    	  if ( i == j ) continue ;				  
      for ( int k = j + 1 ;				      	    for ( int k = j + 1 ;				    	  for ( int k = j + 1 ;					  
      k < n ;						      	    k < n ;						    	  k < n ;						  
      k ++ ) {						      	    k ++ ) {						    	  k ++ ) {						  
	if ( i == k ) continue ;			      	      if ( i == k ) continue ;				    	    if ( i == k ) continue ;				  
	for ( int l = k + 1 ;				      	      for ( int l = k + 1 ;				    	    for ( int l = k + 1 ;				  
	l < n ;						      	      l < n ;						    	    l < n ;						  
	l ++ ) {					      	      l ++ ) {						    	    l ++ ) {						  
	  if ( i == l ) continue ;			      		if ( i == l ) continue ;			    	      if ( i == l ) continue ;				  
	  if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {     		if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {	    	      if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {	  
	    found = true ;				      		  found = true ;				    		found = true ;					  
	    return S [ i ] ;				      		  return S [ i ] ;				    		return S [ i ] ;				  
	  }						      		}						    	      }							  
	}						      	      }							    	    }							  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
  }							      	}							      }								  
  if ( found == false ) return Integer . MAX_VALUE ;	      	if ( found == false ) return INT_MIN ;			      if ( found == false ) return INT_MAX ;			  
  return - 1 ;						      }								      return - 1 ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PRODUCT_SUBSET_ARRAY				      MAXIMUM_PRODUCT_SUBSET_ARRAY				    MAXIMUM_PRODUCT_SUBSET_ARRAY				  MAXIMUM_PRODUCT_SUBSET_ARRAY
--							      --							    --								  --
static int maxProductSubset ( int a [ ] , int n ) {	      int maxProductSubset ( int a [ ] , int n ) {		    int maxProductSubset ( int a [ ] , int n ) {		  failure : #Results: 9, 10
  if ( n == 1 ) {					      	if ( n == 1 ) return a [ 0 ] ;				      if ( n == 1 ) return a [ 0 ] ;				  
    return a [ 0 ] ;					      	int max_neg = INT_MIN ;					      int maxNeg = INT_MAX ;					  
  }							      	int count_neg = 0 , count_zero = 0 ;			      int countNeg = 0 , countZero = 0 ;			  
  int max_neg = Integer . MIN_VALUE ;			      	int prod = 1 ;						      int prod = 1 ;						  
  int count_neg = 0 , count_zero = 0 ;			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  int prod = 1 ;					      	i < n ;							      i < n ;							  
  for ( int i = 0 ;					      	i ++ ) {						      i ++ ) {							  
  i < n ;						      	  if ( a [ i ] == 0 ) {					    	if ( a [ i ] == 0 ) {					  
  i ++ ) {						      	    count_zero ++ ;					    	  countZero ++ ;					  
    if ( a [ i ] == 0 ) {				      	    continue ;						    	  continue ;						  
      count_zero ++ ;					      	  }							    	}							  
      continue ;					      	  if ( a [ i ] < 0 ) {					    	if ( a [ i ] < 0 ) {					  
    }							      	    count_neg ++ ;					    	  countNeg ++ ;						  
    if ( a [ i ] < 0 ) {				      	    max_neg = max ( max_neg , a [ i ] ) ;		    	  maxNeg = max ( maxNeg , a [ i ] ) ;			  
      count_neg ++ ;					      	  }							    	}							  
      max_neg = Math . max ( max_neg , a [ i ] ) ;	      	  prod = prod * a [ i ] ;				    	prod = prod * a [ i ] ;					  
    }							      	}							      }								  
    prod = prod * a [ i ] ;				      	if ( count_zero == n ) return 0 ;			      if ( countZero == n ) return 0 ;				  
  }							      	if ( count_neg & 1 ) {					      if ( countNeg % 2 == 1 ) {				  
  if ( count_zero == n ) {				      	  if ( count_neg == 1 && count_zero > 0 && count_zero + cou 	if ( countNeg == 1 && countZero > 0 && countZero + countN 
    return 0 ;						      	  prod = prod / max_neg ;				    	prod = prod / maxNeg ;					  
  }							      	}							      }								  
  if ( count_neg % 2 == 1 ) {				      	return prod ;						      return prod ;						  
    if ( count_neg == 1 && count_zero > 0 && count_zero + cou }								    }								  
      return 0 ;					      								    								  
    }							      								    								  
    prod = prod / max_neg ;				      								    								  
  }							      								    								  
  return prod ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS	      MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS	    MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS		  MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS
--							      --							    --								  --
static int getMinDiff ( int arr [ ] , int n , int k ) {	      int getMinDiff ( int arr [ ] , int n , int k ) {		    int getMinDiff ( int arr [ ] , int n , int k ) {		  success : None
  if ( n == 1 ) return 0 ;				      	if ( n == 1 ) return 0 ;				      if ( n == 1 ) return 0 ;					  
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  int ans = arr [ n - 1 ] - arr [ 0 ] ;			      	int ans = arr [ n - 1 ] - arr [ 0 ] ;			      int ans = arr [ n - 1 ] - arr [ 0 ] ;			  
  int small = arr [ 0 ] + k ;				      	int small = arr [ 0 ] + k ;				      int small = arr [ 0 ] + k ;				  
  int big = arr [ n - 1 ] - k ;				      	int big = arr [ n - 1 ] - k ;				      int big = arr [ n - 1 ] - k ;				  
  int temp = 0 ;					      	if ( small > big ) swap ( small , big ) ;		      int temp = 0 ;						  
  if ( small > big ) {					      	for ( int i = 1 ;					      if ( small > big ) {					  
    temp = small ;					      	i < n - 1 ;						    	temp = small ;						  
    small = big ;					      	i ++ ) {						    	small = big ;						  
    big = temp ;					      	  int subtract = arr [ i ] - k ;			    	big = temp ;						  
  }							      	  int add = arr [ i ] + k ;				      }								  
  for ( int i = 1 ;					      	  if ( subtract >= small || add <= big ) continue ;	      for ( int i = 1 ;						  
  i < n - 1 ;						      	  if ( big - subtract <= add - small ) small = subtract ;     i < n - 1 ;						  
  i ++ ) {						      	  else big = add ;					      i ++ ) {							  
    int subtract = arr [ i ] - k ;			      	}							    	int subtract = arr [ i ] - k ;				  
    int add = arr [ i ] + k ;				      	return min ( ans , big - small ) ;			    	int add = arr [ i ] + k ;				  
    if ( subtract >= small || add <= big ) continue ;	      }								    	if ( subtract >= small || add <= big ) continue ;	  
    if ( big - subtract <= add - small ) small = subtract ;   								    	if ( big - subtract <= add - small ) small = subtract ;	  
    else big = add ;					      								    	else big = add ;					  
  }							      								      }								  
  return Math . min ( ans , big - small ) ;		      								      return min ( ans , big - small ) ;			  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK	      CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK		    CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK		  CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK
--							      --							    --								  --
static boolean checkSorted ( int n ) {			      bool checkSorted ( int n , queue < int > & q ) {		    bool checkSorted ( int n ) {				  script_not_found : None
  Stack < Integer > st = new Stack < Integer > ( ) ;	      	stack < int > st ;					      stack < int > st ;					  
  int expected = 1 ;					      	int expected = 1 ;					      int expected = 1 ;					  
  int fnt ;						      	int fnt ;						      int fnt ;							  
  while ( q . size ( ) != 0 ) {				      	while ( ! q . empty ( ) ) {				      while ( q . size ( ) != 0 ) {				  
    fnt = q . peek ( ) ;				      	  fnt = q . front ( ) ;					    	fnt = q . top ( ) ;					  
    q . poll ( ) ;					      	  q . pop ( ) ;						    	q . pop ( ) ;						  
    if ( fnt == expected ) expected ++ ;		      	  if ( fnt == expected ) expected ++ ;			    	if ( fnt == expected ) {				  
    else {						      	  else {						    	  expected ++ ;						  
      if ( st . size ( ) == 0 ) {			      	    if ( st . empty ( ) ) {				    	}							  
	st . push ( fnt ) ;				      	      st . push ( fnt ) ;				    	else {							  
      }							      	    }							    	  if ( st . empty ( ) ) st . push ( fnt ) ;		  
      else if ( st . size ( ) != 0 && st . peek ( ) < fnt ) { 	    else if ( ! st . empty ( ) && st . top ( ) < fnt ) {    	  else if ( st . size ( ) != 0 && st . top ( ) < fnt ) re 
	return false ;					      	      return false ;					    	  else st . push ( fnt ) ;				  
      }							      	    }							    	}							  
      else st . push ( fnt ) ;				      	    else st . push ( fnt ) ;				    	while ( st . size ( ) != 0 && st . top ( ) == expected )  
    }							      	  }							    	  st . pop ( ) ;					  
    while ( st . size ( ) != 0 && st . peek ( ) == expected ) 	  while ( ! st . empty ( ) && st . top ( ) == expected ) {  	  expected ++ ;						  
      st . pop ( ) ;					      	    st . pop ( ) ;					    	}							  
      expected ++ ;					      	    expected ++ ;					      }								  
    }							      	  }							      if ( expected - 1 == n && st . size ( ) == 0 ) return true  
  }							      	}							      return false ;						  
  if ( expected - 1 == n && st . size ( ) == 0 ) return true  	if ( expected - 1 == n && st . empty ( ) ) return true ;    }								  
  return false ;					      	return false ;						    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_REPEATING_SUBSEQUENCE				      LONGEST_REPEATING_SUBSEQUENCE				    LONGEST_REPEATING_SUBSEQUENCE				  LONGEST_REPEATING_SUBSEQUENCE
--							      --							    --								  --
static int findLongestRepeatingSubSeq ( String str ) {	      int findLongestRepeatingSubSeq ( string str ) {		    int findLongestRepeatingSubSeq ( string str ) {		  success : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;	      	int dp [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( n +  
  for ( int i = 1 ;					      	for ( int i = 0 ;					      for ( int i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
    for ( int j = 1 ;					      	j <= n ;						    	for ( int j = 1 ;					  
    j <= n ;						      	j ++ ) dp [ i ] [ j ] = 0 ;				    	j <= n ;						  
    j ++ ) {						      	for ( int i = 1 ;					    	j ++ ) {						  
      if ( str . charAt ( i - 1 ) == str . charAt ( j - 1 ) & 	i <= n ;						    	  if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) {	  
      else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , 	i ++ ) {						    	    dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;	  
    }							      	  for ( int j = 1 ;					    	  }							  
  }							      	  j <= n ;						    	  else {						  
  return dp [ n ] [ n ] ;				      	  j ++ ) {						    	    dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i -  
}							      	    if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i  	  }							  
							      	    else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i 	}							  
							      	  }							      }								  
							      	}							      return dp [ n ] [ n ] ;					  
							      	return dp [ n ] [ n ] ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_KTH_CHARACTER_OF_DECRYPTED_STRING			      FIND_KTH_CHARACTER_OF_DECRYPTED_STRING			    FIND_KTH_CHARACTER_OF_DECRYPTED_STRING			  FIND_KTH_CHARACTER_OF_DECRYPTED_STRING
--							      --							    --								  --
static char encodedChar ( String str , int k ) {	      char encodedChar ( string str , int k ) {			    char encodedChar ( string str , int k ) {			  script_not_found : None
  String expand = "" ;					      	string expand = "" ;					      string expand ;						  
  String temp = "" ;					      	string temp ;						      string temp ;						  
  int freq = 0 ;					      	int freq = 0 ;						      int freq = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < str . length ( ) ;				      	str [ i ] != '\0' ;					      i < str . length ( ) ;					  
  ) {							      	) {							      ) {							  
    temp = "" ;						      	  temp = "" ;						    	temp = "" ;						  
    freq = 0 ;						      	  freq = 0 ;						    	freq = 0 ;						  
    while ( i < str . length ( ) && str . charAt ( i ) >= 'a' 	  while ( str [ i ] >= 'a' && str [ i ] <= 'z' ) {	    	while ( i < str . length ( ) && str [ i ] >= 'a' && str [ 
      temp += str . charAt ( i ) ;			      	    temp . push_back ( str [ i ] ) ;			    	  temp += str [ i ] ;					  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
    }							      	  }							    	}							  
    while ( i < str . length ( ) && str . charAt ( i ) >= '1' 	  while ( str [ i ] >= '1' && str [ i ] <= '9' ) {	    	while ( i < str . length ( ) && str [ i ] >= '1' && str [ 
      freq = freq * 10 + str . charAt ( i ) - '0' ;	      	    freq = freq * 10 + str [ i ] - '0' ;		    	  freq = freq * 10 + str [ i ] - '0' ;			  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
    }							      	  }							    	}							  
    for ( int j = 1 ;					      	  for ( int j = 1 ;					    	for ( int j = 1 ;					  
    j <= freq ;						      	  j <= freq ;						    	j <= freq ;						  
    j ++ ) expand += temp ;				      	  j ++ ) expand . append ( temp ) ;			    	j ++ ) {						  
  }							      	}							    	  expand += temp ;					  
  if ( freq == 0 ) expand += temp ;			      	if ( freq == 0 ) expand . append ( temp ) ;		    	}							  
  return expand . charAt ( k - 1 ) ;			      	return expand [ k - 1 ] ;				      }								  
}							      }								      if ( freq == 0 ) {					  
							      								    	expand += temp ;					  
							      								      }								  
							      								      return expand [ k - 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N			      NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N			    NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N			  NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N
--							      --							    --								  --
static int countDivisibleSubseq ( String str , int n ) {      int countDivisibleSubseq ( string str , int n ) {		    int countDivisibleSubseq ( string str , int n ) {		  error : munmap_chunk(): invalid pointer /bin/bash:
  int len = str . length ( ) ;				      	int len = str . length ( ) ;				      int len = str . length ( ) ;				   line 1: 3926722 Aborted		   (core dum
  int dp [ ] [ ] = new int [ len ] [ n ] ;		      	int dp [ len ] [ n ] ;					      vector < vector < int >> dp ( len , vector < int > ( len ,  ped) ./NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N_cpp
  dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ;	      	memset ( dp , 0 , sizeof ( dp ) ) ;			      dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++ ;			  
  for ( int i = 1 ;					      	dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++ ;		      for ( int i = 1 ;						  
  i < len ;						      	for ( int i = 1 ;					      i < len ;							  
  i ++ ) {						      	i < len ;						      i ++ ) {							  
    dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ;	      	i ++ ) {						    	dp [ i ] [ ( str [ i ] - '0' ) % n ] ++ ;		  
    for ( int j = 0 ;					      	  dp [ i ] [ ( str [ i ] - '0' ) % n ] ++ ;		    	for ( int j = 0 ;					  
    j < n ;						      	  for ( int j = 0 ;					    	j < n ;							  
    j ++ ) {						      	  j < n ;						    	j ++ ) {						  
      dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ;		      	  j ++ ) {						    	  dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ;		  
      dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) %  	    dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ;		    	  dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp 
    }							      	    dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp 	}							  
  }							      	  }							      }								  
  return dp [ len - 1 ] [ 0 ] ;				      	}							      return dp [ len - 1 ] [ 0 ] ;				  
}							      	return dp [ len - 1 ] [ 0 ] ;				    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT
--							      --							    --								  --
static boolean checkDivisibility ( String num ) {	      bool checkDivisibility ( string num ) {			    bool checkDivisibility ( string num ) {			  success : None
  int length = num . length ( ) ;			      	int length = num . size ( ) ;				      int length = num . length ( ) ;				  
  if ( length == 1 && num . charAt ( 0 ) == '0' ) return true 	if ( length == 1 && num [ 0 ] == '0' ) return true ;	      if ( length == 1 && num [ 0 ] == '0' ) return true ;	  
  if ( length % 3 == 1 ) {				      	if ( length % 3 == 1 ) {				      if ( length % 3 == 1 ) {					  
    num += "00" ;					      	  num += "00" ;						    	num += "00" ;						  
    length += 2 ;					      	  length += 2 ;						    	length += 2 ;						  
  }							      	}							      }								  
  else if ( length % 3 == 2 ) {				      	else if ( length % 3 == 2 ) {				      else if ( length % 3 == 2 ) {				  
    num += "0" ;					      	  num += "0" ;						    	num += "0" ;						  
    length += 1 ;					      	  length += 1 ;						    	length += 1 ;						  
  }							      	}							      }								  
  int sum = 0 , p = 1 ;					      	int sum = 0 , p = 1 ;					      int sum = 0 , p = 1 ;					  
  for ( int i = length - 1 ;				      	for ( int i = length - 1 ;				      for ( int i = length - 1 ;				  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    int group = 0 ;					      	  int group = 0 ;					    	int group = 0 ;						  
    group += num . charAt ( i -- ) - '0' ;		      	  group += num [ i -- ] - '0' ;				    	group += num [ i -- ] - '0' ;				  
    group += ( num . charAt ( i -- ) - '0' ) * 10 ;	      	  group += ( num [ i -- ] - '0' ) * 10 ;		    	group += ( num [ i -- ] - '0' ) * 10 ;			  
    group += ( num . charAt ( i ) - '0' ) * 100 ;	      	  group += ( num [ i ] - '0' ) * 100 ;			    	group += ( num [ i ] - '0' ) * 100 ;			  
    sum = sum + group * p ;				      	  sum = sum + group * p ;				    	sum = sum + group * p ;					  
    p *= ( - 1 ) ;					      	  p *= ( - 1 ) ;					    	p *= ( - 1 ) ;						  
  }							      	}							      }								  
  sum = Math . abs ( sum ) ;				      	sum = abs ( sum ) ;					      sum = abs ( sum ) ;					  
  return ( sum % 13 == 0 ) ;				      	return ( sum % 13 == 0 ) ;				      return ( sum % 13 == 0 ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX		      MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX		    MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX		  MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX
--							      --							    --								  --
static int maxRowDiff ( int mat [ ] [ ] , int m , int n ) {   int maxRowDiff ( int mat [ ] [ MAX ] , int m , int n ) {	    int maxRowDiff ( int mat [ ] [ 2 ] , int m , int n ) {	  script_not_found : None
  int rowSum [ ] = new int [ m ] ;			      	int rowSum [ m ] ;					      int rowSum [ m ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m ;						      	i < m ;							      i < m ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int sum = 0 ;					      	  int sum = 0 ;						    	int sum = 0 ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) sum += mat [ i ] [ j ] ;			      	  j ++ ) sum += mat [ i ] [ j ] ;			    	j ++ ) {						  
    rowSum [ i ] = sum ;				      	  rowSum [ i ] = sum ;					    	  sum += mat [ i ] [ j ] ;				  
  }							      	}							    	}							  
  int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ;		      	int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ;		    	rowSum [ i ] = sum ;					  
  int min_element = rowSum [ 0 ] ;			      	int min_element = rowSum [ 0 ] ;			      }								  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      int maxDiff = rowSum [ 1 ] - rowSum [ 0 ] ;		  
  i < m ;						      	i < m ;							      int minElement = rowSum [ 0 ] ;				  
  i ++ ) {						      	i ++ ) {						      for ( int i = 1 ;						  
    if ( rowSum [ i ] - min_element > max_diff ) max_diff = r 	  if ( rowSum [ i ] - min_element > max_diff ) max_diff = r   i < m ;							  
    if ( rowSum [ i ] < min_element ) min_element = rowSum [  	  if ( rowSum [ i ] < min_element ) min_element = rowSum [    i ++ ) {							  
  }							      	}							    	if ( rowSum [ i ] - minElement > maxDiff ) {		  
  return max_diff ;					      	return max_diff ;					    	  maxDiff = rowSum [ i ] - minElement ;			  
}							      }								    	}							  
							      								    	if ( rowSum [ i ] < minElement ) {			  
							      								    	  minElement = rowSum [ i ] ;				  
							      								    	}							  
							      								      }								  
							      								      return maxDiff ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS			      SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS			    SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS				  SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS
--							      --							    --								  --
static void diagonalsquare ( int mat [ ] [ ] , int row , int  void diagonalsquare ( int mat [ ] [ MAX ] , int row , int col void diagonalsquare ( int mat [ ] [ 2 ] , int row , int colum script_not_found : None
  System . out . print ( "Diagonal one : " ) ;		      	cout << "Diagonal one : " ;				      cout << "Diagonal one : " ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < row ;						      	i < row ;						      i < row ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < column ;					      	  j < column ;						    	j < column ;						  
    j ++ ) if ( i == j ) System . out . print ( mat [ i ] [ j 	  j ++ ) if ( i == j ) cout << mat [ i ] [ j ] * mat [ i ]  	j ++ ) if ( i == j ) cout << mat [ i ] [ j ] * mat [ i ]  
  }							      	}							      }								  
  System . out . println ( ) ;				      	cout << " \n\nDiagonal two : " ;			      cout << endl ;						  
  System . out . print ( "Diagonal two : " ) ;		      	for ( int i = 0 ;					      cout << "Diagonal two : " ;				  
  for ( int i = 0 ;					      	i < row ;						      for ( int i = 0 ;						  
  i < row ;						      	i ++ ) {						      i < row ;							  
  i ++ ) {						      	  for ( int j = 0 ;					      i ++ ) {							  
    for ( int j = 0 ;					      	  j < column ;						    	for ( int j = 0 ;					  
    j < column ;					      	  j ++ ) if ( i + j == column - 1 ) cout << mat [ i ] [ j ] 	j < column ;						  
    j ++ ) if ( i + j == column - 1 ) System . out . print (  	}							    	j ++ ) if ( i + j == column - 1 ) cout << mat [ i ] [ j ] 
  }							      }								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2	      MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2	    MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2	  MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2
--							      --							    --								  --
static int minJumps ( int arr [ ] , int n ) {		      int minJumps ( int arr [ ] , int n ) {			    int minJumps ( int arr [ ] , int n ) {			  success : None
  int [ ] jumps = new int [ n ] ;			      	int * jumps = new int [ n ] ;				      int jumps [ n ] ;						  
  int min ;						      	int min ;						      int min ;							  
  jumps [ n - 1 ] = 0 ;					      	jumps [ n - 1 ] = 0 ;					      jumps [ n - 1 ] = 0 ;					  
  for ( int i = n - 2 ;					      	for ( int i = n - 2 ;					      for ( int i = n - 2 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    if ( arr [ i ] == 0 ) jumps [ i ] = Integer . MAX_VALUE ; 	  if ( arr [ i ] == 0 ) jumps [ i ] = INT_MAX ;		    	if ( arr [ i ] == 0 ) {					  
    else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ;      	  else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ;	    	  jumps [ i ] = INT_MAX ;				  
    else {						      	  else {						    	}							  
      min = Integer . MAX_VALUE ;			      	    min = INT_MAX ;					    	else if ( arr [ i ] >= n - i - 1 ) {			  
      for ( int j = i + 1 ;				      	    for ( int j = i + 1 ;				    	  jumps [ i ] = 1 ;					  
      j < n && j <= arr [ i ] + i ;			      	    j < n && j <= arr [ i ] + i ;			    	}							  
      j ++ ) {						      	    j ++ ) {						    	else {							  
	if ( min > jumps [ j ] ) min = jumps [ j ] ;	      	      if ( min > jumps [ j ] ) min = jumps [ j ] ;	    	  min = INT_MAX ;					  
      }							      	    }							    	  for ( int j = i + 1 ;					  
      if ( min != Integer . MAX_VALUE ) jumps [ i ] = min + 1 	    if ( min != INT_MAX ) jumps [ i ] = min + 1 ;	    	  j < n && j <= arr [ i ] + i ;				  
      else jumps [ i ] = min ;				      	    else jumps [ i ] = min ;				    	  j ++ ) {						  
    }							      	  }							    	    if ( min > jumps [ j ] ) {				  
  }							      	}							    	      min = jumps [ j ] ;				  
  return jumps [ 0 ] ;					      	return jumps [ 0 ] ;					    	    }							  
}							      }								    	  }							  
							      								    	  if ( min != INT_MAX ) {				  
							      								    	    jumps [ i ] = min + 1 ;				  
							      								    	  }							  
							      								    	  else {						  
							      								    	    jumps [ i ] = min ;					  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return jumps [ 0 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COCKTAIL_SORT						      COCKTAIL_SORT						    COCKTAIL_SORT						  COCKTAIL_SORT
--							      --							    --								  --
void cocktailSort ( int a [ ] ) {			      void CocktailSort ( int a [ ] , int n ) {			    void cocktailSort ( int a [ ] ) {				  script_not_found : None
  boolean swapped = true ;				      	bool swapped = true ;					      bool swapped = true ;					  
  int start = 0 ;					      	int start = 0 ;						      int start = 0 ;						  
  int end = a . length ;				      	int end = n - 1 ;					      int end = sizeof ( a ) / sizeof ( a [ 0 ] ) ;		  
  while ( swapped == true ) {				      	while ( swapped ) {					      while ( swapped == true ) {				  
    swapped = false ;					      	  swapped = false ;					    	swapped = false ;					  
    for ( int i = start ;				      	  for ( int i = start ;					    	for ( int i = start ;					  
    i < end - 1 ;					      	  i < end ;						    	i < end - 1 ;						  
    ++ i ) {						      	  ++ i ) {						    	++ i ) {						  
      if ( a [ i ] > a [ i + 1 ] ) {			      	    if ( a [ i ] > a [ i + 1 ] ) {			    	  if ( a [ i ] > a [ i + 1 ] ) {			  
	int temp = a [ i ] ;				      	      swap ( a [ i ] , a [ i + 1 ] ) ;			    	    int temp = a [ i ] ;				  
	a [ i ] = a [ i + 1 ] ;				      	      swapped = true ;					    	    a [ i ] = a [ i + 1 ] ;				  
	a [ i + 1 ] = temp ;				      	    }							    	    a [ i + 1 ] = temp ;				  
	swapped = true ;				      	  }							    	    swapped = true ;					  
      }							      	  if ( ! swapped ) break ;				    	  }							  
    }							      	  swapped = false ;					    	}							  
    if ( swapped == false ) break ;			      	  -- end ;						    	if ( swapped == false ) break ;				  
    swapped = false ;					      	  for ( int i = end - 1 ;				    	swapped = false ;					  
    end = end - 1 ;					      	  i >= start ;						    	end = end - 1 ;						  
    for ( int i = end - 1 ;				      	  -- i ) {						    	for ( int i = end - 1 ;					  
    i >= start ;					      	    if ( a [ i ] > a [ i + 1 ] ) {			    	i >= start ;						  
    i -- ) {						      	      swap ( a [ i ] , a [ i + 1 ] ) ;			    	-- i ) {						  
      if ( a [ i ] > a [ i + 1 ] ) {			      	      swapped = true ;					    	  if ( a [ i ] > a [ i + 1 ] ) {			  
	int temp = a [ i ] ;				      	    }							    	    int temp = a [ i ] ;				  
	a [ i ] = a [ i + 1 ] ;				      	  }							    	    a [ i ] = a [ i + 1 ] ;				  
	a [ i + 1 ] = temp ;				      	  ++ start ;						    	    a [ i + 1 ] = temp ;				  
	swapped = true ;				      	}							    	    swapped = true ;					  
      }							      }								    	  }							  
    }							      								    	}							  
    start = start + 1 ;					      								    	start = start + 1 ;					  
  }							      								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KNAPSACK_PROBLEM_1					      KNAPSACK_PROBLEM_1					    KNAPSACK_PROBLEM_1						  KNAPSACK_PROBLEM_1
--							      --							    --								  --
static int knapSack ( int W , int wt [ ] , int val [ ] , int  int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {   int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {	  script_not_found : None
  int i , w ;						      	int i , w ;						      int i , w ;						  
  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;		      	int K [ n + 1 ] [ W + 1 ] ;				      int K [ n + 1 ] [ W + 1 ] ;				  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( w = 0 ;					      	  for ( w = 0 ;						    	for ( w = 0 ;						  
    w <= W ;						      	  w <= W ;						    	w <= W ;						  
    w ++ ) {						      	  w ++ ) {						    	w ++ ) {						  
      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;	      	    if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;		    	  if ( i == 0 || w == 0 ) {				  
      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 	    else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 	    K [ i ] [ w ] = 0 ;					  
      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		      	    else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		    	  }							  
    }							      	  }							    	  else if ( wt [ i - 1 ] <= w ) {			  
  }							      	}							    	    K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w 
  return K [ n ] [ W ] ;				      	return K [ n ] [ W ] ;					    	  }							  
}							      }								    	  else {						  
							      								    	    K [ i ] [ w ] = K [ i - 1 ] [ w ] ;			  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return K [ n ] [ W ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C			      MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C			    MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C				  MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C
--							      --							    --								  --
static int maximumSegments ( int n , int a , int b , int c )  int maximumSegments ( int n , int a , int b , int c ) {	    int maximumSegments ( int n , int a , int b , int c ) {	  success : None
  int dp [ ] = new int [ n + 10 ] ;			      	int dp [ n + 1 ] ;					      int dp [ n + 10 ] ;					  
  Arrays . fill ( dp , - 1 ) ;				      	memset ( dp , - 1 , sizeof ( dp ) ) ;			      memset ( dp , - 1 , sizeof ( dp ) ) ;			  
  dp [ 0 ] = 0 ;					      	dp [ 0 ] = 0 ;						      dp [ 0 ] = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( dp [ i ] != - 1 ) {				      	  if ( dp [ i ] != - 1 ) {				    	if ( dp [ i ] != - 1 ) {				  
      if ( i + a <= n ) dp [ i + a ] = Math . max ( dp [ i ]  	    if ( i + a <= n ) dp [ i + a ] = max ( dp [ i ] + 1 , d 	  if ( i + a <= n ) {					  
      if ( i + b <= n ) dp [ i + b ] = Math . max ( dp [ i ]  	    if ( i + b <= n ) dp [ i + b ] = max ( dp [ i ] + 1 , d 	    dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) ;  
      if ( i + c <= n ) dp [ i + c ] = Math . max ( dp [ i ]  	    if ( i + c <= n ) dp [ i + c ] = max ( dp [ i ] + 1 , d 	  }							  
    }							      	  }							    	  if ( i + b <= n ) {					  
  }							      	}							    	    dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) ;  
  return dp [ n ] ;					      	return dp [ n ] ;					    	  }							  
}							      }								    	  if ( i + c <= n ) {					  
							      								    	    dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) ;  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return dp [ n ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1		      CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1		    CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1		  CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1
--							      --							    --								  --
static boolean checkReverse ( int arr [ ] , int n ) {	      bool checkReverse ( int arr [ ] , int n ) {		    bool checkReverse ( int arr [ ] , int n ) {			  success : None
  if ( n == 1 ) {					      	if ( n == 1 ) return true ;				      if ( n == 1 ) return true ;				  
    return true ;					      	int i ;							      int i ;							  
  }							      	for ( i = 1 ;						      for ( i = 1 ;						  
  int i ;						      	i < n && arr [ i - 1 ] < arr [ i ] ;			      arr [ i - 1 ] < arr [ i ] && i < n ;			  
  for ( i = 1 ;						      	i ++ ) ;						      i ++ ) ;							  
  arr [ i - 1 ] < arr [ i ] && i < n ;			      	if ( i == n ) return true ;				      if ( i == n ) return true ;				  
  i ++ ) ;						      	int j = i ;						      int j = i ++ ;						  
  if ( i == n ) {					      	while ( arr [ j ] < arr [ j - 1 ] ) {			      while ( arr [ j ] < arr [ j - 1 ] ) {			  
    return true ;					      	  if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ;  	if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ;  
  }							      	  j ++ ;						    	j ++ ;							  
  int j = i ++ ;					      	}							      }								  
  while ( arr [ j ] < arr [ j - 1 ] ) {			      	if ( j == n ) return true ;				      if ( j == n ) return true ;				  
    if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) {		      	int k = j ;						      int k = j ;						  
      return false ;					      	if ( arr [ k ] < arr [ i - 1 ] ) return false ;		      if ( arr [ k ] < arr [ i - 1 ] ) return false ;		  
    }							      	while ( k > 1 && k < n ) {				      while ( k > 1 && k < n ) {				  
    j ++ ;						      	  if ( arr [ k ] < arr [ k - 1 ] ) return false ;	    	if ( arr [ k ] < arr [ k - 1 ] ) return false ;		  
  }							      	  k ++ ;						    	k ++ ;							  
  if ( j == n ) {					      	}							      }								  
    return true ;					      	return true ;						      return true ;						  
  }							      }								    }								  
  int k = j ;						      								    								  
  if ( arr [ k ] < arr [ i - 1 ] ) {			      								    								  
    return false ;					      								    								  
  }							      								    								  
  while ( k > 1 && k < n ) {				      								    								  
    if ( arr [ k ] < arr [ k - 1 ] ) {			      								    								  
      return false ;					      								    								  
    }							      								    								  
    k ++ ;						      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7			      CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7			    CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7			  CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7
--							      --							    --								  --
static boolean isDivisible7 ( String num ) {		      int isdivisible7 ( char num [ ] ) {			    bool isDivisible7 ( string num ) {				  script_not_found : None
  int n = num . length ( ) ;				      	int n = strlen ( num ) , gSum ;				      int n = num . length ( ) ;				  
  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;    	if ( n == 0 && num [ 0 ] == '\n' ) return 1 ;		      if ( n == 0 && num [ 0 ] == '0' ) return true ;		  
  if ( n % 3 == 1 ) num = "00" + num ;			      	if ( n % 3 == 1 ) {					      if ( n % 3 == 1 ) num = "00" + num ;			  
  if ( n % 3 == 2 ) num = "0" + num ;			      	  strcat ( num , "00" ) ;				      if ( n % 3 == 2 ) num = "0" + num ;			  
  n = num . length ( ) ;				      	  n += 2 ;						      n = num . length ( ) ;					  
  int gSum = 0 , p = 1 ;				      	}							      int gSum = 0 , p = 1 ;					  
  for ( int i = n - 1 ;					      	else if ( n % 3 == 2 ) {				      for ( int i = n - 1 ;					  
  i >= 0 ;						      	  strcat ( num , "0" ) ;				      i >= 0 ;							  
  i -- ) {						      	  n ++ ;						      i -- ) {							  
    int group = 0 ;					      	}							    	int group = 0 ;						  
    group += num . charAt ( i -- ) - '0' ;		      	int i , GSum = 0 , p = 1 ;				    	group += num [ i -- ] - '0' ;				  
    group += ( num . charAt ( i -- ) - '0' ) * 10 ;	      	for ( i = n - 1 ;					    	group += ( num [ i -- ] - '0' ) * 10 ;			  
    group += ( num . charAt ( i ) - '0' ) * 100 ;	      	i >= 0 ;						    	group += ( num [ i ] - '0' ) * 100 ;			  
    gSum = gSum + group * p ;				      	i -- ) {						    	gSum = gSum + group * p ;				  
    p = p * - 1 ;					      	  int group = 0 ;					    	p = p * - 1 ;						  
  }							      	  group += num [ i -- ] - '0' ;				      }								  
  return ( gSum % 7 == 0 ) ;				      	  group += ( num [ i -- ] - '0' ) * 10 ;		      return ( gSum % 7 == 0 ) ;				  
}							      	  group += ( num [ i ] - '0' ) * 100 ;			    }								  
							      	  gSum = gSum + group * p ;				    								  
							      	  p *= ( - 1 ) ;					    								  
							      	}							    								  
							      	return ( gSum % 7 == 0 ) ;				    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS
--							      --							    --								  --
static int longestSubseqWithDiffOne ( int arr [ ] , int n ) { int longestSubseqWithDiffOne ( int arr [ ] , int n ) {	    int longestSubseqWithDiffOne ( int arr [ ] , int n ) {	  success : None
  int dp [ ] = new int [ n ] ;				      	int dp [ n ] ;						      int dp [ n ] ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) dp [ i ] = 1 ;					      	i ++ ) dp [ i ] = 1 ;					      i ++ ) {							  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	dp [ i ] = 1 ;						  
  i < n ;						      	i < n ;							      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 1 ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      i < n ;							  
    j < i ;						      	  j < i ;						      i ++ ) {							  
    j ++ ) {						      	  j ++ ) {						    	for ( int j = 0 ;					  
      if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == a 	    if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == a 	j < i ;							  
    }							      	  }							    	j ++ ) {						  
  }							      	}							    	  if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == a 
  int result = 1 ;					      	int result = 1 ;					    	    dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ;	  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	  }							  
  i < n ;						      	i < n ;							    	}							  
  i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ;	      	i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ;	      }								  
  return result ;					      	return result ;						      int result = 1 ;						  
}							      }								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ;	  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX		      REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX		    REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX		  REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX
--							      --							    --								  --
static int minRemovalsDP ( int arr [ ] , int n ) {	      int minRemovalsDP ( int arr [ ] , int n ) {		    int minRemovalsDP ( int arr [ ] , int n ) {			  success : identical to gold
  int longest_start = - 1 , longest_end = 0 ;		      	int longest_start = - 1 , longest_end = 0 ;		      int longest_start = - 1 , longest_end = 0 ;		  
  for ( int start = 0 ;					      	for ( int start = 0 ;					      for ( int start = 0 ;					  
  start < n ;						      	start < n ;						      start < n ;						  
  start ++ ) {						      	start ++ ) {						      start ++ ) {						  
    int min = Integer . MAX_VALUE , max = Integer . MIN_VALUE 	  int min = INT_MAX , max = INT_MIN ;			    	int min = INT_MAX , max = INT_MIN ;			  
    for ( int end = start ;				      	  for ( int end = start ;				    	for ( int end = start ;					  
    end < n ;						      	  end < n ;						    	end < n ;						  
    end ++ ) {						      	  end ++ ) {						    	end ++ ) {						  
      int val = arr [ end ] ;				      	    int val = arr [ end ] ;				    	  int val = arr [ end ] ;				  
      if ( val < min ) {				      	    if ( val < min ) min = val ;			    	  if ( val < min ) min = val ;				  
	min = val ;					      	    if ( val > max ) max = val ;			    	  if ( val > max ) max = val ;				  
      }							      	    if ( 2 * min <= max ) break ;			    	  if ( 2 * min <= max ) break ;				  
      if ( val > max ) {				      	    if ( end - start > longest_end - longest_start || longe 	  if ( end - start > longest_end - longest_start || longe 
	max = val ;					      	      longest_start = start ;				    	    longest_start = start ;				  
      }							      	      longest_end = end ;				    	    longest_end = end ;					  
      if ( 2 * min <= max ) {				      	    }							    	  }							  
	break ;						      	  }							    	}							  
      }							      	}							      }								  
      if ( end - start > longest_end - longest_start || longe 	if ( longest_start == - 1 ) return n ;			      if ( longest_start == - 1 ) return n ;			  
	longest_start = start ;				      	return ( n - ( longest_end - longest_start + 1 ) ) ;	      return ( n - ( longest_end - longest_start + 1 ) ) ;	  
	longest_end = end ;				      }								    }								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  if ( longest_start == - 1 ) {				      								    								  
    return n ;						      								    								  
  }							      								    								  
  return ( n - ( longest_end - longest_start + 1 ) ) ;	      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING  MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING  MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING  MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING
--							      --							    --								  --
static int minimalSteps ( String s , int n ) {		      int minimalSteps ( string s , int n ) {			    int minimalSteps ( string s , int n ) {			  script_not_found : None
  int [ ] dp = new int [ n ] ;				      	int dp [ n ] ;						      vector < int > dp ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      dp . reserve ( n ) ;					  
  i < n ;						      	i < n ;							      for ( int i = 0 ;						  
  i ++ ) dp [ i ] = Integer . MAX_VALUE ;		      	i ++ ) dp [ i ] = INT_MAX ;				      i < n ;							  
  String s1 = "" , s2 = "" ;				      	string s1 = "" , s2 = "" ;				      i ++ ) {							  
  dp [ 0 ] = 1 ;					      	dp [ 0 ] = 1 ;						    	dp . push_back ( INT_MAX ) ;				  
  s1 += s . charAt ( 0 ) ;				      	s1 += s [ 0 ] ;						      }								  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      string s1 , s2 ;						  
  i < n ;						      	i < n ;							      dp [ 0 ] = 1 ;						  
  i ++ ) {						      	i ++ ) {						      s1 += s [ 0 ] ;						  
    s1 += s . charAt ( i ) ;				      	  s1 += s [ i ] ;					      for ( int i = 1 ;						  
    s2 = s . substring ( i + 1 , i + 1 ) ;		      	  s2 = s . substr ( i + 1 , i + 1 ) ;			      i < n ;							  
    dp [ i ] = Math . min ( dp [ i ] , dp [ i - 1 ] + 1 ) ;   	  dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ;	      i ++ ) {							  
    if ( s1 == s2 ) dp [ i * 2 + 1 ] = Math . min ( dp [ i ]  	  if ( s1 == s2 ) dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , d 	s1 += s [ i ] ;						  
  }							      	}							    	s2 = s . substr ( i + 1 , 1 ) ;				  
  return dp [ n - 1 ] ;					      	return dp [ n - 1 ] ;					    	dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ;	  
}							      }								    	if ( s1 == s2 ) {					  
							      								    	  dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1  
							      								    	}							  
							      								      }								  
							      								      return dp [ n - 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMMON_CHARACTERS_N_STRINGS				      COMMON_CHARACTERS_N_STRINGS				    COMMON_CHARACTERS_N_STRINGS					  COMMON_CHARACTERS_N_STRINGS
--							      --							    --								  --
public static void commonCharacters ( String str [ ] , int n  void commonCharacters ( string str [ ] , int n ) {	    void common_characters ( string str , int n ) {		  script_not_found : None
  Boolean [ ] prim = new Boolean [ MAX_CHAR ] ;		      	bool prim [ MAX_CHAR ] ;				      bool prim [ MAX_CHAR ] ;					  
  Arrays . fill ( prim , new Boolean ( true ) ) ;	      	memset ( prim , true , sizeof ( prim ) ) ;		      memset ( prim , true , sizeof ( bool ) * MAX_CHAR ) ;	  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    Boolean [ ] sec = new Boolean [ MAX_CHAR ] ;	      	  bool sec [ MAX_CHAR ] = {				    	bool sec [ MAX_CHAR ] ;					  
    Arrays . fill ( sec , new Boolean ( false ) ) ;	      	    false }						    	memset ( sec , false , sizeof ( bool ) * MAX_CHAR ) ;	  
    for ( int j = 0 ;					      	    ;							    	for ( int j = 0 ;					  
    j < str [ i ] . length ( ) ;			      	    for ( int j = 0 ;					    	j < str [ i ] . length ( ) ;				  
    j ++ ) {						      	    str [ i ] [ j ] ;					    	j ++ ) {						  
      if ( prim [ str [ i ] . charAt ( j ) - 'a' ] ) sec [ st 	    j ++ ) {						    	  if ( prim [ str [ i ] [ j ] - 'a' ] ) {		  
    }							      	      if ( prim [ str [ i ] [ j ] - 'a' ] ) sec [ str [ i ] 	    sec [ str [ i ] [ j ] - 'a' ] = true ;		  
    System . arraycopy ( sec , 0 , prim , 0 , MAX_CHAR ) ;    	    }							    	  }							  
  }							      	    memcpy ( prim , sec , MAX_CHAR ) ;			    	}							  
  for ( int i = 0 ;					      	  }							    	memset ( prim , false , sizeof ( bool ) * MAX_CHAR ) ;	  
  i < 26 ;						      	  for ( int i = 0 ;					      }								  
  i ++ ) if ( prim [ i ] ) {				      	  i < 26 ;						      for ( int i = 0 ;						  
    System . out . print ( Character . toChars ( i + 97 ) ) ; 	  i ++ ) if ( prim [ i ] ) printf ( "%c " , i + 'a' ) ;	      i < 26 ;							  
    System . out . print ( " " ) ;			      	}							      i ++ ) if ( prim [ i ] ) {				  
  }							      								    	cout << char ( i + 97 ) ;				  
}							      								    	cout << " " ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEIBNIZ_HARMONIC_TRIANGLE				      LEIBNIZ_HARMONIC_TRIANGLE					    LEIBNIZ_HARMONIC_TRIANGLE					  LEIBNIZ_HARMONIC_TRIANGLE
--							      --							    --								  --
static void LeibnizHarmonicTriangle ( int n ) {		      void LeibnizHarmonicTriangle ( int n ) {			    void LeibnizHarmonicTriangle ( int n ) {			  script_not_found : None
  int C [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ;		      	int C [ n + 1 ] [ n + 1 ] ;				      int C [ n + 1 ] [ n + 1 ] ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= Math . min ( i , n ) ;				      	  j <= min ( i , n ) ;					    	j <= min ( i , n ) ;					  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;	      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  if ( j == 0 || j == i ) {				  
      else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	    else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	    C [ i ] [ j ] = 1 ;					  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	    C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ 
  i <= n ;						      	i <= n ;						    	  }							  
  i ++ ) {						      	i ++ ) {						    	}							  
    for ( int j = 1 ;					      	  for ( int j = 1 ;					      }								  
    j <= i ;						      	  j <= i ;						      for ( int i = 1 ;						  
    j ++ ) System . out . print ( "1/" + i * C [ i - 1 ] [ j  	  j ++ ) cout << "1/" << i * C [ i - 1 ] [ j - 1 ] << " " ;   i <= n ;							  
    System . out . println ( ) ;			      	  cout << endl ;					      i ++ ) {							  
  }							      	}							    	for ( int j = 1 ;					  
}							      }								    	j <= i ;						  
							      								    	j ++ ) {						  
							      								    	  cout << "1/" << i * C [ i - 1 ] [ j - 1 ] << " " ;	  
							      								    	}							  
							      								    	cout << endl ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_DIVISIBILITY_LARGE_NUMBER_999			      CHECK_DIVISIBILITY_LARGE_NUMBER_999			    CHECK_DIVISIBILITY_LARGE_NUMBER_999				  CHECK_DIVISIBILITY_LARGE_NUMBER_999
--							      --							    --								  --
static boolean isDivisible999 ( String num ) {		      bool isDivisible999 ( string num ) {			    bool isDivisible999 ( string num ) {			  success : None
  int n = num . length ( ) ;				      	int n = num . length ( ) ;				      int n = num . length ( ) ;				  
  if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ;    	if ( n == 0 && num [ 0 ] == '0' ) return true ;		      if ( n == 0 && num [ 0 ] == '0' ) return true ;		  
  if ( n % 3 == 1 ) num = "00" + num ;			      	if ( n % 3 == 1 ) num = "00" + num ;			      if ( n % 3 == 1 ) num = "00" + num ;			  
  if ( n % 3 == 2 ) num = "0" + num ;			      	if ( n % 3 == 2 ) num = "0" + num ;			      if ( n % 3 == 2 ) num = "0" + num ;			  
  int gSum = 0 ;					      	int gSum = 0 ;						      int gSum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int group = 0 ;					      	  int group = 0 ;					    	int group = 0 ;						  
    group += ( num . charAt ( i ++ ) - '0' ) * 100 ;	      	  group += ( num [ i ++ ] - '0' ) * 100 ;		    	group += ( num [ i ++ ] - '0' ) * 100 ;			  
    group += ( num . charAt ( i ++ ) - '0' ) * 10 ;	      	  group += ( num [ i ++ ] - '0' ) * 10 ;		    	group += ( num [ i ++ ] - '0' ) * 10 ;			  
    group += num . charAt ( i ) - '0' ;			      	  group += num [ i ] - '0' ;				    	group += num [ i ] - '0' ;				  
    gSum += group ;					      	  gSum += group ;					    	gSum += group ;						  
  }							      	}							      }								  
  if ( gSum > 1000 ) {					      	if ( gSum > 1000 ) {					      if ( gSum > 1000 ) {					  
    num = Integer . toString ( gSum ) ;			      	  num = to_string ( gSum ) ;				    	num = to_string ( gSum ) ;				  
    n = num . length ( ) ;				      	  n = num . length ( ) ;				    	n = num . length ( ) ;					  
    gSum = isDivisible999 ( num ) ? 1 : 0 ;		      	  gSum = isDivisible999 ( num ) ;			    	gSum = isDivisible999 ( num ) ? 1 : 0 ;			  
  }							      	}							      }								  
  return ( gSum == 999 ) ;				      	return ( gSum == 999 ) ;				      return ( gSum == 999 ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_COMMON_SUPERSEQUENCE_1				      SHORTEST_COMMON_SUPERSEQUENCE_1				    SHORTEST_COMMON_SUPERSEQUENCE_1				  SHORTEST_COMMON_SUPERSEQUENCE_1
--							      --							    --								  --
static int superSeq ( String X , String Y , int m , int n ) { int superSeq ( char * X , char * Y , int m , int n ) {	    int superSeq ( string X , string Y , int m , int n ) {	  script_not_found : None
  int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;	      	int dp [ m + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( m + 1 , vector < int > ( n +  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= m ;						      	i <= m ;						      i <= m ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= n ;						      	  j <= n ;						    	j <= n ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( i == 0 ) dp [ i ] [ j ] = j ;		      	    if ( ! i ) dp [ i ] [ j ] = j ;			    	  if ( i == 0 ) {					  
      else if ( j == 0 ) dp [ i ] [ j ] = i ;		      	    else if ( ! j ) dp [ i ] [ j ] = i ;		    	    dp [ i ] [ j ] = j ;				  
      else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 )  	    else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 	  }							  
      else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j 	    else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp 	  else if ( j == 0 ) {					  
    }							      	  }							    	    dp [ i ] [ j ] = i ;				  
  }							      	}							    	  }							  
  return dp [ m ] [ n ] ;				      	return dp [ m ] [ n ] ;					    	  else if ( X [ i - 1 ] == Y [ j - 1 ] ) {		  
}							      }								    	    dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;	  
							      								    	  }							  
							      								    	  else {						  
							      								    	    dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return dp [ m ] [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE		      COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE		    COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE		  COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE
--							      --							    --								  --
static void printRect ( Integer X [ ] , Integer Y [ ] , int n void printRect ( int X [ ] , int Y [ ] , int n ) {	    void print_rect ( int32_t X [ ] , int32_t Y [ ] , int n ) {	  script_not_found : None
  int Xmax = Collections . max ( Arrays . asList ( X ) ) ;    	int Xmax = * max_element ( X , X + n ) ;		      int32_t Xmax = std :: max ( std :: min ( X [ 0 ] , X [ n -  
  int Xmin = Collections . min ( Arrays . asList ( X ) ) ;    	int Xmin = * min_element ( X , X + n ) ;		      int32_t Xmin = std :: min ( std :: min ( X [ 0 ] , X [ n -  
  int Ymax = Collections . max ( Arrays . asList ( Y ) ) ;    	int Ymax = * max_element ( Y , Y + n ) ;		      int32_t Ymax = std :: max ( std :: min ( Y [ 0 ] , Y [ n -  
  int Ymin = Collections . min ( Arrays . asList ( Y ) ) ;    	int Ymin = * min_element ( Y , Y + n ) ;		      int32_t Ymin = std :: min ( std :: min ( Y [ 0 ] , Y [ n -  
  System . out . println ( "{" + Xmin + ", " + Ymin + "}" ) ; 	cout << "{" << Xmin << ", " << Ymin << "}" << endl ;	      printf ( "{%d, %d}" , Xmin , Ymin ) ;			  
  System . out . println ( "{" + Xmin + ", " + Ymax + "}" ) ; 	cout << "{" << Xmin << ", " << Ymax << "}" << endl ;	      printf ( "{%d, %d}" , Xmin , Ymax ) ;			  
  System . out . println ( "{" + Xmax + ", " + Ymax + "}" ) ; 	cout << "{" << Xmax << ", " << Ymax << "}" << endl ;	      printf ( "{%d, %d}" , Xmax , Ymax ) ;			  
  System . out . println ( "{" + Xmax + ", " + Ymin + "}" ) ; 	cout << "{" << Xmax << ", " << Ymin << "}" << endl ;	      printf ( "{%d, %d}" , Xmax , Ymin ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE			      LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE			    LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE			  LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE
--							      --							    --								  --
public static int longOddEvenIncSeq ( int arr [ ] , int n ) { int longOddEvenIncSeq ( int arr [ ] , int n ) {		    int longOddEvenIncSeq ( int arr [ ] , int n ) {		  success : None
  int [ ] lioes = new int [ n ] ;			      	int lioes [ n ] ;					      int lioes [ n ] ;						  
  int maxLen = 0 ;					      	int maxLen = 0 ;					      int maxLen = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) lioes [ i ] = 1 ;				      	i ++ ) lioes [ i ] = 1 ;				      i ++ ) {							  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	lioes [ i ] = 1 ;					  
  i < n ;						      	i < n ;							      }								  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      for ( int i = 1 ;						  
  j < i ;						      	j < i ;							      i < n ;							  
  j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j  	j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j    i ++ ) for ( int j = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      j < i ;							  
  i < n ;						      	i < n ;							      j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j  
  i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ;   	i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ;     for ( int i = 0 ;						  
  return maxLen ;					      	return maxLen ;						      i < n ;							  
}							      }								      i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ;	  
							      								      return maxLen ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE		      FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE		    FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE		  FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE
--							      --							    --								  --
static int maxHamming ( int arr [ ] , int n ) {		      int maxHamming ( int arr [ ] , int n ) {			    int maxHamming ( int arr [ ] , int n ) {			  success : None
  int brr [ ] = new int [ 2 * n + 1 ] ;			      	int brr [ 2 * n + 1 ] ;					      int brr [ 2 * n + 1 ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) brr [ i ] = arr [ i ] ;			      	i ++ ) brr [ i ] = arr [ i ] ;				      i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	brr [ i ] = arr [ i ] ;					  
  i < n ;						      	i < n ;							      }								  
  i ++ ) brr [ n + i ] = arr [ i ] ;			      	i ++ ) brr [ n + i ] = arr [ i ] ;			      for ( int i = 0 ;						  
  int maxHam = 0 ;					      	int maxHam = 0 ;					      i < n ;							  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      i ++ ) {							  
  i < n ;						      	i < n ;							    	brr [ n + i ] = arr [ i ] ;				  
  i ++ ) {						      	i ++ ) {						      }								  
    int currHam = 0 ;					      	  int currHam = 0 ;					      int maxHam = 0 ;						  
    for ( int j = i , k = 0 ;				      	  for ( int j = i , k = 0 ;				      for ( int i = 1 ;						  
    j < ( i + n ) ;					      	  j < ( i + n ) ;					      i < n ;							  
    j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ;  	  j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ;    i ++ ) {							  
    if ( currHam == n ) return n ;			      	  if ( currHam == n ) return n ;			    	int currHam = 0 ;					  
    maxHam = Math . max ( maxHam , currHam ) ;		      	  maxHam = max ( maxHam , currHam ) ;			    	for ( int j = i , k = 0 ;				  
  }							      	}							    	j < ( i + n ) ;						  
  return maxHam ;					      	return maxHam ;						    	j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ;  
}							      }								    	if ( currHam == n ) return n ;				  
							      								    	maxHam = max ( maxHam , currHam ) ;			  
							      								      }								  
							      								      return maxHam ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_K_MODULUS_ARRAY_ELEMENT				      FINDING_K_MODULUS_ARRAY_ELEMENT				    FINDING_K_MODULUS_ARRAY_ELEMENT				  FINDING_K_MODULUS_ARRAY_ELEMENT
--							      --							    --								  --
static void printEqualModNumbers ( int arr [ ] , int n ) {    void printEqualModNumbers ( int arr [ ] , int n ) {	    void printEqualModNumbers ( int arr [ ] , int n ) {		  script_not_found : None
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  int d = arr [ n - 1 ] - arr [ 0 ] ;			      	int d = arr [ n - 1 ] - arr [ 0 ] ;			      int d = arr [ n - 1 ] - arr [ 0 ] ;			  
  Vector < Integer > v = new Vector < > ( ) ;		      	vector < int > v ;					      Vector < int > v ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i * i <= d ;						      	i * i <= d ;						      i * i <= d ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( d % i == 0 ) {					      	  if ( d % i == 0 ) {					    	if ( d % i == 0 ) {					  
      v . add ( i ) ;					      	    v . push_back ( i ) ;				    	  v . push_back ( i ) ;					  
      if ( i != d / i ) v . add ( d / i ) ;		      	    if ( i != d / i ) v . push_back ( d / i ) ;		    	  if ( i != d / i ) {					  
    }							      	  }							    	    v . push_back ( d / i ) ;				  
  }							      	}							    	  }							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	}							  
  i < v . size ( ) ;					      	i < v . size ( ) ;					      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 0 ;						  
    int temp = arr [ 0 ] % v . get ( i ) ;		      	  int temp = arr [ 0 ] % v [ i ] ;			      i < v . size ( ) ;					  
    int j ;						      	  int j ;						      i ++ ) {							  
    for ( j = 1 ;					      	  for ( j = 1 ;						    	int temp = arr [ 0 ] % v [ i ] ;			  
    j < n ;						      	  j < n ;						    	int j ;							  
    j ++ ) if ( arr [ j ] % v . get ( i ) != temp ) break ;   	  j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ;	    	for ( j = 1 ;						  
    if ( j == n ) System . out . print ( v . get ( i ) + " "  	  if ( j == n ) cout << v [ i ] << " " ;		    	j < n ;							  
  }							      	}							    	j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ;	  
}							      }								    	if ( j == n ) cout << v [ i ] << " " ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S		      LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S		    LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S		  LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S
--							      --							    --								  --
int findSubArray ( int arr [ ] , int n ) {		      int findSubArray ( int arr [ ] , int n ) {		    int findSubArray ( int arr [ ] , int n ) {			  success : None
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  int maxsize = - 1 , startindex = 0 ;			      	int maxsize = - 1 , startindex ;			      int maxsize = - 1 , startindex = 0 ;			  
  int endindex = 0 ;					      	for ( int i = 0 ;					      int endindex = 0 ;					  
  for ( int i = 0 ;					      	i < n - 1 ;						      for ( int i = 0 ;						  
  i < n - 1 ;						      	i ++ ) {						      i < n - 1 ;						  
  i ++ ) {						      	  sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;			      i ++ ) {							  
    sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;		      	  for ( int j = i + 1 ;					    	sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;			  
    for ( int j = i + 1 ;				      	  j < n ;						    	for ( int j = i + 1 ;					  
    j < n ;						      	  j ++ ) {						    	j < n ;							  
    j ++ ) {						      	    ( arr [ j ] == 0 ) ? ( sum += - 1 ) : ( sum += 1 ) ;    	j ++ ) {						  
      if ( arr [ j ] == 0 ) sum += - 1 ;		      	    if ( sum == 0 && maxsize < j - i + 1 ) {		    	  if ( arr [ j ] == 0 ) {				  
      else sum += 1 ;					      	      maxsize = j - i + 1 ;				    	    sum += - 1 ;					  
      if ( sum == 0 && maxsize < j - i + 1 ) {		      	      startindex = i ;					    	  }							  
	maxsize = j - i + 1 ;				      	    }							    	  else {						  
	startindex = i ;				      	  }							    	    sum += 1 ;						  
      }							      	}							    	  }							  
    }							      	if ( maxsize == - 1 ) cout << "No such subarray" ;	    	  if ( sum == 0 && maxsize < j - i + 1 ) {		  
  }							      	else cout << startindex << " to " << startindex + maxsize - 	    maxsize = j - i + 1 ;				  
  endindex = startindex + maxsize - 1 ;			      	return maxsize ;					    	    startindex = i ;					  
  if ( maxsize == - 1 ) System . out . println ( "No such sub }								    	  }							  
  else System . out . println ( startindex + " to " + endinde 								    	}							  
  return maxsize ;					      								      }								  
}							      								      endindex = startindex + maxsize - 1 ;			  
							      								      if ( maxsize == - 1 ) {					  
							      								    	cout << "No such subarray" << endl ;			  
							      								      }								  
							      								      else {							  
							      								    	cout << startindex << " to " << endindex << endl ;	  
							      								      }								  
							      								      return maxsize ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME		      CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME		    CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME		  CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME
--							      --							    --								  --
static String constructPalin ( char [ ] str , int len ) {     string constructPalin ( string str , int len ) {		    string constructPalin ( char * str , int len ) {		  script_not_found : None
  int i = 0 , j = len - 1 ;				      	int i = 0 , j = len - 1 ;				      int i = 0 , j = len - 1 ;					  
  for ( ;						      	for ( ;							      for ( ;							  
  i < j ;						      	i < j ;							      i < j ;							  
  i ++ , j -- ) {					      	i ++ , j -- ) {						      i ++ , j -- ) {						  
    if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continu 	  if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continu 	if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continu 
    else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) {  	  else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) {  	else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) {  
      str [ i ] = 'a' ;					      	    str [ i ] = 'a' ;					    	  str [ i ] = 'a' ;					  
      str [ j ] = 'a' ;					      	    str [ j ] = 'a' ;					    	  str [ j ] = 'a' ;					  
      continue ;					      	    continue ;						    	  continue ;						  
    }							      	  }							    	}							  
    else if ( str [ i ] == '*' ) {			      	  else if ( str [ i ] == '*' ) {			    	else if ( str [ i ] == '*' ) {				  
      str [ i ] = str [ j ] ;				      	    str [ i ] = str [ j ] ;				    	  str [ i ] = str [ j ] ;				  
      continue ;					      	    continue ;						    	  continue ;						  
    }							      	  }							    	}							  
    else if ( str [ j ] == '*' ) {			      	  else if ( str [ j ] == '*' ) {			    	else if ( str [ j ] == '*' ) {				  
      str [ j ] = str [ i ] ;				      	    str [ j ] = str [ i ] ;				    	  str [ j ] = str [ i ] ;				  
      continue ;					      	    continue ;						    	  continue ;						  
    }							      	  }							    	}							  
    System . out . println ( "Not Possible" ) ;		      	  cout << "Not Possible" ;				    	cout << "Not Possible" << endl ;			  
    return "" ;						      	  return "" ;						    	return "" ;						  
  }							      	}							      }								  
  return String . valueOf ( str ) ;			      	return str ;						      return string ( str , len ) ;				  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1		      CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1		    CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1		  CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1
--							      --							    --								  --
static void substringConversions ( String str , int k , int b int substringConversions ( string str , int k , int b ) {	    void substring_conversions ( string str , int k , int b ) {	  script_not_found : None
  int i = 0 , sum = 0 , counter = k - 1 ;		      	int i = 0 , sum = 0 , counter = k - 1 ;			      int i = 0 , sum = 0 , counter = k - 1 ;			  
  for ( i = 0 ;						      	for ( i ;						      for ( i = 0 ;						  
  i < k ;						      	i < k ;							      i < k ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    sum = ( int ) ( sum + ( ( str . charAt ( i ) - '0' ) * Ma 	  sum = sum + ( ( str . at ( i ) - '0' ) * pow ( b , counte 	sum = ( int ) ( sum + ( ( str [ i ] - '0' ) * pow ( b , c 
    counter -- ;					      	  counter -- ;						    	counter -- ;						  
  }							      	}							      }								  
  System . out . print ( sum + " " ) ;			      	cout << sum << " " ;					      cout << sum << " " ;					  
  int prev = sum ;					      	int prev = sum ;					      int prev = sum ;						  
  sum = 0 ;						      	sum = 0 , counter = 0 ;					      sum = 0 ;							  
  counter = 0 ;						      	for ( i ;						      counter = 0 ;						  
  for ( ;						      	i < str . size ( ) ;					      for ( ;							  
  i < str . length ( ) ;				      	i ++ ) {						      i < str . length ( ) ;					  
  i ++ ) {						      	  sum = prev - ( ( str . at ( i - k ) - '0' ) * pow ( b , k   i ++ ) {							  
    sum = ( int ) ( prev - ( ( str . charAt ( i - k ) - '0' ) 	  sum = sum * b ;					    	sum = ( int ) ( prev - ( ( str [ i - k ] - '0' ) * pow (  
    sum = sum * b ;					      	  sum = sum + ( str . at ( i ) - '0' ) ;		    	sum = sum * b ;						  
    sum = sum + ( str . charAt ( i ) - '0' ) ;		      	  cout << sum << " " ;					    	sum = sum + ( str [ i ] - '0' ) ;			  
    System . out . print ( sum + " " ) ;		      	  prev = sum ;						    	cout << sum << " " ;					  
    prev = sum ;					      	  counter ++ ;						    	prev = sum ;						  
    counter ++ ;					      	}							    	counter ++ ;						  
  }							      }								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S
--							      --							    --								  --
static void deleteElements ( int arr [ ] , int n , int k ) {  void deleteElements ( int arr [ ] , int n , int k ) {	    void deleteElements ( int arr [ ] , int n , int k ) {	  script_not_found : None
  Stack < Integer > s = new Stack < > ( ) ;		      	stack < int > s ;					      stack < int > s ;						  
  s . push ( arr [ 0 ] ) ;				      	s . push ( arr [ 0 ] ) ;				      s . push ( arr [ 0 ] ) ;					  
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    while ( ! s . empty ( ) && s . peek ( ) < arr [ i ] && co 	  while ( ! s . empty ( ) && s . top ( ) < arr [ i ] && cou 	while ( ! s . empty ( ) && s . top ( ) < arr [ i ] && cou 
      s . pop ( ) ;					      	    s . pop ( ) ;					    	  s . pop ( ) ;						  
      count ++ ;					      	    count ++ ;						    	  count ++ ;						  
    }							      	  }							    	}							  
    s . push ( arr [ i ] ) ;				      	  s . push ( arr [ i ] ) ;				    	s . push ( arr [ i ] ) ;				  
  }							      	}							      }								  
  int m = s . size ( ) ;				      	int m = s . size ( ) ;					      int m = s . size ( ) ;					  
  Integer [ ] v = new Integer [ m ] ;			      	vector < int > v ( m ) ;				      int v [ m ] ;						  
  while ( ! s . empty ( ) ) {				      	while ( ! s . empty ( ) ) {				      while ( ! s . empty ( ) ) {				  
    v [ -- m ] = s . peek ( ) ;				      	  v [ -- m ] = s . top ( ) ;				    	v [ -- m ] = s . top ( ) ;				  
    s . pop ( ) ;					      	  s . pop ( ) ;						    	s . pop ( ) ;						  
  }							      	}							      }								  
  for ( Integer x : v ) {				      	for ( auto x : v ) cout << x << " " ;			      for ( int x : v ) cout << x << " " ;			  
    System . out . print ( x + " " ) ;			      	cout << endl ;						      ;								  
  }							      }								      cout << "\n" ;						  
  ;							      								    }								  
  System . out . println ( "" ) ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS	      CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS	    CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS	  CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS
--							      --							    --								  --
static boolean HalfDiagonalSums ( int mat [ ] [ ] , int n ) { bool HalfDiagonalSums ( int mat [ ] [ MAX ] , int n ) {	    bool HalfDiagonalSums ( int mat [ ] [ 4 ] , int n ) {	  script_not_found : None
  int diag1_left = 0 , diag1_right = 0 ;		      	int diag1_left = 0 , diag1_right = 0 ;			      int diag1_left = 0 , diag1_right = 0 ;			  
  int diag2_left = 0 , diag2_right = 0 ;		      	int diag2_left = 0 , diag2_right = 0 ;			      int diag2_left = 0 , diag2_right = 0 ;			  
  for ( int i = 0 , j = n - 1 ;				      	for ( int i = 0 , j = n - 1 ;				      for ( int i = 0 , j = n - 1 ;				  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ , j -- ) {					      	i ++ , j -- ) {						      i ++ , j -- ) {						  
    if ( i < n / 2 ) {					      	  if ( i < n / 2 ) {					    	if ( i < n / 2 ) {					  
      diag1_left += mat [ i ] [ i ] ;			      	    diag1_left += mat [ i ] [ i ] ;			    	  diag1_left += mat [ i ] [ i ] ;			  
      diag2_left += mat [ j ] [ i ] ;			      	    diag2_left += mat [ j ] [ i ] ;			    	  diag2_left += mat [ j ] [ i ] ;			  
    }							      	  }							    	}							  
    else if ( i > n / 2 ) {				      	  else if ( i > n / 2 ) {				    	else if ( i > n / 2 ) {					  
      diag1_right += mat [ i ] [ i ] ;			      	    diag1_right += mat [ i ] [ i ] ;			    	  diag1_right += mat [ i ] [ i ] ;			  
      diag2_right += mat [ j ] [ i ] ;			      	    diag2_right += mat [ j ] [ i ] ;			    	  diag2_right += mat [ j ] [ i ] ;			  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return ( diag1_left == diag2_right && diag2_right == diag2_ 	return ( diag1_left == diag2_right && diag2_right == diag2_   return ( diag1_left == diag2_right && diag2_right == diag2_ 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_MAXIMUM_SHORTEST_DISTANCE				      PRINT_MAXIMUM_SHORTEST_DISTANCE				    PRINT_MAXIMUM_SHORTEST_DISTANCE				  PRINT_MAXIMUM_SHORTEST_DISTANCE
--							      --							    --								  --
static int find_maximum ( int a [ ] , int n , int k ) {	      int find_maximum ( int a [ ] , int n , int k ) {		    int findMaximum ( int a [ ] , int n , int k ) {		  success : None
  HashMap < Integer , Integer > b = new HashMap < Integer , I 	unordered_map < int , int > b ;				      unordered_map < int , int > b ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int x = a [ i ] ;					      	  int x = a [ i ] ;					    	int x = a [ i ] ;					  
    int d = Math . min ( 1 + i , n - i ) ;		      	  int d = min ( 1 + i , n - i ) ;			    	int d = min ( 1 + i , n - i ) ;				  
    if ( ! b . containsKey ( x ) ) b . put ( x , d ) ;	      	  if ( b . find ( x ) == b . end ( ) ) b [ x ] = d ;	    	if ( ! b . count ( x ) ) {				  
    else {						      	  else b [ x ] = min ( d , b [ x ] ) ;			    	  b [ x ] = d ;						  
      b . put ( x , Math . min ( d , b . get ( x ) ) ) ;      	}							    	}							  
    }							      	int ans = INT_MAX ;					    	else {							  
  }							      	for ( int i = 0 ;					    	  b [ x ] = min ( d , b [ x ] ) ;			  
  int ans = Integer . MAX_VALUE ;			      	i < n ;							    	}							  
  for ( int i = 0 ;					      	i ++ ) {						      }								  
  i < n ;						      	  int x = a [ i ] ;					      int ans = INT_MAX ;					  
  i ++ ) {						      	  if ( x != k - x && b . find ( k - x ) != b . end ( ) ) an   for ( int i = 0 ;						  
    int x = a [ i ] ;					      	}							      i < n ;							  
    if ( x != k - x && b . containsKey ( k - x ) ) ans = Math 	return ans ;						      i ++ ) {							  
  }							      }								    	int x = a [ i ] ;					  
  return ans ;						      								    	if ( x != k - x && b . count ( k - x ) ) {		  
}							      								    	  ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) ;	  
							      								    	}							  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A
--							      --							    --								  --
static void printInSortedOrder ( String arr [ ] , int n ) {   void printInSortedOrder ( string arr [ ] , int n ) {	    void printInSortedOrder ( string arr [ ] , int n ) {	  script_not_found : None
  int index [ ] = new int [ n ] ;			      	int index [ n ] ;					      vector < int > index ( n , 0 ) ;				  
  int i , j , min ;					      	int i , j , min ;					      int i , j , min ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) index [ i ] = i ;				      i ++ ) index [ i ] = i ;					  
    index [ i ] = i ;					      	for ( i = 0 ;						      for ( i = 0 ;						  
  }							      	i < n - 1 ;						      i < n - 1 ;						  
  for ( i = 0 ;						      	i ++ ) {						      i ++ ) {							  
  i < n - 1 ;						      	  min = i ;						    	min = i ;						  
  i ++ ) {						      	  for ( j = i + 1 ;					    	for ( j = i + 1 ;					  
    min = i ;						      	  j < n ;						    	j < n ;							  
    for ( j = i + 1 ;					      	  j ++ ) {						    	j ++ ) {						  
    j < n ;						      	    if ( arr [ index [ min ] ] . compare ( arr [ index [ j  	  if ( arr [ index [ min ] ] > arr [ index [ j ] ] ) min  
    j ++ ) {						      	  }							    	}							  
      if ( arr [ index [ min ] ] . compareTo ( arr [ index [  	  if ( min != i ) {					    	if ( min != i ) {					  
	min = j ;					      	    int temp = index [ min ] ;				    	  int temp = index [ min ] ;				  
      }							      	    index [ min ] = index [ i ] ;			    	  index [ min ] = index [ i ] ;				  
    }							      	    index [ i ] = temp ;				    	  index [ i ] = temp ;					  
    if ( min != i ) {					      	  }							    	}							  
      int temp = index [ min ] ;			      	}							      }								  
      index [ min ] = index [ i ] ;			      	for ( i = 0 ;						      for ( i = 0 ;						  
      index [ i ] = temp ;				      	i < n ;							      i < n ;							  
    }							      	i ++ ) cout << arr [ index [ i ] ] << " " ;		      i ++ ) cout << arr [ index [ i ] ] << " " ;		  
  }							      }								    }								  
  for ( i = 0 ;						      								    								  
  i < n ;						      								    								  
  i ++ ) {						      								    								  
    System . out . print ( arr [ index [ i ] ] + " " ) ;      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1	      DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1		    DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1		  DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1
--							      --							    --								  --
static int knapSack ( int W , int wt [ ] , int val [ ] , int  int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {   int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {	  script_not_found : None
  int i , w ;						      	int i , w ;						      int i , w ;						  
  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;		      	int K [ n + 1 ] [ W + 1 ] ;				      int K [ n + 1 ] [ W + 1 ] ;				  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( w = 0 ;					      	  for ( w = 0 ;						    	for ( w = 0 ;						  
    w <= W ;						      	  w <= W ;						    	w <= W ;						  
    w ++ ) {						      	  w ++ ) {						    	w ++ ) {						  
      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;	      	    if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;		    	  if ( i == 0 || w == 0 ) {				  
      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 	    else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 	    K [ i ] [ w ] = 0 ;					  
      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		      	    else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		    	  }							  
    }							      	  }							    	  else if ( wt [ i - 1 ] <= w ) {			  
  }							      	}							    	    K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w 
  return K [ n ] [ W ] ;				      	return K [ n ] [ W ] ;					    	  }							  
}							      }								    	  else {						  
							      								    	    K [ i ] [ w ] = K [ i - 1 ] [ w ] ;			  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return K [ n ] [ W ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN
--							      --							    --								  --
static int findMaximum ( int arr [ ] , int low , int high ) { int findMaximum ( int arr [ ] , int low , int high ) {	    int findMaximum ( int arr [ ] , int low , int high ) {	  script_not_found : None
  if ( low == high ) return arr [ low ] ;		      	if ( low == high ) return arr [ low ] ;			      if ( low == high ) return arr [ low ] ;			  
  if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) r 	if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) r   if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) r 
  if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) re 	if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) re   if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) re 
  int mid = ( low + high ) / 2 ;			      	int mid = ( low + high ) / 2 ;				      int mid = ( low + high ) / 2 ;				  
  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ m 	if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ m   if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ m 
  if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ m 	if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ m   if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ m 
  else return findMaximum ( arr , mid + 1 , high ) ;	      	else return findMaximum ( arr , mid + 1 , high ) ;	      else return findMaximum ( arr , mid + 1 , high ) ;	  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2		      FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2		    FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2			  FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2
--							      --							    --								  --
static void findTriplets ( int arr [ ] , int n ) {	      void findTriplets ( int arr [ ] , int n ) {		    void findTriplets ( int arr [ ] , int n ) {			  script_not_found : None
  boolean found = false ;				      	bool found = false ;					      bool found = false ;					  
  Arrays . sort ( arr ) ;				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int l = i + 1 ;					      	  int l = i + 1 ;					    	int l = i + 1 ;						  
    int r = n - 1 ;					      	  int r = n - 1 ;					    	int r = n - 1 ;						  
    int x = arr [ i ] ;					      	  int x = arr [ i ] ;					    	int x = arr [ i ] ;					  
    while ( l < r ) {					      	  while ( l < r ) {					    	while ( l < r ) {					  
      if ( x + arr [ l ] + arr [ r ] == 0 ) {		      	    if ( x + arr [ l ] + arr [ r ] == 0 ) {		    	  if ( x + arr [ l ] + arr [ r ] == 0 ) {		  
	System . out . print ( x + " " ) ;		      	      printf ( "%d %d %d\n" , x , arr [ l ] , arr [ r ] ) ; 	    cout << x << " " ;					  
	System . out . print ( arr [ l ] + " " ) ;	      	      l ++ ;						    	    cout << arr [ l ] << " " ;				  
	System . out . println ( arr [ r ] + " " ) ;	      	      r -- ;						    	    cout << arr [ r ] << " " ;				  
	l ++ ;						      	      found = true ;					    	    l ++ ;						  
	r -- ;						      	    }							    	    r -- ;						  
	found = true ;					      	    else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ;	    	    found = true ;					  
      }							      	    else r -- ;						    	  }							  
      else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ;	      	  }							    	  else if ( x + arr [ l ] + arr [ r ] < 0 ) {		  
      else r -- ;					      	}							    	    l ++ ;						  
    }							      	if ( found == false ) cout << " No Triplet Found" << endl ; 	  }							  
  }							      }								    	  else {						  
  if ( found == false ) System . out . println ( " No Triplet 								    	    r -- ;						  
}							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      if ( found == false ) {					  
							      								    	cout << " No Triplet Found" << endl ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE    MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE    MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE	  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE
--							      --							    --								  --
static int maxSumWO3Consec ( int arr [ ] , int n ) {	      int maxSumWO3Consec ( int arr [ ] , int n ) {		    int maxSumWO3Consec ( int arr [ ] , int n ) {		  success : None
  int sum [ ] = new int [ n ] ;				      	int sum [ n ] ;						      int sum [ n ] ;						  
  if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ;			      	if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ;			      if ( n >= 1 ) {						  
  if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ;	      	if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ;	    	sum [ 0 ] = arr [ 0 ] ;					  
  if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . ma 	if ( n > 2 ) sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ]    }								  
  for ( int i = 3 ;					      	for ( int i = 3 ;					      if ( n >= 2 ) {						  
  i < n ;						      	i < n ;							    	sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ;			  
  i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ]  	i ++ ) sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2    }								  
  return sum [ n - 1 ] ;				      	return sum [ n - 1 ] ;					      if ( n > 2 ) {						  
}							      }								    	sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] 
							      								      }								  
							      								      for ( int i = 3 ;						  
							      								      i < n ;							  
							      								      i ++ ) {							  
							      								    	sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + a 
							      								      }								  
							      								      return sum [ n - 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2	      LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2	    LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2		  LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2
--							      --							    --								  --
static int longLenSub ( int [ ] arr , int n ) {		      int longLenSub ( int arr [ ] , int n ) {			    int longLenSub ( int * arr , int n ) {			  error : LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_O
  HashMap < Integer , Integer > um = new HashMap < Integer ,  	unordered_map < int , int > um ;			      unordered_map < int , int > um ;				  NE_SET_2.cpp: In function ‘int f_filled(int*, int)
  int longLen = 0 ;					      	int longLen = 0 ;					      int longLen = 0 ;						  ’: LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SE
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  T_2.cpp:39:66: error: expected ‘]’ before ‘)’ toke
  i < n ;						      	i < n ;							      i < n ;							  n	 if ( um . count ( arr [ i ] - 1 ) && len <
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  um [ arr [ i ] - 1 ) {
    int len = 0 ;					      	  int len = 0 ;						    	int len = 0 ;						  					 ^~
    if ( um . containsKey ( arr [ i ] - 1 ) && len < um . get 	  if ( um . find ( arr [ i ] - 1 ) != um . end ( ) && len < 	if ( um . count ( arr [ i ] - 1 ) && len < um [ arr [ i ] 
    if ( um . containsKey ( arr [ i ] + 1 ) && len < um . get 	  if ( um . find ( arr [ i ] + 1 ) != um . end ( ) && len < 	  len = um [ arr [ i ] - 1 ] ;				  	  ]
    um . put ( arr [ i ] , len + 1 ) ;			      	  um [ arr [ i ] ] = len + 1 ;				    	}							  
    if ( longLen < um . get ( arr [ i ] ) ) longLen = um . ge 	  if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i  	if ( um . count ( arr [ i ] + 1 ) && len < um [ arr [ i ] 
  }							      	}							    	  len = um [ arr [ i ] + 1 ] ;				  
  return longLen ;					      	return longLen ;					    	}							  
}							      }								    	um [ arr [ i ] ] = len + 1 ;				  
							      								    	if ( longLen < um [ arr [ i ] ] ) {			  
							      								    	  longLen = um [ arr [ i ] ] ;				  
							      								    	}							  
							      								      }								  
							      								      return longLen ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN			      PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN			    PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN			  PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN
--							      --							    --								  --
static void printPath ( String str ) {			      void printPath ( string str ) {				    void printPath ( string str ) {				  script_not_found : None
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  int curX = 0 , curY = 0 ;				      	int curX = 0 , curY = 0 ;				      int curX = 0 , curY = 0 ;					  
  while ( i < str . length ( ) ) {			      	while ( i < str . length ( ) ) {			      while ( i < str . length ( ) ) {				  
    int nextX = ( str . charAt ( i ) - 'A' ) / 5 ;	      	  int nextX = ( str [ i ] - 'A' ) / 5 ;			    	int nextX = ( str [ i ] - 'A' ) / 5 ;			  
    int nextY = ( str . charAt ( i ) - 'B' + 1 ) % 5 ;	      	  int nextY = ( str [ i ] - 'B' + 1 ) % 5 ;		    	int nextY = ( str [ i ] - 'B' + 1 ) % 5 ;		  
    while ( curX > nextX ) {				      	  while ( curX > nextX ) {				    	while ( curX > nextX ) {				  
      System . out . println ( "Move Up" ) ;		      	    cout << "Move Up" << endl ;				    	  cout << "Move Up" << endl ;				  
      curX -- ;						      	    curX -- ;						    	  curX -- ;						  
    }							      	  }							    	}							  
    while ( curY > nextY ) {				      	  while ( curY > nextY ) {				    	while ( curY > nextY ) {				  
      System . out . println ( "Move Left" ) ;		      	    cout << "Move Left" << endl ;			    	  cout << "Move Left" << endl ;				  
      curY -- ;						      	    curY -- ;						    	  curY -- ;						  
    }							      	  }							    	}							  
    while ( curX < nextX ) {				      	  while ( curX < nextX ) {				    	while ( curX < nextX ) {				  
      System . out . println ( "Move Down" ) ;		      	    cout << "Move Down" << endl ;			    	  cout << "Move Down" << endl ;				  
      curX ++ ;						      	    curX ++ ;						    	  curX ++ ;						  
    }							      	  }							    	}							  
    while ( curY < nextY ) {				      	  while ( curY < nextY ) {				    	while ( curY < nextY ) {				  
      System . out . println ( "Move Right" ) ;		      	    cout << "Move Right" << endl ;			    	  cout << "Move Right" << endl ;			  
      curY ++ ;						      	    curY ++ ;						    	  curY ++ ;						  
    }							      	  }							    	}							  
    System . out . println ( "Press OK" ) ;		      	  cout << "Press OK" << endl ;				    	cout << "Press OK" << endl ;				  
    i ++ ;						      	  i ++ ;						    	i ++ ;							  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B	      DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B	    DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B	  DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B
--							      --							    --								  --
static int discreteLogarithm ( int a , int b , int m ) {      int discreteLogarithm ( int a , int b , int m ) {		    int discreteLogarithm ( int a , int b , int m ) {		  success : None
  int n = ( int ) ( Math . sqrt ( m ) + 1 ) ;		      	int n = ( int ) sqrt ( m ) + 1 ;			      int n = ( int ) ( sqrt ( m ) + 1 ) ;			  
  int an = 1 ;						      	int an = 1 ;						      int an = 1 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  ++ i ) an = ( an * a ) % m ;				      	++ i ) an = ( an * a ) % m ;				      ++ i ) {							  
  int [ ] value = new int [ m ] ;			      	unordered_map < int , int > value ;			    	an = ( an * a ) % m ;					  
  for ( int i = 1 , cur = an ;				      	for ( int i = 1 , cur = an ;				      }								  
  i <= n ;						      	i <= n ;						      vector < int > value ( m , 0 ) ;				  
  ++ i ) {						      	++ i ) {						      for ( int i = 1 , cur = an ;				  
    if ( value [ cur ] == 0 ) value [ cur ] = i ;	      	  if ( ! value [ cur ] ) value [ cur ] = i ;		      i <= n ;							  
    cur = ( cur * an ) % m ;				      	  cur = ( cur * an ) % m ;				      ++ i ) {							  
  }							      	}							    	if ( value [ cur ] == 0 ) {				  
  for ( int i = 0 , cur = b ;				      	for ( int i = 0 , cur = b ;				    	  value [ cur ] = i ;					  
  i <= n ;						      	i <= n ;						    	}							  
  ++ i ) {						      	++ i ) {						    	cur = ( cur * an ) % m ;				  
    if ( value [ cur ] > 0 ) {				      	  if ( value [ cur ] ) {				      }								  
      int ans = value [ cur ] * n - i ;			      	    int ans = value [ cur ] * n - i ;			      for ( int i = 0 , cur = b ;				  
      if ( ans < m ) return ans ;			      	    if ( ans < m ) return ans ;				      i <= n ;							  
    }							      	  }							      ++ i ) {							  
    cur = ( cur * a ) % m ;				      	  cur = ( cur * a ) % m ;				    	if ( value [ cur ] > 0 ) {				  
  }							      	}							    	  int ans = value [ cur ] * n - i ;			  
  return - 1 ;						      	return - 1 ;						    	  if ( ans < m ) {					  
}							      }								    	    return ans ;					  
							      								    	  }							  
							      								    	}							  
							      								    	cur = ( cur * a ) % m ;					  
							      								      }								  
							      								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD    FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD    FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD	  FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD
--							      --							    --								  --
boolean findPairs ( int arr [ ] ) {			      bool findPairs ( int arr [ ] , int n ) {			    bool findPairs ( int arr [ ] ) {				  script_not_found : None
  HashMap < Integer , pair > map = new HashMap < Integer , pa 	map < int , pair < int , int >> Hash ;			      unordered_map < int , pair > map ;			  
  int n = arr . length ;				      	for ( int i = 0 ;					      int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	++ i ) {						      i < n ;							  
  ++ i ) {						      	  for ( int j = i + 1 ;					      ++ i ) {							  
    for ( int j = i + 1 ;				      	  j < n ;						    	for ( int j = i + 1 ;					  
    j < n ;						      	  ++ j ) {						    	j < n ;							  
    ++ j ) {						      	    int sum = arr [ i ] + arr [ j ] ;			    	++ j ) {						  
      int sum = arr [ i ] + arr [ j ] ;			      	    if ( Hash . find ( sum ) == Hash . end ( ) ) Hash [ sum 	  int sum = arr [ i ] + arr [ j ] ;			  
      if ( ! map . containsKey ( sum ) ) map . put ( sum , ne 	    else {						    	  if ( ! map . count ( sum ) ) {			  
      else {						      	      pair < int , int > pp = Hash [ sum ] ;		    	    map [ sum ] = make_pair ( i , j ) ;			  
	pair p = map . get ( sum ) ;			      	      cout << "(" << arr [ pp . first ] << ", " << arr [ pp 	  }							  
	System . out . println ( "(" + arr [ p . first ] + ", 	      return true ;					    	  else {						  
	return true ;					      	    }							    	    pair p = map [ sum ] ;				  
      }							      	  }							    	    cout << "(" << arr [ p . first ] << ", " << arr [ p . 
    }							      	}							    	    return true ;					  
  }							      	cout << "No pairs found" ;				    	  }							  
  return false ;					      	return false ;						    	}							  
}							      }								      }								  
							      								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS		      THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS		    THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS		  THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS
--							      --							    --								  --
static void thirdLargest ( int arr [ ] , int arr_size ) {     void thirdLargest ( int arr [ ] , int arr_size ) {	    void thirdLargest ( int arr [ ] , int arr_size ) {		  script_not_found : None
  if ( arr_size < 3 ) {					      	if ( arr_size < 3 ) {					      if ( arr_size < 3 ) {					  
    System . out . printf ( " Invalid Input " ) ;	      	  printf ( " Invalid Input " ) ;			    	printf ( " Invalid Input " ) ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  int first = arr [ 0 ] ;				      	int first = arr [ 0 ] ;					      int first = arr [ 0 ] ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < arr_size ;					      	i < arr_size ;						      i < arr_size ;						  
  i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ;	      	i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ;	      i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ;	  
  int second = Integer . MIN_VALUE ;			      	int second = INT_MIN ;					      int second = INT_MAX ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < arr_size ;					      	i < arr_size ;						      i < arr_size ;						  
  i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) secon 	i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) secon   i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) secon 
  int third = Integer . MIN_VALUE ;			      	int third = INT_MIN ;					      int third = INT_MAX ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < arr_size ;					      	i < arr_size ;						      i < arr_size ;						  
  i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third 	i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third   i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third 
  System . out . printf ( "The third Largest " + "element is  	printf ( "The third Largest element is %d\n" , third ) ;      printf ( "The third Largest " "element is %d\n" , third ) ; 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBSET_SUM_PROBLEM_OSUM_SPACE				      SUBSET_SUM_PROBLEM_OSUM_SPACE				    SUBSET_SUM_PROBLEM_OSUM_SPACE				  SUBSET_SUM_PROBLEM_OSUM_SPACE
--							      --							    --								  --
static boolean isSubsetSum ( int arr [ ] , int n , int sum )  bool isSubsetSum ( int arr [ ] , int n , int sum ) {	    bool isSubsetSum ( int arr [ ] , int n , int sum ) {	  success : None
  boolean subset [ ] [ ] = new boolean [ 2 ] [ sum + 1 ] ;    	bool subset [ 2 ] [ sum + 1 ] ;				      bool subset [ 2 ] [ sum + 1 ] ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= sum ;						      	  j <= sum ;						    	j <= sum ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( j == 0 ) subset [ i % 2 ] [ j ] = true ;	      	    if ( j == 0 ) subset [ i % 2 ] [ j ] = true ;	    	  if ( j == 0 ) {					  
      else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ;     	    else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ;	    	    subset [ i % 2 ] [ j ] = true ;			  
      else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = 	    else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = 	  }							  
      else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ]  	    else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ]  	  else if ( i == 0 ) {					  
    }							      	  }							    	    subset [ i % 2 ] [ j ] = false ;			  
  }							      	}							    	  }							  
  return subset [ n % 2 ] [ sum ] ;			      	return subset [ n % 2 ] [ sum ] ;			    	  else if ( arr [ i - 1 ] <= j ) {			  
}							      }								    	    subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j 
							      								    	  }							  
							      								    	  else {						  
							      								    	    subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j 
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return subset [ n % 2 ] [ sum ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K		      COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K		    COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K			  COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K
--							      --							    --								  --
static int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int  int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) {   int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) {	  success : None
  int dp [ ] [ ] = new int [ k ] [ n ] , sum = 0 ;	      	int dp [ k ] [ n ] , sum = 0 ;				      int dp [ k ] [ n ] , sum = 0 ;				  
  for ( int i = 0 ;					      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int i = 0 ;						  
  i < n ;						      	for ( int i = 0 ;					      i < n ;							  
  i ++ ) {						      	i < n ;							      i ++ ) dp [ 0 ] [ i ] = 1 ;				  
    dp [ 0 ] [ i ] = 1 ;				      	i ++ ) dp [ 0 ] [ i ] = 1 ;				      for ( int l = 1 ;						  
  }							      	for ( int l = 1 ;					      l < k ;							  
  for ( int l = 1 ;					      	l < k ;							      l ++ ) {							  
  l < k ;						      	l ++ ) {						    	for ( int i = l ;					  
  l ++ ) {						      	  for ( int i = l ;					    	i < n ;							  
    for ( int i = l ;					      	  i < n ;						    	i ++ ) {						  
    i < n ;						      	  i ++ ) {						    	  dp [ l ] [ i ] = 0 ;					  
    i ++ ) {						      	    dp [ l ] [ i ] = 0 ;				    	  for ( int j = l - 1 ;					  
      dp [ l ] [ i ] = 0 ;				      	    for ( int j = l - 1 ;				    	  j < i ;						  
      for ( int j = l - 1 ;				      	    j < i ;						    	  j ++ ) {						  
      j < i ;						      	    j ++ ) {						    	    if ( arr [ j ] < arr [ i ] ) dp [ l ] [ i ] += dp [ l 
      j ++ ) {						      	      if ( arr [ j ] < arr [ i ] ) dp [ l ] [ i ] += dp [ l 	  }							  
	if ( arr [ j ] < arr [ i ] ) {			      	    }							    	}							  
	  dp [ l ] [ i ] += dp [ l - 1 ] [ j ] ;	      	  }							      }								  
	}						      	}							      for ( int i = k - 1 ;					  
      }							      	for ( int i = k - 1 ;					      i < n ;							  
    }							      	i < n ;							      i ++ ) sum += dp [ k - 1 ] [ i ] ;			  
  }							      	i ++ ) sum += dp [ k - 1 ] [ i ] ;			      return sum ;						  
  for ( int i = k - 1 ;					      	return sum ;						    }								  
  i < n ;						      }								    								  
  i ++ ) {						      								    								  
    sum += dp [ k - 1 ] [ i ] ;				      								    								  
  }							      								    								  
  return sum ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K	      MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K	    MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K	  MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K
--							      --							    --								  --
static int solve ( char X [ ] , char Y [ ] , int l , int r ,  int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int solve ( char X [ ] , char Y [ ] , int l , int r , int k , script_not_found : None
  if ( k == 0 ) {					      	if ( ! k ) return 0 ;					      if ( k == 0 ) return 0 ;					  
    return 0 ;						      	if ( l < 0 | r < 0 ) return 1e9 ;			      if ( l < 0 | r < 0 ) return ( int ) 1e9 ;			  
  }							      	if ( dp [ l ] [ r ] [ k ] != - 1 ) return dp [ l ] [ r ] [    if ( dp [ l ] [ r ] [ k ] != - 1 ) return dp [ l ] [ r ] [  
  if ( l < 0 | r < 0 ) {				      	int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ;	      int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ;	  
    return ( int ) 1e9 ;				      	return dp [ l ] [ r ] [ k ] = min ( {			      return dp [ l ] [ r ] [ k ] = min ( min ( cost + solve ( X  
  }							      	  cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , sol }								  
  if ( dp [ l ] [ r ] [ k ] != - 1 ) {			      	  ) ;							    								  
    return dp [ l ] [ r ] [ k ] ;			      	}							    								  
  }							      								    								  
  int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ;	      								    								  
  return dp [ l ] [ r ] [ k ] = Math . min ( Math . min ( cos 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU
--							      --							    --								  --
static void findSmallest ( int m , int s ) {		      void findSmallest ( int m , int s ) {			    void findSmallest ( int m , int s ) {			  script_not_found : None
  if ( s == 0 ) {					      	if ( s == 0 ) {						      if ( s == 0 ) {						  
    System . out . print ( m == 1 ? "Smallest number is 0" :  	  ( m == 1 ) ? cout << "Smallest number is " << 0 : cout << 	cout << m == 1 ? "Smallest number is 0" : "Not possible"  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( s > 9 * m ) {					      	if ( s > 9 * m ) {					      if ( s > 9 * m ) {					  
    System . out . println ( "Not possible" ) ;		      	  cout << "Not possible" ;				    	cout << "Not possible" ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  int [ ] res = new int [ m ] ;				      	int res [ m ] ;						      int res [ m ] ;						  
  s -= 1 ;						      	s -= 1 ;						      s -= 1 ;							  
  for ( int i = m - 1 ;					      	for ( int i = m - 1 ;					      for ( int i = m - 1 ;					  
  i > 0 ;						      	i > 0 ;							      i > 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    if ( s > 9 ) {					      	  if ( s > 9 ) {					    	if ( s > 9 ) {						  
      res [ i ] = 9 ;					      	    res [ i ] = 9 ;					    	  res [ i ] = 9 ;					  
      s -= 9 ;						      	    s -= 9 ;						    	  s -= 9 ;						  
    }							      	  }							    	}							  
    else {						      	  else {						    	else {							  
      res [ i ] = s ;					      	    res [ i ] = s ;					    	  res [ i ] = s ;					  
      s = 0 ;						      	    s = 0 ;						    	  s = 0 ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  res [ 0 ] = s + 1 ;					      	res [ 0 ] = s + 1 ;					      res [ 0 ] = s + 1 ;					  
  System . out . print ( "Smallest number is " ) ;	      	cout << "Smallest number is " ;				      cout << "Smallest number is " ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m ;						      	i < m ;							      i < m ;							  
  i ++ ) System . out . print ( res [ i ] ) ;		      	i ++ ) cout << res [ i ] ;				      i ++ ) {							  
}							      }								    	cout << res [ i ] ;					  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1		      LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1		    LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1		  LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1
--							      --							    --								  --
static int lcsOf3 ( int i , int j , int k ) {		      int lcsOf3 ( int i , int j , int k ) {			    int lcsOf3 ( int i , int j , int k ) {			  script_not_found : None
  if ( i == - 1 || j == - 1 || k == - 1 ) {		      	if ( i == - 1 || j == - 1 || k == - 1 ) return 0 ;	      if ( i == - 1 || j == - 1 || k == - 1 ) return 0 ;	  
    return 0 ;						      	if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [    if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [  
  }							      	if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [   if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [ 
  if ( dp [ i ] [ j ] [ k ] != - 1 ) {			      	else return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i -   else return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 
    return dp [ i ] [ j ] [ k ] ;			      }								    }								  
  }							      								    								  
  if ( X . charAt ( i ) == Y . charAt ( j ) && Y . charAt ( j 								    								  
    return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1  								    								  
  }							      								    								  
  else {						      								    								  
    return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( l 								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED		      LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED		    LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED			  LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED
--							      --							    --								  --
static int longestNull ( String str ) {			      int longestNull ( string str ) {				    int longestNull ( string str ) {				  error : LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED
  ArrayList < Pair > arr = new ArrayList < > ( ) ;	      	vector < pair < char , int >> arr ;			      vector < pair < char , int >> arr ;			  .cpp: In function ‘int f_filled(std::__cxx11::stri
  arr . add ( new Pair ( '@' , - 1 ) ) ;		      	arr . push_back ( {					      arr . push_back ( make_pair ( '@' , - 1 ) ) ;		  ng)’: LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED.c
  int maxlen = 0 ;					      	  '@' , - 1 }						      int maxlen = 0 ;						  pp:48:63: error: no match for ‘operator[]’ (operan
  for ( int i = 0 ;					      	  ) ;							      for ( int i = 0 ;						  d types are ‘__gnu_cxx::__alloc_traits<std::alloca
  i < str . length ( ) ;				      	  int maxlen = 0 ;					      i < str . length ( ) ;					  tor<std::pair<char, int> >, std::pair<char, int> >
  ++ i ) {						      	  for ( int i = 0 ;					      ++ i ) {							  ::value_type’ {aka ‘std::pair<char, int>’} and ‘in
    arr . add ( new Pair ( str . charAt ( i ) , i ) ) ;	      	  i < str . length ( ) ;				    	arr . push_back ( make_pair ( str [ i ] , i ) ) ;	  t’)	   while ( arr . size ( ) >= 3 && arr [ arr
    while ( arr . size ( ) >= 3 && arr . get ( arr . size ( ) 	  ++ i ) {						    	while ( arr . size ( ) >= 3 && arr [ arr . size ( ) - 3 ] . size ( ) - 3 ] [ 0 ] == '1' && arr [ arr . size
      arr . remove ( arr . size ( ) - 3 ) ;		      	    arr . push_back ( {					    	  arr . erase ( arr . size ( ) - 3 ) ;			  ( ) - 2 ] [ 0 ] == '0' && arr [ arr . size ( ) - 1
      arr . remove ( arr . size ( ) - 2 ) ;		      	      str [ i ] , i }					    	  arr . erase ( arr . size ( ) - 2 ) ;			   ] [ 0 ] == '0' ) {
      arr . remove ( arr . size ( ) - 1 ) ;		      	      ) ;						    	  arr . erase ( arr . size ( ) - 1 ) ;			  				   ^ LENGTH_LONGEST_
    }							      	      while ( arr . size ( ) >= 3 && arr [ arr . size ( ) - 	}							  SUB_STRING_CAN_MAKE_REMOVED.cpp:48:106: error: no
    int tmp = arr . get ( arr . size ( ) - 1 ) . second ;     		arr . pop_back ( ) ;				    	int tmp = arr [ arr . size ( ) - 1 ] [ 1 ] ;		  match for ‘operator[]’ (operand types are ‘__gnu_c
    maxlen = Math . max ( maxlen , i - tmp ) ;		      		arr . pop_back ( ) ;				    	maxlen = max ( maxlen , i - tmp ) ;			  xx::__alloc_traits<std::allocator<std::pair<char,
  }							      		arr . pop_back ( ) ;				      }								  int> >, std::pair<char, int> >::value_type’ {aka ‘
  return maxlen ;					      	      }							      return maxlen ;						  std::pair<char, int>’} and ‘int’)	 while ( arr
}							      	      int tmp = arr . back ( ) . second ;		    }								   . size ( ) >= 3 && arr [ arr . size ( ) - 3 ] [ 0
							      	      maxlen = max ( maxlen , i - tmp ) ;		    								   ] == '1' && arr [ arr . size ( ) - 2 ] [ 0 ] == '
							      	    }							    								  0' && arr [ arr . size ( ) - 1 ] [ 0 ] == '0' ) {
							      	    return maxlen ;					    								  
							      	  }							    								  
							      								    								  	^ LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED
							      								    								  .cpp:48:149: error: no match for ‘operator[]’ (ope
							      								    								  rand types are ‘__gnu_cxx::__alloc_traits<std::all
							      								    								  ocator<std::pair<char, int> >, std::pair<char, int
							      								    								  > >::value_type’ {aka ‘std::pair<char, int>’} and
							      								    								  ‘int’)      while ( arr . size ( ) >= 3 && arr [ a
							      								    								  rr . size ( ) - 3 ] [ 0 ] == '1' && arr [ arr . si
							      								    								  ze ( ) - 2 ] [ 0 ] == '0' && arr [ arr . size ( )
							      								    								  - 1 ] [ 0 ] == '0' ) {
							      								    								  
							      								    								  
							      								    								  			^ LENGTH_LONGEST_SUB_STRING_
							      								    								  CAN_MAKE_REMOVED.cpp:49:40: error: no matching fun
							      								    								  ction for call to ‘std::vector<std::pair<char, int
							      								    								  > >::erase(std::vector<std::pair<char, int> >::siz
							      								    								  e_type)’	  arr . erase ( arr . size ( ) - 3 )
							      								    								   ;					     ^ In fi
							      								    								  le included from /usr/include/c++/8/vector:64,
							      								    								  		from LENGTH_LONGEST_SUB_STRING_CAN_M
							      								    								  AKE_REMOVED.cpp:11: /usr/include/c++/8/bits/stl_ve
							      								    								  ctor.h:1317:7: note: candidate: ‘std::vector<_Tp,
							      								    								  _Alloc>::iterator std::vector<_Tp, _Alloc>::erase(
							      								    								  std::vector<_Tp, _Alloc>::const_iterator) [with _T
							      								    								  p = std::pair<char, int>; _Alloc = std::allocator<
							      								    								  std::pair<char, int> >; std::vector<_Tp, _Alloc>::
							      								    								  iterator = __gnu_cxx::__normal_iterator<std::pair<
							      								    								  char, int>*, std::vector<std::pair<char, int> > >;
							      								    								   typename std::_Vector_base<_Tp, _Alloc>::pointer
							      								    								  = std::pair<char, int>*; std::vector<_Tp, _Alloc>:
							      								    								  :const_iterator = __gnu_cxx::__normal_iterator<con
							      								    								  st std::pair<char, int>*, std::vector<std::pair<ch
							      								    								  ar, int> > >; typename __gnu_cxx::__alloc_traits<t
							      								    								  ypename std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_
							      								    								  type>::const_pointer = const std::pair<char, int>*
							      								    								  ]’	    erase(const_iterator __position)
							      								    								  ^~~~~ /usr/include/c++/8/bits/stl_vector.h:1317:7:
							      								    								   note:   no known conversion for argument 1 from ‘
							      								    								  std::vector<std::pair<char, int> >::size_type’ {ak
							      								    								  a ‘long unsigned int’} to ‘std::vector<std::pair<c
							      								    								  har, int> >::const_iterator’ {aka ‘__gnu_cxx::__no
							      								    								  rmal_iterator<const std::pair<char, int>*, std::ve
							      								    								  ctor<std::pair<char, int> > >’} /usr/include/c++/8
							      								    								  /bits/stl_vector.h:1344:7: note: candidate: ‘std::
							      								    								  vector<_Tp, _Alloc>::iterator std::vector<_Tp, _Al
							      								    								  loc>::erase(std::vector<_Tp, _Alloc>::const_iterat
							      								    								  or, std::vector<_Tp, _Alloc>::const_iterator) [wit
							      								    								  h _Tp = std::pair<char, int>; _Alloc = std::alloca
							      								    								  tor<std::pair<char, int> >; std::vector<_Tp, _Allo
							      								    								  c>::iterator = __gnu_cxx::__normal_iterator<std::p
							      								    								  air<char, int>*, std::vector<std::pair<char, int>
							      								    								  > >; typename std::_Vector_base<_Tp, _Alloc>::poin
							      								    								  ter = std::pair<char, int>*; std::vector<_Tp, _All
							      								    								  oc>::const_iterator = __gnu_cxx::__normal_iterator
							      								    								  <const std::pair<char, int>*, std::vector<std::pai
							      								    								  r<char, int> > >; typename __gnu_cxx::__alloc_trai
							      								    								  ts<typename std::_Vector_base<_Tp, _Alloc>::_Tp_al
							      								    								  loc_type>::const_pointer = const std::pair<char, i
							      								    								  nt>*]’	erase(const_iterator __first, const_
							      								    								  iterator __last)	  ^~~~~ /usr/include/c++/8/b
							      								    								  its/stl_vector.h:1344:7: note:   candidate expects
							      								    								   2 arguments, 1 provided LENGTH_LONGEST_SUB_STRING
							      								    								  _CAN_MAKE_REMOVED.cpp:50:40: error: no matching fu
							      								    								  nction for call to ‘std::vector<std::pair<char, in
							      								    								  t> >::erase(std::vector<std::pair<char, int> >::si
							      								    								  ze_type)’	   arr . erase ( arr . size ( ) - 2
							      								    								  ) ;					      ^ In f
							      								    								  ile included from /usr/include/c++/8/vector:64,
							      								    								  		 from LENGTH_LONGEST_SUB_STRING_CAN_
							      								    								  MAKE_REMOVED.cpp:11: /usr/include/c++/8/bits/stl_v
							      								    								  ector.h:1317:7: note: candidate: ‘std::vector<_Tp,
							      								    								   _Alloc>::iterator std::vector<_Tp, _Alloc>::erase
							      								    								  (std::vector<_Tp, _Alloc>::const_iterator) [with _
							      								    								  Tp = std::pair<char, int>; _Alloc = std::allocator
							      								    								  <std::pair<char, int> >; std::vector<_Tp, _Alloc>:
							      								    								  :iterator = __gnu_cxx::__normal_iterator<std::pair
							      								    								  <char, int>*, std::vector<std::pair<char, int> > >
							      								    								  ; typename std::_Vector_base<_Tp, _Alloc>::pointer
							      								    								   = std::pair<char, int>*; std::vector<_Tp, _Alloc>
							      								    								  ::const_iterator = __gnu_cxx::__normal_iterator<co
							      								    								  nst std::pair<char, int>*, std::vector<std::pair<c
							      								    								  har, int> > >; typename __gnu_cxx::__alloc_traits<
							      								    								  typename std::_Vector_base<_Tp, _Alloc>::_Tp_alloc
							      								    								  _type>::const_pointer = const std::pair<char, int>
							      								    								  *]’	     erase(const_iterator __position)
							      								    								   ^~~~~ /usr/include/c++/8/bits/stl_vector.h:1317:7
							      								    								  : note:   no known conversion for argument 1 from
							      								    								  ‘std::vector<std::pair<char, int> >::size_type’ {a
							      								    								  ka ‘long unsigned int’} to ‘std::vector<std::pair<
							      								    								  char, int> >::const_iterator’ {aka ‘__gnu_cxx::__n
							      								    								  ormal_iterator<const std::pair<char, int>*, std::v
							      								    								  ector<std::pair<char, int> > >’} /usr/include/c++/
							      								    								  8/bits/stl_vector.h:1344:7: note: candidate: ‘std:
							      								    								  :vector<_Tp, _Alloc>::iterator std::vector<_Tp, _A
							      								    								  lloc>::erase(std::vector<_Tp, _Alloc>::const_itera
							      								    								  tor, std::vector<_Tp, _Alloc>::const_iterator) [wi
							      								    								  th _Tp = std::pair<char, int>; _Alloc = std::alloc
							      								    								  ator<std::pair<char, int> >; std::vector<_Tp, _All
							      								    								  oc>::iterator = __gnu_cxx::__normal_iterator<std::
							      								    								  pair<char, int>*, std::vector<std::pair<char, int>
							      								    								   > >; typename std::_Vector_base<_Tp, _Alloc>::poi
							      								    								  nter = std::pair<char, int>*; std::vector<_Tp, _Al
							      								    								  loc>::const_iterator = __gnu_cxx::__normal_iterato
							      								    								  r<const std::pair<char, int>*, std::vector<std::pa
							      								    								  ir<char, int> > >; typename __gnu_cxx::__alloc_tra
							      								    								  its<typename std::_Vector_base<_Tp, _Alloc>::_Tp_a
							      								    								  lloc_type>::const_pointer = const std::pair<char,
							      								    								  int>*]’	 erase(const_iterator __first, const
							      								    								  _iterator __last)	   ^~~~~ /usr/include/c++/8/
							      								    								  bits/stl_vector.h:1344:7: note:   candidate expect
							      								    								  s 2 arguments, 1 provided LENGTH_LONGEST_SUB_STRIN
							      								    								  G_CAN_MAKE_REMOVED.cpp:51:40: error: no matching f
							      								    								  unction for call to ‘std::vector<std::pair<char, i
							      								    								  nt> >::erase(std::vector<std::pair<char, int> >::s
							      								    								  ize_type)’	    arr . erase ( arr . size ( ) - 1
							      								    								   ) ;					       ^ In
							      								    								  file included from /usr/include/c++/8/vector:64,
							      								    								  		  from LENGTH_LONGEST_SUB_STRING_CAN
							      								    								  _MAKE_REMOVED.cpp:11: /usr/include/c++/8/bits/stl_
							      								    								  vector.h:1317:7: note: candidate: ‘std::vector<_Tp
							      								    								  , _Alloc>::iterator std::vector<_Tp, _Alloc>::eras
							      								    								  e(std::vector<_Tp, _Alloc>::const_iterator) [with
							      								    								  _Tp = std::pair<char, int>; _Alloc = std::allocato
							      								    								  r<std::pair<char, int> >; std::vector<_Tp, _Alloc>
							      								    								  ::iterator = __gnu_cxx::__normal_iterator<std::pai
							      								    								  r<char, int>*, std::vector<std::pair<char, int> >
							      								    								  >; typename std::_Vector_base<_Tp, _Alloc>::pointe
							      								    								  r = std::pair<char, int>*; std::vector<_Tp, _Alloc
							      								    								  >::const_iterator = __gnu_cxx::__normal_iterator<c
							      								    								  onst std::pair<char, int>*, std::vector<std::pair<
							      								    								  char, int> > >; typename __gnu_cxx::__alloc_traits
							      								    								  <typename std::_Vector_base<_Tp, _Alloc>::_Tp_allo
							      								    								  c_type>::const_pointer = const std::pair<char, int
							      								    								  >*]’	      erase(const_iterator __position)
							      								    								    ^~~~~ /usr/include/c++/8/bits/stl_vector.h:1317:
							      								    								  7: note:   no known conversion for argument 1 from
							      								    								   ‘std::vector<std::pair<char, int> >::size_type’ {
							      								    								  aka ‘long unsigned int’} to ‘std::vector<std::pair
							      								    								  <char, int> >::const_iterator’ {aka ‘__gnu_cxx::__
							      								    								  normal_iterator<const std::pair<char, int>*, std::
							      								    								  vector<std::pair<char, int> > >’} /usr/include/c++
							      								    								  /8/bits/stl_vector.h:1344:7: note: candidate: ‘std
							      								    								  ::vector<_Tp, _Alloc>::iterator std::vector<_Tp, _
							      								    								  Alloc>::erase(std::vector<_Tp, _Alloc>::const_iter
							      								    								  ator, std::vector<_Tp, _Alloc>::const_iterator) [w
							      								    								  ith _Tp = std::pair<char, int>; _Alloc = std::allo
							      								    								  cator<std::pair<char, int> >; std::vector<_Tp, _Al
							      								    								  loc>::iterator = __gnu_cxx::__normal_iterator<std:
							      								    								  :pair<char, int>*, std::vector<std::pair<char, int
							      								    								  > > >; typename std::_Vector_base<_Tp, _Alloc>::po
							      								    								  inter = std::pair<char, int>*; std::vector<_Tp, _A
							      								    								  lloc>::const_iterator = __gnu_cxx::__normal_iterat
							      								    								  or<const std::pair<char, int>*, std::vector<std::p
							      								    								  air<char, int> > >; typename __gnu_cxx::__alloc_tr
							      								    								  aits<typename std::_Vector_base<_Tp, _Alloc>::_Tp_
							      								    								  alloc_type>::const_pointer = const std::pair<char,
							      								    								   int>*]’	  erase(const_iterator __first, cons
							      								    								  t_iterator __last)	    ^~~~~ /usr/include/c++/8
							      								    								  /bits/stl_vector.h:1344:7: note:   candidate expec
							      								    								  ts 2 arguments, 1 provided LENGTH_LONGEST_SUB_STRI
							      								    								  NG_CAN_MAKE_REMOVED.cpp:53:42: error: no match for
							      								    								   ‘operator[]’ (operand types are ‘__gnu_cxx::__all
							      								    								  oc_traits<std::allocator<std::pair<char, int> >, s
							      								    								  td::pair<char, int> >::value_type’ {aka ‘std::pair
							      								    								  <char, int>’} and ‘int’)	int tmp = arr [ arr
							      								    								  . size ( ) - 1 ] [ 1 ] ;
							      								    								  		   ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1		      DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1			    DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1			  DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1
--							      --							    --								  --
static boolean isSubsetSum ( int set [ ] , int n , int sum )  bool isSubsetSum ( int set [ ] , int n , int sum ) {	    bool isSubsetSum ( int set [ ] , int n , int sum ) {	  success : None
  boolean subset [ ] [ ] = new boolean [ sum + 1 ] [ n + 1 ]  	bool subset [ n + 1 ] [ sum + 1 ] ;			      bool subset [ sum + 1 ] [ n + 1 ] ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) subset [ 0 ] [ i ] = true ;			      	i ++ ) subset [ i ] [ 0 ] = true ;			      i ++ ) {							  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	subset [ 0 ] [ i ] = true ;				  
  i <= sum ;						      	i <= sum ;						      }								  
  i ++ ) subset [ i ] [ 0 ] = false ;			      	i ++ ) subset [ 0 ] [ i ] = false ;			      for ( int i = 1 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      i <= sum ;						  
  i <= sum ;						      	i <= n ;						      i ++ ) {							  
  i ++ ) {						      	i ++ ) {						    	subset [ i ] [ 0 ] = false ;				  
    for ( int j = 1 ;					      	  for ( int j = 1 ;					      }								  
    j <= n ;						      	  j <= sum ;						      for ( int i = 1 ;						  
    j ++ ) {						      	  j ++ ) {						      i <= sum ;						  
      subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ;	      	    if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [    i ++ ) {							  
      if ( i >= set [ j - 1 ] ) subset [ i ] [ j ] = subset [ 	    if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ 	for ( int j = 1 ;					  
    }							      	  }							    	j <= n ;						  
  }							      	}							    	j ++ ) {						  
  return subset [ sum ] [ n ] ;				      	return subset [ n ] [ sum ] ;				    	  subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ;		  
}							      }								    	  if ( i >= set [ j - 1 ] ) {				  
							      								    	    subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i 
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return subset [ sum ] [ n ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1		      DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1			    DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1			  DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1
--							      --							    --								  --
static int editDistDP ( String str1 , String str2 , int m , i int editDistDP ( string str1 , string str2 , int m , int n )  int editDistDP ( string str1 , string str2 , int m , int n )  script_not_found : None
  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	int dp [ m + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( m + 1 , vector < int > ( n +  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= m ;						      	i <= m ;						      i <= m ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= n ;						      	  j <= n ;						    	j <= n ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( i == 0 ) dp [ i ] [ j ] = j ;		      	    if ( i == 0 ) dp [ i ] [ j ] = j ;			    	  if ( i == 0 ) {					  
      else if ( j == 0 ) dp [ i ] [ j ] = i ;		      	    else if ( j == 0 ) dp [ i ] [ j ] = i ;		    	    dp [ i ] [ j ] = j ;				  
      else if ( str1 . charAt ( i - 1 ) == str2 . charAt ( j  	    else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ 	  }							  
      else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp 	    else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp 	  else if ( j == 0 ) {					  
    }							      	  }							    	    dp [ i ] [ j ] = i ;				  
  }							      	}							    	  }							  
  return dp [ m ] [ n ] ;				      	return dp [ m ] [ n ] ;					    	  else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) {	  
}							      }								    	    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;		  
							      								    	  }							  
							      								    	  else {						  
							      								    	    dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp [  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return dp [ m ] [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP
--							      --							    --								  --
static void spiralFill ( int m , int n , int a [ ] [ ] ) {    void spiralFill ( int m , int n , int a [ ] [ MAX ] ) {	    void spiralFill ( int m , int n , int a [ ] [ 2 ] ) {	  script_not_found : None
  int val = 1 ;						      	int val = 1 ;						      int val = 1 ;						  
  int k = 0 , l = 0 ;					      	int k = 0 , l = 0 ;					      int k = 0 , l = 0 ;					  
  while ( k < m && l < n ) {				      	while ( k < m && l < n ) {				      while ( k < m && l < n ) {				  
    for ( int i = l ;					      	  for ( int i = l ;					    	for ( int i = l ;					  
    i < n ;						      	  i < n ;						    	i < n ;							  
    ++ i ) {						      	  ++ i ) a [ k ] [ i ] = val ++ ;			    	++ i ) a [ k ] [ i ] = val ++ ;				  
      a [ k ] [ i ] = val ++ ;				      	  k ++ ;						    	k ++ ;							  
    }							      	  for ( int i = k ;					    	for ( int i = k ;					  
    k ++ ;						      	  i < m ;						    	i < m ;							  
    for ( int i = k ;					      	  ++ i ) a [ i ] [ n - 1 ] = val ++ ;			    	++ i ) a [ i ] [ n - 1 ] = val ++ ;			  
    i < m ;						      	  n -- ;						    	n -- ;							  
    ++ i ) {						      	  if ( k < m ) {					    	if ( k < m ) {						  
      a [ i ] [ n - 1 ] = val ++ ;			      	    for ( int i = n - 1 ;				    	  for ( int i = n - 1 ;					  
    }							      	    i >= l ;						    	  i >= l ;						  
    n -- ;						      	    -- i ) a [ m - 1 ] [ i ] = val ++ ;			    	  -- i ) a [ m - 1 ] [ i ] = val ++ ;			  
    if ( k < m ) {					      	    m -- ;						    	  m -- ;						  
      for ( int i = n - 1 ;				      	  }							    	}							  
      i >= l ;						      	  if ( l < n ) {					    	if ( l < n ) {						  
      -- i ) {						      	    for ( int i = m - 1 ;				    	  for ( int i = m - 1 ;					  
	a [ m - 1 ] [ i ] = val ++ ;			      	    i >= k ;						    	  i >= k ;						  
      }							      	    -- i ) a [ i ] [ l ] = val ++ ;			    	  -- i ) a [ i ] [ l ] = val ++ ;			  
      m -- ;						      	    l ++ ;						    	  l ++ ;						  
    }							      	  }							    	}							  
    if ( l < n ) {					      	}							      }								  
      for ( int i = m - 1 ;				      }								    }								  
      i >= k ;						      								    								  
      -- i ) {						      								    								  
	a [ i ] [ l ] = val ++ ;			      								    								  
      }							      								    								  
      l ++ ;						      								    								  
    }							      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_ GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_ GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_ GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_
--							      --							    --								  --
void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n void print_closest ( int ar1 [ ] , int ar2 [ ] , int m , int  script_not_found : None
  int diff = Integer . MAX_VALUE ;			      	int diff = INT_MAX ;					      int diff = INT_MAX ;					  
  int res_l = 0 , res_r = 0 ;				      	int res_l , res_r ;					      int res_l = 0 , res_r = 0 ;				  
  int l = 0 , r = n - 1 ;				      	int l = 0 , r = n - 1 ;					      int l = 0 , r = n - 1 ;					  
  while ( l < m && r >= 0 ) {				      	while ( l < m && r >= 0 ) {				      while ( l < m && r >= 0 ) {				  
    if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) {  	  if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) {	    	if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) {	  
      res_l = l ;					      	    res_l = l ;						    	  res_l = l ;						  
      res_r = r ;					      	    res_r = r ;						    	  res_r = r ;						  
      diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ;	      	    diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) ;		    	  diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) ;		  
    }							      	  }							    	}							  
    if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ;		      	  if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ;		    	if ( ar1 [ l ] + ar2 [ r ] > x ) {			  
    else l ++ ;						      	  else l ++ ;						    	  r -- ;						  
  }							      	}							    	}							  
  System . out . print ( "The closest pair is [" + ar1 [ res_ 	cout << "The closest pair is [" << ar1 [ res_l ] << ", " << 	else {							  
}							      }								    	  l ++ ;						  
							      								    	}							  
							      								      }								  
							      								      cout << "The closest pair is [" << ar1 [ res_l ] << ", " << 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1	  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1
--							      --							    --								  --
static int findLength ( String str ) {			      int findLength ( char * str ) {				    int findLength ( string str ) {				  script_not_found : None
  int n = str . length ( ) ;				      	int n = strlen ( str ) ;				      int n = str . length ( ) ;				  
  int maxlen = 0 ;					      	int maxlen = 0 ;					      int maxlen = 0 ;						  
  int sum [ ] [ ] = new int [ n ] [ n ] ;		      	int sum [ n ] [ n ] ;					      int sum [ n ] [ n ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) sum [ i ] [ i ] = str . charAt ( i ) - '0' ;	      	i ++ ) sum [ i ] [ i ] = str [ i ] - '0' ;		      i ++ ) {							  
  for ( int len = 2 ;					      	for ( int len = 2 ;					    	sum [ i ] [ i ] = str [ i ] - '0' ;			  
  len <= n ;						      	len <= n ;						      }								  
  len ++ ) {						      	len ++ ) {						      for ( int len = 2 ;					  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					      len <= n ;						  
    i < n - len + 1 ;					      	  i < n - len + 1 ;					      len ++ ) {						  
    i ++ ) {						      	  i ++ ) {						    	for ( int i = 0 ;					  
      int j = i + len - 1 ;				      	    int j = i + len - 1 ;				    	i < n - len + 1 ;					  
      int k = len / 2 ;					      	    int k = len / 2 ;					    	i ++ ) {						  
      sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 	    sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 	  int j = i + len - 1 ;					  
      if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - 	    if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - 	  int k = len / 2 ;					  
    }							      	  }							    	  sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 
  }							      	}							    	  if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - 
  return maxlen ;					      	return maxlen ;						    	    maxlen = len ;					  
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return maxlen ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY			      K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY			    K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY			  K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY
--							      --							    --								  --
static int kthLargestSum ( int arr [ ] , int n , int k ) {    int kthLargestSum ( int arr [ ] , int n , int k ) {	    int kthLargestSum ( int arr [ ] , int n , int k ) {		  success : None
  int sum [ ] = new int [ n + 1 ] ;			      	int sum [ n + 1 ] ;					      int sum [ n + 1 ] ;					  
  sum [ 0 ] = 0 ;					      	sum [ 0 ] = 0 ;						      sum [ 0 ] = 0 ;						  
  sum [ 1 ] = arr [ 0 ] ;				      	sum [ 1 ] = arr [ 0 ] ;					      sum [ 1 ] = arr [ 0 ] ;					  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ;	      	i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ;	      i ++ ) {							  
  PriorityQueue < Integer > Q = new PriorityQueue < Integer > 	priority_queue < int , vector < int > , greater < int >> Q  	sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ;		  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      }								  
  i <= n ;						      	i <= n ;						      priority_queue < int , vector < int > , greater < int >> Q  
  i ++ ) {						      	i ++ ) {						      for ( int i = 1 ;						  
    for ( int j = i ;					      	  for ( int j = i ;					      i <= n ;							  
    j <= n ;						      	  j <= n ;						      i ++ ) {							  
    j ++ ) {						      	  j ++ ) {						    	for ( int j = i ;					  
      int x = sum [ j ] - sum [ i - 1 ] ;		      	    int x = sum [ j ] - sum [ i - 1 ] ;			    	j <= n ;						  
      if ( Q . size ( ) < k ) Q . add ( x ) ;		      	    if ( Q . size ( ) < k ) Q . push ( x ) ;		    	j ++ ) {						  
      else {						      	    else {						    	  int x = sum [ j ] - sum [ i - 1 ] ;			  
	if ( Q . peek ( ) < x ) {			      	      if ( Q . top ( ) < x ) {				    	  if ( Q . size ( ) < k ) {				  
	  Q . poll ( ) ;				      		Q . pop ( ) ;					    	    Q . push ( x ) ;					  
	  Q . add ( x ) ;				      		Q . push ( x ) ;				    	  }							  
	}						      	      }							    	  else {						  
      }							      	    }							    	    if ( Q . top ( ) < x ) {				  
    }							      	  }							    	      Q . pop ( ) ;					  
  }							      	}							    	      Q . push ( x ) ;					  
  return Q . poll ( ) ;					      	return Q . top ( ) ;					    	    }							  
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return Q . top ( ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBARRAY_SUM_DIVISIBLE_K			      LONGEST_SUBARRAY_SUM_DIVISIBLE_K				    LONGEST_SUBARRAY_SUM_DIVISIBLE_K				  LONGEST_SUBARRAY_SUM_DIVISIBLE_K
--							      --							    --								  --
static int longSubarrWthSumDivByK ( int arr [ ] , int n , int int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) {  int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) {  success : None
  HashMap < Integer , Integer > um = new HashMap < Integer ,  	unordered_map < int , int > um ;			      unordered_map < int , int > um ;				  
  int mod_arr [ ] = new int [ n ] ;			      	int mod_arr [ n ] , max = 0 ;				      int mod_arr [ n ] ;					  
  int max = 0 ;						      	int curr_sum = 0 ;					      int max = 0 ;						  
  int curr_sum = 0 ;					      	for ( int i = 0 ;					      int curr_sum = 0 ;					  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) {						      i < n ;							  
  i ++ ) {						      	  curr_sum += arr [ i ] ;				      i ++ ) {							  
    curr_sum += arr [ i ] ;				      	  mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ;	    	curr_sum += arr [ i ] ;					  
    mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ;	      	}							    	mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ;		  
  }							      	for ( int i = 0 ;					      }								  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) {						      i < n ;							  
  i ++ ) {						      	  if ( mod_arr [ i ] == 0 ) max = i + 1 ;		      i ++ ) {							  
    if ( mod_arr [ i ] == 0 ) max = i + 1 ;		      	  else if ( um . find ( mod_arr [ i ] ) == um . end ( ) ) u 	if ( mod_arr [ i ] == 0 ) {				  
    else if ( um . containsKey ( mod_arr [ i ] ) == false ) u 	  else if ( max < ( i - um [ mod_arr [ i ] ] ) ) max = i -  	  max = i + 1 ;						  
    else if ( max < ( i - um . get ( mod_arr [ i ] ) ) ) max  	}							    	}							  
  }							      	return max ;						    	else if ( um . find ( mod_arr [ i ] ) == um . end ( ) ) { 
  return max ;						      }								    	  um [ mod_arr [ i ] ] = i ;				  
}							      								    	}							  
							      								    	else if ( max < ( i - um [ mod_arr [ i ] ] ) ) {	  
							      								    	  max = i - um [ mod_arr [ i ] ] ;			  
							      								    	}							  
							      								      }								  
							      								      return max ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_POSSIBLE_PATH_2D_MATRIX				      CHECK_POSSIBLE_PATH_2D_MATRIX				    CHECK_POSSIBLE_PATH_2D_MATRIX				  CHECK_POSSIBLE_PATH_2D_MATRIX
--							      --							    --								  --
static boolean isPath ( int arr [ ] [ ] ) {		      bool isPath ( int arr [ row ] [ col ] ) {			    bool isPath ( int arr [ ] [ 5 ] ) {				  script_not_found : None
  arr [ 0 ] [ 0 ] = 1 ;					      	arr [ 0 ] [ 0 ] = 1 ;					      arr [ 0 ] [ 0 ] = 1 ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < 5 ;						      	i < row ;						      i < 5 ;							  
  i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr  	i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr    i ++ ) if ( arr [ 0 ] [ i ] != - 1 ) arr [ 0 ] [ i ] = arr  
  for ( int j = 1 ;					      	for ( int j = 1 ;					      for ( int j = 1 ;						  
  j < 5 ;						      	j < col ;						      j < 5 ;							  
  j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr  	j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr    j ++ ) if ( arr [ j ] [ 0 ] != - 1 ) arr [ j ] [ 0 ] = arr  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < 5 ;						      	i < row ;						      i < 5 ;							  
  i ++ ) for ( int j = 1 ;				      	i ++ ) for ( int j = 1 ;				      i ++ ) for ( int j = 1 ;					  
  j < 5 ;						      	j < col ;						      j < 5 ;							  
  j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math 	j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = max    j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = max  
  return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ;		      	return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ;		      return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN
--							      --							    --								  --
static int countWords ( String str , int len ) {	      int countWords ( char str [ ] , int len ) {		    int countWords ( string str , int len ) {			  error : /bin/bash: line 1: 3926823 Aborted
  int count = 1 ;					      	int count = 1 ;						      int count = 1 ;						  	   (core dumped) ./COUNT_WORDS_WHOSE_TH_LETT
  if ( len == 1 ) return count ;			      	if ( len == 1 ) return count ;				      if ( len == 1 ) return count ;				  ER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD_cpp
  if ( str . charAt ( 0 ) == str . charAt ( 1 ) ) count *= 1  	if ( str [ 0 ] == str [ 1 ] ) count *= 1 ;		      if ( str [ 0 ] == str [ 1 ] ) {				  
  else count *= 2 ;					      	else count *= 2 ;					    	count *= 1 ;						  
  for ( int j = 1 ;					      	for ( int j = 1 ;					      }								  
  j < len - 1 ;						      	j < len - 1 ;						      else {							  
  j ++ ) {						      	j ++ ) {						    	count *= 2 ;						  
    if ( str . charAt ( j ) == str . charAt ( j - 1 ) && str  	  if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j +   }								  
    else if ( str . charAt ( j ) == str . charAt ( j - 1 ) || 	  else if ( str [ j ] == str [ j - 1 ] || str [ j ] == str    for ( int j = 1 ;						  
    else count *= 3 ;					      	  else count *= 3 ;					      j < len - 1 ;						  
  }							      	}							      j ++ ) {							  
  if ( str . charAt ( len - 1 ) == str . charAt ( len - 2 ) ) 	if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ;	    	if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 
  else count *= 2 ;					      	else count *= 2 ;					    	  count *= 1 ;						  
  return count ;					      	return count ;						    	}							  
}							      }								    	else if ( str [ j ] == str [ j - 1 ] || str [ j ] == str  
							      								    	  count *= 2 ;						  
							      								    	}							  
							      								    	else {							  
							      								    	  count *= 3 ;						  
							      								    	}							  
							      								      }								  
							      								      if ( str [ len - 1 ] == str [ len - 2 ] ) {		  
							      								    	count *= 1 ;						  
							      								      }								  
							      								      else {							  
							      								    	count *= 2 ;						  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH
--							      --							    --								  --
static int pairsInSortedRotated ( int arr [ ] , int n , int x int pairsInSortedRotated ( int arr [ ] , int n , int x ) {    int pairsInSortedRotated ( int arr [ ] , int n , int x ) {	  success : None
  int i ;						      	int i ;							      int i ;							  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						  
  i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ;	      	i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ;		      i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ;		  
  int l = ( i + 1 ) % n ;				      	int l = ( i + 1 ) % n ;					      int l = ( i + 1 ) % n ;					  
  int r = i ;						      	int r = i ;						      int r = i ;						  
  int cnt = 0 ;						      	int cnt = 0 ;						      int cnt = 0 ;						  
  while ( l != r ) {					      	while ( l != r ) {					      while ( l != r ) {					  
    if ( arr [ l ] + arr [ r ] == x ) {			      	  if ( arr [ l ] + arr [ r ] == x ) {			    	if ( arr [ l ] + arr [ r ] == x ) {			  
      cnt ++ ;						      	    cnt ++ ;						    	  cnt ++ ;						  
      if ( l == ( r - 1 + n ) % n ) {			      	    if ( l == ( r - 1 + n ) % n ) {			    	  if ( l == ( r - 1 + n ) % n ) return cnt ;		  
	return cnt ;					      	      return cnt ;					    	  l = ( l + 1 ) % n ;					  
      }							      	    }							    	  r = ( r - 1 + n ) % n ;				  
      l = ( l + 1 ) % n ;				      	    l = ( l + 1 ) % n ;					    	}							  
      r = ( r - 1 + n ) % n ;				      	    r = ( r - 1 + n ) % n ;				    	else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; 
    }							      	  }							    	else r = ( n + r - 1 ) % n ;				  
    else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; 	  else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ;   }								  
    else r = ( n + r - 1 ) % n ;			      	  else r = ( n + r - 1 ) % n ;				      return cnt ;						  
  }							      	}							    }								  
  return cnt ;						      	return cnt ;						    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR
--							      --							    --								  --
static void bitonicGenerator ( int arr [ ] , int n ) {	      void bitonicGenerator ( int arr [ ] , int n ) {		    void bitonicGenerator ( int arr [ ] , int n ) {		  failure : #Results: 1, 10
  Vector < Integer > evenArr = new Vector < Integer > ( ) ;   	vector < int > evenArr ;				      vector < int > evenArr ;					  
  Vector < Integer > oddArr = new Vector < Integer > ( ) ;    	vector < int > oddArr ;					      vector < int > oddArr ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( i % 2 != 1 ) {					      	  if ( ! ( i % 2 ) ) evenArr . push_back ( arr [ i ] ) ;    	if ( i % 2 != 1 ) evenArr . push_back ( arr [ i ] ) ;	  
      evenArr . add ( arr [ i ] ) ;			      	  else oddArr . push_back ( arr [ i ] ) ;		    	else oddArr . push_back ( arr [ i ] ) ;			  
    }							      	}							      }								  
    else {						      	sort ( evenArr . begin ( ) , evenArr . end ( ) ) ;	      sort ( evenArr . begin ( ) , evenArr . end ( ) ) ;	  
      oddArr . add ( arr [ i ] ) ;			      	sort ( oddArr . begin ( ) , oddArr . end ( ) , greater < in   sort ( oddArr . begin ( ) , oddArr . end ( ) ) ;		  
    }							      	int i = 0 ;						      int i = 0 ;						  
  }							      	for ( int j = 0 ;					      for ( int j = 0 ;						  
  Collections . sort ( evenArr ) ;			      	j < evenArr . size ( ) ;				      j < evenArr . size ( ) ;					  
  Collections . sort ( oddArr , Collections . reverseOrder (  	j ++ ) arr [ i ++ ] = evenArr [ j ] ;			      j ++ ) arr [ i ++ ] = evenArr [ j ] ;			  
  int i = 0 ;						      	for ( int j = 0 ;					      for ( int j = 0 ;						  
  for ( int j = 0 ;					      	j < oddArr . size ( ) ;					      j < oddArr . size ( ) ;					  
  j < evenArr . size ( ) ;				      	j ++ ) arr [ i ++ ] = oddArr [ j ] ;			      j ++ ) arr [ i ++ ] = oddArr [ j ] ;			  
  j ++ ) {						      }								    }								  
    arr [ i ++ ] = evenArr . get ( j ) ;		      								    								  
  }							      								    								  
  for ( int j = 0 ;					      								    								  
  j < oddArr . size ( ) ;				      								    								  
  j ++ ) {						      								    								  
    arr [ i ++ ] = oddArr . get ( j ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_CORRELATION_COEFFICIENT			      PROGRAM_FIND_CORRELATION_COEFFICIENT			    PROGRAM_FIND_CORRELATION_COEFFICIENT			  PROGRAM_FIND_CORRELATION_COEFFICIENT
--							      --							    --								  --
static float correlationCoefficient ( int X [ ] , int Y [ ] , float correlationCoefficient ( int X [ ] , int Y [ ] , int n  float correlationCoefficient ( int X [ ] , int Y [ ] , int n  script_not_found : None
  int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ;		      	int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ;		      int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ;			  
  int squareSum_X = 0 , squareSum_Y = 0 ;		      	int squareSum_X = 0 , squareSum_Y = 0 ;			      int square_sum_X = 0 , square_sum_Y = 0 ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    sum_X = sum_X + X [ i ] ;				      	  sum_X = sum_X + X [ i ] ;				    	sum_X = sum_X + X [ i ] ;				  
    sum_Y = sum_Y + Y [ i ] ;				      	  sum_Y = sum_Y + Y [ i ] ;				    	sum_Y = sum_Y + Y [ i ] ;				  
    sum_XY = sum_XY + X [ i ] * Y [ i ] ;		      	  sum_XY = sum_XY + X [ i ] * Y [ i ] ;			    	sum_XY = sum_XY + X [ i ] * Y [ i ] ;			  
    squareSum_X = squareSum_X + X [ i ] * X [ i ] ;	      	  squareSum_X = squareSum_X + X [ i ] * X [ i ] ;	    	square_sum_X = square_sum_X + X [ i ] * X [ i ] ;	  
    squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ;	      	  squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ;	    	square_sum_Y = square_sum_Y + Y [ i ] * Y [ i ] ;	  
  }							      	}							      }								  
  float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( f 	float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / sqr   float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( f 
  return corr ;						      	return corr ;						      return corr ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS	      CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS	    CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS		  CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS
--							      --							    --								  --
public static boolean check ( String s ) {		      bool check ( string s ) {					    bool check ( string s ) {					  error : CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT
  if ( s . length ( ) >= 10 ) return true ;		      	if ( s . size ( ) >= 10 ) return true ;			      if ( s . length ( ) >= 10 ) return true ;			  _STRINGS.cpp: In function ‘bool f_filled(std::__cx
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  x11::string)’: CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_D
  i < s . length ( ) ;					      	i < s . size ( ) ;					      i < s . length ( ) ;					  ISTINCT_STRINGS.cpp:57:17: error: ‘StringIndexOutO
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  fBoundsException’ does not name a type	  ca
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  tch ( StringIndexOutOfBoundsException & ) {
    j < s . length ( ) ;				      	  j < s . size ( ) ;					    	j < s . length ( ) ;					  	     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CHECK_G
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  IVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS.cpp:59
      for ( int k = j + 1 ;				      	    for ( int k = j + 1 ;				    	  for ( int k = j + 1 ;					  :14: error: ‘strf_filled’ was not declared in this
      k < s . length ( ) ;				      	    k < s . size ( ) ;					    	  k < s . length ( ) ;					   scope	  if ( strf_filled ( s1 , s2 ) && st
      k ++ ) {						      	    k ++ ) {						    	  k ++ ) {						  rf_filled ( s1 , s3 ) && strf_filled ( s1 , s4 ) &
	String s1 = "" , s2 = "" , s3 = "" , s4 = "" ;	      	      string s1 = s . substr ( 0 , i ) ;		    	    string s1 , s2 , s3 , s4 ;				  & strf_filled ( s2 , s3 ) && strf_filled ( s2 , s4
	try {						      	      string s2 = s . substr ( i , j - i ) ;		    	    try {						   ) && strf_filled ( s3 , s4 ) ) return true ;
	  s1 = s . substring ( 0 , i ) ;		      	      string s3 = s . substr ( j , k - j ) ;		    	      s1 = s . substr ( 0 , i ) ;			  	    ^~~~~~~~~~~ CHECK_GIVEN_STRING_CAN_SPLIT
	  s2 = s . substring ( i , j - i ) ;		      	      string s4 = s . substr ( k , s . size ( ) - k ) ;	    	      s2 = s . substr ( i , j - i ) ;			  _FOUR_DISTINCT_STRINGS.cpp:59:14: note: suggested
	  s3 = s . substring ( j , k - j ) ;		      	      if ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 &&  	      s3 = s . substr ( j , k - j ) ;			  alternative: ‘f_filled’	   if ( strf_filled
	  s4 = s . substring ( k , s . length ( ) - k ) ;     	    }							    	      s4 = s . substr ( k , s . length ( ) - k ) ;	  ( s1 , s2 ) && strf_filled ( s1 , s3 ) && strf_fil
	}						      	  }							    	    }							  led ( s1 , s4 ) && strf_filled ( s2 , s3 ) && strf
	catch ( StringIndexOutOfBoundsException e ) {	      	}							    	    catch ( StringIndexOutOfBoundsException & ) {	  _filled ( s2 , s4 ) && strf_filled ( s3 , s4 ) ) r
	}						      	return false ;						    	    }							  eturn true ;		     ^~~~~~~~~~~
	if ( strcheck ( s1 , s2 ) && strcheck ( s1 , s3 ) &&  }								    	    if ( strcheck ( s1 , s2 ) && strcheck ( s1 , s3 ) &&     f_filled
      }							      								    	  }							  
    }							      								    	}							  
  }							      								      }								  
  return false ;					      								      return false ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GRAPHS_CYCLE_ODD_LENGTH				      CHECK_GRAPHS_CYCLE_ODD_LENGTH				    CHECK_GRAPHS_CYCLE_ODD_LENGTH				  CHECK_GRAPHS_CYCLE_ODD_LENGTH
--							      --							    --								  --
public static boolean containsOdd ( int G [ ] [ ] , int src ) bool containsOdd ( int G [ ] [ V ] , int src ) {		    int countNonZero ( int v ) {				  script_not_found : None
  int colorArr [ ] = new int [ V ] ;			      	int colorArr [ V ] ;					      int count = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < V ;						      	i < V ;							      i < V ;							  
  ++ i ) colorArr [ i ] = - 1 ;				      	++ i ) colorArr [ i ] = - 1 ;				      ++ i ) {							  
  colorArr [ src ] = 1 ;				      	colorArr [ src ] = 1 ;					    	count ++ ;						  
  LinkedList < Integer > q = new LinkedList < Integer > ( ) ; 	queue < int > q ;					      }								  
  q . add ( src ) ;					      	q . push ( src ) ;					      return count ;						  
  while ( ! q . isEmpty ( ) ) {				      	while ( ! q . empty ( ) ) {				    }								  
    int u = q . peek ( ) ;				      	  int u = q . front ( ) ;				    								  
    q . pop ( ) ;					      	  q . pop ( ) ;						    								  
    if ( G [ u ] [ u ] == 1 ) return true ;		      	  if ( G [ u ] [ u ] == 1 ) return true ;		    								  
    for ( int v = 0 ;					      	  for ( int v = 0 ;					    								  
    v < V ;						      	  v < V ;						    								  
    ++ v ) {						      	  ++ v ) {						    								  
      if ( G [ u ] [ v ] == 1 && colorArr [ v ] == - 1 ) {    	    if ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) {	    								  
	colorArr [ v ] = 1 - colorArr [ u ] ;		      	      colorArr [ v ] = 1 - colorArr [ u ] ;		    								  
	q . push ( v ) ;				      	      q . push ( v ) ;					    								  
      }							      	    }							    								  
      else if ( G [ u ] [ v ] == 1 && colorArr [ v ] == color 	    else if ( G [ u ] [ v ] && colorArr [ v ] == colorArr [ 								  
    }							      	  }							    								  
  }							      	}							    								  
  return false ;					      	return false ;						    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3		      COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3		    COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3		  COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3
--							      --							    --								  --
int findgroups ( int arr [ ] , int n ) {		      int findgroups ( int arr [ ] , int n ) {			    int findgroups ( int arr [ ] , int n ) {			  error : COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPL
  int c [ ] = new int [ ] {				      	int c [ 3 ] = {						      int c [ ] = {						  E_3.cpp: In function ‘int f_filled(int*, int)’: CO
    0 , 0 , 0 }						      	  0 }							    	0 , 0 , 0 }						  UNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3.cpp:49
    ;							      	  , i ;							    	;							  :65: error: expected ‘)’ before ‘;’ token	 res
    int i ;						      	  int res = 0 ;						    	int i ;							   += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2
    int res = 0 ;					      	  for ( i = 0 ;						    	int res = 0 ;						  ) ) / 6 ;		~
    for ( i = 0 ;					      	  i < n ;						    	for ( i = 0 ;						  			   ^~
    i < n ;						      	  i ++ ) c [ arr [ i ] % 3 ] ++ ;			    	i < n ;							  					     )
    i ++ ) c [ arr [ i ] % 3 ] ++ ;			      	  res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;	    	i ++ ) {						  
    res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;	      	  res += c [ 1 ] * c [ 2 ] ;				    	  c [ arr [ i ] % 3 ] ++ ;				  
    res += c [ 1 ] * c [ 2 ] ;				      	  res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) /  	}							  
    res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) /  	  res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) /  	res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;		  
    res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) /  	  res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) )  	res += c [ 1 ] * c [ 2 ] ;				  
    res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) )  	  res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;			    	res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) /  
    res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;		      	  return res ;						    	res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) /  
    return res ;					      	}							    	res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) )  
  }							      								    	res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;			  
							      								    	return res ;						  
							      								      }								  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS
--							      --							    --								  --
static int maximumNumberDistinctPrimeRange ( int m , int n )  int maximumNumberDistinctPrimeRange ( int m , int n ) {	    int maximumNumberDistinctPrimeRange ( int m , int n ) {	  success : None
  long factorCount [ ] = new long [ n + 1 ] ;		      	long long factorCount [ n + 1 ] ;			      long long factorCount [ n + 1 ] ;				  
  boolean prime [ ] = new boolean [ n + 1 ] ;		      	bool prime [ n + 1 ] ;					      bool prime [ n + 1 ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    factorCount [ i ] = 0 ;				      	  factorCount [ i ] = 0 ;				    	factorCount [ i ] = 0 ;					  
    prime [ i ] = true ;				      	  prime [ i ] = true ;					    	prime [ i ] = true ;					  
  }							      	}							      }								  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( prime [ i ] == true ) {			      	  if ( prime [ i ] == true ) {				    	if ( prime [ i ] == true ) {				  
      factorCount [ i ] = 1 ;				      	    factorCount [ i ] = 1 ;				    	  factorCount [ i ] = 1 ;				  
      for ( int j = i * 2 ;				      	    for ( int j = i * 2 ;				    	  for ( int j = i * 2 ;					  
      j <= n ;						      	    j <= n ;						    	  j <= n ;						  
      j += i ) {					      	    j += i ) {						    	  j += i ) {						  
	factorCount [ j ] ++ ;				      	      factorCount [ j ] ++ ;				    	    factorCount [ j ] ++ ;				  
	prime [ j ] = false ;				      	      prime [ j ] = false ;				    	    prime [ j ] = false ;				  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
  }							      	}							      }								  
  int max = ( int ) factorCount [ m ] ;			      	int max = factorCount [ m ] ;				      int max = ( int ) factorCount [ m ] ;			  
  int num = m ;						      	int num = m ;						      int num = m ;						  
  for ( int i = m ;					      	for ( int i = m ;					      for ( int i = m ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( factorCount [ i ] > max ) {			      	  if ( factorCount [ i ] > max ) {			    	if ( factorCount [ i ] > max ) {			  
      max = ( int ) factorCount [ i ] ;			      	    max = factorCount [ i ] ;				    	  max = ( int ) factorCount [ i ] ;			  
      num = i ;						      	    num = i ;						    	  num = i ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  return num ;						      	return num ;						      return num ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOSOYAS_TRIANGLE					      HOSOYAS_TRIANGLE						    HOSOYAS_TRIANGLE						  HOSOYAS_TRIANGLE
--							      --							    --								  --
static void printHosoya ( int n ) {			      void printHosoya ( int n ) {				    void print_hosoya ( int n ) {				  script_not_found : None
  int dp [ ] [ ] = new int [ N ] [ N ] ;		      	int dp [ N ] [ N ] ;					      int dp [ N ] [ N ] ;					  
  dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ;			      	memset ( dp , 0 , sizeof ( dp ) ) ;			      dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ;			  
  dp [ 1 ] [ 1 ] = 1 ;					      	dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 ;	      dp [ 1 ] [ 1 ] = 1 ;					  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ 	    if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ 	  if ( i > j ) {					  
      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 	    else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 	    dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [  
    }							      	  }							    	  }							  
  }							      	}							    	  else {						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2  
  i < n ;						      	i < n ;							    	  }							  
  i ++ ) {						      	i ++ ) {						    	}							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      }								  
    j <= i ;						      	  j <= i ;						      for ( int i = 0 ;						  
    j ++ ) System . out . print ( dp [ i ] [ j ] + " " ) ;    	  j ++ ) cout << dp [ i ] [ j ] << " " ;		      i < n ;							  
    System . out . println ( "" ) ;			      	  cout << endl ;					      i ++ ) {							  
  }							      	}							    	for ( int j = 0 ;					  
}							      }								    	j <= i ;						  
							      								    	j ++ ) {						  
							      								    	  cout << dp [ i ] [ j ] << " " ;			  
							      								    	}							  
							      								    	cout << "\n" ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MERGING_INTERVALS					      MERGING_INTERVALS						    MERGING_INTERVALS						  MERGING_INTERVALS
--							      --							    --								  --
public static void mergeIntervals ( Interval arr [ ] ) {      void mergeIntervals ( Interval arr [ ] , int n ) {	    void mergeIntervals ( interval arr [ ] ) {			  script_not_found : None
  Arrays . sort ( arr , new Comparator < Interval > ( ) {     	sort ( arr , arr + n , mycomp ) ;			      std :: sort ( arr , arr + sizeof ( arr ) / sizeof ( interva 
    public int compare ( Interval i1 , Interval i2 ) {	      	int index = 0 ;						    	return i2 - i1 ;					  
      return i2 . start - i1 . start ;			      	for ( int i = 1 ;					      }								  
    }							      	i < n ;							      ) ;							  
  }							      	i ++ ) {						      int index = 0 ;						  
  ) ;							      	  if ( arr [ index ] . e >= arr [ i ] . s ) {		      for ( int i = 1 ;						  
  int index = 0 ;					      	    arr [ index ] . e = max ( arr [ index ] . e , arr [ i ]   i < sizeof ( arr ) / sizeof ( interval ) ;		  
  for ( int i = 1 ;					      	    arr [ index ] . s = min ( arr [ index ] . s , arr [ i ]   i ++ ) {							  
  i < arr . length ;					      	  }							    	if ( arr [ index ] . end >= arr [ i ] . start ) {	  
  i ++ ) {						      	  else {						    	  arr [ index ] . end = std :: max ( arr [ index ] . end  
    if ( arr [ index ] . end >= arr [ i ] . start ) {	      	    arr [ index ] = arr [ i ] ;				    	  arr [ index ] . start = std :: min ( arr [ index ] . st 
      arr [ index ] . end = Math . max ( arr [ index ] . end  	    index ++ ;						    	}							  
      arr [ index ] . start = Math . min ( arr [ index ] . st 	  }							    	else {							  
    }							      	}							    	  arr [ index ] = arr [ i ] ;				  
    else {						      	cout << "\n The Merged Intervals are: " ;		    	  index ++ ;						  
      arr [ index ] = arr [ i ] ;			      	for ( int i = 0 ;					    	}							  
      index ++ ;					      	i <= index ;						      }								  
    }							      	i ++ ) cout << "[" << arr [ i ] . s << ", " << arr [ i ] .    std :: cout << "The Merged Intervals are: " ;		  
  }							      }								      for ( int i = 0 ;						  
  System . out . print ( "The Merged Intervals are: " ) ;     								      i <= index ;						  
  for ( int i = 0 ;					      								      i ++ ) std :: cout << "[" << arr [ i ] . start << "," << ar 
  i <= index ;						      								    }								  
  i ++ ) {						      								    								  
    System . out . print ( "[" + arr [ i ] . start + "," + ar 								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_N_DIGIT_STEPPING_NUMBERS				      NUMBER_N_DIGIT_STEPPING_NUMBERS				    NUMBER_N_DIGIT_STEPPING_NUMBERS				  NUMBER_N_DIGIT_STEPPING_NUMBERS
--							      --							    --								  --
static long answer ( int n ) {				      long long answer ( int n ) {				    long long answer ( int n ) {				  success : None
  int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ;		      	int dp [ n + 1 ] [ 10 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( 10 , 
  if ( n == 1 ) return 10 ;				      	if ( n == 1 ) return 10 ;				      if ( n == 1 ) return 10 ;					  
  for ( int j = 0 ;					      	for ( int j = 0 ;					      for ( int j = 0 ;						  
  j <= 9 ;						      	j <= 9 ;						      j <= 9 ;							  
  j ++ ) dp [ 1 ] [ j ] = 1 ;				      	j ++ ) dp [ 1 ] [ j ] = 1 ;				      j ++ ) {							  
  for ( int i = 2 ;					      	for ( int i = 2 ;					    	dp [ 1 ] [ j ] = 1 ;					  
  i <= n ;						      	i <= n ;						      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 2 ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      i <= n ;							  
    j <= 9 ;						      	  j <= 9 ;						      i ++ ) {							  
    j ++ ) {						      	  j ++ ) {						    	for ( int j = 0 ;					  
      if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; 	    if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; 	j <= 9 ;						  
      else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j -  	    else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j -  	j ++ ) {						  
      else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 	    else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 	  if ( j == 0 ) {					  
    }							      	  }							    	    dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;		  
  }							      	}							    	  }							  
  long sum = 0 ;					      	long long sum = 0 ;					    	  else if ( j == 9 ) {					  
  for ( int j = 1 ;					      	for ( int j = 1 ;					    	    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;		  
  j <= 9 ;						      	j <= 9 ;						    	  }							  
  j ++ ) sum += dp [ n ] [ j ] ;			      	j ++ ) sum += dp [ n ] [ j ] ;				    	  else {						  
  return sum ;						      	return sum ;						    	    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1  
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      long long sum = 0 ;					  
							      								      for ( int j = 1 ;						  
							      								      j <= 9 ;							  
							      								      j ++ ) {							  
							      								    	sum += dp [ n ] [ j ] ;					  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION	      MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION	    MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION	  MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION
--							      --							    --								  --
static void printMaxSum ( int arr [ ] , int n ) {	      void printMaxSum ( int arr [ ] , int n ) {		    void printMaxSum ( int arr [ ] , int n ) {			  script_not_found : None
  int dp [ ] = new int [ n ] ;				      	int dp [ n ] ;						      int dp [ n ] ;						  
  Arrays . fill ( dp , 0 ) ;				      	memset ( dp , 0 , sizeof dp ) ;				      memset ( dp , 0 , sizeof ( dp ) ) ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    dp [ i ] = arr [ i ] ;				      	  dp [ i ] = arr [ i ] ;				    	dp [ i ] = arr [ i ] ;					  
    int maxi = 0 ;					      	  int maxi = 0 ;					    	int maxi = 0 ;						  
    for ( int j = 1 ;					      	  for ( int j = 1 ;					    	for ( int j = 1 ;					  
    j <= Math . sqrt ( i + 1 ) ;			      	  j <= sqrt ( i + 1 ) ;					    	j <= sqrt ( i + 1 ) ;					  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) {	      	    if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) {	    	  if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) {	  
	if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ;      	      if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ;	    	    if ( dp [ j - 1 ] > maxi ) {			  
	if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi 	      if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi 	      maxi = dp [ j - 1 ] ;				  
      }							      	    }							    	    }							  
    }							      	  }							    	    if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) {	  
    dp [ i ] += maxi ;					      	  dp [ i ] += maxi ;					    	      maxi = dp [ ( i + 1 ) / j - 1 ] ;			  
  }							      	}							    	    }							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	  }							  
  i < n ;						      	i < n ;							    	}							  
  i ++ ) System . out . print ( dp [ i ] + " " ) ;	      	i ++ ) cout << dp [ i ] << " " ;			    	dp [ i ] += maxi ;					  
}							      }								      }								  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) {							  
							      								    	cout << dp [ i ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM			      PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM			    PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM				  PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM
--							      --							    --								  --
static void spiralPrint ( int m , int n , int a [ ] [ ] ) {   void spiralPrint ( int m , int n , int a [ R ] [ C ] ) {	    void spiralPrint ( int m , int n , int a [ ] [ 2 ] ) {	  script_not_found : None
  int i , k = 0 , l = 0 ;				      	int i , k = 0 , l = 0 ;					      int i , k = 0 , l = 0 ;					  
  while ( k < m && l < n ) {				      	while ( k < m && l < n ) {				      while ( k < m && l < n ) {				  
    for ( i = l ;					      	  for ( i = l ;						    	for ( i = l ;						  
    i < n ;						      	  i < n ;						    	i < n ;							  
    ++ i ) {						      	  ++ i ) {						    	++ i ) cout << a [ k ] [ i ] << " " ;			  
      System . out . print ( a [ k ] [ i ] + " " ) ;	      	    cout << a [ k ] [ i ] << " " ;			    	k ++ ;							  
    }							      	  }							    	for ( i = k ;						  
    k ++ ;						      	  k ++ ;						    	i < m ;							  
    for ( i = k ;					      	  for ( i = k ;						    	++ i ) cout << a [ i ] [ n - 1 ] << " " ;		  
    i < m ;						      	  i < m ;						    	n -- ;							  
    ++ i ) {						      	  ++ i ) {						    	if ( k < m ) {						  
      System . out . print ( a [ i ] [ n - 1 ] + " " ) ;      	    cout << a [ i ] [ n - 1 ] << " " ;			    	  for ( i = n - 1 ;					  
    }							      	  }							    	  i >= l ;						  
    n -- ;						      	  n -- ;						    	  -- i ) cout << a [ m - 1 ] [ i ] << " " ;		  
    if ( k < m ) {					      	  if ( k < m ) {					    	  m -- ;						  
      for ( i = n - 1 ;					      	    for ( i = n - 1 ;					    	}							  
      i >= l ;						      	    i >= l ;						    	if ( l < n ) {						  
      -- i ) {						      	    -- i ) {						    	  for ( i = m - 1 ;					  
	System . out . print ( a [ m - 1 ] [ i ] + " " ) ;    	      cout << a [ m - 1 ] [ i ] << " " ;		    	  i >= k ;						  
      }							      	    }							    	  -- i ) cout << a [ i ] [ l ] << " " ;			  
      m -- ;						      	    m -- ;						    	  l ++ ;						  
    }							      	  }							    	}							  
    if ( l < n ) {					      	  if ( l < n ) {					      }								  
      for ( i = m - 1 ;					      	    for ( i = m - 1 ;					    }								  
      i >= k ;						      	    i >= k ;						    								  
      -- i ) {						      	    -- i ) {						    								  
	System . out . print ( a [ i ] [ l ] + " " ) ;	      	      cout << a [ i ] [ l ] << " " ;			    								  
      }							      	    }							    								  
      l ++ ;						      	    l ++ ;						    								  
    }							      	  }							    								  
  }							      	}							    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_PRODUCT_SUBSET_ARRAY				      MINIMUM_PRODUCT_SUBSET_ARRAY				    MINIMUM_PRODUCT_SUBSET_ARRAY				  MINIMUM_PRODUCT_SUBSET_ARRAY
--							      --							    --								  --
static int minProductSubset ( int a [ ] , int n ) {	      int minProductSubset ( int a [ ] , int n ) {		    int minProductSubset ( int a [ ] , int n ) {		  success : None
  if ( n == 1 ) return a [ 0 ] ;			      	if ( n == 1 ) return a [ 0 ] ;				      if ( n == 1 ) return a [ 0 ] ;				  
  int negmax = Integer . MIN_VALUE ;			      	int max_neg = INT_MIN ;					      int negmax = std :: numeric_limits < int > :: min ( ) ;	  
  int posmin = Integer . MAX_VALUE ;			      	int min_pos = INT_MAX ;					      int posmin = std :: numeric_limits < int > :: max ( ) ;	  
  int count_neg = 0 , count_zero = 0 ;			      	int count_neg = 0 , count_zero = 0 ;			      int count_neg = 0 , count_zero = 0 ;			  
  int product = 1 ;					      	int prod = 1 ;						      int product = 1 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( a [ i ] == 0 ) {				      	  if ( a [ i ] == 0 ) {					    	if ( a [ i ] == 0 ) {					  
      count_zero ++ ;					      	    count_zero ++ ;					    	  count_zero ++ ;					  
      continue ;					      	    continue ;						    	  continue ;						  
    }							      	  }							    	}							  
    if ( a [ i ] < 0 ) {				      	  if ( a [ i ] < 0 ) {					    	if ( a [ i ] < 0 ) {					  
      count_neg ++ ;					      	    count_neg ++ ;					    	  count_neg ++ ;					  
      negmax = Math . max ( negmax , a [ i ] ) ;	      	    max_neg = max ( max_neg , a [ i ] ) ;		    	  negmax = std :: max ( negmax , a [ i ] ) ;		  
    }							      	  }							    	}							  
    if ( a [ i ] > 0 && a [ i ] < posmin ) posmin = a [ i ] ; 	  if ( a [ i ] > 0 ) min_pos = min ( min_pos , a [ i ] ) ;  	if ( a [ i ] > 0 && a [ i ] < posmin ) {		  
    product *= a [ i ] ;				      	  prod = prod * a [ i ] ;				    	  posmin = a [ i ] ;					  
  }							      	}							    	}							  
  if ( count_zero == n || ( count_neg == 0 && count_zero > 0  	if ( count_zero == n || ( count_neg == 0 && count_zero > 0  	product *= a [ i ] ;					  
  if ( count_neg == 0 ) return posmin ;			      	if ( count_neg == 0 ) return min_pos ;			      }								  
  if ( count_neg % 2 == 0 && count_neg != 0 ) {		      	if ( ! ( count_neg & 1 ) && count_neg != 0 ) {		      if ( count_zero == n || ( count_neg == 0 && count_zero > 0  
    product = product / negmax ;			      	  prod = prod / max_neg ;				      if ( count_neg == 0 ) return posmin ;			  
  }							      	}							      if ( count_neg % 2 == 0 && count_neg != 0 ) product = produ 
  return product ;					      	return prod ;						      return product ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS	      FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS		    FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS		  FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS
--							      --							    --								  --
static void pairSum ( int mat [ ] [ ] , int n , int sum ) {   void pairSum ( int mat [ ] [ MAX ] , int n , int sum ) {	    void pairSum ( int mat [ ] [ 2 ] , int n , int sum ) {	  script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) Arrays . sort ( mat [ i ] ) ;			      	i ++ ) sort ( mat [ i ] , mat [ i ] + n ) ;		      i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	sort ( mat [ i ] , mat [ i ] + n ) ;			  
  i < n - 1 ;						      	i < n - 1 ;						      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 0 ;						  
    for ( int j = i + 1 ;				      	  for ( int j = i + 1 ;					      i < n - 1 ;						  
    j < n ;						      	  j < n ;						      i ++ ) {							  
    j ++ ) {						      	  j ++ ) {						    	for ( int j = i + 1 ;					  
      int left = 0 , right = n - 1 ;			      	    int left = 0 , right = n - 1 ;			    	j < n ;							  
      while ( left < n && right >= 0 ) {		      	    while ( left < n && right >= 0 ) {			    	j ++ ) {						  
	if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) ==  	      if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) ==  	  int left = 0 , right = n - 1 ;			  
	  System . out . print ( "(" + mat [ i ] [ left ] + " 		cout << "(" << mat [ i ] [ left ] << ", " << mat [  	  while ( left < n && right >= 0 ) {			  
	  left ++ ;					      		left ++ ;					    	    if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) ==  
	  right -- ;					      		right -- ;					    	      cout << "(" << mat [ i ] [ left ] << ", " << mat [  
	}						      	      }							    	      left ++ ;						  
	else {						      	      else {						    	      right -- ;					  
	  if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < 		if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < 	    }							  
	  else right -- ;				      		else right -- ;					    	    else {						  
	}						      	      }							    	      if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < 
      }							      	    }							    		left ++ ;					  
    }							      	  }							    	      }							  
  }							      	}							    	      else {						  
}							      }								    		right -- ;					  
							      								    	      }							  
							      								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1		      FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1		    FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1		  FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1
--							      --							    --								  --
static int count ( String a , String b ) {		      int count ( string a , string b ) {			    int count ( string a , string b ) {				  success : None
  int m = a . length ( ) ;				      	int m = a . length ( ) ;				      int m = a . length ( ) ;					  
  int n = b . length ( ) ;				      	int n = b . length ( ) ;				      int n = b . length ( ) ;					  
  int lookup [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	int lookup [ m + 1 ] [ n + 1 ] = {			      vector < vector < int >> lookup ( m + 1 , vector < int > (  
  for ( int i = 0 ;					      	  {							      for ( int i = 0 ;						  
  i <= n ;						      	    0 }							      i <= n ;							  
  ++ i ) lookup [ 0 ] [ i ] = 0 ;			      	  }							      ++ i ) {							  
  for ( int i = 0 ;					      	  ;							    	lookup [ 0 ] [ i ] = 0 ;				  
  i <= m ;						      	  for ( int i = 0 ;					      }								  
  ++ i ) lookup [ i ] [ 0 ] = 1 ;			      	  i <= n ;						      for ( int i = 0 ;						  
  for ( int i = 1 ;					      	  ++ i ) lookup [ 0 ] [ i ] = 0 ;			      i <= m ;							  
  i <= m ;						      	  for ( int i = 0 ;					      ++ i ) {							  
  i ++ ) {						      	  i <= m ;						    	lookup [ i ] [ 0 ] = 1 ;				  
    for ( int j = 1 ;					      	  ++ i ) lookup [ i ] [ 0 ] = 1 ;			      }								  
    j <= n ;						      	  for ( int i = 1 ;					      for ( int i = 1 ;						  
    j ++ ) {						      	  i <= m ;						      i <= m ;							  
      if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) loo 	  i ++ ) {						      ++ i ) {							  
      else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ;      	    for ( int j = 1 ;					    	for ( int j = 1 ;					  
    }							      	    j <= n ;						    	j <= n ;						  
  }							      	    j ++ ) {						    	++ j ) {						  
  return lookup [ m ] [ n ] ;				      	      if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ]  	  if ( a [ i - 1 ] == b [ j - 1 ] ) {			  
}							      	      else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ;    	    lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + loo 
							      	    }							    	  }							  
							      	  }							    	  else {						  
							      	  return lookup [ m ] [ n ] ;				    	    lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ;	  
							      	}							    	  }							  
							      								    	}							  
							      								      }								  
							      								      return lookup [ m ] [ n ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_ FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_ FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_ FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_
--							      --							    --								  --
static int maxSubsequenceSubstring ( char x [ ] , char y [ ]  int maxSubsequenceSubstring ( char x [ ] , char y [ ] , int n int maxSubsequenceSubstring ( char x [ ] , char y [ ] , int n script_not_found : None
  int dp [ ] [ ] = new int [ MAX ] [ MAX ] ;		      	int dp [ MAX ] [ MAX ] ;				      int dp [ MAX ] [ MAX ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= m ;						      	i <= m ;						      i <= m ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j <= n ;						      	j <= n ;						      j <= n ;							  
  j ++ ) dp [ i ] [ j ] = 0 ;				      	j ++ ) dp [ i ] [ j ] = 0 ;				      j ++ ) dp [ i ] [ j ] = 0 ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= m ;						      	i <= m ;						      i <= m ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 1 ;					      	  for ( int j = 1 ;					    	for ( int j = 1 ;					  
    j <= n ;						      	  j <= n ;						    	j <= n ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 +  	    if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 +  	  if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 +  
      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;	      	    else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		    	  else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		  
    }							      	  }							    	}							  
  }							      	}							      }								  
  int ans = 0 ;						      	int ans = 0 ;						      int ans = 0 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= m ;						      	i <= m ;						      i <= m ;							  
  i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ;	      	i ++ ) ans = max ( ans , dp [ i ] [ n ] ) ;		      i ++ ) ans = max ( ans , dp [ i ] [ n ] ) ;		  
  return ans ;						      	return ans ;						      return ans ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER		      GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER		    GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER			  GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER
--							      --							    --								  --
static void evaluate ( int n ) {			      void evaluate ( long long int n ) {			    void evaluate ( int n ) {					  script_not_found : None
  if ( n == 1 || n == 2 ) System . out . println ( "No Pythag 	if ( n == 1 || n == 2 ) printf ( "No Pythagoras Triplet exi   if ( n == 1 || n == 2 ) {					  
  else if ( n % 2 == 0 ) {				      	else if ( n % 2 == 0 ) {				    	cout << "No Pythagoras " << "Triplet exists" << endl ;	  
    int var = 1 * n * n / 4 ;				      	  long long int var = 1LL * n * n / 4 ;			      }								  
    System . out . print ( "Pythagoras Triplets " + "exist i. 	  printf ( "Pythagoras Triplets exist i.e. " ) ;	      else if ( n % 2 == 0 ) {					  
    System . out . print ( n + " " ) ;			      	  printf ( "%lld %lld %lld" , n , var - 1 , var + 1 ) ;	    	int var = 1 * n * n / 4 ;				  
    System . out . print ( var - 1 + " " ) ;		      	}							    	cout << "Pythagoras Triplets " << "exist i.e. " << n << " 
    System . out . println ( var + 1 + " " ) ;		      	else if ( n % 2 != 0 ) {				      }								  
  }							      	  long long int var = 1LL * n * n + 1 ;			      else if ( n % 2 != 0 ) {					  
  else if ( n % 2 != 0 ) {				      	  printf ( "Pythagoras Triplets exist i.e. " ) ;	    	int var = 1 * n * n + 1 ;				  
    int var = 1 * n * n + 1 ;				      	  printf ( "%lld %lld %lld" , n , var / 2 - 1 , var / 2 ) ; 	cout << "Pythagoras Triplets " << "exist i.e. " << n << " 
    System . out . print ( "Pythagoras Triplets " + "exist i. 	}							      }								  
    System . out . print ( n + " " ) ;			      }								    }								  
    System . out . print ( var / 2 - 1 + " " ) ;	      								    								  
    System . out . println ( var / 2 + " " ) ;		      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HIGHWAY_BILLBOARD_PROBLEM				      HIGHWAY_BILLBOARD_PROBLEM					    HIGHWAY_BILLBOARD_PROBLEM					  HIGHWAY_BILLBOARD_PROBLEM
--							      --							    --								  --
static int maxRevenue ( int m , int [ ] x , int [ ] revenue , int maxRevenue ( int m , int x [ ] , int revenue [ ] , int n  int maxRevenue ( int m , int * x , int * revenue , int n , in success : None
  int [ ] maxRev = new int [ m + 1 ] ;			      	int maxRev [ m + 1 ] ;					      int maxRev [ m + 1 ] ;					  
  for ( int i = 0 ;					      	memset ( maxRev , 0 , sizeof ( maxRev ) ) ;		      for ( int i = 0 ;						  
  i < m + 1 ;						      	int nxtbb = 0 ;						      i < m + 1 ;						  
  i ++ ) maxRev [ i ] = 0 ;				      	for ( int i = 1 ;					      i ++ ) {							  
  int nxtbb = 0 ;					      	i <= m ;						    	maxRev [ i ] = 0 ;					  
  for ( int i = 1 ;					      	i ++ ) {						      }								  
  i <= m ;						      	  if ( nxtbb < n ) {					      int nxtbb = 0 ;						  
  i ++ ) {						      	    if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ]   for ( int i = 1 ;						  
    if ( nxtbb < n ) {					      	    else {						      i <= m ;							  
      if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] 	      if ( i <= t ) maxRev [ i ] = max ( maxRev [ i - 1 ] ,   i ++ ) {							  
      else {						      	      else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + reve 	if ( nxtbb < n ) {					  
	if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i  	      nxtbb ++ ;					    	  if ( x [ nxtbb ] != i ) {				  
	else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] 	    }							    	    maxRev [ i ] = maxRev [ i - 1 ] ;			  
	nxtbb ++ ;					      	  }							    	  }							  
      }							      	  else maxRev [ i ] = maxRev [ i - 1 ] ;		    	  else {						  
    }							      	}							    	    if ( i <= t ) {					  
    else maxRev [ i ] = maxRev [ i - 1 ] ;		      	return maxRev [ m ] ;					    	      maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ n 
  }							      }								    	    }							  
  return maxRev [ m ] ;					      								    	    else {						  
}							      								    	      maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue 
							      								    	    }							  
							      								    	    nxtbb ++ ;						  
							      								    	  }							  
							      								    	}							  
							      								    	else {							  
							      								    	  maxRev [ i ] = maxRev [ i - 1 ] ;			  
							      								    	}							  
							      								      }								  
							      								      return maxRev [ m ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE
--							      --							    --								  --
static int minCost ( int a [ ] , int n , int k ) {	      int minCost ( int a [ ] , int n , int k ) {		    int minCost ( int a [ ] , int n , int k ) {			  script_not_found : None
  int dp [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ;	      	int dp [ n + 1 ] [ k + 1 ] ;				      int dp [ n + 1 ] [ k + 1 ] ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j <= k ;						      	j <= k ;						      j <= k ;							  
  j ++ ) dp [ i ] [ j ] = inf ;				      	j ++ ) dp [ i ] [ j ] = inf ;				      j ++ ) dp [ i ] [ j ] = inf ;				  
  dp [ 0 ] [ 0 ] = 0 ;					      	dp [ 0 ] [ 0 ] = 0 ;					      dp [ 0 ] [ 0 ] = 0 ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) for ( int j = 1 ;				      	i ++ ) for ( int j = 1 ;				      i ++ ) for ( int j = 1 ;					  
  j <= k ;						      	j <= k ;						      j <= k ;							  
  j ++ ) for ( int m = i - 1 ;				      	j ++ ) for ( int m = i - 1 ;				      j ++ ) for ( int m = i - 1 ;				  
  m >= 0 ;						      	m >= 0 ;						      m >= 0 ;							  
  m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [  	m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j   m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j 
  return dp [ n ] [ k ] ;				      	return dp [ n ] [ k ] ;					      return dp [ n ] [ k ] ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1		      COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1		    COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1		  COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1
--							      --							    --								  --
static int countPS ( int i , int j ) {			      int countPS ( int i , int j ) {				    int countPS ( int i , int j ) {				  script_not_found : None
  if ( i >= n || j < 0 ) return 0 ;			      	if ( i >= n || j < 0 ) return 0 ;			      if ( i >= n || j < 0 ) return 0 ;				  
  if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ;	      	if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ;	      if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ;	  
  if ( ( i - j == 1 ) || ( i - j == - 1 ) ) {		      	if ( abs ( i - j ) == 1 ) {				      if ( ( i - j == 1 ) || ( i - j == - 1 ) ) {		  
    if ( str . charAt ( i ) == str . charAt ( j ) ) return dp 	  if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = 3 ; 	if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = 3 ; 
    else return dp [ i ] [ j ] = 2 ;			      	  else return dp [ i ] [ j ] = 2 ;			    	else return dp [ i ] [ j ] = 2 ;			  
  }							      	}							      }								  
  if ( i == j ) return dp [ 1 ] [ j ] = 1 ;		      	if ( i == j ) return dp [ 1 ] [ j ] = 1 ;		      if ( i == j ) return dp [ 1 ] [ j ] = 1 ;			  
  else if ( str . charAt ( i ) == str . charAt ( j ) ) return 	else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] =    else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] =  
  else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countP 	else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countP   else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countP 
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS			      FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS			    FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS			  FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS
--							      --							    --								  --
static void kSmallestPair ( int arr1 [ ] , int n1 , int arr2  void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , i void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , i script_not_found : None
  if ( k > n1 * n2 ) {					      	if ( k > n1 * n2 ) {					      if ( k > n1 * n2 ) {					  
    System . out . print ( "k pairs don't exist" ) ;	      	  cout << "k pairs don't exist" ;			    	cout << "k pairs don't exist" << endl ;			  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  int index2 [ ] = new int [ n1 ] ;			      	int index2 [ n1 ] ;					      int index2 [ n1 ] ;					  
  while ( k > 0 ) {					      	memset ( index2 , 0 , sizeof ( index2 ) ) ;		      while ( k > 0 ) {						  
    int min_sum = Integer . MAX_VALUE ;			      	while ( k > 0 ) {					    	int min_sum = INT_MAX ;					  
    int min_index = 0 ;					      	  int min_sum = INT_MAX ;				    	int min_index = 0 ;					  
    for ( int i1 = 0 ;					      	  int min_index = 0 ;					    	for ( int i1 = 0 ;					  
    i1 < n1 ;						      	  for ( int i1 = 0 ;					    	i1 < n1 ;						  
    i1 ++ ) {						      	  i1 < n1 ;						    	i1 ++ ) {						  
      if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2  	  i1 ++ ) {						    	  if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2  
	min_index = i1 ;				      	    if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2  	    min_index = i1 ;					  
	min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ;      	      min_index = i1 ;					    	    min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ;	  
      }							      	      min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ;	    	  }							  
    }							      	    }							    	}							  
    System . out . print ( "(" + arr1 [ min_index ] + ", " +  	  }							    	cout << "(" << arr1 [ min_index ] << ", " << arr2 [ index 
    index2 [ min_index ] ++ ;				      	  cout << "(" << arr1 [ min_index ] << ", " << arr2 [ index 	index2 [ min_index ] ++ ;				  
    k -- ;						      	  index2 [ min_index ] ++ ;				    	k -- ;							  
  }							      	  k -- ;						      }								  
}							      	}							    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL	      FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL		    FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL		  FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL
--							      --							    --								  --
static int countOps ( int A [ ] [ ] , int B [ ] [ ] , int m , int countOps ( int A [ ] [ MAX ] , int B [ ] [ MAX ] , int m  int countOps ( int A [ ] [ 2 ] , int B [ ] [ 2 ] , int m , in script_not_found : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < m ;						      	j < m ;							      j < m ;							  
  j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ;		      	j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ;			      j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ;			  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) for ( int j = 1 ;				      	i ++ ) for ( int j = 1 ;				      i ++ ) for ( int j = 1 ;					  
  j < m ;						      	j < m ;							      j < m ;							  
  j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + 	j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] +   j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + 
  int result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) result += Math . abs ( A [ i ] [ 0 ] ) ;	      	i ++ ) result += abs ( A [ i ] [ 0 ] ) ;		      i ++ ) result += abs ( A [ i ] [ 0 ] ) ;			  
  for ( int j = 0 ;					      	for ( int j = 0 ;					      for ( int j = 0 ;						  
  j < m ;						      	j < m ;							      j < m ;							  
  j ++ ) result += Math . abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] 	j ++ ) result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ;      j ++ ) result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ;	  
  return ( result ) ;					      	return ( result ) ;					      return ( result ) ;					  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT		      CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT			    CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT			  CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT
--							      --							    --								  --
static boolean isMagicSquare ( int mat [ ] [ ] ) {	      bool isMagicSquare ( int mat [ ] [ N ] ) {		    bool isMagicSquare ( int mat [ N ] [ N ] ) {		  script_not_found : None
  int sum = 0 , sum2 = 0 ;				      	int sum = 0 , sum2 = 0 ;				      int sum = 0 , sum2 = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) sum = sum + mat [ i ] [ i ] ;			      	i ++ ) sum = sum + mat [ i ] [ i ] ;			      i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	sum = sum + mat [ i ] [ i ] ;				  
  i < N ;						      	i < N ;							      }								  
  i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ;	      	i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ;		      for ( int i = 0 ;						  
  if ( sum != sum2 ) return false ;			      	if ( sum != sum2 ) return false ;			      i < N ;							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      i ++ ) {							  
  i < N ;						      	i < N ;							    	sum2 = sum2 + mat [ i ] [ N - 1 - i ] ;			  
  i ++ ) {						      	i ++ ) {						      }								  
    int rowSum = 0 ;					      	  int rowSum = 0 ;					      if ( sum != sum2 ) return false ;				  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      for ( int i = 0 ;						  
    j < N ;						      	  j < N ;						      i < N ;							  
    j ++ ) rowSum += mat [ i ] [ j ] ;			      	  j ++ ) rowSum += mat [ i ] [ j ] ;			      i ++ ) {							  
    if ( rowSum != sum ) return false ;			      	  if ( rowSum != sum ) return false ;			    	int rowSum = 0 ;					  
  }							      	}							    	for ( int j = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	j < N ;							  
  i < N ;						      	i < N ;							    	j ++ ) {						  
  i ++ ) {						      	i ++ ) {						    	  rowSum += mat [ i ] [ j ] ;				  
    int colSum = 0 ;					      	  int colSum = 0 ;					    	}							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	if ( rowSum != sum ) return false ;			  
    j < N ;						      	  j < N ;						      }								  
    j ++ ) colSum += mat [ j ] [ i ] ;			      	  j ++ ) colSum += mat [ j ] [ i ] ;			      for ( int i = 0 ;						  
    if ( sum != colSum ) return false ;			      	  if ( sum != colSum ) return false ;			      i < N ;							  
  }							      	}							      i ++ ) {							  
  return true ;						      	return true ;						    	int colSum = 0 ;					  
}							      }								    	for ( int j = 0 ;					  
							      								    	j < N ;							  
							      								    	j ++ ) {						  
							      								    	  colSum += mat [ j ] [ i ] ;				  
							      								    	}							  
							      								    	if ( sum != colSum ) return false ;			  
							      								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES	      MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES	    MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES	  MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES
--							      --							    --								  --
static int maximumDifferenceSum ( int arr [ ] , int N ) {     int maximumDifferenceSum ( int arr [ ] , int N ) {	    int maximumDifferenceSum ( int arr [ ] , int N ) {		  script_not_found : None
  int dp [ ] [ ] = new int [ N ] [ 2 ] ;		      	int dp [ N ] [ 2 ] ;					      int dp [ N ] [ 2 ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ;		      	i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ;		      i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ;			  
  i < ( N - 1 ) ;					      	i < ( N - 1 ) ;						      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 0 ;						  
    dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i 	  dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1    i < ( N - 1 ) ;						  
    dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . 	  dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i   i ++ ) {							  
  }							      	}							    	dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1  
  return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] 	return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ;    	dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i 
}							      }								      }								  
							      								      return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ;	  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS	      LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS	    LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS	  LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS
--							      --							    --								  --
static void findLIS ( int A [ ] , int n ) {		      int findLIS ( int A [ ] , int n ) {			    void findLIS ( int A [ ] , int n ) {			  script_not_found : None
  Map < Integer , Integer > hash = new HashMap < Integer , In 	unordered_map < int , int > hash ;			      map < int , int > hash ;					  
  int LIS_size = 1 ;					      	int LIS_size = 1 ;					      int LIS_size = 1 ;					  
  int LIS_index = 0 ;					      	int LIS_index = 0 ;					      int LIS_index = 0 ;					  
  hash . put ( A [ 0 ] , 1 ) ;				      	hash [ A [ 0 ] ] = 1 ;					      hash [ A [ 0 ] ] = 1 ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    hash . put ( A [ i ] , hash . get ( A [ i ] - 1 ) == null 	  hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 ;		    	hash [ A [ i ] ] = hash [ A [ i ] - 1 ] == 0 ? 1 : hash [ 
    if ( LIS_size < hash . get ( A [ i ] ) ) {		      	  if ( LIS_size < hash [ A [ i ] ] ) {			    	if ( LIS_size < hash [ A [ i ] ] ) {			  
      LIS_size = hash . get ( A [ i ] ) ;		      	    LIS_size = hash [ A [ i ] ] ;			    	  LIS_size = hash [ A [ i ] ] ;				  
      LIS_index = A [ i ] ;				      	    LIS_index = A [ i ] ;				    	  LIS_index = A [ i ] ;					  
    }							      	  }							    	}							  
  }							      	}							      }								  
  System . out . println ( "LIS_size = " + LIS_size ) ;	      	cout << "LIS_size = " << LIS_size << "\n" ;		      cout << "LIS_size = " << LIS_size << endl ;		  
  System . out . print ( "LIS : " ) ;			      	cout << "LIS : " ;					      cout << "LIS : " ;					  
  int start = LIS_index - LIS_size + 1 ;		      	int start = LIS_index - LIS_size + 1 ;			      int start = LIS_index - LIS_size + 1 ;			  
  while ( start <= LIS_index ) {			      	while ( start <= LIS_index ) {				      while ( start <= LIS_index ) {				  
    System . out . print ( start + " " ) ;		      	  cout << start << " " ;				    	cout << start << " " ;					  
    start ++ ;						      	  start ++ ;						    	start ++ ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE		      COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE		    COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE			  COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE
--							      --							    --								  --
static int findSubsequenceCount ( String S , String T ) {     int findSubsequenceCount ( string S , string T ) {	    int findSubsequenceCount ( string S , string T ) {		  success : None
  int m = T . length ( ) ;				      	int m = T . length ( ) , n = S . length ( ) ;		      int m = T . length ( ) ;					  
  int n = S . length ( ) ;				      	if ( m > n ) return 0 ;					      int n = S . length ( ) ;					  
  if ( m > n ) return 0 ;				      	int mat [ m + 1 ] [ n + 1 ] ;				      if ( m > n ) return 0 ;					  
  int mat [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	for ( int i = 1 ;					      vector < vector < int >> mat ( m + 1 , vector < int > ( n + 
  for ( int i = 1 ;					      	i <= m ;						      for ( int i = 1 ;						  
  i <= m ;						      	i ++ ) mat [ i ] [ 0 ] = 0 ;				      i <= m ;							  
  i ++ ) mat [ i ] [ 0 ] = 0 ;				      	for ( int j = 0 ;					      i ++ ) {							  
  for ( int j = 0 ;					      	j <= n ;						    	mat [ i ] [ 0 ] = 0 ;					  
  j <= n ;						      	j ++ ) mat [ 0 ] [ j ] = 1 ;				      }								  
  j ++ ) mat [ 0 ] [ j ] = 1 ;				      	for ( int i = 1 ;					      for ( int j = 0 ;						  
  for ( int i = 1 ;					      	i <= m ;						      j <= n ;							  
  i <= m ;						      	i ++ ) {						      j ++ ) {							  
  i ++ ) {						      	  for ( int j = 1 ;					    	mat [ 0 ] [ j ] = 1 ;					  
    for ( int j = 1 ;					      	  j <= n ;						      }								  
    j <= n ;						      	  j ++ ) {						      for ( int i = 1 ;						  
    j ++ ) {						      	    if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat   i <= m ;							  
      if ( T . charAt ( i - 1 ) != S . charAt ( j - 1 ) ) mat 	    else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i -    i ++ ) {							  
      else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i -  	  }							    	for ( int j = 1 ;					  
    }							      	}							    	j <= n ;						  
  }							      	return mat [ m ] [ n ] ;				    	j ++ ) {						  
  return mat [ m ] [ n ] ;				      }								    	  if ( T [ i - 1 ] != S [ j - 1 ] ) {			  
}							      								    	    mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ;		  
							      								    	  }							  
							      								    	  else {						  
							      								    	    mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] 
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return mat [ m ] [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX	      MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX	    MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX		  MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX
--							      --							    --								  --
public static int maxCost ( int mat [ ] [ ] , int N ) {	      int maxCost ( int mat [ ] [ MAX ] , int N ) {		    int maxCost ( int mat [ ] [ 2 ] , int N ) {			  script_not_found : None
  int dp [ ] [ ] = new int [ N ] [ N ] ;		      	int dp [ N ] [ N ] ;					      int dp [ N ] [ N ] ;					  
  dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ;			      	memset ( dp , 0 , sizeof ( dp ) ) ;			      dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ;			  
  for ( int i = 1 ;					      	dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ;			      for ( int i = 1 ;						  
  i < N ;						      	for ( int i = 1 ;					      i < N ;							  
  i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0  	i < N ;							      i ++ ) {							  
  for ( int i = 1 ;					      	i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0  	dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ;	  
  i < N ;						      	for ( int i = 1 ;					      }								  
  i ++ ) for ( int j = 1 ;				      	i < N ;							      for ( int i = 1 ;						  
  j < i + 1 && j < N ;					      	i ++ ) for ( int j = 1 ;				      i < N ;							  
  j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ 	j < i + 1 && j < N ;					      i ++ ) for ( int j = 1 ;					  
  int result = 0 ;					      	j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1    j < i + 1 && j < N ;					  
  for ( int i = 0 ;					      	int result = 0 ;					      j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1  
  i < N ;						      	for ( int i = 0 ;					      int result = 0 ;						  
  i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 	i < N ;							      for ( int i = 0 ;						  
  return result ;					      	i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N -   i < N ;							  
}							      	return result ;						      i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 
							      }								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS     NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS	    NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS	  NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS
--							      --							    --								  --
static int waysToArrange ( int N , int K , int [ ] k ) {      int waysToArrange ( int N , int K , int k [ ] ) {		    int waysToArrange ( int N , int K , vector < int > k ) {	  script_not_found : None
  int [ ] [ ] C = new int [ N + 1 ] [ N + 1 ] ;		      	int C [ N + 1 ] [ N + 1 ] ;				      vector < vector < int >> C ( N + 1 , vector < int > ( N + 1 
  int i , j ;						      	int i , j ;						      int i , j ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i <= N ;						      	i <= N ;						      i <= N ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( j = 0 ;					      	  for ( j = 0 ;						    	for ( j = 0 ;						  
    j <= i ;						      	  j <= i ;						    	j <= i ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( j == 0 || j == i ) {				      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		  
	C [ i ] [ j ] = 1 ;				      	    else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i -  	  else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i -  
      }							      	  }							    	}							  
      else {						      	}							      }								  
	C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] 	int dp [ K ] ;						      vector < int > dp ( K + 1 , 0 ) ;				  
      }							      	int count = 0 ;						      int count = 0 ;						  
    }							      	dp [ 0 ] = 1 ;						      dp [ 0 ] = 1 ;						  
  }							      	for ( int i = 0 ;					      for ( i = 0 ;						  
  int [ ] dp = new int [ K + 1 ] ;			      	i < K ;							      i < K ;							  
  int count = 0 ;					      	i ++ ) {						      i ++ ) {							  
  dp [ 0 ] = 1 ;					      	  dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k 	dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k 
  for ( i = 0 ;						      	  count += k [ i ] ;					    	count += k [ i ] ;					  
  i < K ;						      	}							      }								  
  i ++ ) {						      	return dp [ K ] ;					      return dp [ K ] ;						  
    dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k }								    }								  
    count += k [ i ] ;					      								    								  
  }							      								    								  
  return dp [ K ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_MATRIX_ANTISPIRAL_FORM				      PRINT_MATRIX_ANTISPIRAL_FORM				    PRINT_MATRIX_ANTISPIRAL_FORM				  PRINT_MATRIX_ANTISPIRAL_FORM
--							      --							    --								  --
public static void antiSpiralTraversal ( int m , int n , int  void antiSpiralTraversal ( int m , int n , int a [ R ] [ C ]  void antiSpiralTraversal ( int m , int n , int a [ ] [ 2 ] )  script_not_found : None
  int i , k = 0 , l = 0 ;				      	int i , k = 0 , l = 0 ;					      int i , k = 0 , l = 0 ;					  
  Stack < Integer > stk = new Stack < Integer > ( ) ;	      	stack < int > stk ;					      stack < int > stk ;					  
  while ( k <= m && l <= n ) {				      	while ( k <= m && l <= n ) {				      while ( k <= m && l <= n ) {				  
    for ( i = l ;					      	  for ( i = l ;						    	for ( i = l ;						  
    i <= n ;						      	  i <= n ;						    	i <= n ;						  
    ++ i ) stk . push ( a [ k ] [ i ] ) ;		      	  ++ i ) stk . push ( a [ k ] [ i ] ) ;			    	++ i ) {						  
    k ++ ;						      	  k ++ ;						    	  stk . push ( a [ k ] [ i ] ) ;			  
    for ( i = k ;					      	  for ( i = k ;						    	}							  
    i <= m ;						      	  i <= m ;						    	k ++ ;							  
    ++ i ) stk . push ( a [ i ] [ n ] ) ;		      	  ++ i ) stk . push ( a [ i ] [ n ] ) ;			    	for ( i = k ;						  
    n -- ;						      	  n -- ;						    	i <= m ;						  
    if ( k <= m ) {					      	  if ( k <= m ) {					    	++ i ) {						  
      for ( i = n ;					      	    for ( i = n ;					    	  stk . push ( a [ i ] [ n ] ) ;			  
      i >= l ;						      	    i >= l ;						    	}							  
      -- i ) stk . push ( a [ m ] [ i ] ) ;		      	    -- i ) stk . push ( a [ m ] [ i ] ) ;		    	n -- ;							  
      m -- ;						      	    m -- ;						    	if ( k <= m ) {						  
    }							      	  }							    	  for ( i = n ;						  
    if ( l <= n ) {					      	  if ( l <= n ) {					    	  i >= l ;						  
      for ( i = m ;					      	    for ( i = m ;					    	  -- i ) {						  
      i >= k ;						      	    i >= k ;						    	    stk . push ( a [ m ] [ i ] ) ;			  
      -- i ) stk . push ( a [ i ] [ l ] ) ;		      	    -- i ) stk . push ( a [ i ] [ l ] ) ;		    	  }							  
      l ++ ;						      	    l ++ ;						    	  m -- ;						  
    }							      	  }							    	}							  
  }							      	}							    	if ( l <= n ) {						  
  while ( ! stk . empty ( ) ) {				      	while ( ! stk . empty ( ) ) {				    	  for ( i = m ;						  
    System . out . print ( stk . peek ( ) + " " ) ;	      	  cout << stk . top ( ) << " " ;			    	  i >= k ;						  
    stk . pop ( ) ;					      	  stk . pop ( ) ;					    	  -- i ) {						  
  }							      	}							    	    stk . push ( a [ i ] [ l ] ) ;			  
}							      }								    	  }							  
							      								    	  l ++ ;						  
							      								    	}							  
							      								      }								  
							      								      while ( ! stk . empty ( ) ) {				  
							      								    	cout << stk . top ( ) << " " ;				  
							      								    	stk . pop ( ) ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MEDIAN_ROW_WISE_SORTED_MATRIX			      FIND_MEDIAN_ROW_WISE_SORTED_MATRIX			    FIND_MEDIAN_ROW_WISE_SORTED_MATRIX				  FIND_MEDIAN_ROW_WISE_SORTED_MATRIX
--							      --							    --								  --
static int binaryMedian ( int m [ ] [ ] , int r , int c ) {   int binaryMedian ( int m [ ] [ MAX ] , int r , int c ) {	    int binaryMedian ( int m [ ] [ 2 ] , int r , int c ) {	  script_not_found : None
  int max = Integer . MIN_VALUE ;			      	int min = INT_MAX , max = INT_MIN ;			      int max = std :: numeric_limits < int > :: min ( ) ;	  
  int min = Integer . MAX_VALUE ;			      	for ( int i = 0 ;					      int min = std :: numeric_limits < int > :: max ( ) ;	  
  for ( int i = 0 ;					      	i < r ;							      for ( int i = 0 ;						  
  i < r ;						      	i ++ ) {						      i < r ;							  
  i ++ ) {						      	  if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ;	      i ++ ) {							  
    if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ;	      	  if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ;  	if ( m [ i ] [ 0 ] < min ) {				  
    if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ;  	}							    	  min = m [ i ] [ 0 ] ;					  
  }							      	int desired = ( r * c + 1 ) / 2 ;			    	}							  
  int desired = ( r * c + 1 ) / 2 ;			      	while ( min < max ) {					    	if ( m [ i ] [ c - 1 ] > max ) {			  
  while ( min < max ) {					      	  int mid = min + ( max - min ) / 2 ;			    	  max = m [ i ] [ c - 1 ] ;				  
    int mid = min + ( max - min ) / 2 ;			      	  int place = 0 ;					    	}							  
    int place = 0 ;					      	  for ( int i = 0 ;					      }								  
    int get = 0 ;					      	  i < r ;						      int desired = ( r * c + 1 ) / 2 ;				  
    for ( int i = 0 ;					      	  ++ i ) place += upper_bound ( m [ i ] , m [ i ] + c , mid   while ( min < max ) {					  
    i < r ;						      	  if ( place < desired ) min = mid + 1 ;		    	int mid = min + ( max - min ) / 2 ;			  
    ++ i ) {						      	  else max = mid ;					    	int place = 0 ;						  
      get = Arrays . binarySearch ( m [ i ] , mid ) ;	      	}							    	int get = 0 ;						  
      if ( get < 0 ) get = Math . abs ( get ) - 1 ;	      	return min ;						    	for ( int i = 0 ;					  
      else {						      }								    	i < r ;							  
	while ( get < m [ i ] . length && m [ i ] [ get ] ==  								    	++ i ) {						  
      }							      								    	  get = std :: binary_search ( m [ i ] , mid , mid ) ;	  
      place = place + get ;				      								    	  if ( get < 0 ) {					  
    }							      								    	    get = abs ( get ) - 1 ;				  
    if ( place < desired ) min = mid + 1 ;		      								    	  }							  
    else max = mid ;					      								    	  else {						  
  }							      								    	    while ( get < sizeof ( m [ i ] ) && m [ i ] [ get ] = 
  return min ;						      								    	      get += 1 ;					  
}							      								    	    }							  
							      								    	  }							  
							      								    	  place = place + get ;					  
							      								    	}							  
							      								    	if ( place < desired ) {				  
							      								    	  min = mid + 1 ;					  
							      								    	}							  
							      								    	else {							  
							      								    	  max = mid ;						  
							      								    	}							  
							      								      }								  
							      								      return min ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_GREATER_FREQUENCY_ELEMENT				      NEXT_GREATER_FREQUENCY_ELEMENT				    NEXT_GREATER_FREQUENCY_ELEMENT				  NEXT_GREATER_FREQUENCY_ELEMENT
--							      --							    --								  --
static void NFG ( int a [ ] , int n , int freq [ ] ) {	      void NFG ( int a [ ] , int n , int freq [ ] ) {		    void NFG ( int a [ ] , int n , int freq [ ] ) {		  script_not_found : None
  Stack < Integer > s = new Stack < Integer > ( ) ;	      	stack < int > s ;					      stack < int > s ;						  
  s . push ( 0 ) ;					      	s . push ( 0 ) ;					      s . push ( 0 ) ;						  
  int res [ ] = new int [ n ] ;				      	int res [ n ] = {					      int res [ n ] ;						  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < n ;						      	  ;							      i < n ;							  
  i ++ ) res [ i ] = 0 ;				      	  for ( int i = 1 ;					      i ++ ) {							  
  for ( int i = 1 ;					      	  i < n ;						    	res [ i ] = 0 ;						  
  i < n ;						      	  i ++ ) {						      }								  
  i ++ ) {						      	    if ( freq [ a [ s . top ( ) ] ] > freq [ a [ i ] ] ) s    for ( int i = 1 ;						  
    if ( freq [ a [ s . peek ( ) ] ] > freq [ a [ i ] ] ) s . 	    else {						      i < n ;							  
    else {						      	      while ( freq [ a [ s . top ( ) ] ] < freq [ a [ i ] ]   i ++ ) {							  
      while ( freq [ a [ s . peek ( ) ] ] < freq [ a [ i ] ]  		res [ s . top ( ) ] = a [ i ] ;			    	if ( freq [ a [ s . top ( ) ] ] > freq [ a [ i ] ] ) {	  
	res [ s . peek ( ) ] = a [ i ] ;		      		s . pop ( ) ;					    	  s . push ( i ) ;					  
	s . pop ( ) ;					      	      }							    	}							  
      }							      	      s . push ( i ) ;					    	else {							  
      s . push ( i ) ;					      	    }							    	  while ( freq [ a [ s . top ( ) ] ] < freq [ a [ i ] ] & 
    }							      	  }							    	    res [ s . top ( ) ] = a [ i ] ;			  
  }							      	  while ( ! s . empty ( ) ) {				    	    s . pop ( ) ;					  
  while ( s . size ( ) > 0 ) {				      	    res [ s . top ( ) ] = - 1 ;				    	  }							  
    res [ s . peek ( ) ] = - 1 ;			      	    s . pop ( ) ;					    	  s . push ( i ) ;					  
    s . pop ( ) ;					      	  }							    	}							  
  }							      	  for ( int i = 0 ;					      }								  
  for ( int i = 0 ;					      	  i < n ;						      while ( s . size ( ) > 0 ) {				  
  i < n ;						      	  i ++ ) {						    	res [ s . top ( ) ] = - 1 ;				  
  i ++ ) {						      	    cout << res [ i ] << " " ;				    	s . pop ( ) ;						  
    System . out . print ( res [ i ] + " " ) ;		      	  }							      }								  
  }							      	}							      for ( int i = 0 ;						  
}							      								      i < n ;							  
							      								      i ++ ) cout << res [ i ] << " " ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE    DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE    DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE
--							      --							    --								  --
static int lps ( String seq ) {				      int lps ( char * str ) {					    int lps ( string seq ) {					  script_not_found : None
  int n = seq . length ( ) ;				      	int n = strlen ( str ) ;				      int n = seq . length ( ) ;				  
  int i , j , cl ;					      	int i , j , cl ;					      int i , j , cl ;						  
  int L [ ] [ ] = new int [ n ] [ n ] ;			      	int L [ n ] [ n ] ;					      vector < vector < int >> L ( n , vector < int > ( n , 0 ) ) 
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) L [ i ] [ i ] = 1 ;				      	i ++ ) L [ i ] [ i ] = 1 ;				      i ++ ) {							  
  for ( cl = 2 ;					      	for ( cl = 2 ;						    	L [ i ] [ i ] = 1 ;					  
  cl <= n ;						      	cl <= n ;						      }								  
  cl ++ ) {						      	cl ++ ) {						      for ( cl = 2 ;						  
    for ( i = 0 ;					      	  for ( i = 0 ;						      cl <= n ;							  
    i < n - cl + 1 ;					      	  i < n - cl + 1 ;					      cl ++ ) {							  
    i ++ ) {						      	  i ++ ) {						    	for ( i = 0 ;						  
      j = i + cl - 1 ;					      	    j = i + cl - 1 ;					    	i < n - cl + 1 ;					  
      if ( seq . charAt ( i ) == seq . charAt ( j ) && cl ==  	    if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ]  	i ++ ) {						  
      else if ( seq . charAt ( i ) == seq . charAt ( j ) ) L  	    else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [  	  j = i + cl - 1 ;					  
      else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i +  	    else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i +  	  if ( seq [ i ] == seq [ j ] && cl == 2 ) {		  
    }							      	  }							    	    L [ i ] [ j ] = 2 ;					  
  }							      	}							    	  }							  
  return L [ 0 ] [ n - 1 ] ;				      	return L [ 0 ] [ n - 1 ] ;				    	  else if ( seq [ i ] == seq [ j ] ) {			  
}							      }								    	    L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ;		  
							      								    	  }							  
							      								    	  else {						  
							      								    	    L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] 
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return L [ 0 ] [ n - 1 ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX			      MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX			    MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX			  MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX
--							      --							    --								  --
static void maxMin ( int arr [ ] [ ] , int n ) {	      void maxMin ( int arr [ ] [ MAX ] , int n ) {		    void maxMin ( int arr [ ] [ 2 ] , int n ) {			  script_not_found : None
  int min = + 2147483647 ;				      	int min = INT_MAX ;					      int min = + 2147483647 ;					  
  int max = - 2147483648 ;				      	int max = INT_MIN ;					      int max = - 2147483648 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= n / 2 ;					      	  j <= n / 2 ;						    	j <= n / 2 ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) {      	    if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) {	    	  if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) {	  
	if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ]  	      if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ]  	    if ( min > arr [ i ] [ n - j - 1 ] ) {		  
	if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ;  	      if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ;  	      min = arr [ i ] [ n - j - 1 ] ;			  
      }							      	    }							    	    }							  
      else {						      	    else {						    	    if ( max < arr [ i ] [ j ] ) {			  
	if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ;  	      if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ;  	      max = arr [ i ] [ j ] ;				  
	if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ]  	      if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ]  	    }							  
      }							      	    }							    	  }							  
    }							      	  }							    	  else {						  
  }							      	}							    	    if ( min > arr [ i ] [ j ] ) {			  
  System . out . print ( "Maximum = " + max + ", Minimum = "  	cout << "Maximum = " << max ;				    	      min = arr [ i ] [ j ] ;				  
}							      	<< ", Minimum = " << min ;				    	    }							  
							      }								    	    if ( max < arr [ i ] [ n - j - 1 ] ) {		  
							      								    	      max = arr [ i ] [ n - j - 1 ] ;			  
							      								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      cout << "Maximum = " << max << ", Minimum = " << min << end 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE	      MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE	    MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE		  MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE
--							      --							    --								  --
static int maxLower ( String str ) {			      int maxLower ( string str ) {				    int maxLower ( string str ) {				  script_not_found : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  for ( ;						      	for ( ;							      for ( ;							  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= ' 	  if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {		    	if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {		  
      i ++ ;						      	    i ++ ;						    	  i ++ ;						  
      break ;						      	    break ;						    	  break ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  int maxCount = 0 ;					      	int maxCount = 0 ;					      int maxCount = 0 ;					  
  int count [ ] = new int [ MAX_CHAR ] ;		      	int count [ MAX_CHAR ] = {				      int count [ MAX_CHAR ] ;					  
  for ( ;						      	  0 }							      for ( int i = 0 ;						  
  i < n ;						      	  ;							      i < n ;							  
  i ++ ) {						      	  for ( ;						      i ++ ) {							  
    if ( str . charAt ( i ) >= 'A' && str . charAt ( i ) <= ' 	  i < n ;						    	if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {		  
      int currCount = 0 ;				      	  i ++ ) {						    	  int currCount = 0 ;					  
      for ( int j = 0 ;					      	    if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {	    	  for ( int j = 0 ;					  
      j < MAX_CHAR ;					      	      int currCount = 0 ;				    	  j < MAX_CHAR ;					  
      j ++ ) {						      	      for ( int j = 0 ;					    	  j ++ ) {						  
	if ( count [ j ] > 0 ) {			      	      j < MAX_CHAR ;					    	    if ( count [ j ] > 0 ) currCount ++ ;		  
	  currCount ++ ;				      	      j ++ ) if ( count [ j ] > 0 ) currCount ++ ;	    	  }							  
	}						      	      maxCount = max ( maxCount , currCount ) ;		    	  maxCount = max ( maxCount , currCount ) ;		  
      }							      	      memset ( count , 0 , sizeof ( count ) ) ;		    	  memset ( count , 0 , MAX_CHAR ) ;			  
      maxCount = Math . max ( maxCount , currCount ) ;	      	    }							    	}							  
      Arrays . fill ( count , 0 ) ;			      	    if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) count [ str 	if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) count [ str [ 
    }							      	  }							      }								  
    if ( str . charAt ( i ) >= 'a' && str . charAt ( i ) <= ' 	  return maxCount ;					      return maxCount ;						  
      count [ str . charAt ( i ) - 'a' ] ++ ;		      	}							    }								  
    }							      								    								  
  }							      								    								  
  return maxCount ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1		      FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1		    FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1			  FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1
--							      --							    --								  --
static int findGreatest ( int arr [ ] , int n ) {	      int findGreatest ( int arr [ ] , int n ) {		    int findGreatest ( int arr [ ] , int n ) {			  script_not_found : None
  Map < Integer , Integer > m = new HashMap < > ( ) ;	      	unordered_map < int , int > m ;				      map < int , int > m ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) m [ arr [ i ] ] ++ ;				      i ++ ) {							  
    if ( m . containsKey ( arr [ i ] ) ) {		      	sort ( arr , arr + n ) ;				    	if ( m . find ( arr [ i ] ) != m . end ( ) ) m [ arr [ i  
      m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ;     	for ( int i = n - 1 ;					    	else m [ arr [ i ] ] = m [ arr [ i ] ] ;		  
    }							      	i > 1 ;							      }								  
    else {						      	i -- ) {						      sort ( arr , arr + n ) ;					  
      m . put ( arr [ i ] , m . get ( arr [ i ] ) ) ;	      	  for ( int j = 0 ;					      for ( int i = n - 1 ;					  
    }							      	  j < i && arr [ j ] <= sqrt ( arr [ i ] ) ;		      i > 1 ;							  
  }							      	  j ++ ) {						      i -- ) {							  
  Arrays . sort ( arr ) ;				      	    if ( arr [ i ] % arr [ j ] == 0 ) {			    	for ( int j = 0 ;					  
  for ( int i = n - 1 ;					      	      int result = arr [ i ] / arr [ j ] ;		    	j < i && arr [ j ] <= sqrt ( arr [ i ] ) ;		  
  i > 1 ;						      	      if ( result != arr [ j ] && m [ result ] > 0 ) return 	j ++ ) {						  
  i -- ) {						      	      else if ( result == arr [ j ] && m [ result ] > 1 ) r 	  if ( arr [ i ] % arr [ j ] == 0 ) {			  
    for ( int j = 0 ;					      	    }							    	    int result = arr [ i ] / arr [ j ] ;		  
    j < i && arr [ j ] <= Math . sqrt ( arr [ i ] ) ;	      	  }							    	    if ( result != arr [ j ] && m [ result ] == 0 || m [  
    j ++ ) {						      	}							    	    else if ( result == arr [ j ] && m [ result ] > 1 ) r 
      if ( arr [ i ] % arr [ j ] == 0 ) {		      	return - 1 ;						    	  }							  
	int result = arr [ i ] / arr [ j ] ;		      }								    	}							  
	if ( result != arr [ j ] && m . get ( result ) == nul 								      }								  
	  return arr [ i ] ;				      								      return - 1 ;						  
	}						      								    }								  
	else if ( result == arr [ j ] && m . get ( result ) > 								    								  
	  return arr [ i ] ;				      								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return - 1 ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PATH_MAXIMUM_AVERAGE_VALUE				      PATH_MAXIMUM_AVERAGE_VALUE				    PATH_MAXIMUM_AVERAGE_VALUE					  PATH_MAXIMUM_AVERAGE_VALUE
--							      --							    --								  --
public static double maxAverageOfPath ( int cost [ ] [ ] , in double maxAverageOfPath ( int cost [ M ] [ M ] , int N ) {    double max_average_of_path ( int cost [ ] [ N + 1 ] , int N ) script_not_found : None
  int dp [ ] [ ] = new int [ N + 1 ] [ N + 1 ] ;	      	int dp [ N + 1 ] [ N + 1 ] ;				      int dp [ N + 1 ] [ N + 1 ] ;				  
  dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;			      	dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;			      dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;			  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 	i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0   i ++ ) {							  
  for ( int j = 1 ;					      	for ( int j = 1 ;					    	dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ;  
  j < N ;						      	j < N ;							      }								  
  j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j 	j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j   for ( int j = 1 ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      j < N ;							  
  i < N ;						      	i < N ;							      j ++ ) {							  
  i ++ ) for ( int j = 1 ;				      	i ++ ) for ( int j = 1 ;				    	dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ;  
  j < N ;						      	j <= N ;						      }								  
  j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , d 	j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ]   for ( int i = 1 ;						  
  return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ;  	return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ;    i < N ;							  
}							      }								      i ++ ) {							  
							      								    	for ( int j = 1 ;					  
							      								    	j < N ;							  
							      								    	j ++ ) {						  
							      								    	  dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [  
							      								    	}							  
							      								      }								  
							      								      return double ( dp [ N - 1 ] [ N - 1 ] ) / ( 2 * N - 1 ) ;  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING		      COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING		    COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING			  COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING
--							      --							    --								  --
static int countPS ( String str ) {			      int countPS ( string str ) {				    int countPS ( string str ) {				  error : /bin/bash: line 1: 3926910 Aborted
  int N = str . length ( ) ;				      	int N = str . length ( ) ;				      int N = str . length ( ) ;				  	   (core dumped) ./COUNT_PALINDROMIC_SUBSEQU
  int [ ] [ ] cps = new int [ N + 1 ] [ N + 1 ] ;	      	int cps [ N + 1 ] [ N + 1 ] ;				      vector < vector < int >> cps ( N + 1 , vector < int > ( N + ENCE_GIVEN_STRING_cpp
  for ( int i = 0 ;					      	memset ( cps , 0 , sizeof ( cps ) ) ;			      for ( int i = 0 ;						  
  i < N ;						      	for ( int i = 0 ;					      i < N ;							  
  i ++ ) cps [ i ] [ i ] = 1 ;				      	i < N ;							      i ++ ) {							  
  for ( int L = 2 ;					      	i ++ ) cps [ i ] [ i ] = 1 ;				    	cps [ i ] [ i ] = 1 ;					  
  L <= N ;						      	for ( int L = 2 ;					      }								  
  L ++ ) {						      	L <= N ;						      for ( int L = 2 ;						  
    for ( int i = 0 ;					      	L ++ ) {						      L <= N ;							  
    i < N ;						      	  for ( int i = 0 ;					      L ++ ) {							  
    i ++ ) {						      	  i < N ;						    	for ( int i = 0 ;					  
      int k = L + i - 1 ;				      	  i ++ ) {						    	i < N ;							  
      if ( k < N ) {					      	    int k = L + i - 1 ;					    	i ++ ) {						  
	if ( str . charAt ( i ) == str . charAt ( k ) ) cps [ 	    if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i 	  int k = L + i - 1 ;					  
	else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i  	    else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i +  	  if ( k < N ) {					  
      }							      	  }							    	    if ( str [ i ] == str [ k ] ) {			  
    }							      	}							    	      cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 
  }							      	return cps [ 0 ] [ N - 1 ] ;				    	    }							  
  return cps [ 0 ] [ N - 1 ] ;				      }								    	    else {						  
}							      								    	      cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 
							      								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return cps [ 0 ] [ N - 1 ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY		      FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY		    FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY		  FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY
--							      --							    --								  --
static int findRepeatingNumber ( int [ ] arr , int n ) {      int findRepeatingNumber ( const int arr [ ] , int n ) {	    int findRepeatingNumber ( int * arr , int n ) {		  script_not_found : None
  int sq = ( int ) Math . sqrt ( n ) ;			      	int sq = sqrt ( n ) ;					      int sq = ( int ) sqrt ( n ) ;				  
  int range = ( n / sq ) + 1 ;				      	int range = ( n / sq ) + 1 ;				      int range = ( n / sq ) + 1 ;				  
  int [ ] count = new int [ range ] ;			      	int count [ range ] = {					      int count [ range ] ;					  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i <= n ;						      	  ;							      i <= n ;							  
  i ++ ) {						      	  for ( int i = 0 ;					      i ++ ) count [ ( arr [ i ] - 1 ) / sq ] ++ ;		  
    count [ ( arr [ i ] - 1 ) / sq ] ++ ;		      	  i <= n ;						      int selected_block = range - 1 ;				  
  }							      	  i ++ ) {						      for ( int i = 0 ;						  
  int selected_block = range - 1 ;			      	    count [ ( arr [ i ] - 1 ) / sq ] ++ ;		      i < range - 1 ;						  
  for ( int i = 0 ;					      	  }							      i ++ ) {							  
  i < range - 1 ;					      	  int selected_block = range - 1 ;			    	if ( count [ i ] > sq ) {				  
  i ++ ) {						      	  for ( int i = 0 ;					    	  selected_block = i ;					  
    if ( count [ i ] > sq ) {				      	  i < range - 1 ;					    	  break ;						  
      selected_block = i ;				      	  i ++ ) {						    	}							  
      break ;						      	    if ( count [ i ] > sq ) {				      }								  
    }							      	      selected_block = i ;				      unordered_map < int , int > m ;				  
  }							      	      break ;						      for ( int i = 0 ;						  
  HashMap < Integer , Integer > m = new HashMap < > ( ) ;     	    }							      i <= n ;							  
  for ( int i = 0 ;					      	  }							      i ++ ) {							  
  i <= n ;						      	  unordered_map < int , int > m ;			    	if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i 
  i ++ ) {						      	  for ( int i = 0 ;					    	  m [ arr [ i ] ] = 1 ;					  
    if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i 	  i <= n ;						    	  if ( m [ arr [ i ] ] == 1 ) return arr [ i ] ;	  
      m . put ( arr [ i ] , 1 ) ;			      	  i ++ ) {						    	}							  
      if ( m . get ( arr [ i ] ) == 1 ) return arr [ i ] ;    	    if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [   }								  
    }							      	      m [ arr [ i ] ] ++ ;				      return - 1 ;						  
  }							      	      if ( m [ arr [ i ] ] > 1 ) return arr [ i ] ;	    }								  
  return - 1 ;						      	    }							    								  
}							      	  }							    								  
							      	  return - 1 ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING	      EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING	    EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING		  EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING
--							      --							    --								  --
static int evaluateBoolExpr ( StringBuffer s ) {	      int evaluateBoolExpr ( string s ) {			    int evaluateBoolExpr ( string s ) {				  script_not_found : None
  int n = s . length ( ) ;				      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i += 2 ) {						      	i += 2 ) {						      i += 2 ) {						  
    if ( i + 1 < n && i + 2 < n ) {			      	  if ( s [ i + 1 ] == 'A' ) {				    	if ( i + 1 < n && i + 2 < n ) {				  
      if ( s . charAt ( i + 1 ) == 'A' ) {		      	    if ( s [ i + 2 ] == '0' || s [ i ] == '0' ) s [ i + 2 ] 	  if ( s [ i + 1 ] == 'A' ) {				  
	if ( s . charAt ( i + 2 ) == '0' || s . charAt ( i )  	    else s [ i + 2 ] = '1' ;				    	    if ( s [ i + 2 ] == '0' || s [ i ] == 0 ) {		  
	else s . setCharAt ( i + 2 , '1' ) ;		      	  }							    	      s [ i + 2 ] = '0' ;				  
      }							      	  else if ( s [ i + 1 ] == 'B' ) {			    	    }							  
      else if ( ( i + 1 ) < n && s . charAt ( i + 1 ) == 'B'  	    if ( s [ i + 2 ] == '1' || s [ i ] == '1' ) s [ i + 2 ] 	    else {						  
	if ( s . charAt ( i + 2 ) == '1' || s . charAt ( i )  	    else s [ i + 2 ] = '0' ;				    	      s [ i + 2 ] = '1' ;				  
	else s . setCharAt ( i + 2 , '0' ) ;		      	  }							    	    }							  
      }							      	  else {						    	  }							  
      else {						      	    if ( s [ i + 2 ] == s [ i ] ) s [ i + 2 ] = '0' ;	    	  else if ( ( i + 1 ) < n && s [ i + 1 ] == 'B' ) {	  
	if ( s . charAt ( i + 2 ) == s . charAt ( i ) ) s . s 	    else s [ i + 2 ] = '1' ;				    	    if ( s [ i + 2 ] == '1' || s [ i ] == '1' ) {	  
	else s . setCharAt ( i + 2 , '1' ) ;		      	  }							    	      s [ i + 2 ] = '1' ;				  
      }							      	}							    	    }							  
    }							      	return s [ n - 1 ] - '0' ;				    	    else {						  
  }							      }								    	      s [ i + 2 ] = '0' ;				  
  return s . charAt ( n - 1 ) - '0' ;			      								    	    }							  
}							      								    	  }							  
							      								    	  else {						  
							      								    	    if ( s [ i + 2 ] == s [ i ] ) {			  
							      								    	      s [ i + 2 ] = '0' ;				  
							      								    	    }							  
							      								    	    else {						  
							      								    	      s [ i + 2 ] = '1' ;				  
							      								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return s [ n - 1 ] - '0' ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
static void NextFit ( int blockSize [ ] , int m , int process void NextFit ( int blockSize [ ] , int m , int processSize [  void NextFit ( int blockSize [ ] , int m , int processSize [  script_not_found : None
  int allocation [ ] = new int [ n ] , j = 0 ;		      	int allocation [ n ] , j = 0 ;				      int allocation [ n ] , j = 0 ;				  
  Arrays . fill ( allocation , - 1 ) ;			      	memset ( allocation , - 1 , sizeof ( allocation ) ) ;	      memset ( allocation , - 1 , sizeof ( allocation ) ) ;	  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    while ( j < m ) {					      	  while ( j < m ) {					    	while ( j < m ) {					  
      if ( blockSize [ j ] >= processSize [ i ] ) {	      	    if ( blockSize [ j ] >= processSize [ i ] ) {	    	  if ( blockSize [ j ] >= processSize [ i ] ) {		  
	allocation [ i ] = j ;				      	      allocation [ i ] = j ;				    	    allocation [ i ] = j ;				  
	blockSize [ j ] -= processSize [ i ] ;		      	      blockSize [ j ] -= processSize [ i ] ;		    	    blockSize [ j ] -= processSize [ i ] ;		  
	break ;						      	      break ;						    	    break ;						  
      }							      	    }							    	  }							  
      j = ( j + 1 ) % m ;				      	    j = ( j + 1 ) % m ;					    	  j = ( j + 1 ) % m ;					  
    }							      	  }							    	}							  
  }							      	}							      }								  
  System . out . print ( "\nProcess No.\tProcess Size\tBlock  	cout << "\nProcess No.\tProcess Size\tBlock no.\n" ;	      cout << "\nProcess No.\tProcess Size\tBlock no.\n" ;	  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    System . out . print ( i + 1 + "\t\t" + processSize [ i ] 	  cout << " " << i + 1 << "\t\t" << processSize [ i ] << "\ 	cout << i + 1 << "\t\t" << processSize [ i ] << "\t\t" ;  
    if ( allocation [ i ] != - 1 ) {			      	  if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 	if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 
      System . out . print ( allocation [ i ] + 1 ) ;	      	  else cout << "Not Allocated" ;			    	else cout << "Not Allocated" ;				  
    }							      	  cout << endl ;					    	cout << "\n" ;						  
    else {						      	}							      }								  
      System . out . print ( "Not Allocated" ) ;	      }								    }								  
    }							      								    								  
    System . out . println ( "" ) ;			      								    								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH			      DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH			    DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH			  DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH
--							      --							    --								  --
private static int minCost ( int cost [ ] [ ] , int m , int n int minCost ( int cost [ R ] [ C ] , int m , int n ) {	    int minCost ( int cost [ ] [ 2 ] , int m , int n ) {	  script_not_found : None
  int i , j ;						      	int i , j ;						      int i , j ;						  
  int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	int tc [ R ] [ C ] ;					      int tc [ m + 1 ] [ n + 1 ] ;				  
  tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;			      	tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;			      tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;			  
  for ( i = 1 ;						      	for ( i = 1 ;						      for ( i = 1 ;						  
  i <= m ;						      	i <= m ;						      i <= m ;							  
  i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 	i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0   i ++ ) {							  
  for ( j = 1 ;						      	for ( j = 1 ;						    	tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ;  
  j <= n ;						      	j <= n ;						      }								  
  j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j 	j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j   for ( j = 1 ;						  
  for ( i = 1 ;						      	for ( i = 1 ;						      j <= n ;							  
  i <= m ;						      	i <= m ;						      j ++ ) {							  
  i ++ ) for ( j = 1 ;					      	i ++ ) for ( j = 1 ;					    	tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ;  
  j <= n ;						      	j <= n ;						      }								  
  j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ 	j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [   for ( i = 1 ;						  
  return tc [ m ] [ n ] ;				      	return tc [ m ] [ n ] ;					      i <= m ;							  
}							      }								      i ++ ) {							  
							      								    	for ( j = 1 ;						  
							      								    	j <= n ;						  
							      								    	j ++ ) {						  
							      								    	  tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i  
							      								    	}							  
							      								      }								  
							      								      return tc [ m ] [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2	    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2
--							      --							    --								  --
void printRepeating ( int arr [ ] , int size ) {	      void printRepeating ( int arr [ ] , int size ) {		    void printRepeating ( int arr [ ] , int size ) {		  script_not_found : None
  int xor = arr [ 0 ] ;					      	int Xor = arr [ 0 ] ;					      int xor = arr [ 0 ] ;					  
  int set_bit_no ;					      	int set_bit_no ;					      int set_bit_no ;						  
  int i ;						      	int i ;							      int i ;							  
  int n = size - 2 ;					      	int n = size - 2 ;					      int n = size - 2 ;					  
  int x = 0 , y = 0 ;					      	int x = 0 , y = 0 ;					      int x = 0 , y = 0 ;					  
  for ( i = 1 ;						      	for ( i = 1 ;						      for ( i = 1 ;						  
  i < size ;						      	i < size ;						      i < size ;						  
  i ++ ) xor ^= arr [ i ] ;				      	i ++ ) Xor ^= arr [ i ] ;				      i ++ ) {							  
  for ( i = 1 ;						      	for ( i = 1 ;						    	xor ^= arr [ i ] ;					  
  i <= n ;						      	i <= n ;						      }								  
  i ++ ) xor ^= i ;					      	i ++ ) Xor ^= i ;					      for ( i = 1 ;						  
  set_bit_no = ( xor & ~ ( xor - 1 ) ) ;		      	set_bit_no = Xor & ~ ( Xor - 1 ) ;			      i <= n ;							  
  for ( i = 0 ;						      	for ( i = 0 ;						      i ++ ) {							  
  i < size ;						      	i < size ;						    	xor ^= i ;						  
  i ++ ) {						      	i ++ ) {						      }								  
    int a = arr [ i ] & set_bit_no ;			      	  if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ;	      set_bit_no = ( xor & ~ ( xor - 1 ) ) ;			  
    if ( a != 0 ) x = x ^ arr [ i ] ;			      	  else y = y ^ arr [ i ] ;				      for ( i = 0 ;						  
    else y = y ^ arr [ i ] ;				      	}							      i < size ;						  
  }							      	for ( i = 1 ;						      i ++ ) {							  
  for ( i = 1 ;						      	i <= n ;						    	int a = arr [ i ] & set_bit_no ;			  
  i <= n ;						      	i ++ ) {						    	if ( a != 0 ) {						  
  i ++ ) {						      	  if ( i & set_bit_no ) x = x ^ i ;			    	  x = x ^ arr [ i ] ;					  
    int a = i & set_bit_no ;				      	  else y = y ^ i ;					    	}							  
    if ( a != 0 ) x = x ^ i ;				      	}							    	else {							  
    else y = y ^ i ;					      	cout << "The two repeating elements are " << y << " " << x  	  y = y ^ arr [ i ] ;					  
  }							      }								    	}							  
  System . out . println ( "The two reppeated elements are :" 								      }								  
  System . out . println ( x + " " + y ) ;		      								      for ( i = 1 ;						  
}							      								      i <= n ;							  
							      								      i ++ ) {							  
							      								    	int a = i & set_bit_no ;				  
							      								    	if ( a != 0 ) {						  
							      								    	  x = x ^ i ;						  
							      								    	}							  
							      								    	else {							  
							      								    	  y = y ^ i ;						  
							      								    	}							  
							      								      }								  
							      								      cout << "The two reppeated elements are :" << endl ;	  
							      								      cout << x << " " << y << endl ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
static void firstFit ( int blockSize [ ] , int m , int proces void firstFit ( int blockSize [ ] , int m , int processSize [ void firstFit ( int blockSize [ ] , int m , int processSize [ script_not_found : None
  int allocation [ ] = new int [ n ] ;			      	int allocation [ n ] ;					      int allocation [ n ] ;					  
  for ( int i = 0 ;					      	memset ( allocation , - 1 , sizeof ( allocation ) ) ;	      for ( int i = 0 ;						  
  i < allocation . length ;				      	for ( int i = 0 ;					      i < sizeof ( allocation ) / sizeof ( allocation [ 0 ] ) ;	  
  i ++ ) allocation [ i ] = - 1 ;			      	i < n ;							      i ++ ) {							  
  for ( int i = 0 ;					      	i ++ ) {						    	allocation [ i ] = - 1 ;				  
  i < n ;						      	  for ( int j = 0 ;					      }								  
  i ++ ) {						      	  j < m ;						      for ( int i = 0 ;						  
    for ( int j = 0 ;					      	  j ++ ) {						      i < n ;							  
    j < m ;						      	    if ( blockSize [ j ] >= processSize [ i ] ) {	      i ++ ) {							  
    j ++ ) {						      	      allocation [ i ] = j ;				    	for ( int j = 0 ;					  
      if ( blockSize [ j ] >= processSize [ i ] ) {	      	      blockSize [ j ] -= processSize [ i ] ;		    	j < m ;							  
	allocation [ i ] = j ;				      	      break ;						    	j ++ ) {						  
	blockSize [ j ] -= processSize [ i ] ;		      	    }							    	  if ( blockSize [ j ] >= processSize [ i ] ) {		  
	break ;						      	  }							    	    allocation [ i ] = j ;				  
      }							      	}							    	    blockSize [ j ] -= processSize [ i ] ;		  
    }							      	cout << "\nProcess No.\tProcess Size\tBlock no.\n" ;	    	    break ;						  
  }							      	for ( int i = 0 ;					    	  }							  
  System . out . println ( "\nProcess No.\tProcess Size\tBloc 	i < n ;							    	}							  
  for ( int i = 0 ;					      	i ++ ) {						      }								  
  i < n ;						      	  cout << " " << i + 1 << "\t\t" << processSize [ i ] << "\   cout << "\nProcess No.\tProcess Size\tBlock no." << endl ;  
  i ++ ) {						      	  if ( allocation [ i ] != - 1 ) cout << allocation [ i ] +   for ( int i = 0 ;						  
    System . out . print ( " " + ( i + 1 ) + "\t\t" + process 	  else cout << "Not Allocated" ;			      i < n ;							  
    if ( allocation [ i ] != - 1 ) System . out . print ( all 	  cout << endl ;					      i ++ ) {							  
    else System . out . print ( "Not Allocated" ) ;	      	}							    	cout << " " << ( i + 1 ) << "\t\t" << processSize [ i ] < 
    System . out . println ( ) ;			      }								    	if ( allocation [ i ] != - 1 ) {			  
  }							      								    	  cout << allocation [ i ] + 1 << endl ;		  
}							      								    	}							  
							      								    	else {							  
							      								    	  cout << "Not Allocated" << endl ;			  
							      								    	}							  
							      								    	cout << endl ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY		      FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY			    FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY			  FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY
--							      --							    --								  --
static int minAdjustmentCost ( int A [ ] , int n , int target int minAdjustmentCost ( int A [ ] , int n , int target ) {    int minAdjustmentCost ( int A [ ] , int n , int target ) {	  script_not_found : None
  int [ ] [ ] dp = new int [ n ] [ M + 1 ] ;		      	int dp [ n ] [ M + 1 ] ;				      vector < vector < int >> dp ( n , vector < int > ( M + 1 ,  
  for ( int j = 0 ;					      	for ( int j = 0 ;					      for ( int j = 0 ;						  
  j <= M ;						      	j <= M ;						      j <= M ;							  
  j ++ ) dp [ 0 ] [ j ] = Math . abs ( j - A [ 0 ] ) ;	      	j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ;		      j ++ ) {							  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ;			  
  i < n ;						      	i < n ;							      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 1 ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      i < n ;							  
    j <= M ;						      	  j <= M ;						      i ++ ) {							  
    j ++ ) {						      	  j ++ ) {						    	for ( int j = 0 ;					  
      dp [ i ] [ j ] = Integer . MAX_VALUE ;		      	    dp [ i ] [ j ] = INT_MAX ;				    	j <= M ;						  
      int k = Math . max ( j - target , 0 ) ;		      	    for ( int k = max ( j - target , 0 ) ;		    	j ++ ) {						  
      for ( ;						      	    k <= min ( M , j + target ) ;			    	  dp [ i ] [ j ] = INT_MAX ;				  
      k <= Math . min ( M , j + target ) ;		      	    k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 	  int k = max ( j - target , 0 ) ;			  
      k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , d 	  }							    	  for ( ;						  
    }							      	}							    	  k <= min ( M , j + target ) ;				  
  }							      	int res = INT_MAX ;					    	  k ++ ) {						  
  int res = Integer . MAX_VALUE ;			      	for ( int j = 0 ;					    	    dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ]  
  for ( int j = 0 ;					      	j <= M ;						    	  }							  
  j <= M ;						      	j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ;		    	}							  
  j ++ ) res = Math . min ( res , dp [ n - 1 ] [ j ] ) ;      	return res ;						      }								  
  return res ;						      }								      int res = INT_MAX ;					  
}							      								      for ( int j = 0 ;						  
							      								      j <= M ;							  
							      								      j ++ ) {							  
							      								    	res = min ( res , dp [ n - 1 ] [ j ] ) ;		  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY			      MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY			    MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY				  MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY
--							      --							    --								  --
static double largestSumOfAverages ( int [ ] A , int K ) {    double largestSumOfAverages ( vector < int > & A , int K ) {  double largestSumOfAverages ( vector < int > A , int K ) {	  success : None
  int n = A . length ;					      	int n = A . size ( ) ;					      int n = A . size ( ) ;					  
  double [ ] pre_sum = new double [ n + 1 ] ;		      	double pre_sum [ n + 1 ] ;				      vector < double > pre_sum ( n + 1 , 0 ) ;			  
  pre_sum [ 0 ] = 0 ;					      	pre_sum [ 0 ] = 0 ;					      pre_sum [ 0 ] = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ;	      	i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ;	      i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ;	  
  double [ ] dp = new double [ n ] ;			      	double dp [ n ] = {					      vector < double > dp ( n , 0 ) ;				  
  double sum = 0 ;					      	  0 }							      double sum = 0 ;						  
  for ( int i = 0 ;					      	  ;							      for ( int i = 0 ;						  
  i < n ;						      	  double sum = 0 ;					      i < n ;							  
  i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - 	  for ( int i = 0 ;					      i ++ ) {							  
  for ( int k = 0 ;					      	  i < n ;						    	dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i )  
  k < K - 1 ;						      	  i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n   }								  
  k ++ ) for ( int i = 0 ;				      	  for ( int k = 0 ;					      for ( int k = 0 ;						  
  i < n ;						      	  k < K - 1 ;						      k < K - 1 ;						  
  i ++ ) for ( int j = i + 1 ;				      	  k ++ ) for ( int i = 0 ;				      k ++ ) for ( int i = 0 ;					  
  j < n ;						      	  i < n ;						      i < n ;							  
  j ++ ) dp [ i ] = Math . max ( dp [ i ] , ( pre_sum [ j ] - 	  i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
  return dp [ 0 ] ;					      	  j < n ;						      j < n ;							  
}							      	  j ++ ) dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_   j ++ ) dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_su 
							      	  return dp [ 0 ] ;					      return dp [ 0 ] ;						  
							      	}							    }								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_PRODUCT_TWO_ARRAYS				      MINIMUM_SUM_PRODUCT_TWO_ARRAYS				    MINIMUM_SUM_PRODUCT_TWO_ARRAYS				  MINIMUM_SUM_PRODUCT_TWO_ARRAYS
--							      --							    --								  --
static int minproduct ( int a [ ] , int b [ ] , int n , int k int minproduct ( int a [ ] , int b [ ] , int n , int k ) {    int minproduct ( int a [ ] , int b [ ] , int n , int k ) {	  success : None
  int diff = 0 , res = 0 ;				      	int diff = 0 , res = 0 ;				      int diff = 0 , res = 0 ;					  
  int temp = 0 ;					      	int temp ;						      int temp = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int pro = a [ i ] * b [ i ] ;			      	  int pro = a [ i ] * b [ i ] ;				    	int pro = a [ i ] * b [ i ] ;				  
    res = res + pro ;					      	  res = res + pro ;					    	res = res + pro ;					  
    if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k )  	  if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k )  	if ( pro < 0 && b [ i ] < 0 ) {				  
    else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * 	  else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * 	  temp = ( a [ i ] + 2 * k ) * b [ i ] ;		  
    else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * 	  else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * 	}							  
    else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * 	  else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * 	else if ( pro < 0 && a [ i ] < 0 ) {			  
    int d = Math . abs ( pro - temp ) ;			      	  int d = abs ( pro - temp ) ;				    	  temp = ( a [ i ] - 2 * k ) * b [ i ] ;		  
    if ( d > diff ) diff = d ;				      	  if ( d > diff ) diff = d ;				    	}							  
  }							      	}							    	else if ( pro > 0 && a [ i ] < 0 ) {			  
  return res - diff ;					      	return res - diff ;					    	  temp = ( a [ i ] + 2 * k ) * b [ i ] ;		  
}							      }								    	}							  
							      								    	else if ( pro > 0 && a [ i ] > 0 ) {			  
							      								    	  temp = ( a [ i ] - 2 * k ) * b [ i ] ;		  
							      								    	}							  
							      								    	int d = abs ( pro - temp ) ;				  
							      								    	if ( d > diff ) {					  
							      								    	  diff = d ;						  
							      								    	}							  
							      								      }								  
							      								      return res - diff ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY		      COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY		    COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY		  COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY
--							      --							    --								  --
static int numofAP ( int a [ ] , int n ) {		      int numofAP ( int a [ ] , int n ) {			    int numofAP ( int a [ ] , int n ) {				  script_not_found : None
  int minarr = + 2147483647 ;				      	int minarr = INT_MAX , maxarr = INT_MIN ;		      int minarr = + 2147483647 ;				  
  int maxarr = - 2147483648 ;				      	for ( int i = 0 ;					      int maxarr = - 2147483648 ;				  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) {						      i < n ;							  
  i ++ ) {						      	  minarr = min ( minarr , a [ i ] ) ;			      i ++ ) {							  
    minarr = Math . min ( minarr , a [ i ] ) ;		      	  maxarr = max ( maxarr , a [ i ] ) ;			    	minarr = min ( minarr , a [ i ] ) ;			  
    maxarr = Math . max ( maxarr , a [ i ] ) ;		      	}							    	maxarr = max ( maxarr , a [ i ] ) ;			  
  }							      	int dp [ n ] , sum [ MAX ] ;				      }								  
  int dp [ ] = new int [ n ] ;				      	int ans = n + 1 ;					      int dp [ n ] ;						  
  int sum [ ] = new int [ MAX ] ;			      	for ( int d = ( minarr - maxarr ) ;			      int sum [ MAX ] ;						  
  int ans = n + 1 ;					      	d <= ( maxarr - minarr ) ;				      int ans = n + 1 ;						  
  for ( int d = ( minarr - maxarr ) ;			      	d ++ ) {						      for ( int d = ( minarr - maxarr ) ;			  
  d <= ( maxarr - minarr ) ;				      	  memset ( sum , 0 , sizeof sum ) ;			      d <= ( maxarr - minarr ) ;				  
  d ++ ) {						      	  for ( int i = 0 ;					      d ++ ) {							  
    Arrays . fill ( sum , 0 ) ;				      	  i < n ;						    	memset ( sum , 0 , sizeof ( sum ) ) ;			  
    for ( int i = 0 ;					      	  i ++ ) {						    	for ( int i = 0 ;					  
    i < n ;						      	    dp [ i ] = 1 ;					    	i < n ;							  
    i ++ ) {						      	    if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [  	i ++ ) {						  
      dp [ i ] = 1 ;					      	    ans += dp [ i ] - 1 ;				    	  dp [ i ] = 1 ;					  
      if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [  	    sum [ a [ i ] ] += dp [ i ] ;			    	  if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) {	  
      ans += dp [ i ] - 1 ;				      	  }							    	    dp [ i ] += sum [ a [ i ] - d ] ;			  
      sum [ a [ i ] ] += dp [ i ] ;			      	}							    	  }							  
    }							      	return ans ;						    	  ans += dp [ i ] - 1 ;					  
  }							      }								    	  sum [ a [ i ] ] += dp [ i ] ;				  
  return ans ;						      								    	}							  
}							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT
--							      --							    --								  --
static int maxNumOfChocolates ( int arr [ ] , int n , int k ) int maxNumOfChocolates ( int arr [ ] , int n , int k ) {	    int maxNumOfChocolates ( int arr [ ] , int n , int k ) {	  error : /bin/bash: line 1: 3926948 Segmentation fa
  HashMap < Integer , Integer > um = new HashMap < Integer ,  	unordered_map < int , int > um ;			      unordered_map < int , int > um ;				  ult	   (core dumped) ./MAXIMUM_NUMBER_CHOCOLATES
  int [ ] sum = new int [ n ] ;				      	int sum [ n ] , curr_rem ;				      vector < int > sum ;					  _DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS_cpp
  int curr_rem ;					      	int maxSum = 0 ;					      int curr_rem ;						  
  int maxSum = 0 ;					      	sum [ 0 ] = arr [ 0 ] ;					      int max_sum = 0 ;						  
  sum [ 0 ] = arr [ 0 ] ;				      	for ( int i = 1 ;					      sum [ 0 ] = arr [ 0 ] ;					  
  for ( int i = 1 ;					      	i < n ;							      for ( int i = 1 ;						  
  i < n ;						      	i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ;		      i < n ;							  
  i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ;	      	for ( int i = 0 ;					      i ++ ) {							  
  for ( int i = 0 ;					      	i < n ;							    	sum [ i ] = sum [ i - 1 ] + arr [ i ] ;			  
  i < n ;						      	i ++ ) {						      }								  
  i ++ ) {						      	  curr_rem = sum [ i ] % k ;				      for ( int i = 0 ;						  
    curr_rem = sum [ i ] % k ;				      	  if ( curr_rem == 0 ) {				      i < n ;							  
    if ( curr_rem == 0 ) {				      	    if ( maxSum < sum [ i ] ) maxSum = sum [ i ] ;	      i ++ ) {							  
      if ( maxSum < sum [ i ] ) maxSum = sum [ i ] ;	      	  }							    	curr_rem = sum [ i ] % k ;				  
    }							      	  else if ( um . find ( curr_rem ) == um . end ( ) ) um [ c 	if ( curr_rem == 0 ) {					  
    else if ( ! um . containsKey ( curr_rem ) ) um . put ( cu 	  else if ( maxSum < ( sum [ i ] - sum [ um [ curr_rem ] ]  	  if ( max_sum < sum [ i ] ) {				  
    else if ( maxSum < ( sum [ i ] - sum [ um . get ( curr_re 	}							    	    max_sum = sum [ i ] ;				  
  }							      	return ( maxSum / k ) ;					    	  }							  
  return ( maxSum / k ) ;				      }								    	}							  
}							      								    	else if ( ! um . count ( curr_rem ) ) {			  
							      								    	  um [ curr_rem ] = i ;					  
							      								    	}							  
							      								    	else if ( max_sum < ( sum [ i ] - sum [ um [ curr_rem ] ] 
							      								    	  max_sum = sum [ i ] - sum [ um [ curr_rem ] ] ;	  
							      								    	}							  
							      								      }								  
							      								      return ( max_sum / k ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTANCE_NEAREST_CELL_1_BINARY_MATRIX			      DISTANCE_NEAREST_CELL_1_BINARY_MATRIX			    DISTANCE_NEAREST_CELL_1_BINARY_MATRIX			  DISTANCE_NEAREST_CELL_1_BINARY_MATRIX
--							      --							    --								  --
static void printDistance ( int mat [ ] [ ] ) {		      void printDistance ( int mat [ N ] [ M ] ) {		    void printDistance ( int mat [ N ] [ M ] ) {		  script_not_found : None
  int ans [ ] [ ] = new int [ N ] [ M ] ;		      	int ans [ N ] [ M ] ;					      int ans [ N ] [ M ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < M ;						      	j < M ;							      j < M ;							  
  j ++ ) ans [ i ] [ j ] = Integer . MAX_VALUE ;	      	j ++ ) ans [ i ] [ j ] = INT_MAX ;			      j ++ ) ans [ i ] [ j ] = INT_MAX ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < M ;						      	j < M ;							      j < M ;							  
  j ++ ) {						      	j ++ ) {						      j ++ ) {							  
    for ( int k = 0 ;					      	  for ( int k = 0 ;					    	for ( int k = 0 ;					  
    k < N ;						      	  k < N ;						    	k < N ;							  
    k ++ ) for ( int l = 0 ;				      	  k ++ ) for ( int l = 0 ;				    	k ++ ) for ( int l = 0 ;				  
    l < M ;						      	  l < M ;						    	l < M ;							  
    l ++ ) {						      	  l ++ ) {						    	l ++ ) {						  
      if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . mi 	    if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = min ( ans 	  if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = min ( ans 
    }							      	  }							    	}							  
  }							      	}							      }								  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < N ;						      	i < N ;							      i < N ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < M ;						      	  j < M ;						    	j < M ;							  
    j ++ ) System . out . print ( ans [ i ] [ j ] + " " ) ;   	  j ++ ) cout << ans [ i ] [ j ] << " " ;		    	j ++ ) cout << ans [ i ] [ j ] << " " ;			  
    System . out . println ( ) ;			      	  cout << endl ;					    	cout << endl ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE    MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE    MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE	  MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE
--							      --							    --								  --
static int maxProfit ( int price [ ] , int n ) {	      int maxProfit ( int price [ ] , int n ) {			    int maxProfit ( int price [ ] , int n ) {			  success : None
  int profit [ ] = new int [ n ] ;			      	int * profit = new int [ n ] ;				      int profit [ n ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) profit [ i ] = 0 ;				      	i ++ ) profit [ i ] = 0 ;				      i ++ ) {							  
  int max_price = price [ n - 1 ] ;			      	int max_price = price [ n - 1 ] ;			    	profit [ i ] = 0 ;					  
  for ( int i = n - 2 ;					      	for ( int i = n - 2 ;					      }								  
  i >= 0 ;						      	i >= 0 ;						      int maxPrice = price [ n - 1 ] ;				  
  i -- ) {						      	i -- ) {						      for ( int i = n - 2 ;					  
    if ( price [ i ] > max_price ) max_price = price [ i ] ;  	  if ( price [ i ] > max_price ) max_price = price [ i ] ;    i >= 0 ;							  
    profit [ i ] = Math . max ( profit [ i + 1 ] , max_price  	  profit [ i ] = max ( profit [ i + 1 ] , max_price - price   i -- ) {							  
  }							      	}							    	if ( price [ i ] > maxPrice ) {				  
  int min_price = price [ 0 ] ;				      	int min_price = price [ 0 ] ;				    	  maxPrice = price [ i ] ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					    	}							  
  i < n ;						      	i < n ;							    	profit [ i ] = max ( profit [ i + 1 ] , maxPrice - price  
  i ++ ) {						      	i ++ ) {						      }								  
    if ( price [ i ] < min_price ) min_price = price [ i ] ;  	  if ( price [ i ] < min_price ) min_price = price [ i ] ;    int minPrice = price [ 0 ] ;				  
    profit [ i ] = Math . max ( profit [ i - 1 ] , profit [ i 	  profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + (    for ( int i = 1 ;						  
  }							      	}							      i < n ;							  
  int result = profit [ n - 1 ] ;			      	int result = profit [ n - 1 ] ;				      i ++ ) {							  
  return result ;					      	delete [ ] profit ;					    	if ( price [ i ] < minPrice ) {				  
}							      	return result ;						    	  minPrice = price [ i ] ;				  
							      }								    	}							  
							      								    	profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + (  
							      								      }								  
							      								      int result = profit [ n - 1 ] ;				  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES      PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES	    PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES	  PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES
--							      --							    --								  --
static void constructTree ( int n , int d , int h ) {	      void constructTree ( int n , int d , int h ) {		    void constructTree ( int n , int d , int h ) {		  script_not_found : None
  if ( d == 1 ) {					      	if ( d == 1 ) {						      if ( d == 1 ) {						  
    if ( n == 2 && h == 1 ) {				      	  if ( n == 2 && h == 1 ) {				    	if ( n == 2 && h == 1 ) {				  
      System . out . println ( "1 2" ) ;		      	    cout << "1 2" << endl ;				    	  cout << "1 2" << endl ;				  
      return ;						      	    return ;						    	  return ;						  
    }							      	  }							    	}							  
    System . out . println ( "-1" ) ;			      	  cout << "-1" << endl ;				    	cout << "-1" << endl ;					  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( d > 2 * h ) {					      	if ( d > 2 * h ) {					      if ( d > 2 * h ) {					  
    System . out . println ( "-1" ) ;			      	  cout << "-1" << endl ;				    	cout << "-1" << endl ;					  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= h ;						      	i <= h ;						      i <= h ;							  
  i ++ ) System . out . println ( i + " " + ( i + 1 ) ) ;     	i ++ ) cout << i << " " << i + 1 << endl ;		      i ++ ) {							  
  if ( d > h ) {					      	if ( d > h ) {						    	cout << i << " " << ( i + 1 ) << endl ;			  
    System . out . println ( "1" + " " + ( h + 2 ) ) ;	      	  cout << "1" << " " << h + 2 << endl ;			      }								  
    for ( int i = h + 2 ;				      	  for ( int i = h + 2 ;					      if ( d > h ) {						  
    i <= d ;						      	  i <= d ;						    	cout << "1" << " " << ( h + 2 ) << endl ;		  
    i ++ ) {						      	  i ++ ) {						    	for ( int i = h + 2 ;					  
      System . out . println ( i + " " + ( i + 1 ) ) ;	      	    cout << i << " " << i + 1 << endl ;			    	i <= d ;						  
    }							      	  }							    	i ++ ) {						  
  }							      	}							    	  cout << i << " " << ( i + 1 ) << endl ;		  
  for ( int i = d + 1 ;					      	for ( int i = d + 1 ;					    	}							  
  i < n ;						      	i < n ;							      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = d + 1 ;					  
    int k = 1 ;						      	  int k = 1 ;						      i < n ;							  
    if ( d == h ) k = 2 ;				      	  if ( d == h ) k = 2 ;					      i ++ ) {							  
    System . out . println ( k + " " + ( i + 1 ) ) ;	      	  cout << k << " " << i + 1 << endl ;			    	int k = 1 ;						  
  }							      	}							    	if ( d == h ) {						  
}							      }								    	  k = 2 ;						  
							      								    	}							  
							      								    	cout << k << " " << ( i + 1 ) << endl ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE		      FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE			    FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE			  FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE
--							      --							    --								  --
static int sumNodes ( int l ) {				      int sumNodes ( int l ) {					    int sumNodes ( int l ) {					  script_not_found : None
  int leafNodeCount = ( int ) Math . pow ( 2 , l - 1 ) ;      	int leafNodeCount = pow ( 2 , l - 1 ) ;			      int leafNodeCount = ( int ) pow ( 2 , l - 1 ) ;		  
  Vector < Vector < Integer >> vec = new Vector < Vector < In 	vector < int > vec [ l ] ;				      vector < vector < int >> vec ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= l ;						      	i <= leafNodeCount ;					      i <= l ;							  
  i ++ ) vec . add ( new Vector < Integer > ( ) ) ;	      	i ++ ) vec [ l - 1 ] . push_back ( i ) ;		      i ++ ) {							  
  for ( int i = 1 ;					      	for ( int i = l - 2 ;					    	vec . push_back ( vector < int > ( ) ) ;		  
  i <= leafNodeCount ;					      	i >= 0 ;						      }								  
  i ++ ) vec . get ( l - 1 ) . add ( i ) ;		      	i -- ) {						      for ( int i = 1 ;						  
  for ( int i = l - 2 ;					      	  int k = 0 ;						      i <= leafNodeCount ;					  
  i >= 0 ;						      	  while ( k < vec [ i + 1 ] . size ( ) - 1 ) {		      i ++ ) {							  
  i -- ) {						      	    vec [ i ] . push_back ( vec [ i + 1 ] [ k ] + vec [ i + 	vec [ l - 1 ] . push_back ( i ) ;			  
    int k = 0 ;						      	    k += 2 ;						      }								  
    while ( k < vec . get ( i + 1 ) . size ( ) - 1 ) {	      	  }							      for ( int i = l - 2 ;					  
      vec . get ( i ) . add ( vec . get ( i + 1 ) . get ( k ) 	}							      i >= 0 ;							  
      k += 2 ;						      	int sum = 0 ;						      i -- ) {							  
    }							      	for ( int i = 0 ;					    	int k = 0 ;						  
  }							      	i < l ;							    	while ( k < vec [ i + 1 ] . size ( ) - 1 ) {		  
  int sum = 0 ;						      	i ++ ) {						    	  vec [ i ] . push_back ( vec [ i + 1 ] [ k ] + vec [ i + 
  for ( int i = 0 ;					      	  for ( int j = 0 ;					    	  k += 2 ;						  
  i < l ;						      	  j < vec [ i ] . size ( ) ;				    	}							  
  i ++ ) {						      	  j ++ ) sum += vec [ i ] [ j ] ;			      }								  
    for ( int j = 0 ;					      	}							      int sum = 0 ;						  
    j < vec . get ( i ) . size ( ) ;			      	return sum ;						      for ( int i = 0 ;						  
    j ++ ) sum += vec . get ( i ) . get ( j ) ;		      }								      i < l ;							  
  }							      								      i ++ ) {							  
  return sum ;						      								    	for ( int j = 0 ;					  
}							      								    	j < vec [ i ] . size ( ) ;				  
							      								    	j ++ ) {						  
							      								    	  sum += vec [ i ] [ j ] ;				  
							      								    	}							  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER		      CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER		    CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER			  CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER
--							      --							    --								  --
static boolean check ( String s1 , String s2 ) {	      bool check ( string s1 , string s2 ) {			    bool check ( string s1 , string s2 ) {			  failure : #Results: 7, 10
  int n = s1 . length ( ) ;				      	int n = s1 . length ( ) ;				      int n = s1 . length ( ) ;					  
  int m = s2 . length ( ) ;				      	int m = s2 . length ( ) ;				      int m = s2 . length ( ) ;					  
  boolean dp [ ] [ ] = new boolean [ n + 1 ] [ m + 1 ] ;      	bool dp [ n + 1 ] [ m + 1 ] ;				      bool dp [ n + 1 ] [ m + 1 ] ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= m ;						      	  j <= m ;						    	j <= m ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) dp [ i ] [ j ] = false ;				  
      dp [ i ] [ j ] = false ;				      	    dp [ i ] [ j ] = false ;				      }								  
    }							      	  }							      dp [ 0 ] [ 0 ] = true ;					  
  }							      	}							      for ( int i = 0 ;						  
  dp [ 0 ] [ 0 ] = true ;				      	dp [ 0 ] [ 0 ] = true ;					      i < s1 . length ( ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      i ++ ) {							  
  i < s1 . length ( ) ;					      	i < s1 . length ( ) ;					    	for ( int j = 0 ;					  
  i ++ ) {						      	i ++ ) {						    	j <= s2 . length ( ) ;					  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	j ++ ) {						  
    j <= s2 . length ( ) ;				      	  j <= s2 . length ( ) ;				    	  if ( dp [ i ] [ j ] ) {				  
    j ++ ) {						      	  j ++ ) {						    	    if ( j < s2 . length ( ) && ( toupper ( s1 [ i ] ) == 
      if ( dp [ i ] [ j ] ) {				      	    if ( dp [ i ] [ j ] ) {				    	      dp [ i + 1 ] [ j + 1 ] = true ;			  
	if ( j < s2 . length ( ) && ( Character . toUpperCase 	      if ( j < s2 . length ( ) && ( toupper ( s1 [ i ] ) == 	    }							  
	if ( ! Character . isUpperCase ( s1 . charAt ( i ) )  	      if ( ! isupper ( s1 [ i ] ) ) dp [ i + 1 ] [ j ] = tr 	    if ( ! toupper ( s1 [ i ] ) ) {			  
      }							      	    }							    	      dp [ i + 1 ] [ j ] = true ;			  
    }							      	  }							    	    }							  
  }							      	}							    	  }							  
  return ( dp [ n ] [ m ] ) ;				      	return ( dp [ n ] [ m ] ) ;				    	}							  
}							      }								      }								  
							      								      return ( dp [ n ] [ m ] ) ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_LONGEST_BALANCED_SUBSEQUENCE			      LENGTH_LONGEST_BALANCED_SUBSEQUENCE			    LENGTH_LONGEST_BALANCED_SUBSEQUENCE				  LENGTH_LONGEST_BALANCED_SUBSEQUENCE
--							      --							    --								  --
static int maxLength ( String s , int n ) {		      int maxLength ( char s [ ] , int n ) {			    int maxLength ( string s , int n ) {			  success : None
  int dp [ ] [ ] = new int [ n ] [ n ] ;		      	int dp [ n ] [ n ] ;					      vector < vector < int >> dp ( n , vector < int > ( n , 0 )  
  for ( int i = 0 ;					      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int i = 0 ;						  
  i < n - 1 ;						      	for ( int i = 0 ;					      i < n - 1 ;						  
  i ++ ) if ( s . charAt ( i ) == '(' && s . charAt ( i + 1 ) 	i < n - 1 ;						      i ++ ) if ( s [ i ] == '(' && s [ i + 1 ] == ')' ) dp [ i ] 
  for ( int l = 2 ;					      	i ++ ) if ( s [ i ] == '(' && s [ i + 1 ] == ')' ) dp [ i ]   for ( int l = 2 ;						  
  l < n ;						      	for ( int l = 2 ;					      l < n ;							  
  l ++ ) {						      	l < n ;							      l ++ ) {							  
    for ( int i = 0 , j = l ;				      	l ++ ) {						    	for ( int i = 0 , j = l ;				  
    j < n ;						      	  for ( int i = 0 , j = l ;				    	j < n ;							  
    i ++ , j ++ ) {					      	  j < n ;						    	i ++ , j ++ ) {						  
      if ( s . charAt ( i ) == '(' && s . charAt ( j ) == ')' 	  i ++ , j ++ ) {					    	  if ( s [ i ] == '(' && s [ j ] == ')' ) dp [ i ] [ j ]  
      for ( int k = i ;					      	    if ( s [ i ] == '(' && s [ j ] == ')' ) dp [ i ] [ j ]  	  for ( int k = i ;					  
      k < j ;						      	    for ( int k = i ;					    	  k < j ;						  
      k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , d 	    k < j ;						    	  k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] 
    }							      	    k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] 	}							  
  }							      	  }							      }								  
  return dp [ 0 ] [ n - 1 ] ;				      	}							      return dp [ 0 ] [ n - 1 ] ;				  
}							      	return dp [ 0 ] [ n - 1 ] ;				    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS  COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS  COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS  COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS
--							      --							    --								  --
static int countStrings ( int n , int k ) {		      int countStrings ( int n , int k ) {			    int countStrings ( int n , int k ) {			  script_not_found : None
  int dp [ ] [ ] [ ] = new int [ n + 1 ] [ k + 1 ] [ 2 ] ;    	int dp [ n + 1 ] [ k + 1 ] [ 2 ] ;			      vector < vector < int >> dp ( n + 1 , vector < int > ( k +  
  dp [ 1 ] [ 0 ] [ 0 ] = 1 ;				      	memset ( dp , 0 , sizeof ( dp ) ) ;			      dp [ 1 ] [ 0 ] [ 0 ] = 1 ;				  
  dp [ 1 ] [ 0 ] [ 1 ] = 1 ;				      	dp [ 1 ] [ 0 ] [ 0 ] = 1 ;				      dp [ 1 ] [ 0 ] [ 1 ] = 1 ;				  
  for ( int i = 2 ;					      	dp [ 1 ] [ 0 ] [ 1 ] = 1 ;				      for ( int i = 2 ;						  
  i <= n ;						      	for ( int i = 2 ;					      i <= n ;							  
  i ++ ) {						      	i <= n ;						      i ++ ) {							  
    for ( int j = 0 ;					      	i ++ ) {						    	for ( int j = 0 ;					  
    j < i && j < k + 1 ;				      	  for ( int j = 0 ;					    	j < i && j < k + 1 ;					  
    j ++ ) {						      	  j < i ;						    	j ++ ) {						  
      dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [  	  j ++ ) {						    	  dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [  
      dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;	      	    dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [  	  dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;	  
      if ( j - 1 >= 0 ) {				      	    dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;	    	  if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ]  
	dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ]  	    if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ]  	}							  
      }							      	  }							      }								  
    }							      	}							      return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ;	  
  }							      	return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ;	    }								  
  return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ;	      }								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1	      DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1		    DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1		  DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1
--							      --							    --								  --
static int eggDrop ( int n , int k ) {			      int eggDrop ( int n , int k ) {				    int eggDrop ( int n , int k ) {				  success : None
  int eggFloor [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ;	      	int eggFloor [ n + 1 ] [ k + 1 ] ;			      int eggFloor [ n + 1 ] [ k + 1 ] ;			  
  int res ;						      	int res ;						      int res ;							  
  int i , j , x ;					      	int i , j , x ;						      int i , j , x ;						  
  for ( i = 1 ;						      	for ( i = 1 ;						      for ( i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    eggFloor [ i ] [ 1 ] = 1 ;				      	  eggFloor [ i ] [ 1 ] = 1 ;				    	eggFloor [ i ] [ 1 ] = 1 ;				  
    eggFloor [ i ] [ 0 ] = 0 ;				      	  eggFloor [ i ] [ 0 ] = 0 ;				    	eggFloor [ i ] [ 0 ] = 0 ;				  
  }							      	}							      }								  
  for ( j = 1 ;						      	for ( j = 1 ;						      for ( j = 1 ;						  
  j <= k ;						      	j <= k ;						      j <= k ;							  
  j ++ ) eggFloor [ 1 ] [ j ] = j ;			      	j ++ ) eggFloor [ 1 ] [ j ] = j ;			      j ++ ) {							  
  for ( i = 2 ;						      	for ( i = 2 ;						    	eggFloor [ 1 ] [ j ] = j ;				  
  i <= n ;						      	i <= n ;						      }								  
  i ++ ) {						      	i ++ ) {						      for ( i = 2 ;						  
    for ( j = 2 ;					      	  for ( j = 2 ;						      i <= n ;							  
    j <= k ;						      	  j <= k ;						      i ++ ) {							  
    j ++ ) {						      	  j ++ ) {						    	for ( j = 2 ;						  
      eggFloor [ i ] [ j ] = Integer . MAX_VALUE ;	      	    eggFloor [ i ] [ j ] = INT_MAX ;			    	j <= k ;						  
      for ( x = 1 ;					      	    for ( x = 1 ;					    	j ++ ) {						  
      x <= j ;						      	    x <= j ;						    	  eggFloor [ i ] [ j ] = INT_MAX ;			  
      x ++ ) {						      	    x ++ ) {						    	  for ( x = 1 ;						  
	res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFlo 	      res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFlo 	  x <= j ;						  
	if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j  	      if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j  	  x ++ ) {						  
      }							      	    }							    	    res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFlo 
    }							      	  }							    	    if ( res < eggFloor [ i ] [ j ] ) {			  
  }							      	}							    	      eggFloor [ i ] [ j ] = res ;			  
  return eggFloor [ n ] [ k ] ;				      	return eggFloor [ n ] [ k ] ;				    	    }							  
}							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return eggFloor [ n ] [ k ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED     LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED	    LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED	  LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED
--							      --							    --								  --
static int lcs ( int [ ] [ ] [ ] dp , int [ ] arr1 , int n ,  int lcs ( int dp [ MAX ] [ MAX ] [ MAX ] , int arr1 [ ] , int int lcs ( int * * dp , int * arr1 , int n , int * arr2 , int  script_not_found : None
  if ( k < 0 ) return - 10000000 ;			      	if ( k < 0 ) return - 1e7 ;				      if ( k < 0 ) return - 10000000 ;				  
  if ( n < 0 || m < 0 ) return 0 ;			      	if ( n < 0 || m < 0 ) return 0 ;			      if ( n < 0 || m < 0 ) return 0 ;				  
  int ans = dp [ n ] [ m ] [ k ] ;			      	int & ans = dp [ n ] [ m ] [ k ] ;			      int ans = dp [ n ] [ m ] [ k ] ;				  
  if ( ans != - 1 ) return ans ;			      	if ( ans != - 1 ) return ans ;				      if ( ans != - 1 ) return ans ;				  
  try {							      	ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs    {								  
    ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k 	if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = max ( ans , 1 	ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lc 
    if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max  	ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m -  	if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = max ( ans , 
    ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , ar 	return ans ;						    	ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m  
  }							      }								      }								  
  catch ( Exception e ) {				      								      return ans ;						  
  }							      								    }								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1		      SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1			    SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1			  SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1
--							      --							    --								  --
public static void sortSquares ( int arr [ ] ) {	      void sortSquares ( int arr [ ] , int n ) {		    void sortSquares ( int arr [ ] ) {				  script_not_found : None
  int n = arr . length ;				      	int K = 0 ;						      int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
  int k ;						      	for ( K = 0 ;						      int k ;							  
  for ( k = 0 ;						      	K < n ;							      for ( k = 0 ;						  
  k < n ;						      	K ++ ) if ( arr [ K ] >= 0 ) break ;			      k < n ;							  
  k ++ ) {						      	int i = K - 1 ;						      k ++ ) {							  
    if ( arr [ k ] >= 0 ) break ;			      	int j = K ;						    	if ( arr [ k ] >= 0 ) break ;				  
  }							      	int ind = 0 ;						      }								  
  int i = k - 1 ;					      	int temp [ n ] ;					      int i = k - 1 ;						  
  int j = k ;						      	while ( i >= 0 && j < n ) {				      int j = k ;						  
  int ind = 0 ;						      	  if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) {      int ind = 0 ;						  
  int [ ] temp = new int [ n ] ;			      	    temp [ ind ] = arr [ i ] * arr [ i ] ;		      int temp [ n ] ;						  
  while ( i >= 0 && j < n ) {				      	    i -- ;						      while ( i >= 0 && j < n ) {				  
    if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) {    	  }							    	if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) {	  
      temp [ ind ] = arr [ i ] * arr [ i ] ;		      	  else {						    	  temp [ ind ] = arr [ i ] * arr [ i ] ;		  
      i -- ;						      	    temp [ ind ] = arr [ j ] * arr [ j ] ;		    	  i -- ;						  
    }							      	    j ++ ;						    	}							  
    else {						      	  }							    	else {							  
      temp [ ind ] = arr [ j ] * arr [ j ] ;		      	  ind ++ ;						    	  temp [ ind ] = arr [ j ] * arr [ j ] ;		  
      j ++ ;						      	}							    	  j ++ ;						  
    }							      	while ( i >= 0 ) {					    	}							  
    ind ++ ;						      	  temp [ ind ] = arr [ i ] * arr [ i ] ;		    	ind ++ ;						  
  }							      	  i -- ;						      }								  
  while ( i >= 0 ) {					      	  ind ++ ;						      while ( i >= 0 ) {					  
    temp [ ind ++ ] = arr [ i ] * arr [ i ] ;		      	}							    	temp [ ind ++ ] = arr [ i ] * arr [ i ] ;		  
    i -- ;						      	while ( j < n ) {					    	i -- ;							  
  }							      	  temp [ ind ] = arr [ j ] * arr [ j ] ;		      }								  
  while ( j < n ) {					      	  j ++ ;						      while ( j < n ) {						  
    temp [ ind ++ ] = arr [ j ] * arr [ j ] ;		      	  ind ++ ;						    	temp [ ind ++ ] = arr [ j ] * arr [ j ] ;		  
    j ++ ;						      	}							    	j ++ ;							  
  }							      	for ( int i = 0 ;					      }								  
  for ( int x = 0 ;					      	i < n ;							      for ( int x = 0 ;						  
  x < n ;						      	i ++ ) arr [ i ] = temp [ i ] ;				      x < n ;							  
  x ++ ) arr [ x ] = temp [ x ] ;			      }								      x ++ ) {							  
}							      								    	arr [ x ] = temp [ x ] ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K			      SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K				    SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K				  SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K
--							      --							    --								  --
static void subarrayDivisibleByK ( int [ ] arr , int n , int  void subarrayDivisibleByK ( int arr [ ] , int n , int k ) {   void subarray_divisible_by_k ( int * arr , int n , int k ) {  script_not_found : None
  int [ ] mp = new int [ 1000 ] ;			      	map < int , int > mp ;					      int mp [ 1000 ] ;						  
  int s = 0 , e = 0 , maxs = 0 , maxe = 0 ;		      	int s = 0 , e = 0 , maxs = 0 , maxe = 0 ;		      int s = 0 , e = 0 , maxs = 0 , maxe = 0 ;			  
  mp [ arr [ 0 ] % k ] ++ ;				      	mp [ arr [ 0 ] % k ] ++ ;				      mp [ arr [ 0 ] % k ] ++ ;					  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int mod = arr [ i ] % k ;				      	  int mod = arr [ i ] % k ;				    	int mod = arr [ i ] % k ;				  
    while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] ! 	  while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] ! 	while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] ! 
      mp [ arr [ s ] % k ] -- ;				      	    mp [ arr [ s ] % k ] -- ;				    	  mp [ arr [ s ] % k ] -- ;				  
      s ++ ;						      	    s ++ ;						    	  s ++ ;						  
    }							      	  }							    	}							  
    mp [ mod ] ++ ;					      	  mp [ mod ] ++ ;					    	mp [ mod ] ++ ;						  
    e ++ ;						      	  e ++ ;						    	e ++ ;							  
    if ( ( e - s ) > ( maxe - maxs ) ) {		      	  if ( ( e - s ) > ( maxe - maxs ) ) {			    	if ( ( e - s ) > ( maxe - maxs ) ) {			  
      maxe = e ;					      	    maxe = e ;						    	  maxe = e ;						  
      maxs = s ;					      	    maxs = s ;						    	  maxs = s ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  System . out . print ( "The maximum size is " + ( maxe - ma 	cout << "The maximum size is " << maxe - maxs + 1 << " and    cout << "The maximum size is " << ( maxe - maxs + 1 ) << "  
  for ( int i = maxs ;					      	for ( int i = maxs ;					      for ( int i = maxs ;					  
  i <= maxe ;						      	i <= maxe ;						      i <= maxe ;						  
  i ++ ) System . out . print ( arr [ i ] + " " ) ;	      	i ++ ) cout << arr [ i ] << " " ;			      i ++ ) {							  
}							      }								    	cout << arr [ i ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA
--							      --							    --								  --
static int maxdiff ( int arr [ ] , int n ) {		      int maxdiff ( int arr [ ] , int n ) {			    int maxdiff ( int arr [ ] , int n ) {			  success : None
  Map < Integer , Integer > freq = new HashMap < > ( ) ;      	unordered_map < int , int > freq ;			      map < int , int > freq ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) == 	i ++ ) freq [ arr [ i ] ] ++ ;				      i ++ ) {							  
  int ans = 0 ;						      	int ans = 0 ;						    	freq [ arr [ i ] ] = freq [ arr [ i ] ] == 0 ? 1 : freq [ 
  for ( int i = 0 ;					      	for ( int i = 0 ;					      }								  
  i < n ;						      	i < n ;							      int ans = 0 ;						  
  i ++ ) {						      	i ++ ) {						      for ( int i = 0 ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      i < n ;							  
    j < n ;						      	  j < n ;						      i ++ ) {							  
    j ++ ) {						      	  j ++ ) {						    	for ( int j = 0 ;					  
      if ( freq . get ( arr [ i ] ) > freq . get ( arr [ j ]  	    if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i 	j < n ;							  
      else if ( freq . get ( arr [ i ] ) < freq . get ( arr [ 	    else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && ar 	j ++ ) {						  
    }							      	  }							    	  if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i 
  }							      	}							    	    ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j 
  return ans ;						      	return ans ;						    	  }							  
}							      }								    	  else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && ar 
							      								    	    ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i 
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PATH_SUM_MATRIX					      MAXIMUM_PATH_SUM_MATRIX					    MAXIMUM_PATH_SUM_MATRIX					  MAXIMUM_PATH_SUM_MATRIX
--							      --							    --								  --
static int findMaxPath ( int mat [ ] [ ] ) {		      int findMaxPath ( int mat [ ] [ M ] ) {			    int findMaxPath ( int mat [ ] [ M ] ) {			  script_not_found : None
  int res = - 1 ;					      	for ( int i = 1 ;					      int res = - 1 ;						  
  for ( int i = 0 ;					      	i < N ;							      for ( int i = 0 ;						  
  i < M ;						      	i ++ ) {						      i < M ;							  
  i ++ ) res = max ( res , mat [ 0 ] [ i ] ) ;		      	  for ( int j = 0 ;					      i ++ ) {							  
  for ( int i = 1 ;					      	  j < M ;						    	res = max ( res , mat [ 0 ] [ i ] ) ;			  
  i < N ;						      	  j ++ ) {						      }								  
  i ++ ) {						      	    if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat    for ( int i = 1 ;						  
    res = - 1 ;						      	    else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1    i < N ;							  
    for ( int j = 0 ;					      	    else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i    i ++ ) {							  
    j < M ;						      	  }							    	res = - 1 ;						  
    j ++ ) {						      	}							    	for ( int j = 0 ;					  
      if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat  	int res = 0 ;						    	j < M ;							  
      else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1  	for ( int j = 0 ;					    	j ++ ) {						  
      else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i  	j < M ;							    	  if ( j > 0 && j < M - 1 ) {				  
      res = max ( mat [ i ] [ j ] , res ) ;		      	j ++ ) res = max ( mat [ N - 1 ] [ j ] , res ) ;	    	    mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , max (  
    }							      	return res ;						    	  }							  
  }							      }								    	  else if ( j > 0 ) {					  
  return res ;						      								    	    mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [  
}							      								    	  }							  
							      								    	  else if ( j < M - 1 ) {				  
							      								    	    mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ] , mat [  
							      								    	  }							  
							      								    	  res = max ( mat [ i ] [ j ] , res ) ;			  
							      								    	}							  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K	      COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K		    COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K		  COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K
--							      --							    --								  --
static void countDistinct ( int arr [ ] , int k ) {	      void countDistinct ( int arr [ ] , int k , int n ) {	    void countDistinct ( int arr [ ] , int k ) {		  script_not_found : None
  HashMap < Integer , Integer > hM = new HashMap < Integer ,  	map < int , int > hm ;					      unordered_map < int , int > hM ;				  
  int dist_count = 0 ;					      	int dist_count = 0 ;					      int dist_count = 0 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < k ;						      	i < k ;							      i < k ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( hM . get ( arr [ i ] ) == null ) {		      	  if ( hm [ arr [ i ] ] == 0 ) {			    	if ( hM [ arr [ i ] ] == 0 ) {				  
      hM . put ( arr [ i ] , 1 ) ;			      	    dist_count ++ ;					    	  hM [ arr [ i ] ] = 1 ;				  
      dist_count ++ ;					      	  }							    	  dist_count ++ ;					  
    }							      	  hm [ arr [ i ] ] += 1 ;				    	}							  
    else {						      	}							    	else {							  
      int count = hM . get ( arr [ i ] ) ;		      	cout << dist_count << endl ;				    	  int count = hM [ arr [ i ] ] ;			  
      hM . put ( arr [ i ] , count + 1 ) ;		      	for ( int i = k ;					    	  hM [ arr [ i ] ] = count + 1 ;			  
    }							      	i < n ;							    	}							  
  }							      	i ++ ) {						      }								  
  System . out . println ( dist_count ) ;		      	  if ( hm [ arr [ i - k ] ] == 1 ) {			      cout << dist_count << endl ;				  
  for ( int i = k ;					      	    dist_count -- ;					      for ( int i = k ;						  
  i < arr . length ;					      	  }							      i < arr [ k ] ;						  
  i ++ ) {						      	  hm [ arr [ i - k ] ] -= 1 ;				      i ++ ) {							  
    if ( hM . get ( arr [ i - k ] ) == 1 ) {		      	  if ( hm [ arr [ i ] ] == 0 ) {			    	if ( hM [ arr [ i - k ] ] == 1 ) {			  
      hM . remove ( arr [ i - k ] ) ;			      	    dist_count ++ ;					    	  hM . erase ( arr [ i - k ] ) ;			  
      dist_count -- ;					      	  }							    	  dist_count -- ;					  
    }							      	  hm [ arr [ i ] ] += 1 ;				    	}							  
    else {						      	  cout << dist_count << endl ;				    	else {							  
      int count = hM . get ( arr [ i - k ] ) ;		      	}							    	  int count = hM [ arr [ i - k ] ] ;			  
      hM . put ( arr [ i - k ] , count - 1 ) ;		      }								    	  hM [ arr [ i - k ] ] = count - 1 ;			  
    }							      								    	}							  
    if ( hM . get ( arr [ i ] ) == null ) {		      								    	if ( hM [ arr [ i ] ] == 0 ) {				  
      hM . put ( arr [ i ] , 1 ) ;			      								    	  hM [ arr [ i ] ] = 1 ;				  
      dist_count ++ ;					      								    	  dist_count ++ ;					  
    }							      								    	}							  
    else {						      								    	else {							  
      int count = hM . get ( arr [ i ] ) ;		      								    	  int count = hM [ arr [ i ] ] ;			  
      hM . put ( arr [ i ] , count + 1 ) ;		      								    	  hM [ arr [ i ] ] = count + 1 ;			  
    }							      								    	}							  
    System . out . println ( dist_count ) ;		      								    	cout << dist_count << endl ;				  
  }							      								      }								  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY	      FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY	    FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY	  FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY
--							      --							    --								  --
static void findRandomIndexOfMax ( int arr [ ] , int n ) {    void findRandomIndexOfMax ( int arr [ ] , int n ) {	    void findRandomIndexOfMax ( int arr [ ] , int n ) {		  script_not_found : None
  HashMap < Integer , Integer > mp = new HashMap < Integer ,  	unordered_map < int , int > freq ;			      unordered_map < int , int > mp ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) if ( mp . containsKey ( arr [ i ] ) ) {	      	i ++ ) freq [ arr [ i ] ] += 1 ;			      i ++ ) if ( mp . find ( arr [ i ] ) != mp . end ( ) ) mp [  
    mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ;     	int max_element ;					      else mp [ arr [ i ] ] = 1 ;				  
  }							      	int max_so_far = INT_MIN ;				      int maxElement = INT_MAX ;				  
  else {						      	for ( pair < int , int > p : freq ) {			      int maxSo_far = INT_MAX ;					  
    mp . put ( arr [ i ] , 1 ) ;			      	  if ( p . second > max_so_far ) {			      for ( unordered_map < int , int > :: iterator p = mp . begi 
  }							      	    max_so_far = p . second ;				      p != mp . end ( ) ;					  
  int max_element = Integer . MIN_VALUE ;		      	    max_element = p . first ;				      p ++ ) {							  
  int max_so_far = Integer . MIN_VALUE ;		      	  }							    	if ( p -> second > maxSo_far ) {			  
  for ( Map . Entry < Integer , Integer > p : mp . entrySet ( 	}							    	  maxSo_far = p -> second ;				  
    if ( p . getValue ( ) > max_so_far ) {		      	int r = ( rand ( ) % max_so_far ) + 1 ;			    	  maxElement = p -> first ;				  
      max_so_far = p . getValue ( ) ;			      	for ( int i = 0 , count = 0 ;				    	}							  
      max_element = p . getKey ( ) ;			      	i < n ;							      }								  
    }							      	i ++ ) {						      int r = ( int ) ( ( rand ( ) % maxSo_far ) + 1 ) ;	  
  }							      	  if ( arr [ i ] == max_element ) count ++ ;		      for ( int i = 0 , count = 0 ;				  
  int r = ( int ) ( ( new Random ( ) . nextInt ( max_so_far ) 	  if ( count == r ) {					      i < n ;							  
  for ( int i = 0 , count = 0 ;				      	    cout << "Element with maximum frequency present " "at i   i ++ ) {							  
  i < n ;						      	    break ;						    	if ( arr [ i ] == maxElement ) count ++ ;		  
  i ++ ) {						      	  }							    	if ( count == r ) {					  
    if ( arr [ i ] == max_element ) count ++ ;		      	}							    	  cout << "Element with maximum frequency present " << "a 
    if ( count == r ) {					      }								    	  break ;						  
      System . out . print ( "Element with maximum frequency  								    	}							  
      break ;						      								      }								  
    }							      								    }								  
  }							      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1		      FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1		    FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1			  FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1
--							      --							    --								  --
static int findFourElements ( int [ ] arr , int n ) {	      int findFourElements ( int arr [ ] , int n ) {		    int findFourElements ( int * arr , int n ) {		  error : FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_
  HashMap < Integer , Indexes > map = new HashMap < > ( ) ;   	unordered_map < int , pair < int , int >> mp ;		      unordered_map < int , indexes > map ;			  1.cpp: In function ‘int f_filled(int*, int)’: FIND
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  _LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1.cpp:43:25:
  i < n - 1 ;						      	i < n - 1 ;						      i < n - 1 ;						   error: ‘indexes’ was not declared in this scope
  i ++ ) {						      	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							    unordered_map < int , indexes > map ;
    for ( int j = i + 1 ;				      	j < n ;							    	for ( int j = i + 1 ;					  		 ^~~~~~~ FIND_LARGEST_D_IN_ARRAY_SUC
    j < n ;						      	j ++ ) mp [ arr [ i ] + arr [ j ] ] = {			    	j < n ;							  H_THAT_A_B_C_D_1.cpp:43:25: note: suggested altern
    j ++ ) {						      	  i , j }						    	j ++ ) map [ arr [ i ] + arr [ j ] ] = indexes ( i , j )  ative: ‘index’    unordered_map < int , indexes >
      map . put ( arr [ i ] + arr [ j ] , new Indexes ( i , j 	  ;							      }								  map ;				 ^~~~~~~
    }							      	  int d = INT_MIN ;					      int d = INT_MIN ;						  		index FIND_LARGEST_D_IN_ARRAY_SUCH_T
  }							      	  for ( int i = 0 ;					      for ( int i = 0 ;						  HAT_A_B_C_D_1.cpp:43:33: error: template argument
  int d = Integer . MIN_VALUE ;				      	  i < n - 1 ;						      i < n - 1 ;						  2 is invalid	  unordered_map < int , indexes > ma
  for ( int i = 0 ;					      	  i ++ ) {						      i ++ ) {							  p ;				       ^ FIND_LARGES
  i < n - 1 ;						      	    for ( int j = i + 1 ;				    	for ( int j = i + 1 ;					  T_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1.cpp:43:33: error:
  i ++ ) {						      	    j < n ;						    	j < n ;							   template argument 5 is invalid FIND_LARGEST_D_IN_
    for ( int j = i + 1 ;				      	    j ++ ) {						    	j ++ ) {						  ARRAY_SUCH_THAT_A_B_C_D_1.cpp:49:40: error: invali
    j < n ;						      	      int abs_diff = abs ( arr [ i ] - arr [ j ] ) ;	    	  int abs_diff = abs ( arr [ i ] - arr [ j ] ) ;	  d types ‘int[int]’ for array subscript      j ++ )
    j ++ ) {						      	      if ( mp . find ( abs_diff ) != mp . end ( ) ) {	    	  if ( map . count ( abs_diff ) != 0 ) {		   map [ arr [ i ] + arr [ j ] ] = indexes ( i , j )
      int abs_diff = Math . abs ( arr [ i ] - arr [ j ] ) ;   		pair < int , int > p = mp [ abs_diff ] ;	    	    indexes indexes = map [ abs_diff ] ;		   ;					     ^ FIND_
      if ( map . containsKey ( abs_diff ) ) {		      		if ( p . first != i && p . first != j && p . second 	    if ( indexes . i != i && indexes . i != j && indexes  LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1.cpp:59:18:
	Indexes indexes = map . get ( abs_diff ) ;	      	      }							    	  }							  error: request for member ‘count’ in ‘map’, which
	if ( indexes . getI ( ) != i && indexes . getI ( ) != 	    }							    	}							  is of non-class type ‘int’	    if ( map . count
	  d = Math . max ( d , Math . max ( arr [ i ] , arr [ 	  }							      }								   ( abs_diff ) != 0 ) {		   ^~~~~ FIN
	}						      	  return d ;						      return d ;						  D_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1.cpp:60:16
      }							      	}							    }								  : error: expected ‘;’ before ‘indexes’	  in
    }							      								    								  dexes indexes = map [ abs_diff ] ;
  }							      								    								   ^~~~~~~~		    ;
  return d ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_ENDLESS_POINTS				      FIND_NUMBER_ENDLESS_POINTS				    FIND_NUMBER_ENDLESS_POINTS					  FIND_NUMBER_ENDLESS_POINTS
--							      --							    --								  --
static int countEndless ( boolean input [ ] [ ] , int n ) {   int countEndless ( bool input [ ] [ MAX ] , int n ) {	    int countEndless ( bool input [ ] [ 2 ] , int n ) {		  script_not_found : None
  boolean row [ ] [ ] = new boolean [ n ] [ n ] ;	      	bool row [ n ] [ n ] , col [ n ] [ n ] ;		      bool row [ n ] [ n ] ;					  
  boolean col [ ] [ ] = new boolean [ n ] [ n ] ;	      	for ( int j = 0 ;					      bool col [ n ] [ n ] ;					  
  for ( int j = 0 ;					      	j < n ;							      for ( int j = 0 ;						  
  j < n ;						      	j ++ ) {						      j < n ;							  
  j ++ ) {						      	  bool isEndless = 1 ;					      j ++ ) {							  
    boolean isEndless = true ;				      	  for ( int i = n - 1 ;					    	bool isEndless = true ;					  
    for ( int i = n - 1 ;				      	  i >= 0 ;						    	for ( int i = n - 1 ;					  
    i >= 0 ;						      	  i -- ) {						    	i >= 0 ;						  
    i -- ) {						      	    if ( input [ i ] [ j ] == 0 ) isEndless = 0 ;	    	i -- ) {						  
      if ( input [ i ] [ j ] == false ) isEndless = false ;   	    col [ i ] [ j ] = isEndless ;			    	  if ( input [ i ] [ j ] == false ) {			  
      col [ i ] [ j ] = isEndless ;			      	  }							    	    isEndless = false ;					  
    }							      	}							    	  }							  
  }							      	for ( int i = 0 ;					    	  col [ i ] [ j ] = isEndless ;				  
  for ( int i = 0 ;					      	i < n ;							    	}							  
  i < n ;						      	i ++ ) {						      }								  
  i ++ ) {						      	  bool isEndless = 1 ;					      for ( int i = 0 ;						  
    boolean isEndless = true ;				      	  for ( int j = n - 1 ;					      i < n ;							  
    for ( int j = n - 1 ;				      	  j >= 0 ;						      i ++ ) {							  
    j >= 0 ;						      	  j -- ) {						    	bool isEndless = true ;					  
    j -- ) {						      	    if ( input [ i ] [ j ] == 0 ) isEndless = 0 ;	    	for ( int j = n - 1 ;					  
      if ( input [ i ] [ j ] == false ) isEndless = false ;   	    row [ i ] [ j ] = isEndless ;			    	j >= 0 ;						  
      row [ i ] [ j ] = isEndless ;			      	  }							    	j -- ) {						  
    }							      	}							    	  if ( input [ i ] [ j ] == false ) {			  
  }							      	int ans = 0 ;						    	    isEndless = false ;					  
  int ans = 0 ;						      	for ( int i = 0 ;					    	  }							  
  for ( int i = 0 ;					      	i < n ;							    	  row [ i ] [ j ] = isEndless ;				  
  i < n ;						      	i ++ ) for ( int j = 1 ;				    	}							  
  i ++ ) for ( int j = 1 ;				      	j < n ;							      }								  
  j < n ;						      	j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ;     int ans = 0 ;						  
  j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ;   	return ans ;						      for ( int i = 0 ;						  
  return ans ;						      }								      i < n ;							  
}							      								      i ++ ) for ( int j = 1 ;					  
							      								      j < n ;							  
							      								      j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ;	  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINTING_STRING_PLUS_PATTERN_MATRIX			      PRINTING_STRING_PLUS_PATTERN_MATRIX			    PRINTING_STRING_PLUS_PATTERN_MATRIX				  PRINTING_STRING_PLUS_PATTERN_MATRIX
--							      --							    --								  --
static void carveCross ( String str ) {			      void carveCross ( string str ) {				    void carveCross ( string str ) {				  script_not_found : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  if ( n % 2 == 0 ) {					      	if ( n % 2 == 0 ) {					      if ( n % 2 == 0 ) cout << "Not possible. Please enter " <<  
    System . out . print ( "Not possible. Please enter " + "o 	  cout << "Not possible. Please enter " << "odd length stri   else {							  
  }							      	}							    	string arr [ max ] [ max ] ;				  
  else {						      	else {							    	int m = n / 2 ;						  
    char arr [ ] [ ] = new char [ max ] [ max ] ;	      	  char arr [ max ] [ max ] ;				    	for ( int i = 0 ;					  
    int m = n / 2 ;					      	  int m = n / 2 ;					    	i < n ;							  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					    	i ++ ) {						  
    i < n ;						      	  i < n ;						    	  for ( int j = 0 ;					  
    i ++ ) {						      	  i ++ ) {						    	  j < n ;						  
      for ( int j = 0 ;					      	    for ( int j = 0 ;					    	  j ++ ) arr [ i ] [ j ] = 'X' ;			  
      j < n ;						      	    j < n ;						    	}							  
      j ++ ) {						      	    j ++ ) {						    	for ( int i = 0 ;					  
	arr [ i ] [ j ] = 'X' ;				      	      arr [ i ] [ j ] = 'X' ;				    	i < n ;							  
      }							      	    }							    	i ++ ) arr [ i ] [ m ] = str [ i ] ;			  
    }							      	  }							    	for ( int i = 0 ;					  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					    	i < n ;							  
    i < n ;						      	  i < n ;						    	i ++ ) arr [ m ] [ i ] = str [ i ] ;			  
    i ++ ) {						      	  i ++ ) {						    	for ( int i = 0 ;					  
      arr [ i ] [ m ] = str . charAt ( i ) ;		      	    arr [ i ] [ m ] = str [ i ] ;			    	i < n ;							  
    }							      	  }							    	i ++ ) {						  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					    	  for ( int j = 0 ;					  
    i < n ;						      	  i < n ;						    	  j < n ;						  
    i ++ ) {						      	  i ++ ) {						    	  j ++ ) cout << arr [ i ] [ j ] << " " ;		  
      arr [ m ] [ i ] = str . charAt ( i ) ;		      	    arr [ m ] [ i ] = str [ i ] ;			    	  cout << "\n" ;					  
    }							      	  }							    	}							  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					      }								  
    i < n ;						      	  i < n ;						    }								  
    i ++ ) {						      	  i ++ ) {						    								  
      for ( int j = 0 ;					      	    for ( int j = 0 ;					    								  
      j < n ;						      	    j < n ;						    								  
      j ++ ) {						      	    j ++ ) {						    								  
	System . out . print ( arr [ i ] [ j ] + " " ) ;      	      cout << arr [ i ] [ j ] << " " ;			    								  
      }							      	    }							    								  
      System . out . print ( "\n" ) ;			      	    cout << "\n" ;					    								  
    }							      	  }							    								  
  }							      	}							    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING	      DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING	    DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING		  DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING
--							      --							    --								  --
static int carAssembly ( int a [ ] [ ] , int t [ ] [ ] , int  int carAssembly ( int a [ ] [ NUM_STATION ] , int t [ ] [ NUM int carAssembly ( int a [ ] [ 2 ] , int t [ ] [ 2 ] , int e [ script_not_found : None
  int T1 [ ] = new int [ NUM_STATION ] ;		      	int T1 [ NUM_STATION ] , T2 [ NUM_STATION ] , i ;	      int T1 [ NUM_STATION ] ;					  
  int T2 [ ] = new int [ NUM_STATION ] ;		      	T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;			      int T2 [ NUM_STATION ] ;					  
  int i ;						      	T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;			      int i ;							  
  T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;			      	for ( i = 1 ;						      T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;			  
  T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;			      	i < NUM_STATION ;					      T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;			  
  for ( i = 1 ;						      	++ i ) {						      for ( i = 1 ;						  
  i < NUM_STATION ;					      	  T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i -    i < NUM_STATION ;						  
  ++ i ) {						      	  T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i -    ++ i ) {							  
    T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i -  	}							    	T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i -  
    T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i -  	return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_ST 	T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i -  
  }							      }								      }								  
  return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_ST 								      return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_ST 
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_TWO_LARGE_NUMBERS					      SUM_TWO_LARGE_NUMBERS					    SUM_TWO_LARGE_NUMBERS					  SUM_TWO_LARGE_NUMBERS
--							      --							    --								  --
static String findSum ( String str1 , String str2 ) {	      string findSum ( string str1 , string str2 ) {		    string findSum ( string str1 , string str2 ) {		  error : SUM_TWO_LARGE_NUMBERS.cpp: In function ‘st
  if ( str1 . length ( ) > str2 . length ( ) ) {	      	if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1 ,    if ( str1 . length ( ) > str2 . length ( ) ) {		  d::__cxx11::string f_filled(std::__cxx11::string,
    String t = str1 ;					      	string str = "" ;					    	string t = str1 ;					  std::__cxx11::string)’: SUM_TWO_LARGE_NUMBERS.cpp:
    str1 = str2 ;					      	int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;	    	str1 = str2 ;						  51:113: error: ‘carry’ was not declared in this sc
    str2 = t ;						      	reverse ( str1 . begin ( ) , str1 . end ( ) ) ;		    	str2 = t ;						  ope	 str1 = string ( str1 . begin ( ) , str1 . e
  }							      	reverse ( str2 . begin ( ) , str2 . end ( ) ) ;		      }								  nd ( ) ) + string ( str2 . begin ( ) , str2 . end
  String str = "" ;					      	int carry = 0 ;						      string str ;						  ( ) ) + string ( carry ) ;
  int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;	      	for ( int i = 0 ;					      int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;	  
  str1 = new StringBuilder ( str1 ) . reverse ( ) . toString  	i < n1 ;						      str1 = string ( str1 . begin ( ) , str1 . end ( ) ) + strin 					  ^~~~~ SUM_
  str2 = new StringBuilder ( str2 ) . reverse ( ) . toString  	i ++ ) {						      int carry = 0 ;						  TWO_LARGE_NUMBERS.cpp:51:113: note: suggested alte
  int carry = 0 ;					      	  int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i ] - '0' ) +   for ( int i = 0 ;						  rnative: ‘strfry’    str1 = string ( str1 . begin
  for ( int i = 0 ;					      	  str . push_back ( sum % 10 + '0' ) ;			      i < n1 ;							  ( ) , str1 . end ( ) ) + string ( str2 . begin ( )
  i < n1 ;						      	  carry = sum / 10 ;					      i ++ ) {							   , str2 . end ( ) ) + string ( carry ) ;
  i ++ ) {						      	}							    	int sum = ( ( int ) ( str1 [ i ] - '0' ) + ( int ) ( str2 
    int sum = ( ( int ) ( str1 . charAt ( i ) - '0' ) + ( int 	for ( int i = n1 ;					    	str += char ( sum % 10 + '0' ) ;			  
    str += ( char ) ( sum % 10 + '0' ) ;		      	i < n2 ;						    	carry = sum / 10 ;					      ^~~~~
    carry = sum / 10 ;					      	i ++ ) {						      }								  
  }							      	  int sum = ( ( str2 [ i ] - '0' ) + carry ) ;		      for ( int i = n1 ;					  			 strfry
  for ( int i = n1 ;					      	  str . push_back ( sum % 10 + '0' ) ;			      i < n2 ;							  
  i < n2 ;						      	  carry = sum / 10 ;					      i ++ ) {							  
  i ++ ) {						      	}							    	int sum = ( ( int ) ( str2 [ i ] - '0' ) + carry ) ;	  
    int sum = ( ( int ) ( str2 . charAt ( i ) - '0' ) + carry 	if ( carry ) str . push_back ( carry + '0' ) ;		    	str += char ( sum % 10 + '0' ) ;			  
    str += ( char ) ( sum % 10 + '0' ) ;		      	reverse ( str . begin ( ) , str . end ( ) ) ;		    	carry = sum / 10 ;					  
    carry = sum / 10 ;					      	return str ;						      }								  
  }							      }								      if ( carry > 0 ) str += char ( carry + '0' ) ;		  
  if ( carry > 0 ) str += ( char ) ( carry + '0' ) ;	      								      str = string ( str . begin ( ) , str . end ( ) ) ;	  
  str = new StringBuilder ( str ) . reverse ( ) . toString (  								      return str ;						  
  return str ;						      								    }								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1		      FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1			    FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1			  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1
--							      --							    --								  --
static boolean isRectangle ( int matrix [ ] [ ] ) {	      bool isRectangle ( const vector < vector < int >> & matrix )  bool isRectangle ( vector < vector < int >> matrix ) {	  error : FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.c
  int rows = matrix . length ;				      	int rows = matrix . size ( ) ;				      int rows = matrix . size ( ) ;				  pp: In function ‘bool f_filled(std::vector<std::ve
  if ( rows == 0 ) return false ;			      	if ( rows == 0 ) return false ;				      if ( rows == 0 ) return false ;				  ctor<int> >)’: FIND_RECTANGLE_BINARY_MATRIX_CORNER
  int columns = matrix [ 0 ] . length ;			      	int columns = matrix [ 0 ] . size ( ) ;			      int columns = matrix [ 0 ] . size ( ) ;			  S_1_1.cpp:56:82: error: no match for ‘operator!=’
  HashMap < Integer , HashSet < Integer >> table = new HashMa 	unordered_map < int , unordered_set < int >> table ;	      unordered_map < int , set < int >> table ;		  (operand types are ‘std::set<int>::iterator’ {aka
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  ‘std::_Rb_tree_const_iterator<int>’} and ‘std::uno
  i < rows ;						      	i < rows ;						      i < rows ;						  rdered_map<int, std::set<int> >::iterator’ {aka ‘s
  i ++ ) {						      	++ i ) {						      i ++ ) {							  td::__detail::_Node_iterator<std::pair<const int,
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  std::set<int> >, false, false>’})	       if (
    j < columns - 1 ;					      	  j < columns - 1 ;					    	j < columns - 1 ;					  table . find ( j ) != table . end ( ) && table [ j
    j ++ ) {						      	  ++ j ) {						    	j ++ ) {						   ] . find ( k ) != table . end ( ) ) return true ;
      for ( int k = j + 1 ;				      	    for ( int k = j + 1 ;				    	  for ( int k = j + 1 ;					  
      k < columns ;					      	    k < columns ;					    	  k < columns ;						  	  ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~
      k ++ ) {						      	    ++ k ) {						    	  k ++ ) {						  ~ In file included from /usr/include/c++/8/map:60,
	if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 	      if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 	    if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 		    from /usr/include/c++/8/x86_64-r
	  if ( table . containsKey ( j ) && table . get ( j ) 		if ( table . find ( j ) != table . end ( ) && table 	      if ( table . find ( j ) != table . end ( ) && table edhat-linux/bits/stdc++.h:81,			 fro
	    return true ;				      		table [ j ] . insert ( k ) ;			    	      if ( table . find ( k ) != table . end ( ) && table m FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14:
	  }						      	      }							    	      if ( ! table . find ( j ) != table . end ( ) ) {	   /usr/include/c++/8/bits/stl_tree.h:398:7: note: c
	  if ( table . containsKey ( k ) && table . get ( k ) 	    }							    		set < int > x ;					  andidate: ‘bool std::_Rb_tree_const_iterator<_Tp>:
	    return true ;				      	  }							    		x . insert ( k ) ;				  :operator!=(const _Self&) const [with _Tp = int; s
	  }						      	}							    		table [ j ] . insert ( x ) ;			  td::_Rb_tree_const_iterator<_Tp>::_Self = std::_Rb
	  if ( ! table . containsKey ( j ) ) {		      	return false ;						    	      }							  _tree_const_iterator<int>]’	     operator!=(cons
	    HashSet < Integer > x = new HashSet < > ( ) ;     }								    	      else table [ j ] . insert ( k ) ;			  t _Self& __x) const _GLIBCXX_NOEXCEPT	       ^~~~~
	    x . add ( k ) ;				      								    	      if ( ! table . find ( k ) != table . end ( ) ) {	  ~~~ /usr/include/c++/8/bits/stl_tree.h:398:7: note
	    table . put ( j , x ) ;			      								    		set < int > x ;					  :   no known conversion for argument 1 from ‘std::
	  }						      								    		x . insert ( j ) ;				  unordered_map<int, std::set<int> >::iterator’ {aka
	  else {					      								    		table [ k ] . insert ( x ) ;			   ‘std::__detail::_Node_iterator<std::pair<const in
	    table . get ( j ) . add ( k ) ;		      								    	      }							  t, std::set<int> >, false, false>’} to ‘const _Sel
	  }						      								    	      else table [ k ] . insert ( j ) ;			  f&’ {aka ‘const std::_Rb_tree_const_iterator<int>&
	  if ( ! table . containsKey ( k ) ) {		      								    	    }							  ’} In file included from /usr/include/c++/8/regex:
	    HashSet < Integer > x = new HashSet < > ( ) ;     								    	  }							  62,		       from /usr/include/c++/8/x86_6
	    x . add ( j ) ;				      								    	}							  4-redhat-linux/bits/stdc++.h:110,
	    table . put ( k , x ) ;			      								      }								   from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp
	  }						      								      return false ;						  :14: /usr/include/c++/8/bits/regex.h:991:5: note:
	  else {					      								    }								  candidate: ‘template<class _BiIter> bool std::__cx
	    table . get ( k ) . add ( j ) ;		      								    								  x11::operator!=(const std::__cxx11::sub_match<_BiI
	  }						      								    								  ter>&, const std::__cxx11::sub_match<_BiIter>&)’
	}						      								    								      operator!=(const sub_match<_BiIter>& __lhs, co
      }							      								    								  nst sub_match<_BiIter>& __rhs)      ^~~~~~~~ /usr/
    }							      								    								  include/c++/8/bits/regex.h:991:5: note:   template
  }							      								    								   argument deduction/substitution failed: FIND_RECT
  return false ;					      								    								  ANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:
}							      								    								   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_con
							      								    								  st_iterator<int>’} is not derived from ‘const std:
							      								    								  :__cxx11::sub_match<_BiIter>’		   if ( tabl
							      								    								  e . find ( j ) != table . end ( ) && table [ j ] .
							      								    								   find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						^ In
							      								    								   file included from /usr/include/c++/8/regex:62,
							      								    								  		  from /usr/include/c++/8/x86_64-red
							      								    								  hat-linux/bits/stdc++.h:110,			from
							      								    								   FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14:
							      								    								  /usr/include/c++/8/bits/regex.h:1069:5: note: cand
							      								    								  idate: ‘template<class _Bi_iter, class _Ch_traits,
							      								    								   class _Ch_alloc> bool std::__cxx11::operator!=(st
							      								    								  d::__cxx11::__sub_match_string<_Bi_iter, _Ch_trait
							      								    								  s, _Ch_alloc>&, const std::__cxx11::sub_match<_BiI
							      								    								  ter>&)’      operator!=(const __sub_match_string<_
							      								    								  Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/regex.h:1069:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:9
							      								    								  9: note:   ‘std::set<int>::iterator’ {aka ‘std::_R
							      								    								  b_tree_const_iterator<int>’} is not derived from ‘
							      								    								  std::__cxx11::__sub_match_string<_Bi_iter, _Ch_tra
							      								    								  its, _Ch_alloc>’	      if ( table . find ( j
							      								    								  ) != table . end ( ) && table [ j ] . find ( k ) !
							      								    								  = table . end ( ) ) return true ;
							      								    								  
							      								    								  				   ^ In file include
							      								    								  d from /usr/include/c++/8/regex:62,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:110,		   from FIND_RECTANG
							      								    								  LE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/
							      								    								  c++/8/bits/regex.h:1149:5: note: candidate: ‘templ
							      								    								  ate<class _Bi_iter, class _Ch_traits, class _Ch_al
							      								    								  loc> bool std::__cxx11::operator!=(const std::__cx
							      								    								  x11::sub_match<_BiIter>&, std::__cxx11::__sub_matc
							      								    								  h_string<_Bi_iter, _Ch_traits, _Ch_alloc>&)’
							      								    								  operator!=(const sub_match<_Bi_iter>& __lhs,
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/regex.h:1149:5: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp
							      								    								  :56:99: note:	  ‘std::set<int>::iterator’ {aka ‘st
							      								    								  d::_Rb_tree_const_iterator<int>’} is not derived f
							      								    								  rom ‘const std::__cxx11::sub_match<_BiIter>’
							      								    								  	if ( table . find ( j ) != table . end ( ) &
							      								    								  & table [ j ] . find ( k ) != table . end ( ) ) re
							      								    								  turn true ;
							      								    								  
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/regex:62,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  	     from FIND_RECTANGLE_BINARY_MATRIX_CORNE
							      								    								  RS_1_1.cpp:14: /usr/include/c++/8/bits/regex.h:122
							      								    								  6:5: note: candidate: ‘template<class _Bi_iter> bo
							      								    								  ol std::__cxx11::operator!=(const typename std::it
							      								    								  erator_traits<_Iter>::value_type*, const std::__cx
							      								    								  x11::sub_match<_BiIter>&)’	  operator!=(typenam
							      								    								  e iterator_traits<_Bi_iter>::value_type const* __l
							      								    								  hs,	   ^~~~~~~~ /usr/include/c++/8/bits/regex.h:
							      								    								  1226:5: note:	  template argument deduction/substi
							      								    								  tution failed: FIND_RECTANGLE_BINARY_MATRIX_CORNER
							      								    								  S_1_1.cpp:56:99: note:   ‘std::unordered_map<int,
							      								    								  std::set<int> >::iterator’ {aka ‘std::__detail::_N
							      								    								  ode_iterator<std::pair<const int, std::set<int> >,
							      								    								   false, false>’} is not derived from ‘const std::_
							      								    								  _cxx11::sub_match<_BiIter>’		 if ( table
							      								    								  . find ( j ) != table . end ( ) && table [ j ] . f
							      								    								  ind ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/regex:62,
							      								    								  		from /usr/include/c++/8/x86_64-redha
							      								    								  t-linux/bits/stdc++.h:110,		      from F
							      								    								  IND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /u
							      								    								  sr/include/c++/8/bits/regex.h:1300:5: note: candid
							      								    								  ate: ‘template<class _Bi_iter> bool std::__cxx11::
							      								    								  operator!=(const std::__cxx11::sub_match<_BiIter>&
							      								    								  , const typename std::iterator_traits<_Iter>::valu
							      								    								  e_type*)’	 operator!=(const sub_match<_Bi_iter
							      								    								  >& __lhs,	 ^~~~~~~~ /usr/include/c++/8/bits/re
							      								    								  gex.h:1300:5: note:	template argument deduction/
							      								    								  substitution failed: FIND_RECTANGLE_BINARY_MATRIX_
							      								    								  CORNERS_1_1.cpp:56:99: note:	 ‘std::set<int>::ite
							      								    								  rator’ {aka ‘std::_Rb_tree_const_iterator<int>’} i
							      								    								  s not derived from ‘const std::__cxx11::sub_match<
							      								    								  _BiIter>’	       if ( table . find ( j ) != ta
							      								    								  ble . end ( ) && table [ j ] . find ( k ) != table
							      								    								   . end ( ) ) return true ;
							      								    								  
							      								    								  			    ^ In file included from
							      								    								  /usr/include/c++/8/regex:62,			from
							      								    								   /usr/include/c++/8/x86_64-redhat-linux/bits/stdc+
							      								    								  +.h:110,		    from FIND_RECTANGLE_BINA
							      								    								  RY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/b
							      								    								  its/regex.h:1377:5: note: candidate: ‘template<cla
							      								    								  ss _Bi_iter> bool std::__cxx11::operator!=(const t
							      								    								  ypename std::iterator_traits<_Iter>::value_type&,
							      								    								  const std::__cxx11::sub_match<_BiIter>&)’	 ope
							      								    								  rator!=(typename iterator_traits<_Bi_iter>::value_
							      								    								  type const& __lhs,	  ^~~~~~~~ /usr/include/c++/
							      								    								  8/bits/regex.h:1377:5: note:	 template argument d
							      								    								  eduction/substitution failed: FIND_RECTANGLE_BINAR
							      								    								  Y_MATRIX_CORNERS_1_1.cpp:56:99: note:	  ‘std::unor
							      								    								  dered_map<int, std::set<int> >::iterator’ {aka ‘st
							      								    								  d::__detail::_Node_iterator<std::pair<const int, s
							      								    								  td::set<int> >, false, false>’} is not derived fro
							      								    								  m ‘const std::__cxx11::sub_match<_BiIter>’
							      								    								      if ( table . find ( j ) != table . end ( ) &&
							      								    								  table [ j ] . find ( k ) != table . end ( ) ) retu
							      								    								  rn true ;
							      								    								  
							      								    								  	   ^ In file included from /usr/include/c++/
							      								    								  8/regex:62,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  	   from FIND_RECTANGLE_BINARY_MATRIX_CORNERS
							      								    								  _1_1.cpp:14: /usr/include/c++/8/bits/regex.h:1457:
							      								    								  5: note: candidate: ‘template<class _Bi_iter> bool
							      								    								   std::__cxx11::operator!=(const std::__cxx11::sub_
							      								    								  match<_BiIter>&, const typename std::iterator_trai
							      								    								  ts<_Iter>::value_type&)’	operator!=(const sub
							      								    								  _match<_Bi_iter>& __lhs,	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/regex.h:1457:5: note:   template argu
							      								    								  ment deduction/substitution failed: FIND_RECTANGLE
							      								    								  _BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:	‘std
							      								    								  ::set<int>::iterator’ {aka ‘std::_Rb_tree_const_it
							      								    								  erator<int>’} is not derived from ‘const std::__cx
							      								    								  x11::sub_match<_BiIter>’	      if ( table . f
							      								    								  ind ( j ) != table . end ( ) && table [ j ] . find
							      								    								   ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					   ^ In file
							      								    								   included from /usr/include/c++/8/regex:62,
							      								    								  	     from /usr/include/c++/8/x86_64-redhat-l
							      								    								  inux/bits/stdc++.h:110,		   from FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/
							      								    								  include/c++/8/bits/regex.h:1981:5: note: candidate
							      								    								  : ‘template<class _Bi_iter, class _Alloc> bool std
							      								    								  ::__cxx11::operator!=(const std::__cxx11::match_re
							      								    								  sults<_BiIter, _Alloc>&, const std::__cxx11::match
							      								    								  _results<_BiIter, _Alloc>&)’	    operator!=(const
							      								    								   match_results<_Bi_iter, _Alloc>& __m1,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/regex.h:1981:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:9
							      								    								  9: note:   ‘std::set<int>::iterator’ {aka ‘std::_R
							      								    								  b_tree_const_iterator<int>’} is not derived from ‘
							      								    								  const std::__cxx11::match_results<_BiIter, _Alloc>
							      								    								  ’	       if ( table . find ( j ) != table . en
							      								    								  d ( ) && table [ j ] . find ( k ) != table . end (
							      								    								   ) ) return true ;
							      								    								  
							      								    								  		    ^ In file included from /usr/inc
							      								    								  lude/c++/8/iosfwd:40,			 from /usr/i
							      								    								  nclude/c++/8/ios:38,			from /usr/in
							      								    								  clude/c++/8/ostream:38,		   from /usr
							      								    								  /include/c++/8/iostream:39,		       from
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8: /u
							      								    								  sr/include/c++/8/bits/postypes.h:221:5: note: cand
							      								    								  idate: ‘template<class _StateT> bool std::operator
							      								    								  !=(const std::fpos<_StateT>&, const std::fpos<_Sta
							      								    								  teT>&)’      operator!=(const fpos<_StateT>& __lhs
							      								    								  , const fpos<_StateT>& __rhs)	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/postypes.h:221:5: note:   templa
							      								    								  te argument deduction/substitution failed: FIND_RE
							      								    								  CTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:
							      								    								     ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_c
							      								    								  onst_iterator<int>’} is not derived from ‘const st
							      								    								  d::fpos<_StateT>’	       if ( table . find ( j
							      								    								   ) != table . end ( ) && table [ j ] . find ( k )
							      								    								  != table . end ( ) ) return true ;
							      								    								  
							      								    								  				    ^ In file includ
							      								    								  ed from /usr/include/c++/8/bits/stl_algobase.h:64,
							      								    								  		    from /usr/include/c++/8/bits/cha
							      								    								  r_traits.h:39,		  from /usr/include/
							      								    								  c++/8/ios:40,			 from /usr/include/c
							      								    								  ++/8/ostream:38,		    from /usr/includ
							      								    								  e/c++/8/iostream:39,			from FIND_RE
							      								    								  CTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8: /usr/incl
							      								    								  ude/c++/8/bits/stl_pair.h:461:5: note: candidate:
							      								    								  ‘template<class _T1, class _T2> constexpr bool std
							      								    								  ::operator!=(const std::pair<_T1, _T2>&, const std
							      								    								  ::pair<_T1, _T2>&)’	   operator!=(const pair<_T1
							      								    								  , _T2>& __x, const pair<_T1, _T2>& __y)      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/stl_pair.h:461:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56
							      								    								  :99: note:   ‘std::set<int>::iterator’ {aka ‘std::
							      								    								  _Rb_tree_const_iterator<int>’} is not derived from
							      								    								   ‘const std::pair<_T1, _T2>’		  if ( table
							      								    								   . find ( j ) != table . end ( ) && table [ j ] .
							      								    								  find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					       ^ In
							      								    								  file included from /usr/include/c++/8/bits/stl_alg
							      								    								  obase.h:67,		       from /usr/include/c++
							      								    								  /8/bits/char_traits.h:39,		     from /u
							      								    								  sr/include/c++/8/ios:40,		    from /us
							      								    								  r/include/c++/8/ostream:38,		       from
							      								    								  /usr/include/c++/8/iostream:39,		   f
							      								    								  rom FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8
							      								    								  : /usr/include/c++/8/bits/stl_iterator.h:314:5: no
							      								    								  te: candidate: ‘template<class _Iterator> bool std
							      								    								  ::operator!=(const std::reverse_iterator<_Iterator
							      								    								  >&, const std::reverse_iterator<_Iterator>&)’
							      								    								   operator!=(const reverse_iterator<_Iterator>& __x
							      								    								  ,	 ^~~~~~~~ /usr/include/c++/8/bits/stl_iterat
							      								    								  or.h:314:5: note:   template argument deduction/su
							      								    								  bstitution failed: FIND_RECTANGLE_BINARY_MATRIX_CO
							      								    								  RNERS_1_1.cpp:56:99: note:   ‘std::set<int>::itera
							      								    								  tor’ {aka ‘std::_Rb_tree_const_iterator<int>’} is
							      								    								  not derived from ‘const std::reverse_iterator<_Ite
							      								    								  rator>’	     if ( table . find ( j ) != tabl
							      								    								  e . end ( ) && table [ j ] . find ( k ) != table .
							      								    								   end ( ) ) return true ;
							      								    								  
							      								    								  			  ^ In file included from /u
							      								    								  sr/include/c++/8/bits/stl_algobase.h:67,
							      								    								  	  from /usr/include/c++/8/bits/char_traits.h
							      								    								  :39,			from /usr/include/c++/8/ios:
							      								    								  40,		       from /usr/include/c++/8/ostre
							      								    								  am:38,		  from /usr/include/c++/8/io
							      								    								  stream:39,		      from FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:8: /usr/include/c++/8/
							      								    								  bits/stl_iterator.h:352:5: note: candidate: ‘templ
							      								    								  ate<class _IteratorL, class _IteratorR> bool std::
							      								    								  operator!=(const std::reverse_iterator<_Iterator>&
							      								    								  , const std::reverse_iterator<_IteratorR>&)’
							      								    								  operator!=(const reverse_iterator<_IteratorL>& __x
							      								    								  ,	 ^~~~~~~~ /usr/include/c++/8/bits/stl_iterat
							      								    								  or.h:352:5: note:   template argument deduction/su
							      								    								  bstitution failed: FIND_RECTANGLE_BINARY_MATRIX_CO
							      								    								  RNERS_1_1.cpp:56:99: note:   ‘std::set<int>::itera
							      								    								  tor’ {aka ‘std::_Rb_tree_const_iterator<int>’} is
							      								    								  not derived from ‘const std::reverse_iterator<_Ite
							      								    								  rator>’	     if ( table . find ( j ) != tabl
							      								    								  e . end ( ) && table [ j ] . find ( k ) != table .
							      								    								   end ( ) ) return true ;
							      								    								  
							      								    								  			  ^ In file included from /u
							      								    								  sr/include/c++/8/bits/stl_algobase.h:67,
							      								    								  	  from /usr/include/c++/8/bits/char_traits.h
							      								    								  :39,			from /usr/include/c++/8/ios:
							      								    								  40,		       from /usr/include/c++/8/ostre
							      								    								  am:38,		  from /usr/include/c++/8/io
							      								    								  stream:39,		      from FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:8: /usr/include/c++/8/
							      								    								  bits/stl_iterator.h:1127:5: note: candidate: ‘temp
							      								    								  late<class _IteratorL, class _IteratorR> bool std:
							      								    								  :operator!=(const std::move_iterator<_IteratorL>&,
							      								    								   const std::move_iterator<_IteratorR>&)’	oper
							      								    								  ator!=(const move_iterator<_IteratorL>& __x,
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/stl_iterator.h:11
							      								    								  27:5: note:	template argument deduction/substitu
							      								    								  tion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_
							      								    								  1_1.cpp:56:99: note:	 ‘std::set<int>::iterator’ {
							      								    								  aka ‘std::_Rb_tree_const_iterator<int>’} is not de
							      								    								  rived from ‘const std::move_iterator<_IteratorL>’
							      								    								  	     if ( table . find ( j ) != table . end
							      								    								  ( ) && table [ j ] . find ( k ) != table . end ( )
							      								    								   ) return true ;
							      								    								  
							      								    								  		  ^ In file included from /usr/inclu
							      								    								  de/c++/8/bits/stl_algobase.h:67,
							      								    								  from /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  		from /usr/include/c++/8/ios:40,
							      								    								  	       from /usr/include/c++/8/ostream:38,
							      								    								  		  from /usr/include/c++/8/iostream:3
							      								    								  9,		      from FIND_RECTANGLE_BINARY_MAT
							      								    								  RIX_CORNERS_1_1.cpp:8: /usr/include/c++/8/bits/stl
							      								    								  _iterator.h:1133:5: note: candidate: ‘template<cla
							      								    								  ss _Iterator> bool std::operator!=(const std::move
							      								    								  _iterator<_IteratorL>&, const std::move_iterator<_
							      								    								  IteratorL>&)’	     operator!=(const move_iterator<
							      								    								  _Iterator>& __x,	^~~~~~~~ /usr/include/c++/8/
							      								    								  bits/stl_iterator.h:1133:5: note:   template argum
							      								    								  ent deduction/substitution failed: FIND_RECTANGLE_
							      								    								  BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std:
							      								    								  :set<int>::iterator’ {aka ‘std::_Rb_tree_const_ite
							      								    								  rator<int>’} is not derived from ‘const std::move_
							      								    								  iterator<_IteratorL>’		   if ( table . find
							      								    								   ( j ) != table . end ( ) && table [ j ] . find (
							      								    								  k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					^ In file in
							      								    								  cluded from /usr/include/c++/8/string:41,
							      								    								  	   from /usr/include/c++/8/bits/locale_class
							      								    								  es.h:40,		    from /usr/include/c++/8/
							      								    								  bits/ios_base.h:41,		       from /usr/inc
							      								    								  lude/c++/8/ios:42,		      from /usr/incl
							      								    								  ude/c++/8/ostream:38,			 from /usr/i
							      								    								  nclude/c++/8/iostream:39,		     from FI
							      								    								  ND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8: /usr
							      								    								  /include/c++/8/bits/allocator.h:158:5: note: candi
							      								    								  date: ‘template<class _T1, class _T2> bool std::op
							      								    								  erator!=(const std::allocator<_CharT>&, const std:
							      								    								  :allocator<_T2>&)’	  operator!=(const allocator
							      								    								  <_T1>&, const allocator<_T2>&)      ^~~~~~~~ /usr/
							      								    								  include/c++/8/bits/allocator.h:158:5: note:	temp
							      								    								  late argument deduction/substitution failed: FIND_
							      								    								  RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: not
							      								    								  e:   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree
							      								    								  _const_iterator<int>’} is not derived from ‘const
							      								    								  std::allocator<_CharT>’	     if ( table . fi
							      								    								  nd ( j ) != table . end ( ) && table [ j ] . find
							      								    								  ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					  ^ In file
							      								    								  included from /usr/include/c++/8/string:41,
							      								    								  	     from /usr/include/c++/8/bits/locale_cla
							      								    								  sses.h:40,		      from /usr/include/c++/
							      								    								  8/bits/ios_base.h:41,			 from /usr/i
							      								    								  nclude/c++/8/ios:42,			from /usr/in
							      								    								  clude/c++/8/ostream:38,		   from /usr
							      								    								  /include/c++/8/iostream:39,		       from
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8: /u
							      								    								  sr/include/c++/8/bits/allocator.h:164:5: note: can
							      								    								  didate: ‘template<class _Tp> bool std::operator!=(
							      								    								  const std::allocator<_CharT>&, const std::allocato
							      								    								  r<_CharT>&)’	    operator!=(const allocator<_Tp>&
							      								    								  , const allocator<_Tp>&)	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/allocator.h:164:5: note:	  template a
							      								    								  rgument deduction/substitution failed: FIND_RECTAN
							      								    								  GLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘
							      								    								  std::set<int>::iterator’ {aka ‘std::_Rb_tree_const
							      								    								  _iterator<int>’} is not derived from ‘const std::a
							      								    								  llocator<_CharT>’	       if ( table . find ( j
							      								    								   ) != table . end ( ) && table [ j ] . find ( k )
							      								    								  != table . end ( ) ) return true ;
							      								    								  
							      								    								  				    ^ In file includ
							      								    								  ed from /usr/include/c++/8/string:52,
							      								    								       from /usr/include/c++/8/bits/locale_classes.h
							      								    								  :40,			from /usr/include/c++/8/bits
							      								    								  /ios_base.h:41,		   from /usr/include
							      								    								  /c++/8/ios:42,		  from /usr/include/
							      								    								  c++/8/ostream:38,		     from /usr/inclu
							      								    								  de/c++/8/iostream:39,			 from FIND_R
							      								    								  ECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8: /usr/inc
							      								    								  lude/c++/8/bits/basic_string.h:6095:5: note: candi
							      								    								  date: ‘template<class _CharT, class _Traits, class
							      								    								   _Alloc> bool std::operator!=(const std::__cxx11::
							      								    								  basic_string<_CharT, _Traits, _Alloc>&, const std:
							      								    								  :__cxx11::basic_string<_CharT, _Traits, _Alloc>&)’
							      								    								  	operator!=(const basic_string<_CharT, _Trait
							      								    								  s, _Alloc>& __lhs,	  ^~~~~~~~ /usr/include/c++/
							      								    								  8/bits/basic_string.h:6095:5: note:	template arg
							      								    								  ument deduction/substitution failed: FIND_RECTANGL
							      								    								  E_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:	 ‘st
							      								    								  d::set<int>::iterator’ {aka ‘std::_Rb_tree_const_i
							      								    								  terator<int>’} is not derived from ‘const std::__c
							      								    								  xx11::basic_string<_CharT, _Traits, _Alloc>’
							      								    								  	if ( table . find ( j ) != table . end ( ) &
							      								    								  & table [ j ] . find ( k ) != table . end ( ) ) re
							      								    								  turn true ;
							      								    								  
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/string:52,		  from /usr/include/
							      								    								  c++/8/bits/locale_classes.h:40,		   f
							      								    								  rom /usr/include/c++/8/bits/ios_base.h:41,
							      								    								  	    from /usr/include/c++/8/ios:42,
							      								    								  	   from /usr/include/c++/8/ostream:38,
							      								    								  	      from /usr/include/c++/8/iostream:39,
							      								    								  		  from FIND_RECTANGLE_BINARY_MATRIX_
							      								    								  CORNERS_1_1.cpp:8: /usr/include/c++/8/bits/basic_s
							      								    								  tring.h:6108:5: note: candidate: ‘template<class _
							      								    								  CharT, class _Traits, class _Alloc> bool std::oper
							      								    								  ator!=(const _CharT*, const std::__cxx11::basic_st
							      								    								  ring<_CharT, _Traits, _Alloc>&)’	operator!=(c
							      								    								  onst _CharT* __lhs,	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/basic_string.h:6108:5: note:	 template ar
							      								    								  gument deduction/substitution failed: FIND_RECTANG
							      								    								  LE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:	  mi
							      								    								  smatched types ‘const _CharT*’ and ‘std::_Rb_tree_
							      								    								  const_iterator<int>’		  if ( table . find
							      								    								  ( j ) != table . end ( ) && table [ j ] . find ( k
							      								    								   ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  				       ^ In file inc
							      								    								  luded from /usr/include/c++/8/string:52,
							      								    								  	  from /usr/include/c++/8/bits/locale_classe
							      								    								  s.h:40,		   from /usr/include/c++/8/b
							      								    								  its/ios_base.h:41,		      from /usr/incl
							      								    								  ude/c++/8/ios:42,		     from /usr/inclu
							      								    								  de/c++/8/ostream:38,			from /usr/in
							      								    								  clude/c++/8/iostream:39,		    from FIN
							      								    								  D_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8: /usr/
							      								    								  include/c++/8/bits/basic_string.h:6120:5: note: ca
							      								    								  ndidate: ‘template<class _CharT, class _Traits, cl
							      								    								  ass _Alloc> bool std::operator!=(const std::__cxx1
							      								    								  1::basic_string<_CharT, _Traits, _Alloc>&, const _
							      								    								  CharT*)’	operator!=(const basic_string<_CharT
							      								    								  , _Traits, _Alloc>& __lhs,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/basic_string.h:6120:5: note:	temp
							      								    								  late argument deduction/substitution failed: FIND_
							      								    								  RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: not
							      								    								  e:   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree
							      								    								  _const_iterator<int>’} is not derived from ‘const
							      								    								  std::__cxx11::basic_string<_CharT, _Traits, _Alloc
							      								    								  >’		if ( table . find ( j ) != table . e
							      								    								  nd ( ) && table [ j ] . find ( k ) != table . end
							      								    								  ( ) ) return true ;
							      								    								  
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/bits/ios_base.h:46,		   f
							      								    								  rom /usr/include/c++/8/ios:42,		  fr
							      								    								  om /usr/include/c++/8/ostream:38,
							      								    								   from /usr/include/c++/8/iostream:39,
							      								    								       from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1
							      								    								  .cpp:8: /usr/include/c++/8/system_error:319:3: not
							      								    								  e: candidate: ‘bool std::operator!=(const std::err
							      								    								  or_code&, const std::error_code&)’	operator!=(c
							      								    								  onst error_code& __lhs, const error_code& __rhs) n
							      								    								  oexcept    ^~~~~~~~ /usr/include/c++/8/system_erro
							      								    								  r:319:3: note:   no known conversion for argument
							      								    								  1 from ‘std::set<int>::iterator’ {aka ‘std::_Rb_tr
							      								    								  ee_const_iterator<int>’} to ‘const std::error_code
							      								    								  &’ /usr/include/c++/8/system_error:323:3: note: ca
							      								    								  ndidate: ‘bool std::operator!=(const std::error_co
							      								    								  de&, const std::error_condition&)’	operator!=(c
							      								    								  onst error_code& __lhs, const error_condition& __r
							      								    								  hs) noexcept	  ^~~~~~~~ /usr/include/c++/8/system
							      								    								  _error:323:3: note:	no known conversion for argu
							      								    								  ment 1 from ‘std::set<int>::iterator’ {aka ‘std::_
							      								    								  Rb_tree_const_iterator<int>’} to ‘const std::error
							      								    								  _code&’ /usr/include/c++/8/system_error:327:3: not
							      								    								  e: candidate: ‘bool std::operator!=(const std::err
							      								    								  or_condition&, const std::error_code&)’    operato
							      								    								  r!=(const error_condition& __lhs, const error_code
							      								    								  & __rhs) noexcept    ^~~~~~~~ /usr/include/c++/8/s
							      								    								  ystem_error:327:3: note:   no known conversion for
							      								    								   argument 1 from ‘std::set<int>::iterator’ {aka ‘s
							      								    								  td::_Rb_tree_const_iterator<int>’} to ‘const std::
							      								    								  error_condition&’ /usr/include/c++/8/system_error:
							      								    								  331:3: note: candidate: ‘bool std::operator!=(cons
							      								    								  t std::error_condition&, const std::error_conditio
							      								    								  n&)’	  operator!=(const error_condition& __lhs,
							      								    								    ^~~~~~~~ /usr/include/c++/8/system_error:331:3:
							      								    								  note:	  no known conversion for argument 1 from ‘s
							      								    								  td::set<int>::iterator’ {aka ‘std::_Rb_tree_const_
							      								    								  iterator<int>’} to ‘const std::error_condition&’ I
							      								    								  n file included from /usr/include/c++/8/bits/local
							      								    								  e_facets.h:48,		  from /usr/include/
							      								    								  c++/8/bits/basic_ios.h:37,		      from /
							      								    								  usr/include/c++/8/ios:44,		     from /u
							      								    								  sr/include/c++/8/ostream:38,			from
							      								    								   /usr/include/c++/8/iostream:39,
							      								    								  from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:
							      								    								  8: /usr/include/c++/8/bits/streambuf_iterator.h:20
							      								    								  9:5: note: candidate: ‘template<class _CharT, clas
							      								    								  s _Traits> bool std::operator!=(const std::istream
							      								    								  buf_iterator<_CharT, _Traits>&, const std::istream
							      								    								  buf_iterator<_CharT, _Traits>&)’	operator!=(c
							      								    								  onst istreambuf_iterator<_CharT, _Traits>& __a,
							      								    								     ^~~~~~~~ /usr/include/c++/8/bits/streambuf_iter
							      								    								  ator.h:209:5: note:	template argument deduction/
							      								    								  substitution failed: FIND_RECTANGLE_BINARY_MATRIX_
							      								    								  CORNERS_1_1.cpp:56:99: note:	 ‘std::set<int>::ite
							      								    								  rator’ {aka ‘std::_Rb_tree_const_iterator<int>’} i
							      								    								  s not derived from ‘const std::istreambuf_iterator
							      								    								  <_CharT, _Traits>’		if ( table . find (
							      								    								  j ) != table . end ( ) && table [ j ] . find ( k )
							      								    								   != table . end ( ) ) return true ;
							      								    								  
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/vector:64,
							      								    								  	from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_
							      								    								  1.cpp:11: /usr/include/c++/8/bits/stl_vector.h:177
							      								    								  7:5: note: candidate: ‘template<class _Tp, class _
							      								    								  Alloc> bool std::operator!=(const std::vector<_Tp,
							      								    								   _Alloc>&, const std::vector<_Tp, _Alloc>&)’
							      								    								  operator!=(const vector<_Tp, _Alloc>& __x, const v
							      								    								  ector<_Tp, _Alloc>& __y)	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/stl_vector.h:1777:5: note:   template
							      								    								   argument deduction/substitution failed: FIND_RECT
							      								    								  ANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:
							      								    								   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_con
							      								    								  st_iterator<int>’} is not derived from ‘const std:
							      								    								  :vector<_Tp, _Alloc>’		   if ( table . find
							      								    								   ( j ) != table . end ( ) && table [ j ] . find (
							      								    								  k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					^ In file in
							      								    								  cluded from /usr/include/c++/8/tuple:39,
							      								    								  	  from /usr/include/c++/8/bits/unique_ptr.h:
							      								    								  37,		       from /usr/include/c++/8/bits/
							      								    								  locale_conv.h:41,		     from /usr/inclu
							      								    								  de/c++/8/locale:43,		       from /usr/inc
							      								    								  lude/c++/8/iomanip:43,		  from FIND_
							      								    								  RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:13: /usr/i
							      								    								  nclude/c++/8/array:257:5: note: candidate: ‘templa
							      								    								  te<class _Tp, long unsigned int _Nm> bool std::ope
							      								    								  rator!=(const std::array<_Tp, _Nm>&, const std::ar
							      								    								  ray<_Tp, _Nm>&)’	operator!=(const array<_Tp,
							      								    								  _Nm>& __one, const array<_Tp, _Nm>& __two)	  ^~
							      								    								  ~~~~~~ /usr/include/c++/8/array:257:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: no
							      								    								  te:	‘std::set<int>::iterator’ {aka ‘std::_Rb_tre
							      								    								  e_const_iterator<int>’} is not derived from ‘const
							      								    								   std::array<_Tp, _Nm>’	    if ( table . fin
							      								    								  d ( j ) != table . end ( ) && table [ j ] . find (
							      								    								   k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/bits/unique_ptr.h:
							      								    								  37,		       from /usr/include/c++/8/bits/
							      								    								  locale_conv.h:41,		     from /usr/inclu
							      								    								  de/c++/8/locale:43,		       from /usr/inc
							      								    								  lude/c++/8/iomanip:43,		  from FIND_
							      								    								  RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:13: /usr/i
							      								    								  nclude/c++/8/tuple:1439:5: note: candidate: ‘templ
							      								    								  ate<class ... _TElements, class ... _UElements> co
							      								    								  nstexpr bool std::operator!=(const std::tuple<_Tps
							      								    								   ...>&, const std::tuple<_Elements ...>&)’	  op
							      								    								  erator!=(const tuple<_TElements...>& __t,	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/tuple:1439:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: no
							      								    								  te:	‘std::set<int>::iterator’ {aka ‘std::_Rb_tre
							      								    								  e_const_iterator<int>’} is not derived from ‘const
							      								    								   std::tuple<_Tps ...>’	    if ( table . fin
							      								    								  d ( j ) != table . end ( ) && table [ j ] . find (
							      								    								   k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/bits/locale_conv.h
							      								    								  :41,			from /usr/include/c++/8/loca
							      								    								  le:43,		  from /usr/include/c++/8/io
							      								    								  manip:43,		     from FIND_RECTANGLE_BIN
							      								    								  ARY_MATRIX_CORNERS_1_1.cpp:13: /usr/include/c++/8/
							      								    								  bits/unique_ptr.h:710:5: note: candidate: ‘templat
							      								    								  e<class _Tp, class _Dp, class _Up, class _Ep> bool
							      								    								   std::operator!=(const std::unique_ptr<_Tp, _Dp>&,
							      								    								   const std::unique_ptr<_Up, _Ep>&)’	   operator!
							      								    								  =(const unique_ptr<_Tp, _Dp>& __x,	  ^~~~~~~~ /
							      								    								  usr/include/c++/8/bits/unique_ptr.h:710:5: note:
							      								    								   template argument deduction/substitution failed:
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99
							      								    								  : note:   ‘std::set<int>::iterator’ {aka ‘std::_Rb
							      								    								  _tree_const_iterator<int>’} is not derived from ‘c
							      								    								  onst std::unique_ptr<_Tp, _Dp>’	     if ( ta
							      								    								  ble . find ( j ) != table . end ( ) && table [ j ]
							      								    								   . find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						  ^
							      								    								  In file included from /usr/include/c++/8/bits/loca
							      								    								  le_conv.h:41,			 from /usr/include/c
							      								    								  ++/8/locale:43,		   from /usr/include
							      								    								  /c++/8/iomanip:43,		      from FIND_RECT
							      								    								  ANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:13: /usr/inclu
							      								    								  de/c++/8/bits/unique_ptr.h:716:5: note: candidate:
							      								    								   ‘template<class _Tp, class _Dp> bool std::operato
							      								    								  r!=(const std::unique_ptr<_Tp, _Dp>&, std::nullptr
							      								    								  _t)’	    operator!=(const unique_ptr<_Tp, _Dp>& _
							      								    								  _x, nullptr_t) noexcept      ^~~~~~~~ /usr/include
							      								    								  /c++/8/bits/unique_ptr.h:716:5: note:	  template a
							      								    								  rgument deduction/substitution failed: FIND_RECTAN
							      								    								  GLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘
							      								    								  std::set<int>::iterator’ {aka ‘std::_Rb_tree_const
							      								    								  _iterator<int>’} is not derived from ‘const std::u
							      								    								  nique_ptr<_Tp, _Dp>’		  if ( table . find
							      								    								  ( j ) != table . end ( ) && table [ j ] . find ( k
							      								    								   ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  				       ^ In file inc
							      								    								  luded from /usr/include/c++/8/bits/locale_conv.h:4
							      								    								  1,		      from /usr/include/c++/8/locale
							      								    								  :43,			from /usr/include/c++/8/ioma
							      								    								  nip:43,		   from FIND_RECTANGLE_BINAR
							      								    								  Y_MATRIX_CORNERS_1_1.cpp:13: /usr/include/c++/8/bi
							      								    								  ts/unique_ptr.h:721:5: note: candidate: ‘template<
							      								    								  class _Tp, class _Dp> bool std::operator!=(std::nu
							      								    								  llptr_t, const std::unique_ptr<_Tp, _Dp>&)’	   o
							      								    								  perator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& _
							      								    								  _x) noexcept	    ^~~~~~~~ /usr/include/c++/8/bits
							      								    								  /unique_ptr.h:721:5: note:   template argument ded
							      								    								  uction/substitution failed: FIND_RECTANGLE_BINARY_
							      								    								  MATRIX_CORNERS_1_1.cpp:56:99: note:	‘std::unorde
							      								    								  red_map<int, std::set<int> >::iterator’ {aka ‘std:
							      								    								  :__detail::_Node_iterator<std::pair<const int, std
							      								    								  ::set<int> >, false, false>’} is not derived from
							      								    								  ‘const std::unique_ptr<_Tp, _Dp>’	       if (
							      								    								  table . find ( j ) != table . end ( ) && table [ j
							      								    								   ] . find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  
							      								    								  ^ In file included from /usr/include/c++/8/ccomple
							      								    								  x:39,			 from /usr/include/c++/8/x86
							      								    								  _64-redhat-linux/bits/stdc++.h:52,
							      								    								    from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:14: /usr/include/c++/8/complex:476:5: note: cand
							      								    								  idate: ‘template<class _Tp> constexpr bool std::op
							      								    								  erator!=(const std::complex<_Tp>&, const std::comp
							      								    								  lex<_Tp>&)’	   operator!=(const complex<_Tp>& __
							      								    								  x, const complex<_Tp>& __y)	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/complex:476:5: note:   template argumen
							      								    								  t deduction/substitution failed: FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::s
							      								    								  et<int>::iterator’ {aka ‘std::_Rb_tree_const_itera
							      								    								  tor<int>’} is not derived from ‘const std::complex
							      								    								  <_Tp>’	    if ( table . find ( j ) != table
							      								    								   . end ( ) && table [ j ] . find ( k ) != table .
							      								    								  end ( ) ) return true ;
							      								    								  
							      								    								  			 ^ In file included from /us
							      								    								  r/include/c++/8/ccomplex:39,			from
							      								    								   /usr/include/c++/8/x86_64-redhat-linux/bits/stdc+
							      								    								  +.h:52,		   from FIND_RECTANGLE_BINAR
							      								    								  Y_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/co
							      								    								  mplex:481:5: note: candidate: ‘template<class _Tp>
							      								    								   constexpr bool std::operator!=(const std::complex
							      								    								  <_Tp>&, const _Tp&)’	    operator!=(const complex
							      								    								  <_Tp>& __x, const _Tp& __y)	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/complex:481:5: note:   template argumen
							      								    								  t deduction/substitution failed: FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::s
							      								    								  et<int>::iterator’ {aka ‘std::_Rb_tree_const_itera
							      								    								  tor<int>’} is not derived from ‘const std::complex
							      								    								  <_Tp>’	    if ( table . find ( j ) != table
							      								    								   . end ( ) && table [ j ] . find ( k ) != table .
							      								    								  end ( ) ) return true ;
							      								    								  
							      								    								  			 ^ In file included from /us
							      								    								  r/include/c++/8/ccomplex:39,			from
							      								    								   /usr/include/c++/8/x86_64-redhat-linux/bits/stdc+
							      								    								  +.h:52,		   from FIND_RECTANGLE_BINAR
							      								    								  Y_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/co
							      								    								  mplex:486:5: note: candidate: ‘template<class _Tp>
							      								    								   constexpr bool std::operator!=(const _Tp&, const
							      								    								  std::complex<_Tp>&)’	    operator!=(const _Tp& __
							      								    								  x, const complex<_Tp>& __y)	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/complex:486:5: note:   template argumen
							      								    								  t deduction/substitution failed: FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::u
							      								    								  nordered_map<int, std::set<int> >::iterator’ {aka
							      								    								  ‘std::__detail::_Node_iterator<std::pair<const int
							      								    								  , std::set<int> >, false, false>’} is not derived
							      								    								  from ‘const std::complex<_Tp>’	    if ( tab
							      								    								  le . find ( j ) != table . end ( ) && table [ j ]
							      								    								  . find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						 ^ I
							      								    								  n file included from /usr/include/c++/8/deque:64,
							      								    								  		   from /usr/include/c++/8/x86_64-re
							      								    								  dhat-linux/bits/stdc++.h:68,			from
							      								    								   FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14:
							      								    								  /usr/include/c++/8/bits/stl_deque.h:281:5: note: c
							      								    								  andidate: ‘template<class _Tp, class _Ref, class _
							      								    								  Ptr> bool std::operator!=(const std::_Deque_iterat
							      								    								  or<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_
							      								    								  Tp, _Ref, _Ptr>&)’	  operator!=(const _Deque_it
							      								    								  erator<_Tp, _Ref, _Ptr>& __x,	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/stl_deque.h:281:5: note:   templ
							      								    								  ate argument deduction/substitution failed: FIND_R
							      								    								  ECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note
							      								    								  :   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_
							      								    								  const_iterator<int>’} is not derived from ‘const s
							      								    								  td::_Deque_iterator<_Tp, _Ref, _Ptr>’		   i
							      								    								  f ( table . find ( j ) != table . end ( ) && table
							      								    								   [ j ] . find ( k ) != table . end ( ) ) return tr
							      								    								  ue ;
							      								    								  
							      								    								      ^ In file included from /usr/include/c++/8/deq
							      								    								  ue:64,		  from /usr/include/c++/8/x8
							      								    								  6_64-redhat-linux/bits/stdc++.h:68,
							      								    								     from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.c
							      								    								  pp:14: /usr/include/c++/8/bits/stl_deque.h:288:5:
							      								    								  note: candidate: ‘template<class _Tp, class _RefL,
							      								    								   class _PtrL, class _RefR, class _PtrR> bool std::
							      								    								  operator!=(const std::_Deque_iterator<_Tp, _Ref, _
							      								    								  Ptr>&, const std::_Deque_iterator<_Tp, _RefR, _Ptr
							      								    								  R>&)’	     operator!=(const _Deque_iterator<_Tp, _
							      								    								  RefL, _PtrL>& __x,	  ^~~~~~~~ /usr/include/c++/
							      								    								  8/bits/stl_deque.h:288:5: note:   template argumen
							      								    								  t deduction/substitution failed: FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::s
							      								    								  et<int>::iterator’ {aka ‘std::_Rb_tree_const_itera
							      								    								  tor<int>’} is not derived from ‘const std::_Deque_
							      								    								  iterator<_Tp, _Ref, _Ptr>’		if ( table .
							      								    								   find ( j ) != table . end ( ) && table [ j ] . fi
							      								    								  nd ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					     ^ In fi
							      								    								  le included from /usr/include/c++/8/deque:64,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:68,		    from FIN
							      								    								  D_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr
							      								    								  /include/c++/8/bits/stl_deque.h:2303:5: note: cand
							      								    								  idate: ‘template<class _Tp, class _Alloc> bool std
							      								    								  ::operator!=(const std::deque<_Tp, _Alloc>&, const
							      								    								   std::deque<_Tp, _Alloc>&)’	   operator!=(const
							      								    								  deque<_Tp, _Alloc>& __x,	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/stl_deque.h:2303:5: note:   template
							      								    								  argument deduction/substitution failed: FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:
							      								    								  ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_cons
							      								    								  t_iterator<int>’} is not derived from ‘const std::
							      								    								  deque<_Tp, _Alloc>’		 if ( table . find (
							      								    								   j ) != table . end ( ) && table [ j ] . find ( k
							      								    								  ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  				      ^ In file incl
							      								    								  uded from /usr/include/c++/8/functional:59,
							      								    								  	     from /usr/include/c++/8/x86_64-redhat-l
							      								    								  inux/bits/stdc++.h:71,		  from FIND_
							      								    								  RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/i
							      								    								  nclude/c++/8/bits/std_function.h:763:5: note: cand
							      								    								  idate: ‘template<class _Res, class ... _Args> bool
							      								    								   std::operator!=(const std::function<_Res(_ArgType
							      								    								  s ...)>&, std::nullptr_t)’	  operator!=(const f
							      								    								  unction<_Res(_Args...)>& __f, nullptr_t) noexcept
							      								    								       ^~~~~~~~ /usr/include/c++/8/bits/std_function
							      								    								  .h:763:5: note:   template argument deduction/subs
							      								    								  titution failed: FIND_RECTANGLE_BINARY_MATRIX_CORN
							      								    								  ERS_1_1.cpp:56:99: note:   ‘std::set<int>::iterato
							      								    								  r’ {aka ‘std::_Rb_tree_const_iterator<int>’} is no
							      								    								  t derived from ‘const std::function<_Res(_ArgTypes
							      								    								   ...)>’	     if ( table . find ( j ) != tabl
							      								    								  e . end ( ) && table [ j ] . find ( k ) != table .
							      								    								   end ( ) ) return true ;
							      								    								  
							      								    								  			  ^ In file included from /u
							      								    								  sr/include/c++/8/functional:59,		   f
							      								    								  rom /usr/include/c++/8/x86_64-redhat-linux/bits/st
							      								    								  dc++.h:71,		      from FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8
							      								    								  /bits/std_function.h:769:5: note: candidate: ‘temp
							      								    								  late<class _Res, class ... _Args> bool std::operat
							      								    								  or!=(std::nullptr_t, const std::function<_Res(_Arg
							      								    								  Types ...)>&)’      operator!=(nullptr_t, const fu
							      								    								  nction<_Res(_Args...)>& __f) noexcept	     ^~~~~~~
							      								    								  ~ /usr/include/c++/8/bits/std_function.h:769:5: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:
							      								    								  56:99: note:	 ‘std::unordered_map<int, std::set<i
							      								    								  nt> >::iterator’ {aka ‘std::__detail::_Node_iterat
							      								    								  or<std::pair<const int, std::set<int> >, false, fa
							      								    								  lse>’} is not derived from ‘const std::function<_R
							      								    								  es(_ArgTypes ...)>’		 if ( table . find (
							      								    								   j ) != table . end ( ) && table [ j ] . find ( k
							      								    								  ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  				      ^ In file incl
							      								    								  uded from /usr/include/c++/8/iterator:66,
							      								    								  	   from /usr/include/c++/8/x86_64-redhat-lin
							      								    								  ux/bits/stdc++.h:77,			from FIND_RE
							      								    								  CTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/inc
							      								    								  lude/c++/8/bits/stream_iterator.h:137:5: note: can
							      								    								  didate: ‘template<class _Tp, class _CharT, class _
							      								    								  Traits, class _Dist> bool std::operator!=(const st
							      								    								  d::istream_iterator<_Tp, _CharT, _Traits, _Dist>&,
							      								    								   const std::istream_iterator<_Tp, _CharT, _Traits,
							      								    								   _Dist>&)’	  operator!=(const istream_iterator<
							      								    								  _Tp, _CharT, _Traits, _Dist>& __x,	  ^~~~~~~~ /
							      								    								  usr/include/c++/8/bits/stream_iterator.h:137:5: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:
							      								    								  56:99: note:	 ‘std::set<int>::iterator’ {aka ‘std
							      								    								  ::_Rb_tree_const_iterator<int>’} is not derived fr
							      								    								  om ‘const std::istream_iterator<_Tp, _CharT, _Trai
							      								    								  ts, _Dist>’		 if ( table . find ( j ) !=
							      								    								  table . end ( ) && table [ j ] . find ( k ) != tab
							      								    								  le . end ( ) ) return true ;
							      								    								  
							      								    								  			      ^ In file included fro
							      								    								  m /usr/include/c++/8/list:63,			 fro
							      								    								  m /usr/include/c++/8/x86_64-redhat-linux/bits/stdc
							      								    								  ++.h:79,		    from FIND_RECTANGLE_BINA
							      								    								  RY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/b
							      								    								  its/stl_list.h:350:5: note: candidate: ‘template<c
							      								    								  lass _Val> bool std::operator!=(const std::_List_i
							      								    								  terator<_Tp>&, const std::_List_const_iterator<_Tp
							      								    								  >&)’	    operator!=(const _List_iterator<_Val>& _
							      								    								  _x,	   ^~~~~~~~ /usr/include/c++/8/bits/stl_list
							      								    								  .h:350:5: note:   template argument deduction/subs
							      								    								  titution failed: FIND_RECTANGLE_BINARY_MATRIX_CORN
							      								    								  ERS_1_1.cpp:56:99: note:   ‘std::set<int>::iterato
							      								    								  r’ {aka ‘std::_Rb_tree_const_iterator<int>’} is no
							      								    								  t derived from ‘const std::_List_iterator<_Tp>’
							      								    								  	   if ( table . find ( j ) != table . end (
							      								    								  ) && table [ j ] . find ( k ) != table . end ( ) )
							      								    								   return true ;
							      								    								  
							      								    								  		^ In file included from /usr/include
							      								    								  /c++/8/list:63,		   from /usr/include
							      								    								  /c++/8/x86_64-redhat-linux/bits/stdc++.h:79,
							      								    								  	      from FIND_RECTANGLE_BINARY_MATRIX_CORN
							      								    								  ERS_1_1.cpp:14: /usr/include/c++/8/bits/stl_list.h
							      								    								  :2028:5: note: candidate: ‘template<class _Tp, cla
							      								    								  ss _Alloc> bool std::operator!=(const std::__cxx11
							      								    								  ::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp
							      								    								  , _Alloc>&)’	    operator!=(const list<_Tp, _Allo
							      								    								  c>& __x, const list<_Tp, _Alloc>& __y)      ^~~~~~
							      								    								  ~~ /usr/include/c++/8/bits/stl_list.h:2028:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56
							      								    								  :99: note:   ‘std::set<int>::iterator’ {aka ‘std::
							      								    								  _Rb_tree_const_iterator<int>’} is not derived from
							      								    								   ‘const std::__cxx11::list<_Tp, _Alloc>’
							      								    								    if ( table . find ( j ) != table . end ( ) && ta
							      								    								  ble [ j ] . find ( k ) != table . end ( ) ) return
							      								    								   true ;
							      								    								  
							      								    								  	 ^ In file included from /usr/include/c++/8/
							      								    								  map:60,		   from /usr/include/c++/8/x
							      								    								  86_64-redhat-linux/bits/stdc++.h:81,
							      								    								      from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.
							      								    								  cpp:14: /usr/include/c++/8/bits/stl_tree.h:412:5:
							      								    								  note: candidate: ‘template<class _Val> bool std::o
							      								    								  perator!=(const std::_Rb_tree_iterator<_Tp>&, cons
							      								    								  t std::_Rb_tree_const_iterator<_Val>&)’      opera
							      								    								  tor!=(const _Rb_tree_iterator<_Val>& __x,	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/bits/stl_tree.h:412:5: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:
							      								    								  56:99: note:	 ‘std::set<int>::iterator’ {aka ‘std
							      								    								  ::_Rb_tree_const_iterator<int>’} is not derived fr
							      								    								  om ‘const std::_Rb_tree_iterator<_Tp>’
							      								    								  if ( table . find ( j ) != table . end ( ) && tabl
							      								    								  e [ j ] . find ( k ) != table . end ( ) ) return t
							      								    								  rue ;
							      								    								  
							      								    								       ^ In file included from /usr/include/c++/8/ma
							      								    								  p:60,			 from /usr/include/c++/8/x86
							      								    								  _64-redhat-linux/bits/stdc++.h:81,
							      								    								    from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:14: /usr/include/c++/8/bits/stl_tree.h:1576:5: n
							      								    								  ote: candidate: ‘template<class _Key, class _Val,
							      								    								  class _KeyOfValue, class _Compare, class _Alloc> b
							      								    								  ool std::operator!=(const std::_Rb_tree<_Key, _Val
							      								    								  , _KeyOfValue, _Compare, _Alloc>&, const std::_Rb_
							      								    								  tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&)’
							      								    								  	operator!=(const _Rb_tree<_Key, _Val, _KeyOf
							      								    								  Value, _Compare, _Alloc>& __x,      ^~~~~~~~ /usr/
							      								    								  include/c++/8/bits/stl_tree.h:1576:5: note:	temp
							      								    								  late argument deduction/substitution failed: FIND_
							      								    								  RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: not
							      								    								  e:   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree
							      								    								  _const_iterator<int>’} is not derived from ‘const
							      								    								  std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _
							      								    								  Alloc>’	     if ( table . find ( j ) != tabl
							      								    								  e . end ( ) && table [ j ] . find ( k ) != table .
							      								    								   end ( ) ) return true ;
							      								    								  
							      								    								  			  ^ In file included from /u
							      								    								  sr/include/c++/8/map:61,		    from /us
							      								    								  r/include/c++/8/x86_64-redhat-linux/bits/stdc++.h:
							      								    								  81,		       from FIND_RECTANGLE_BINARY_MA
							      								    								  TRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/s
							      								    								  tl_map.h:1458:5: note: candidate: ‘template<class
							      								    								  _Key, class _Tp, class _Compare, class _Alloc> boo
							      								    								  l std::operator!=(const std::map<_Key, _Tp, _Compa
							      								    								  re, _Alloc>&, const std::map<_Key, _Tp, _Compare,
							      								    								  _Alloc>&)’	  operator!=(const map<_Key, _Tp, _C
							      								    								  ompare, _Alloc>& __x,	     ^~~~~~~~ /usr/include/c
							      								    								  ++/8/bits/stl_map.h:1458:5: note:   template argum
							      								    								  ent deduction/substitution failed: FIND_RECTANGLE_
							      								    								  BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std:
							      								    								  :set<int>::iterator’ {aka ‘std::_Rb_tree_const_ite
							      								    								  rator<int>’} is not derived from ‘const std::map<_
							      								    								  Key, _Tp, _Compare, _Alloc>’		  if ( table
							      								    								   . find ( j ) != table . end ( ) && table [ j ] .
							      								    								  find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					       ^ In
							      								    								  file included from /usr/include/c++/8/map:62,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:81,		    from FIN
							      								    								  D_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr
							      								    								  /include/c++/8/bits/stl_multimap.h:1122:5: note: c
							      								    								  andidate: ‘template<class _Key, class _Tp, class _
							      								    								  Compare, class _Alloc> bool std::operator!=(const
							      								    								  std::multimap<_Key, _Tp, _Compare, _Alloc>&, const
							      								    								   std::multimap<_Key, _Tp, _Compare, _Alloc>&)’
							      								    								    operator!=(const multimap<_Key, _Tp, _Compare, _
							      								    								  Alloc>& __x,	    ^~~~~~~~ /usr/include/c++/8/bits
							      								    								  /stl_multimap.h:1122:5: note:	  template argument
							      								    								  deduction/substitution failed: FIND_RECTANGLE_BINA
							      								    								  RY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::set
							      								    								  <int>::iterator’ {aka ‘std::_Rb_tree_const_iterato
							      								    								  r<int>’} is not derived from ‘const std::multimap<
							      								    								  _Key, _Tp, _Compare, _Alloc>’		   if ( tabl
							      								    								  e . find ( j ) != table . end ( ) && table [ j ] .
							      								    								   find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						^ In
							      								    								   file included from /usr/include/c++/8/bits/shared
							      								    								  _ptr.h:52,		      from /usr/include/c++/
							      								    								  8/memory:81,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:82,
							      								    								  	   from FIND_RECTANGLE_BINARY_MATRIX_CORNERS
							      								    								  _1_1.cpp:14: /usr/include/c++/8/bits/shared_ptr_ba
							      								    								  se.h:1426:5: note: candidate: ‘template<class _Tp1
							      								    								  , class _Tp2, __gnu_cxx::_Lock_policy _Lp> bool st
							      								    								  d::operator!=(const std::__shared_ptr<_Tp1, _Lp>&,
							      								    								   const std::__shared_ptr<_Tp2, _Lp>&)’      operat
							      								    								  or!=(const __shared_ptr<_Tp1, _Lp>& __a,	^~~~
							      								    								  ~~~~ /usr/include/c++/8/bits/shared_ptr_base.h:142
							      								    								  6:5: note:   template argument deduction/substitut
							      								    								  ion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
							      								    								  _1.cpp:56:99: note:	‘std::set<int>::iterator’ {a
							      								    								  ka ‘std::_Rb_tree_const_iterator<int>’} is not der
							      								    								  ived from ‘const std::__shared_ptr<_Tp1, _Lp>’
							      								    								  	  if ( table . find ( j ) != table . end ( )
							      								    								   && table [ j ] . find ( k ) != table . end ( ) )
							      								    								  return true ;
							      								    								  
							      								    								  	       ^ In file included from /usr/include/
							      								    								  c++/8/bits/shared_ptr.h:52,		       from
							      								    								  /usr/include/c++/8/memory:81,			 fro
							      								    								  m /usr/include/c++/8/x86_64-redhat-linux/bits/stdc
							      								    								  ++.h:82,		    from FIND_RECTANGLE_BINA
							      								    								  RY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/b
							      								    								  its/shared_ptr_base.h:1432:5: note: candidate: ‘te
							      								    								  mplate<class _Tp, __gnu_cxx::_Lock_policy _Lp> boo
							      								    								  l std::operator!=(const std::__shared_ptr<_Tp, _Lp
							      								    								  >&, std::nullptr_t)’	    operator!=(const __share
							      								    								  d_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/bits/shared_ptr_base.h:14
							      								    								  32:5: note:	template argument deduction/substitu
							      								    								  tion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_
							      								    								  1_1.cpp:56:99: note:	 ‘std::set<int>::iterator’ {
							      								    								  aka ‘std::_Rb_tree_const_iterator<int>’} is not de
							      								    								  rived from ‘const std::__shared_ptr<_Tp, _Lp>’
							      								    								  	  if ( table . find ( j ) != table . end ( )
							      								    								   && table [ j ] . find ( k ) != table . end ( ) )
							      								    								  return true ;
							      								    								  
							      								    								  	       ^ In file included from /usr/include/
							      								    								  c++/8/bits/shared_ptr.h:52,		       from
							      								    								  /usr/include/c++/8/memory:81,			 fro
							      								    								  m /usr/include/c++/8/x86_64-redhat-linux/bits/stdc
							      								    								  ++.h:82,		    from FIND_RECTANGLE_BINA
							      								    								  RY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/b
							      								    								  its/shared_ptr_base.h:1437:5: note: candidate: ‘te
							      								    								  mplate<class _Tp, __gnu_cxx::_Lock_policy _Lp> boo
							      								    								  l std::operator!=(std::nullptr_t, const std::__sha
							      								    								  red_ptr<_Tp, _Lp>&)’	    operator!=(nullptr_t, co
							      								    								  nst __shared_ptr<_Tp, _Lp>& __a) noexcept	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/bits/shared_ptr_base.h:14
							      								    								  37:5: note:	template argument deduction/substitu
							      								    								  tion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_
							      								    								  1_1.cpp:56:99: note:	 ‘std::unordered_map<int, st
							      								    								  d::set<int> >::iterator’ {aka ‘std::__detail::_Nod
							      								    								  e_iterator<std::pair<const int, std::set<int> >, f
							      								    								  alse, false>’} is not derived from ‘const std::__s
							      								    								  hared_ptr<_Tp, _Lp>’		  if ( table . find
							      								    								  ( j ) != table . end ( ) && table [ j ] . find ( k
							      								    								   ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  				       ^ In file inc
							      								    								  luded from /usr/include/c++/8/memory:81,
							      								    								  	  from /usr/include/c++/8/x86_64-redhat-linu
							      								    								  x/bits/stdc++.h:82,		       from FIND_REC
							      								    								  TANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/incl
							      								    								  ude/c++/8/bits/shared_ptr.h:398:5: note: candidate
							      								    								  : ‘template<class _Tp, class _Up> bool std::operat
							      								    								  or!=(const std::shared_ptr<_Tp>&, const std::share
							      								    								  d_ptr<_Tp>&)’	     operator!=(const shared_ptr<_Tp
							      								    								  >& __a, const shared_ptr<_Up>& __b) noexcept
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr.h:398:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1
							      								    								  .cpp:56:99: note:   ‘std::set<int>::iterator’ {aka
							      								    								   ‘std::_Rb_tree_const_iterator<int>’} is not deriv
							      								    								  ed from ‘const std::shared_ptr<_Tp>’		  if
							      								    								   ( table . find ( j ) != table . end ( ) && table
							      								    								  [ j ] . find ( k ) != table . end ( ) ) return tru
							      								    								  e ;
							      								    								  
							      								    								     ^ In file included from /usr/include/c++/8/memo
							      								    								  ry:81,		  from /usr/include/c++/8/x8
							      								    								  6_64-redhat-linux/bits/stdc++.h:82,
							      								    								     from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.c
							      								    								  pp:14: /usr/include/c++/8/bits/shared_ptr.h:403:5:
							      								    								   note: candidate: ‘template<class _Tp> bool std::o
							      								    								  perator!=(const std::shared_ptr<_Tp>&, std::nullpt
							      								    								  r_t)’	     operator!=(const shared_ptr<_Tp>& __a,
							      								    								  nullptr_t) noexcept	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/shared_ptr.h:403:5: note:   template argum
							      								    								  ent deduction/substitution failed: FIND_RECTANGLE_
							      								    								  BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std:
							      								    								  :set<int>::iterator’ {aka ‘std::_Rb_tree_const_ite
							      								    								  rator<int>’} is not derived from ‘const std::share
							      								    								  d_ptr<_Tp>’		 if ( table . find ( j ) !=
							      								    								  table . end ( ) && table [ j ] . find ( k ) != tab
							      								    								  le . end ( ) ) return true ;
							      								    								  
							      								    								  			      ^ In file included fro
							      								    								  m /usr/include/c++/8/memory:81,		   f
							      								    								  rom /usr/include/c++/8/x86_64-redhat-linux/bits/st
							      								    								  dc++.h:82,		      from FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8
							      								    								  /bits/shared_ptr.h:408:5: note: candidate: ‘templa
							      								    								  te<class _Tp> bool std::operator!=(std::nullptr_t,
							      								    								   const std::shared_ptr<_Tp>&)’      operator!=(nul
							      								    								  lptr_t, const shared_ptr<_Tp>& __a) noexcept
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr.h:408:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1
							      								    								  .cpp:56:99: note:   ‘std::unordered_map<int, std::
							      								    								  set<int> >::iterator’ {aka ‘std::__detail::_Node_i
							      								    								  terator<std::pair<const int, std::set<int> >, fals
							      								    								  e, false>’} is not derived from ‘const std::shared
							      								    								  _ptr<_Tp>’		if ( table . find ( j ) != t
							      								    								  able . end ( ) && table [ j ] . find ( k ) != tabl
							      								    								  e . end ( ) ) return true ;
							      								    								  
							      								    								  			     ^ In file included from
							      								    								   /usr/include/c++/8/queue:64,			 fro
							      								    								  m /usr/include/c++/8/x86_64-redhat-linux/bits/stdc
							      								    								  ++.h:86,		    from FIND_RECTANGLE_BINA
							      								    								  RY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/b
							      								    								  its/stl_queue.h:354:5: note: candidate: ‘template<
							      								    								  class _Tp, class _Seq> bool std::operator!=(const
							      								    								  std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq
							      								    								  >&)’	    operator!=(const queue<_Tp, _Seq>& __x,
							      								    								  const queue<_Tp, _Seq>& __y)	    ^~~~~~~~ /usr/in
							      								    								  clude/c++/8/bits/stl_queue.h:354:5: note:   templa
							      								    								  te argument deduction/substitution failed: FIND_RE
							      								    								  CTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:
							      								    								     ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_c
							      								    								  onst_iterator<int>’} is not derived from ‘const st
							      								    								  d::queue<_Tp, _Seq>’		  if ( table . find
							      								    								  ( j ) != table . end ( ) && table [ j ] . find ( k
							      								    								   ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  				       ^ In file inc
							      								    								  luded from /usr/include/c++/8/set:61,
							      								    								       from /usr/include/c++/8/x86_64-redhat-linux/b
							      								    								  its/stdc++.h:87,		    from FIND_RECTAN
							      								    								  GLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include
							      								    								  /c++/8/bits/stl_set.h:982:5: note: candidate: ‘tem
							      								    								  plate<class _Key, class _Compare, class _Alloc> bo
							      								    								  ol std::operator!=(const std::set<_Key, _Compare,
							      								    								  _Alloc>&, const std::set<_Key, _Compare, _Alloc>&)
							      								    								  ’	 operator!=(const set<_Key, _Compare, _Alloc
							      								    								  >& __x,      ^~~~~~~~ /usr/include/c++/8/bits/stl_
							      								    								  set.h:982:5: note:   template argument deduction/s
							      								    								  ubstitution failed: FIND_RECTANGLE_BINARY_MATRIX_C
							      								    								  ORNERS_1_1.cpp:56:99: note:	‘std::set<int>::iter
							      								    								  ator’ {aka ‘std::_Rb_tree_const_iterator<int>’} is
							      								    								   not derived from ‘const std::set<_Key, _Compare,
							      								    								  _Alloc>’	      if ( table . find ( j ) != tab
							      								    								  le . end ( ) && table [ j ] . find ( k ) != table
							      								    								  . end ( ) ) return true ;
							      								    								  
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/set:62,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :87,			from FIND_RECTANGLE_BINARY_M
							      								    								  ATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/
							      								    								  stl_multiset.h:967:5: note: candidate: ‘template<c
							      								    								  lass _Key, class _Compare, class _Alloc> bool std:
							      								    								  :operator!=(const std::multiset<_Key, _Compare, _A
							      								    								  lloc>&, const std::multiset<_Key, _Compare, _Alloc
							      								    								  >&)’	    operator!=(const multiset<_Key, _Compare
							      								    								  , _Alloc>& __x,      ^~~~~~~~ /usr/include/c++/8/b
							      								    								  its/stl_multiset.h:967:5: note:   template argumen
							      								    								  t deduction/substitution failed: FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::s
							      								    								  et<int>::iterator’ {aka ‘std::_Rb_tree_const_itera
							      								    								  tor<int>’} is not derived from ‘const std::multise
							      								    								  t<_Key, _Compare, _Alloc>’		if ( table .
							      								    								   find ( j ) != table . end ( ) && table [ j ] . fi
							      								    								  nd ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					     ^ In fi
							      								    								  le included from /usr/include/c++/8/stack:61,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:89,		    from FIN
							      								    								  D_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr
							      								    								  /include/c++/8/bits/stl_stack.h:329:5: note: candi
							      								    								  date: ‘template<class _Tp, class _Seq> bool std::o
							      								    								  perator!=(const std::stack<_Tp, _Seq>&, const std:
							      								    								  :stack<_Tp, _Seq>&)’	    operator!=(const stack<_
							      								    								  Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/stl_stack.h:329:5
							      								    								  : note:   template argument deduction/substitution
							      								    								   failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.
							      								    								  cpp:56:99: note:   ‘std::set<int>::iterator’ {aka
							      								    								  ‘std::_Rb_tree_const_iterator<int>’} is not derive
							      								    								  d from ‘const std::stack<_Tp, _Seq>’		  if
							      								    								   ( table . find ( j ) != table . end ( ) && table
							      								    								  [ j ] . find ( k ) != table . end ( ) ) return tru
							      								    								  e ;
							      								    								  
							      								    								     ^ In file included from /usr/include/c++/8/vala
							      								    								  rray:592,		     from /usr/include/c++/8
							      								    								  /x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  	from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_
							      								    								  1.cpp:14: /usr/include/c++/8/bits/valarray_after.h
							      								    								  :415:5: note: candidate: ‘template<class _Dom1, cl
							      								    								  ass _Dom2> std::_Expr<std::_BinClos<std::__not_equ
							      								    								  al_to, std::_Expr, std::_Expr, _Dom1, _Dom2>, type
							      								    								  name std::__fun<std::__not_equal_to, typename _Dom
							      								    								  1::value_type>::result_type> std::operator!=(const
							      								    								   std::_Expr<_Dom1, typename _Dom1::value_type>&, c
							      								    								  onst std::_Expr<_Dom2, typename _Dom2::value_type>
							      								    								  &)’	   _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_eq
							      								    								  ual_to)      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/valarray_after.h:415:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: FIN
							      								    								  D_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: n
							      								    								  ote:	 ‘std::set<int>::iterator’ {aka ‘std::_Rb_tr
							      								    								  ee_const_iterator<int>’} is not derived from ‘cons
							      								    								  t std::_Expr<_Dom1, typename _Dom1::value_type>’
							      								    								  	    if ( table . find ( j ) != table . end (
							      								    								   ) && table [ j ] . find ( k ) != table . end ( )
							      								    								  ) return true ;
							      								    								  
							      								    								  		 ^ In file included from /usr/includ
							      								    								  e/c++/8/valarray:592,			 from /usr/i
							      								    								  nclude/c++/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  		    from FIND_RECTANGLE_BINARY_MATRI
							      								    								  X_CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/vala
							      								    								  rray_after.h:415:5: note: candidate: ‘template<cla
							      								    								  ss _Dom> std::_Expr<std::_BinClos<std::__not_equal
							      								    								  _to, std::_Expr, std::_Constant, _Dom, typename _D
							      								    								  om::value_type>, typename std::__fun<std::__not_eq
							      								    								  ual_to, typename _Dom1::value_type>::result_type>
							      								    								  std::operator!=(const std::_Expr<_Dom1, typename _
							      								    								  Dom1::value_type>&, const typename _Dom::value_typ
							      								    								  e&)’	    _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_e
							      								    								  qual_to)	^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/in
							      								    								  clude/c++/8/bits/valarray_after.h:415:5: note:   t
							      								    								  emplate argument deduction/substitution failed: FI
							      								    								  ND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99:
							      								    								  note:	  ‘std::set<int>::iterator’ {aka ‘std::_Rb_t
							      								    								  ree_const_iterator<int>’} is not derived from ‘con
							      								    								  st std::_Expr<_Dom1, typename _Dom1::value_type>’
							      								    								  	     if ( table . find ( j ) != table . end
							      								    								  ( ) && table [ j ] . find ( k ) != table . end ( )
							      								    								   ) return true ;
							      								    								  
							      								    								  		  ^ In file included from /usr/inclu
							      								    								  de/c++/8/valarray:592,		  from /usr/
							      								    								  include/c++/8/x86_64-redhat-linux/bits/stdc++.h:95
							      								    								  ,		     from FIND_RECTANGLE_BINARY_MATR
							      								    								  IX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/val
							      								    								  array_after.h:415:5: note: candidate: ‘template<cl
							      								    								  ass _Dom> std::_Expr<std::_BinClos<std::__not_equa
							      								    								  l_to, std::_Constant, std::_Expr, typename _Dom::v
							      								    								  alue_type, _Dom>, typename std::__fun<std::__not_e
							      								    								  qual_to, typename _Dom1::value_type>::result_type>
							      								    								   std::operator!=(const typename _Dom::value_type&,
							      								    								   const std::_Expr<_Dom1, typename _Dom1::value_typ
							      								    								  e>&)’	     _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_
							      								    								  equal_to)	 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/valarray_after.h:415:5: note:
							      								    								  template argument deduction/substitution failed: F
							      								    								  IND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99:
							      								    								   note:   ‘std::unordered_map<int, std::set<int> >:
							      								    								  :iterator’ {aka ‘std::__detail::_Node_iterator<std
							      								    								  ::pair<const int, std::set<int> >, false, false>’}
							      								    								   is not derived from ‘const std::_Expr<_Dom1, type
							      								    								  name _Dom1::value_type>’	      if ( table . f
							      								    								  ind ( j ) != table . end ( ) && table [ j ] . find
							      								    								   ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					   ^ In file
							      								    								   included from /usr/include/c++/8/valarray:592,
							      								    								  		 from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:95,		      from F
							      								    								  IND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /u
							      								    								  sr/include/c++/8/bits/valarray_after.h:415:5: note
							      								    								  : candidate: ‘template<class _Dom> std::_Expr<std:
							      								    								  :_BinClos<std::__not_equal_to, std::_Expr, std::_V
							      								    								  alArray, _Dom, typename _Dom::value_type>, typenam
							      								    								  e std::__fun<std::__not_equal_to, typename _Dom1::
							      								    								  value_type>::result_type> std::operator!=(const st
							      								    								  d::_Expr<_Dom1, typename _Dom1::value_type>&, cons
							      								    								  t std::valarray<typename _Dom::value_type>&)’
							      								    								   _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_equal_to)
							      								    								       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++
							      								    								  /8/bits/valarray_after.h:415:5: note:	  template a
							      								    								  rgument deduction/substitution failed: FIND_RECTAN
							      								    								  GLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘
							      								    								  std::set<int>::iterator’ {aka ‘std::_Rb_tree_const
							      								    								  _iterator<int>’} is not derived from ‘const std::_
							      								    								  Expr<_Dom1, typename _Dom1::value_type>’
							      								    								    if ( table . find ( j ) != table . end ( ) && ta
							      								    								  ble [ j ] . find ( k ) != table . end ( ) ) return
							      								    								   true ;
							      								    								  
							      								    								  	 ^ In file included from /usr/include/c++/8/
							      								    								  valarray:592,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  	    from FIND_RECTANGLE_BINARY_MATRIX_CORNER
							      								    								  S_1_1.cpp:14: /usr/include/c++/8/bits/valarray_aft
							      								    								  er.h:415:5: note: candidate: ‘template<class _Dom>
							      								    								   std::_Expr<std::_BinClos<std::__not_equal_to, std
							      								    								  ::_ValArray, std::_Expr, typename _Dom::value_type
							      								    								  , _Dom>, typename std::__fun<std::__not_equal_to,
							      								    								  typename _Dom1::value_type>::result_type> std::ope
							      								    								  rator!=(const std::valarray<typename _Dom::value_t
							      								    								  ype>&, const std::_Expr<_Dom1, typename _Dom1::val
							      								    								  ue_type>&)’	   _DEFINE_EXPR_BINARY_OPERATOR(!=,
							      								    								  __not_equal_to)      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
							      								    								  /usr/include/c++/8/bits/valarray_after.h:415:5: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:
							      								    								  56:99: note:	 ‘std::unordered_map<int, std::set<i
							      								    								  nt> >::iterator’ {aka ‘std::__detail::_Node_iterat
							      								    								  or<std::pair<const int, std::set<int> >, false, fa
							      								    								  lse>’} is not derived from ‘const std::_Expr<_Dom1
							      								    								  , typename _Dom1::value_type>’	    if ( tab
							      								    								  le . find ( j ) != table . end ( ) && table [ j ]
							      								    								  . find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						 ^ I
							      								    								  n file included from /usr/include/c++/8/x86_64-red
							      								    								  hat-linux/bits/stdc++.h:95,		       from
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /
							      								    								  usr/include/c++/8/valarray:1185:1: note: candidate
							      								    								  : ‘template<class _Tp> std::_Expr<std::_BinClos<st
							      								    								  d::__not_equal_to, std::_ValArray, std::_ValArray,
							      								    								   _Tp, _Tp>, typename std::__fun<std::__not_equal_t
							      								    								  o, _Tp>::result_type> std::operator!=(const std::v
							      								    								  alarray<_Tp>&, const std::valarray<_Tp>&)’  _DEFIN
							      								    								  E_BINARY_OPERATOR(!=, __not_equal_to)	 ^~~~~~~~~~~
							      								    								  ~~~~~~~~~~~~ /usr/include/c++/8/valarray:1185:1: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp
							      								    								  :56:99: note:	  ‘std::set<int>::iterator’ {aka ‘st
							      								    								  d::_Rb_tree_const_iterator<int>’} is not derived f
							      								    								  rom ‘const std::valarray<_Tp>’	    if ( tab
							      								    								  le . find ( j ) != table . end ( ) && table [ j ]
							      								    								  . find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						 ^ I
							      								    								  n file included from /usr/include/c++/8/x86_64-red
							      								    								  hat-linux/bits/stdc++.h:95,		       from
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /
							      								    								  usr/include/c++/8/valarray:1185:1: note: candidate
							      								    								  : ‘template<class _Tp> std::_Expr<std::_BinClos<st
							      								    								  d::__not_equal_to, std::_ValArray, std::_Constant,
							      								    								   _Tp, _Tp>, typename std::__fun<std::__not_equal_t
							      								    								  o, _Tp>::result_type> std::operator!=(const std::v
							      								    								  alarray<_Tp>&, const _Tp&)’  _DEFINE_BINARY_OPERAT
							      								    								  OR(!=, __not_equal_to)  ^~~~~~~~~~~~~~~~~~~~~~~ /u
							      								    								  sr/include/c++/8/valarray:1185:1: note:   template
							      								    								   argument deduction/substitution failed: FIND_RECT
							      								    								  ANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:
							      								    								   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_con
							      								    								  st_iterator<int>’} is not derived from ‘const std:
							      								    								  :valarray<_Tp>’	     if ( table . find ( j )
							      								    								   != table . end ( ) && table [ j ] . find ( k ) !=
							      								    								   table . end ( ) ) return true ;
							      								    								  
							      								    								  				  ^ In file included
							      								    								   from /usr/include/c++/8/x86_64-redhat-linux/bits/
							      								    								  stdc++.h:95,			from FIND_RECTANGLE_
							      								    								  BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++
							      								    								  /8/valarray:1185:1: note: candidate: ‘template<cla
							      								    								  ss _Tp> std::_Expr<std::_BinClos<std::__not_equal_
							      								    								  to, std::_Constant, std::_ValArray, _Tp, _Tp>, typ
							      								    								  ename std::__fun<std::__not_equal_to, _Tp>::result
							      								    								  _type> std::operator!=(const _Tp&, const std::vala
							      								    								  rray<_Tp>&)’	_DEFINE_BINARY_OPERATOR(!=, __not_eq
							      								    								  ual_to)  ^~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/
							      								    								  8/valarray:1185:1: note:   template argument deduc
							      								    								  tion/substitution failed: FIND_RECTANGLE_BINARY_MA
							      								    								  TRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::unordere
							      								    								  d_map<int, std::set<int> >::iterator’ {aka ‘std::_
							      								    								  _detail::_Node_iterator<std::pair<const int, std::
							      								    								  set<int> >, false, false>’} is not derived from ‘c
							      								    								  onst std::valarray<_Tp>’	      if ( table . f
							      								    								  ind ( j ) != table . end ( ) && table [ j ] . find
							      								    								   ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					   ^ In file
							      								    								   included from /usr/include/c++/8/forward_list:38,
							      								    								  		    from /usr/include/c++/8/x86_64-r
							      								    								  edhat-linux/bits/stdc++.h:104,		  fr
							      								    								  om FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14
							      								    								  : /usr/include/c++/8/bits/forward_list.h:281:5: no
							      								    								  te: candidate: ‘template<class _Tp> bool std::oper
							      								    								  ator!=(const std::_Fwd_list_iterator<_Tp>&, const
							      								    								  std::_Fwd_list_const_iterator<_Tp>&)’	     operato
							      								    								  r!=(const _Fwd_list_iterator<_Tp>& __x,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/forward_list.h:281:5:
							      								    								  note:	  template argument deduction/substitution f
							      								    								  ailed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:56:99: note:   ‘std::set<int>::iterator’ {aka ‘s
							      								    								  td::_Rb_tree_const_iterator<int>’} is not derived
							      								    								  from ‘const std::_Fwd_list_iterator<_Tp>’
							      								    								     if ( table . find ( j ) != table . end ( ) && t
							      								    								  able [ j ] . find ( k ) != table . end ( ) ) retur
							      								    								  n true ;
							      								    								  
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /forward_list:38,		     from /usr/inclu
							      								    								  de/c++/8/x86_64-redhat-linux/bits/stdc++.h:104,
							      								    								  		 from FIND_RECTANGLE_BINARY_MATRIX_C
							      								    								  ORNERS_1_1.cpp:14: /usr/include/c++/8/bits/forward
							      								    								  _list.h:1440:5: note: candidate: ‘template<class _
							      								    								  Tp, class _Alloc> bool std::operator!=(const std::
							      								    								  forward_list<_Tp, _Alloc>&, const std::forward_lis
							      								    								  t<_Tp, _Alloc>&)’	 operator!=(const forward_li
							      								    								  st<_Tp, _Alloc>& __lx,      ^~~~~~~~ /usr/include/
							      								    								  c++/8/bits/forward_list.h:1440:5: note:   template
							      								    								   argument deduction/substitution failed: FIND_RECT
							      								    								  ANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:
							      								    								   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_con
							      								    								  st_iterator<int>’} is not derived from ‘const std:
							      								    								  :forward_list<_Tp, _Alloc>’		 if ( table
							      								    								  . find ( j ) != table . end ( ) && table [ j ] . f
							      								    								  ind ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/future:39,
							      								    								  		 from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:105,		       from
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /
							      								    								  usr/include/c++/8/thread:287:3: note: candidate: ‘
							      								    								  bool std::operator!=(std::thread::id, std::thread:
							      								    								  :id)’	   operator!=(thread::id __x, thread::id __y
							      								    								  ) noexcept	^~~~~~~~ /usr/include/c++/8/thread:2
							      								    								  87:3: note:	no known conversion for argument 1 f
							      								    								  rom ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_
							      								    								  const_iterator<int>’} to ‘std::thread::id’ In file
							      								    								   included from /usr/include/c++/8/random:49,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:108,		    from FIN
							      								    								  D_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr
							      								    								  /include/c++/8/bits/random.h:397:5: note: candidat
							      								    								  e: ‘template<class _UIntType, _UIntType __a, _UInt
							      								    								  Type __c, _UIntType __m> bool std::operator!=(cons
							      								    								  t std::linear_congruential_engine<_UIntType, __a,
							      								    								  __c, __m>&, const std::linear_congruential_engine<
							      								    								  _UIntType, __a, __c, __m>&)’	    operator!=(const
							      								    								   std::linear_congruential_engine<_UIntType, __a,
							      								    								      ^~~~~~~~ /usr/include/c++/8/bits/random.h:397:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1
							      								    								  .cpp:56:99: note:   ‘std::set<int>::iterator’ {aka
							      								    								   ‘std::_Rb_tree_const_iterator<int>’} is not deriv
							      								    								  ed from ‘const std::linear_congruential_engine<_UI
							      								    								  ntType, __a, __c, __m>’	     if ( table . fi
							      								    								  nd ( j ) != table . end ( ) && table [ j ] . find
							      								    								  ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					  ^ In file
							      								    								  included from /usr/include/c++/8/random:49,
							      								    								  	     from /usr/include/c++/8/x86_64-redhat-l
							      								    								  inux/bits/stdc++.h:108,		   from FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/
							      								    								  include/c++/8/bits/random.h:629:5: note: candidate
							      								    								  : ‘template<class _UIntType, long unsigned int __w
							      								    								  , long unsigned int __n, long unsigned int __m, lo
							      								    								  ng unsigned int __r, _UIntType __a, long unsigned
							      								    								  int __u, _UIntType __d, long unsigned int __s, _UI
							      								    								  ntType __b, long unsigned int __t, _UIntType __c,
							      								    								  long unsigned int __l, _UIntType __f> bool std::op
							      								    								  erator!=(const std::mersenne_twister_engine<_UIntT
							      								    								  ype, __w, __n, __m, __r, __a, __u, __d, __s, __b,
							      								    								  __t, __c, __l, __f>&, const std::mersenne_twister_
							      								    								  engine<_UIntType, __w, __n, __m, __r, __a, __u, __
							      								    								  d, __s, __b, __t, __c, __l, __f>&)’	   operator!
							      								    								  =(const std::mersenne_twister_engine<_UIntType, __
							      								    								  w, __n, __m,	    ^~~~~~~~ /usr/include/c++/8/bits
							      								    								  /random.h:629:5: note:   template argument deducti
							      								    								  on/substitution failed: FIND_RECTANGLE_BINARY_MATR
							      								    								  IX_CORNERS_1_1.cpp:56:99: note:   ‘std::set<int>::
							      								    								  iterator’ {aka ‘std::_Rb_tree_const_iterator<int>’
							      								    								  } is not derived from ‘const std::mersenne_twister
							      								    								  _engine<_UIntType, __w, __n, __m, __r, __a, __u, _
							      								    								  _d, __s, __b, __t, __c, __l, __f>’		if (
							      								    								   table . find ( j ) != table . end ( ) && table [
							      								    								  j ] . find ( k ) != table . end ( ) ) return true
							      								    								  ;
							      								    								  
							      								    								   ^ In file included from /usr/include/c++/8/random
							      								    								  :49,			from /usr/include/c++/8/x86_
							      								    								  64-redhat-linux/bits/stdc++.h:108,
							      								    								    from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:14: /usr/include/c++/8/bits/random.h:825:5: note
							      								    								  : candidate: ‘template<class _UIntType, long unsig
							      								    								  ned int __w, long unsigned int __s, long unsigned
							      								    								  int __r> bool std::operator!=(const std::subtract_
							      								    								  with_carry_engine<_UIntType, __w, __s, __r>&, cons
							      								    								  t std::subtract_with_carry_engine<_UIntType, __w,
							      								    								  __s, __r>&)’	    operator!=(const std::subtract_w
							      								    								  ith_carry_engine<_UIntType, __w,	^~~~~~~~ /us
							      								    								  r/include/c++/8/bits/random.h:825:5: note:   templ
							      								    								  ate argument deduction/substitution failed: FIND_R
							      								    								  ECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note
							      								    								  :   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_
							      								    								  const_iterator<int>’} is not derived from ‘const s
							      								    								  td::subtract_with_carry_engine<_UIntType, __w, __s
							      								    								  , __r>’	     if ( table . find ( j ) != tabl
							      								    								  e . end ( ) && table [ j ] . find ( k ) != table .
							      								    								   end ( ) ) return true ;
							      								    								  
							      								    								  			  ^ In file included from /u
							      								    								  sr/include/c++/8/random:49,		       from
							      								    								  /usr/include/c++/8/x86_64-redhat-linux/bits/stdc++
							      								    								  .h:108,		   from FIND_RECTANGLE_BINAR
							      								    								  Y_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bi
							      								    								  ts/random.h:1047:5: note: candidate: ‘template<cla
							      								    								  ss _RandomNumberEngine, long unsigned int __p, lon
							      								    								  g unsigned int __r> bool std::operator!=(const std
							      								    								  ::discard_block_engine<_RandomNumberEngine, __p, _
							      								    								  _r>&, const std::discard_block_engine<_RandomNumbe
							      								    								  rEngine, __p, __r>&)’	     operator!=(const std::d
							      								    								  iscard_block_engine<_RandomNumberEngine, __p,
							      								    								   ^~~~~~~~ /usr/include/c++/8/bits/random.h:1047:5:
							      								    								   note:   template argument deduction/substitution
							      								    								  failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.c
							      								    								  pp:56:99: note:   ‘std::set<int>::iterator’ {aka ‘
							      								    								  std::_Rb_tree_const_iterator<int>’} is not derived
							      								    								   from ‘const std::discard_block_engine<_RandomNumb
							      								    								  erEngine, __p, __r>’		  if ( table . find
							      								    								  ( j ) != table . end ( ) && table [ j ] . find ( k
							      								    								   ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  				       ^ In file inc
							      								    								  luded from /usr/include/c++/8/random:49,
							      								    								  	  from /usr/include/c++/8/x86_64-redhat-linu
							      								    								  x/bits/stdc++.h:108,			from FIND_RE
							      								    								  CTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/inc
							      								    								  lude/c++/8/bits/random.h:1243:5: note: candidate:
							      								    								  ‘template<class _RandomNumberEngine, long unsigned
							      								    								   int __w, class _UIntType> bool std::operator!=(co
							      								    								  nst std::independent_bits_engine<_RandomNumberEngi
							      								    								  ne, __w, _UIntType>&, const std::independent_bits_
							      								    								  engine<_RandomNumberEngine, __w, _UIntType>&)’
							      								    								    operator!=(const std::independent_bits_engine<_R
							      								    								  andomNumberEngine, __w,      ^~~~~~~~ /usr/include
							      								    								  /c++/8/bits/random.h:1243:5: note:   template argu
							      								    								  ment deduction/substitution failed: FIND_RECTANGLE
							      								    								  _BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:	‘std
							      								    								  ::set<int>::iterator’ {aka ‘std::_Rb_tree_const_it
							      								    								  erator<int>’} is not derived from ‘const std::inde
							      								    								  pendent_bits_engine<_RandomNumberEngine, __w, _UIn
							      								    								  tType>’	     if ( table . find ( j ) != tabl
							      								    								  e . end ( ) && table [ j ] . find ( k ) != table .
							      								    								   end ( ) ) return true ;
							      								    								  
							      								    								  			  ^ In file included from /u
							      								    								  sr/include/c++/8/random:49,		       from
							      								    								  /usr/include/c++/8/x86_64-redhat-linux/bits/stdc++
							      								    								  .h:108,		   from FIND_RECTANGLE_BINAR
							      								    								  Y_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bi
							      								    								  ts/random.h:1495:5: note: candidate: ‘template<cla
							      								    								  ss _RandomNumberEngine, long unsigned int __k> boo
							      								    								  l std::operator!=(const std::shuffle_order_engine<
							      								    								  _RandomNumberEngine, __k>&, const std::shuffle_ord
							      								    								  er_engine<_RandomNumberEngine, __k>&)’      operat
							      								    								  or!=(const std::shuffle_order_engine<_RandomNumber
							      								    								  Engine,      ^~~~~~~~ /usr/include/c++/8/bits/rand
							      								    								  om.h:1495:5: note:   template argument deduction/s
							      								    								  ubstitution failed: FIND_RECTANGLE_BINARY_MATRIX_C
							      								    								  ORNERS_1_1.cpp:56:99: note:	‘std::set<int>::iter
							      								    								  ator’ {aka ‘std::_Rb_tree_const_iterator<int>’} is
							      								    								   not derived from ‘const std::shuffle_order_engine
							      								    								  <_RandomNumberEngine, __k>’		 if ( table
							      								    								  . find ( j ) != table . end ( ) && table [ j ] . f
							      								    								  ind ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/random:49,
							      								    								  		 from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:108,		       from
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /
							      								    								  usr/include/c++/8/bits/random.h:1660:5: note: cand
							      								    								  idate: ‘template<class _IntType> bool std::operato
							      								    								  r!=(const std::uniform_int_distribution<_IntType>&
							      								    								  , const std::uniform_int_distribution<_IntType>&)’
							      								    								  	operator!=(const std::uniform_int_distributi
							      								    								  on<_IntType>& __d1,	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/random.h:1660:5: note:   template argument
							      								    								   deduction/substitution failed: FIND_RECTANGLE_BIN
							      								    								  ARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::se
							      								    								  t<int>::iterator’ {aka ‘std::_Rb_tree_const_iterat
							      								    								  or<int>’} is not derived from ‘const std::uniform_
							      								    								  int_distribution<_IntType>’		 if ( table
							      								    								  . find ( j ) != table . end ( ) && table [ j ] . f
							      								    								  ind ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/random:49,
							      								    								  		 from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:108,		       from
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /
							      								    								  usr/include/c++/8/bits/random.h:1874:5: note: cand
							      								    								  idate: ‘template<class _IntType> bool std::operato
							      								    								  r!=(const std::uniform_real_distribution<_IntType>
							      								    								  &, const std::uniform_real_distribution<_IntType>&
							      								    								  )’	  operator!=(const std::uniform_real_distrib
							      								    								  ution<_IntType>& __d1,      ^~~~~~~~ /usr/include/
							      								    								  c++/8/bits/random.h:1874:5: note:   template argum
							      								    								  ent deduction/substitution failed: FIND_RECTANGLE_
							      								    								  BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std:
							      								    								  :set<int>::iterator’ {aka ‘std::_Rb_tree_const_ite
							      								    								  rator<int>’} is not derived from ‘const std::unifo
							      								    								  rm_real_distribution<_IntType>’	     if ( ta
							      								    								  ble . find ( j ) != table . end ( ) && table [ j ]
							      								    								   . find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						  ^
							      								    								  In file included from /usr/include/c++/8/random:49
							      								    								  ,		     from /usr/include/c++/8/x86_64-
							      								    								  redhat-linux/bits/stdc++.h:108,		   f
							      								    								  rom FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:1
							      								    								  4: /usr/include/c++/8/bits/random.h:2128:5: note:
							      								    								  candidate: ‘template<class _RealType> bool std::op
							      								    								  erator!=(const std::normal_distribution<_RealType>
							      								    								  &, const std::normal_distribution<_RealType>&)’
							      								    								     operator!=(const std::normal_distribution<_Real
							      								    								  Type>& __d1,	    ^~~~~~~~ /usr/include/c++/8/bits
							      								    								  /random.h:2128:5: note:   template argument deduct
							      								    								  ion/substitution failed: FIND_RECTANGLE_BINARY_MAT
							      								    								  RIX_CORNERS_1_1.cpp:56:99: note:   ‘std::set<int>:
							      								    								  :iterator’ {aka ‘std::_Rb_tree_const_iterator<int>
							      								    								  ’} is not derived from ‘const std::normal_distribu
							      								    								  tion<_RealType>’	      if ( table . find ( j
							      								    								  ) != table . end ( ) && table [ j ] . find ( k ) !
							      								    								  = table . end ( ) ) return true ;
							      								    								  
							      								    								  				   ^ In file include
							      								    								  d from /usr/include/c++/8/random:49,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:108,		    from FIND_RECTAN
							      								    								  GLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include
							      								    								  /c++/8/bits/random.h:2337:5: note: candidate: ‘tem
							      								    								  plate<class _RealType> bool std::operator!=(const
							      								    								  std::lognormal_distribution<_RealType>&, const std
							      								    								  ::lognormal_distribution<_RealType>&)’      operat
							      								    								  or!=(const std::lognormal_distribution<_RealType>&
							      								    								   __d1,      ^~~~~~~~ /usr/include/c++/8/bits/rando
							      								    								  m.h:2337:5: note:   template argument deduction/su
							      								    								  bstitution failed: FIND_RECTANGLE_BINARY_MATRIX_CO
							      								    								  RNERS_1_1.cpp:56:99: note:   ‘std::set<int>::itera
							      								    								  tor’ {aka ‘std::_Rb_tree_const_iterator<int>’} is
							      								    								  not derived from ‘const std::lognormal_distributio
							      								    								  n<_RealType>’		   if ( table . find ( j ) !
							      								    								  = table . end ( ) && table [ j ] . find ( k ) != t
							      								    								  able . end ( ) ) return true ;
							      								    								  
							      								    								  				^ In file included f
							      								    								  rom /usr/include/c++/8/random:49,
							      								    								   from /usr/include/c++/8/x86_64-redhat-linux/bits/
							      								    								  stdc++.h:108,			 from FIND_RECTANGLE
							      								    								  _BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c+
							      								    								  +/8/bits/random.h:2562:6: note: candidate: ‘templa
							      								    								  te<class _RealType> bool std::operator!=(const std
							      								    								  ::gamma_distribution<_RealType>&, const std::gamma
							      								    								  _distribution<_RealType>&)’	    operator!=(const
							      								    								   std::gamma_distribution<_RealType>& __d1,	   ^
							      								    								  ~~~~~~~ /usr/include/c++/8/bits/random.h:2562:6: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp
							      								    								  :56:99: note:	  ‘std::set<int>::iterator’ {aka ‘st
							      								    								  d::_Rb_tree_const_iterator<int>’} is not derived f
							      								    								  rom ‘const std::gamma_distribution<_RealType>’
							      								    								  	  if ( table . find ( j ) != table . end ( )
							      								    								   && table [ j ] . find ( k ) != table . end ( ) )
							      								    								  return true ;
							      								    								  
							      								    								  	       ^ In file included from /usr/include/
							      								    								  c++/8/random:49,		    from /usr/includ
							      								    								  e/c++/8/x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  		from FIND_RECTANGLE_BINARY_MATRIX_CO
							      								    								  RNERS_1_1.cpp:14: /usr/include/c++/8/bits/random.h
							      								    								  :2782:5: note: candidate: ‘template<class _RealTyp
							      								    								  e> bool std::operator!=(const std::chi_squared_dis
							      								    								  tribution<_RealType>&, const std::chi_squared_dist
							      								    								  ribution<_RealType>&)’      operator!=(const std::
							      								    								  chi_squared_distribution<_RealType>& __d1,	  ^~
							      								    								  ~~~~~~ /usr/include/c++/8/bits/random.h:2782:5: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:
							      								    								  56:99: note:	 ‘std::set<int>::iterator’ {aka ‘std
							      								    								  ::_Rb_tree_const_iterator<int>’} is not derived fr
							      								    								  om ‘const std::chi_squared_distribution<_RealType>
							      								    								  ’	       if ( table . find ( j ) != table . en
							      								    								  d ( ) && table [ j ] . find ( k ) != table . end (
							      								    								   ) ) return true ;
							      								    								  
							      								    								  		    ^ In file included from /usr/inc
							      								    								  lude/c++/8/random:49,			 from /usr/i
							      								    								  nclude/c++/8/x86_64-redhat-linux/bits/stdc++.h:108
							      								    								  ,		     from FIND_RECTANGLE_BINARY_MATR
							      								    								  IX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/ran
							      								    								  dom.h:2954:5: note: candidate: ‘template<class _Re
							      								    								  alType> bool std::operator!=(const std::cauchy_dis
							      								    								  tribution<_RealType>&, const std::cauchy_distribut
							      								    								  ion<_RealType>&)’	 operator!=(const std::cauch
							      								    								  y_distribution<_RealType>& __d1,	^~~~~~~~ /us
							      								    								  r/include/c++/8/bits/random.h:2954:5: note:	temp
							      								    								  late argument deduction/substitution failed: FIND_
							      								    								  RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: not
							      								    								  e:   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree
							      								    								  _const_iterator<int>’} is not derived from ‘const
							      								    								  std::cauchy_distribution<_RealType>’		  if
							      								    								   ( table . find ( j ) != table . end ( ) && table
							      								    								  [ j ] . find ( k ) != table . end ( ) ) return tru
							      								    								  e ;
							      								    								  
							      								    								     ^ In file included from /usr/include/c++/8/rand
							      								    								  om:49,		  from /usr/include/c++/8/x8
							      								    								  6_64-redhat-linux/bits/stdc++.h:108,
							      								    								      from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.
							      								    								  cpp:14: /usr/include/c++/8/bits/random.h:3215:5: n
							      								    								  ote: candidate: ‘template<class _RealType> bool st
							      								    								  d::operator!=(const std::fisher_f_distribution<_Re
							      								    								  alType>&, const std::fisher_f_distribution<_RealTy
							      								    								  pe>&)’      operator!=(const std::fisher_f_distrib
							      								    								  ution<_RealType>& __d1,      ^~~~~~~~ /usr/include
							      								    								  /c++/8/bits/random.h:3215:5: note:   template argu
							      								    								  ment deduction/substitution failed: FIND_RECTANGLE
							      								    								  _BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:	‘std
							      								    								  ::set<int>::iterator’ {aka ‘std::_Rb_tree_const_it
							      								    								  erator<int>’} is not derived from ‘const std::fish
							      								    								  er_f_distribution<_RealType>’		   if ( tabl
							      								    								  e . find ( j ) != table . end ( ) && table [ j ] .
							      								    								   find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						^ In
							      								    								   file included from /usr/include/c++/8/random:49,
							      								    								  		   from /usr/include/c++/8/x86_64-re
							      								    								  dhat-linux/bits/stdc++.h:108,			 fro
							      								    								  m FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14:
							      								    								   /usr/include/c++/8/bits/random.h:3433:5: note: ca
							      								    								  ndidate: ‘template<class _RealType> bool std::oper
							      								    								  ator!=(const std::student_t_distribution<_RealType
							      								    								  >&, const std::student_t_distribution<_RealType>&)
							      								    								  ’	 operator!=(const std::student_t_distributio
							      								    								  n<_RealType>& __d1,	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/random.h:3433:5: note:   template argument
							      								    								   deduction/substitution failed: FIND_RECTANGLE_BIN
							      								    								  ARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::se
							      								    								  t<int>::iterator’ {aka ‘std::_Rb_tree_const_iterat
							      								    								  or<int>’} is not derived from ‘const std::student_
							      								    								  t_distribution<_RealType>’		if ( table .
							      								    								   find ( j ) != table . end ( ) && table [ j ] . fi
							      								    								  nd ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					     ^ In fi
							      								    								  le included from /usr/include/c++/8/random:49,
							      								    								  		from /usr/include/c++/8/x86_64-redha
							      								    								  t-linux/bits/stdc++.h:108,		      from F
							      								    								  IND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /u
							      								    								  sr/include/c++/8/bits/random.h:3614:3: note: candi
							      								    								  date: ‘bool std::operator!=(const std::bernoulli_d
							      								    								  istribution&, const std::bernoulli_distribution&)’
							      								    								      operator!=(const std::bernoulli_distribution&
							      								    								  __d1,	   ^~~~~~~~ /usr/include/c++/8/bits/random.h
							      								    								  :3614:3: note:   no known conversion for argument
							      								    								  1 from ‘std::set<int>::iterator’ {aka ‘std::_Rb_tr
							      								    								  ee_const_iterator<int>’} to ‘const std::bernoulli_
							      								    								  distribution&’ /usr/include/c++/8/bits/random.h:38
							      								    								  85:5: note: candidate: ‘template<class _IntType> b
							      								    								  ool std::operator!=(const std::binomial_distributi
							      								    								  on<_IntType>&, const std::binomial_distribution<_I
							      								    								  ntType>&)’	  operator!=(const std::binomial_dis
							      								    								  tribution<_IntType>& __d1,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/random.h:3885:5: note:	  template a
							      								    								  rgument deduction/substitution failed: FIND_RECTAN
							      								    								  GLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘
							      								    								  std::set<int>::iterator’ {aka ‘std::_Rb_tree_const
							      								    								  _iterator<int>’} is not derived from ‘const std::b
							      								    								  inomial_distribution<_IntType>’	     if ( ta
							      								    								  ble . find ( j ) != table . end ( ) && table [ j ]
							      								    								   . find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						  ^
							      								    								  In file included from /usr/include/c++/8/random:49
							      								    								  ,		     from /usr/include/c++/8/x86_64-
							      								    								  redhat-linux/bits/stdc++.h:108,		   f
							      								    								  rom FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:1
							      								    								  4: /usr/include/c++/8/bits/random.h:4059:5: note:
							      								    								  candidate: ‘template<class _IntType> bool std::ope
							      								    								  rator!=(const std::geometric_distribution<_IntType
							      								    								  >&, const std::geometric_distribution<_IntType>&)’
							      								    								  	operator!=(const std::geometric_distribution
							      								    								  <_IntType>& __d1,	 ^~~~~~~~ /usr/include/c++/8
							      								    								  /bits/random.h:4059:5: note:	 template argument d
							      								    								  eduction/substitution failed: FIND_RECTANGLE_BINAR
							      								    								  Y_MATRIX_CORNERS_1_1.cpp:56:99: note:	  ‘std::set<
							      								    								  int>::iterator’ {aka ‘std::_Rb_tree_const_iterator
							      								    								  <int>’} is not derived from ‘const std::geometric_
							      								    								  distribution<_IntType>’	     if ( table . fi
							      								    								  nd ( j ) != table . end ( ) && table [ j ] . find
							      								    								  ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					  ^ In file
							      								    								  included from /usr/include/c++/8/random:49,
							      								    								  	     from /usr/include/c++/8/x86_64-redhat-l
							      								    								  inux/bits/stdc++.h:108,		   from FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/
							      								    								  include/c++/8/bits/random.h:4309:5: note: candidat
							      								    								  e: ‘template<class _IntType> bool std::operator!=(
							      								    								  const std::negative_binomial_distribution<_IntType
							      								    								  >&, const std::negative_binomial_distribution<_Int
							      								    								  Type>&)’	operator!=(const std::negative_binom
							      								    								  ial_distribution<_IntType>& __d1,	 ^~~~~~~~ /u
							      								    								  sr/include/c++/8/bits/random.h:4309:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: no
							      								    								  te:	‘std::set<int>::iterator’ {aka ‘std::_Rb_tre
							      								    								  e_const_iterator<int>’} is not derived from ‘const
							      								    								   std::negative_binomial_distribution<_IntType>’
							      								    								  	   if ( table . find ( j ) != table . end (
							      								    								  ) && table [ j ] . find ( k ) != table . end ( ) )
							      								    								   return true ;
							      								    								  
							      								    								  		^ In file included from /usr/include
							      								    								  /c++/8/random:49,		     from /usr/inclu
							      								    								  de/c++/8/x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  		 from FIND_RECTANGLE_BINARY_MATRIX_C
							      								    								  ORNERS_1_1.cpp:14: /usr/include/c++/8/bits/random.
							      								    								  h:4530:5: note: candidate: ‘template<class _IntTyp
							      								    								  e> bool std::operator!=(const std::poisson_distrib
							      								    								  ution<_IntType>&, const std::poisson_distribution<
							      								    								  _IntType>&)’	    operator!=(const std::poisson_di
							      								    								  stribution<_IntType>& __d1,	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/random.h:4530:5: note:   template
							      								    								  argument deduction/substitution failed: FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:
							      								    								  ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_cons
							      								    								  t_iterator<int>’} is not derived from ‘const std::
							      								    								  poisson_distribution<_IntType>’	     if ( ta
							      								    								  ble . find ( j ) != table . end ( ) && table [ j ]
							      								    								   . find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						  ^
							      								    								  In file included from /usr/include/c++/8/random:49
							      								    								  ,		     from /usr/include/c++/8/x86_64-
							      								    								  redhat-linux/bits/stdc++.h:108,		   f
							      								    								  rom FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:1
							      								    								  4: /usr/include/c++/8/bits/random.h:4713:5: note:
							      								    								  candidate: ‘template<class _RealType> bool std::op
							      								    								  erator!=(const std::exponential_distribution<_Real
							      								    								  Type>&, const std::exponential_distribution<_RealT
							      								    								  ype>&)’      operator!=(const std::exponential_dis
							      								    								  tribution<_RealType>& __d1,	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/random.h:4713:5: note:   template
							      								    								  argument deduction/substitution failed: FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:
							      								    								  ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_cons
							      								    								  t_iterator<int>’} is not derived from ‘const std::
							      								    								  exponential_distribution<_RealType>’		  if
							      								    								   ( table . find ( j ) != table . end ( ) && table
							      								    								  [ j ] . find ( k ) != table . end ( ) ) return tru
							      								    								  e ;
							      								    								  
							      								    								     ^ In file included from /usr/include/c++/8/rand
							      								    								  om:49,		  from /usr/include/c++/8/x8
							      								    								  6_64-redhat-linux/bits/stdc++.h:108,
							      								    								      from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.
							      								    								  cpp:14: /usr/include/c++/8/bits/random.h:4921:5: n
							      								    								  ote: candidate: ‘template<class _RealType> bool st
							      								    								  d::operator!=(const std::weibull_distribution<_Rea
							      								    								  lType>&, const std::weibull_distribution<_RealType
							      								    								  >&)’	    operator!=(const std::weibull_distributi
							      								    								  on<_RealType>& __d1,	    ^~~~~~~~ /usr/include/c+
							      								    								  +/8/bits/random.h:4921:5: note:   template argumen
							      								    								  t deduction/substitution failed: FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::s
							      								    								  et<int>::iterator’ {aka ‘std::_Rb_tree_const_itera
							      								    								  tor<int>’} is not derived from ‘const std::weibull
							      								    								  _distribution<_RealType>’	       if ( table .
							      								    								  find ( j ) != table . end ( ) && table [ j ] . fin
							      								    								  d ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					    ^ In fil
							      								    								  e included from /usr/include/c++/8/random:49,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:108,		     from FI
							      								    								  ND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /us
							      								    								  r/include/c++/8/bits/random.h:5129:5: note: candid
							      								    								  ate: ‘template<class _RealType> bool std::operator
							      								    								  !=(const std::extreme_value_distribution<_RealType
							      								    								  >&, const std::extreme_value_distribution<_RealTyp
							      								    								  e>&)’	     operator!=(const std::extreme_value_dis
							      								    								  tribution<_RealType>& __d1,	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/random.h:5129:5: note:   template
							      								    								  argument deduction/substitution failed: FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:
							      								    								  ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_cons
							      								    								  t_iterator<int>’} is not derived from ‘const std::
							      								    								  extreme_value_distribution<_RealType>’
							      								    								  if ( table . find ( j ) != table . end ( ) && tabl
							      								    								  e [ j ] . find ( k ) != table . end ( ) ) return t
							      								    								  rue ;
							      								    								  
							      								    								       ^ In file included from /usr/include/c++/8/ra
							      								    								  ndom:49,		    from /usr/include/c++/8/
							      								    								  x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_
							      								    								  1.cpp:14: /usr/include/c++/8/bits/random.h:5394:5:
							      								    								   note: candidate: ‘template<class _IntType> bool s
							      								    								  td::operator!=(const std::discrete_distribution<_I
							      								    								  ntType>&, const std::discrete_distribution<_IntTyp
							      								    								  e>&)’	     operator!=(const std::discrete_distribu
							      								    								  tion<_IntType>& __d1,	     ^~~~~~~~ /usr/include/c
							      								    								  ++/8/bits/random.h:5394:5: note:   template argume
							      								    								  nt deduction/substitution failed: FIND_RECTANGLE_B
							      								    								  INARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::
							      								    								  set<int>::iterator’ {aka ‘std::_Rb_tree_const_iter
							      								    								  ator<int>’} is not derived from ‘const std::discre
							      								    								  te_distribution<_IntType>’		if ( table .
							      								    								   find ( j ) != table . end ( ) && table [ j ] . fi
							      								    								  nd ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					     ^ In fi
							      								    								  le included from /usr/include/c++/8/random:49,
							      								    								  		from /usr/include/c++/8/x86_64-redha
							      								    								  t-linux/bits/stdc++.h:108,		      from F
							      								    								  IND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /u
							      								    								  sr/include/c++/8/bits/random.h:5666:5: note: candi
							      								    								  date: ‘template<class _RealType> bool std::operato
							      								    								  r!=(const std::piecewise_constant_distribution<_Re
							      								    								  alType>&, const std::piecewise_constant_distributi
							      								    								  on<_RealType>&)’	operator!=(const std::piecew
							      								    								  ise_constant_distribution<_RealType>& __d1,	   ^
							      								    								  ~~~~~~~ /usr/include/c++/8/bits/random.h:5666:5: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp
							      								    								  :56:99: note:	  ‘std::set<int>::iterator’ {aka ‘st
							      								    								  d::_Rb_tree_const_iterator<int>’} is not derived f
							      								    								  rom ‘const std::piecewise_constant_distribution<_R
							      								    								  ealType>’	       if ( table . find ( j ) != ta
							      								    								  ble . end ( ) && table [ j ] . find ( k ) != table
							      								    								   . end ( ) ) return true ;
							      								    								  
							      								    								  			    ^ In file included from
							      								    								  /usr/include/c++/8/random:49,			 fro
							      								    								  m /usr/include/c++/8/x86_64-redhat-linux/bits/stdc
							      								    								  ++.h:108,		     from FIND_RECTANGLE_BIN
							      								    								  ARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/
							      								    								  bits/random.h:5940:5: note: candidate: ‘template<c
							      								    								  lass _RealType> bool std::operator!=(const std::pi
							      								    								  ecewise_linear_distribution<_RealType>&, const std
							      								    								  ::piecewise_linear_distribution<_RealType>&)’
							      								    								   operator!=(const std::piecewise_linear_distributi
							      								    								  on<_RealType>& __d1,	    ^~~~~~~~ /usr/include/c+
							      								    								  +/8/bits/random.h:5940:5: note:   template argumen
							      								    								  t deduction/substitution failed: FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::s
							      								    								  et<int>::iterator’ {aka ‘std::_Rb_tree_const_itera
							      								    								  tor<int>’} is not derived from ‘const std::piecewi
							      								    								  se_linear_distribution<_RealType>’		if (
							      								    								   table . find ( j ) != table . end ( ) && table [
							      								    								  j ] . find ( k ) != table . end ( ) ) return true
							      								    								  ;
							      								    								  
							      								    								   ^ In file included from /usr/include/c++/8/x86_64
							      								    								  -redhat-linux/bits/stdc++.h:111,
							      								    								  from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:
							      								    								  14: /usr/include/c++/8/scoped_allocator:468:5: not
							      								    								  e: candidate: ‘template<class _OutA1, class _OutA2
							      								    								  , class ... _InA> bool std::operator!=(const std::
							      								    								  scoped_allocator_adaptor<_OutA1, _InA ...>&, const
							      								    								   std::scoped_allocator_adaptor<_InnerHead, _InnerT
							      								    								  ail ...>&)’	   operator!=(const scoped_allocator
							      								    								  _adaptor<_OutA1, _InA...>& __a,      ^~~~~~~~ /usr
							      								    								  /include/c++/8/scoped_allocator:468:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: no
							      								    								  te:	‘std::set<int>::iterator’ {aka ‘std::_Rb_tre
							      								    								  e_const_iterator<int>’} is not derived from ‘const
							      								    								   std::scoped_allocator_adaptor<_OutA1, _InA ...>’
							      								    								  	     if ( table . find ( j ) != table . end
							      								    								  ( ) && table [ j ] . find ( k ) != table . end ( )
							      								    								   ) return true ;
							      								    								  
							      								    								  		  ^ In file included from /usr/inclu
							      								    								  de/c++/8/unordered_map:47,		      from /
							      								    								  usr/include/c++/8/x86_64-redhat-linux/bits/stdc++.
							      								    								  h:117,		  from FIND_RECTANGLE_BINARY
							      								    								  _MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bit
							      								    								  s/unordered_map.h:2063:5: note: candidate: ‘templa
							      								    								  te<class _Key, class _Tp, class _Hash, class _Pred
							      								    								  , class _Alloc> bool std::operator!=(const std::un
							      								    								  ordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, con
							      								    								  st std::unordered_map<_Key, _Tp, _Hash, _Pred, _Al
							      								    								  loc>&)’      operator!=(const unordered_map<_Key,
							      								    								  _Tp, _Hash, _Pred, _Alloc>& __x,	^~~~~~~~ /us
							      								    								  r/include/c++/8/bits/unordered_map.h:2063:5: note:
							      								    								     template argument deduction/substitution failed
							      								    								  : FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:56:
							      								    								  99: note:   ‘std::set<int>::iterator’ {aka ‘std::_
							      								    								  Rb_tree_const_iterator<int>’} is not derived from
							      								    								  ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred,
							      								    								   _Alloc>’	       if ( table . find ( j ) != ta
							      								    								  ble . end ( ) && table [ j ] . find ( k ) != table
							      								    								   . end ( ) ) return true ;
							      								    								  
							      								    								  			    ^ In file included from
							      								    								  /usr/include/c++/8/unordered_map:47,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:117,		    from FIND_RECTAN
							      								    								  GLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include
							      								    								  /c++/8/bits/unordered_map.h:2075:5: note: candidat
							      								    								  e: ‘template<class _Key, class _Tp, class _Hash, c
							      								    								  lass _Pred, class _Alloc> bool std::operator!=(con
							      								    								  st std::unordered_multimap<_Key, _Tp, _Hash, _Pred
							      								    								  , _Alloc>&, const std::unordered_multimap<_Key, _T
							      								    								  p, _Hash, _Pred, _Alloc>&)’	   operator!=(const
							      								    								  unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc
							      								    								  >& __x,      ^~~~~~~~ /usr/include/c++/8/bits/unor
							      								    								  dered_map.h:2075:5: note:   template argument dedu
							      								    								  ction/substitution failed: FIND_RECTANGLE_BINARY_M
							      								    								  ATRIX_CORNERS_1_1.cpp:56:99: note:   ‘std::set<int
							      								    								  >::iterator’ {aka ‘std::_Rb_tree_const_iterator<in
							      								    								  t>’} is not derived from ‘const std::unordered_mul
							      								    								  timap<_Key, _Tp, _Hash, _Pred, _Alloc>’
							      								    								   if ( table . find ( j ) != table . end ( ) && tab
							      								    								  le [ j ] . find ( k ) != table . end ( ) ) return
							      								    								  true ;
							      								    								  
							      								    								  	^ In file included from /usr/include/c++/8/u
							      								    								  nordered_set:47,		    from /usr/includ
							      								    								  e/c++/8/x86_64-redhat-linux/bits/stdc++.h:118,
							      								    								  		from FIND_RECTANGLE_BINARY_MATRIX_CO
							      								    								  RNERS_1_1.cpp:14: /usr/include/c++/8/bits/unordere
							      								    								  d_set.h:1675:5: note: candidate: ‘template<class _
							      								    								  Value, class _Hash, class _Pred, class _Alloc> boo
							      								    								  l std::operator!=(const std::unordered_set<_Value,
							      								    								   _Hash, _Pred, _Alloc>&, const std::unordered_set<
							      								    								  _Value, _Hash, _Pred, _Alloc>&)’	operator!=(c
							      								    								  onst unordered_set<_Value, _Hash, _Pred, _Alloc>&
							      								    								  __x,	    ^~~~~~~~ /usr/include/c++/8/bits/unorder
							      								    								  ed_set.h:1675:5: note:   template argument deducti
							      								    								  on/substitution failed: FIND_RECTANGLE_BINARY_MATR
							      								    								  IX_CORNERS_1_1.cpp:56:99: note:   ‘std::set<int>::
							      								    								  iterator’ {aka ‘std::_Rb_tree_const_iterator<int>’
							      								    								  } is not derived from ‘const std::unordered_set<_V
							      								    								  alue, _Hash, _Pred, _Alloc>’		  if ( table
							      								    								   . find ( j ) != table . end ( ) && table [ j ] .
							      								    								  find ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					       ^ In
							      								    								  file included from /usr/include/c++/8/unordered_se
							      								    								  t:47,			 from /usr/include/c++/8/x86
							      								    								  _64-redhat-linux/bits/stdc++.h:118,
							      								    								     from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.c
							      								    								  pp:14: /usr/include/c++/8/bits/unordered_set.h:168
							      								    								  7:5: note: candidate: ‘template<class _Value, clas
							      								    								  s _Hash, class _Pred, class _Alloc> bool std::oper
							      								    								  ator!=(const std::unordered_multiset<_Value, _Hash
							      								    								  , _Pred, _Alloc>&, const std::unordered_multiset<_
							      								    								  Value, _Hash, _Pred, _Alloc>&)’      operator!=(co
							      								    								  nst unordered_multiset<_Value, _Hash, _Pred, _Allo
							      								    								  c>& __x,	^~~~~~~~ /usr/include/c++/8/bits/uno
							      								    								  rdered_set.h:1687:5: note:   template argument ded
							      								    								  uction/substitution failed: FIND_RECTANGLE_BINARY_
							      								    								  MATRIX_CORNERS_1_1.cpp:56:99: note:	‘std::set<in
							      								    								  t>::iterator’ {aka ‘std::_Rb_tree_const_iterator<i
							      								    								  nt>’} is not derived from ‘const std::unordered_mu
							      								    								  ltiset<_Value, _Hash, _Pred, _Alloc>’		   i
							      								    								  f ( table . find ( j ) != table . end ( ) && table
							      								    								   [ j ] . find ( k ) != table . end ( ) ) return tr
							      								    								  ue ;
							      								    								  
							      								    								      ^ In file included from /usr/include/c++/8/bit
							      								    								  s/hashtable.h:35,		     from /usr/inclu
							      								    								  de/c++/8/unordered_map:46,		      from /
							      								    								  usr/include/c++/8/x86_64-redhat-linux/bits/stdc++.
							      								    								  h:117,		  from FIND_RECTANGLE_BINARY
							      								    								  _MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bit
							      								    								  s/hashtable_policy.h:312:5: note: candidate: ‘temp
							      								    								  late<class _Value, bool _Cache_hash_code> bool std
							      								    								  ::__detail::operator!=(const std::__detail::_Node_
							      								    								  iterator_base<_Value, _Cache_hash_code>&, const st
							      								    								  d::__detail::_Node_iterator_base<_Value, _Cache_ha
							      								    								  sh_code>&)’	   operator!=(const _Node_iterator_b
							      								    								  ase<_Value, _Cache_hash_code>& __x,	   ^~~~~~~~
							      								    								  /usr/include/c++/8/bits/hashtable_policy.h:312:5:
							      								    								  note:	  template argument deduction/substitution f
							      								    								  ailed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:56:99: note:   ‘std::set<int>::iterator’ {aka ‘s
							      								    								  td::_Rb_tree_const_iterator<int>’} is not derived
							      								    								  from ‘const std::__detail::_Node_iterator_base<_Va
							      								    								  lue, _Cache_hash_code>’	     if ( table . fi
							      								    								  nd ( j ) != table . end ( ) && table [ j ] . find
							      								    								  ( k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					  ^ In file
							      								    								  included from /usr/include/c++/8/bits/hashtable.h:
							      								    								  35,		       from /usr/include/c++/8/unord
							      								    								  ered_map:46,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:117,
							      								    								  	    from FIND_RECTANGLE_BINARY_MATRIX_CORNER
							      								    								  S_1_1.cpp:14: /usr/include/c++/8/bits/hashtable_po
							      								    								  licy.h:1647:5: note: candidate: ‘template<class _K
							      								    								  ey, class _Value, class _ExtractKey, class _H1, cl
							      								    								  ass _H2, class _Hash, bool __cache> bool std::__de
							      								    								  tail::operator!=(const std::__detail::_Local_itera
							      								    								  tor_base<_Key, _Value, _ExtractKey, _H1, _H2, _Has
							      								    								  h, __cache>&, const std::__detail::_Local_iterator
							      								    								  _base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,
							      								    								  __cache>&)’	   operator!=(const _Local_iterator_
							      								    								  base<_Key, _Value, _ExtractKey,      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/hashtable_policy.h:1647:5: not
							      								    								  e:   template argument deduction/substitution fail
							      								    								  ed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:5
							      								    								  6:99: note:	‘std::set<int>::iterator’ {aka ‘std:
							      								    								  :_Rb_tree_const_iterator<int>’} is not derived fro
							      								    								  m ‘const std::__detail::_Local_iterator_base<_Key,
							      								    								   _Value, _ExtractKey, _H1, _H2, _Hash, __cache>’
							      								    								  	    if ( table . find ( j ) != table . end (
							      								    								   ) && table [ j ] . find ( k ) != table . end ( )
							      								    								  ) return true ;
							      								    								  
							      								    								  		 ^ In file included from /usr/includ
							      								    								  e/c++/8/bits/stl_algobase.h:67,		   f
							      								    								  rom /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  	       from /usr/include/c++/8/ios:40,
							      								    								  	      from /usr/include/c++/8/ostream:38,
							      								    								  		 from /usr/include/c++/8/iostream:39
							      								    								  ,		     from FIND_RECTANGLE_BINARY_MATR
							      								    								  IX_CORNERS_1_1.cpp:8: /usr/include/c++/8/bits/stl_
							      								    								  iterator.h:877:5: note: candidate: ‘template<class
							      								    								   _IteratorL, class _IteratorR, class _Container> b
							      								    								  ool __gnu_cxx::operator!=(const __gnu_cxx::__norma
							      								    								  l_iterator<_IteratorL, _Container>&, const __gnu_c
							      								    								  xx::__normal_iterator<_IteratorR, _Container>&)’
							      								    								      operator!=(const __normal_iterator<_IteratorL,
							      								    								   _Container>& __lhs,	    ^~~~~~~~ /usr/include/c+
							      								    								  +/8/bits/stl_iterator.h:877:5: note:	 template ar
							      								    								  gument deduction/substitution failed: FIND_RECTANG
							      								    								  LE_BINARY_MATRIX_CORNERS_1_1.cpp:56:99: note:	  ‘s
							      								    								  td::set<int>::iterator’ {aka ‘std::_Rb_tree_const_
							      								    								  iterator<int>’} is not derived from ‘const __gnu_c
							      								    								  xx::__normal_iterator<_IteratorL, _Container>’
							      								    								  	  if ( table . find ( j ) != table . end ( )
							      								    								   && table [ j ] . find ( k ) != table . end ( ) )
							      								    								  return true ;
							      								    								  
							      								    								  	       ^ In file included from /usr/include/
							      								    								  c++/8/bits/stl_algobase.h:67,			 fro
							      								    								  m /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  	     from /usr/include/c++/8/ios:40,
							      								    								  	    from /usr/include/c++/8/ostream:38,
							      								    								  	       from /usr/include/c++/8/iostream:39,
							      								    								  		   from FIND_RECTANGLE_BINARY_MATRIX
							      								    								  _CORNERS_1_1.cpp:8: /usr/include/c++/8/bits/stl_it
							      								    								  erator.h:884:5: note: candidate: ‘template<class _
							      								    								  Iterator, class _Container> bool __gnu_cxx::operat
							      								    								  or!=(const __gnu_cxx::__normal_iterator<_Iterator,
							      								    								   _Container>&, const __gnu_cxx::__normal_iterator<
							      								    								  _Iterator, _Container>&)’	 operator!=(const __
							      								    								  normal_iterator<_Iterator, _Container>& __lhs,
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/stl_iterator.h:
							      								    								  884:5: note:	 template argument deduction/substit
							      								    								  ution failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS
							      								    								  _1_1.cpp:56:99: note:	  ‘std::set<int>::iterator’
							      								    								  {aka ‘std::_Rb_tree_const_iterator<int>’} is not d
							      								    								  erived from ‘const __gnu_cxx::__normal_iterator<_I
							      								    								  terator, _Container>’		   if ( table . find
							      								    								   ( j ) != table . end ( ) && table [ j ] . find (
							      								    								  k ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					^ In file in
							      								    								  cluded from /usr/include/c++/8/x86_64-redhat-linux
							      								    								  /bits/c++allocator.h:33,		    from /us
							      								    								  r/include/c++/8/bits/allocator.h:46,
							      								    								      from /usr/include/c++/8/string:41,
							      								    								  	from /usr/include/c++/8/bits/locale_classes.
							      								    								  h:40,			 from /usr/include/c++/8/bit
							      								    								  s/ios_base.h:41,		    from /usr/includ
							      								    								  e/c++/8/ios:42,		   from /usr/include
							      								    								  /c++/8/ostream:38,		      from /usr/incl
							      								    								  ude/c++/8/iostream:39,		  from FIND_
							      								    								  RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8: /usr/in
							      								    								  clude/c++/8/ext/new_allocator.h:160:5: note: candi
							      								    								  date: ‘template<class _Tp> bool __gnu_cxx::operato
							      								    								  r!=(const __gnu_cxx::new_allocator<_Tp>&, const __
							      								    								  gnu_cxx::new_allocator<_Tp>&)’      operator!=(con
							      								    								  st new_allocator<_Tp>&, const new_allocator<_Tp>&)
							      								    								  	^~~~~~~~ /usr/include/c++/8/ext/new_allocato
							      								    								  r.h:160:5: note:   template argument deduction/sub
							      								    								  stitution failed: FIND_RECTANGLE_BINARY_MATRIX_COR
							      								    								  NERS_1_1.cpp:56:99: note:   ‘std::set<int>::iterat
							      								    								  or’ {aka ‘std::_Rb_tree_const_iterator<int>’} is n
							      								    								  ot derived from ‘const __gnu_cxx::new_allocator<_T
							      								    								  p>’		 if ( table . find ( j ) != table .
							      								    								  end ( ) && table [ j ] . find ( k ) != table . end
							      								    								   ( ) ) return true ;
							      								    								  
							      								    								  		      ^ FIND_RECTANGLE_BINARY_MATRIX
							      								    								  _CORNERS_1_1.cpp:57:82: error: no match for ‘opera
							      								    								  tor!=’ (operand types are ‘std::set<int>::iterator
							      								    								  ’ {aka ‘std::_Rb_tree_const_iterator<int>’} and ‘s
							      								    								  td::unordered_map<int, std::set<int> >::iterator’
							      								    								  {aka ‘std::__detail::_Node_iterator<std::pair<cons
							      								    								  t int, std::set<int> >, false, false>’})
							      								    								    if ( table . find ( k ) != table . end ( ) && ta
							      								    								  ble [ k ] . find ( j ) != table . end ( ) ) return
							      								    								   true ;
							      								    								  		 ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~
							      								    								  ~~~~~~~~ In file included from /usr/include/c++/8/
							      								    								  map:60,		   from /usr/include/c++/8/x
							      								    								  86_64-redhat-linux/bits/stdc++.h:81,
							      								    								      from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.
							      								    								  cpp:14: /usr/include/c++/8/bits/stl_tree.h:398:7:
							      								    								  note: candidate: ‘bool std::_Rb_tree_const_iterato
							      								    								  r<_Tp>::operator!=(const _Self&) const [with _Tp =
							      								    								   int; std::_Rb_tree_const_iterator<_Tp>::_Self = s
							      								    								  td::_Rb_tree_const_iterator<int>]’	    operator
							      								    								  !=(const _Self& __x) const _GLIBCXX_NOEXCEPT
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/stl_tree.h:398:
							      								    								  7: note:   no known conversion for argument 1 from
							      								    								   ‘std::unordered_map<int, std::set<int> >::iterato
							      								    								  r’ {aka ‘std::__detail::_Node_iterator<std::pair<c
							      								    								  onst int, std::set<int> >, false, false>’} to ‘con
							      								    								  st _Self&’ {aka ‘const std::_Rb_tree_const_iterato
							      								    								  r<int>&’} In file included from /usr/include/c++/8
							      								    								  /regex:62,		      from /usr/include/c++/
							      								    								  8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  	  from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_
							      								    								  1_1.cpp:14: /usr/include/c++/8/bits/regex.h:991:5:
							      								    								   note: candidate: ‘template<class _BiIter> bool st
							      								    								  d::__cxx11::operator!=(const std::__cxx11::sub_mat
							      								    								  ch<_BiIter>&, const std::__cxx11::sub_match<_BiIte
							      								    								  r>&)’	     operator!=(const sub_match<_BiIter>& __
							      								    								  lhs, const sub_match<_BiIter>& __rhs)	     ^~~~~~~
							      								    								  ~ /usr/include/c++/8/bits/regex.h:991:5: note:   t
							      								    								  emplate argument deduction/substitution failed: FI
							      								    								  ND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99:
							      								    								  note:	  ‘std::set<int>::iterator’ {aka ‘std::_Rb_t
							      								    								  ree_const_iterator<int>’} is not derived from ‘con
							      								    								  st std::__cxx11::sub_match<_BiIter>’		  if
							      								    								   ( table . find ( k ) != table . end ( ) && table
							      								    								  [ k ] . find ( j ) != table . end ( ) ) return tru
							      								    								  e ;
							      								    								  
							      								    								     ^ In file included from /usr/include/c++/8/rege
							      								    								  x:62,			 from /usr/include/c++/8/x86
							      								    								  _64-redhat-linux/bits/stdc++.h:110,
							      								    								     from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.c
							      								    								  pp:14: /usr/include/c++/8/bits/regex.h:1069:5: not
							      								    								  e: candidate: ‘template<class _Bi_iter, class _Ch_
							      								    								  traits, class _Ch_alloc> bool std::__cxx11::operat
							      								    								  or!=(std::__cxx11::__sub_match_string<_Bi_iter, _C
							      								    								  h_traits, _Ch_alloc>&, const std::__cxx11::sub_mat
							      								    								  ch<_BiIter>&)’      operator!=(const __sub_match_s
							      								    								  tring<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/regex.h:1069:5:
							      								    								   note:   template argument deduction/substitution
							      								    								  failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.c
							      								    								  pp:57:99: note:   ‘std::set<int>::iterator’ {aka ‘
							      								    								  std::_Rb_tree_const_iterator<int>’} is not derived
							      								    								   from ‘std::__cxx11::__sub_match_string<_Bi_iter,
							      								    								  _Ch_traits, _Ch_alloc>’	     if ( table . fi
							      								    								  nd ( k ) != table . end ( ) && table [ k ] . find
							      								    								  ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					  ^ In file
							      								    								  included from /usr/include/c++/8/regex:62,
							      								    								  	    from /usr/include/c++/8/x86_64-redhat-li
							      								    								  nux/bits/stdc++.h:110,		  from FIND_
							      								    								  RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/i
							      								    								  nclude/c++/8/bits/regex.h:1149:5: note: candidate:
							      								    								   ‘template<class _Bi_iter, class _Ch_traits, class
							      								    								   _Ch_alloc> bool std::__cxx11::operator!=(const st
							      								    								  d::__cxx11::sub_match<_BiIter>&, std::__cxx11::__s
							      								    								  ub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>&)
							      								    								  ’	 operator!=(const sub_match<_Bi_iter>& __lhs
							      								    								  ,	 ^~~~~~~~ /usr/include/c++/8/bits/regex.h:11
							      								    								  49:5: note:	template argument deduction/substitu
							      								    								  tion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_
							      								    								  1_1.cpp:57:99: note:	 ‘std::set<int>::iterator’ {
							      								    								  aka ‘std::_Rb_tree_const_iterator<int>’} is not de
							      								    								  rived from ‘const std::__cxx11::sub_match<_BiIter>
							      								    								  ’	       if ( table . find ( k ) != table . en
							      								    								  d ( ) && table [ k ] . find ( j ) != table . end (
							      								    								   ) ) return true ;
							      								    								  
							      								    								  		    ^ In file included from /usr/inc
							      								    								  lude/c++/8/regex:62,			from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  		    from FIND_RECTANGLE_BINARY_MATRI
							      								    								  X_CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/rege
							      								    								  x.h:1226:5: note: candidate: ‘template<class _Bi_i
							      								    								  ter> bool std::__cxx11::operator!=(const typename
							      								    								  std::iterator_traits<_Iter>::value_type*, const st
							      								    								  d::__cxx11::sub_match<_BiIter>&)’	 operator!=(
							      								    								  typename iterator_traits<_Bi_iter>::value_type con
							      								    								  st* __lhs,	  ^~~~~~~~ /usr/include/c++/8/bits/r
							      								    								  egex.h:1226:5: note:	 template argument deduction
							      								    								  /substitution failed: FIND_RECTANGLE_BINARY_MATRIX
							      								    								  _CORNERS_1_1.cpp:57:99: note:	  ‘std::unordered_ma
							      								    								  p<int, std::set<int> >::iterator’ {aka ‘std::__det
							      								    								  ail::_Node_iterator<std::pair<const int, std::set<
							      								    								  int> >, false, false>’} is not derived from ‘const
							      								    								   std::__cxx11::sub_match<_BiIter>’		if (
							      								    								   table . find ( k ) != table . end ( ) && table [
							      								    								  k ] . find ( j ) != table . end ( ) ) return true
							      								    								  ;
							      								    								  
							      								    								   ^ In file included from /usr/include/c++/8/regex:
							      								    								  62,		       from /usr/include/c++/8/x86_6
							      								    								  4-redhat-linux/bits/stdc++.h:110,
							      								    								   from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp
							      								    								  :14: /usr/include/c++/8/bits/regex.h:1300:5: note:
							      								    								   candidate: ‘template<class _Bi_iter> bool std::__
							      								    								  cxx11::operator!=(const std::__cxx11::sub_match<_B
							      								    								  iIter>&, const typename std::iterator_traits<_Iter
							      								    								  >::value_type*)’	operator!=(const sub_match<_
							      								    								  Bi_iter>& __lhs,	^~~~~~~~ /usr/include/c++/8/
							      								    								  bits/regex.h:1300:5: note:   template argument ded
							      								    								  uction/substitution failed: FIND_RECTANGLE_BINARY_
							      								    								  MATRIX_CORNERS_1_1.cpp:57:99: note:	‘std::set<in
							      								    								  t>::iterator’ {aka ‘std::_Rb_tree_const_iterator<i
							      								    								  nt>’} is not derived from ‘const std::__cxx11::sub
							      								    								  _match<_BiIter>’	      if ( table . find ( k
							      								    								  ) != table . end ( ) && table [ k ] . find ( j ) !
							      								    								  = table . end ( ) ) return true ;
							      								    								  
							      								    								  				   ^ In file include
							      								    								  d from /usr/include/c++/8/regex:62,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:110,		   from FIND_RECTANG
							      								    								  LE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/
							      								    								  c++/8/bits/regex.h:1377:5: note: candidate: ‘templ
							      								    								  ate<class _Bi_iter> bool std::__cxx11::operator!=(
							      								    								  const typename std::iterator_traits<_Iter>::value_
							      								    								  type&, const std::__cxx11::sub_match<_BiIter>&)’
							      								    								      operator!=(typename iterator_traits<_Bi_iter>:
							      								    								  :value_type const& __lhs,	 ^~~~~~~~ /usr/inclu
							      								    								  de/c++/8/bits/regex.h:1377:5: note:	template arg
							      								    								  ument deduction/substitution failed: FIND_RECTANGL
							      								    								  E_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:	 ‘st
							      								    								  d::unordered_map<int, std::set<int> >::iterator’ {
							      								    								  aka ‘std::__detail::_Node_iterator<std::pair<const
							      								    								   int, std::set<int> >, false, false>’} is not deri
							      								    								  ved from ‘const std::__cxx11::sub_match<_BiIter>’
							      								    								  	     if ( table . find ( k ) != table . end
							      								    								  ( ) && table [ k ] . find ( j ) != table . end ( )
							      								    								   ) return true ;
							      								    								  
							      								    								  		  ^ In file included from /usr/inclu
							      								    								  de/c++/8/regex:62,		      from /usr/incl
							      								    								  ude/c++/8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  		  from FIND_RECTANGLE_BINARY_MATRIX_
							      								    								  CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/regex.
							      								    								  h:1457:5: note: candidate: ‘template<class _Bi_ite
							      								    								  r> bool std::__cxx11::operator!=(const std::__cxx1
							      								    								  1::sub_match<_BiIter>&, const typename std::iterat
							      								    								  or_traits<_Iter>::value_type&)’      operator!=(co
							      								    								  nst sub_match<_Bi_iter>& __lhs,      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/regex.h:1457:5: note:   templa
							      								    								  te argument deduction/substitution failed: FIND_RE
							      								    								  CTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								     ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_c
							      								    								  onst_iterator<int>’} is not derived from ‘const st
							      								    								  d::__cxx11::sub_match<_BiIter>’	     if ( ta
							      								    								  ble . find ( k ) != table . end ( ) && table [ k ]
							      								    								   . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						  ^
							      								    								  In file included from /usr/include/c++/8/regex:62,
							      								    								  		    from /usr/include/c++/8/x86_64-r
							      								    								  edhat-linux/bits/stdc++.h:110,		  fr
							      								    								  om FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14
							      								    								  : /usr/include/c++/8/bits/regex.h:1981:5: note: ca
							      								    								  ndidate: ‘template<class _Bi_iter, class _Alloc> b
							      								    								  ool std::__cxx11::operator!=(const std::__cxx11::m
							      								    								  atch_results<_BiIter, _Alloc>&, const std::__cxx11
							      								    								  ::match_results<_BiIter, _Alloc>&)’	   operator!
							      								    								  =(const match_results<_Bi_iter, _Alloc>& __m1,
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/regex.h:1981:5:
							      								    								   note:   template argument deduction/substitution
							      								    								  failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.c
							      								    								  pp:57:99: note:   ‘std::set<int>::iterator’ {aka ‘
							      								    								  std::_Rb_tree_const_iterator<int>’} is not derived
							      								    								   from ‘const std::__cxx11::match_results<_BiIter,
							      								    								  _Alloc>’	      if ( table . find ( k ) != tab
							      								    								  le . end ( ) && table [ k ] . find ( j ) != table
							      								    								  . end ( ) ) return true ;
							      								    								  
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/iosfwd:40,			from
							      								    								   /usr/include/c++/8/ios:38,		       from
							      								    								  /usr/include/c++/8/ostream:38,		  fr
							      								    								  om /usr/include/c++/8/iostream:39,
							      								    								    from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:8: /usr/include/c++/8/bits/postypes.h:221:5: not
							      								    								  e: candidate: ‘template<class _StateT> bool std::o
							      								    								  perator!=(const std::fpos<_StateT>&, const std::fp
							      								    								  os<_StateT>&)’      operator!=(const fpos<_StateT>
							      								    								  & __lhs, const fpos<_StateT>& __rhs)	    ^~~~~~~~
							      								    								   /usr/include/c++/8/bits/postypes.h:221:5: note:
							      								    								   template argument deduction/substitution failed:
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99
							      								    								  : note:   ‘std::set<int>::iterator’ {aka ‘std::_Rb
							      								    								  _tree_const_iterator<int>’} is not derived from ‘c
							      								    								  onst std::fpos<_StateT>’	      if ( table . f
							      								    								  ind ( k ) != table . end ( ) && table [ k ] . find
							      								    								   ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					   ^ In file
							      								    								   included from /usr/include/c++/8/bits/stl_algobas
							      								    								  e.h:64,		   from /usr/include/c++/8/b
							      								    								  its/char_traits.h:39,			 from /usr/i
							      								    								  nclude/c++/8/ios:40,			from /usr/in
							      								    								  clude/c++/8/ostream:38,		   from /usr
							      								    								  /include/c++/8/iostream:39,		       from
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8: /u
							      								    								  sr/include/c++/8/bits/stl_pair.h:461:5: note: cand
							      								    								  idate: ‘template<class _T1, class _T2> constexpr b
							      								    								  ool std::operator!=(const std::pair<_T1, _T2>&, co
							      								    								  nst std::pair<_T1, _T2>&)’	  operator!=(const p
							      								    								  air<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/stl_pair.h:461:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1
							      								    								  .cpp:57:99: note:   ‘std::set<int>::iterator’ {aka
							      								    								   ‘std::_Rb_tree_const_iterator<int>’} is not deriv
							      								    								  ed from ‘const std::pair<_T1, _T2>’		 if
							      								    								  ( table . find ( k ) != table . end ( ) && table [
							      								    								   k ] . find ( j ) != table . end ( ) ) return true
							      								    								   ;
							      								    								  
							      								    								    ^ In file included from /usr/include/c++/8/bits/
							      								    								  stl_algobase.h:67,		      from /usr/incl
							      								    								  ude/c++/8/bits/char_traits.h:39,
							      								    								  from /usr/include/c++/8/ios:40,		   f
							      								    								  rom /usr/include/c++/8/ostream:38,
							      								    								    from /usr/include/c++/8/iostream:39,
							      								    								  	from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_
							      								    								  1.cpp:8: /usr/include/c++/8/bits/stl_iterator.h:31
							      								    								  4:5: note: candidate: ‘template<class _Iterator> b
							      								    								  ool std::operator!=(const std::reverse_iterator<_I
							      								    								  terator>&, const std::reverse_iterator<_Iterator>&
							      								    								  )’	  operator!=(const reverse_iterator<_Iterato
							      								    								  r>& __x,	^~~~~~~~ /usr/include/c++/8/bits/stl
							      								    								  _iterator.h:314:5: note:   template argument deduc
							      								    								  tion/substitution failed: FIND_RECTANGLE_BINARY_MA
							      								    								  TRIX_CORNERS_1_1.cpp:57:99: note:   ‘std::set<int>
							      								    								  ::iterator’ {aka ‘std::_Rb_tree_const_iterator<int
							      								    								  >’} is not derived from ‘const std::reverse_iterat
							      								    								  or<_Iterator>’	    if ( table . find ( k )
							      								    								  != table . end ( ) && table [ k ] . find ( j ) !=
							      								    								  table . end ( ) ) return true ;
							      								    								  
							      								    								  				 ^ In file included
							      								    								  from /usr/include/c++/8/bits/stl_algobase.h:67,
							      								    								  		 from /usr/include/c++/8/bits/char_t
							      								    								  raits.h:39,		       from /usr/include/c++
							      								    								  /8/ios:40,		      from /usr/include/c++/
							      								    								  8/ostream:38,			 from /usr/include/c
							      								    								  ++/8/iostream:39,		     from FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8: /usr/include
							      								    								  /c++/8/bits/stl_iterator.h:352:5: note: candidate:
							      								    								   ‘template<class _IteratorL, class _IteratorR> boo
							      								    								  l std::operator!=(const std::reverse_iterator<_Ite
							      								    								  rator>&, const std::reverse_iterator<_IteratorR>&)
							      								    								  ’	 operator!=(const reverse_iterator<_Iterator
							      								    								  L>& __x,	^~~~~~~~ /usr/include/c++/8/bits/stl
							      								    								  _iterator.h:352:5: note:   template argument deduc
							      								    								  tion/substitution failed: FIND_RECTANGLE_BINARY_MA
							      								    								  TRIX_CORNERS_1_1.cpp:57:99: note:   ‘std::set<int>
							      								    								  ::iterator’ {aka ‘std::_Rb_tree_const_iterator<int
							      								    								  >’} is not derived from ‘const std::reverse_iterat
							      								    								  or<_Iterator>’	    if ( table . find ( k )
							      								    								  != table . end ( ) && table [ k ] . find ( j ) !=
							      								    								  table . end ( ) ) return true ;
							      								    								  
							      								    								  				 ^ In file included
							      								    								  from /usr/include/c++/8/bits/stl_algobase.h:67,
							      								    								  		 from /usr/include/c++/8/bits/char_t
							      								    								  raits.h:39,		       from /usr/include/c++
							      								    								  /8/ios:40,		      from /usr/include/c++/
							      								    								  8/ostream:38,			 from /usr/include/c
							      								    								  ++/8/iostream:39,		     from FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8: /usr/include
							      								    								  /c++/8/bits/stl_iterator.h:1127:5: note: candidate
							      								    								  : ‘template<class _IteratorL, class _IteratorR> bo
							      								    								  ol std::operator!=(const std::move_iterator<_Itera
							      								    								  torL>&, const std::move_iterator<_IteratorR>&)’
							      								    								     operator!=(const move_iterator<_IteratorL>& __x
							      								    								  ,	 ^~~~~~~~ /usr/include/c++/8/bits/stl_iterat
							      								    								  or.h:1127:5: note:   template argument deduction/s
							      								    								  ubstitution failed: FIND_RECTANGLE_BINARY_MATRIX_C
							      								    								  ORNERS_1_1.cpp:57:99: note:	‘std::set<int>::iter
							      								    								  ator’ {aka ‘std::_Rb_tree_const_iterator<int>’} is
							      								    								   not derived from ‘const std::move_iterator<_Itera
							      								    								  torL>’	    if ( table . find ( k ) != table
							      								    								   . end ( ) && table [ k ] . find ( j ) != table .
							      								    								  end ( ) ) return true ;
							      								    								  
							      								    								  			 ^ In file included from /us
							      								    								  r/include/c++/8/bits/stl_algobase.h:67,
							      								    								  	 from /usr/include/c++/8/bits/char_traits.h:
							      								    								  39,		       from /usr/include/c++/8/ios:4
							      								    								  0,		      from /usr/include/c++/8/ostrea
							      								    								  m:38,			 from /usr/include/c++/8/ios
							      								    								  tream:39,		     from FIND_RECTANGLE_BIN
							      								    								  ARY_MATRIX_CORNERS_1_1.cpp:8: /usr/include/c++/8/b
							      								    								  its/stl_iterator.h:1133:5: note: candidate: ‘templ
							      								    								  ate<class _Iterator> bool std::operator!=(const st
							      								    								  d::move_iterator<_IteratorL>&, const std::move_ite
							      								    								  rator<_IteratorL>&)’	    operator!=(const move_it
							      								    								  erator<_Iterator>& __x,      ^~~~~~~~ /usr/include
							      								    								  /c++/8/bits/stl_iterator.h:1133:5: note:   templat
							      								    								  e argument deduction/substitution failed: FIND_REC
							      								    								  TANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								    ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_co
							      								    								  nst_iterator<int>’} is not derived from ‘const std
							      								    								  ::move_iterator<_IteratorL>’		  if ( table
							      								    								   . find ( k ) != table . end ( ) && table [ k ] .
							      								    								  find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					       ^ In
							      								    								  file included from /usr/include/c++/8/string:41,
							      								    								  		  from /usr/include/c++/8/bits/local
							      								    								  e_classes.h:40,		   from /usr/include
							      								    								  /c++/8/bits/ios_base.h:41,		      from /
							      								    								  usr/include/c++/8/ios:42,		     from /u
							      								    								  sr/include/c++/8/ostream:38,			from
							      								    								   /usr/include/c++/8/iostream:39,
							      								    								  from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:
							      								    								  8: /usr/include/c++/8/bits/allocator.h:158:5: note
							      								    								  : candidate: ‘template<class _T1, class _T2> bool
							      								    								  std::operator!=(const std::allocator<_CharT>&, con
							      								    								  st std::allocator<_T2>&)’	 operator!=(const al
							      								    								  locator<_T1>&, const allocator<_T2>&)	     ^~~~~~~
							      								    								  ~ /usr/include/c++/8/bits/allocator.h:158:5: note:
							      								    								     template argument deduction/substitution failed
							      								    								  : FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:
							      								    								  99: note:   ‘std::set<int>::iterator’ {aka ‘std::_
							      								    								  Rb_tree_const_iterator<int>’} is not derived from
							      								    								  ‘const std::allocator<_CharT>’	    if ( tab
							      								    								  le . find ( k ) != table . end ( ) && table [ k ]
							      								    								  . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						 ^ I
							      								    								  n file included from /usr/include/c++/8/string:41,
							      								    								  		    from /usr/include/c++/8/bits/loc
							      								    								  ale_classes.h:40,		     from /usr/inclu
							      								    								  de/c++/8/bits/ios_base.h:41,			from
							      								    								   /usr/include/c++/8/ios:42,		       from
							      								    								  /usr/include/c++/8/ostream:38,		  fr
							      								    								  om /usr/include/c++/8/iostream:39,
							      								    								    from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:8: /usr/include/c++/8/bits/allocator.h:164:5: no
							      								    								  te: candidate: ‘template<class _Tp> bool std::oper
							      								    								  ator!=(const std::allocator<_CharT>&, const std::a
							      								    								  llocator<_CharT>&)’	   operator!=(const allocato
							      								    								  r<_Tp>&, const allocator<_Tp>&)      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/allocator.h:164:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: no
							      								    								  te:	‘std::set<int>::iterator’ {aka ‘std::_Rb_tre
							      								    								  e_const_iterator<int>’} is not derived from ‘const
							      								    								   std::allocator<_CharT>’	      if ( table . f
							      								    								  ind ( k ) != table . end ( ) && table [ k ] . find
							      								    								   ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					   ^ In file
							      								    								   included from /usr/include/c++/8/string:52,
							      								    								  	      from /usr/include/c++/8/bits/locale_cl
							      								    								  asses.h:40,		       from /usr/include/c++
							      								    								  /8/bits/ios_base.h:41,		  from /usr/
							      								    								  include/c++/8/ios:42,			 from /usr/i
							      								    								  nclude/c++/8/ostream:38,		    from /us
							      								    								  r/include/c++/8/iostream:39,			from
							      								    								   FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8: /
							      								    								  usr/include/c++/8/bits/basic_string.h:6095:5: note
							      								    								  : candidate: ‘template<class _CharT, class _Traits
							      								    								  , class _Alloc> bool std::operator!=(const std::__
							      								    								  cxx11::basic_string<_CharT, _Traits, _Alloc>&, con
							      								    								  st std::__cxx11::basic_string<_CharT, _Traits, _Al
							      								    								  loc>&)’      operator!=(const basic_string<_CharT,
							      								    								   _Traits, _Alloc>& __lhs,	 ^~~~~~~~ /usr/inclu
							      								    								  de/c++/8/bits/basic_string.h:6095:5: note:   templ
							      								    								  ate argument deduction/substitution failed: FIND_R
							      								    								  ECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note
							      								    								  :   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_
							      								    								  const_iterator<int>’} is not derived from ‘const s
							      								    								  td::__cxx11::basic_string<_CharT, _Traits, _Alloc>
							      								    								  ’	       if ( table . find ( k ) != table . en
							      								    								  d ( ) && table [ k ] . find ( j ) != table . end (
							      								    								   ) ) return true ;
							      								    								  
							      								    								  		    ^ In file included from /usr/inc
							      								    								  lude/c++/8/string:52,			 from /usr/i
							      								    								  nclude/c++/8/bits/locale_classes.h:40,
							      								    								  	from /usr/include/c++/8/bits/ios_base.h:41,
							      								    								  		   from /usr/include/c++/8/ios:42,
							      								    								  		  from /usr/include/c++/8/ostream:38
							      								    								  ,		     from /usr/include/c++/8/iostrea
							      								    								  m:39,			 from FIND_RECTANGLE_BINARY_
							      								    								  MATRIX_CORNERS_1_1.cpp:8: /usr/include/c++/8/bits/
							      								    								  basic_string.h:6108:5: note: candidate: ‘template<
							      								    								  class _CharT, class _Traits, class _Alloc> bool st
							      								    								  d::operator!=(const _CharT*, const std::__cxx11::b
							      								    								  asic_string<_CharT, _Traits, _Alloc>&)’      opera
							      								    								  tor!=(const _CharT* __lhs,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/basic_string.h:6108:5: note:	temp
							      								    								  late argument deduction/substitution failed: FIND_
							      								    								  RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: not
							      								    								  e:   mismatched types ‘const _CharT*’ and ‘std::_R
							      								    								  b_tree_const_iterator<int>’		 if ( table
							      								    								  . find ( k ) != table . end ( ) && table [ k ] . f
							      								    								  ind ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/string:52,
							      								    								  		 from /usr/include/c++/8/bits/locale
							      								    								  _classes.h:40,		  from /usr/include/
							      								    								  c++/8/bits/ios_base.h:41,		     from /u
							      								    								  sr/include/c++/8/ios:42,		    from /us
							      								    								  r/include/c++/8/ostream:38,		       from
							      								    								  /usr/include/c++/8/iostream:39,		   f
							      								    								  rom FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8
							      								    								  : /usr/include/c++/8/bits/basic_string.h:6120:5: n
							      								    								  ote: candidate: ‘template<class _CharT, class _Tra
							      								    								  its, class _Alloc> bool std::operator!=(const std:
							      								    								  :__cxx11::basic_string<_CharT, _Traits, _Alloc>&,
							      								    								  const _CharT*)’      operator!=(const basic_string
							      								    								  <_CharT, _Traits, _Alloc>& __lhs,	 ^~~~~~~~ /u
							      								    								  sr/include/c++/8/bits/basic_string.h:6120:5: note:
							      								    								     template argument deduction/substitution failed
							      								    								  : FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:
							      								    								  99: note:   ‘std::set<int>::iterator’ {aka ‘std::_
							      								    								  Rb_tree_const_iterator<int>’} is not derived from
							      								    								  ‘const std::__cxx11::basic_string<_CharT, _Traits,
							      								    								   _Alloc>’	       if ( table . find ( k ) != ta
							      								    								  ble . end ( ) && table [ k ] . find ( j ) != table
							      								    								   . end ( ) ) return true ;
							      								    								  
							      								    								  			    ^ In file included from
							      								    								  /usr/include/c++/8/bits/ios_base.h:46,
							      								    								  	from /usr/include/c++/8/ios:42,
							      								    								       from /usr/include/c++/8/ostream:38,
							      								    								  	  from /usr/include/c++/8/iostream:39,
							      								    								  	      from FIND_RECTANGLE_BINARY_MATRIX_CORN
							      								    								  ERS_1_1.cpp:8: /usr/include/c++/8/system_error:319
							      								    								  :3: note: candidate: ‘bool std::operator!=(const s
							      								    								  td::error_code&, const std::error_code&)’    opera
							      								    								  tor!=(const error_code& __lhs, const error_code& _
							      								    								  _rhs) noexcept    ^~~~~~~~ /usr/include/c++/8/syst
							      								    								  em_error:319:3: note:	  no known conversion for ar
							      								    								  gument 1 from ‘std::set<int>::iterator’ {aka ‘std:
							      								    								  :_Rb_tree_const_iterator<int>’} to ‘const std::err
							      								    								  or_code&’ /usr/include/c++/8/system_error:323:3: n
							      								    								  ote: candidate: ‘bool std::operator!=(const std::e
							      								    								  rror_code&, const std::error_condition&)’    opera
							      								    								  tor!=(const error_code& __lhs, const error_conditi
							      								    								  on& __rhs) noexcept	 ^~~~~~~~ /usr/include/c++/8
							      								    								  /system_error:323:3: note:   no known conversion f
							      								    								  or argument 1 from ‘std::set<int>::iterator’ {aka
							      								    								  ‘std::_Rb_tree_const_iterator<int>’} to ‘const std
							      								    								  ::error_code&’ /usr/include/c++/8/system_error:327
							      								    								  :3: note: candidate: ‘bool std::operator!=(const s
							      								    								  td::error_condition&, const std::error_code&)’
							      								    								  operator!=(const error_condition& __lhs, const err
							      								    								  or_code& __rhs) noexcept    ^~~~~~~~ /usr/include/
							      								    								  c++/8/system_error:327:3: note:   no known convers
							      								    								  ion for argument 1 from ‘std::set<int>::iterator’
							      								    								  {aka ‘std::_Rb_tree_const_iterator<int>’} to ‘cons
							      								    								  t std::error_condition&’ /usr/include/c++/8/system
							      								    								  _error:331:3: note: candidate: ‘bool std::operator
							      								    								  !=(const std::error_condition&, const std::error_c
							      								    								  ondition&)’	 operator!=(const error_condition& _
							      								    								  _lhs,	   ^~~~~~~~ /usr/include/c++/8/system_error:
							      								    								  331:3: note:	 no known conversion for argument 1
							      								    								  from ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree
							      								    								  _const_iterator<int>’} to ‘const std::error_condit
							      								    								  ion&’ In file included from /usr/include/c++/8/bit
							      								    								  s/locale_facets.h:48,			 from /usr/i
							      								    								  nclude/c++/8/bits/basic_ios.h:37,
							      								    								   from /usr/include/c++/8/ios:44,
							      								    								  from /usr/include/c++/8/ostream:38,
							      								    								     from /usr/include/c++/8/iostream:39,
							      								    								  	 from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
							      								    								  _1.cpp:8: /usr/include/c++/8/bits/streambuf_iterat
							      								    								  or.h:209:5: note: candidate: ‘template<class _Char
							      								    								  T, class _Traits> bool std::operator!=(const std::
							      								    								  istreambuf_iterator<_CharT, _Traits>&, const std::
							      								    								  istreambuf_iterator<_CharT, _Traits>&)’      opera
							      								    								  tor!=(const istreambuf_iterator<_CharT, _Traits>&
							      								    								  __a,	    ^~~~~~~~ /usr/include/c++/8/bits/streamb
							      								    								  uf_iterator.h:209:5: note:   template argument ded
							      								    								  uction/substitution failed: FIND_RECTANGLE_BINARY_
							      								    								  MATRIX_CORNERS_1_1.cpp:57:99: note:	‘std::set<in
							      								    								  t>::iterator’ {aka ‘std::_Rb_tree_const_iterator<i
							      								    								  nt>’} is not derived from ‘const std::istreambuf_i
							      								    								  terator<_CharT, _Traits>’	       if ( table .
							      								    								  find ( k ) != table . end ( ) && table [ k ] . fin
							      								    								  d ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					    ^ In fil
							      								    								  e included from /usr/include/c++/8/vector:64,
							      								    								  	       from FIND_RECTANGLE_BINARY_MATRIX_COR
							      								    								  NERS_1_1.cpp:11: /usr/include/c++/8/bits/stl_vecto
							      								    								  r.h:1777:5: note: candidate: ‘template<class _Tp,
							      								    								  class _Alloc> bool std::operator!=(const std::vect
							      								    								  or<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
							      								    								  ’	 operator!=(const vector<_Tp, _Alloc>& __x,
							      								    								  const vector<_Tp, _Alloc>& __y)      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/stl_vector.h:1777:5: note:   t
							      								    								  emplate argument deduction/substitution failed: FI
							      								    								  ND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99:
							      								    								  note:	  ‘std::set<int>::iterator’ {aka ‘std::_Rb_t
							      								    								  ree_const_iterator<int>’} is not derived from ‘con
							      								    								  st std::vector<_Tp, _Alloc>’		  if ( table
							      								    								   . find ( k ) != table . end ( ) && table [ k ] .
							      								    								  find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					       ^ In
							      								    								  file included from /usr/include/c++/8/tuple:39,
							      								    								  		 from /usr/include/c++/8/bits/unique
							      								    								  _ptr.h:37,		      from /usr/include/c++/
							      								    								  8/bits/locale_conv.h:41,		    from /us
							      								    								  r/include/c++/8/locale:43,		      from /
							      								    								  usr/include/c++/8/iomanip:43,			 fro
							      								    								  m FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:13:
							      								    								   /usr/include/c++/8/array:257:5: note: candidate:
							      								    								  ‘template<class _Tp, long unsigned int _Nm> bool s
							      								    								  td::operator!=(const std::array<_Tp, _Nm>&, const
							      								    								  std::array<_Tp, _Nm>&)’      operator!=(const arra
							      								    								  y<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
							      								    								       ^~~~~~~~ /usr/include/c++/8/array:257:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57
							      								    								  :99: note:   ‘std::set<int>::iterator’ {aka ‘std::
							      								    								  _Rb_tree_const_iterator<int>’} is not derived from
							      								    								   ‘const std::array<_Tp, _Nm>’		   if ( tabl
							      								    								  e . find ( k ) != table . end ( ) && table [ k ] .
							      								    								   find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						^ In
							      								    								   file included from /usr/include/c++/8/bits/unique
							      								    								  _ptr.h:37,		      from /usr/include/c++/
							      								    								  8/bits/locale_conv.h:41,		    from /us
							      								    								  r/include/c++/8/locale:43,		      from /
							      								    								  usr/include/c++/8/iomanip:43,			 fro
							      								    								  m FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:13:
							      								    								   /usr/include/c++/8/tuple:1439:5: note: candidate:
							      								    								   ‘template<class ... _TElements, class ... _UEleme
							      								    								  nts> constexpr bool std::operator!=(const std::tup
							      								    								  le<_Tps ...>&, const std::tuple<_Elements ...>&)’
							      								    								       operator!=(const tuple<_TElements...>& __t,
							      								    								      ^~~~~~~~ /usr/include/c++/8/tuple:1439:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57
							      								    								  :99: note:   ‘std::set<int>::iterator’ {aka ‘std::
							      								    								  _Rb_tree_const_iterator<int>’} is not derived from
							      								    								   ‘const std::tuple<_Tps ...>’		   if ( tabl
							      								    								  e . find ( k ) != table . end ( ) && table [ k ] .
							      								    								   find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						^ In
							      								    								   file included from /usr/include/c++/8/bits/locale
							      								    								  _conv.h:41,		       from /usr/include/c++
							      								    								  /8/locale:43,			 from /usr/include/c
							      								    								  ++/8/iomanip:43,		    from FIND_RECTAN
							      								    								  GLE_BINARY_MATRIX_CORNERS_1_1.cpp:13: /usr/include
							      								    								  /c++/8/bits/unique_ptr.h:710:5: note: candidate: ‘
							      								    								  template<class _Tp, class _Dp, class _Up, class _E
							      								    								  p> bool std::operator!=(const std::unique_ptr<_Tp,
							      								    								   _Dp>&, const std::unique_ptr<_Up, _Ep>&)’	  op
							      								    								  erator!=(const unique_ptr<_Tp, _Dp>& __x,	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/bits/unique_ptr.h:710:5:
							      								    								  note:	  template argument deduction/substitution f
							      								    								  ailed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:57:99: note:   ‘std::set<int>::iterator’ {aka ‘s
							      								    								  td::_Rb_tree_const_iterator<int>’} is not derived
							      								    								  from ‘const std::unique_ptr<_Tp, _Dp>’
							      								    								  if ( table . find ( k ) != table . end ( ) && tabl
							      								    								  e [ k ] . find ( j ) != table . end ( ) ) return t
							      								    								  rue ;
							      								    								  
							      								    								       ^ In file included from /usr/include/c++/8/bi
							      								    								  ts/locale_conv.h:41,			from /usr/in
							      								    								  clude/c++/8/locale:43,		  from /usr/
							      								    								  include/c++/8/iomanip:43,		     from FI
							      								    								  ND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:13: /us
							      								    								  r/include/c++/8/bits/unique_ptr.h:716:5: note: can
							      								    								  didate: ‘template<class _Tp, class _Dp> bool std::
							      								    								  operator!=(const std::unique_ptr<_Tp, _Dp>&, std::
							      								    								  nullptr_t)’	   operator!=(const unique_ptr<_Tp,
							      								    								  _Dp>& __x, nullptr_t) noexcept      ^~~~~~~~ /usr/
							      								    								  include/c++/8/bits/unique_ptr.h:716:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: no
							      								    								  te:	‘std::set<int>::iterator’ {aka ‘std::_Rb_tre
							      								    								  e_const_iterator<int>’} is not derived from ‘const
							      								    								   std::unique_ptr<_Tp, _Dp>’		 if ( table
							      								    								  . find ( k ) != table . end ( ) && table [ k ] . f
							      								    								  ind ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/bits/locale_c
							      								    								  onv.h:41,		     from /usr/include/c++/8
							      								    								  /locale:43,		       from /usr/include/c++
							      								    								  /8/iomanip:43,		  from FIND_RECTANGL
							      								    								  E_BINARY_MATRIX_CORNERS_1_1.cpp:13: /usr/include/c
							      								    								  ++/8/bits/unique_ptr.h:721:5: note: candidate: ‘te
							      								    								  mplate<class _Tp, class _Dp> bool std::operator!=(
							      								    								  std::nullptr_t, const std::unique_ptr<_Tp, _Dp>&)’
							      								    								  	operator!=(nullptr_t, const unique_ptr<_Tp,
							      								    								  _Dp>& __x) noexcept	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/unique_ptr.h:721:5: note:   template argum
							      								    								  ent deduction/substitution failed: FIND_RECTANGLE_
							      								    								  BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:   ‘std:
							      								    								  :unordered_map<int, std::set<int> >::iterator’ {ak
							      								    								  a ‘std::__detail::_Node_iterator<std::pair<const i
							      								    								  nt, std::set<int> >, false, false>’} is not derive
							      								    								  d from ‘const std::unique_ptr<_Tp, _Dp>’
							      								    								    if ( table . find ( k ) != table . end ( ) && ta
							      								    								  ble [ k ] . find ( j ) != table . end ( ) ) return
							      								    								   true ;
							      								    								  
							      								    								  	 ^ In file included from /usr/include/c++/8/
							      								    								  ccomplex:39,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:52,
							      								    								  	   from FIND_RECTANGLE_BINARY_MATRIX_CORNERS
							      								    								  _1_1.cpp:14: /usr/include/c++/8/complex:476:5: not
							      								    								  e: candidate: ‘template<class _Tp> constexpr bool
							      								    								  std::operator!=(const std::complex<_Tp>&, const st
							      								    								  d::complex<_Tp>&)’	  operator!=(const complex<_
							      								    								  Tp>& __x, const complex<_Tp>& __y)	  ^~~~~~~~ /
							      								    								  usr/include/c++/8/complex:476:5: note:   template
							      								    								  argument deduction/substitution failed: FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								  ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_cons
							      								    								  t_iterator<int>’} is not derived from ‘const std::
							      								    								  complex<_Tp>’		   if ( table . find ( k ) !
							      								    								  = table . end ( ) && table [ k ] . find ( j ) != t
							      								    								  able . end ( ) ) return true ;
							      								    								  
							      								    								  				^ In file included f
							      								    								  rom /usr/include/c++/8/ccomplex:39,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:52,		  from FIND_RECTANGL
							      								    								  E_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c
							      								    								  ++/8/complex:481:5: note: candidate: ‘template<cla
							      								    								  ss _Tp> constexpr bool std::operator!=(const std::
							      								    								  complex<_Tp>&, const _Tp&)’	   operator!=(const
							      								    								  complex<_Tp>& __x, const _Tp& __y)	  ^~~~~~~~ /
							      								    								  usr/include/c++/8/complex:481:5: note:   template
							      								    								  argument deduction/substitution failed: FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								  ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_cons
							      								    								  t_iterator<int>’} is not derived from ‘const std::
							      								    								  complex<_Tp>’		   if ( table . find ( k ) !
							      								    								  = table . end ( ) && table [ k ] . find ( j ) != t
							      								    								  able . end ( ) ) return true ;
							      								    								  
							      								    								  				^ In file included f
							      								    								  rom /usr/include/c++/8/ccomplex:39,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:52,		  from FIND_RECTANGL
							      								    								  E_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c
							      								    								  ++/8/complex:486:5: note: candidate: ‘template<cla
							      								    								  ss _Tp> constexpr bool std::operator!=(const _Tp&,
							      								    								   const std::complex<_Tp>&)’	   operator!=(const
							      								    								  _Tp& __x, const complex<_Tp>& __y)	  ^~~~~~~~ /
							      								    								  usr/include/c++/8/complex:486:5: note:   template
							      								    								  argument deduction/substitution failed: FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								  ‘std::unordered_map<int, std::set<int> >::iterator
							      								    								  ’ {aka ‘std::__detail::_Node_iterator<std::pair<co
							      								    								  nst int, std::set<int> >, false, false>’} is not d
							      								    								  erived from ‘const std::complex<_Tp>’		   i
							      								    								  f ( table . find ( k ) != table . end ( ) && table
							      								    								   [ k ] . find ( j ) != table . end ( ) ) return tr
							      								    								  ue ;
							      								    								  
							      								    								      ^ In file included from /usr/include/c++/8/deq
							      								    								  ue:64,		  from /usr/include/c++/8/x8
							      								    								  6_64-redhat-linux/bits/stdc++.h:68,
							      								    								     from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.c
							      								    								  pp:14: /usr/include/c++/8/bits/stl_deque.h:281:5:
							      								    								  note: candidate: ‘template<class _Tp, class _Ref,
							      								    								  class _Ptr> bool std::operator!=(const std::_Deque
							      								    								  _iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_ite
							      								    								  rator<_Tp, _Ref, _Ptr>&)’	 operator!=(const _D
							      								    								  eque_iterator<_Tp, _Ref, _Ptr>& __x,	    ^~~~~~~~
							      								    								   /usr/include/c++/8/bits/stl_deque.h:281:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:9
							      								    								  9: note:   ‘std::set<int>::iterator’ {aka ‘std::_R
							      								    								  b_tree_const_iterator<int>’} is not derived from ‘
							      								    								  const std::_Deque_iterator<_Tp, _Ref, _Ptr>’
							      								    								  	if ( table . find ( k ) != table . end ( ) &
							      								    								  & table [ k ] . find ( j ) != table . end ( ) ) re
							      								    								  turn true ;
							      								    								  
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/deque:64,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:68,
							      								    								  	    from FIND_RECTANGLE_BINARY_MATRIX_CORNER
							      								    								  S_1_1.cpp:14: /usr/include/c++/8/bits/stl_deque.h:
							      								    								  288:5: note: candidate: ‘template<class _Tp, class
							      								    								   _RefL, class _PtrL, class _RefR, class _PtrR> boo
							      								    								  l std::operator!=(const std::_Deque_iterator<_Tp,
							      								    								  _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref
							      								    								  R, _PtrR>&)’	    operator!=(const _Deque_iterator
							      								    								  <_Tp, _RefL, _PtrL>& __x,	 ^~~~~~~~ /usr/inclu
							      								    								  de/c++/8/bits/stl_deque.h:288:5: note:   template
							      								    								  argument deduction/substitution failed: FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								  ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_cons
							      								    								  t_iterator<int>’} is not derived from ‘const std::
							      								    								  _Deque_iterator<_Tp, _Ref, _Ptr>’	       if (
							      								    								  table . find ( k ) != table . end ( ) && table [ k
							      								    								   ] . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  
							      								    								  ^ In file included from /usr/include/c++/8/deque:6
							      								    								  4,		      from /usr/include/c++/8/x86_64
							      								    								  -redhat-linux/bits/stdc++.h:68,		   f
							      								    								  rom FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:1
							      								    								  4: /usr/include/c++/8/bits/stl_deque.h:2303:5: not
							      								    								  e: candidate: ‘template<class _Tp, class _Alloc> b
							      								    								  ool std::operator!=(const std::deque<_Tp, _Alloc>&
							      								    								  , const std::deque<_Tp, _Alloc>&)’	  operator!=
							      								    								  (const deque<_Tp, _Alloc>& __x,      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/stl_deque.h:2303:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: FIN
							      								    								  D_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: n
							      								    								  ote:	 ‘std::set<int>::iterator’ {aka ‘std::_Rb_tr
							      								    								  ee_const_iterator<int>’} is not derived from ‘cons
							      								    								  t std::deque<_Tp, _Alloc>’		if ( table .
							      								    								   find ( k ) != table . end ( ) && table [ k ] . fi
							      								    								  nd ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					     ^ In fi
							      								    								  le included from /usr/include/c++/8/functional:59,
							      								    								  		    from /usr/include/c++/8/x86_64-r
							      								    								  edhat-linux/bits/stdc++.h:71,			 fro
							      								    								  m FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14:
							      								    								   /usr/include/c++/8/bits/std_function.h:763:5: not
							      								    								  e: candidate: ‘template<class _Res, class ... _Arg
							      								    								  s> bool std::operator!=(const std::function<_Res(_
							      								    								  ArgTypes ...)>&, std::nullptr_t)’	 operator!=(
							      								    								  const function<_Res(_Args...)>& __f, nullptr_t) no
							      								    								  except      ^~~~~~~~ /usr/include/c++/8/bits/std_f
							      								    								  unction.h:763:5: note:   template argument deducti
							      								    								  on/substitution failed: FIND_RECTANGLE_BINARY_MATR
							      								    								  IX_CORNERS_1_1.cpp:57:99: note:   ‘std::set<int>::
							      								    								  iterator’ {aka ‘std::_Rb_tree_const_iterator<int>’
							      								    								  } is not derived from ‘const std::function<_Res(_A
							      								    								  rgTypes ...)>’	    if ( table . find ( k )
							      								    								  != table . end ( ) && table [ k ] . find ( j ) !=
							      								    								  table . end ( ) ) return true ;
							      								    								  
							      								    								  				 ^ In file included
							      								    								  from /usr/include/c++/8/functional:59,
							      								    								  	from /usr/include/c++/8/x86_64-redhat-linux/
							      								    								  bits/stdc++.h:71,		     from FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/includ
							      								    								  e/c++/8/bits/std_function.h:769:5: note: candidate
							      								    								  : ‘template<class _Res, class ... _Args> bool std:
							      								    								  :operator!=(std::nullptr_t, const std::function<_R
							      								    								  es(_ArgTypes ...)>&)’	     operator!=(nullptr_t, c
							      								    								  onst function<_Res(_Args...)>& __f) noexcept
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/std_function.h:76
							      								    								  9:5: note:   template argument deduction/substitut
							      								    								  ion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
							      								    								  _1.cpp:57:99: note:	‘std::unordered_map<int, std
							      								    								  ::set<int> >::iterator’ {aka ‘std::__detail::_Node
							      								    								  _iterator<std::pair<const int, std::set<int> >, fa
							      								    								  lse, false>’} is not derived from ‘const std::func
							      								    								  tion<_Res(_ArgTypes ...)>’		if ( table .
							      								    								   find ( k ) != table . end ( ) && table [ k ] . fi
							      								    								  nd ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					     ^ In fi
							      								    								  le included from /usr/include/c++/8/iterator:66,
							      								    								  		  from /usr/include/c++/8/x86_64-red
							      								    								  hat-linux/bits/stdc++.h:77,		       from
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /
							      								    								  usr/include/c++/8/bits/stream_iterator.h:137:5: no
							      								    								  te: candidate: ‘template<class _Tp, class _CharT,
							      								    								  class _Traits, class _Dist> bool std::operator!=(c
							      								    								  onst std::istream_iterator<_Tp, _CharT, _Traits, _
							      								    								  Dist>&, const std::istream_iterator<_Tp, _CharT, _
							      								    								  Traits, _Dist>&)’	 operator!=(const istream_it
							      								    								  erator<_Tp, _CharT, _Traits, _Dist>& __x,	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/bits/stream_iterator.h:13
							      								    								  7:5: note:   template argument deduction/substitut
							      								    								  ion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
							      								    								  _1.cpp:57:99: note:	‘std::set<int>::iterator’ {a
							      								    								  ka ‘std::_Rb_tree_const_iterator<int>’} is not der
							      								    								  ived from ‘const std::istream_iterator<_Tp, _CharT
							      								    								  , _Traits, _Dist>’		if ( table . find (
							      								    								  k ) != table . end ( ) && table [ k ] . find ( j )
							      								    								   != table . end ( ) ) return true ;
							      								    								  
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/list:63,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:79,		   from FIND_RECTANG
							      								    								  LE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/
							      								    								  c++/8/bits/stl_list.h:350:5: note: candidate: ‘tem
							      								    								  plate<class _Val> bool std::operator!=(const std::
							      								    								  _List_iterator<_Tp>&, const std::_List_const_itera
							      								    								  tor<_Tp>&)’	   operator!=(const _List_iterator<_
							      								    								  Val>& __x,	  ^~~~~~~~ /usr/include/c++/8/bits/s
							      								    								  tl_list.h:350:5: note:   template argument deducti
							      								    								  on/substitution failed: FIND_RECTANGLE_BINARY_MATR
							      								    								  IX_CORNERS_1_1.cpp:57:99: note:   ‘std::set<int>::
							      								    								  iterator’ {aka ‘std::_Rb_tree_const_iterator<int>’
							      								    								  } is not derived from ‘const std::_List_iterator<_
							      								    								  Tp>’		  if ( table . find ( k ) != table .
							      								    								   end ( ) && table [ k ] . find ( j ) != table . en
							      								    								  d ( ) ) return true ;
							      								    								  
							      								    								  		       ^ In file included from /usr/
							      								    								  include/c++/8/list:63,		  from /usr/
							      								    								  include/c++/8/x86_64-redhat-linux/bits/stdc++.h:79
							      								    								  ,		     from FIND_RECTANGLE_BINARY_MATR
							      								    								  IX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/stl
							      								    								  _list.h:2028:5: note: candidate: ‘template<class _
							      								    								  Tp, class _Alloc> bool std::operator!=(const std::
							      								    								  __cxx11::list<_Tp, _Alloc>&, const std::__cxx11::l
							      								    								  ist<_Tp, _Alloc>&)’	   operator!=(const list<_Tp
							      								    								  , _Alloc>& __x, const list<_Tp, _Alloc>& __y)
							      								    								   ^~~~~~~~ /usr/include/c++/8/bits/stl_list.h:2028:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1
							      								    								  .cpp:57:99: note:   ‘std::set<int>::iterator’ {aka
							      								    								   ‘std::_Rb_tree_const_iterator<int>’} is not deriv
							      								    								  ed from ‘const std::__cxx11::list<_Tp, _Alloc>’
							      								    								  	   if ( table . find ( k ) != table . end (
							      								    								  ) && table [ k ] . find ( j ) != table . end ( ) )
							      								    								   return true ;
							      								    								  
							      								    								  		^ In file included from /usr/include
							      								    								  /c++/8/map:60,		  from /usr/include/
							      								    								  c++/8/x86_64-redhat-linux/bits/stdc++.h:81,
							      								    								  	     from FIND_RECTANGLE_BINARY_MATRIX_CORNE
							      								    								  RS_1_1.cpp:14: /usr/include/c++/8/bits/stl_tree.h:
							      								    								  412:5: note: candidate: ‘template<class _Val> bool
							      								    								   std::operator!=(const std::_Rb_tree_iterator<_Tp>
							      								    								  &, const std::_Rb_tree_const_iterator<_Val>&)’
							      								    								    operator!=(const _Rb_tree_iterator<_Val>& __x,
							      								    								      ^~~~~~~~ /usr/include/c++/8/bits/stl_tree.h:41
							      								    								  2:5: note:   template argument deduction/substitut
							      								    								  ion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
							      								    								  _1.cpp:57:99: note:	‘std::set<int>::iterator’ {a
							      								    								  ka ‘std::_Rb_tree_const_iterator<int>’} is not der
							      								    								  ived from ‘const std::_Rb_tree_iterator<_Tp>’
							      								    								  	 if ( table . find ( k ) != table . end ( )
							      								    								  && table [ k ] . find ( j ) != table . end ( ) ) r
							      								    								  eturn true ;
							      								    								  
							      								    								  	      ^ In file included from /usr/include/c
							      								    								  ++/8/map:60,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:81,
							      								    								  	   from FIND_RECTANGLE_BINARY_MATRIX_CORNERS
							      								    								  _1_1.cpp:14: /usr/include/c++/8/bits/stl_tree.h:15
							      								    								  76:5: note: candidate: ‘template<class _Key, class
							      								    								   _Val, class _KeyOfValue, class _Compare, class _A
							      								    								  lloc> bool std::operator!=(const std::_Rb_tree<_Ke
							      								    								  y, _Val, _KeyOfValue, _Compare, _Alloc>&, const st
							      								    								  d::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Al
							      								    								  loc>&)’      operator!=(const _Rb_tree<_Key, _Val,
							      								    								   _KeyOfValue, _Compare, _Alloc>& __x,	     ^~~~~~~
							      								    								  ~ /usr/include/c++/8/bits/stl_tree.h:1576:5: note:
							      								    								     template argument deduction/substitution failed
							      								    								  : FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:
							      								    								  99: note:   ‘std::set<int>::iterator’ {aka ‘std::_
							      								    								  Rb_tree_const_iterator<int>’} is not derived from
							      								    								  ‘const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Com
							      								    								  pare, _Alloc>’	    if ( table . find ( k )
							      								    								  != table . end ( ) && table [ k ] . find ( j ) !=
							      								    								  table . end ( ) ) return true ;
							      								    								  
							      								    								  				 ^ In file included
							      								    								  from /usr/include/c++/8/map:61,		   f
							      								    								  rom /usr/include/c++/8/x86_64-redhat-linux/bits/st
							      								    								  dc++.h:81,		      from FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8
							      								    								  /bits/stl_map.h:1458:5: note: candidate: ‘template
							      								    								  <class _Key, class _Tp, class _Compare, class _All
							      								    								  oc> bool std::operator!=(const std::map<_Key, _Tp,
							      								    								   _Compare, _Alloc>&, const std::map<_Key, _Tp, _Co
							      								    								  mpare, _Alloc>&)’	 operator!=(const map<_Key,
							      								    								  _Tp, _Compare, _Alloc>& __x,	    ^~~~~~~~ /usr/in
							      								    								  clude/c++/8/bits/stl_map.h:1458:5: note:   templat
							      								    								  e argument deduction/substitution failed: FIND_REC
							      								    								  TANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								    ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_co
							      								    								  nst_iterator<int>’} is not derived from ‘const std
							      								    								  ::map<_Key, _Tp, _Compare, _Alloc>’		 if
							      								    								  ( table . find ( k ) != table . end ( ) && table [
							      								    								   k ] . find ( j ) != table . end ( ) ) return true
							      								    								   ;
							      								    								  
							      								    								    ^ In file included from /usr/include/c++/8/map:6
							      								    								  2,		      from /usr/include/c++/8/x86_64
							      								    								  -redhat-linux/bits/stdc++.h:81,		   f
							      								    								  rom FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:1
							      								    								  4: /usr/include/c++/8/bits/stl_multimap.h:1122:5:
							      								    								  note: candidate: ‘template<class _Key, class _Tp,
							      								    								  class _Compare, class _Alloc> bool std::operator!=
							      								    								  (const std::multimap<_Key, _Tp, _Compare, _Alloc>&
							      								    								  , const std::multimap<_Key, _Tp, _Compare, _Alloc>
							      								    								  &)’	   operator!=(const multimap<_Key, _Tp, _Com
							      								    								  pare, _Alloc>& __x,	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/stl_multimap.h:1122:5: note:	 template ar
							      								    								  gument deduction/substitution failed: FIND_RECTANG
							      								    								  LE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:	  ‘s
							      								    								  td::set<int>::iterator’ {aka ‘std::_Rb_tree_const_
							      								    								  iterator<int>’} is not derived from ‘const std::mu
							      								    								  ltimap<_Key, _Tp, _Compare, _Alloc>’		  if
							      								    								   ( table . find ( k ) != table . end ( ) && table
							      								    								  [ k ] . find ( j ) != table . end ( ) ) return tru
							      								    								  e ;
							      								    								  
							      								    								     ^ In file included from /usr/include/c++/8/bits
							      								    								  /shared_ptr.h:52,		     from /usr/inclu
							      								    								  de/c++/8/memory:81,		       from /usr/inc
							      								    								  lude/c++/8/x86_64-redhat-linux/bits/stdc++.h:82,
							      								    								  		  from FIND_RECTANGLE_BINARY_MATRIX_
							      								    								  CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/shared
							      								    								  _ptr_base.h:1426:5: note: candidate: ‘template<cla
							      								    								  ss _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp>
							      								    								  bool std::operator!=(const std::__shared_ptr<_Tp1,
							      								    								   _Lp>&, const std::__shared_ptr<_Tp2, _Lp>&)’
							      								    								   operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
							      								    								     ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr_bas
							      								    								  e.h:1426:5: note:   template argument deduction/su
							      								    								  bstitution failed: FIND_RECTANGLE_BINARY_MATRIX_CO
							      								    								  RNERS_1_1.cpp:57:99: note:   ‘std::set<int>::itera
							      								    								  tor’ {aka ‘std::_Rb_tree_const_iterator<int>’} is
							      								    								  not derived from ‘const std::__shared_ptr<_Tp1, _L
							      								    								  p>’		 if ( table . find ( k ) != table .
							      								    								  end ( ) && table [ k ] . find ( j ) != table . end
							      								    								   ( ) ) return true ;
							      								    								  
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/bits/shared_ptr.h:52,
							      								    								    from /usr/include/c++/8/memory:81,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:82,		   from FIND_RECTANG
							      								    								  LE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/
							      								    								  c++/8/bits/shared_ptr_base.h:1432:5: note: candida
							      								    								  te: ‘template<class _Tp, __gnu_cxx::_Lock_policy _
							      								    								  Lp> bool std::operator!=(const std::__shared_ptr<_
							      								    								  Tp, _Lp>&, std::nullptr_t)’	   operator!=(const
							      								    								  __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
							      								    								      ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr_ba
							      								    								  se.h:1432:5: note:   template argument deduction/s
							      								    								  ubstitution failed: FIND_RECTANGLE_BINARY_MATRIX_C
							      								    								  ORNERS_1_1.cpp:57:99: note:	‘std::set<int>::iter
							      								    								  ator’ {aka ‘std::_Rb_tree_const_iterator<int>’} is
							      								    								   not derived from ‘const std::__shared_ptr<_Tp, _L
							      								    								  p>’		 if ( table . find ( k ) != table .
							      								    								  end ( ) && table [ k ] . find ( j ) != table . end
							      								    								   ( ) ) return true ;
							      								    								  
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/bits/shared_ptr.h:52,
							      								    								    from /usr/include/c++/8/memory:81,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:82,		   from FIND_RECTANG
							      								    								  LE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/
							      								    								  c++/8/bits/shared_ptr_base.h:1437:5: note: candida
							      								    								  te: ‘template<class _Tp, __gnu_cxx::_Lock_policy _
							      								    								  Lp> bool std::operator!=(std::nullptr_t, const std
							      								    								  ::__shared_ptr<_Tp, _Lp>&)’	   operator!=(nullpt
							      								    								  r_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
							      								    								      ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr_ba
							      								    								  se.h:1437:5: note:   template argument deduction/s
							      								    								  ubstitution failed: FIND_RECTANGLE_BINARY_MATRIX_C
							      								    								  ORNERS_1_1.cpp:57:99: note:	‘std::unordered_map<
							      								    								  int, std::set<int> >::iterator’ {aka ‘std::__detai
							      								    								  l::_Node_iterator<std::pair<const int, std::set<in
							      								    								  t> >, false, false>’} is not derived from ‘const s
							      								    								  td::__shared_ptr<_Tp, _Lp>’		 if ( table
							      								    								  . find ( k ) != table . end ( ) && table [ k ] . f
							      								    								  ind ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/memory:81,
							      								    								  		 from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:82,		      from F
							      								    								  IND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /u
							      								    								  sr/include/c++/8/bits/shared_ptr.h:398:5: note: ca
							      								    								  ndidate: ‘template<class _Tp, class _Up> bool std:
							      								    								  :operator!=(const std::shared_ptr<_Tp>&, const std
							      								    								  ::shared_ptr<_Tp>&)’	    operator!=(const shared_
							      								    								  ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcep
							      								    								  t	 ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr
							      								    								  .h:398:5: note:   template argument deduction/subs
							      								    								  titution failed: FIND_RECTANGLE_BINARY_MATRIX_CORN
							      								    								  ERS_1_1.cpp:57:99: note:   ‘std::set<int>::iterato
							      								    								  r’ {aka ‘std::_Rb_tree_const_iterator<int>’} is no
							      								    								  t derived from ‘const std::shared_ptr<_Tp>’
							      								    								       if ( table . find ( k ) != table . end ( ) &&
							      								    								   table [ k ] . find ( j ) != table . end ( ) ) ret
							      								    								  urn true ;
							      								    								  
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/memory:81,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:82,
							      								    								  	    from FIND_RECTANGLE_BINARY_MATRIX_CORNER
							      								    								  S_1_1.cpp:14: /usr/include/c++/8/bits/shared_ptr.h
							      								    								  :403:5: note: candidate: ‘template<class _Tp> bool
							      								    								   std::operator!=(const std::shared_ptr<_Tp>&, std:
							      								    								  :nullptr_t)’	    operator!=(const shared_ptr<_Tp>
							      								    								  & __a, nullptr_t) noexcept	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/shared_ptr.h:403:5: note:   templat
							      								    								  e argument deduction/substitution failed: FIND_REC
							      								    								  TANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								    ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_co
							      								    								  nst_iterator<int>’} is not derived from ‘const std
							      								    								  ::shared_ptr<_Tp>’		if ( table . find (
							      								    								  k ) != table . end ( ) && table [ k ] . find ( j )
							      								    								   != table . end ( ) ) return true ;
							      								    								  
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/memory:81,
							      								    								  	from /usr/include/c++/8/x86_64-redhat-linux/
							      								    								  bits/stdc++.h:82,		     from FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/includ
							      								    								  e/c++/8/bits/shared_ptr.h:408:5: note: candidate:
							      								    								  ‘template<class _Tp> bool std::operator!=(std::nul
							      								    								  lptr_t, const std::shared_ptr<_Tp>&)’	     operato
							      								    								  r!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcep
							      								    								  t	 ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr
							      								    								  .h:408:5: note:   template argument deduction/subs
							      								    								  titution failed: FIND_RECTANGLE_BINARY_MATRIX_CORN
							      								    								  ERS_1_1.cpp:57:99: note:   ‘std::unordered_map<int
							      								    								  , std::set<int> >::iterator’ {aka ‘std::__detail::
							      								    								  _Node_iterator<std::pair<const int, std::set<int>
							      								    								  >, false, false>’} is not derived from ‘const std:
							      								    								  :shared_ptr<_Tp>’	       if ( table . find ( k
							      								    								   ) != table . end ( ) && table [ k ] . find ( j )
							      								    								  != table . end ( ) ) return true ;
							      								    								  
							      								    								  				    ^ In file includ
							      								    								  ed from /usr/include/c++/8/queue:64,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:86,		   from FIND_RECTANG
							      								    								  LE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/
							      								    								  c++/8/bits/stl_queue.h:354:5: note: candidate: ‘te
							      								    								  mplate<class _Tp, class _Seq> bool std::operator!=
							      								    								  (const std::queue<_Tp, _Seq>&, const std::queue<_T
							      								    								  p, _Seq>&)’	   operator!=(const queue<_Tp, _Seq>
							      								    								  & __x, const queue<_Tp, _Seq>& __y)	   ^~~~~~~~
							      								    								  /usr/include/c++/8/bits/stl_queue.h:354:5: note:
							      								    								   template argument deduction/substitution failed:
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99
							      								    								  : note:   ‘std::set<int>::iterator’ {aka ‘std::_Rb
							      								    								  _tree_const_iterator<int>’} is not derived from ‘c
							      								    								  onst std::queue<_Tp, _Seq>’		 if ( table
							      								    								  . find ( k ) != table . end ( ) && table [ k ] . f
							      								    								  ind ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/set:61,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:87,		   from FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/
							      								    								  include/c++/8/bits/stl_set.h:982:5: note: candidat
							      								    								  e: ‘template<class _Key, class _Compare, class _Al
							      								    								  loc> bool std::operator!=(const std::set<_Key, _Co
							      								    								  mpare, _Alloc>&, const std::set<_Key, _Compare, _A
							      								    								  lloc>&)’	operator!=(const set<_Key, _Compare,
							      								    								   _Alloc>& __x,      ^~~~~~~~ /usr/include/c++/8/bi
							      								    								  ts/stl_set.h:982:5: note:   template argument dedu
							      								    								  ction/substitution failed: FIND_RECTANGLE_BINARY_M
							      								    								  ATRIX_CORNERS_1_1.cpp:57:99: note:   ‘std::set<int
							      								    								  >::iterator’ {aka ‘std::_Rb_tree_const_iterator<in
							      								    								  t>’} is not derived from ‘const std::set<_Key, _Co
							      								    								  mpare, _Alloc>’	     if ( table . find ( k )
							      								    								   != table . end ( ) && table [ k ] . find ( j ) !=
							      								    								   table . end ( ) ) return true ;
							      								    								  
							      								    								  				  ^ In file included
							      								    								   from /usr/include/c++/8/set:62,
							      								    								  from /usr/include/c++/8/x86_64-redhat-linux/bits/s
							      								    								  tdc++.h:87,		       from FIND_RECTANGLE_B
							      								    								  INARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/
							      								    								  8/bits/stl_multiset.h:967:5: note: candidate: ‘tem
							      								    								  plate<class _Key, class _Compare, class _Alloc> bo
							      								    								  ol std::operator!=(const std::multiset<_Key, _Comp
							      								    								  are, _Alloc>&, const std::multiset<_Key, _Compare,
							      								    								   _Alloc>&)’	   operator!=(const multiset<_Key, _
							      								    								  Compare, _Alloc>& __x,      ^~~~~~~~ /usr/include/
							      								    								  c++/8/bits/stl_multiset.h:967:5: note:   template
							      								    								  argument deduction/substitution failed: FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								  ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_cons
							      								    								  t_iterator<int>’} is not derived from ‘const std::
							      								    								  multiset<_Key, _Compare, _Alloc>’	       if (
							      								    								  table . find ( k ) != table . end ( ) && table [ k
							      								    								   ] . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  
							      								    								  ^ In file included from /usr/include/c++/8/stack:6
							      								    								  1,		      from /usr/include/c++/8/x86_64
							      								    								  -redhat-linux/bits/stdc++.h:89,		   f
							      								    								  rom FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:1
							      								    								  4: /usr/include/c++/8/bits/stl_stack.h:329:5: note
							      								    								  : candidate: ‘template<class _Tp, class _Seq> bool
							      								    								   std::operator!=(const std::stack<_Tp, _Seq>&, con
							      								    								  st std::stack<_Tp, _Seq>&)’	   operator!=(const
							      								    								  stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y
							      								    								  )	 ^~~~~~~~ /usr/include/c++/8/bits/stl_stack.
							      								    								  h:329:5: note:   template argument deduction/subst
							      								    								  itution failed: FIND_RECTANGLE_BINARY_MATRIX_CORNE
							      								    								  RS_1_1.cpp:57:99: note:   ‘std::set<int>::iterator
							      								    								  ’ {aka ‘std::_Rb_tree_const_iterator<int>’} is not
							      								    								   derived from ‘const std::stack<_Tp, _Seq>’
							      								    								       if ( table . find ( k ) != table . end ( ) &&
							      								    								   table [ k ] . find ( j ) != table . end ( ) ) ret
							      								    								  urn true ;
							      								    								  
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/valarray:592,		    from /usr/includ
							      								    								  e/c++/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  	       from FIND_RECTANGLE_BINARY_MATRIX_COR
							      								    								  NERS_1_1.cpp:14: /usr/include/c++/8/bits/valarray_
							      								    								  after.h:415:5: note: candidate: ‘template<class _D
							      								    								  om1, class _Dom2> std::_Expr<std::_BinClos<std::__
							      								    								  not_equal_to, std::_Expr, std::_Expr, _Dom1, _Dom2
							      								    								  >, typename std::__fun<std::__not_equal_to, typena
							      								    								  me _Dom1::value_type>::result_type> std::operator!
							      								    								  =(const std::_Expr<_Dom1, typename _Dom1::value_ty
							      								    								  pe>&, const std::_Expr<_Dom2, typename _Dom2::valu
							      								    								  e_type>&)’	  _DEFINE_EXPR_BINARY_OPERATOR(!=, _
							      								    								  _not_equal_to)      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /
							      								    								  usr/include/c++/8/bits/valarray_after.h:415:5: not
							      								    								  e:   template argument deduction/substitution fail
							      								    								  ed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:5
							      								    								  7:99: note:	‘std::set<int>::iterator’ {aka ‘std:
							      								    								  :_Rb_tree_const_iterator<int>’} is not derived fro
							      								    								  m ‘const std::_Expr<_Dom1, typename _Dom1::value_t
							      								    								  ype>’		   if ( table . find ( k ) != table
							      								    								  . end ( ) && table [ k ] . find ( j ) != table . e
							      								    								  nd ( ) ) return true ;
							      								    								  
							      								    								  			^ In file included from /usr
							      								    								  /include/c++/8/valarray:592,			from
							      								    								   /usr/include/c++/8/x86_64-redhat-linux/bits/stdc+
							      								    								  +.h:95,		   from FIND_RECTANGLE_BINAR
							      								    								  Y_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bi
							      								    								  ts/valarray_after.h:415:5: note: candidate: ‘templ
							      								    								  ate<class _Dom> std::_Expr<std::_BinClos<std::__no
							      								    								  t_equal_to, std::_Expr, std::_Constant, _Dom, type
							      								    								  name _Dom::value_type>, typename std::__fun<std::_
							      								    								  _not_equal_to, typename _Dom1::value_type>::result
							      								    								  _type> std::operator!=(const std::_Expr<_Dom1, typ
							      								    								  ename _Dom1::value_type>&, const typename _Dom::va
							      								    								  lue_type&)’	   _DEFINE_EXPR_BINARY_OPERATOR(!=,
							      								    								  __not_equal_to)      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
							      								    								  /usr/include/c++/8/bits/valarray_after.h:415:5: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:
							      								    								  57:99: note:	 ‘std::set<int>::iterator’ {aka ‘std
							      								    								  ::_Rb_tree_const_iterator<int>’} is not derived fr
							      								    								  om ‘const std::_Expr<_Dom1, typename _Dom1::value_
							      								    								  type>’	    if ( table . find ( k ) != table
							      								    								   . end ( ) && table [ k ] . find ( j ) != table .
							      								    								  end ( ) ) return true ;
							      								    								  
							      								    								  			 ^ In file included from /us
							      								    								  r/include/c++/8/valarray:592,			 fro
							      								    								  m /usr/include/c++/8/x86_64-redhat-linux/bits/stdc
							      								    								  ++.h:95,		    from FIND_RECTANGLE_BINA
							      								    								  RY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/b
							      								    								  its/valarray_after.h:415:5: note: candidate: ‘temp
							      								    								  late<class _Dom> std::_Expr<std::_BinClos<std::__n
							      								    								  ot_equal_to, std::_Constant, std::_Expr, typename
							      								    								  _Dom::value_type, _Dom>, typename std::__fun<std::
							      								    								  __not_equal_to, typename _Dom1::value_type>::resul
							      								    								  t_type> std::operator!=(const typename _Dom::value
							      								    								  _type&, const std::_Expr<_Dom1, typename _Dom1::va
							      								    								  lue_type>&)’	    _DEFINE_EXPR_BINARY_OPERATOR(!=,
							      								    								   __not_equal_to)	^~~~~~~~~~~~~~~~~~~~~~~~~~~~
							      								    								   /usr/include/c++/8/bits/valarray_after.h:415:5: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp
							      								    								  :57:99: note:	  ‘std::unordered_map<int, std::set<
							      								    								  int> >::iterator’ {aka ‘std::__detail::_Node_itera
							      								    								  tor<std::pair<const int, std::set<int> >, false, f
							      								    								  alse>’} is not derived from ‘const std::_Expr<_Dom
							      								    								  1, typename _Dom1::value_type>’	     if ( ta
							      								    								  ble . find ( k ) != table . end ( ) && table [ k ]
							      								    								   . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						  ^
							      								    								  In file included from /usr/include/c++/8/valarray:
							      								    								  592,			from /usr/include/c++/8/x86_
							      								    								  64-redhat-linux/bits/stdc++.h:95,
							      								    								   from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp
							      								    								  :14: /usr/include/c++/8/bits/valarray_after.h:415:
							      								    								  5: note: candidate: ‘template<class _Dom> std::_Ex
							      								    								  pr<std::_BinClos<std::__not_equal_to, std::_Expr,
							      								    								  std::_ValArray, _Dom, typename _Dom::value_type>,
							      								    								  typename std::__fun<std::__not_equal_to, typename
							      								    								  _Dom1::value_type>::result_type> std::operator!=(c
							      								    								  onst std::_Expr<_Dom1, typename _Dom1::value_type>
							      								    								  &, const std::valarray<typename _Dom::value_type>&
							      								    								  )’	  _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_equ
							      								    								  al_to)      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/valarray_after.h:415:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: no
							      								    								  te:	‘std::set<int>::iterator’ {aka ‘std::_Rb_tre
							      								    								  e_const_iterator<int>’} is not derived from ‘const
							      								    								   std::_Expr<_Dom1, typename _Dom1::value_type>’
							      								    								  	   if ( table . find ( k ) != table . end (
							      								    								  ) && table [ k ] . find ( j ) != table . end ( ) )
							      								    								   return true ;
							      								    								  
							      								    								  		^ In file included from /usr/include
							      								    								  /c++/8/valarray:592,			from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  		   from FIND_RECTANGLE_BINARY_MATRIX
							      								    								  _CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/valar
							      								    								  ray_after.h:415:5: note: candidate: ‘template<clas
							      								    								  s _Dom> std::_Expr<std::_BinClos<std::__not_equal_
							      								    								  to, std::_ValArray, std::_Expr, typename _Dom::val
							      								    								  ue_type, _Dom>, typename std::__fun<std::__not_equ
							      								    								  al_to, typename _Dom1::value_type>::result_type> s
							      								    								  td::operator!=(const std::valarray<typename _Dom::
							      								    								  value_type>&, const std::_Expr<_Dom1, typename _Do
							      								    								  m1::value_type>&)’	  _DEFINE_EXPR_BINARY_OPERAT
							      								    								  OR(!=, __not_equal_to)      ^~~~~~~~~~~~~~~~~~~~~~
							      								    								  ~~~~~~ /usr/include/c++/8/bits/valarray_after.h:41
							      								    								  5:5: note:   template argument deduction/substitut
							      								    								  ion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
							      								    								  _1.cpp:57:99: note:	‘std::unordered_map<int, std
							      								    								  ::set<int> >::iterator’ {aka ‘std::__detail::_Node
							      								    								  _iterator<std::pair<const int, std::set<int> >, fa
							      								    								  lse, false>’} is not derived from ‘const std::_Exp
							      								    								  r<_Dom1, typename _Dom1::value_type>’		   i
							      								    								  f ( table . find ( k ) != table . end ( ) && table
							      								    								   [ k ] . find ( j ) != table . end ( ) ) return tr
							      								    								  ue ;
							      								    								  
							      								    								      ^ In file included from /usr/include/c++/8/x86
							      								    								  _64-redhat-linux/bits/stdc++.h:95,
							      								    								    from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:14: /usr/include/c++/8/valarray:1185:1: note: ca
							      								    								  ndidate: ‘template<class _Tp> std::_Expr<std::_Bin
							      								    								  Clos<std::__not_equal_to, std::_ValArray, std::_Va
							      								    								  lArray, _Tp, _Tp>, typename std::__fun<std::__not_
							      								    								  equal_to, _Tp>::result_type> std::operator!=(const
							      								    								   std::valarray<_Tp>&, const std::valarray<_Tp>&)’
							      								    								   _DEFINE_BINARY_OPERATOR(!=, __not_equal_to)	^~~~
							      								    								  ~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/valarray:11
							      								    								  85:1: note:	template argument deduction/substitu
							      								    								  tion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_
							      								    								  1_1.cpp:57:99: note:	 ‘std::set<int>::iterator’ {
							      								    								  aka ‘std::_Rb_tree_const_iterator<int>’} is not de
							      								    								  rived from ‘const std::valarray<_Tp>’		   i
							      								    								  f ( table . find ( k ) != table . end ( ) && table
							      								    								   [ k ] . find ( j ) != table . end ( ) ) return tr
							      								    								  ue ;
							      								    								  
							      								    								      ^ In file included from /usr/include/c++/8/x86
							      								    								  _64-redhat-linux/bits/stdc++.h:95,
							      								    								    from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:14: /usr/include/c++/8/valarray:1185:1: note: ca
							      								    								  ndidate: ‘template<class _Tp> std::_Expr<std::_Bin
							      								    								  Clos<std::__not_equal_to, std::_ValArray, std::_Co
							      								    								  nstant, _Tp, _Tp>, typename std::__fun<std::__not_
							      								    								  equal_to, _Tp>::result_type> std::operator!=(const
							      								    								   std::valarray<_Tp>&, const _Tp&)’  _DEFINE_BINARY
							      								    								  _OPERATOR(!=, __not_equal_to)	 ^~~~~~~~~~~~~~~~~~~
							      								    								  ~~~~ /usr/include/c++/8/valarray:1185:1: note:   t
							      								    								  emplate argument deduction/substitution failed: FI
							      								    								  ND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99:
							      								    								  note:	  ‘std::set<int>::iterator’ {aka ‘std::_Rb_t
							      								    								  ree_const_iterator<int>’} is not derived from ‘con
							      								    								  st std::valarray<_Tp>’	    if ( table . fin
							      								    								  d ( k ) != table . end ( ) && table [ k ] . find (
							      								    								   j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/x86_64-redhat-linu
							      								    								  x/bits/stdc++.h:95,		       from FIND_REC
							      								    								  TANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/incl
							      								    								  ude/c++/8/valarray:1185:1: note: candidate: ‘templ
							      								    								  ate<class _Tp> std::_Expr<std::_BinClos<std::__not
							      								    								  _equal_to, std::_Constant, std::_ValArray, _Tp, _T
							      								    								  p>, typename std::__fun<std::__not_equal_to, _Tp>:
							      								    								  :result_type> std::operator!=(const _Tp&, const st
							      								    								  d::valarray<_Tp>&)’  _DEFINE_BINARY_OPERATOR(!=, _
							      								    								  _not_equal_to)  ^~~~~~~~~~~~~~~~~~~~~~~ /usr/inclu
							      								    								  de/c++/8/valarray:1185:1: note:   template argumen
							      								    								  t deduction/substitution failed: FIND_RECTANGLE_BI
							      								    								  NARY_MATRIX_CORNERS_1_1.cpp:57:99: note:   ‘std::u
							      								    								  nordered_map<int, std::set<int> >::iterator’ {aka
							      								    								  ‘std::__detail::_Node_iterator<std::pair<const int
							      								    								  , std::set<int> >, false, false>’} is not derived
							      								    								  from ‘const std::valarray<_Tp>’	     if ( ta
							      								    								  ble . find ( k ) != table . end ( ) && table [ k ]
							      								    								   . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						  ^
							      								    								  In file included from /usr/include/c++/8/forward_l
							      								    								  ist:38,		   from /usr/include/c++/8/x
							      								    								  86_64-redhat-linux/bits/stdc++.h:104,
							      								    								       from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1
							      								    								  .cpp:14: /usr/include/c++/8/bits/forward_list.h:28
							      								    								  1:5: note: candidate: ‘template<class _Tp> bool st
							      								    								  d::operator!=(const std::_Fwd_list_iterator<_Tp>&,
							      								    								   const std::_Fwd_list_const_iterator<_Tp>&)’
							      								    								  operator!=(const _Fwd_list_iterator<_Tp>& __x,
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/forward_list.h:
							      								    								  281:5: note:	 template argument deduction/substit
							      								    								  ution failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS
							      								    								  _1_1.cpp:57:99: note:	  ‘std::set<int>::iterator’
							      								    								  {aka ‘std::_Rb_tree_const_iterator<int>’} is not d
							      								    								  erived from ‘const std::_Fwd_list_iterator<_Tp>’
							      								    								  	    if ( table . find ( k ) != table . end (
							      								    								   ) && table [ k ] . find ( j ) != table . end ( )
							      								    								  ) return true ;
							      								    								  
							      								    								  		 ^ In file included from /usr/includ
							      								    								  e/c++/8/forward_list:38,		    from /us
							      								    								  r/include/c++/8/x86_64-redhat-linux/bits/stdc++.h:
							      								    								  104,			from FIND_RECTANGLE_BINARY_M
							      								    								  ATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/
							      								    								  forward_list.h:1440:5: note: candidate: ‘template<
							      								    								  class _Tp, class _Alloc> bool std::operator!=(cons
							      								    								  t std::forward_list<_Tp, _Alloc>&, const std::forw
							      								    								  ard_list<_Tp, _Alloc>&)’	operator!=(const for
							      								    								  ward_list<_Tp, _Alloc>& __lx,	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/forward_list.h:1440:5: note:   t
							      								    								  emplate argument deduction/substitution failed: FI
							      								    								  ND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99:
							      								    								  note:	  ‘std::set<int>::iterator’ {aka ‘std::_Rb_t
							      								    								  ree_const_iterator<int>’} is not derived from ‘con
							      								    								  st std::forward_list<_Tp, _Alloc>’		if (
							      								    								   table . find ( k ) != table . end ( ) && table [
							      								    								  k ] . find ( j ) != table . end ( ) ) return true
							      								    								  ;
							      								    								  
							      								    								   ^ In file included from /usr/include/c++/8/future
							      								    								  :39,			from /usr/include/c++/8/x86_
							      								    								  64-redhat-linux/bits/stdc++.h:105,
							      								    								    from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:14: /usr/include/c++/8/thread:287:3: note: candi
							      								    								  date: ‘bool std::operator!=(std::thread::id, std::
							      								    								  thread::id)’	  operator!=(thread::id __x, thread:
							      								    								  :id __y) noexcept    ^~~~~~~~ /usr/include/c++/8/t
							      								    								  hread:287:3: note:   no known conversion for argum
							      								    								  ent 1 from ‘std::set<int>::iterator’ {aka ‘std::_R
							      								    								  b_tree_const_iterator<int>’} to ‘std::thread::id’
							      								    								  In file included from /usr/include/c++/8/random:49
							      								    								  ,		     from /usr/include/c++/8/x86_64-
							      								    								  redhat-linux/bits/stdc++.h:108,		   f
							      								    								  rom FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:1
							      								    								  4: /usr/include/c++/8/bits/random.h:397:5: note: c
							      								    								  andidate: ‘template<class _UIntType, _UIntType __a
							      								    								  , _UIntType __c, _UIntType __m> bool std::operator
							      								    								  !=(const std::linear_congruential_engine<_UIntType
							      								    								  , __a, __c, __m>&, const std::linear_congruential_
							      								    								  engine<_UIntType, __a, __c, __m>&)’	   operator!
							      								    								  =(const std::linear_congruential_engine<_UIntType,
							      								    								   __a,	     ^~~~~~~~ /usr/include/c++/8/bits/random
							      								    								  .h:397:5: note:   template argument deduction/subs
							      								    								  titution failed: FIND_RECTANGLE_BINARY_MATRIX_CORN
							      								    								  ERS_1_1.cpp:57:99: note:   ‘std::set<int>::iterato
							      								    								  r’ {aka ‘std::_Rb_tree_const_iterator<int>’} is no
							      								    								  t derived from ‘const std::linear_congruential_eng
							      								    								  ine<_UIntType, __a, __c, __m>’	    if ( tab
							      								    								  le . find ( k ) != table . end ( ) && table [ k ]
							      								    								  . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						 ^ I
							      								    								  n file included from /usr/include/c++/8/random:49,
							      								    								  		    from /usr/include/c++/8/x86_64-r
							      								    								  edhat-linux/bits/stdc++.h:108,		  fr
							      								    								  om FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14
							      								    								  : /usr/include/c++/8/bits/random.h:629:5: note: ca
							      								    								  ndidate: ‘template<class _UIntType, long unsigned
							      								    								  int __w, long unsigned int __n, long unsigned int
							      								    								  __m, long unsigned int __r, _UIntType __a, long un
							      								    								  signed int __u, _UIntType __d, long unsigned int _
							      								    								  _s, _UIntType __b, long unsigned int __t, _UIntTyp
							      								    								  e __c, long unsigned int __l, _UIntType __f> bool
							      								    								  std::operator!=(const std::mersenne_twister_engine
							      								    								  <_UIntType, __w, __n, __m, __r, __a, __u, __d, __s
							      								    								  , __b, __t, __c, __l, __f>&, const std::mersenne_t
							      								    								  wister_engine<_UIntType, __w, __n, __m, __r, __a,
							      								    								  __u, __d, __s, __b, __t, __c, __l, __f>&)’	  op
							      								    								  erator!=(const std::mersenne_twister_engine<_UIntT
							      								    								  ype, __w, __n, __m,	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/random.h:629:5: note:	  template argument
							      								    								  deduction/substitution failed: FIND_RECTANGLE_BINA
							      								    								  RY_MATRIX_CORNERS_1_1.cpp:57:99: note:   ‘std::set
							      								    								  <int>::iterator’ {aka ‘std::_Rb_tree_const_iterato
							      								    								  r<int>’} is not derived from ‘const std::mersenne_
							      								    								  twister_engine<_UIntType, __w, __n, __m, __r, __a,
							      								    								   __u, __d, __s, __b, __t, __c, __l, __f>’
							      								    								     if ( table . find ( k ) != table . end ( ) && t
							      								    								  able [ k ] . find ( j ) != table . end ( ) ) retur
							      								    								  n true ;
							      								    								  
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /random:49,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	   from FIND_RECTANGLE_BINARY_MATRIX_CORNERS
							      								    								  _1_1.cpp:14: /usr/include/c++/8/bits/random.h:825:
							      								    								  5: note: candidate: ‘template<class _UIntType, lon
							      								    								  g unsigned int __w, long unsigned int __s, long un
							      								    								  signed int __r> bool std::operator!=(const std::su
							      								    								  btract_with_carry_engine<_UIntType, __w, __s, __r>
							      								    								  &, const std::subtract_with_carry_engine<_UIntType
							      								    								  , __w, __s, __r>&)’	   operator!=(const std::sub
							      								    								  tract_with_carry_engine<_UIntType, __w,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/random.h:825:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:9
							      								    								  9: note:   ‘std::set<int>::iterator’ {aka ‘std::_R
							      								    								  b_tree_const_iterator<int>’} is not derived from ‘
							      								    								  const std::subtract_with_carry_engine<_UIntType, _
							      								    								  _w, __s, __r>’	    if ( table . find ( k )
							      								    								  != table . end ( ) && table [ k ] . find ( j ) !=
							      								    								  table . end ( ) ) return true ;
							      								    								  
							      								    								  				 ^ In file included
							      								    								  from /usr/include/c++/8/random:49,
							      								    								    from /usr/include/c++/8/x86_64-redhat-linux/bits
							      								    								  /stdc++.h:108,		  from FIND_RECTANGL
							      								    								  E_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c
							      								    								  ++/8/bits/random.h:1047:5: note: candidate: ‘templ
							      								    								  ate<class _RandomNumberEngine, long unsigned int _
							      								    								  _p, long unsigned int __r> bool std::operator!=(co
							      								    								  nst std::discard_block_engine<_RandomNumberEngine,
							      								    								   __p, __r>&, const std::discard_block_engine<_Rand
							      								    								  omNumberEngine, __p, __r>&)’	    operator!=(const
							      								    								   std::discard_block_engine<_RandomNumberEngine, __
							      								    								  p,	  ^~~~~~~~ /usr/include/c++/8/bits/random.h:
							      								    								  1047:5: note:	  template argument deduction/substi
							      								    								  tution failed: FIND_RECTANGLE_BINARY_MATRIX_CORNER
							      								    								  S_1_1.cpp:57:99: note:   ‘std::set<int>::iterator’
							      								    								   {aka ‘std::_Rb_tree_const_iterator<int>’} is not
							      								    								  derived from ‘const std::discard_block_engine<_Ran
							      								    								  domNumberEngine, __p, __r>’		 if ( table
							      								    								  . find ( k ) != table . end ( ) && table [ k ] . f
							      								    								  ind ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/random:49,
							      								    								  		 from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:108,		       from
							      								    								  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /
							      								    								  usr/include/c++/8/bits/random.h:1243:5: note: cand
							      								    								  idate: ‘template<class _RandomNumberEngine, long u
							      								    								  nsigned int __w, class _UIntType> bool std::operat
							      								    								  or!=(const std::independent_bits_engine<_RandomNum
							      								    								  berEngine, __w, _UIntType>&, const std::independen
							      								    								  t_bits_engine<_RandomNumberEngine, __w, _UIntType>
							      								    								  &)’	   operator!=(const std::independent_bits_en
							      								    								  gine<_RandomNumberEngine, __w,      ^~~~~~~~ /usr/
							      								    								  include/c++/8/bits/random.h:1243:5: note:   templa
							      								    								  te argument deduction/substitution failed: FIND_RE
							      								    								  CTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								     ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_c
							      								    								  onst_iterator<int>’} is not derived from ‘const st
							      								    								  d::independent_bits_engine<_RandomNumberEngine, __
							      								    								  w, _UIntType>’	    if ( table . find ( k )
							      								    								  != table . end ( ) && table [ k ] . find ( j ) !=
							      								    								  table . end ( ) ) return true ;
							      								    								  
							      								    								  				 ^ In file included
							      								    								  from /usr/include/c++/8/random:49,
							      								    								    from /usr/include/c++/8/x86_64-redhat-linux/bits
							      								    								  /stdc++.h:108,		  from FIND_RECTANGL
							      								    								  E_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c
							      								    								  ++/8/bits/random.h:1495:5: note: candidate: ‘templ
							      								    								  ate<class _RandomNumberEngine, long unsigned int _
							      								    								  _k> bool std::operator!=(const std::shuffle_order_
							      								    								  engine<_RandomNumberEngine, __k>&, const std::shuf
							      								    								  fle_order_engine<_RandomNumberEngine, __k>&)’
							      								    								   operator!=(const std::shuffle_order_engine<_Rando
							      								    								  mNumberEngine,      ^~~~~~~~ /usr/include/c++/8/bi
							      								    								  ts/random.h:1495:5: note:   template argument dedu
							      								    								  ction/substitution failed: FIND_RECTANGLE_BINARY_M
							      								    								  ATRIX_CORNERS_1_1.cpp:57:99: note:   ‘std::set<int
							      								    								  >::iterator’ {aka ‘std::_Rb_tree_const_iterator<in
							      								    								  t>’} is not derived from ‘const std::shuffle_order
							      								    								  _engine<_RandomNumberEngine, __k>’		if (
							      								    								   table . find ( k ) != table . end ( ) && table [
							      								    								  k ] . find ( j ) != table . end ( ) ) return true
							      								    								  ;
							      								    								  
							      								    								   ^ In file included from /usr/include/c++/8/random
							      								    								  :49,			from /usr/include/c++/8/x86_
							      								    								  64-redhat-linux/bits/stdc++.h:108,
							      								    								    from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:14: /usr/include/c++/8/bits/random.h:1660:5: not
							      								    								  e: candidate: ‘template<class _IntType> bool std::
							      								    								  operator!=(const std::uniform_int_distribution<_In
							      								    								  tType>&, const std::uniform_int_distribution<_IntT
							      								    								  ype>&)’      operator!=(const std::uniform_int_dis
							      								    								  tribution<_IntType>& __d1,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/random.h:1660:5: note:	  template a
							      								    								  rgument deduction/substitution failed: FIND_RECTAN
							      								    								  GLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:   ‘
							      								    								  std::set<int>::iterator’ {aka ‘std::_Rb_tree_const
							      								    								  _iterator<int>’} is not derived from ‘const std::u
							      								    								  niform_int_distribution<_IntType>’		if (
							      								    								   table . find ( k ) != table . end ( ) && table [
							      								    								  k ] . find ( j ) != table . end ( ) ) return true
							      								    								  ;
							      								    								  
							      								    								   ^ In file included from /usr/include/c++/8/random
							      								    								  :49,			from /usr/include/c++/8/x86_
							      								    								  64-redhat-linux/bits/stdc++.h:108,
							      								    								    from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cp
							      								    								  p:14: /usr/include/c++/8/bits/random.h:1874:5: not
							      								    								  e: candidate: ‘template<class _IntType> bool std::
							      								    								  operator!=(const std::uniform_real_distribution<_I
							      								    								  ntType>&, const std::uniform_real_distribution<_In
							      								    								  tType>&)’	 operator!=(const std::uniform_real_
							      								    								  distribution<_IntType>& __d1,	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/random.h:1874:5: note:   templat
							      								    								  e argument deduction/substitution failed: FIND_REC
							      								    								  TANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								    ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_co
							      								    								  nst_iterator<int>’} is not derived from ‘const std
							      								    								  ::uniform_real_distribution<_IntType>’
							      								    								  if ( table . find ( k ) != table . end ( ) && tabl
							      								    								  e [ k ] . find ( j ) != table . end ( ) ) return t
							      								    								  rue ;
							      								    								  
							      								    								       ^ In file included from /usr/include/c++/8/ra
							      								    								  ndom:49,		    from /usr/include/c++/8/
							      								    								  x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_
							      								    								  1.cpp:14: /usr/include/c++/8/bits/random.h:2128:5:
							      								    								   note: candidate: ‘template<class _RealType> bool
							      								    								  std::operator!=(const std::normal_distribution<_Re
							      								    								  alType>&, const std::normal_distribution<_RealType
							      								    								  >&)’	    operator!=(const std::normal_distributio
							      								    								  n<_RealType>& __d1,	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/random.h:2128:5: note:   template argument
							      								    								   deduction/substitution failed: FIND_RECTANGLE_BIN
							      								    								  ARY_MATRIX_CORNERS_1_1.cpp:57:99: note:   ‘std::se
							      								    								  t<int>::iterator’ {aka ‘std::_Rb_tree_const_iterat
							      								    								  or<int>’} is not derived from ‘const std::normal_d
							      								    								  istribution<_RealType>’	     if ( table . fi
							      								    								  nd ( k ) != table . end ( ) && table [ k ] . find
							      								    								  ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					  ^ In file
							      								    								  included from /usr/include/c++/8/random:49,
							      								    								  	     from /usr/include/c++/8/x86_64-redhat-l
							      								    								  inux/bits/stdc++.h:108,		   from FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/
							      								    								  include/c++/8/bits/random.h:2337:5: note: candidat
							      								    								  e: ‘template<class _RealType> bool std::operator!=
							      								    								  (const std::lognormal_distribution<_RealType>&, co
							      								    								  nst std::lognormal_distribution<_RealType>&)’
							      								    								   operator!=(const std::lognormal_distribution<_Rea
							      								    								  lType>& __d1,	     ^~~~~~~~ /usr/include/c++/8/bit
							      								    								  s/random.h:2337:5: note:   template argument deduc
							      								    								  tion/substitution failed: FIND_RECTANGLE_BINARY_MA
							      								    								  TRIX_CORNERS_1_1.cpp:57:99: note:   ‘std::set<int>
							      								    								  ::iterator’ {aka ‘std::_Rb_tree_const_iterator<int
							      								    								  >’} is not derived from ‘const std::lognormal_dist
							      								    								  ribution<_RealType>’		  if ( table . find
							      								    								  ( k ) != table . end ( ) && table [ k ] . find ( j
							      								    								   ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  				       ^ In file inc
							      								    								  luded from /usr/include/c++/8/random:49,
							      								    								  	  from /usr/include/c++/8/x86_64-redhat-linu
							      								    								  x/bits/stdc++.h:108,			from FIND_RE
							      								    								  CTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/inc
							      								    								  lude/c++/8/bits/random.h:2562:6: note: candidate:
							      								    								  ‘template<class _RealType> bool std::operator!=(co
							      								    								  nst std::gamma_distribution<_RealType>&, const std
							      								    								  ::gamma_distribution<_RealType>&)’	   operator!
							      								    								  =(const std::gamma_distribution<_RealType>& __d1,
							      								    								  	^~~~~~~~ /usr/include/c++/8/bits/random.h:25
							      								    								  62:6: note:	template argument deduction/substitu
							      								    								  tion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_
							      								    								  1_1.cpp:57:99: note:	 ‘std::set<int>::iterator’ {
							      								    								  aka ‘std::_Rb_tree_const_iterator<int>’} is not de
							      								    								  rived from ‘const std::gamma_distribution<_RealTyp
							      								    								  e>’		 if ( table . find ( k ) != table .
							      								    								  end ( ) && table [ k ] . find ( j ) != table . end
							      								    								   ( ) ) return true ;
							      								    								  
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/random:49,		   from /usr
							      								    								  /include/c++/8/x86_64-redhat-linux/bits/stdc++.h:1
							      								    								  08,		       from FIND_RECTANGLE_BINARY_MA
							      								    								  TRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/r
							      								    								  andom.h:2782:5: note: candidate: ‘template<class _
							      								    								  RealType> bool std::operator!=(const std::chi_squa
							      								    								  red_distribution<_RealType>&, const std::chi_squar
							      								    								  ed_distribution<_RealType>&)’	     operator!=(cons
							      								    								  t std::chi_squared_distribution<_RealType>& __d1,
							      								    								       ^~~~~~~~ /usr/include/c++/8/bits/random.h:278
							      								    								  2:5: note:   template argument deduction/substitut
							      								    								  ion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
							      								    								  _1.cpp:57:99: note:	‘std::set<int>::iterator’ {a
							      								    								  ka ‘std::_Rb_tree_const_iterator<int>’} is not der
							      								    								  ived from ‘const std::chi_squared_distribution<_Re
							      								    								  alType>’	      if ( table . find ( k ) != tab
							      								    								  le . end ( ) && table [ k ] . find ( j ) != table
							      								    								  . end ( ) ) return true ;
							      								    								  
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/random:49,			from
							      								    								   /usr/include/c++/8/x86_64-redhat-linux/bits/stdc+
							      								    								  +.h:108,		    from FIND_RECTANGLE_BINA
							      								    								  RY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/b
							      								    								  its/random.h:2954:5: note: candidate: ‘template<cl
							      								    								  ass _RealType> bool std::operator!=(const std::cau
							      								    								  chy_distribution<_RealType>&, const std::cauchy_di
							      								    								  stribution<_RealType>&)’	operator!=(const std
							      								    								  ::cauchy_distribution<_RealType>& __d1,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/random.h:2954:5: note:
							      								    								     template argument deduction/substitution failed
							      								    								  : FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:
							      								    								  99: note:   ‘std::set<int>::iterator’ {aka ‘std::_
							      								    								  Rb_tree_const_iterator<int>’} is not derived from
							      								    								  ‘const std::cauchy_distribution<_RealType>’
							      								    								       if ( table . find ( k ) != table . end ( ) &&
							      								    								   table [ k ] . find ( j ) != table . end ( ) ) ret
							      								    								  urn true ;
							      								    								  
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/random:49,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	     from FIND_RECTANGLE_BINARY_MATRIX_CORNE
							      								    								  RS_1_1.cpp:14: /usr/include/c++/8/bits/random.h:32
							      								    								  15:5: note: candidate: ‘template<class _RealType>
							      								    								  bool std::operator!=(const std::fisher_f_distribut
							      								    								  ion<_RealType>&, const std::fisher_f_distribution<
							      								    								  _RealType>&)’	     operator!=(const std::fisher_f_
							      								    								  distribution<_RealType>& __d1,      ^~~~~~~~ /usr/
							      								    								  include/c++/8/bits/random.h:3215:5: note:   templa
							      								    								  te argument deduction/substitution failed: FIND_RE
							      								    								  CTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								     ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_c
							      								    								  onst_iterator<int>’} is not derived from ‘const st
							      								    								  d::fisher_f_distribution<_RealType>’		  if
							      								    								   ( table . find ( k ) != table . end ( ) && table
							      								    								  [ k ] . find ( j ) != table . end ( ) ) return tru
							      								    								  e ;
							      								    								  
							      								    								     ^ In file included from /usr/include/c++/8/rand
							      								    								  om:49,		  from /usr/include/c++/8/x8
							      								    								  6_64-redhat-linux/bits/stdc++.h:108,
							      								    								      from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.
							      								    								  cpp:14: /usr/include/c++/8/bits/random.h:3433:5: n
							      								    								  ote: candidate: ‘template<class _RealType> bool st
							      								    								  d::operator!=(const std::student_t_distribution<_R
							      								    								  ealType>&, const std::student_t_distribution<_Real
							      								    								  Type>&)’	operator!=(const std::student_t_dist
							      								    								  ribution<_RealType>& __d1,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/random.h:3433:5: note:	  template a
							      								    								  rgument deduction/substitution failed: FIND_RECTAN
							      								    								  GLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:   ‘
							      								    								  std::set<int>::iterator’ {aka ‘std::_Rb_tree_const
							      								    								  _iterator<int>’} is not derived from ‘const std::s
							      								    								  tudent_t_distribution<_RealType>’	       if (
							      								    								  table . find ( k ) != table . end ( ) && table [ k
							      								    								   ] . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  
							      								    								  ^ In file included from /usr/include/c++/8/random:
							      								    								  49,		       from /usr/include/c++/8/x86_6
							      								    								  4-redhat-linux/bits/stdc++.h:108,
							      								    								   from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp
							      								    								  :14: /usr/include/c++/8/bits/random.h:3614:3: note
							      								    								  : candidate: ‘bool std::operator!=(const std::bern
							      								    								  oulli_distribution&, const std::bernoulli_distribu
							      								    								  tion&)’    operator!=(const std::bernoulli_distrib
							      								    								  ution& __d1,	  ^~~~~~~~ /usr/include/c++/8/bits/r
							      								    								  andom.h:3614:3: note:	  no known conversion for ar
							      								    								  gument 1 from ‘std::set<int>::iterator’ {aka ‘std:
							      								    								  :_Rb_tree_const_iterator<int>’} to ‘const std::ber
							      								    								  noulli_distribution&’ /usr/include/c++/8/bits/rand
							      								    								  om.h:3885:5: note: candidate: ‘template<class _Int
							      								    								  Type> bool std::operator!=(const std::binomial_dis
							      								    								  tribution<_IntType>&, const std::binomial_distribu
							      								    								  tion<_IntType>&)’	 operator!=(const std::binom
							      								    								  ial_distribution<_IntType>& __d1,	 ^~~~~~~~ /u
							      								    								  sr/include/c++/8/bits/random.h:3885:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: no
							      								    								  te:	‘std::set<int>::iterator’ {aka ‘std::_Rb_tre
							      								    								  e_const_iterator<int>’} is not derived from ‘const
							      								    								   std::binomial_distribution<_IntType>’
							      								    								  if ( table . find ( k ) != table . end ( ) && tabl
							      								    								  e [ k ] . find ( j ) != table . end ( ) ) return t
							      								    								  rue ;
							      								    								  
							      								    								       ^ In file included from /usr/include/c++/8/ra
							      								    								  ndom:49,		    from /usr/include/c++/8/
							      								    								  x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_
							      								    								  1.cpp:14: /usr/include/c++/8/bits/random.h:4059:5:
							      								    								   note: candidate: ‘template<class _IntType> bool s
							      								    								  td::operator!=(const std::geometric_distribution<_
							      								    								  IntType>&, const std::geometric_distribution<_IntT
							      								    								  ype>&)’      operator!=(const std::geometric_distr
							      								    								  ibution<_IntType>& __d1,	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/random.h:4059:5: note:	template arg
							      								    								  ument deduction/substitution failed: FIND_RECTANGL
							      								    								  E_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:	 ‘st
							      								    								  d::set<int>::iterator’ {aka ‘std::_Rb_tree_const_i
							      								    								  terator<int>’} is not derived from ‘const std::geo
							      								    								  metric_distribution<_IntType>’	    if ( tab
							      								    								  le . find ( k ) != table . end ( ) && table [ k ]
							      								    								  . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						 ^ I
							      								    								  n file included from /usr/include/c++/8/random:49,
							      								    								  		    from /usr/include/c++/8/x86_64-r
							      								    								  edhat-linux/bits/stdc++.h:108,		  fr
							      								    								  om FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14
							      								    								  : /usr/include/c++/8/bits/random.h:4309:5: note: c
							      								    								  andidate: ‘template<class _IntType> bool std::oper
							      								    								  ator!=(const std::negative_binomial_distribution<_
							      								    								  IntType>&, const std::negative_binomial_distributi
							      								    								  on<_IntType>&)’      operator!=(const std::negativ
							      								    								  e_binomial_distribution<_IntType>& __d1,	^~~~
							      								    								  ~~~~ /usr/include/c++/8/bits/random.h:4309:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57
							      								    								  :99: note:   ‘std::set<int>::iterator’ {aka ‘std::
							      								    								  _Rb_tree_const_iterator<int>’} is not derived from
							      								    								   ‘const std::negative_binomial_distribution<_IntTy
							      								    								  pe>’		  if ( table . find ( k ) != table .
							      								    								   end ( ) && table [ k ] . find ( j ) != table . en
							      								    								  d ( ) ) return true ;
							      								    								  
							      								    								  		       ^ In file included from /usr/
							      								    								  include/c++/8/random:49,		    from /us
							      								    								  r/include/c++/8/x86_64-redhat-linux/bits/stdc++.h:
							      								    								  108,			from FIND_RECTANGLE_BINARY_M
							      								    								  ATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/
							      								    								  random.h:4530:5: note: candidate: ‘template<class
							      								    								  _IntType> bool std::operator!=(const std::poisson_
							      								    								  distribution<_IntType>&, const std::poisson_distri
							      								    								  bution<_IntType>&)’	   operator!=(const std::poi
							      								    								  sson_distribution<_IntType>& __d1,	  ^~~~~~~~ /
							      								    								  usr/include/c++/8/bits/random.h:4530:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: FIN
							      								    								  D_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: n
							      								    								  ote:	 ‘std::set<int>::iterator’ {aka ‘std::_Rb_tr
							      								    								  ee_const_iterator<int>’} is not derived from ‘cons
							      								    								  t std::poisson_distribution<_IntType>’
							      								    								  if ( table . find ( k ) != table . end ( ) && tabl
							      								    								  e [ k ] . find ( j ) != table . end ( ) ) return t
							      								    								  rue ;
							      								    								  
							      								    								       ^ In file included from /usr/include/c++/8/ra
							      								    								  ndom:49,		    from /usr/include/c++/8/
							      								    								  x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_
							      								    								  1.cpp:14: /usr/include/c++/8/bits/random.h:4713:5:
							      								    								   note: candidate: ‘template<class _RealType> bool
							      								    								  std::operator!=(const std::exponential_distributio
							      								    								  n<_RealType>&, const std::exponential_distribution
							      								    								  <_RealType>&)’      operator!=(const std::exponent
							      								    								  ial_distribution<_RealType>& __d1,	  ^~~~~~~~ /
							      								    								  usr/include/c++/8/bits/random.h:4713:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: FIN
							      								    								  D_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: n
							      								    								  ote:	 ‘std::set<int>::iterator’ {aka ‘std::_Rb_tr
							      								    								  ee_const_iterator<int>’} is not derived from ‘cons
							      								    								  t std::exponential_distribution<_RealType>’
							      								    								       if ( table . find ( k ) != table . end ( ) &&
							      								    								   table [ k ] . find ( j ) != table . end ( ) ) ret
							      								    								  urn true ;
							      								    								  
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/random:49,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	     from FIND_RECTANGLE_BINARY_MATRIX_CORNE
							      								    								  RS_1_1.cpp:14: /usr/include/c++/8/bits/random.h:49
							      								    								  21:5: note: candidate: ‘template<class _RealType>
							      								    								  bool std::operator!=(const std::weibull_distributi
							      								    								  on<_RealType>&, const std::weibull_distribution<_R
							      								    								  ealType>&)’	   operator!=(const std::weibull_dis
							      								    								  tribution<_RealType>& __d1,	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/random.h:4921:5: note:   template
							      								    								  argument deduction/substitution failed: FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								  ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_cons
							      								    								  t_iterator<int>’} is not derived from ‘const std::
							      								    								  weibull_distribution<_RealType>’	      if ( t
							      								    								  able . find ( k ) != table . end ( ) && table [ k
							      								    								  ] . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						   ^
							      								    								   In file included from /usr/include/c++/8/random:4
							      								    								  9,		      from /usr/include/c++/8/x86_64
							      								    								  -redhat-linux/bits/stdc++.h:108,
							      								    								  from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:
							      								    								  14: /usr/include/c++/8/bits/random.h:5129:5: note:
							      								    								   candidate: ‘template<class _RealType> bool std::o
							      								    								  perator!=(const std::extreme_value_distribution<_R
							      								    								  ealType>&, const std::extreme_value_distribution<_
							      								    								  RealType>&)’	    operator!=(const std::extreme_va
							      								    								  lue_distribution<_RealType>& __d1,	  ^~~~~~~~ /
							      								    								  usr/include/c++/8/bits/random.h:5129:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: FIN
							      								    								  D_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: n
							      								    								  ote:	 ‘std::set<int>::iterator’ {aka ‘std::_Rb_tr
							      								    								  ee_const_iterator<int>’} is not derived from ‘cons
							      								    								  t std::extreme_value_distribution<_RealType>’
							      								    								  	 if ( table . find ( k ) != table . end ( )
							      								    								  && table [ k ] . find ( j ) != table . end ( ) ) r
							      								    								  eturn true ;
							      								    								  
							      								    								  	      ^ In file included from /usr/include/c
							      								    								  ++/8/random:49,		   from /usr/include
							      								    								  /c++/8/x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	       from FIND_RECTANGLE_BINARY_MATRIX_COR
							      								    								  NERS_1_1.cpp:14: /usr/include/c++/8/bits/random.h:
							      								    								  5394:5: note: candidate: ‘template<class _IntType>
							      								    								   bool std::operator!=(const std::discrete_distribu
							      								    								  tion<_IntType>&, const std::discrete_distribution<
							      								    								  _IntType>&)’	    operator!=(const std::discrete_d
							      								    								  istribution<_IntType>& __d1,	    ^~~~~~~~ /usr/in
							      								    								  clude/c++/8/bits/random.h:5394:5: note:   template
							      								    								   argument deduction/substitution failed: FIND_RECT
							      								    								  ANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_con
							      								    								  st_iterator<int>’} is not derived from ‘const std:
							      								    								  :discrete_distribution<_IntType>’	       if (
							      								    								  table . find ( k ) != table . end ( ) && table [ k
							      								    								   ] . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  
							      								    								  ^ In file included from /usr/include/c++/8/random:
							      								    								  49,		       from /usr/include/c++/8/x86_6
							      								    								  4-redhat-linux/bits/stdc++.h:108,
							      								    								   from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp
							      								    								  :14: /usr/include/c++/8/bits/random.h:5666:5: note
							      								    								  : candidate: ‘template<class _RealType> bool std::
							      								    								  operator!=(const std::piecewise_constant_distribut
							      								    								  ion<_RealType>&, const std::piecewise_constant_dis
							      								    								  tribution<_RealType>&)’      operator!=(const std:
							      								    								  :piecewise_constant_distribution<_RealType>& __d1,
							      								    								  	^~~~~~~~ /usr/include/c++/8/bits/random.h:56
							      								    								  66:5: note:	template argument deduction/substitu
							      								    								  tion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_
							      								    								  1_1.cpp:57:99: note:	 ‘std::set<int>::iterator’ {
							      								    								  aka ‘std::_Rb_tree_const_iterator<int>’} is not de
							      								    								  rived from ‘const std::piecewise_constant_distribu
							      								    								  tion<_RealType>’	      if ( table . find ( k
							      								    								  ) != table . end ( ) && table [ k ] . find ( j ) !
							      								    								  = table . end ( ) ) return true ;
							      								    								  
							      								    								  				   ^ In file include
							      								    								  d from /usr/include/c++/8/random:49,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:108,		    from FIND_RECTAN
							      								    								  GLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include
							      								    								  /c++/8/bits/random.h:5940:5: note: candidate: ‘tem
							      								    								  plate<class _RealType> bool std::operator!=(const
							      								    								  std::piecewise_linear_distribution<_RealType>&, co
							      								    								  nst std::piecewise_linear_distribution<_RealType>&
							      								    								  )’	  operator!=(const std::piecewise_linear_dis
							      								    								  tribution<_RealType>& __d1,	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/random.h:5940:5: note:   template
							      								    								  argument deduction/substitution failed: FIND_RECTA
							      								    								  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:
							      								    								  ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree_cons
							      								    								  t_iterator<int>’} is not derived from ‘const std::
							      								    								  piecewise_linear_distribution<_RealType>’
							      								    								     if ( table . find ( k ) != table . end ( ) && t
							      								    								  able [ k ] . find ( j ) != table . end ( ) ) retur
							      								    								  n true ;
							      								    								  
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /x86_64-redhat-linux/bits/stdc++.h:111,
							      								    								  	 from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
							      								    								  _1.cpp:14: /usr/include/c++/8/scoped_allocator:468
							      								    								  :5: note: candidate: ‘template<class _OutA1, class
							      								    								   _OutA2, class ... _InA> bool std::operator!=(cons
							      								    								  t std::scoped_allocator_adaptor<_OutA1, _InA ...>&
							      								    								  , const std::scoped_allocator_adaptor<_InnerHead,
							      								    								  _InnerTail ...>&)’	  operator!=(const scoped_al
							      								    								  locator_adaptor<_OutA1, _InA...>& __a,      ^~~~~~
							      								    								  ~~ /usr/include/c++/8/scoped_allocator:468:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57
							      								    								  :99: note:   ‘std::set<int>::iterator’ {aka ‘std::
							      								    								  _Rb_tree_const_iterator<int>’} is not derived from
							      								    								   ‘const std::scoped_allocator_adaptor<_OutA1, _InA
							      								    								   ...>’	    if ( table . find ( k ) != table
							      								    								   . end ( ) && table [ k ] . find ( j ) != table .
							      								    								  end ( ) ) return true ;
							      								    								  
							      								    								  			 ^ In file included from /us
							      								    								  r/include/c++/8/unordered_map:47,
							      								    								   from /usr/include/c++/8/x86_64-redhat-linux/bits/
							      								    								  stdc++.h:117,			 from FIND_RECTANGLE
							      								    								  _BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c+
							      								    								  +/8/bits/unordered_map.h:2063:5: note: candidate:
							      								    								  ‘template<class _Key, class _Tp, class _Hash, clas
							      								    								  s _Pred, class _Alloc> bool std::operator!=(const
							      								    								  std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc
							      								    								  >&, const std::unordered_map<_Key, _Tp, _Hash, _Pr
							      								    								  ed, _Alloc>&)’      operator!=(const unordered_map
							      								    								  <_Key, _Tp, _Hash, _Pred, _Alloc>& __x,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/unordered_map.h:2063:5
							      								    								  : note:   template argument deduction/substitution
							      								    								   failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.
							      								    								  cpp:57:99: note:   ‘std::set<int>::iterator’ {aka
							      								    								  ‘std::_Rb_tree_const_iterator<int>’} is not derive
							      								    								  d from ‘const std::unordered_map<_Key, _Tp, _Hash,
							      								    								   _Pred, _Alloc>’	      if ( table . find ( k
							      								    								  ) != table . end ( ) && table [ k ] . find ( j ) !
							      								    								  = table . end ( ) ) return true ;
							      								    								  
							      								    								  				   ^ In file include
							      								    								  d from /usr/include/c++/8/unordered_map:47,
							      								    								  	     from /usr/include/c++/8/x86_64-redhat-l
							      								    								  inux/bits/stdc++.h:117,		   from FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/
							      								    								  include/c++/8/bits/unordered_map.h:2075:5: note: c
							      								    								  andidate: ‘template<class _Key, class _Tp, class _
							      								    								  Hash, class _Pred, class _Alloc> bool std::operato
							      								    								  r!=(const std::unordered_multimap<_Key, _Tp, _Hash
							      								    								  , _Pred, _Alloc>&, const std::unordered_multimap<_
							      								    								  Key, _Tp, _Hash, _Pred, _Alloc>&)’	  operator!=
							      								    								  (const unordered_multimap<_Key, _Tp, _Hash, _Pred,
							      								    								   _Alloc>& __x,      ^~~~~~~~ /usr/include/c++/8/bi
							      								    								  ts/unordered_map.h:2075:5: note:   template argume
							      								    								  nt deduction/substitution failed: FIND_RECTANGLE_B
							      								    								  INARY_MATRIX_CORNERS_1_1.cpp:57:99: note:   ‘std::
							      								    								  set<int>::iterator’ {aka ‘std::_Rb_tree_const_iter
							      								    								  ator<int>’} is not derived from ‘const std::unorde
							      								    								  red_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
							      								    								  	  if ( table . find ( k ) != table . end ( )
							      								    								   && table [ k ] . find ( j ) != table . end ( ) )
							      								    								  return true ;
							      								    								  
							      								    								  	       ^ In file included from /usr/include/
							      								    								  c++/8/unordered_set:47,		   from /usr
							      								    								  /include/c++/8/x86_64-redhat-linux/bits/stdc++.h:1
							      								    								  18,		       from FIND_RECTANGLE_BINARY_MA
							      								    								  TRIX_CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/u
							      								    								  nordered_set.h:1675:5: note: candidate: ‘template<
							      								    								  class _Value, class _Hash, class _Pred, class _All
							      								    								  oc> bool std::operator!=(const std::unordered_set<
							      								    								  _Value, _Hash, _Pred, _Alloc>&, const std::unorder
							      								    								  ed_set<_Value, _Hash, _Pred, _Alloc>&)’      opera
							      								    								  tor!=(const unordered_set<_Value, _Hash, _Pred, _A
							      								    								  lloc>& __x,	   ^~~~~~~~ /usr/include/c++/8/bits/
							      								    								  unordered_set.h:1675:5: note:	  template argument
							      								    								  deduction/substitution failed: FIND_RECTANGLE_BINA
							      								    								  RY_MATRIX_CORNERS_1_1.cpp:57:99: note:   ‘std::set
							      								    								  <int>::iterator’ {aka ‘std::_Rb_tree_const_iterato
							      								    								  r<int>’} is not derived from ‘const std::unordered
							      								    								  _set<_Value, _Hash, _Pred, _Alloc>’		 if
							      								    								  ( table . find ( k ) != table . end ( ) && table [
							      								    								   k ] . find ( j ) != table . end ( ) ) return true
							      								    								   ;
							      								    								  
							      								    								    ^ In file included from /usr/include/c++/8/unord
							      								    								  ered_set:47,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:118,
							      								    								  	    from FIND_RECTANGLE_BINARY_MATRIX_CORNER
							      								    								  S_1_1.cpp:14: /usr/include/c++/8/bits/unordered_se
							      								    								  t.h:1687:5: note: candidate: ‘template<class _Valu
							      								    								  e, class _Hash, class _Pred, class _Alloc> bool st
							      								    								  d::operator!=(const std::unordered_multiset<_Value
							      								    								  , _Hash, _Pred, _Alloc>&, const std::unordered_mul
							      								    								  tiset<_Value, _Hash, _Pred, _Alloc>&)’      operat
							      								    								  or!=(const unordered_multiset<_Value, _Hash, _Pred
							      								    								  , _Alloc>& __x,      ^~~~~~~~ /usr/include/c++/8/b
							      								    								  its/unordered_set.h:1687:5: note:   template argum
							      								    								  ent deduction/substitution failed: FIND_RECTANGLE_
							      								    								  BINARY_MATRIX_CORNERS_1_1.cpp:57:99: note:   ‘std:
							      								    								  :set<int>::iterator’ {aka ‘std::_Rb_tree_const_ite
							      								    								  rator<int>’} is not derived from ‘const std::unord
							      								    								  ered_multiset<_Value, _Hash, _Pred, _Alloc>’
							      								    								  	if ( table . find ( k ) != table . end ( ) &
							      								    								  & table [ k ] . find ( j ) != table . end ( ) ) re
							      								    								  turn true ;
							      								    								  
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/bits/hashtable.h:35,		    from /us
							      								    								  r/include/c++/8/unordered_map:46,
							      								    								   from /usr/include/c++/8/x86_64-redhat-linux/bits/
							      								    								  stdc++.h:117,			 from FIND_RECTANGLE
							      								    								  _BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c+
							      								    								  +/8/bits/hashtable_policy.h:312:5: note: candidate
							      								    								  : ‘template<class _Value, bool _Cache_hash_code> b
							      								    								  ool std::__detail::operator!=(const std::__detail:
							      								    								  :_Node_iterator_base<_Value, _Cache_hash_code>&, c
							      								    								  onst std::__detail::_Node_iterator_base<_Value, _C
							      								    								  ache_hash_code>&)’	  operator!=(const _Node_ite
							      								    								  rator_base<_Value, _Cache_hash_code>& __x,	  ^~
							      								    								  ~~~~~~ /usr/include/c++/8/bits/hashtable_policy.h:
							      								    								  312:5: note:	 template argument deduction/substit
							      								    								  ution failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS
							      								    								  _1_1.cpp:57:99: note:	  ‘std::set<int>::iterator’
							      								    								  {aka ‘std::_Rb_tree_const_iterator<int>’} is not d
							      								    								  erived from ‘const std::__detail::_Node_iterator_b
							      								    								  ase<_Value, _Cache_hash_code>’	    if ( tab
							      								    								  le . find ( k ) != table . end ( ) && table [ k ]
							      								    								  . find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  						 ^ I
							      								    								  n file included from /usr/include/c++/8/bits/hasht
							      								    								  able.h:35,		      from /usr/include/c++/
							      								    								  8/unordered_map:46,		       from /usr/inc
							      								    								  lude/c++/8/x86_64-redhat-linux/bits/stdc++.h:117,
							      								    								  		   from FIND_RECTANGLE_BINARY_MATRIX
							      								    								  _CORNERS_1_1.cpp:14: /usr/include/c++/8/bits/hasht
							      								    								  able_policy.h:1647:5: note: candidate: ‘template<c
							      								    								  lass _Key, class _Value, class _ExtractKey, class
							      								    								  _H1, class _H2, class _Hash, bool __cache> bool st
							      								    								  d::__detail::operator!=(const std::__detail::_Loca
							      								    								  l_iterator_base<_Key, _Value, _ExtractKey, _H1, _H
							      								    								  2, _Hash, __cache>&, const std::__detail::_Local_i
							      								    								  terator_base<_Key, _Value, _ExtractKey, _H1, _H2,
							      								    								  _Hash, __cache>&)’	  operator!=(const _Local_it
							      								    								  erator_base<_Key, _Value, _ExtractKey,      ^~~~~~
							      								    								  ~~ /usr/include/c++/8/bits/hashtable_policy.h:1647
							      								    								  :5: note:   template argument deduction/substituti
							      								    								  on failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_
							      								    								  1.cpp:57:99: note:   ‘std::set<int>::iterator’ {ak
							      								    								  a ‘std::_Rb_tree_const_iterator<int>’} is not deri
							      								    								  ved from ‘const std::__detail::_Local_iterator_bas
							      								    								  e<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __ca
							      								    								  che>’		   if ( table . find ( k ) != table
							      								    								  . end ( ) && table [ k ] . find ( j ) != table . e
							      								    								  nd ( ) ) return true ;
							      								    								  
							      								    								  			^ In file included from /usr
							      								    								  /include/c++/8/bits/stl_algobase.h:67,
							      								    								  	from /usr/include/c++/8/bits/char_traits.h:3
							      								    								  9,		      from /usr/include/c++/8/ios:40
							      								    								  ,		     from /usr/include/c++/8/ostream
							      								    								  :38,			from /usr/include/c++/8/iost
							      								    								  ream:39,		    from FIND_RECTANGLE_BINA
							      								    								  RY_MATRIX_CORNERS_1_1.cpp:8: /usr/include/c++/8/bi
							      								    								  ts/stl_iterator.h:877:5: note: candidate: ‘templat
							      								    								  e<class _IteratorL, class _IteratorR, class _Conta
							      								    								  iner> bool __gnu_cxx::operator!=(const __gnu_cxx::
							      								    								  __normal_iterator<_IteratorL, _Container>&, const
							      								    								  __gnu_cxx::__normal_iterator<_IteratorR, _Containe
							      								    								  r>&)’	     operator!=(const __normal_iterator<_Ite
							      								    								  ratorL, _Container>& __lhs,	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/stl_iterator.h:877:5: note:	temp
							      								    								  late argument deduction/substitution failed: FIND_
							      								    								  RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:57:99: not
							      								    								  e:   ‘std::set<int>::iterator’ {aka ‘std::_Rb_tree
							      								    								  _const_iterator<int>’} is not derived from ‘const
							      								    								  __gnu_cxx::__normal_iterator<_IteratorL, _Containe
							      								    								  r>’		 if ( table . find ( k ) != table .
							      								    								  end ( ) && table [ k ] . find ( j ) != table . end
							      								    								   ( ) ) return true ;
							      								    								  
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/bits/stl_algobase.h:67,
							      								    								      from /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  		    from /usr/include/c++/8/ios:40,
							      								    								  		   from /usr/include/c++/8/ostream:3
							      								    								  8,		      from /usr/include/c++/8/iostre
							      								    								  am:39,		  from FIND_RECTANGLE_BINARY
							      								    								  _MATRIX_CORNERS_1_1.cpp:8: /usr/include/c++/8/bits
							      								    								  /stl_iterator.h:884:5: note: candidate: ‘template<
							      								    								  class _Iterator, class _Container> bool __gnu_cxx:
							      								    								  :operator!=(const __gnu_cxx::__normal_iterator<_It
							      								    								  erator, _Container>&, const __gnu_cxx::__normal_it
							      								    								  erator<_Iterator, _Container>&)’	operator!=(c
							      								    								  onst __normal_iterator<_Iterator, _Container>& __l
							      								    								  hs,	   ^~~~~~~~ /usr/include/c++/8/bits/stl_iter
							      								    								  ator.h:884:5: note:	template argument deduction/
							      								    								  substitution failed: FIND_RECTANGLE_BINARY_MATRIX_
							      								    								  CORNERS_1_1.cpp:57:99: note:	 ‘std::set<int>::ite
							      								    								  rator’ {aka ‘std::_Rb_tree_const_iterator<int>’} i
							      								    								  s not derived from ‘const __gnu_cxx::__normal_iter
							      								    								  ator<_Iterator, _Container>’		  if ( table
							      								    								   . find ( k ) != table . end ( ) && table [ k ] .
							      								    								  find ( j ) != table . end ( ) ) return true ;
							      								    								  
							      								    								  					       ^ In
							      								    								  file included from /usr/include/c++/8/x86_64-redha
							      								    								  t-linux/bits/c++allocator.h:33,		   f
							      								    								  rom /usr/include/c++/8/bits/allocator.h:46,
							      								    								  	     from /usr/include/c++/8/string:41,
							      								    								  	       from /usr/include/c++/8/bits/locale_c
							      								    								  lasses.h:40,			from /usr/include/c+
							      								    								  +/8/bits/ios_base.h:41,		   from /usr
							      								    								  /include/c++/8/ios:42,		  from /usr/
							      								    								  include/c++/8/ostream:38,		     from /u
							      								    								  sr/include/c++/8/iostream:39,			 fro
							      								    								  m FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:8:
							      								    								  /usr/include/c++/8/ext/new_allocator.h:160:5: note
							      								    								  : candidate: ‘template<class _Tp> bool __gnu_cxx::
							      								    								  operator!=(const __gnu_cxx::new_allocator<_Tp>&, c
							      								    								  onst __gnu_cxx::new_allocator<_Tp>&)’	     operato
							      								    								  r!=(const new_allocator<_Tp>&, const new_allocator
							      								    								  <_Tp>&)      ^~~~~~~~ /usr/include/c++/8/ext/new_a
							      								    								  llocator.h:160:5: note:   template argument deduct
							      								    								  ion/substitution failed: FIND_RECTANGLE_BINARY_MAT
							      								    								  RIX_CORNERS_1_1.cpp:57:99: note:   ‘std::set<int>:
							      								    								  :iterator’ {aka ‘std::_Rb_tree_const_iterator<int>
							      								    								  ’} is not derived from ‘const __gnu_cxx::new_alloc
							      								    								  ator<_Tp>’		if ( table . find ( k ) != t
							      								    								  able . end ( ) && table [ k ] . find ( j ) != tabl
							      								    								  e . end ( ) ) return true ;
							      								    								  
							      								    								  			     ^ FIND_RECTANGLE_BINARY
							      								    								  _MATRIX_CORNERS_1_1.cpp:58:16: error: no match for
							      								    								   ‘operator!’ (operand type is ‘std::unordered_map<
							      								    								  int, std::set<int> >::iterator’ {aka ‘std::__detai
							      								    								  l::_Node_iterator<std::pair<const int, std::set<in
							      								    								  t> >, false, false>’})	    if ( ! table . f
							      								    								  ind ( j ) != table . end ( ) ) {		   ^
							      								    								  ~~~~~~~~~~~~~~~~~~~ FIND_RECTANGLE_BINARY_MATRIX_C
							      								    								  ORNERS_1_1.cpp:58:16: note: candidate: ‘operator!(
							      								    								  bool)’ <built-in> FIND_RECTANGLE_BINARY_MATRIX_COR
							      								    								  NERS_1_1.cpp:58:16: note:   no known conversion fo
							      								    								  r argument 1 from ‘std::unordered_map<int, std::se
							      								    								  t<int> >::iterator’ {aka ‘std::__detail::_Node_ite
							      								    								  rator<std::pair<const int, std::set<int> >, false,
							      								    								   false>’} to ‘bool’ FIND_RECTANGLE_BINARY_MATRIX_C
							      								    								  ORNERS_1_1.cpp:61:38: error: no matching function
							      								    								  for call to ‘std::set<int>::insert(std::set<int>&)
							      								    								  ’		 table [ j ] . insert ( x ) ;
							      								    								  				  ^ In file included
							      								    								   from /usr/include/c++/8/set:61,
							      								    								  from /usr/include/c++/8/x86_64-redhat-linux/bits/s
							      								    								  tdc++.h:87,		       from FIND_RECTANGLE_B
							      								    								  INARY_MATRIX_CORNERS_1_1.cpp:14: /usr/include/c++/
							      								    								  8/bits/stl_set.h:509:7: note: candidate: ‘std::pai
							      								    								  r<typename std::_Rb_tree<_Key, _Key, std::_Identit
							      								    								  y<_Tp>, _Compare, typename __gnu_cxx::__alloc_trai
							      								    								  ts<_Alloc>::rebind<_Key>::other>::const_iterator,
							      								    								  bool> std::set<_Key, _Compare, _Alloc>::insert(con
							      								    								  st value_type&) [with _Key = int; _Compare = std::
							      								    								  less<int>; _Alloc = std::allocator<int>; typename
							      								    								  std::_Rb_tree<_Key, _Key, std::_Identity<_Tp>, _Co
							      								    								  mpare, typename __gnu_cxx::__alloc_traits<_Alloc>:
							      								    								  :rebind<_Key>::other>::const_iterator = std::_Rb_t
							      								    								  ree_const_iterator<int>; std::set<_Key, _Compare,
							      								    								  _Alloc>::value_type = int]’	     insert(const va
							      								    								  lue_type& __x)	^~~~~~ /usr/include/c++/8/bi
							      								    								  ts/stl_set.h:509:7: note:   no known conversion fo
							      								    								  r argument 1 from ‘std::set<int>’ to ‘const value_
							      								    								  type&’ {aka ‘const int&’} /usr/include/c++/8/bits/
							      								    								  stl_set.h:518:7: note: candidate: ‘std::pair<typen
							      								    								  ame std::_Rb_tree<_Key, _Key, std::_Identity<_Tp>,
							      								    								   _Compare, typename __gnu_cxx::__alloc_traits<_All
							      								    								  oc>::rebind<_Key>::other>::const_iterator, bool> s
							      								    								  td::set<_Key, _Compare, _Alloc>::insert(std::set<_
							      								    								  Key, _Compare, _Alloc>::value_type&&) [with _Key =
							      								    								   int; _Compare = std::less<int>; _Alloc = std::all
							      								    								  ocator<int>; typename std::_Rb_tree<_Key, _Key, st
							      								    								  d::_Identity<_Tp>, _Compare, typename __gnu_cxx::_
							      								    								  _alloc_traits<_Alloc>::rebind<_Key>::other>::const
							      								    								  _iterator = std::_Rb_tree_const_iterator<int>; std
							      								    								  ::set<_Key, _Compare, _Alloc>::value_type = int]’
							      								    								  	 insert(value_type&& __x)	 ^~~~~~ /usr
							      								    								  /include/c++/8/bits/stl_set.h:518:7: note:   no kn
							      								    								  own conversion for argument 1 from ‘std::set<int>’
							      								    								   to ‘std::set<int>::value_type&&’ {aka ‘int&&’} /u
							      								    								  sr/include/c++/8/bits/stl_set.h:546:7: note: candi
							      								    								  date: ‘std::set<_Key, _Compare, _Alloc>::iterator
							      								    								  std::set<_Key, _Compare, _Alloc>::insert(std::set<
							      								    								  _Key, _Compare, _Alloc>::const_iterator, const val
							      								    								  ue_type&) [with _Key = int; _Compare = std::less<i
							      								    								  nt>; _Alloc = std::allocator<int>; std::set<_Key,
							      								    								  _Compare, _Alloc>::iterator = std::_Rb_tree_const_
							      								    								  iterator<int>; std::set<_Key, _Compare, _Alloc>::c
							      								    								  onst_iterator = std::_Rb_tree_const_iterator<int>;
							      								    								   std::set<_Key, _Compare, _Alloc>::value_type = in
							      								    								  t]’	     insert(const_iterator __position, const
							      								    								   value_type& __x)	   ^~~~~~ /usr/include/c++/8
							      								    								  /bits/stl_set.h:546:7: note:	 candidate expects 2
							      								    								   arguments, 1 provided /usr/include/c++/8/bits/stl
							      								    								  _set.h:551:7: note: candidate: ‘std::set<_Key, _Co
							      								    								  mpare, _Alloc>::iterator std::set<_Key, _Compare,
							      								    								  _Alloc>::insert(std::set<_Key, _Compare, _Alloc>::
							      								    								  const_iterator, std::set<_Key, _Compare, _Alloc>::
							      								    								  value_type&&) [with _Key = int; _Compare = std::le
							      								    								  ss<int>; _Alloc = std::allocator<int>; std::set<_K
							      								    								  ey, _Compare, _Alloc>::iterator = std::_Rb_tree_co
							      								    								  nst_iterator<int>; std::set<_Key, _Compare, _Alloc
							      								    								  >::const_iterator = std::_Rb_tree_const_iterator<i
							      								    								  nt>; std::set<_Key, _Compare, _Alloc>::value_type
							      								    								  = int]’	 insert(const_iterator __position, v
							      								    								  alue_type&& __x)	  ^~~~~~ /usr/include/c++/8/
							      								    								  bits/stl_set.h:551:7: note:	candidate expects 2
							      								    								  arguments, 1 provided /usr/include/c++/8/bits/stl_
							      								    								  set.h:566:2: note: candidate: ‘template<class _Inp
							      								    								  utIterator> void std::set<_Key, _Compare, _Alloc>:
							      								    								  :insert(_InputIterator, _InputIterator) [with _Inp
							      								    								  utIterator = _InputIterator; _Key = int; _Compare
							      								    								  = std::less<int>; _Alloc = std::allocator<int>]’
							      								    								   insert(_InputIterator __first, _InputIterator __l
							      								    								  ast)	 ^~~~~~ /usr/include/c++/8/bits/stl_set.h:56
							      								    								  6:2: note:   template argument deduction/substitut
							      								    								  ion failed: FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
							      								    								  _1.cpp:61:38: note:	candidate expects 2 argument
							      								    								  s, 1 provided		     table [ j ] . insert (
							      								    								  x ) ;					      ^ In f
							      								    								  ile included from /usr/include/c++/8/set:61,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:87,		   from FIND
							      								    								  _RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:14: /usr/
							      								    								  include/c++/8/bits/stl_set.h:578:7: note: candidat
							      								    								  e: ‘void std::set<_Key, _Compare, _Alloc>::insert(
							      								    								  std::initializer_list<_Tp>) [with _Key = int; _Com
							      								    								  pare = std::less<int>; _Alloc = std::allocator<int
							      								    								  >]’	     insert(initializer_list<value_type> __l
							      								    								  )	   ^~~~~~ /usr/include/c++/8/bits/stl_set.h:
							      								    								  578:7: note:	 no known conversion for argument 1
							      								    								  from ‘std::set<int>’ to ‘std::initializer_list<int
							      								    								  >’ FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:64
							      								    								  :16: error: no match for ‘operator!’ (operand type
							      								    								   is ‘std::unordered_map<int, std::set<int> >::iter
							      								    								  ator’ {aka ‘std::__detail::_Node_iterator<std::pai
							      								    								  r<const int, std::set<int> >, false, false>’})
							      								    								  	  if ( ! table . find ( k ) != table . end (
							      								    								   ) ) {		 ^~~~~~~~~~~~~~~~~~~~ FIND_R
							      								    								  ECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:64:16: note
							      								    								  : candidate: ‘operator!(bool)’ <built-in> FIND_REC
							      								    								  TANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:64:16: note:
							      								    								    no known conversion for argument 1 from ‘std::un
							      								    								  ordered_map<int, std::set<int> >::iterator’ {aka ‘
							      								    								  std::__detail::_Node_iterator<std::pair<const int,
							      								    								   std::set<int> >, false, false>’} to ‘bool’ FIND_R
							      								    								  ECTANGLE_BINARY_MATRIX_CORNERS_1_1.cpp:67:38: erro
							      								    								  r: no matching function for call to ‘std::set<int>
							      								    								  ::insert(std::set<int>&)’		 table [ k ]
							      								    								   . insert ( x ) ;
							      								    								  	^ In file included from /usr/include/c++/8/s
							      								    								  et:61,		  from /usr/include/c++/8/x8
							      								    								  6_64-redhat-linux/bits/stdc++.h:87,
							      								    								     from FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.c
							      								    								  pp:14: /usr/include/c++/8/bits/stl_set.h:509:7: no
							      								    								  te: candidate: ‘std::pair<typename std::_Rb_tree<_
							      								    								  Key, _Key, std::_Identity<_Tp>, _Compare, typename
							      								    								   __gnu_cxx::__alloc_traits<_Alloc>::rebind<_Key>::
							      								    								  other>::const_iterator, bool> std::set<_Key, _Comp
							      								    								  are, _Alloc>::insert(const value_type&) [with _Key
							      								    								   = int; _Compare = std::less<int>; _Alloc = std::a
							      								    								  llocator<int>; typename std::_Rb_tree<_Key, _Key,
							      								    								  std::_Identity<_Tp>, _Compare, typename __gnu_cxx:
							      								    								  :__alloc_traits<_Alloc>::rebind<_Key>::other>::con
							      								    								  st_iterator = std::_Rb_tree_const_iterator<int>; s
							      								    								  td::set<_Key, _Compare, _Alloc>::value_type = int]
							      								    								  ’	   insert(const value_type& __x)	^~~~
							      								    								  ~~ /usr/include/c++/8/bits/stl_set.h:509:7: note:
							      								    								    no known conversion for argument 1 from ‘std::se
							      								    								  t<int>’ to ‘const value_type&’ {aka ‘const int&’}
							      								    								  /usr/include/c++/8/bits/stl_set.h:518:7: note: can
							      								    								  didate: ‘std::pair<typename std::_Rb_tree<_Key, _K
							      								    								  ey, std::_Identity<_Tp>, _Compare, typename __gnu_
							      								    								  cxx::__alloc_traits<_Alloc>::rebind<_Key>::other>:
							      								    								  :const_iterator, bool> std::set<_Key, _Compare, _A
							      								    								  lloc>::insert(std::set<_Key, _Compare, _Alloc>::va
							      								    								  lue_type&&) [with _Key = int; _Compare = std::less
							      								    								  <int>; _Alloc = std::allocator<int>; typename std:
							      								    								  :_Rb_tree<_Key, _Key, std::_Identity<_Tp>, _Compar
							      								    								  e, typename __gnu_cxx::__alloc_traits<_Alloc>::reb
							      								    								  ind<_Key>::other>::const_iterator = std::_Rb_tree_
							      								    								  const_iterator<int>; std::set<_Key, _Compare, _All
							      								    								  oc>::value_type = int]’	 insert(value_type&&
							      								    								   __x)	       ^~~~~~ /usr/include/c++/8/bits/stl_se
							      								    								  t.h:518:7: note:   no known conversion for argumen
							      								    								  t 1 from ‘std::set<int>’ to ‘std::set<int>::value_
							      								    								  type&&’ {aka ‘int&&’} /usr/include/c++/8/bits/stl_
							      								    								  set.h:546:7: note: candidate: ‘std::set<_Key, _Com
							      								    								  pare, _Alloc>::iterator std::set<_Key, _Compare, _
							      								    								  Alloc>::insert(std::set<_Key, _Compare, _Alloc>::c
							      								    								  onst_iterator, const value_type&) [with _Key = int
							      								    								  ; _Compare = std::less<int>; _Alloc = std::allocat
							      								    								  or<int>; std::set<_Key, _Compare, _Alloc>::iterato
							      								    								  r = std::_Rb_tree_const_iterator<int>; std::set<_K
							      								    								  ey, _Compare, _Alloc>::const_iterator = std::_Rb_t
							      								    								  ree_const_iterator<int>; std::set<_Key, _Compare,
							      								    								  _Alloc>::value_type = int]’	     insert(const_it
							      								    								  erator __position, const value_type& __x)	   ^
							      								    								  ~~~~~ /usr/include/c++/8/bits/stl_set.h:546:7: not
							      								    								  e:   candidate expects 2 arguments, 1 provided /us
							      								    								  r/include/c++/8/bits/stl_set.h:551:7: note: candid
							      								    								  ate: ‘std::set<_Key, _Compare, _Alloc>::iterator s
							      								    								  td::set<_Key, _Compare, _Alloc>::insert(std::set<_
							      								    								  Key, _Compare, _Alloc>::const_iterator, std::set<_
							      								    								  Key, _Compare, _Alloc>::value_type&&) [with _Key =
							      								    								   int; _Compare = std::less<int>; _Alloc = std::all
							      								    								  ocator<int>; std::set<_Key, _Compare, _Alloc>::ite
							      								    								  rator = std::_Rb_tree_const_iterator<int>; std::se
							      								    								  t<_Key, _Compare, _Alloc>::const_iterator = std::_
							      								    								  Rb_tree_const_iterator<int>; std::set<_Key, _Compa
							      								    								  re, _Alloc>::value_type = int]’	 insert(cons
							      								    								  t_iterator __position, value_type&& __x)	  ^~
							      								    								  ~~~~ /usr/include/c++/8/bits/stl_set.h:551:7: note
							      								    								  :   candidate expects 2 arguments, 1 provided /usr
							      								    								  /include/c++/8/bits/stl_set.h:566:2: note: candida
							      								    								  te: ‘template<class _InputIterator> void std::set<
							      								    								  _Key, _Compare, _Alloc>::insert(_InputIterator, _I
							      								    								  nputIterator) [with _InputIterator = _InputIterato
							      								    								  r; _Key = int; _Compare = std::less<int>; _Alloc =
							      								    								   std::allocator<int>]’   insert(_InputIterator __f
							      								    								  irst, _InputIterator __last)	 ^~~~~~ /usr/include
							      								    								  /c++/8/bits/stl_set.h:566:2: note:   template argu
							      								    								  ment deduction/substitution failed: FIND_RECTANGLE
							      								    								  _BINARY_MATRIX_CORNERS_1_1.cpp:67:38: note:	cand
							      								    								  idate expects 2 arguments, 1 provided
							      								    								   table [ k ] . insert ( x ) ;
							      								    								  		    ^ In file included from /usr/inc
							      								    								  lude/c++/8/set:61,		      from /usr/incl
							      								    								  ude/c++/8/x86_64-redhat-linux/bits/stdc++.h:87,
							      								    								  		 from FIND_RECTANGLE_BINARY_MATRIX_C
							      								    								  ORNERS_1_1.cpp:14: /usr/include/c++/8/bits/stl_set
							      								    								  .h:578:7: note: candidate: ‘void std::set<_Key, _C
							      								    								  ompare, _Alloc>::insert(std::initializer_list<_Tp>
							      								    								  ) [with _Key = int; _Compare = std::less<int>; _Al
							      								    								  loc = std::allocator<int>]’	     insert(initiali
							      								    								  zer_list<value_type> __l)	   ^~~~~~ /usr/inclu
							      								    								  de/c++/8/bits/stl_set.h:578:7: note:	 no known co
							      								    								  nversion for argument 1 from ‘std::set<int>’ to ‘s
							      								    								  td::initializer_list<int>’
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION		      WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION		    WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION			  WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION
--							      --							    --								  --
static void solveWordWrap ( int arr [ ] , int n , int k ) {   void solveWordWrap ( int arr [ ] , int n , int k ) {	    void solve_word_wrap ( int arr [ ] , int n , int k ) {	  script_not_found : None
  int i , j ;						      	int i , j ;						      int i , j ;						  
  int currlen ;						      	int currlen ;						      int currlen ;						  
  int cost ;						      	int cost ;						      int cost ;						  
  int dp [ ] = new int [ n ] ;				      	int dp [ n ] ;						      int dp [ n ] ;						  
  int ans [ ] = new int [ n ] ;				      	int ans [ n ] ;						      int ans [ n ] ;						  
  dp [ n - 1 ] = 0 ;					      	dp [ n - 1 ] = 0 ;					      dp [ n - 1 ] = 0 ;					  
  ans [ n - 1 ] = n - 1 ;				      	ans [ n - 1 ] = n - 1 ;					      ans [ n - 1 ] = n - 1 ;					  
  for ( i = n - 2 ;					      	for ( i = n - 2 ;					      for ( i = n - 2 ;						  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    currlen = - 1 ;					      	  currlen = - 1 ;					    	currlen = - 1 ;						  
    dp [ i ] = Integer . MAX_VALUE ;			      	  dp [ i ] = INT_MAX ;					    	dp [ i ] = INT_MAX ;					  
    for ( j = i ;					      	  for ( j = i ;						    	for ( j = i ;						  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      currlen += ( arr [ j ] + 1 ) ;			      	    currlen += ( arr [ j ] + 1 ) ;			    	  currlen += ( arr [ j ] + 1 ) ;			  
      if ( currlen > k ) break ;			      	    if ( currlen > k ) break ;				    	  if ( currlen > k ) break ;				  
      if ( j == n - 1 ) cost = 0 ;			      	    if ( j == n - 1 ) cost = 0 ;			    	  if ( j == n - 1 ) cost = 0 ;				  
      else cost = ( k - currlen ) * ( k - currlen ) + dp [ j  	    else cost = ( k - currlen ) * ( k - currlen ) + dp [ j  	  else cost = ( k - currlen ) * ( k - currlen ) + dp [ j  
      if ( cost < dp [ i ] ) {				      	    if ( cost < dp [ i ] ) {				    	  if ( cost < dp [ i ] ) {				  
	dp [ i ] = cost ;				      	      dp [ i ] = cost ;					    	    dp [ i ] = cost ;					  
	ans [ i ] = j ;					      	      ans [ i ] = j ;					    	    ans [ i ] = j ;					  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
  }							      	}							      }								  
  i = 0 ;						      	i = 0 ;							      i = 0 ;							  
  while ( i < n ) {					      	while ( i < n ) {					      while ( i < n ) {						  
    System . out . print ( ( i + 1 ) + " " + ( ans [ i ] + 1  	  cout << i + 1 << " " << ans [ i ] + 1 << " " ;	    	cout << ( i + 1 ) << " " << ( ans [ i ] + 1 ) << " " ;	  
    i = ans [ i ] + 1 ;					      	  i = ans [ i ] + 1 ;					    	i = ans [ i ] + 1 ;					  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX		      FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX			    FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX			  FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX
--							      --							    --								  --
static void KMP ( int m , int n , String str2 , String str1 ) void KMP ( int m , int n , string str2 , string str1 ) {	    void KMP ( int m , int n , string str2 , string str1 ) {	  script_not_found : None
  int pos = 0 , len = 0 ;				      	int pos = 0 , len = 0 ;					      int pos = 0 , len = 0 ;					  
  int [ ] p = new int [ m + 1 ] ;			      	int p [ m + 1 ] ;					      int p [ m + 1 ] ;						  
  int k = 0 ;						      	int k = 0 ;						      int k = 0 ;						  
  char [ ] ch1 = str1 . toCharArray ( ) ;		      	p [ 1 ] = 0 ;						      string ch1 = str1 ;					  
  char [ ] ch2 = str2 . toCharArray ( ) ;		      	for ( int i = 2 ;					      string ch2 = str2 ;					  
  for ( int i = 2 ;					      	i <= n ;						      for ( int i = 2 ;						  
  i <= n ;						      	i ++ ) {						      i <= n ;							  
  i ++ ) {						      	  while ( k > 0 && str1 [ k ] != str1 [ i - 1 ] ) k = p [ k   i ++ ) {							  
    while ( k > 0 && ch1 [ k ] != ch1 [ i - 1 ] ) k = p [ k ] 	  if ( str1 [ k ] == str1 [ i - 1 ] ) ++ k ;		    	while ( k > 0 && ch1 [ k ] != ch1 [ i - 1 ] ) {		  
    if ( ch1 [ k ] == ch1 [ i - 1 ] ) ++ k ;		      	  p [ i ] = k ;						    	  k = p [ k ] ;						  
    p [ i ] = k ;					      	}							    	}							  
  }							      	for ( int j = 0 , i = 0 ;				    	if ( ch1 [ k ] == ch1 [ i - 1 ] ) {			  
  for ( int j = 0 , i = 0 ;				      	i < m ;							    	  ++ k ;						  
  i < m ;						      	i ++ ) {						    	}							  
  i ++ ) {						      	  while ( j > 0 && str1 [ j ] != str2 [ i ] ) j = p [ j ] ; 	p [ i ] = k ;						  
    while ( j > 0 && j < n && ch1 [ j ] != ch2 [ i ] ) j = p  	  if ( str1 [ j ] == str2 [ i ] ) j ++ ;		      }								  
    if ( j < n && ch1 [ j ] == ch2 [ i ] ) j ++ ;	      	  if ( j > len ) {					      for ( int j = 0 , i = 0 ;					  
    if ( j > len ) {					      	    len = j ;						      i < m ;							  
      len = j ;						      	    pos = i - j + 1 ;					      i ++ ) {							  
      pos = i - j + 1 ;					      	  }							    	while ( j > 0 && j < n && ch1 [ j ] != ch2 [ i ] ) {	  
    }							      	}							    	  j = p [ j ] ;						  
  }							      	cout << "Shift = " << pos << endl ;			    	}							  
  System . out . println ( "Shift = " + pos ) ;		      	cout << "Prefix = " << str1 . substr ( 0 , len ) ;	    	if ( j < n && ch1 [ j ] == ch2 [ i ] ) {		  
  System . out . println ( "Prefix = " + str1 . substring ( 0 }								    	  j ++ ;						  
}							      								    	}							  
							      								    	if ( j > len ) {					  
							      								    	  len = j ;						  
							      								    	  pos = i - j + 1 ;					  
							      								    	}							  
							      								      }								  
							      								      cout << "Shift = " << pos << endl ;			  
							      								      cout << "Prefix = " << str1 . substr ( 0 , len ) << endl ;  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY		      MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY			    MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY			  MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY
--							      --							    --								  --
public static int minSwaps ( int [ ] arr ) {		      int minSwaps ( int arr [ ] , int n ) {			    int minSwaps ( vector < int > arr ) {			  script_not_found : None
  int n = arr . length ;				      	pair < int , int > arrPos [ n ] ;			      int n = arr . size ( ) ;					  
  ArrayList < Pair < Integer , Integer >> arrpos = new ArrayL 	for ( int i = 0 ;					      vector < pair < int , int >> arrpos ;			  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) {						      i < n ;							  
  i ++ ) arrpos . add ( new Pair < Integer , Integer > ( arr  	  arrPos [ i ] . first = arr [ i ] ;			      i ++ ) {							  
  arrpos . sort ( new Comparator < Pair < Integer , Integer > 	  arrPos [ i ] . second = i ;				    	arrpos . push_back ( make_pair ( arr [ i ] , i ) ) ;	  
    @ Override public int compare ( Pair < Integer , Integer  	}							      }								  
      if ( o1 . getKey ( ) > o2 . getKey ( ) ) return - 1 ;   	sort ( arrPos , arrPos + n ) ;				      sort ( arrpos . begin ( ) , arrpos . end ( ) , [ ] ( pair < 
      else if ( o1 . getKey ( ) . equals ( o2 . getKey ( ) )  	vector < bool > vis ( n , false ) ;			    	if ( o1 . first > o2 . first ) return - 1 ;		  
      else return 1 ;					      	int ans = 0 ;						    	else if ( o1 . first == o2 . first ) return 0 ;		  
    }							      	for ( int i = 0 ;					    	else return 1 ;						  
  }							      	i < n ;							      }								  
  ) ;							      	i ++ ) {						      ) ;							  
  Boolean [ ] vis = new Boolean [ n ] ;			      	  if ( vis [ i ] || arrPos [ i ] . second == i ) continue ;   vector < bool > vis ( n , false ) ;			  
  Arrays . fill ( vis , false ) ;			      	  int cycle_size = 0 ;					      int ans = 0 ;						  
  int ans = 0 ;						      	  int j = i ;						      for ( int i = 0 ;						  
  for ( int i = 0 ;					      	  while ( ! vis [ j ] ) {				      i < n ;							  
  i < n ;						      	    vis [ j ] = 1 ;					      i ++ ) {							  
  i ++ ) {						      	    j = arrPos [ j ] . second ;				    	if ( vis [ i ] || arrpos [ i ] . second == i ) continue ; 
    if ( vis [ i ] || arrpos . get ( i ) . getValue ( ) == i  	    cycle_size ++ ;					    	int cycle_size = 0 ;					  
    int cycle_size = 0 ;				      	  }							    	int j = i ;						  
    int j = i ;						      	  if ( cycle_size > 0 ) {				    	while ( ! vis [ j ] ) {					  
    while ( ! vis [ j ] ) {				      	    ans += ( cycle_size - 1 ) ;				    	  vis [ j ] = true ;					  
      vis [ j ] = true ;				      	  }							    	  j = arrpos [ j ] . second ;				  
      j = arrpos . get ( j ) . getValue ( ) ;		      	}							    	  cycle_size ++ ;					  
      cycle_size ++ ;					      	return ans ;						    	}							  
    }							      }								    	if ( cycle_size > 0 ) ans += ( cycle_size - 1 ) ;	  
    if ( cycle_size > 0 ) {				      								      }								  
      ans += ( cycle_size - 1 ) ;			      								      return ans ;						  
    }							      								    }								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE
--							      --							    --								  --
static void smallestSubsegment ( int a [ ] , int n ) {	      void smallestSubsegment ( int a [ ] , int n ) {		    void smallestSubsegment ( int a [ ] , int n ) {		  script_not_found : None
  HashMap < Integer , Integer > left = new HashMap < Integer  	unordered_map < int , int > left ;			      unordered_map < int , int > left ;			  
  HashMap < Integer , Integer > count = new HashMap < Integer 	unordered_map < int , int > count ;			      unordered_map < int , int > count ;			  
  int mx = 0 ;						      	int mx = 0 ;						      int mx = 0 ;						  
  int mn = - 1 , strindex = - 1 ;			      	int mn , strindex ;					      int mn = - 1 , strindex = - 1 ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int x = a [ i ] ;					      	  int x = a [ i ] ;					    	int x = a [ i ] ;					  
    if ( count . get ( x ) == null ) {			      	  if ( count [ x ] == 0 ) {				    	if ( count . find ( x ) == count . end ( ) ) {		  
      left . put ( x , i ) ;				      	    left [ x ] = i ;					    	  left [ x ] = i ;					  
      count . put ( x , 1 ) ;				      	    count [ x ] = 1 ;					    	  count [ x ] = 1 ;					  
    }							      	  }							    	}							  
    else count . put ( x , count . get ( x ) + 1 ) ;	      	  else count [ x ] ++ ;					    	else {							  
    if ( count . get ( x ) > mx ) {			      	  if ( count [ x ] > mx ) {				    	  count [ x ] = count [ x ] + 1 ;			  
      mx = count . get ( x ) ;				      	    mx = count [ x ] ;					    	}							  
      mn = i - left . get ( x ) + 1 ;			      	    mn = i - left [ x ] + 1 ;				    	if ( count [ x ] > mx ) {				  
      strindex = left . get ( x ) ;			      	    strindex = left [ x ] ;				    	  mx = count [ x ] ;					  
    }							      	  }							    	  mn = i - left [ x ] + 1 ;				  
    else if ( ( count . get ( x ) == mx ) && ( i - left . get 	  else if ( count [ x ] == mx && i - left [ x ] + 1 < mn )  	  strindex = left [ x ] ;				  
      mn = i - left . get ( x ) + 1 ;			      	    mn = i - left [ x ] + 1 ;				    	}							  
      strindex = left . get ( x ) ;			      	    strindex = left [ x ] ;				    	else if ( ( count [ x ] == mx ) && ( i - left [ x ] + 1 < 
    }							      	  }							    	  mn = i - left [ x ] + 1 ;				  
  }							      	}							    	  strindex = left [ x ] ;				  
  for ( int i = strindex ;				      	for ( int i = strindex ;				    	}							  
  i < strindex + mn ;					      	i < strindex + mn ;					      }								  
  i ++ ) System . out . print ( a [ i ] + " " ) ;	      	i ++ ) cout << a [ i ] << " " ;				      for ( int i = strindex ;					  
}							      }								      i < strindex + mn ;					  
							      								      i ++ ) {							  
							      								    	cout << a [ i ] << " " ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN
--							      --							    --								  --
static int find ( boolean arr [ ] [ ] ) {		      int find ( bool arr [ n ] [ n ] ) {			    int find ( bool arr [ ] [ n ] ) {				  script_not_found : None
  int i = 0 , j = n - 1 ;				      	int i = 0 , j = n - 1 ;					      int i = 0 , j = n - 1 ;					  
  int res = - 1 ;					      	int res = - 1 ;						      int res = - 1 ;						  
  while ( i < n && j >= 0 ) {				      	while ( i < n && j >= 0 ) {				      while ( i < n && j >= 0 ) {				  
    if ( arr [ i ] [ j ] == false ) {			      	  if ( arr [ i ] [ j ] == 0 ) {				    	if ( arr [ i ] [ j ] == false ) {			  
      while ( j >= 0 && ( arr [ i ] [ j ] == false || i == j  	    while ( j >= 0 && ( arr [ i ] [ j ] == 0 || i == j ) )  	  while ( j >= 0 && ( arr [ i ] [ j ] == false || i == j  
	j -- ;						      	    if ( j == - 1 ) {					    	  if ( j == - 1 ) {					  
      }							      	      res = i ;						    	    res = i ;						  
      if ( j == - 1 ) {					      	      break ;						    	    break ;						  
	res = i ;					      	    }							    	  }							  
	break ;						      	    else i ++ ;						    	  else i ++ ;						  
      }							      	  }							    	}							  
      else {						      	  else {						    	else {							  
	i ++ ;						      	    while ( i < n && ( arr [ i ] [ j ] == 1 || i == j ) ) i 	  while ( i < n && ( arr [ i ] [ j ] == true || i == j )  
      }							      	    if ( i == n ) {					    	  if ( i == n ) {					  
    }							      	      res = j ;						    	    res = j ;						  
    else {						      	      break ;						    	    break ;						  
      while ( i < n && ( arr [ i ] [ j ] == true || i == j )  	    }							    	  }							  
	i ++ ;						      	    else j -- ;						    	  else j -- ;						  
      }							      	  }							    	}							  
      if ( i == n ) {					      	}							      }								  
	res = j ;					      	if ( res == - 1 ) return res ;				      if ( res == - 1 ) return res ;				  
	break ;						      	for ( int i = 0 ;					      for ( int k = 0 ;						  
      }							      	i < n ;							      k < n ;							  
      else {						      	i ++ ) if ( res != i && arr [ i ] [ res ] != 1 ) return - 1   k ++ ) {							  
	j -- ;						      	for ( int j = 0 ;					    	if ( res != k && arr [ k ] [ res ] != true ) return - 1 ; 
      }							      	j < n ;							      }								  
    }							      	j ++ ) if ( res != j && arr [ res ] [ j ] != 0 ) return - 1   for ( int l = 0 ;						  
  }							      	return res ;						      l < n ;							  
  if ( res == - 1 ) {					      }								      l ++ ) {							  
    return res ;					      								    	if ( res != l && arr [ res ] [ l ] != false ) return - 1  
  }							      								      }								  
  for ( int k = 0 ;					      								      return res ;						  
  k < n ;						      								    }								  
  k ++ ) {						      								    								  
    if ( res != k && arr [ k ] [ res ] != true ) {	      								    								  
      return - 1 ;					      								    								  
    }							      								    								  
  }							      								    								  
  for ( int l = 0 ;					      								    								  
  l < n ;						      								    								  
  l ++ ) {						      								    								  
    if ( res != l && arr [ res ] [ l ] != false ) {	      								    								  
      return - 1 ;					      								    								  
    }							      								    								  
  }							      								    								  
  return res ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM			      MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM			    MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM			  MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM
--							      --							    --								  --
static int maxAlternateSum ( int arr [ ] , int n ) {	      int maxAlternateSum ( int arr [ ] , int n ) {		    int maxAlternateSum ( int arr [ ] , int n ) {		  failure : #Results: 4, 10
  if ( n == 1 ) return arr [ 0 ] ;			      	if ( n == 1 ) return arr [ 0 ] ;			      if ( n == 1 ) return arr [ 0 ] ;				  
  int dec [ ] = new int [ n ] ;				      	int dec [ n ] ;						      int dec [ n ] ;						  
  int inc [ ] = new int [ n ] ;				      	memset ( dec , 0 , sizeof ( dec ) ) ;			      int inc [ n ] ;						  
  dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ;			      	int inc [ n ] ;						      dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ;			  
  int flag = 0 ;					      	memset ( inc , 0 , sizeof ( inc ) ) ;			      int flag = 0 ;						  
  for ( int i = 1 ;					      	dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ;			      for ( int i = 1 ;						  
  i < n ;						      	int flag = 0 ;						      i < n ;							  
  i ++ ) {						      	for ( int i = 1 ;					      i ++ ) {							  
    for ( int j = 0 ;					      	i < n ;							    	for ( int j = 0 ;					  
    j < i ;						      	i ++ ) {						    	j < i ;							  
    j ++ ) {						      	  for ( int j = 0 ;					    	j ++ ) {						  
      if ( arr [ j ] > arr [ i ] ) {			      	  j < i ;						    	  if ( arr [ j ] > arr [ i ] ) {			  
	dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr  	  j ++ ) {						    	    dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) 
	flag = 1 ;					      	    if ( arr [ j ] > arr [ i ] ) {			    	    flag = 1 ;						  
      }							      	      dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) 	  }							  
      else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i  	      flag = 1 ;					    	  else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i  
    }							      	    }							    	}							  
  }							      	    else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i    }								  
  int result = Integer . MIN_VALUE ;			      	  }							      int result = INT_MIN ;					  
  for ( int i = 0 ;					      	}							      for ( int i = 0 ;						  
  i < n ;						      	int result = INT_MIN ;					      i < n ;							  
  i ++ ) {						      	for ( int i = 0 ;					      i ++ ) {							  
    if ( result < inc [ i ] ) result = inc [ i ] ;	      	i < n ;							    	if ( result < inc [ i ] ) result = inc [ i ] ;		  
    if ( result < dec [ i ] ) result = dec [ i ] ;	      	i ++ ) {						    	if ( result < dec [ i ] ) result = dec [ i ] ;		  
  }							      	  if ( result < inc [ i ] ) result = inc [ i ] ;	      }								  
  return result ;					      	  if ( result < dec [ i ] ) result = dec [ i ] ;	      return result ;						  
}							      	}							    }								  
							      	return result ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORTING_USING_TRIVIAL_HASH_FUNCTION_1			      SORTING_USING_TRIVIAL_HASH_FUNCTION_1			    SORTING_USING_TRIVIAL_HASH_FUNCTION_1			  SORTING_USING_TRIVIAL_HASH_FUNCTION_1
--							      --							    --								  --
static void sortUsingHash ( int a [ ] , int n ) {	      void sortUsingHash ( int a [ ] , int n ) {		    void sortUsingHash ( int a [ ] , int n ) {			  script_not_found : None
  int max = Arrays . stream ( a ) . max ( ) . getAsInt ( ) ;  	int max = * std :: max_element ( a , a + n ) ;		      int max = std :: max ( a , a [ n - 1 ] ) ;		  
  int min = Math . abs ( Arrays . stream ( a ) . min ( ) . ge 	int min = abs ( * std :: min_element ( a , a + n ) ) ;	      int min = abs ( std :: min ( a , a [ n - 1 ] ) ) ;	  
  int hashpos [ ] = new int [ max + 1 ] ;		      	int hashpos [ max + 1 ] = {				      int hashpos [ max + 1 ] ;					  
  int hashneg [ ] = new int [ min + 1 ] ;		      	  0 }							      int hashneg [ min + 1 ] ;					  
  for ( int i = 0 ;					      	  ;							      for ( int i = 0 ;						  
  i < n ;						      	  int hashneg [ min + 1 ] = {				      i < n ;							  
  i ++ ) {						      	    0 }							      i ++ ) {							  
    if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ;	      	    ;							    	if ( a [ i ] >= 0 ) {					  
    else hashneg [ Math . abs ( a [ i ] ) ] += 1 ;	      	    for ( int i = 0 ;					    	  hashpos [ a [ i ] ] += 1 ;				  
  }							      	    i < n ;						    	}							  
  for ( int i = min ;					      	    i ++ ) {						    	else {							  
  i > 0 ;						      	      if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ;	    	  hashneg [ abs ( a [ i ] ) ] += 1 ;			  
  i -- ) {						      	      else hashneg [ abs ( a [ i ] ) ] += 1 ;		    	}							  
    if ( hashneg [ i ] > 0 ) {				      	    }							      }								  
      for ( int j = 0 ;					      	    for ( int i = min ;					      for ( int i = min ;					  
      j < hashneg [ i ] ;				      	    i > 0 ;						      i > 0 ;							  
      j ++ ) {						      	    i -- ) {						      i -- ) {							  
	System . out . print ( ( - 1 ) * i + " " ) ;	      	      if ( hashneg [ i ] ) {				    	if ( hashneg [ i ] > 0 ) {				  
      }							      		for ( int j = 0 ;				    	  for ( int j = 0 ;					  
    }							      		j < hashneg [ i ] ;				    	  j < hashneg [ i ] ;					  
  }							      		j ++ ) {					    	  j ++ ) {						  
  for ( int i = 0 ;					      		  cout << ( - 1 ) * i << " " ;			    	    cout << ( - 1 ) * i << " " ;			  
  i <= max ;						      		}						    	  }							  
  i ++ ) {						      	      }							    	}							  
    if ( hashpos [ i ] > 0 ) {				      	    }							      }								  
      for ( int j = 0 ;					      	    for ( int i = 0 ;					      for ( int i = 0 ;						  
      j < hashpos [ i ] ;				      	    i <= max ;						      i <= max ;						  
      j ++ ) {						      	    i ++ ) {						      i ++ ) {							  
	System . out . print ( i + " " ) ;		      	      if ( hashpos [ i ] ) {				    	if ( hashpos [ i ] > 0 ) {				  
      }							      		for ( int j = 0 ;				    	  for ( int j = 0 ;					  
    }							      		j < hashpos [ i ] ;				    	  j < hashpos [ i ] ;					  
  }							      		j ++ ) {					    	  j ++ ) {						  
}							      		  cout << i << " " ;				    	    cout << i << " " ;					  
							      		}						    	  }							  
							      	      }							    	}							  
							      	    }							      }								  
							      	  }							    }								  
-							      	  -							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B
--							      --							    --								  --
static long arrangeBraces ( int n , int pos [ ] , int k ) {   long long arrangeBraces ( int n , int pos [ ] , int k ) {	    long long arrangeBraces ( int n , int pos [ ] , int k ) {	  script_not_found : None
  boolean h [ ] = new boolean [ N ] ;			      	bool h [ N ] ;						      bool h [ N ] ;						  
  int dp [ ] [ ] = new int [ N ] [ N ] ;		      	int dp [ N ] [ N ] ;					      int dp [ N ] [ N ] ;					  
  for ( int i = 0 ;					      	memset ( h , 0 , sizeof h ) ;				      for ( int i = 0 ;						  
  i < k ;						      	memset ( dp , 0 , sizeof dp ) ;				      i < k ;							  
  i ++ ) {						      	for ( int i = 0 ;					      i ++ ) h [ pos [ i ] ] = true ;				  
    h [ pos [ i ] ] = true ;				      	i < k ;							      dp [ 0 ] [ 0 ] = 1 ;					  
  }							      	i ++ ) h [ pos [ i ] ] = 1 ;				      for ( int i = 1 ;						  
  dp [ 0 ] [ 0 ] = 1 ;					      	dp [ 0 ] [ 0 ] = 1 ;					      i <= 2 * n ;						  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      i ++ ) {							  
  i <= 2 * n ;						      	i <= 2 * n ;						    	for ( int j = 0 ;					  
  i ++ ) {						      	i ++ ) {						    	j <= 2 * n ;						  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	j ++ ) {						  
    j <= 2 * n ;					      	  j <= 2 * n ;						    	  if ( h [ i ] ) {					  
    j ++ ) {						      	  j ++ ) {						    	    if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] 
      if ( h [ i ] ) {					      	    if ( h [ i ] ) {					    	    else dp [ i ] [ j ] = 0 ;				  
	if ( j != 0 ) {					      	      if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] 	  }							  
	  dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;	      	      else dp [ i ] [ j ] = 0 ;				    	  else if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j -  
	}						      	    }							    	  else dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;	  
	else {						      	    else {						    	}							  
	  dp [ i ] [ j ] = 0 ;				      	      if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]   }								  
	}						      	      else dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;	      return dp [ 2 * n ] [ 0 ] ;				  
      }							      	    }							    }								  
      else if ( j != 0 ) {				      	  }							    								  
	dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1  	}							    								  
      }							      	return dp [ 2 * n ] [ 0 ] ;				    								  
      else {						      }								    								  
	dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;	      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return dp [ 2 * n ] [ 0 ] ;				      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA
--							      --							    --								  --
static int lenghtOfLongestAP ( int set [ ] , int n ) {	      int lenghtOfLongestAP ( int set [ ] , int n ) {		    int lenghtOfLongestAP ( int set [ ] , int n ) {		  success : None
  if ( n <= 2 ) return n ;				      	if ( n <= 2 ) return n ;				      if ( n <= 2 ) return n ;					  
  int L [ ] [ ] = new int [ n ] [ n ] ;			      	int L [ n ] [ n ] ;					      int L [ n ] [ n ] ;					  
  int llap = 2 ;					      	int llap = 2 ;						      int llap = 2 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) L [ i ] [ n - 1 ] = 2 ;			      	i ++ ) L [ i ] [ n - 1 ] = 2 ;				      i ++ ) {							  
  for ( int j = n - 2 ;					      	for ( int j = n - 2 ;					    	L [ i ] [ n - 1 ] = 2 ;					  
  j >= 1 ;						      	j >= 1 ;						      }								  
  j -- ) {						      	j -- ) {						      for ( int j = n - 2 ;					  
    int i = j - 1 , k = j + 1 ;				      	  int i = j - 1 , k = j + 1 ;				      j >= 1 ;							  
    while ( i >= 0 && k <= n - 1 ) {			      	  while ( i >= 0 && k <= n - 1 ) {			      j -- ) {							  
      if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ;     	    if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ;	    	int i = j - 1 , k = j + 1 ;				  
      else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) {     	    else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) {	    	while ( i >= 0 && k <= n - 1 ) {			  
	L [ i ] [ j ] = 2 ;				      	      L [ i ] [ j ] = 2 , i -- ;			    	  if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ;	  
	i -- ;						      	    }							    	  else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) {	  
      }							      	    else {						    	    L [ i ] [ j ] = 2 ;					  
      else {						      	      L [ i ] [ j ] = L [ j ] [ k ] + 1 ;		    	    i -- ;						  
	L [ i ] [ j ] = L [ j ] [ k ] + 1 ;		      	      llap = max ( llap , L [ i ] [ j ] ) ;		    	  }							  
	llap = Math . max ( llap , L [ i ] [ j ] ) ;	      	      i -- ;						    	  else {						  
	i -- ;						      	      k ++ ;						    	    L [ i ] [ j ] = L [ j ] [ k ] + 1 ;			  
	k ++ ;						      	    }							    	    llap = max ( llap , L [ i ] [ j ] ) ;		  
      }							      	  }							    	    i -- ;						  
    }							      	  while ( i >= 0 ) {					    	    k ++ ;						  
    while ( i >= 0 ) {					      	    L [ i ] [ j ] = 2 ;					    	  }							  
      L [ i ] [ j ] = 2 ;				      	    i -- ;						    	}							  
      i -- ;						      	  }							    	while ( i >= 0 ) {					  
    }							      	}							    	  L [ i ] [ j ] = 2 ;					  
  }							      	return llap ;						    	  i -- ;						  
  return llap ;						      }								    	}							  
}							      								      }								  
							      								      return llap ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_BITONIC_SUBARRAY				      MAXIMUM_SUM_BITONIC_SUBARRAY				    MAXIMUM_SUM_BITONIC_SUBARRAY				  MAXIMUM_SUM_BITONIC_SUBARRAY
--							      --							    --								  --
static int maxSumBitonicSubArr ( int arr [ ] , int n ) {      int maxSumBitonicSubArr ( int arr [ ] , int n ) {		    int maxSumBitonicSubArr ( int arr [ ] , int n ) {		  success : None
  int [ ] msis = new int [ n ] ;			      	int msis [ n ] , msds [ n ] ;				      int msis [ n ] ;						  
  int [ ] msds = new int [ n ] ;			      	int max_sum = INT_MIN ;					      int msds [ n ] ;						  
  int max_sum = Integer . MIN_VALUE ;			      	msis [ 0 ] = arr [ 0 ] ;				      int maxSum = INT_MIN ;					  
  msis [ 0 ] = arr [ 0 ] ;				      	for ( int i = 1 ;					      msis [ 0 ] = arr [ 0 ] ;					  
  for ( int i = 1 ;					      	i < n ;							      for ( int i = 1 ;						  
  i < n ;						      	i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [   i < n ;							  
  i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ 	else msis [ i ] = arr [ i ] ;				      i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ 
  else msis [ i ] = arr [ i ] ;				      	msds [ n - 1 ] = arr [ n - 1 ] ;			      else msis [ i ] = arr [ i ] ;				  
  msds [ n - 1 ] = arr [ n - 1 ] ;			      	for ( int i = n - 2 ;					      msds [ n - 1 ] = arr [ n - 1 ] ;				  
  for ( int i = n - 2 ;					      	i >= 0 ;						      for ( int i = n - 2 ;					  
  i >= 0 ;						      	i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [   i >= 0 ;							  
  i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ 	else msds [ i ] = arr [ i ] ;				      i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ 
  else msds [ i ] = arr [ i ] ;				      	for ( int i = 0 ;					      else msds [ i ] = arr [ i ] ;				  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ]   i < n ;							  
  i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] 	return max_sum ;					      i ++ ) if ( maxSum < ( msis [ i ] + msds [ i ] - arr [ i ]  
  return max_sum ;					      }								      return maxSum ;						  
}							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1	      LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1		    LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1		  LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1
--							      --							    --								  --
int maxLen ( int arr [ ] , int n ) {			      int maxLen ( int arr [ ] , int n ) {			    int maxLen ( int arr [ ] , int n ) {			  success : None
  HashMap < Integer , Integer > hM = new HashMap < Integer ,  	unordered_map < int , int > hM ;			      unordered_map < int , int > hM ;				  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  int max_len = 0 ;					      	int max_len = 0 ;					      int maxLen = 0 ;						  
  int ending_index = - 1 ;				      	int ending_index = - 1 ;				      int endingIndex = - 1 ;					  
  int start_index = 0 ;					      	for ( int i = 0 ;					      int startIndex = 0 ;					  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ;	      i < n ;							  
  i ++ ) {						      	for ( int i = 0 ;					      i ++ ) arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ;		  
    arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ;		      	i < n ;							      for ( int i = 0 ;						  
  }							      	i ++ ) {						      i < n ;							  
  for ( int i = 0 ;					      	  sum += arr [ i ] ;					      i ++ ) {							  
  i < n ;						      	  if ( sum == 0 ) {					    	sum += arr [ i ] ;					  
  i ++ ) {						      	    max_len = i + 1 ;					    	if ( sum == 0 ) {					  
    sum += arr [ i ] ;					      	    ending_index = i ;					    	  maxLen = i + 1 ;					  
    if ( sum == 0 ) {					      	  }							    	  endingIndex = i ;					  
      max_len = i + 1 ;					      	  if ( hM . find ( sum + n ) != hM . end ( ) ) {	    	}							  
      ending_index = i ;				      	    if ( max_len < i - hM [ sum + n ] ) {		    	if ( hM . find ( sum + n ) != hM . end ( ) ) {		  
    }							      	      max_len = i - hM [ sum + n ] ;			    	  if ( maxLen < i - hM [ sum + n ] ) {			  
    if ( hM . containsKey ( sum + n ) ) {		      	      ending_index = i ;				    	    maxLen = i - hM [ sum + n ] ;			  
      if ( max_len < i - hM . get ( sum + n ) ) {	      	    }							    	    endingIndex = i ;					  
	max_len = i - hM . get ( sum + n ) ;		      	  }							    	  }							  
	ending_index = i ;				      	  else hM [ sum + n ] = i ;				    	}							  
      }							      	}							    	else hM [ sum + n ] = i ;				  
    }							      	for ( int i = 0 ;					      }								  
    else hM . put ( sum + n , i ) ;			      	i < n ;							      for ( int i = 0 ;						  
  }							      	i ++ ) arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ;	      i < n ;							  
  for ( int i = 0 ;					      	printf ( "%d to %d\n" , ending_index - max_len + 1 , ending   i ++ ) arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ;		  
  i < n ;						      	return max_len ;					      int end = endingIndex - maxLen + 1 ;			  
  i ++ ) {						      }								      cout << end << " to " << endingIndex << endl ;		  
    arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ;		      								      return maxLen ;						  
  }							      								    }								  
  int end = ending_index - max_len + 1 ;		      								    								  
  System . out . println ( end + " to " + ending_index ) ;    								    								  
  return max_len ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAGIC_SQUARE						      MAGIC_SQUARE						    MAGIC_SQUARE						  MAGIC_SQUARE
--							      --							    --								  --
static void generateSquare ( int n ) {			      void generateSquare ( int n ) {				    void generateSquare ( int n ) {				  script_not_found : None
  int [ ] [ ] magicSquare = new int [ n ] [ n ] ;	      	int magicSquare [ n ] [ n ] ;				      vector < vector < int >> magicSquare ( n , vector < int > ( 
  int i = n / 2 ;					      	memset ( magicSquare , 0 , sizeof ( magicSquare ) ) ;	      int i = n / 2 ;						  
  int j = n - 1 ;					      	int i = n / 2 ;						      int j = n - 1 ;						  
  for ( int num = 1 ;					      	int j = n - 1 ;						      for ( int num = 1 ;					  
  num <= n * n ;					      	for ( int num = 1 ;					      num <= n * n ;						  
  ) {							      	num <= n * n ;						      ) {							  
    if ( i == - 1 && j == n ) {				      	) {							    	if ( i == - 1 && j == n ) {				  
      j = n - 2 ;					      	  if ( i == - 1 && j == n ) {				    	  j = n - 2 ;						  
      i = 0 ;						      	    j = n - 2 ;						    	  i = 0 ;						  
    }							      	    i = 0 ;						    	}							  
    else {						      	  }							    	else {							  
      if ( j == n ) j = 0 ;				      	  else {						    	  if ( j == n ) {					  
      if ( i < 0 ) i = n - 1 ;				      	    if ( j == n ) j = 0 ;				    	    j = 0 ;						  
    }							      	    if ( i < 0 ) i = n - 1 ;				    	  }							  
    if ( magicSquare [ i ] [ j ] != 0 ) {		      	  }							    	  if ( i < 0 ) {					  
      j -= 2 ;						      	  if ( magicSquare [ i ] [ j ] ) {			    	    i = n - 1 ;						  
      i ++ ;						      	    j -= 2 ;						    	  }							  
      continue ;					      	    i ++ ;						    	}							  
    }							      	    continue ;						    	if ( magicSquare [ i ] [ j ] != 0 ) {			  
    else magicSquare [ i ] [ j ] = num ++ ;		      	  }							    	  j -= 2 ;						  
    j ++ ;						      	  else magicSquare [ i ] [ j ] = num ++ ;		    	  i ++ ;						  
    i -- ;						      	  j ++ ;						    	  continue ;						  
  }							      	  i -- ;						    	}							  
  System . out . println ( "The Magic Square for " + n + ":"  	}							    	else {							  
  System . out . println ( "Sum of each row or column " + n * 	cout << "The Magic Square for n=" << n << ":\nSum of " "eac 	  magicSquare [ i ] [ j ] = num ++ ;			  
  for ( i = 0 ;						      	for ( i = 0 ;						    	}							  
  i < n ;						      	i < n ;							    	j ++ ;							  
  i ++ ) {						      	i ++ ) {						    	i -- ;							  
    for ( j = 0 ;					      	  for ( j = 0 ;						      }								  
    j < n ;						      	  j < n ;						      cout << "The Magic Square for " << n << ":" << endl ;	  
    j ++ ) System . out . print ( magicSquare [ i ] [ j ] + " 	  j ++ ) cout << magicSquare [ i ] [ j ] << " " ;	      cout << "Sum of each row or column " << n * ( n * n + 1 ) / 
    System . out . println ( ) ;			      	  cout << endl ;					      for ( i = 0 ;						  
  }							      	}							      i < n ;							  
}							      }								      i ++ ) {							  
							      								    	for ( j = 0 ;						  
							      								    	j < n ;							  
							      								    	j ++ ) {						  
							      								    	  cout << magicSquare [ i ] [ j ] << " " ;		  
							      								    	}							  
							      								    	cout << endl ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_
--							      --							    --								  --
static int pre_compute ( int a [ ] , int n , int index , int  ll pre_compute ( ll a [ ] , ll n , ll index , ll k ) {	    int pre_compute ( int a [ ] , int n , int index , int k ) {	  script_not_found : None
  int dp [ ] [ ] = new int [ n ] [ n ] ;		      	ll dp [ n ] [ n ] = {					      int dp [ n ] [ n ] ;					  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < n ;						      	  ;							      i < n ;							  
  i ++ ) {						      	  for ( int i = 0 ;					      i ++ ) {							  
    if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 	  i < n ;						    	if ( a [ i ] > a [ 0 ] ) {				  
    else dp [ 0 ] [ i ] = a [ i ] ;			      	  i ++ ) {						    	  dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ;			  
  }							      	    if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 	}							  
  for ( int i = 1 ;					      	    else dp [ 0 ] [ i ] = a [ i ] ;			    	else {							  
  i < n ;						      	  }							    	  dp [ 0 ] [ i ] = a [ i ] ;				  
  i ++ ) {						      	  for ( int i = 1 ;					    	}							  
    for ( int j = 0 ;					      	  i < n ;						      }								  
    j < n ;						      	  i ++ ) {						      for ( int i = 1 ;						  
    j ++ ) {						      	    for ( int j = 0 ;					      i < n ;							  
      if ( a [ j ] > a [ i ] && j > i ) {		      	    j < n ;						      i ++ ) {							  
	if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j  	    j ++ ) {						    	for ( int j = 0 ;					  
	else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;	      	      if ( a [ j ] > a [ i ] && j > i ) {		    	j < n ;							  
      }							      		if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [  	j ++ ) {						  
      else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;	      		else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;	    	  if ( a [ j ] > a [ i ] && j > i ) {			  
    }							      	      }							    	    if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j  
  }							      	      else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;	    	      dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ;	  
  return dp [ index ] [ k ] ;				      	    }							    	    }							  
}							      	  }							    	    else {						  
							      	  return dp [ index ] [ k ] ;				    	      dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;		  
							      	}							    	    }							  
							      								    	  }							  
							      								    	  else {						  
							      								    	    dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;		  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return dp [ index ] [ k ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING		      SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING		    SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING			  SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING
--							      --							    --								  --
static String findSubString ( String str ) {		      string findSubString ( string str ) {			    string findSubString ( string str ) {			  script_not_found : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  int dist_count = 0 ;					      	int dist_count = 0 ;					      int dist_count = 0 ;					  
  boolean [ ] visited = new boolean [ MAX_CHARS ] ;	      	bool visited [ MAX_CHARS ] = {				      vector < bool > visited ( MAX_CHARS , false ) ;		  
  Arrays . fill ( visited , false ) ;			      	  false }						      for ( int i = 0 ;						  
  for ( int i = 0 ;					      	  ;							      i < n ;							  
  i < n ;						      	  for ( int i = 0 ;					      i ++ ) {							  
  i ++ ) {						      	  i < n ;						    	if ( visited [ str [ i ] ] == false ) {			  
    if ( visited [ str . charAt ( i ) ] == false ) {	      	  i ++ ) {						    	  visited [ str [ i ] ] = true ;			  
      visited [ str . charAt ( i ) ] = true ;		      	    if ( visited [ str [ i ] ] == false ) {		    	  dist_count ++ ;					  
      dist_count ++ ;					      	      visited [ str [ i ] ] = true ;			    	}							  
    }							      	      dist_count ++ ;					      }								  
  }							      	    }							      int start = 0 , start_index = - 1 ;			  
  int start = 0 , start_index = - 1 ;			      	  }							      int min_len = INT_MAX ;					  
  int min_len = Integer . MAX_VALUE ;			      	  int start = 0 , start_index = - 1 , min_len = INT_MAX ;     int count = 0 ;						  
  int count = 0 ;					      	  int count = 0 ;					      vector < int > curr_count ( MAX_CHARS , 0 ) ;		  
  int [ ] curr_count = new int [ MAX_CHARS ] ;		      	  int curr_count [ MAX_CHARS ] = {			      for ( int j = 0 ;						  
  for ( int j = 0 ;					      	    0 }							      j < n ;							  
  j < n ;						      	    ;							      j ++ ) {							  
  j ++ ) {						      	    for ( int j = 0 ;					    	curr_count [ str [ j ] ] ++ ;				  
    curr_count [ str . charAt ( j ) ] ++ ;		      	    j < n ;						    	if ( curr_count [ str [ j ] ] == 1 ) {			  
    if ( curr_count [ str . charAt ( j ) ] == 1 ) count ++ ;  	    j ++ ) {						    	  count ++ ;						  
    if ( count == dist_count ) {			      	      curr_count [ str [ j ] ] ++ ;			    	}							  
      while ( curr_count [ str . charAt ( start ) ] > 1 ) {   	      if ( curr_count [ str [ j ] ] == 1 ) count ++ ;	    	if ( count == dist_count ) {				  
	if ( curr_count [ str . charAt ( start ) ] > 1 ) curr 	      if ( count == dist_count ) {			    	  while ( curr_count [ str [ start ] ] > 1 ) {		  
	start ++ ;					      		while ( curr_count [ str [ start ] ] > 1 ) {	    	    if ( curr_count [ str [ start ] ] > 1 ) {		  
      }							      		  if ( curr_count [ str [ start ] ] > 1 ) curr_coun 	      curr_count [ str [ start ] ] -- ;			  
      int len_window = j - start + 1 ;			      		  start ++ ;					    	    }							  
      if ( min_len > len_window ) {			      		}						    	    start ++ ;						  
	min_len = len_window ;				      		int len_window = j - start + 1 ;		    	  }							  
	start_index = start ;				      		if ( min_len > len_window ) {			    	  int len_window = j - start + 1 ;			  
      }							      		  min_len = len_window ;			    	  if ( min_len > len_window ) {				  
    }							      		  start_index = start ;				    	    min_len = len_window ;				  
  }							      		}						    	    start_index = start ;				  
  return str . substring ( start_index , start_index + min_le 	      }							    	  }							  
}							      	    }							    	}							  
							      	    return str . substr ( start_index , min_len ) ;	      }								  
							      	  }							      return str . substr ( start_index , min_len ) ;		  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM	      SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM		    SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM		  SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM
--							      --							    --								  --
static int KnapSack ( int val [ ] , int wt [ ] , int n , int  int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) {   int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) {	  failure : #Results: 2, 10
  int mat [ ] [ ] = new int [ 2 ] [ W + 1 ] ;		      	int mat [ 2 ] [ W + 1 ] ;				      int mat [ 2 ] [ W + 1 ] ;					  
  int i = 0 ;						      	memset ( mat , 0 , sizeof ( mat ) ) ;			      int i = 0 ;						  
  while ( i < n ) {					      	int i = 0 ;						      while ( i < n ) {						  
    int j = 0 ;						      	while ( i < n ) {					    	int j = 0 ;						  
    if ( i % 2 != 0 ) {					      	  int j = 0 ;						    	if ( i % 2 != 0 ) {					  
      while ( ++ j <= W ) {				      	  if ( i % 2 != 0 ) {					    	  while ( ++ j <= W ) {					  
	if ( wt [ i ] <= j ) {				      	    while ( ++ j <= W ) {				    	    if ( wt [ i ] <= j ) mat [ 1 ] [ j ] = max ( val [ i  
	  mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0  	      if ( wt [ i ] <= j ) mat [ 1 ] [ j ] = max ( val [ i  	    else mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ;		  
	}						      	      else mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ;		    	  }							  
	else {						      	    }							    	}							  
	  mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ;		      	  }							    	else {							  
	}						      	  else {						    	  while ( ++ j <= W ) {					  
      }							      	    while ( ++ j <= W ) {				    	    if ( wt [ i ] <= j ) mat [ 0 ] [ j ] = max ( val [ i  
    }							      	      if ( wt [ i ] <= j ) mat [ 0 ] [ j ] = max ( val [ i  	    else mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ;		  
    else {						      	      else mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ;		    	  }							  
      while ( ++ j <= W ) {				      	    }							    	}							  
	if ( wt [ i ] <= j ) {				      	  }							    	i ++ ;							  
	  mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1  	  i ++ ;						      }								  
	}						      	}							      return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; 
	else {						      	return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; }								  
	  mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ;		      }								    								  
	}						      								    								  
      }							      								    								  
    }							      								    								  
    i ++ ;						      								    								  
  }							      								    								  
  return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_APPLYING_GIVEN_EQUATION			      SORT_ARRAY_APPLYING_GIVEN_EQUATION			    SORT_ARRAY_APPLYING_GIVEN_EQUATION				  SORT_ARRAY_APPLYING_GIVEN_EQUATION
--							      --							    --								  --
static void sortArray ( int arr [ ] , int n , int A , int B , void sortArray ( int arr [ ] , int n , int A , int B , int C  void sortArray ( int arr [ ] , int n , int A , int B , int C  success : None
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i  	i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i    i ++ ) {							  
  int index = - 1 ;					      	int index , maximum = INT_MIN ;				    	arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i ] + C 
  int maximum = - 999999 ;				      	for ( int i = 0 ;					      }								  
  for ( int i = 0 ;					      	i < n ;							      int index = - 1 ;						  
  i < n ;						      	i ++ ) {						      int maximum = - 999999 ;					  
  i ++ ) {						      	  if ( maximum < arr [ i ] ) {				      for ( int i = 0 ;						  
    if ( maximum < arr [ i ] ) {			      	    index = i ;						      i < n ;							  
      index = i ;					      	    maximum = arr [ i ] ;				      i ++ ) {							  
      maximum = arr [ i ] ;				      	  }							    	if ( maximum < arr [ i ] ) {				  
    }							      	}							    	  index = i ;						  
  }							      	int i = 0 , j = n - 1 ;					    	  maximum = arr [ i ] ;					  
  int i = 0 , j = n - 1 ;				      	int new_arr [ n ] , k = 0 ;				    	}							  
  int [ ] new_arr = new int [ n ] ;			      	while ( i < index && j > index ) {			      }								  
  int k = 0 ;						      	  if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i +   int i = 0 , j = n - 1 ;					  
  while ( i < index && j > index ) {			      	  else new_arr [ k ++ ] = arr [ j -- ] ;		      int new_arr [ n ] ;					  
    if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i + 	}							      int k = 0 ;						  
    else new_arr [ k ++ ] = arr [ j -- ] ;		      	while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ] ;	      while ( i < index && j > index ) {			  
  }							      	while ( j > index ) new_arr [ k ++ ] = arr [ j -- ] ;	    	if ( arr [ i ] < arr [ j ] ) {				  
  while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ] ;	      	new_arr [ n - 1 ] = maximum ;				    	  new_arr [ k ++ ] = arr [ i ++ ] ;			  
  while ( j > index ) new_arr [ k ++ ] = arr [ j -- ] ;	      	for ( int i = 0 ;					    	}							  
  new_arr [ n - 1 ] = maximum ;				      	i < n ;							    	else {							  
  for ( int p = 0 ;					      	i ++ ) arr [ i ] = new_arr [ i ] ;			    	  new_arr [ k ++ ] = arr [ j -- ] ;			  
  p < n ;						      }								    	}							  
  p ++ ) arr [ p ] = new_arr [ p ] ;			      								      }								  
}							      								      while ( i < index ) {					  
							      								    	new_arr [ k ++ ] = arr [ i ++ ] ;			  
							      								      }								  
							      								      while ( j > index ) {					  
							      								    	new_arr [ k ++ ] = arr [ j -- ] ;			  
							      								      }								  
							      								      new_arr [ n - 1 ] = maximum ;				  
							      								      for ( int p = 0 ;						  
							      								      p < n ;							  
							      								      p ++ ) {							  
							      								    	arr [ p ] = new_arr [ p ] ;				  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS		      LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS		    LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS		  LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS
--							      --							    --								  --
static int lcsOf3 ( String X , String Y , String Z , int m ,  int lcsOf3 ( string X , string Y , string Z , int m , int n , int lcsOf3 ( string X , string Y , string Z , int m , int n , script_not_found : None
  int [ ] [ ] [ ] L = new int [ m + 1 ] [ n + 1 ] [ o + 1 ] ; 	int L [ m + 1 ] [ n + 1 ] [ o + 1 ] ;			      vector < vector < int >> L ( m + 1 , vector < int > ( n + 1 
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= m ;						      	i <= m ;						      i <= m ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= n ;						      	  j <= n ;						    	j <= n ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      for ( int k = 0 ;					      	    for ( int k = 0 ;					    	  for ( int k = 0 ;					  
      k <= o ;						      	    k <= o ;						    	  k <= o ;						  
      k ++ ) {						      	    k ++ ) {						    	  k ++ ) {						  
	if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] 	      if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] 	    if ( i == 0 || j == 0 || k == 0 ) {			  
	else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1  	      else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] = 	      L [ i ] [ j ] [ k ] = 0 ;				  
	else L [ i ] [ j ] [ k ] = Math . max ( Math . max (  	      else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [  	    }							  
      }							      	    }							    	    else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] = 
    }							      	  }							    	      L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 
  }							      	}							    	    }							  
  return L [ m ] [ n ] [ o ] ;				      	return L [ m ] [ n ] [ o ] ;				    	    else {						  
}							      }								    	      L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] 
							      								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return L [ m ] [ n ] [ o ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES			      CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES			    CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES			  CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES
--							      --							    --								  --
static void printMat ( int degseq [ ] , int n ) {	      void printMat ( int degseq [ ] , int n ) {		    void print_mat ( int degseq [ ] , int n ) {			  script_not_found : None
  int [ ] [ ] mat = new int [ n ] [ n ] ;		      	int mat [ n ] [ n ] ;					      int mat [ n ] [ n ] ;					  
  for ( int i = 0 ;					      	memset ( mat , 0 , sizeof ( mat ) ) ;			      for ( int i = 0 ;						  
  i < n ;						      	for ( int i = 0 ;					      i < n ;							  
  i ++ ) {						      	i < n ;							      i ++ ) {							  
    for ( int j = i + 1 ;				      	i ++ ) {						    	for ( int j = i + 1 ;					  
    j < n ;						      	  for ( int j = i + 1 ;					    	j < n ;							  
    j ++ ) {						      	  j < n ;						    	j ++ ) {						  
      if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) {	      	  j ++ ) {						    	  if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) {		  
	degseq [ i ] -- ;				      	    if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) {	    	    degseq [ i ] -- ;					  
	degseq [ j ] -- ;				      	      degseq [ i ] -- ;					    	    degseq [ j ] -- ;					  
	mat [ i ] [ j ] = 1 ;				      	      degseq [ j ] -- ;					    	    mat [ i ] [ j ] = 1 ;				  
	mat [ j ] [ i ] = 1 ;				      	      mat [ i ] [ j ] = 1 ;				    	    mat [ j ] [ i ] = 1 ;				  
      }							      	      mat [ j ] [ i ] = 1 ;				    	  }							  
    }							      	    }							    	}							  
  }							      	  }							      }								  
  System . out . print ( "\n" + setw ( 3 ) + "	   " ) ;      	}							      cout << "\n" << setw ( 3 ) << "	  " ;			  
  for ( int i = 0 ;					      	cout << "\n" << setw ( 3 ) << "	    " ;			      for ( int i = 0 ;						  
  i < n ;						      	for ( int i = 0 ;					      i < n ;							  
  i ++ ) System . out . print ( setw ( 3 ) + "(" + i + ")" )  	i < n ;							      i ++ ) {							  
  System . out . print ( "\n\n" ) ;			      	i ++ ) cout << setw ( 3 ) << "(" << i << ")" ;		    	cout << setw ( 3 ) << "(" << i << ")" ;			  
  for ( int i = 0 ;					      	cout << "\n\n" ;					      }								  
  i < n ;						      	for ( int i = 0 ;					      cout << "\n\n" ;						  
  i ++ ) {						      	i < n ;							      for ( int i = 0 ;						  
    System . out . print ( setw ( 4 ) + "(" + i + ")" ) ;     	i ++ ) {						      i < n ;							  
    for ( int j = 0 ;					      	  cout << setw ( 4 ) << "(" << i << ")" ;		      i ++ ) {							  
    j < n ;						      	  for ( int j = 0 ;					    	cout << setw ( 4 ) << "(" << i << ")" ;			  
    j ++ ) System . out . print ( setw ( 5 ) + mat [ i ] [ j  	  j < n ;						    	for ( int j = 0 ;					  
    System . out . print ( "\n" ) ;			      	  j ++ ) cout << setw ( 5 ) << mat [ i ] [ j ] ;	    	j < n ;							  
  }							      	  cout << "\n" ;					    	j ++ ) {						  
}							      	}							    	  cout << setw ( 5 ) << mat [ i ] [ j ] ;		  
							      }								    	}							  
							      								    	cout << "\n" ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_CHECK					      DIVISIBILITY_CHECK					    DIVISIBILITY_CHECK						  DIVISIBILITY_CHECK
--							      --							    --								  --
static void divisibilityCheck ( List < Integer > arr , int n  void divisibilityCheck ( int arr [ ] , int n ) {		    void divisibilityCheck ( vector < int > arr , int n ) {	  script_not_found : None
  List < Integer > s = new ArrayList < Integer > ( ) ;	      	unordered_set < int > s ;				      vector < int > s ;					  
  int max_ele = Integer . MIN_VALUE ;			      	int max_ele = INT_MIN ;					      int max_ele = INT_MAX ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    s . add ( arr . get ( i ) ) ;			      	  s . insert ( arr [ i ] ) ;				    	s . push_back ( arr [ i ] ) ;				  
    max_ele = Math . max ( max_ele , arr . get ( i ) ) ;      	  max_ele = max ( max_ele , arr [ i ] ) ;		    	max_ele = max ( max_ele , arr [ i ] ) ;			  
  }							      	}							      }								  
  LinkedHashSet < Integer > res = new LinkedHashSet < Integer 	unordered_set < int > res ;				      unordered_set < int > res ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr . get ( i ) != 0 ) for ( int j = arr . get ( i ) 	  if ( arr [ i ] != 0 ) {				    	if ( arr [ i ] != 0 ) for ( int j = arr [ i ] * 2 ;	  
    j <= max_ele ;					      	    for ( int j = arr [ i ] * 2 ;			    	j <= max_ele ;						  
    j += arr . get ( i ) ) {				      	    j <= max_ele ;					    	j += arr [ i ] ) {					  
      if ( s . contains ( j ) ) res . add ( j ) ;	      	    j += arr [ i ] ) {					    	  if ( s . find ( j ) != s . end ( ) ) res . insert ( j ) 
    }							      	      if ( s . find ( j ) != s . end ( ) ) res . insert ( j 	}							  
  }							      	    }							      }								  
  List < Integer > list = new ArrayList < Integer > ( res ) ; 	  }							      vector < int > vec ( res ) ;				  
  Collections . reverse ( list ) ;			      	}							      sort ( vec . begin ( ) , vec . end ( ) ) ;		  
  for ( Integer temp : list ) System . out . print ( temp + " 	unordered_map < int , int > mp ;			      for ( int temp : vec ) cout << temp << " " ;		  
}							      	for ( int i = 0 ;					    }								  
							      	i < n ;							    								  
							      	i ++ ) mp [ arr [ i ] ] ++ ;				    								  
							      	unordered_map < int , int > :: iterator it ;		    								  
							      	vector < int > ans ;					    								  
							      	for ( it = mp . begin ( ) ;				    								  
							      	it != mp . end ( ) ;					    								  
							      	it ++ ) {						    								  
							      	  if ( it -> second >= 2 ) {				    								  
							      	    if ( res . find ( it -> first ) == res . end ( ) ) {    								  
							      	      int val = it -> second ;				    								  
							      	      while ( val -- ) ans . push_back ( it -> first ) ;    								  
							      	    }							    								  
							      	  }							    								  
							      	  if ( res . find ( it -> first ) != res . end ( ) ) {	    								  
							      	    int val = it -> second ;				    								  
							      	    while ( val -- ) ans . push_back ( it -> first ) ;	    								  
							      	  }							    								  
							      	}							    								  
							      	for ( auto x : ans ) cout << x << " " ;			    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X	      CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X	    CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X	  CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X
--							      --							    --								  --
static void fill0X ( int m , int n ) {			      void fill0X ( int m , int n ) {				    void fill0X ( int m , int n ) {				  script_not_found : None
  int i , k = 0 , l = 0 ;				      	int i , k = 0 , l = 0 ;					      int i , k = 0 , l = 0 ;					  
  int r = m , c = n ;					      	int r = m , c = n ;					      int r = m , c = n ;					  
  char a [ ] [ ] = new char [ m ] [ n ] ;		      	char a [ m ] [ n ] ;					      char a [ m ] [ n ] ;					  
  char x = 'X' ;					      	char x = 'X' ;						      char x = 'X' ;						  
  while ( k < m && l < n ) {				      	while ( k < m && l < n ) {				      while ( k < m && l < n ) {				  
    for ( i = l ;					      	  for ( i = l ;						    	for ( i = l ;						  
    i < n ;						      	  i < n ;						    	i < n ;							  
    ++ i ) a [ k ] [ i ] = x ;				      	  ++ i ) a [ k ] [ i ] = x ;				    	++ i ) {						  
    k ++ ;						      	  k ++ ;						    	  a [ k ] [ i ] = x ;					  
    for ( i = k ;					      	  for ( i = k ;						    	}							  
    i < m ;						      	  i < m ;						    	k ++ ;							  
    ++ i ) a [ i ] [ n - 1 ] = x ;			      	  ++ i ) a [ i ] [ n - 1 ] = x ;			    	for ( i = k ;						  
    n -- ;						      	  n -- ;						    	i < m ;							  
    if ( k < m ) {					      	  if ( k < m ) {					    	++ i ) {						  
      for ( i = n - 1 ;					      	    for ( i = n - 1 ;					    	  a [ i ] [ n - 1 ] = x ;				  
      i >= l ;						      	    i >= l ;						    	}							  
      -- i ) a [ m - 1 ] [ i ] = x ;			      	    -- i ) a [ m - 1 ] [ i ] = x ;			    	n -- ;							  
      m -- ;						      	    m -- ;						    	if ( k < m ) {						  
    }							      	  }							    	  for ( i = n - 1 ;					  
    if ( l < n ) {					      	  if ( l < n ) {					    	  i >= l ;						  
      for ( i = m - 1 ;					      	    for ( i = m - 1 ;					    	  -- i ) {						  
      i >= k ;						      	    i >= k ;						    	    a [ m - 1 ] [ i ] = x ;				  
      -- i ) a [ i ] [ l ] = x ;			      	    -- i ) a [ i ] [ l ] = x ;				    	  }							  
      l ++ ;						      	    l ++ ;						    	  m -- ;						  
    }							      	  }							    	}							  
    x = ( x == '0' ) ? 'X' : '0' ;			      	  x = ( x == '0' ) ? 'X' : '0' ;			    	if ( l < n ) {						  
  }							      	}							    	  for ( i = m - 1 ;					  
  for ( i = 0 ;						      	for ( i = 0 ;						    	  i >= k ;						  
  i < r ;						      	i < r ;							    	  -- i ) {						  
  i ++ ) {						      	i ++ ) {						    	    a [ i ] [ l ] = x ;					  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	  }							  
    j < c ;						      	  j < c ;						    	  l ++ ;						  
    j ++ ) System . out . print ( a [ i ] [ j ] + " " ) ;     	  j ++ ) printf ( "%c " , a [ i ] [ j ] ) ;		    	}							  
    System . out . println ( ) ;			      	  printf ( "\n" ) ;					    	x = ( x == '0' ) ? 'X' : '0' ;				  
  }							      	}							      }								  
}							      }								      for ( i = 0 ;						  
							      								      i < r ;							  
							      								      i ++ ) {							  
							      								    	for ( int j = 0 ;					  
							      								    	j < c ;							  
							      								    	j ++ ) {						  
							      								    	  cout << a [ i ] [ j ] << " " ;			  
							      								    	}							  
							      								    	cout << endl ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS	      FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS		    FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS		  FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS
--							      --							    --								  --
public static int maxSum ( int stack1 [ ] , int stack2 [ ] ,  int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] success : None
  int sum1 = 0 , sum2 = 0 , sum3 = 0 ;			      	int sum1 = 0 , sum2 = 0 , sum3 = 0 ;			      int sum1 = 0 , sum2 = 0 , sum3 = 0 ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n1 ;						      	i < n1 ;						      i < n1 ;							  
  i ++ ) sum1 += stack1 [ i ] ;				      	i ++ ) sum1 += stack1 [ i ] ;				      i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	sum1 += stack1 [ i ] ;					  
  i < n2 ;						      	i < n2 ;						      }								  
  i ++ ) sum2 += stack2 [ i ] ;				      	i ++ ) sum2 += stack2 [ i ] ;				      for ( int i = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      i < n2 ;							  
  i < n3 ;						      	i < n3 ;						      i ++ ) {							  
  i ++ ) sum3 += stack3 [ i ] ;				      	i ++ ) sum3 += stack3 [ i ] ;				    	sum2 += stack2 [ i ] ;					  
  int top1 = 0 , top2 = 0 , top3 = 0 ;			      	int top1 = 0 , top2 = 0 , top3 = 0 ;			      }								  
  int ans = 0 ;						      	int ans = 0 ;						      for ( int i = 0 ;						  
  while ( true ) {					      	while ( 1 ) {						      i < n3 ;							  
    if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ;  	  if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ;    i ++ ) {							  
    if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ;	      	  if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ;	    	sum3 += stack3 [ i ] ;					  
    if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 	  if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1   }								  
    else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ 	  else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [   int top1 = 0 , top2 = 0 , top3 = 0 ;			  
    else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ 	  else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [   int ans = 0 ;						  
  }							      	}							      while ( true ) {						  
}							      }								    	if ( top1 == n1 || top2 == n2 || top3 == n3 ) {		  
							      								    	  return 0 ;						  
							      								    	}							  
							      								    	if ( sum1 == sum2 && sum2 == sum3 ) {			  
							      								    	  return sum1 ;						  
							      								    	}							  
							      								    	if ( sum1 >= sum2 && sum1 >= sum3 ) {			  
							      								    	  sum1 -= stack1 [ top1 ++ ] ;				  
							      								    	}							  
							      								    	else if ( sum2 >= sum3 && sum2 >= sum3 ) {		  
							      								    	  sum2 -= stack2 [ top2 ++ ] ;				  
							      								    	}							  
							      								    	else if ( sum3 >= sum2 && sum3 >= sum1 ) {		  
							      								    	  sum3 -= stack3 [ top3 ++ ] ;				  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT		      MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT			    MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT			  MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT
--							      --							    --								  --
static int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) {    int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) {	  success : None
  int fw [ ] = new int [ n ] ;				      	int fw [ n ] , bw [ n ] ;				      int fw [ n ] ;						  
  int bw [ ] = new int [ n ] ;				      	int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ;	      int bw [ n ] ;						  
  int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ;	      	fw [ 0 ] = arr [ 0 ] ;					      int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ;	  
  fw [ 0 ] = arr [ 0 ] ;				      	for ( int i = 1 ;					      fw [ 0 ] = arr [ 0 ] ;					  
  for ( int i = 1 ;					      	i < n ;							      for ( int i = 1 ;						  
  i < n ;						      	i ++ ) {						      i < n ;							  
  i ++ ) {						      	  cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) ;	      i ++ ) {							  
    cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] )  	  max_so_far = max ( max_so_far , cur_max ) ;		    	cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) ;	  
    max_so_far = Math . max ( max_so_far , cur_max ) ;	      	  fw [ i ] = cur_max ;					    	max_so_far = max ( max_so_far , cur_max ) ;		  
    fw [ i ] = cur_max ;				      	}							    	fw [ i ] = cur_max ;					  
  }							      	cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ;	      }								  
  cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ;	      	for ( int i = n - 2 ;					      cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ;	  
  for ( int i = n - 2 ;					      	i >= 0 ;						      for ( int i = n - 2 ;					  
  i >= 0 ;						      	i -- ) {						      i >= 0 ;							  
  i -- ) {						      	  cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) ;	      i -- ) {							  
    cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] )  	  max_so_far = max ( max_so_far , cur_max ) ;		    	cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) ;	  
    max_so_far = Math . max ( max_so_far , cur_max ) ;	      	  bw [ i ] = cur_max ;					    	max_so_far = max ( max_so_far , cur_max ) ;		  
    bw [ i ] = cur_max ;				      	}							    	bw [ i ] = cur_max ;					  
  }							      	int fans = max_so_far ;					      }								  
  int fans = max_so_far ;				      	for ( int i = 1 ;					      int fans = max_so_far ;					  
  for ( int i = 1 ;					      	i < n - 1 ;						      for ( int i = 1 ;						  
  i < n - 1 ;						      	i ++ ) fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ;    i < n - 1 ;						  
  i ++ ) fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 	return fans ;						      i ++ ) {							  
  return fans ;						      }								    	fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ;	  
}							      								      }								  
							      								      return fans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1     GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1	    GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1	  GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1
--							      --							    --								  --
static boolean isSubSeqDivisible ( String str ) {	      bool isSubSeqDivisible ( string str ) {			    bool isSubSeqDivisible ( string str ) {			  error : /bin/bash: line 1: 3926879 Segmentation fa
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  ult	   (core dumped) ./GIVEN_LARGE_NUMBER_CHECK_
  int dp [ ] [ ] = new int [ n + 1 ] [ 10 ] ;		      	int dp [ n + 1 ] [ 10 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( n +  SUBSEQUENCE_DIGITS_DIVISIBLE_8_1_cpp
  int arr [ ] = new int [ n + 1 ] ;			      	memset ( dp , 0 , sizeof ( dp ) ) ;			      vector < int > arr ( n + 1 , 0 ) ;			  
  for ( int i = 1 ;					      	int arr [ n + 1 ] ;					      for ( int i = 1 ;						  
  i <= n ;						      	for ( int i = 1 ;					      i <= n ;							  
  i ++ ) arr [ i ] = ( int ) ( str . charAt ( i - 1 ) - '0' ) 	i <= n ;						      i ++ ) {							  
  for ( int i = 1 ;					      	i ++ ) arr [ i ] = str [ i - 1 ] - '0' ;		    	arr [ i ] = ( int ) ( str [ i - 1 ] - '0' ) ;		  
  i <= n ;						      	for ( int i = 1 ;					      }								  
  i ++ ) {						      	i <= n ;						      for ( int i = 1 ;						  
    dp [ i ] [ arr [ i ] % 8 ] = 1 ;			      	i ++ ) {						      i <= n ;							  
    for ( int j = 0 ;					      	  dp [ i ] [ arr [ i ] % 8 ] = 1 ;			      i ++ ) {							  
    j < 8 ;						      	  for ( int j = 0 ;					    	dp [ i ] [ arr [ i ] % 8 ] = 1 ;			  
    j ++ ) {						      	  j < 8 ;						    	for ( int j = 0 ;					  
      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i 	  j ++ ) {						    	j < 8 ;							  
      if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j 	    if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i 	j ++ ) {						  
    }							      	    if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j 	  if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i 
  }							      	  }							    	    dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1  
  for ( int i = 1 ;					      	}							    	  }							  
  i <= n ;						      	for ( int i = 1 ;					    	  if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) {		  
  i ++ ) {						      	i <= n ;						    	    dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;		  
    if ( dp [ i ] [ 0 ] == 1 ) return true ;		      	i ++ ) {						    	  }							  
  }							      	  if ( dp [ i ] [ 0 ] == 1 ) return true ;		    	}							  
  return false ;					      	}							      }								  
}							      	return false ;						      for ( int i = 1 ;						  
							      }								      i <= n ;							  
							      								      i ++ ) {							  
							      								    	if ( dp [ i ] [ 0 ] == 1 ) {				  
							      								    	  return true ;						  
							      								    	}							  
							      								      }								  
							      								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PREFIX_SUM_2D_ARRAY					      PREFIX_SUM_2D_ARRAY					    PREFIX_SUM_2D_ARRAY						  PREFIX_SUM_2D_ARRAY
--							      --							    --								  --
public static void prefixSum2D ( int a [ ] [ ] ) {	      void prefixSum2D ( int a [ ] [ C ] ) {			    int main ( ) {						  script_not_found : None
  int R = a . length ;					      	int psa [ R ] [ C ] ;					      int R = sizeof ( a ) / sizeof ( a [ 0 ] ) ;		  
  int C = a [ 0 ] . length ;				      	psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ;			      int C = sizeof ( a ) / sizeof ( a [ 0 ] ) ;		  
  int psa [ ] [ ] = new int [ R ] [ C ] ;		      	for ( int i = 1 ;					      int psa [ R ] [ C ] ;					  
  psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ;			      	i < C ;							      psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ;				  
  for ( int i = 1 ;					      	i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i    for ( int i = 1 ;						  
  i < C ;						      	for ( int i = 0 ;					      i < C ;							  
  i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i  	i < R ;							      i ++ ) {							  
  for ( int i = 1 ;					      	i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0  	psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i ] ;	  
  i < R ;						      	for ( int i = 1 ;					      }								  
  i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0  	i < R ;							      for ( int i = 1 ;						  
  for ( int i = 1 ;					      	i ++ ) {						      i < R ;							  
  i < R ;						      	  for ( int j = 1 ;					      i ++ ) {							  
  i ++ ) for ( int j = 1 ;				      	  j < C ;						    	psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 ] ;	  
  j < C ;						      	  j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ]    }								  
  j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [  	}							      for ( int i = 1 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      i < R ;							  
  i < R ;						      	i < R ;							      i ++ ) for ( int j = 1 ;					  
  i ++ ) {						      	i ++ ) {						      j < C ;							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ] [  
    j < C ;						      	  j < C ;						      for ( int i = 0 ;						  
    j ++ ) System . out . print ( psa [ i ] [ j ] + " " ) ;   	  j ++ ) cout << psa [ i ] [ j ] << " " ;		      i < R ;							  
    System . out . println ( ) ;			      	  cout << "\n" ;					      i ++ ) {							  
  }							      	}							    	for ( int j = 0 ;					  
}							      }								    	j < C ;							  
							      								    	j ++ ) cout << psa [ i ] [ j ] << " " ;			  
							      								    	cout << endl ;						  
							      								      }								  
							      								      return 0 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM			      MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM			    MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM				  MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM
--							      --							    --								  --
static int maxSum ( int [ ] [ ] mat , int n ) {		      int maxSum ( int mat [ SIZE ] [ SIZE ] , int n ) {	    int maxSum ( int * * mat , int n ) {			  script_not_found : None
  if ( n == 1 ) return mat [ 0 ] [ 0 ] ;		      	if ( n == 1 ) return mat [ 0 ] [ 0 ] ;			      if ( n == 1 ) return mat [ 0 ] [ 0 ] ;			  
  int dp [ ] [ ] = new int [ n ] [ n ] ;		      	int dp [ n ] [ n ] ;					      int dp [ n ] [ n ] ;					  
  int maxSum = Integer . MIN_VALUE , max ;		      	int maxSum = INT_MIN , max ;				      int maxSum = INT_MAX , max ;				  
  for ( int j = 0 ;					      	for ( int j = 0 ;					      for ( int j = 0 ;						  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ;	      	j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ;	      j ++ ) {							  
  for ( int i = n - 2 ;					      	for ( int i = n - 2 ;					    	dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ;		  
  i >= 0 ;						      	i >= 0 ;						      }								  
  i -- ) {						      	i -- ) {						      for ( int i = n - 2 ;					  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					      i >= 0 ;							  
    j < n ;						      	  j < n ;						      i -- ) {							  
    j ++ ) {						      	  j ++ ) {						    	for ( int j = 0 ;					  
      max = Integer . MIN_VALUE ;			      	    max = INT_MIN ;					    	j < n ;							  
      if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 	    if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 	j ++ ) {						  
      if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1  	    if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1  	  max = INT_MAX ;					  
      dp [ i ] [ j ] = mat [ i ] [ j ] + max ;		      	    dp [ i ] [ j ] = mat [ i ] [ j ] + max ;		    	  if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 
    }							      	  }							    	    max = dp [ i + 1 ] [ j - 1 ] ;			  
  }							      	}							    	  }							  
  for ( int j = 0 ;					      	for ( int j = 0 ;					    	  if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1  
  j < n ;						      	j < n ;							    	    max = dp [ i + 1 ] [ j + 1 ] ;			  
  j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j 	j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j 	  }							  
  return maxSum ;					      	return maxSum ;						    	  dp [ i ] [ j ] = mat [ i ] [ j ] + max ;		  
}							      }								    	}							  
							      								      }								  
							      								      for ( int j = 0 ;						  
							      								      j < n ;							  
							      								      j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j 
							      								      return maxSum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
static void bestFit ( int blockSize [ ] , int m , int process void bestFit ( int blockSize [ ] , int m , int processSize [  void bestFit ( int blockSize [ ] , int m , int processSize [  script_not_found : None
  int allocation [ ] = new int [ n ] ;			      	int allocation [ n ] ;					      int allocation [ n ] ;					  
  for ( int i = 0 ;					      	memset ( allocation , - 1 , sizeof ( allocation ) ) ;	      for ( int i = 0 ;						  
  i < allocation . length ;				      	for ( int i = 0 ;					      i < sizeof ( allocation ) / sizeof ( allocation [ 0 ] ) ;	  
  i ++ ) allocation [ i ] = - 1 ;			      	i < n ;							      i ++ ) {							  
  for ( int i = 0 ;					      	i ++ ) {						    	allocation [ i ] = - 1 ;				  
  i < n ;						      	  int bestIdx = - 1 ;					      }								  
  i ++ ) {						      	  for ( int j = 0 ;					      for ( int i = 0 ;						  
    int bestIdx = - 1 ;					      	  j < m ;						      i < n ;							  
    for ( int j = 0 ;					      	  j ++ ) {						      i ++ ) {							  
    j < m ;						      	    if ( blockSize [ j ] >= processSize [ i ] ) {	    	int bestIdx = - 1 ;					  
    j ++ ) {						      	      if ( bestIdx == - 1 ) bestIdx = j ;		    	for ( int j = 0 ;					  
      if ( blockSize [ j ] >= processSize [ i ] ) {	      	      else if ( blockSize [ bestIdx ] > blockSize [ j ] ) b 	j < m ;							  
	if ( bestIdx == - 1 ) bestIdx = j ;		      	    }							    	j ++ ) {						  
	else if ( blockSize [ bestIdx ] > blockSize [ j ] ) b 	  }							    	  if ( blockSize [ j ] >= processSize [ i ] ) {		  
      }							      	  if ( bestIdx != - 1 ) {				    	    if ( bestIdx == - 1 ) {				  
    }							      	    allocation [ i ] = bestIdx ;			    	      bestIdx = j ;					  
    if ( bestIdx != - 1 ) {				      	    blockSize [ bestIdx ] -= processSize [ i ] ;	    	    }							  
      allocation [ i ] = bestIdx ;			      	  }							    	    else if ( blockSize [ bestIdx ] > blockSize [ j ] ) { 
      blockSize [ bestIdx ] -= processSize [ i ] ;	      	}							    	      bestIdx = j ;					  
    }							      	cout << "\nProcess No.\tProcess Size\tBlock no.\n" ;	    	    }							  
  }							      	for ( int i = 0 ;					    	  }							  
  System . out . println ( "\nProcess No.\tProcess Size\tBloc 	i < n ;							    	}							  
  for ( int i = 0 ;					      	i ++ ) {						    	if ( bestIdx != - 1 ) {					  
  i < n ;						      	  cout << "   " << i + 1 << "\t\t" << processSize [ i ] <<  	  allocation [ i ] = bestIdx ;				  
  i ++ ) {						      	  if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 	  blockSize [ bestIdx ] -= processSize [ i ] ;		  
    System . out . print ( "   " + ( i + 1 ) + "\t\t" + proce 	  else cout << "Not Allocated" ;			    	}							  
    if ( allocation [ i ] != - 1 ) System . out . print ( all 	  cout << endl ;					      }								  
    else System . out . print ( "Not Allocated" ) ;	      	}							      cout << "\nProcess No.\tProcess Size\tBlock no." << endl ;  
    System . out . println ( ) ;			      }								      for ( int i = 0 ;						  
  }							      								      i < n ;							  
}							      								      i ++ ) {							  
							      								    	cout << "   " << ( i + 1 ) << "\t\t" << processSize [ i ] 
							      								    	if ( allocation [ i ] != - 1 ) {			  
							      								    	  cout << allocation [ i ] + 1 ;			  
							      								    	}							  
							      								    	else {							  
							      								    	  cout << "Not Allocated" ;				  
							      								    	}							  
							      								    	cout << endl ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS	      WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS	    WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS		  WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS
--							      --							    --								  --
static int countTransformation ( String a , String b ) {      int countTransformation ( string a , string b ) {		    int countTransformation ( string a , string b ) {		  success : None
  int n = a . length ( ) , m = b . length ( ) ;		      	int n = a . size ( ) , m = b . size ( ) ;		      int n = a . length ( ) , m = b . length ( ) ;		  
  if ( m == 0 ) {					      	if ( m == 0 ) return 1 ;				      if ( m == 0 ) return 1 ;					  
    return 1 ;						      	int dp [ m + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( m + 1 , vector < int > ( n +  
  }							      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int i = 0 ;						  
  int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ;	      	for ( int i = 0 ;					      i < m ;							  
  for ( int i = 0 ;					      	i < m ;							      i ++ ) {							  
  i < m ;						      	i ++ ) {						    	for ( int j = i ;					  
  i ++ ) {						      	  for ( int j = i ;					    	j < n ;							  
    for ( int j = i ;					      	  j < n ;						    	j ++ ) {						  
    j < n ;						      	  j ++ ) {						    	  if ( i == 0 ) {					  
    j ++ ) {						      	    if ( i == 0 ) {					    	    if ( j == 0 ) dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) 
      if ( i == 0 ) {					      	      if ( j == 0 ) dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) 	    else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [  
	if ( j == 0 ) {					      	      else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [  	    else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		  
	  dp [ i ] [ j ] = ( a . charAt ( j ) == b . charAt ( 	      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;	    	  }							  
	}						      	    }							    	  else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i  
	else if ( a . charAt ( j ) == b . charAt ( i ) ) {    	    else {						    	  else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		  
	  dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ;	      	      if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ 	}							  
	}						      	      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;	      }								  
	else {						      	    }							      return dp [ m - 1 ] [ n - 1 ] ;				  
	  dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		      	  }							    }								  
	}						      	}							    								  
      }							      	return dp [ m - 1 ] [ n - 1 ] ;				    								  
      else if ( a . charAt ( j ) == b . charAt ( i ) ) {      }								    								  
	dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [  								    								  
      }							      								    								  
      else {						      								    								  
	dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		      								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return dp [ m - 1 ] [ n - 1 ] ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE	      DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE	    DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE
--							      --							    --								  --
static int lbs ( int arr [ ] , int n ) {		      int lbs ( int arr [ ] , int n ) {				    int lbs ( int arr [ ] , int n ) {				  failure : #Results: 9, 10
  int i , j ;						      	int i , j ;						      int i , j ;						  
  int [ ] lis = new int [ n ] ;				      	int * lis = new int [ n ] ;				      int lis [ n ] ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) lis [ i ] = 1 ;				      	i ++ ) lis [ i ] = 1 ;					      i ++ ) {							  
  for ( i = 1 ;						      	for ( i = 1 ;						    	lis [ i ] = 1 ;						  
  i < n ;						      	i < n ;							      }								  
  i ++ ) for ( j = 0 ;					      	i ++ ) for ( j = 0 ;					      for ( i = 1 ;						  
  j < i ;						      	j < i ;							      i < n ;							  
  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ]  	j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ]    i ++ ) for ( j = 0 ;					  
  int [ ] lds = new int [ n ] ;				      	int * lds = new int [ n ] ;				      j < i ;							  
  for ( i = 0 ;						      	for ( i = 0 ;						      j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ]  
  i < n ;						      	i < n ;							      int lds [ n ] ;						  
  i ++ ) lds [ i ] = 1 ;				      	i ++ ) lds [ i ] = 1 ;					      for ( i = 0 ;						  
  for ( i = n - 2 ;					      	for ( i = n - 2 ;					      i < n ;							  
  i >= 0 ;						      	i >= 0 ;						      i ++ ) lds [ i ] = 1 ;					  
  i -- ) for ( j = n - 1 ;				      	i -- ) for ( j = n - 1 ;				      for ( i = n - 2 ;						  
  j > i ;						      	j > i ;							      i >= 0 ;							  
  j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ]  	j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ]    i -- ) for ( j = n - 1 ;					  
  int max = lis [ 0 ] + lds [ 0 ] - 1 ;			      	int max = lis [ 0 ] + lds [ 0 ] - 1 ;			      j > i ;							  
  for ( i = 1 ;						      	for ( i = 1 ;						      j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ]  
  i < n ;						      	i < n ;							      int max = lis [ 0 ] + lds [ 0 ] - 1 ;			  
  i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i 	i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i   for ( i = 1 ;						  
  return max ;						      	return max ;						      i < n ;							  
}							      }								      i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i 
							      								      return max ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINTING_ITEMS_01_KNAPSACK				      PRINTING_ITEMS_01_KNAPSACK				    PRINTING_ITEMS_01_KNAPSACK					  PRINTING_ITEMS_01_KNAPSACK
--							      --							    --								  --
static void printknapSack ( int W , int wt [ ] , int val [ ]  void printknapSack ( int W , int wt [ ] , int val [ ] , int n void printknapSack ( int W , int wt [ ] , int val [ ] , int n script_not_found : None
  int i , w ;						      	int i , w ;						      int i , w ;						  
  int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;		      	int K [ n + 1 ] [ W + 1 ] ;				      int K [ n + 1 ] [ W + 1 ] ;				  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( w = 0 ;					      	  for ( w = 0 ;						    	for ( w = 0 ;						  
    w <= W ;						      	  w <= W ;						    	w <= W ;						  
    w ++ ) {						      	  w ++ ) {						    	w ++ ) {						  
      if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;	      	    if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;		    	  if ( i == 0 || w == 0 ) {				  
      else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . ma 	    else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 	    K [ i ] [ w ] = 0 ;					  
      else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		      	    else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		    	  }							  
    }							      	  }							    	  else if ( wt [ i - 1 ] <= w ) {			  
  }							      	}							    	    K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w 
  int res = K [ n ] [ W ] ;				      	int res = K [ n ] [ W ] ;				    	  }							  
  System . out . println ( res ) ;			      	printf ( "%d\n" , res ) ;				    	  else {						  
  w = W ;						      	w = W ;							    	    K [ i ] [ w ] = K [ i - 1 ] [ w ] ;			  
  for ( i = n ;						      	for ( i = n ;						    	  }							  
  i > 0 && res > 0 ;					      	i > 0 && res > 0 ;					    	}							  
  i -- ) {						      	i -- ) {						      }								  
    if ( res == K [ i - 1 ] [ w ] ) continue ;		      	  if ( res == K [ i - 1 ] [ w ] ) continue ;		      int res = K [ n ] [ W ] ;					  
    else {						      	  else {						      cout << res << endl ;					  
      System . out . print ( wt [ i - 1 ] + " " ) ;	      	    printf ( "%d " , wt [ i - 1 ] ) ;			      w = W ;							  
      res = res - val [ i - 1 ] ;			      	    res = res - val [ i - 1 ] ;				      for ( i = n ;						  
      w = w - wt [ i - 1 ] ;				      	    w = w - wt [ i - 1 ] ;				      i > 0 && res > 0 ;					  
    }							      	  }							      i -- ) {							  
  }							      	}							    	if ( res == K [ i - 1 ] [ w ] ) {			  
}							      }								    	  continue ;						  
							      								    	}							  
							      								    	else {							  
							      								    	  cout << wt [ i - 1 ] << " " ;				  
							      								    	  res = res - val [ i - 1 ] ;				  
							      								    	  w = w - wt [ i - 1 ] ;				  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET
--							      --							    --								  --
static int maximumZeros ( int arr [ ] , int n , int k ) {     int maximumZeros ( int * arr , int n , int k ) {		    int maximumZeros ( int arr [ ] , int n , int k ) {		  script_not_found : None
  int subset [ ] [ ] = new int [ k + 1 ] [ MAX5 + 5 ] ;	      	int subset [ k + 1 ] [ MAX5 + 5 ] ;			      int subset [ k + 1 ] [ MAX5 + 5 ] ;			  
  for ( int [ ] row : subset ) {			      	memset ( subset , - 1 , sizeof ( subset ) ) ;		      for ( int * row = subset ;				  
    Arrays . fill ( row , - 1 ) ;			      	subset [ 0 ] [ 0 ] = 0 ;				      row [ 0 ] [ 0 ] != - 1 ;					  
  }							      	for ( int p = 0 ;					      row ++ ) memset ( row , - 1 , sizeof ( int ) * MAX5 ) ;	  
  subset [ 0 ] [ 0 ] = 0 ;				      	p < n ;							      subset [ 0 ] [ 0 ] = 0 ;					  
  for ( int p = 0 ;					      	p ++ ) {						      for ( int p = 0 ;						  
  p < n ;						      	  int pw2 = 0 , pw5 = 0 ;				      p < n ;							  
  p ++ ) {						      	  while ( arr [ p ] % 2 == 0 ) {			      p ++ ) {							  
    int pw2 = 0 , pw5 = 0 ;				      	    pw2 ++ ;						    	int pw2 = 0 , pw5 = 0 ;					  
    while ( arr [ p ] % 2 == 0 ) {			      	    arr [ p ] /= 2 ;					    	while ( arr [ p ] % 2 == 0 ) {				  
      pw2 ++ ;						      	  }							    	  pw2 ++ ;						  
      arr [ p ] /= 2 ;					      	  while ( arr [ p ] % 5 == 0 ) {			    	  arr [ p ] /= 2 ;					  
    }							      	    pw5 ++ ;						    	}							  
    while ( arr [ p ] % 5 == 0 ) {			      	    arr [ p ] /= 5 ;					    	while ( arr [ p ] % 5 == 0 ) {				  
      pw5 ++ ;						      	  }							    	  pw5 ++ ;						  
      arr [ p ] /= 5 ;					      	  for ( int i = k - 1 ;					    	  arr [ p ] /= 5 ;					  
    }							      	  i >= 0 ;						    	}							  
    for ( int i = k - 1 ;				      	  i -- ) for ( int j = 0 ;				    	for ( int i = k - 1 ;					  
    i >= 0 ;						      	  j < MAX5 ;						    	i >= 0 ;						  
    i -- ) {						      	  j ++ ) if ( subset [ i ] [ j ] != - 1 ) subset [ i + 1 ]  	i -- ) {						  
      for ( int j = 0 ;					      	}							    	  for ( int j = 0 ;					  
      j < MAX5 ;					      	int ans = 0 ;						    	  j < MAX5 ;						  
      j ++ ) {						      	for ( int i = 0 ;					    	  j ++ ) {						  
	if ( subset [ i ] [ j ] != - 1 ) {		      	i < MAX5 ;						    	    if ( subset [ i ] [ j ] != - 1 ) subset [ i + 1 ] [ j 
	  subset [ i + 1 ] [ j + pw5 ] = Math . max ( subset  	i ++ ) ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) ; 	  }							  
	}						      	return ans ;						    	}							  
      }							      }								      }								  
    }							      								      int ans = 0 ;						  
  }							      								      for ( int i = 0 ;						  
  int ans = 0 ;						      								      i < MAX5 ;						  
  for ( int i = 0 ;					      								      i ++ ) ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) ; 
  i < MAX5 ;						      								      return ans ;						  
  i ++ ) {						      								    }								  
    ans = Math . max ( ans , Math . min ( i , subset [ k ] [  								    								  
  }							      								    								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K		      LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K		    LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K		  LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K
--							      --							    --								  --
static int longestSubsequenceCommonSegment ( int k , String s int longestSubsequenceCommonSegment ( int k , string s1 , str int longestSubsequenceCommonSegment ( int k , string s1 , str success : None
  int n = s1 . length ( ) ;				      	int n = s1 . length ( ) ;				      int n = s1 . length ( ) ;					  
  int m = s2 . length ( ) ;				      	int m = s2 . length ( ) ;				      int m = s2 . length ( ) ;					  
  int lcs [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;	      	int lcs [ n + 1 ] [ m + 1 ] ;				      vector < vector < int >> lcs ( n + 1 , vector < int > ( m + 
  int cnt [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ;	      	int cnt [ n + 1 ] [ m + 1 ] ;				      vector < vector < int >> cnt ( n + 1 , vector < int > ( m + 
  for ( int i = 1 ;					      	memset ( lcs , 0 , sizeof ( lcs ) ) ;			      for ( int i = 1 ;						  
  i <= n ;						      	memset ( cnt , 0 , sizeof ( cnt ) ) ;			      i <= n ;							  
  i ++ ) {						      	for ( int i = 1 ;					      i ++ ) {							  
    for ( int j = 1 ;					      	i <= n ;						    	for ( int j = 1 ;					  
    j <= m ;						      	i ++ ) {						    	j <= m ;						  
    j ++ ) {						      	  for ( int j = 1 ;					    	j ++ ) {						  
      lcs [ i ] [ j ] = Math . max ( lcs [ i - 1 ] [ j ] , lc 	  j <= m ;						    	  lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] 
      if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 ) ) c 	  j ++ ) {						    	  if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) {			  
      if ( cnt [ i ] [ j ] >= k ) {			      	    lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] 	    cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 ;	  
	for ( int a = k ;				      	    if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = c 	  }							  
	a <= cnt [ i ] [ j ] ;				      	    if ( cnt [ i ] [ j ] >= k ) {			    	  if ( cnt [ i ] [ j ] >= k ) {				  
	a ++ ) lcs [ i ] [ j ] = Math . max ( lcs [ i ] [ j ] 	      for ( int a = k ;					    	    for ( int a = k ;					  
      }							      	      a <= cnt [ i ] [ j ] ;				    	    a <= cnt [ i ] [ j ] ;				  
    }							      	      a ++ ) lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs  	    a ++ ) {						  
  }							      	    }							    	      lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [ i - 
  return lcs [ n ] [ m ] ;				      	  }							    	    }							  
}							      	}							    	  }							  
							      	return lcs [ n ] [ m ] ;				    	}							  
							      }								      }								  
							      								      return lcs [ n ] [ m ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT	      FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT	    FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT	  FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT
--							      --							    --								  --
static void findTriplets ( int x ) {			      void findTriplets ( int x ) {				    void findTriplets ( int x ) {				  script_not_found : None
  Vector < Integer > fact = new Vector < Integer > ( ) ;      	vector < int > fact ;					      vector < int > fact ;					  
  HashSet < Integer > factors = new HashSet < Integer > ( ) ; 	unordered_set < int > factors ;				      set < int > factors ;					  
  for ( int i = 2 ;					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
  i <= Math . sqrt ( x ) ;				      	i <= sqrt ( x ) ;					      i <= sqrt ( x ) ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( x % i == 0 ) {					      	  if ( x % i == 0 ) {					    	if ( x % i == 0 ) {					  
      fact . add ( i ) ;				      	    fact . push_back ( i ) ;				    	  fact . push_back ( i ) ;				  
      if ( x / i != i ) fact . add ( x / i ) ;		      	    if ( x / i != i ) fact . push_back ( x / i ) ;	    	  if ( x / i != i ) fact . push_back ( x / i ) ;	  
      factors . add ( i ) ;				      	    factors . insert ( i ) ;				    	  factors . insert ( i ) ;				  
      factors . add ( x / i ) ;				      	    factors . insert ( x / i ) ;			    	  factors . insert ( x / i ) ;				  
    }							      	  }							    	}							  
  }							      	}							      }								  
  boolean found = false ;				      	bool found = false ;					      bool found = false ;					  
  int k = fact . size ( ) ;				      	int k = fact . size ( ) ;				      int k = fact . size ( ) ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < k ;						      	i < k ;							      i < k ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int a = fact . get ( i ) ;				      	  int a = fact [ i ] ;					    	int a = fact [ i ] ;					  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < k ;						      	  j < k ;						    	j < k ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      int b = fact . get ( j ) ;			      	    int b = fact [ j ] ;				    	  int b = fact [ j ] ;					  
      if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a  	    if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a  	  if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a  
	System . out . print ( a + " " + b + " " + ( x / ( a  	      cout << a << " " << b << " " << ( x / ( a * b ) ) ;   	    cout << a << " " << b << " " << ( x / ( a * b ) ) <<  
	found = true ;					      	      found = true ;					    	    found = true ;					  
	break ;						      	      break ;						    	    break ;						  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
    if ( found ) break ;				      	  if ( found ) break ;					    	if ( found ) break ;					  
  }							      	}							      }								  
  if ( ! found ) System . out . print ( "-1" ) ;	      	if ( ! found ) cout << "-1" ;				      if ( ! found ) cout << "-1" << endl ;			  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM
--							      --							    --								  --
static int minSum ( int [ ] arr , int n ) {		      int minSum ( int arr [ ] , int n ) {			    int minSum ( int * arr , int n ) {				  success : None
  int [ ] dp = new int [ n ] ;				      	int dp [ n ] ;						      int dp [ n ] ;						  
  if ( n == 1 ) return arr [ 0 ] ;			      	if ( n == 1 ) return arr [ 0 ] ;			      if ( n == 1 ) return arr [ 0 ] ;				  
  if ( n == 2 ) return Math . min ( arr [ 0 ] , arr [ 1 ] ) ; 	if ( n == 2 ) return min ( arr [ 0 ] , arr [ 1 ] ) ;	      if ( n == 2 ) return min ( arr [ 0 ] , arr [ 1 ] ) ;	  
  if ( n == 3 ) return Math . min ( arr [ 0 ] , Math . min (  	if ( n == 3 ) return min ( arr [ 0 ] , min ( arr [ 1 ] , ar   if ( n == 3 ) return min ( arr [ 0 ] , min ( arr [ 1 ] , ar 
  if ( n == 4 ) return Math . min ( Math . min ( arr [ 0 ] ,  	if ( n == 4 ) return min ( min ( arr [ 0 ] , arr [ 1 ] ) ,    if ( n == 4 ) return min ( min ( arr [ 0 ] , arr [ 1 ] ) ,  
  dp [ 0 ] = arr [ 0 ] ;				      	dp [ 0 ] = arr [ 0 ] ;					      dp [ 0 ] = arr [ 0 ] ;					  
  dp [ 1 ] = arr [ 1 ] ;				      	dp [ 1 ] = arr [ 1 ] ;					      dp [ 1 ] = arr [ 1 ] ;					  
  dp [ 2 ] = arr [ 2 ] ;				      	dp [ 2 ] = arr [ 2 ] ;					      dp [ 2 ] = arr [ 2 ] ;					  
  dp [ 3 ] = arr [ 3 ] ;				      	dp [ 3 ] = arr [ 3 ] ;					      dp [ 3 ] = arr [ 3 ] ;					  
  for ( int i = 4 ;					      	for ( int i = 4 ;					      for ( int i = 4 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) dp [ i ] = arr [ i ] + Math . min ( Math . min ( dp  	i ++ ) dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp   i ++ ) {							  
  return Math . min ( Math . min ( dp [ n - 1 ] , dp [ n - 2  	return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp 	dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i  
}							      }								      }								  
							      								      return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH
--							      --							    --								  --
static boolean isValidString ( String str ) {		      bool isValidString ( string str ) {			    bool isValidString ( string str ) {				  script_not_found : None
  int freq [ ] = new int [ CHARS ] ;			      	int freq [ CHARS ] = {					      int freq [ CHARS ] ;					  
  for ( int i = 0 ;					      	  0 }							      for ( int i = 0 ;						  
  i < str . length ( ) ;				      	  ;							      i < str . length ( ) ;					  
  i ++ ) {						      	  for ( int i = 0 ;					      i ++ ) freq [ str [ i ] - 'a' ] ++ ;			  
    freq [ str . charAt ( i ) - 'a' ] ++ ;		      	  i < str . length ( ) ;				      int i , freq1 = 0 , count_freq1 = 0 ;			  
  }							      	  i ++ ) freq [ str [ i ] - 'a' ] ++ ;			      for ( i = 0 ;						  
  int i , freq1 = 0 , count_freq1 = 0 ;			      	  int i , freq1 = 0 , count_freq1 = 0 ;			      i < CHARS ;						  
  for ( i = 0 ;						      	  for ( i = 0 ;						      i ++ ) {							  
  i < CHARS ;						      	  i < CHARS ;						    	if ( freq [ i ] != 0 ) {				  
  i ++ ) {						      	  i ++ ) {						    	  freq1 = freq [ i ] ;					  
    if ( freq [ i ] != 0 ) {				      	    if ( freq [ i ] != 0 ) {				    	  count_freq1 = 1 ;					  
      freq1 = freq [ i ] ;				      	      freq1 = freq [ i ] ;				    	  break ;						  
      count_freq1 = 1 ;					      	      count_freq1 = 1 ;					    	}							  
      break ;						      	      break ;						      }								  
    }							      	    }							      int j , freq2 = 0 , count_freq2 = 0 ;			  
  }							      	  }							      for ( j = i + 1 ;						  
  int j , freq2 = 0 , count_freq2 = 0 ;			      	  int j , freq2 = 0 , count_freq2 = 0 ;			      j < CHARS ;						  
  for ( j = i + 1 ;					      	  for ( j = i + 1 ;					      j ++ ) {							  
  j < CHARS ;						      	  j < CHARS ;						    	if ( freq [ j ] != 0 ) {				  
  j ++ ) {						      	  j ++ ) {						    	  if ( freq [ j ] == freq1 ) count_freq1 ++ ;		  
    if ( freq [ j ] != 0 ) {				      	    if ( freq [ j ] != 0 ) {				    	  else {						  
      if ( freq [ j ] == freq1 ) {			      	      if ( freq [ j ] == freq1 ) count_freq1 ++ ;	    	    count_freq2 = 1 ;					  
	count_freq1 ++ ;				      	      else {						    	    freq2 = freq [ j ] ;				  
      }							      		count_freq2 = 1 ;				    	    break ;						  
      else {						      		freq2 = freq [ j ] ;				    	  }							  
	count_freq2 = 1 ;				      		break ;						    	}							  
	freq2 = freq [ j ] ;				      	      }							      }								  
	break ;						      	    }							      for ( int k = j + 1 ;					  
      }							      	  }							      k < CHARS ;						  
    }							      	  for ( int k = j + 1 ;					      k ++ ) {							  
  }							      	  k < CHARS ;						    	if ( freq [ k ] != 0 ) {				  
  for ( int k = j + 1 ;					      	  k ++ ) {						    	  if ( freq [ k ] == freq1 ) count_freq1 ++ ;		  
  k < CHARS ;						      	    if ( freq [ k ] != 0 ) {				    	  if ( freq [ k ] == freq2 ) count_freq2 ++ ;		  
  k ++ ) {						      	      if ( freq [ k ] == freq1 ) count_freq1 ++ ;	    	  else return false ;					  
    if ( freq [ k ] != 0 ) {				      	      if ( freq [ k ] == freq2 ) count_freq2 ++ ;	    	}							  
      if ( freq [ k ] == freq1 ) {			      	      else return false ;				    	if ( count_freq1 > 1 && count_freq2 > 1 ) return false ;  
	count_freq1 ++ ;				      	    }							      }								  
      }							      	    if ( count_freq1 > 1 && count_freq2 > 1 ) return false    return true ;						  
      if ( freq [ k ] == freq2 ) {			      	  }							    }								  
	count_freq2 ++ ;				      	  return true ;						    								  
      }							      	}							    								  
      else {						      								    								  
	return false ;					      								    								  
      }							      								    								  
    }							      								    								  
    if ( count_freq1 > 1 && count_freq2 > 1 ) {		      								    								  
      return false ;					      								    								  
    }							      								    								  
  }							      								    								  
  return true ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS
--							      --							    --								  --
static int largestKSubmatrix ( int [ ] [ ] a ) {	      int largestKSubmatrix ( int a [ ] [ Col ] ) {		    int largestKSubmatrix ( int * * a ) {			  script_not_found : None
  int [ ] [ ] dp = new int [ Row ] [ Col ] ;		      	int dp [ Row ] [ Col ] ;				      int dp [ Row ] [ Col ] ;					  
  int result = 0 ;					      	memset ( dp , sizeof ( dp ) , 0 ) ;			      int result = 0 ;						  
  for ( int i = 0 ;					      	int result = 0 ;					      for ( int i = 0 ;						  
  i < Row ;						      	for ( int i = 0 ;					      i < Row ;							  
  i ++ ) {						      	i < Row ;						      i ++ ) {							  
    for ( int j = 0 ;					      	i ++ ) {						    	for ( int j = 0 ;					  
    j < Col ;						      	  for ( int j = 0 ;					    	j < Col ;						  
    j ++ ) {						      	  j < Col ;						    	j ++ ) {						  
      if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1 ;	      	  j ++ ) {						    	  if ( i == 0 || j == 0 ) {				  
      else {						      	    if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1 ;	    	    dp [ i ] [ j ] = 1 ;				  
	if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [  	    else {						    	  }							  
	  dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [  	      if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [  	  else {						  
	}						      	      else dp [ i ] [ j ] = 1 ;				    	    if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [  
	else dp [ i ] [ j ] = 1 ;			      	    }							    	      dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [  
      }							      	    result = max ( result , dp [ i ] [ j ] ) ;		    	    }							  
      result = result > dp [ i ] [ j ] ? result : dp [ i ] [  	  }							    	    else {						  
    }							      	}							    	      dp [ i ] [ j ] = 1 ;				  
  }							      	return result ;						    	    }							  
  return result ;					      }								    	  }							  
}							      								    	  result = result > dp [ i ] [ j ] ? result : dp [ i ] [  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
static void worstFit ( int blockSize [ ] , int m , int proces void worstFit ( int blockSize [ ] , int m , int processSize [ void worstFit ( int blockSize [ ] , int m , int processSize [ script_not_found : None
  int allocation [ ] = new int [ n ] ;			      	int allocation [ n ] ;					      int allocation [ n ] ;					  
  for ( int i = 0 ;					      	memset ( allocation , - 1 , sizeof ( allocation ) ) ;	      for ( int i = 0 ;						  
  i < allocation . length ;				      	for ( int i = 0 ;					      i < sizeof ( allocation ) / sizeof ( allocation [ 0 ] ) ;	  
  i ++ ) allocation [ i ] = - 1 ;			      	i < n ;							      i ++ ) {							  
  for ( int i = 0 ;					      	i ++ ) {						    	allocation [ i ] = - 1 ;				  
  i < n ;						      	  int wstIdx = - 1 ;					      }								  
  i ++ ) {						      	  for ( int j = 0 ;					      for ( int i = 0 ;						  
    int wstIdx = - 1 ;					      	  j < m ;						      i < n ;							  
    for ( int j = 0 ;					      	  j ++ ) {						      i ++ ) {							  
    j < m ;						      	    if ( blockSize [ j ] >= processSize [ i ] ) {	    	int wstIdx = - 1 ;					  
    j ++ ) {						      	      if ( wstIdx == - 1 ) wstIdx = j ;			    	for ( int j = 0 ;					  
      if ( blockSize [ j ] >= processSize [ i ] ) {	      	      else if ( blockSize [ wstIdx ] < blockSize [ j ] ) ws 	j < m ;							  
	if ( wstIdx == - 1 ) wstIdx = j ;		      	    }							    	j ++ ) {						  
	else if ( blockSize [ wstIdx ] < blockSize [ j ] ) ws 	  }							    	  if ( blockSize [ j ] >= processSize [ i ] ) {		  
      }							      	  if ( wstIdx != - 1 ) {				    	    if ( wstIdx == - 1 ) {				  
    }							      	    allocation [ i ] = wstIdx ;				    	      wstIdx = j ;					  
    if ( wstIdx != - 1 ) {				      	    blockSize [ wstIdx ] -= processSize [ i ] ;		    	    }							  
      allocation [ i ] = wstIdx ;			      	  }							    	    else if ( blockSize [ wstIdx ] < blockSize [ j ] ) {  
      blockSize [ wstIdx ] -= processSize [ i ] ;	      	}							    	      wstIdx = j ;					  
    }							      	cout << "\nProcess No.\tProcess Size\tBlock no.\n" ;	    	    }							  
  }							      	for ( int i = 0 ;					    	  }							  
  System . out . println ( "\nProcess No.\tProcess Size\tBloc 	i < n ;							    	}							  
  for ( int i = 0 ;					      	i ++ ) {						    	if ( wstIdx != - 1 ) {					  
  i < n ;						      	  cout << "   " << i + 1 << "\t\t" << processSize [ i ] <<  	  allocation [ i ] = wstIdx ;				  
  i ++ ) {						      	  if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 	  blockSize [ wstIdx ] -= processSize [ i ] ;		  
    System . out . print ( "   " + ( i + 1 ) + "\t\t" + proce 	  else cout << "Not Allocated" ;			    	}							  
    if ( allocation [ i ] != - 1 ) System . out . print ( all 	  cout << endl ;					      }								  
    else System . out . print ( "Not Allocated" ) ;	      	}							      cout << "\nProcess No.\tProcess Size\tBlock no." << endl ;  
    System . out . println ( ) ;			      }								      for ( int i = 0 ;						  
  }							      								      i < n ;							  
}							      								      i ++ ) {							  
							      								    	cout << "   " << ( i + 1 ) << "\t\t" << processSize [ i ] 
							      								    	if ( allocation [ i ] != - 1 ) {			  
							      								    	  cout << allocation [ i ] + 1 ;			  
							      								    	}							  
							      								    	else {							  
							      								    	  cout << "Not Allocated" ;				  
							      								    	}							  
							      								    	cout << endl ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6	      PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6	    PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6	  PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6
--							      --							    --								  --
static void greatest ( String s ) {			      void greatest ( string s ) {				    void greatest ( string s ) {				  script_not_found : None
  int n = s . length ( ) ;				      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
  int [ ] a = new int [ n ] ;				      	int a [ n ] ;						      int a [ n ] ;						  
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    a [ i ] = s . charAt ( i ) - '0' ;			      	  a [ i ] = s [ i ] - '0' ;				    	a [ i ] = s [ i ] - '0' ;				  
    sum += a [ i ] ;					      	  sum += a [ i ] ;					    	sum += a [ i ] ;					  
  }							      	}							      }								  
  if ( a [ n - 1 ] % 2 != 0 ) {				      	if ( a [ n - 1 ] % 2 ) {				      if ( a [ n - 1 ] % 2 != 0 ) {				  
    if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 	  if ( a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 	if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 
      System . out . println ( "-1" ) ;			      	    cout << "-1" << endl ;				    	else cout << n << endl ;				  
    }							      	  }							      }								  
    else {						      	  else {						      else {							  
      System . out . println ( n ) ;			      	    cout << n << endl ;					    	int re = sum % 3 ;					  
    }							      	  }							    	int del = - 1 ;						  
  }							      	}							    	int flag = 0 ;						  
  else {						      	else {							    	for ( int i = 0 ;					  
    int re = sum % 3 ;					      	  int re = sum % 3 ;					    	i < n - 1 ;						  
    int del = - 1 ;					      	  int del = - 1 ;					    	i ++ ) {						  
    int flag = 0 ;					      	  int flag = 0 ;					    	  if ( ( a [ i ] ) % 3 == re ) {			  
    for ( int i = 0 ;					      	  for ( int i = 0 ;					    	    if ( a [ i + 1 ] > a [ i ] ) {			  
    i < n - 1 ;						      	  i < n - 1 ;						    	      del = i ;						  
    i ++ ) {						      	  i ++ ) {						    	      flag = 1 ;					  
      if ( ( a [ i ] ) % 3 == re ) {			      	    if ( ( a [ i ] ) % 3 == re ) {			    	      break ;						  
	if ( a [ i + 1 ] > a [ i ] ) {			      	      if ( a [ i + 1 ] > a [ i ] ) {			    	    }							  
	  del = i ;					      		del = i ;					    	    else del = i ;					  
	  flag = 1 ;					      		flag = 1 ;					    	  }							  
	  break ;					      		break ;						    	}							  
	}						      	      }							    	if ( flag == 0 ) {					  
	else {						      	      else {						    	  if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) de 
	  del = i ;					      		del = i ;					    	}							  
	}						      	      }							    	if ( del == - 1 ) cout << - 1 << endl ;			  
      }							      	    }							    	else cout << del + 1 << endl ;				  
    }							      	  }							      }								  
    if ( flag == 0 ) {					      	  if ( flag == 0 ) {					    }								  
      if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) de 	    if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) d 								  
    }							      	  }							    								  
    if ( del == - 1 ) System . out . println ( - 1 ) ;	      	  if ( del == - 1 ) cout << - 1 << endl ;		    								  
    else {						      	  else {						    								  
      System . out . println ( del + 1 ) ;		      	    cout << del + 1 << endl ;				    								  
    }							      	  }							    								  
  }							      	}							    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION		      MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION		    MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION		  MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION
--							      --							    --								  --
static int minInitialPoints ( int points [ ] [ ] , int R , in int minInitialPoints ( int points [ ] [ C ] ) {		    int minInitialPoints ( int points [ ] [ 3 ] , int R , int C ) script_not_found : None
  int dp [ ] [ ] = new int [ R ] [ C ] ;		      	int dp [ R ] [ C ] ;					      int dp [ R ] [ C ] ;					  
  int m = R , n = C ;					      	int m = R , n = C ;					      int m = R , n = C ;					  
  dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 	dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1   dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 
  for ( int i = m - 2 ;					      	for ( int i = m - 2 ;					      for ( int i = m - 2 ;					  
  i >= 0 ;						      	i >= 0 ;						      i >= 0 ;							  
  i -- ) dp [ i ] [ n - 1 ] = Math . max ( dp [ i + 1 ] [ n - 	i -- ) dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] -    i -- ) {							  
  for ( int j = n - 2 ;					      	for ( int j = n - 2 ;					    	dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - point 
  j >= 0 ;						      	j >= 0 ;						      }								  
  j -- ) dp [ m - 1 ] [ j ] = Math . max ( dp [ m - 1 ] [ j + 	j -- ) dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] -    for ( int j = n - 2 ;					  
  for ( int i = m - 2 ;					      	for ( int i = m - 2 ;					      j >= 0 ;							  
  i >= 0 ;						      	i >= 0 ;						      j -- ) {							  
  i -- ) {						      	i -- ) {						    	dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] - point 
    for ( int j = n - 2 ;				      	  for ( int j = n - 2 ;					      }								  
    j >= 0 ;						      	  j >= 0 ;						      for ( int i = m - 2 ;					  
    j -- ) {						      	  j -- ) {						      i >= 0 ;							  
      int min_points_on_exit = Math . min ( dp [ i + 1 ] [ j  	    int min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp    i -- ) {							  
      dp [ i ] [ j ] = Math . max ( min_points_on_exit - poin 	    dp [ i ] [ j ] = max ( min_points_on_exit - points [ i  	for ( int j = n - 2 ;					  
    }							      	  }							    	j >= 0 ;						  
  }							      	}							    	j -- ) {						  
  return dp [ 0 ] [ 0 ] ;				      	return dp [ 0 ] [ 0 ] ;					    	  int min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp  
}							      }								    	  dp [ i ] [ j ] = max ( min_points_on_exit - points [ i  
							      								    	}							  
							      								      }								  
							      								      return dp [ 0 ] [ 0 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS	      FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS	    FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS	  FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS
--							      --							    --								  --
static void findSmallestRange ( int arr [ ] [ ] , int n , int void findSmallestRange ( int arr [ ] [ N ] , int n , int k )  void findSmallestRange ( int arr [ ] [ 4 ] , int n , int k )  script_not_found : None
  int i , minval , maxval , minrange , minel = 0 , maxel = 0  	int i , minval , maxval , minrange , minel , maxel , flag ,   int i , minval , maxval , minrange , minel = 0 , maxel = 0  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i <= k ;						      	i <= k ;						      i <= k ;							  
  i ++ ) {						      	i ++ ) ptr [ i ] = 0 ;					      i ++ ) ptr [ i ] = 0 ;					  
    ptr [ i ] = 0 ;					      	minrange = INT_MAX ;					      minrange = INT_MAX ;					  
  }							      	while ( 1 ) {						      while ( true ) {						  
  minrange = Integer . MAX_VALUE ;			      	  minind = - 1 ;					    	minind = - 1 ;						  
  while ( true ) {					      	  minval = INT_MAX ;					    	minval = INT_MAX ;					  
    minind = - 1 ;					      	  maxval = INT_MIN ;					    	maxval = INT_MIN ;					  
    minval = Integer . MAX_VALUE ;			      	  flag = 0 ;						    	flag = 0 ;						  
    maxval = Integer . MIN_VALUE ;			      	  for ( i = 0 ;						    	for ( i = 0 ;						  
    flag = 0 ;						      	  i < k ;						    	i < k ;							  
    for ( i = 0 ;					      	  i ++ ) {						    	i ++ ) {						  
    i < k ;						      	    if ( ptr [ i ] == n ) {				    	  if ( ptr [ i ] == n ) {				  
    i ++ ) {						      	      flag = 1 ;					    	    flag = 1 ;						  
      if ( ptr [ i ] == n ) {				      	      break ;						    	    break ;						  
	flag = 1 ;					      	    }							    	  }							  
	break ;						      	    if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval  	  if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval  
      }							      	      minind = i ;					    	    minind = i ;					  
      if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval  	      minval = arr [ i ] [ ptr [ i ] ] ;		    	    minval = arr [ i ] [ ptr [ i ] ] ;			  
	minind = i ;					      	    }							    	  }							  
	minval = arr [ i ] [ ptr [ i ] ] ;		      	    if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval  	  if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval  
      }							      	      maxval = arr [ i ] [ ptr [ i ] ] ;		    	}							  
      if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval  	    }							    	if ( flag == 1 ) break ;				  
	maxval = arr [ i ] [ ptr [ i ] ] ;		      	  }							    	ptr [ minind ] ++ ;					  
      }							      	  if ( flag ) break ;					    	if ( ( maxval - minval ) < minrange ) {			  
    }							      	  ptr [ minind ] ++ ;					    	  minel = minval ;					  
    if ( flag == 1 ) {					      	  if ( ( maxval - minval ) < minrange ) {		    	  maxel = maxval ;					  
      break ;						      	    minel = minval ;					    	  minrange = maxel - minel ;				  
    }							      	    maxel = maxval ;					    	}							  
    ptr [ minind ] ++ ;					      	    minrange = maxel - minel ;				      }								  
    if ( ( maxval - minval ) < minrange ) {		      	  }							      printf ( "The smallest range is [%d , %d]\n" , minel , maxe 
      minel = minval ;					      	}							    }								  
      maxel = maxval ;					      	printf ( "The smallest range is [%d , %d]\n" , minel , maxe 								  
      minrange = maxel - minel ;			      }								    								  
    }							      								    								  
  }							      								    								  
  System . out . printf ( "The smallest range is [%d , %d]\n" 								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS	      REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS	    REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS	  REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS
--							      --							    --								  --
static String simplify ( String str ) {			      char * simplify ( string str ) {				    string simplify ( string str ) {				  script_not_found : None
  int len = str . length ( ) ;				      	int len = str . length ( ) ;				      int len = str . length ( ) ;				  
  char res [ ] = new char [ len ] ;			      	char * res = new char ( len ) ;				      char res [ len ] ;					  
  int index = 0 , i = 0 ;				      	int index = 0 , i = 0 ;					      int index = 0 , i = 0 ;					  
  Stack < Integer > s = new Stack < Integer > ( ) ;	      	stack < int > s ;					      stack < int > s ;						  
  s . push ( 0 ) ;					      	s . push ( 0 ) ;					      s . push ( 0 ) ;						  
  while ( i < len ) {					      	while ( i < len ) {					      while ( i < len ) {					  
    if ( str . charAt ( i ) == '+' ) {			      	  if ( str [ i ] == '+' ) {				    	if ( str [ i ] == '+' ) {				  
      if ( s . peek ( ) == 1 ) res [ index ++ ] = '-' ;	      	    if ( s . top ( ) == 1 ) res [ index ++ ] = '-' ;	    	  if ( s . top ( ) == 1 ) {				  
      if ( s . peek ( ) == 0 ) res [ index ++ ] = '+' ;	      	    if ( s . top ( ) == 0 ) res [ index ++ ] = '+' ;	    	    res [ index ++ ] = '-' ;				  
    }							      	  }							    	  }							  
    else if ( str . charAt ( i ) == '-' ) {		      	  else if ( str [ i ] == '-' ) {			    	  if ( s . top ( ) == 0 ) {				  
      if ( s . peek ( ) == 1 ) res [ index ++ ] = '+' ;	      	    if ( s . top ( ) == 1 ) res [ index ++ ] = '+' ;	    	    res [ index ++ ] = '+' ;				  
      else if ( s . peek ( ) == 0 ) res [ index ++ ] = '-' ;  	    else if ( s . top ( ) == 0 ) res [ index ++ ] = '-' ;   	  }							  
    }							      	  }							    	}							  
    else if ( str . charAt ( i ) == '(' && i > 0 ) {	      	  else if ( str [ i ] == '(' && i > 0 ) {		    	else if ( str [ i ] == '-' ) {				  
      if ( str . charAt ( i - 1 ) == '-' ) {		      	    if ( str [ i - 1 ] == '-' ) {			    	  if ( s . top ( ) == 1 ) {				  
	int x = ( s . peek ( ) == 1 ) ? 0 : 1 ;		      	      int x = ( s . top ( ) == 1 ) ? 0 : 1 ;		    	    res [ index ++ ] = '+' ;				  
	s . push ( x ) ;				      	      s . push ( x ) ;					    	  }							  
      }							      	    }							    	  else if ( s . top ( ) == 0 ) {			  
      else if ( str . charAt ( i - 1 ) == '+' ) s . push ( s  	    else if ( str [ i - 1 ] == '+' ) s . push ( s . top ( ) 	    res [ index ++ ] = '-' ;				  
    }							      	  }							    	  }							  
    else if ( str . charAt ( i ) == ')' ) s . pop ( ) ;	      	  else if ( str [ i ] == ')' ) s . pop ( ) ;		    	}							  
    else res [ index ++ ] = str . charAt ( i ) ;	      	  else res [ index ++ ] = str [ i ] ;			    	else if ( str [ i ] == '(' && i > 0 ) {			  
    i ++ ;						      	  i ++ ;						    	  if ( str [ i - 1 ] == '-' ) {				  
  }							      	}							    	    int x = ( s . top ( ) == 1 ) ? 0 : 1 ;		  
  return new String ( res ) ;				      	return res ;						    	    s . push ( x ) ;					  
}							      }								    	  }							  
							      								    	  else if ( str [ i - 1 ] == '+' ) {			  
							      								    	    s . push ( s . top ( ) ) ;				  
							      								    	  }							  
							      								    	}							  
							      								    	else if ( str [ i ] == ')' ) {				  
							      								    	  s . pop ( ) ;						  
							      								    	}							  
							      								    	else {							  
							      								    	  res [ index ++ ] = str [ i ] ;			  
							      								    	}							  
							      								    	i ++ ;							  
							      								      }								  
							      								      return string ( res , index ) ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION		      MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION		    MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION			  MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION
--							      --							    --								  --
static void minMaxValues ( int [ ] arr , int n , int m ) {    e9 int minMaxValues ( int arr [ ] , int n , int m ) {	    void minMaxValues ( int * arr , int n , int m ) {		  script_not_found : None
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < ( n + m ) ;					      	i < ( n + m ) ;						      i < ( n + m ) ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    sum += arr [ i ] ;					      	  sum += arr [ i ] ;					    	sum += arr [ i ] ;					  
    arr [ i ] += 50 ;					      	  arr [ i ] += 50 ;					    	arr [ i ] += 50 ;					  
  }							      	}							      }								  
  boolean dp [ ] [ ] = new boolean [ MAX + 1 ] [ MAX * MAX +  	bool dp [ MAX + 1 ] [ MAX * MAX + 1 ] ;			      bool dp [ MAX + 1 ] [ MAX * MAX + 1 ] ;			  
  dp [ 0 ] [ 0 ] = true ;				      	memset ( dp , 0 , sizeof ( dp ) ) ;			      dp [ 0 ] [ 0 ] = true ;					  
  for ( int i = 0 ;					      	dp [ 0 ] [ 0 ] = 1 ;					      for ( int i = 0 ;						  
  i < ( n + m ) ;					      	for ( int i = 0 ;					      i < ( n + m ) ;						  
  i ++ ) {						      	i < ( n + m ) ;						      i ++ ) {							  
    for ( int k = Math . min ( n , i + 1 ) ;		      	i ++ ) {						    	for ( int k = min ( n , i + 1 ) ;			  
    k >= 1 ;						      	  for ( int k = min ( n , i + 1 ) ;			    	k >= 1 ;						  
    k -- ) {						      	  k >= 1 ;						    	k -- ) {						  
      for ( int j = 0 ;					      	  k -- ) {						    	  for ( int j = 0 ;					  
      j < MAX * MAX + 1 ;				      	    for ( int j = 0 ;					    	  j < MAX * MAX + 1 ;					  
      j ++ ) {						      	    j < MAX * MAX + 1 ;					    	  j ++ ) {						  
	if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ]  	    j ++ ) {						    	    if ( dp [ k - 1 ] [ j ] ) {				  
      }							      	      if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ]  	      dp [ k ] [ j + arr [ i ] ] = true ;		  
    }							      	    }							    	    }							  
  }							      	  }							    	  }							  
  double max_value = - 1 * INF , min_value = INF ;	      	}							    	}							  
  for ( int i = 0 ;					      	int max_value = - INF , min_value = INF ;		      }								  
  i < MAX * MAX + 1 ;					      	for ( int i = 0 ;					      double max_value = - 1 * INF , min_value = INF ;		  
  i ++ ) {						      	i < MAX * MAX + 1 ;					      for ( int i = 0 ;						  
    if ( dp [ n ] [ i ] ) {				      	i ++ ) {						      i < MAX * MAX + 1 ;					  
      int temp = i - 50 * n ;				      	  if ( dp [ n ] [ i ] ) {				      i ++ ) {							  
      max_value = Math . max ( max_value , temp * ( sum - tem 	    int temp = i - 50 * n ;				    	if ( dp [ n ] [ i ] ) {					  
      min_value = Math . min ( min_value , temp * ( sum - tem 	    max_value = max ( max_value , temp * ( sum - temp ) ) ; 	  int temp = i - 50 * n ;				  
    }							      	    min_value = min ( min_value , temp * ( sum - temp ) ) ; 	  max_value = max ( max_value , temp * ( sum - temp ) ) ; 
  }							      	  }							    	  min_value = min ( min_value , temp * ( sum - temp ) ) ; 
  System . out . print ( "Maximum Value: " + ( int ) max_valu 	}							    	}							  
}							      	cout << "Maximum Value: " << max_value << "\n" << "Minimum    }								  
							      }								      cout << "Maximum Value: " << ( int ) max_value << "\n" << " 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING	      DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING	    DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING		  DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING
--							      --							    --								  --
static int minPalPartion ( String str ) {		      int minPalPartion ( char * str ) {			    int minPalPartion ( string str ) {				  script_not_found : None
  int n = str . length ( ) ;				      	int n = strlen ( str ) ;				      int n = str . length ( ) ;				  
  int [ ] [ ] C = new int [ n ] [ n ] ;			      	int C [ n ] [ n ] ;					      vector < vector < bool >> C ( n , vector < bool > ( n , fal 
  boolean [ ] [ ] P = new boolean [ n ] [ n ] ;		      	bool P [ n ] [ n ] ;					      vector < vector < bool >> P ( n , vector < bool > ( n , fal 
  int i , j , k , L ;					      	int i , j , k , L ;					      int i , j , k , L ;					  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    P [ i ] [ i ] = true ;				      	  P [ i ] [ i ] = true ;				    	P [ i ] [ i ] = true ;					  
    C [ i ] [ i ] = 0 ;					      	  C [ i ] [ i ] = 0 ;					    	C [ i ] [ i ] = 0 ;					  
  }							      	}							      }								  
  for ( L = 2 ;						      	for ( L = 2 ;						      for ( L = 2 ;						  
  L <= n ;						      	L <= n ;						      L <= n ;							  
  L ++ ) {						      	L ++ ) {						      L ++ ) {							  
    for ( i = 0 ;					      	  for ( i = 0 ;						    	for ( i = 0 ;						  
    i < n - L + 1 ;					      	  i < n - L + 1 ;					    	i < n - L + 1 ;						  
    i ++ ) {						      	  i ++ ) {						    	i ++ ) {						  
      j = i + L - 1 ;					      	    j = i + L - 1 ;					    	  j = i + L - 1 ;					  
      if ( L == 2 ) P [ i ] [ j ] = ( str . charAt ( i ) == s 	    if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ]  	  if ( L == 2 ) {					  
      else P [ i ] [ j ] = ( str . charAt ( i ) == str . char 	    else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [  	    P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ;	  
      if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ;	      	    if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ;	    	  }							  
      else {						      	    else {						    	  else {						  
	C [ i ] [ j ] = Integer . MAX_VALUE ;		      	      C [ i ] [ j ] = INT_MAX ;				    	    P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 
	for ( k = i ;					      	      for ( k = i ;					    	  }							  
	k <= j - 1 ;					      	      k <= j - 1 ;					    	  if ( P [ i ] [ j ] == true ) {			  
	k ++ ) C [ i ] [ j ] = Integer . min ( C [ i ] [ j ]  	      k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ]  	    C [ i ] [ j ] = 0 ;					  
      }							      	    }							    	  }							  
    }							      	  }							    	  else {						  
  }							      	}							    	    C [ i ] [ j ] = INT_MAX ;				  
  return C [ 0 ] [ n - 1 ] ;				      	return C [ 0 ] [ n - 1 ] ;				    	    for ( k = i ;					  
}							      }								    	    k <= j - 1 ;					  
							      								    	    k ++ ) {						  
							      								    	      C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] 
							      								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return C [ 0 ] [ n - 1 ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRUFER_CODE_TREE_CREATION				      PRUFER_CODE_TREE_CREATION					    PRUFER_CODE_TREE_CREATION					  PRUFER_CODE_TREE_CREATION
--							      --							    --								  --
static void printTreeEdges ( int prufer [ ] , int m ) {	      void printTreeEdges ( int prufer [ ] , int m ) {		    void print_tree_edges ( int prufer [ ] , int m ) {		  script_not_found : None
  int vertices = m + 2 ;				      	int vertices = m + 2 ;					      int vertices = m + 2 ;					  
  int vertex_set [ ] = new int [ vertices ] ;		      	int vertex_set [ vertices ] ;				      int vertex_set [ vertices ] ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < vertices ;					      	i < vertices ;						      i < vertices ;						  
  i ++ ) vertex_set [ i ] = 0 ;				      	i ++ ) vertex_set [ i ] = 0 ;				      i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	vertex_set [ i ] = 0 ;					  
  i < vertices - 2 ;					      	i < vertices - 2 ;					      }								  
  i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1 ;		      	i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1 ;		      for ( int i = 0 ;						  
  System . out . print ( "\nThe edge set E(G) is :\n" ) ;     	cout << "\nThe edge set E(G) is :\n" ;			      i < vertices - 2 ;					  
  int j = 0 ;						      	int j = 0 ;						      i ++ ) {							  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	vertex_set [ prufer [ i ] - 1 ] += 1 ;			  
  i < vertices - 2 ;					      	i < vertices - 2 ;					      }								  
  i ++ ) {						      	i ++ ) {						      cout << "\nThe edge set E(G) is :\n" ;			  
    for ( j = 0 ;					      	  for ( j = 0 ;						      int j = 0 ;						  
    j < vertices ;					      	  j < vertices ;					      for ( int i = 0 ;						  
    j ++ ) {						      	  j ++ ) {						      i < vertices - 2 ;					  
      if ( vertex_set [ j ] == 0 ) {			      	    if ( vertex_set [ j ] == 0 ) {			      i ++ ) {							  
	vertex_set [ j ] = - 1 ;			      	      vertex_set [ j ] = - 1 ;				    	for ( j = 0 ;						  
	System . out . print ( "(" + ( j + 1 ) + ", " + prufe 	      cout << "(" << ( j + 1 ) << ", " << prufer [ i ] << " 	j < vertices ;						  
	vertex_set [ prufer [ i ] - 1 ] -- ;		      	      vertex_set [ prufer [ i ] - 1 ] -- ;		    	j ++ ) {						  
	break ;						      	      break ;						    	  if ( vertex_set [ j ] == 0 ) {			  
      }							      	    }							    	    vertex_set [ j ] = - 1 ;				  
    }							      	  }							    	    cout << "(" << ( j + 1 ) << ", " << prufer [ i ] << " 
  }							      	}							    	    vertex_set [ prufer [ i ] - 1 ] -- ;		  
  j = 0 ;						      	j = 0 ;							    	    break ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	  }							  
  i < vertices ;					      	i < vertices ;						    	}							  
  i ++ ) {						      	i ++ ) {						      }								  
    if ( vertex_set [ i ] == 0 && j == 0 ) {		      	  if ( vertex_set [ i ] == 0 && j == 0 ) {		      j = 0 ;							  
      System . out . print ( "(" + ( i + 1 ) + ", " ) ;	      	    cout << "(" << ( i + 1 ) << ", " ;			      for ( int i = 0 ;						  
      j ++ ;						      	    j ++ ;						      i < vertices ;						  
    }							      	  }							      i ++ ) {							  
    else if ( vertex_set [ i ] == 0 && j == 1 ) System . out  	  else if ( vertex_set [ i ] == 0 && j == 1 ) cout << ( i + 	if ( vertex_set [ i ] == 0 && j == 0 ) {		  
  }							      	}							    	  cout << "(" << ( i + 1 ) << ", " ;			  
}							      }								    	  j ++ ;						  
							      								    	}							  
							      								    	else if ( vertex_set [ i ] == 0 && j == 1 ) {		  
							      								    	  cout << ( i + 1 ) << ")\n" ;				  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS		      MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS			    MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS			  MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS
--							      --							    --								  --
static String maximumPalinUsingKChanges ( String str , int k  string maximumPalinUsingKChanges ( string str , int k ) {	    string maximumPalinUsingKChanges ( string str , int k ) {	  error : /bin/bash: line 1: 3926943 Aborted
  char palin [ ] = str . toCharArray ( ) ;		      	string palin = str ;					      string palin ;						  	   (core dumped) ./MAKE_LARGEST_PALINDROME_C
  String ans = "" ;					      	int l = 0 ;						      string ans ;						  HANGING_K_DIGITS_cpp
  int l = 0 ;						      	int r = str . length ( ) - 1 ;				      int l = 0 ;						  
  int r = str . length ( ) - 1 ;			      	while ( l < r ) {					      int r = str . length ( ) - 1 ;				  
  while ( l < r ) {					      	  if ( str [ l ] != str [ r ] ) {			      while ( l < r ) {						  
    if ( str . charAt ( l ) != str . charAt ( r ) ) {	      	    palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] 	if ( str [ l ] != str [ r ] ) {				  
      palin [ l ] = palin [ r ] = ( char ) Math . max ( str . 	    k -- ;						    	  palin [ l ] = palin [ r ] = ( char ) max ( str [ l ] ,  
      k -- ;						      	  }							    	  k -- ;						  
    }							      	  l ++ ;						    	}							  
    l ++ ;						      	  r -- ;						    	l ++ ;							  
    r -- ;						      	}							    	r -- ;							  
  }							      	if ( k < 0 ) return "Not possible" ;			      }								  
  if ( k < 0 ) {					      	l = 0 ;							      if ( k < 0 ) return "Not possible" ;			  
    return "Not possible" ;				      	r = str . length ( ) - 1 ;				      l = 0 ;							  
  }							      	while ( l <= r ) {					      r = str . length ( ) - 1 ;				  
  l = 0 ;						      	  if ( l == r ) {					      while ( l <= r ) {					  
  r = str . length ( ) - 1 ;				      	    if ( k > 0 ) palin [ l ] = '9' ;			    	if ( l == r ) {						  
  while ( l <= r ) {					      	  }							    	  if ( k > 0 ) palin [ l ] = '9' ;			  
    if ( l == r ) {					      	  if ( palin [ l ] < '9' ) {				    	}							  
      if ( k > 0 ) {					      	    if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ]  	if ( palin [ l ] < '9' ) {				  
	palin [ l ] = '9' ;				      	      k -= 2 ;						    	  if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ]  
      }							      	      palin [ l ] = palin [ r ] = '9' ;			    	    k -= 2 ;						  
    }							      	    }							    	    palin [ l ] = palin [ r ] = '9' ;			  
    if ( palin [ l ] < '9' ) {				      	    else if ( k >= 1 && ( palin [ l ] != str [ l ] || palin 	  }							  
      if ( k >= 2 && palin [ l ] == str . charAt ( l ) && pal 	      k -- ;						    	  else if ( k >= 1 && ( palin [ l ] != str [ l ] || palin 
	k -= 2 ;					      	      palin [ l ] = palin [ r ] = '9' ;			    	    k -- ;						  
	palin [ l ] = palin [ r ] = '9' ;		      	    }							    	    palin [ l ] = palin [ r ] = '9' ;			  
      }							      	  }							    	  }							  
      else if ( k >= 1 && ( palin [ l ] != str . charAt ( l ) 	  l ++ ;						    	}							  
	k -- ;						      	  r -- ;						    	l ++ ;							  
	palin [ l ] = palin [ r ] = '9' ;		      	}							    	r -- ;							  
      }							      	return palin ;						      }								  
    }							      }								      for ( int i = 0 ;						  
    l ++ ;						      								      i < palin . length ( ) ;					  
    r -- ;						      								      i ++ ) {							  
  }							      								    	ans += palin [ i ] ;					  
  for ( int i = 0 ;					      								      }								  
  i < palin . length ;					      								      return ans ;						  
  i ++ ) ans += palin [ i ] ;				      								    }								  
  return ans ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG		      MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG		    MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG			  MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG
--							      --							    --								  --
public static int MinimumCost ( int cost [ ] , int n , int W  int MinimumCost ( int cost [ ] , int n , int W ) {	    int MinimumCost ( int cost [ ] , int & n , int W ) {	  script_not_found : None
  Vector < Integer > val = new Vector < Integer > ( ) ;	      	vector < int > val , wt ;				      vector < int > val ;					  
  Vector < Integer > wt = new Vector < Integer > ( ) ;	      	int size = 0 ;						      vector < int > wt ;					  
  int size = 0 ;					      	for ( int i = 0 ;					      int size = 0 ;						  
  for ( int i = 0 ;					      	i < n ;							      for ( int i = 0 ;						  
  i < n ;						      	i ++ ) {						      i < n ;							  
  i ++ ) {						      	  if ( cost [ i ] != - 1 ) {				      i ++ ) {							  
    if ( cost [ i ] != - 1 ) {				      	    val . push_back ( cost [ i ] ) ;			    	if ( cost [ i ] != - 1 ) {				  
      val . add ( cost [ i ] ) ;			      	    wt . push_back ( i + 1 ) ;				    	  val . push_back ( cost [ i ] ) ;			  
      wt . add ( i + 1 ) ;				      	    size ++ ;						    	  wt . push_back ( i + 1 ) ;				  
      size ++ ;						      	  }							    	  size ++ ;						  
    }							      	}							    	}							  
  }							      	n = size ;						      }								  
  n = size ;						      	int min_cost [ n + 1 ] [ W + 1 ] ;			      n = size ;						  
  int min_cost [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ;	      	for ( int i = 0 ;					      vector < vector < int >> min_cost ( n + 1 , vector < int >  
  for ( int i = 0 ;					      	i <= W ;						      for ( int i = 0 ;						  
  i <= W ;						      	i ++ ) min_cost [ 0 ] [ i ] = INF ;			      i <= W ;							  
  i ++ ) min_cost [ 0 ] [ i ] = Integer . MAX_VALUE ;	      	for ( int i = 1 ;					      i ++ ) {							  
  for ( int i = 1 ;					      	i <= n ;						    	min_cost [ 0 ] [ i ] = INT_MAX ;			  
  i <= n ;						      	i ++ ) min_cost [ i ] [ 0 ] = 0 ;			      }								  
  i ++ ) min_cost [ i ] [ 0 ] = 0 ;			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  for ( int i = 1 ;					      	i <= n ;						      i <= n ;							  
  i <= n ;						      	i ++ ) {						      i ++ ) {							  
  i ++ ) {						      	  for ( int j = 1 ;					    	min_cost [ i ] [ 0 ] = 0 ;				  
    for ( int j = 1 ;					      	  j <= W ;						      }								  
    j <= W ;						      	  j ++ ) {						      for ( int i = 1 ;						  
    j ++ ) {						      	    if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost   i <= n ;							  
      if ( wt . get ( i - 1 ) > j ) min_cost [ i ] [ j ] = mi 	    else min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [    i ++ ) {							  
      else min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 	  }							    	for ( int j = 1 ;					  
    }							      	}							    	j <= W ;						  
  }							      	return ( min_cost [ n ] [ W ] == INF ) ? - 1 : min_cost [ n 	j ++ ) {						  
  return ( min_cost [ n ] [ W ] == Integer . MAX_VALUE ) ? -  }								    	  if ( wt [ i - 1 ] > j ) {				  
}							      								    	    min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ;	  
							      								    	  }							  
							      								    	  else {						  
							      								    	    min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] 
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return ( min_cost [ n ] [ W ] == INT_MAX ) ? - 1 : min_cost 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2	      MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2	    MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2	  MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2
--							      --							    --								  --
static int getLevenstein ( StringBuilder input ) {	      int getLevenstein ( string const & input ) {		    int getLevenstein ( string input ) {			  script_not_found : None
  StringBuilder revInput = new StringBuilder ( input ) ;      	string revInput ( input . rbegin ( ) , input . rend ( ) ) ;   string revInput ( input ) ;				  
  revInput = revInput . reverse ( ) ;			      	int n = input . size ( ) ;				      revInput = revInput . substr ( 0 , revInput . length ( ) -  
  int n = input . length ( ) ;				      	vector < vector < int >> dp ( n + 1 , vector < int > ( n +    int n = input . length ( ) ;				  
  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;	      	for ( int i = 0 ;					      vector < vector < int >> dp ( n + 1 , vector < int > ( n +  
  for ( int i = 0 ;					      	i <= n ;						      for ( int i = 0 ;						  
  i <= n ;						      	++ i ) {						      i <= n ;							  
  ++ i ) {						      	  dp [ 0 ] [ i ] = i ;					      ++ i ) {							  
    dp [ 0 ] [ i ] = i ;				      	  dp [ i ] [ 0 ] = i ;					    	dp [ 0 ] [ i ] = i ;					  
    dp [ i ] [ 0 ] = i ;				      	}							    	dp [ i ] [ 0 ] = i ;					  
  }							      	for ( int i = 1 ;					      }								  
  for ( int i = 1 ;					      	i <= n ;						      for ( int i = 1 ;						  
  i <= n ;						      	++ i ) {						      i <= n ;							  
  ++ i ) {						      	  for ( int j = 1 ;					      ++ i ) {							  
    for ( int j = 1 ;					      	  j <= n ;						    	for ( int j = 1 ;					  
    j <= n ;						      	  ++ j ) {						    	j <= n ;						  
    ++ j ) {						      	    if ( input [ i - 1 ] == revInput [ j - 1 ] ) dp [ i ] [ 	++ j ) {						  
      if ( input . charAt ( i - 1 ) == revInput . charAt ( j  	    else dp [ i ] [ j ] = 1 + min ( {			    	  if ( input [ i - 1 ] == revInput [ j - 1 ] ) {	  
      else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j 	      dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] }		    	    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;		  
    }							      	      ) ;						    	  }							  
  }							      	    }							    	  else {						  
  int res = Integer . MAX_VALUE ;			      	  }							    	    dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [  
  for ( int i = n , j = 0 ;				      	  int res = numeric_limits < int > :: max ( ) ;		    	  }							  
  i >= 0 ;						      	  for ( int i = n , j = 0 ;				    	}							  
  i -- , j ++ ) {					      	  i >= 0 ;						      }								  
    res = Math . min ( res , dp [ i ] [ j ] ) ;		      	  -- i , ++ j ) {					      int res = INT_MAX ;					  
    if ( i < n ) res = Math . min ( res , dp [ i + 1 ] [ j ]  	    res = min ( res , dp [ i ] [ j ] ) ;		      for ( int i = n , j = 0 ;					  
    if ( i > 0 ) res = Math . min ( res , dp [ i - 1 ] [ j ]  	    if ( i < n ) res = min ( res , dp [ i + 1 ] [ j ] ) ;     i >= 0 ;							  
  }							      	    if ( i > 0 ) res = min ( res , dp [ i - 1 ] [ j ] ) ;     i -- , j ++ ) {						  
  return res ;						      	  }							    	res = min ( res , dp [ i ] [ j ] ) ;			  
}							      	  return res ;						    	if ( i < n ) {						  
							      	}							    	  res = min ( res , dp [ i + 1 ] [ j ] ) ;		  
							      								    	}							  
							      								    	if ( i > 0 ) {						  
							      								    	  res = min ( res , dp [ i - 1 ] [ j ] ) ;		  
							      								    	}							  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_REPEATED_SUBSEQUENCE_1				      LONGEST_REPEATED_SUBSEQUENCE_1				    LONGEST_REPEATED_SUBSEQUENCE_1				  LONGEST_REPEATED_SUBSEQUENCE_1
--							      --							    --								  --
static String longestRepeatedSubSeq ( String str ) {	      string longestRepeatedSubSeq ( string str ) {		    string longestRepeatedSubSeq ( string str ) {		  success : None
  int n = str . length ( ) ;				      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
  int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ;	      	int dp [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( n +  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j <= n ;						      	j <= n ;						      j <= n ;							  
  j ++ ) dp [ i ] [ j ] = 0 ;				      	j ++ ) dp [ i ] [ j ] = 0 ;				      j ++ ) dp [ i ] [ j ] = 0 ;				  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i <= n ;						      	i <= n ;						      i <= n ;							  
  i ++ ) for ( int j = 1 ;				      	i ++ ) for ( int j = 1 ;				      i ++ ) for ( int j = 1 ;					  
  j <= n ;						      	j <= n ;						      j <= n ;							  
  j ++ ) if ( str . charAt ( i - 1 ) == str . charAt ( j - 1  	j ++ ) if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [   j ++ ) if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ 
  else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp  	else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1   else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 
  String res = "" ;					      	string res = "" ;					      string res ;						  
  int i = n , j = n ;					      	int i = n , j = n ;					      int i = n , j = n ;					  
  while ( i > 0 && j > 0 ) {				      	while ( i > 0 && j > 0 ) {				      while ( i > 0 && j > 0 ) {				  
    if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) {     	  if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) {	    	if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) {	  
      res = res + str . charAt ( i - 1 ) ;		      	    res = res + str [ i - 1 ] ;				    	  res = res + str [ i - 1 ] ;				  
      i -- ;						      	    i -- ;						    	  i -- ;						  
      j -- ;						      	    j -- ;						    	  j -- ;						  
    }							      	  }							    	}							  
    else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ;   	  else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ;   	else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ;	  
    else j -- ;						      	  else j -- ;						    	else j -- ;						  
  }							      	}							      }								  
  String reverse = "" ;					      	reverse ( res . begin ( ) , res . end ( ) ) ;		      string reverse ;						  
  for ( int k = res . length ( ) - 1 ;			      	return res ;						      for ( int k = res . length ( ) - 1 ;			  
  k >= 0 ;						      }								      k >= 0 ;							  
  k -- ) {						      								      k -- ) reverse = reverse + res [ k ] ;			  
    reverse = reverse + res . charAt ( k ) ;		      								      return reverse ;						  
  }							      								    }								  
  return reverse ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL
--							      --							    --								  --
static int minCells ( int mat [ ] [ ] , int m , int n ) {     int minCells ( int mat [ SIZE ] [ SIZE ] , int m , int n ) {  int minCells ( int mat [ ] [ 2 ] , int m , int n ) {	  script_not_found : None
  int dp [ ] [ ] = new int [ m ] [ n ] ;		      	int dp [ m ] [ n ] ;					      int dp [ m ] [ n ] ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m ;						      	i < m ;							      i < m ;							  
  i ++ ) for ( int j = 0 ;				      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
  j < n ;						      	j < n ;							      j < n ;							  
  j ++ ) dp [ i ] [ j ] = Integer . MAX_VALUE ;		      	j ++ ) dp [ i ] [ j ] = INT_MAX ;			      j ++ ) dp [ i ] [ j ] = INT_MAX ;				  
  dp [ 0 ] [ 0 ] = 1 ;					      	dp [ 0 ] [ 0 ] = 1 ;					      dp [ 0 ] [ 0 ] = 1 ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < m ;						      	i < m ;							      i < m ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < n ;						      	  j < n ;						    	j < n ;							  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( j + mat 	    if ( dp [ i ] [ j ] != INT_MAX && ( j + mat [ i ] [ j ] 	  if ( dp [ i ] [ j ] != INT_MAX && ( j + mat [ i ] [ j ] 
      if ( dp [ i ] [ j ] != Integer . MAX_VALUE && ( i + mat 	    if ( dp [ i ] [ j ] != INT_MAX && ( i + mat [ i ] [ j ] 	  if ( dp [ i ] [ j ] != INT_MAX && ( i + mat [ i ] [ j ] 
    }							      	  }							    	}							  
  }							      	}							      }								  
  if ( dp [ m - 1 ] [ n - 1 ] != Integer . MAX_VALUE ) return 	if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) return dp [ m - 1    if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) return dp [ m - 1  
  return - 1 ;						      	return - 1 ;						      return - 1 ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1     RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1	    RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1	  RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1
--							      --							    --								  --
static void maxProduct ( int arr [ ] , int n ) {	      void maxProduct ( int arr [ ] , int n ) {			    void maxProduct ( int arr [ ] , int n ) {			  script_not_found : None
  if ( n < 2 ) {					      	if ( n < 2 ) {						      if ( n < 2 ) {						  
    System . out . println ( "No pairs exists" ) ;	      	  cout << "No pairs exists\n" ;				    	cout << "No pairs exists" << endl ;			  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( n == 2 ) {					      	if ( n == 2 ) {						      if ( n == 2 ) {						  
    System . out . println ( arr [ 0 ] + " " + arr [ 1 ] ) ;  	  cout << arr [ 0 ] << " " << arr [ 1 ] << endl ;	    	cout << arr [ 0 ] << " " << arr [ 1 ] << endl ;		  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  int posa = Integer . MIN_VALUE , posb = Integer . MIN_VALUE 	int posa = INT_MIN , posb = INT_MIN ;			      int posa = INT_MAX , posb = INT_MAX ;			  
  int nega = Integer . MIN_VALUE , negb = Integer . MIN_VALUE 	int nega = INT_MIN , negb = INT_MIN ;			      int nega = INT_MIN , negb = INT_MIN ;			  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] > posa ) {				      	  if ( arr [ i ] > posa ) {				    	if ( arr [ i ] > posa ) {				  
      posb = posa ;					      	    posb = posa ;					    	  posb = posa ;						  
      posa = arr [ i ] ;				      	    posa = arr [ i ] ;					    	  posa = arr [ i ] ;					  
    }							      	  }							    	}							  
    else if ( arr [ i ] > posb ) posb = arr [ i ] ;	      	  else if ( arr [ i ] > posb ) posb = arr [ i ] ;	    	else if ( arr [ i ] > posb ) {				  
    if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Math . a 	  if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( nega ) )  	  posb = arr [ i ] ;					  
      negb = nega ;					      	    negb = nega ;					    	}							  
      nega = arr [ i ] ;				      	    nega = arr [ i ] ;					    	if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( nega ) )  
    }							      	  }							    	  negb = nega ;						  
    else if ( arr [ i ] < 0 && Math . abs ( arr [ i ] ) > Mat 	  else if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( negb 	  nega = arr [ i ] ;					  
  }							      	}							    	}							  
  if ( nega * negb > posa * posb ) System . out . println ( " 	if ( nega * negb > posa * posb ) cout << "Max product pair  	else if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( negb 
  else System . out . println ( "Max product pair is {" + pos 	else cout << "Max product pair is {" << posa << ", " << pos 	  negb = arr [ i ] ;					  
}							      }								    	}							  
							      								      }								  
							      								      if ( nega * negb > posa * posb ) {			  
							      								    	cout << "Max product pair is {" << nega << ", " << negb < 
							      								      }								  
							      								      else {							  
							      								    	cout << "Max product pair is {" << posa << ", " << posb < 
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PALINDROME_SUB_STRINGS_STRING			      COUNT_PALINDROME_SUB_STRINGS_STRING			    COUNT_PALINDROME_SUB_STRINGS_STRING				  COUNT_PALINDROME_SUB_STRINGS_STRING
--							      --							    --								  --
static int CountPS ( char str [ ] , int n ) {		      int CountPS ( char str [ ] , int n ) {			    int CountPS ( char str [ ] , int n ) {			  failure : #Results: 5, 10
  int dp [ ] [ ] = new int [ n ] [ n ] ;		      	int dp [ n ] [ n ] ;					      vector < vector < bool >> dp ( n , vector < bool > ( n , fa 
  boolean P [ ] [ ] = new boolean [ n ] [ n ] ;		      	memset ( dp , 0 , sizeof ( dp ) ) ;			      vector < vector < bool >> P ( n , vector < bool > ( n , fal 
  for ( int i = 0 ;					      	bool P [ n ] [ n ] ;					      for ( int i = 0 ;						  
  i < n ;						      	memset ( P , false , sizeof ( P ) ) ;			      i < n ;							  
  i ++ ) P [ i ] [ i ] = true ;				      	for ( int i = 0 ;					      i ++ ) {							  
  for ( int i = 0 ;					      	i < n ;							    	P [ i ] [ i ] = true ;					  
  i < n - 1 ;						      	i ++ ) P [ i ] [ i ] = true ;				      }								  
  i ++ ) {						      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    if ( str [ i ] == str [ i + 1 ] ) {			      	i < n - 1 ;						      i < n - 1 ;						  
      P [ i ] [ i + 1 ] = true ;			      	i ++ ) {						      i ++ ) {							  
      dp [ i ] [ i + 1 ] = 1 ;				      	  if ( str [ i ] == str [ i + 1 ] ) {			    	if ( str [ i ] == str [ i + 1 ] ) {			  
    }							      	    P [ i ] [ i + 1 ] = true ;				    	  P [ i ] [ i + 1 ] = true ;				  
  }							      	    dp [ i ] [ i + 1 ] = 1 ;				    	  dp [ i ] [ i + 1 ] = 1 ;				  
  for ( int gap = 2 ;					      	  }							    	}							  
  gap < n ;						      	}							      }								  
  gap ++ ) {						      	for ( int gap = 2 ;					      for ( int gap = 2 ;					  
    for ( int i = 0 ;					      	gap < n ;						      gap < n ;							  
    i < n - gap ;					      	gap ++ ) {						      gap ++ ) {						  
    i ++ ) {						      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
      int j = gap + i ;					      	  i < n - gap ;						    	i < n - gap ;						  
      if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] )  	  i ++ ) {						    	i ++ ) {						  
      if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ]  	    int j = gap + i ;					    	  int j = gap + i ;					  
      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] 	    if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] )  	  if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] )  
    }							      	    if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ]  	    P [ i ] [ j ] = true ;				  
  }							      	    else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] 	  }							  
  return dp [ 0 ] [ n - 1 ] ;				      	  }							    	  if ( P [ i ] [ j ] == true ) {			  
}							      	}							    	    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [  
							      	return dp [ 0 ] [ n - 1 ] ;				    	  }							  
							      }								    	  else {						  
							      								    	    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return dp [ 0 ] [ n - 1 ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL
--							      --							    --								  --
static int maxArea ( int mat [ ] [ ] ) {		      int maxArea ( bool mat [ R ] [ C ] ) {			    int maxArea ( int mat [ ] [ 4 ] ) {				  script_not_found : None
  int hist [ ] [ ] = new int [ R + 1 ] [ C + 1 ] ;	      	int hist [ R + 1 ] [ C + 1 ] ;				      int hist [ R + 1 ] [ C + 1 ] ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < C ;						      	i < C ;							      i < C ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ;		      	  hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ;			    	hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ;			  
    for ( int j = 1 ;					      	  for ( int j = 1 ;					    	for ( int j = 1 ;					  
    j < R ;						      	  j < R ;						    	j < R ;							  
    j ++ ) {						      	  j ++ ) hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 :  	j ++ ) hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 :  
      hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist  	}							      }								  
    }							      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  }							      	i < R ;							      i < R ;							  
  for ( int i = 0 ;					      	i ++ ) {						      i ++ ) {							  
  i < R ;						      	  int count [ R + 1 ] = {				    	int count [ R + 1 ] ;					  
  i ++ ) {						      	    0 }							    	for ( int j = 0 ;					  
    int count [ ] = new int [ R + 1 ] ;			      	    ;							    	j < C ;							  
    for ( int j = 0 ;					      	    for ( int j = 0 ;					    	j ++ ) count [ hist [ i ] [ j ] ] ++ ;			  
    j < C ;						      	    j < C ;						    	int colNo = 0 ;						  
    j ++ ) {						      	    j ++ ) count [ hist [ i ] [ j ] ] ++ ;		    	for ( int j = R ;					  
      count [ hist [ i ] [ j ] ] ++ ;			      	    int col_no = 0 ;					    	j >= 0 ;						  
    }							      	    for ( int j = R ;					    	j -- ) {						  
    int col_no = 0 ;					      	    j >= 0 ;						    	  if ( count [ j ] > 0 ) {				  
    for ( int j = R ;					      	    j -- ) {						    	    for ( int k = 0 ;					  
    j >= 0 ;						      	      if ( count [ j ] > 0 ) {				    	    k < count [ j ] ;					  
    j -- ) {						      		for ( int k = 0 ;				    	    k ++ ) {						  
      if ( count [ j ] > 0 ) {				      		k < count [ j ] ;				    	      hist [ i ] [ colNo ] = j ;			  
	for ( int k = 0 ;				      		k ++ ) {					    	      colNo ++ ;					  
	k < count [ j ] ;				      		  hist [ i ] [ col_no ] = j ;			    	    }							  
	k ++ ) {					      		  col_no ++ ;					    	  }							  
	  hist [ i ] [ col_no ] = j ;			      		}						    	}							  
	  col_no ++ ;					      	      }							    	int currArea , maxArea = 0 ;				  
	}						      	    }							    	for ( int i = 0 ;					  
      }							      	  }							    	i < R ;							  
    }							      	  int curr_area , max_area = 0 ;			    	i ++ ) {						  
  }							      	  for ( int i = 0 ;					    	  for ( int j = 0 ;					  
  int curr_area , max_area = 0 ;			      	  i < R ;						    	  j < C ;						  
  for ( int i = 0 ;					      	  i ++ ) {						    	  j ++ ) {						  
  i < R ;						      	    for ( int j = 0 ;					    	    currArea = ( j + 1 ) * hist [ i ] [ j ] ;		  
  i ++ ) {						      	    j < C ;						    	    if ( currArea > maxArea ) maxArea = currArea ;	  
    for ( int j = 0 ;					      	    j ++ ) {						    	  }							  
    j < C ;						      	      curr_area = ( j + 1 ) * hist [ i ] [ j ] ;	    	}							  
    j ++ ) {						      	      if ( curr_area > max_area ) max_area = curr_area ;      }								  
      curr_area = ( j + 1 ) * hist [ i ] [ j ] ;	      	    }							      return maxArea ;						  
      if ( curr_area > max_area ) {			      	  }							    }								  
	max_area = curr_area ;				      	  return max_area ;					    								  
      }							      	}							    								  
    }							      								    								  
  }							      								    								  
  return max_area ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ROTATE_MATRIX_ELEMENTS					      ROTATE_MATRIX_ELEMENTS					    ROTATE_MATRIX_ELEMENTS					  ROTATE_MATRIX_ELEMENTS
--							      --							    --								  --
static void rotatematrix ( int m , int n , int mat [ ] [ ] )  void rotatematrix ( int m , int n , int mat [ R ] [ C ] ) {   void rotatematrix ( int m , int n , int mat [ ] [ 3 ] ) {	  script_not_found : None
  int row = 0 , col = 0 ;				      	int row = 0 , col = 0 ;					      int row = 0 , col = 0 ;					  
  int prev , curr ;					      	int prev , curr ;					      int prev , curr ;						  
  while ( row < m && col < n ) {			      	while ( row < m && col < n ) {				      while ( row < m && col < n ) {				  
    if ( row + 1 == m || col + 1 == n ) break ;		      	  if ( row + 1 == m || col + 1 == n ) break ;		    	if ( row + 1 == m || col + 1 == n ) break ;		  
    prev = mat [ row + 1 ] [ col ] ;			      	  prev = mat [ row + 1 ] [ col ] ;			    	prev = mat [ row + 1 ] [ col ] ;			  
    for ( int i = col ;					      	  for ( int i = col ;					    	for ( int i = col ;					  
    i < n ;						      	  i < n ;						    	i < n ;							  
    i ++ ) {						      	  i ++ ) {						    	i ++ ) {						  
      curr = mat [ row ] [ i ] ;			      	    curr = mat [ row ] [ i ] ;				    	  curr = mat [ row ] [ i ] ;				  
      mat [ row ] [ i ] = prev ;			      	    mat [ row ] [ i ] = prev ;				    	  mat [ row ] [ i ] = prev ;				  
      prev = curr ;					      	    prev = curr ;					    	  prev = curr ;						  
    }							      	  }							    	}							  
    row ++ ;						      	  row ++ ;						    	row ++ ;						  
    for ( int i = row ;					      	  for ( int i = row ;					    	for ( int i = row ;					  
    i < m ;						      	  i < m ;						    	i < m ;							  
    i ++ ) {						      	  i ++ ) {						    	i ++ ) {						  
      curr = mat [ i ] [ n - 1 ] ;			      	    curr = mat [ i ] [ n - 1 ] ;			    	  curr = mat [ i ] [ n - 1 ] ;				  
      mat [ i ] [ n - 1 ] = prev ;			      	    mat [ i ] [ n - 1 ] = prev ;			    	  mat [ i ] [ n - 1 ] = prev ;				  
      prev = curr ;					      	    prev = curr ;					    	  prev = curr ;						  
    }							      	  }							    	}							  
    n -- ;						      	  n -- ;						    	n -- ;							  
    if ( row < m ) {					      	  if ( row < m ) {					    	if ( row < m ) {					  
      for ( int i = n - 1 ;				      	    for ( int i = n - 1 ;				    	  for ( int i = n - 1 ;					  
      i >= col ;					      	    i >= col ;						    	  i >= col ;						  
      i -- ) {						      	    i -- ) {						    	  i -- ) {						  
	curr = mat [ m - 1 ] [ i ] ;			      	      curr = mat [ m - 1 ] [ i ] ;			    	    curr = mat [ m - 1 ] [ i ] ;			  
	mat [ m - 1 ] [ i ] = prev ;			      	      mat [ m - 1 ] [ i ] = prev ;			    	    mat [ m - 1 ] [ i ] = prev ;			  
	prev = curr ;					      	      prev = curr ;					    	    prev = curr ;					  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
    m -- ;						      	  m -- ;						    	m -- ;							  
    if ( col < n ) {					      	  if ( col < n ) {					    	if ( col < n ) {					  
      for ( int i = m - 1 ;				      	    for ( int i = m - 1 ;				    	  for ( int i = m - 1 ;					  
      i >= row ;					      	    i >= row ;						    	  i >= row ;						  
      i -- ) {						      	    i -- ) {						    	  i -- ) {						  
	curr = mat [ i ] [ col ] ;			      	      curr = mat [ i ] [ col ] ;			    	    curr = mat [ i ] [ col ] ;				  
	mat [ i ] [ col ] = prev ;			      	      mat [ i ] [ col ] = prev ;			    	    mat [ i ] [ col ] = prev ;				  
	prev = curr ;					      	      prev = curr ;					    	    prev = curr ;					  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
    col ++ ;						      	  col ++ ;						    	col ++ ;						  
  }							      	}							      }								  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < R ;						      	i < R ;							      i < R ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j < C ;						      	  j < C ;						    	j < C ;							  
    j ++ ) System . out . print ( mat [ i ] [ j ] + " " ) ;   	  j ++ ) cout << mat [ i ] [ j ] << " " ;		    	j ++ ) {						  
    System . out . print ( "\n" ) ;			      	  cout << endl ;					    	  cout << mat [ i ] [ j ] << " " ;			  
  }							      	}							    	}							  
}							      }								    	cout << "\n" ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP
--							      --							    --								  --
static void printUnsorted ( int arr [ ] , int n ) {	      void printUnsorted ( int arr [ ] , int n ) {		    void printUnsorted ( int arr [ ] , int n ) {		  script_not_found : None
  int s = 0 , e = n - 1 , i , max , min ;		      	int s = 0 , e = n - 1 , i , max , min ;			      int s = 0 , e = n - 1 , i , max , min ;			  
  for ( s = 0 ;						      	for ( s = 0 ;						      for ( s = 0 ;						  
  s < n - 1 ;						      	s < n - 1 ;						      s < n - 1 ;						  
  s ++ ) {						      	s ++ ) {						      s ++ ) {							  
    if ( arr [ s ] > arr [ s + 1 ] ) break ;		      	  if ( arr [ s ] > arr [ s + 1 ] ) break ;		    	if ( arr [ s ] > arr [ s + 1 ] ) break ;		  
  }							      	}							      }								  
  if ( s == n - 1 ) {					      	if ( s == n - 1 ) {					      if ( s == n - 1 ) {					  
    System . out . println ( "The complete array is sorted" ) 	  cout << "The complete array is sorted" ;		    	cout << "The complete array is sorted" << endl ;	  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  for ( e = n - 1 ;					      	for ( e = n - 1 ;					      for ( e = n - 1 ;						  
  e > 0 ;						      	e > 0 ;							      e > 0 ;							  
  e -- ) {						      	e -- ) {						      e -- ) {							  
    if ( arr [ e ] < arr [ e - 1 ] ) break ;		      	  if ( arr [ e ] < arr [ e - 1 ] ) break ;		    	if ( arr [ e ] < arr [ e - 1 ] ) break ;		  
  }							      	}							      }								  
  max = arr [ s ] ;					      	max = arr [ s ] ;					      max = arr [ s ] ;						  
  min = arr [ s ] ;					      	min = arr [ s ] ;					      min = arr [ s ] ;						  
  for ( i = s + 1 ;					      	for ( i = s + 1 ;					      for ( i = s + 1 ;						  
  i <= e ;						      	i <= e ;						      i <= e ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] > max ) max = arr [ i ] ;		      	  if ( arr [ i ] > max ) max = arr [ i ] ;		    	if ( arr [ i ] > max ) max = arr [ i ] ;		  
    if ( arr [ i ] < min ) min = arr [ i ] ;		      	  if ( arr [ i ] < min ) min = arr [ i ] ;		    	if ( arr [ i ] < min ) min = arr [ i ] ;		  
  }							      	}							      }								  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < s ;						      	i < s ;							      i < s ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( arr [ i ] > min ) {				      	  if ( arr [ i ] > min ) {				    	if ( arr [ i ] > min ) {				  
      s = i ;						      	    s = i ;						    	  s = i ;						  
      break ;						      	    break ;						    	  break ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  for ( i = n - 1 ;					      	for ( i = n - 1 ;					      for ( i = n - 1 ;						  
  i >= e + 1 ;						      	i >= e + 1 ;						      i >= e + 1 ;						  
  i -- ) {						      	i -- ) {						      i -- ) {							  
    if ( arr [ i ] < max ) {				      	  if ( arr [ i ] < max ) {				    	if ( arr [ i ] < max ) {				  
      e = i ;						      	    e = i ;						    	  e = i ;						  
      break ;						      	    break ;						    	  break ;						  
    }							      	  }							    	}							  
  }							      	}							      }								  
  System . out . println ( " The unsorted subarray which" + " 	cout << "The unsorted subarray which" << " makes the given    cout << " The unsorted subarray which" << " makes the given 
  return ;						      	return ;						      return ;							  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS		      POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS		    POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS			  POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS
--							      --							    --								  --
static void pointClip ( int XY [ ] [ ] , int n , int Xmin , i void pointClip ( int XY [ ] [ 2 ] , int n , int Xmin , int Ym void pointClip ( int XY [ ] [ 2 ] , int n , int Xmin , int Ym script_not_found : None
  System . out . printf ( "Point inside the viewing pane:\n"  	cout << "Point inside the viewing pane:" << endl ;	      printf ( "Point inside the viewing pane:\n" ) ;		  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xm 	  if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xm 	if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xm 
      if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <=  	    if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <=  	  if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <=  
    }							      	  }							    	    printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1  
  }							      	}							    	  }							  
  System . out . printf ( "\nPoint outside the viewing pane:\ 	cout << "\n" << endl ;					    	}							  
  for ( int i = 0 ;					      	cout << "Point outside the viewing pane:" << endl ;	      }								  
  i < n ;						      	for ( int i = 0 ;					      printf ( "\nPoint outside the viewing pane:\n" ) ;	  
  i ++ ) {						      	i < n ;							      for ( int i = 0 ;						  
    if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax 	i ++ ) {						      i < n ;							  
    if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax 	  if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax   i ++ ) {							  
  }							      	  if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax 	if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax 
}							      	}							    	  printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ]  
							      }								    	}							  
							      								    	if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax 
							      								    	  printf ( "[%d, %d] " , XY [ i ] [ 0 ] , XY [ i ] [ 1 ]  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER		      MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER			    MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER			  MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER
--							      --							    --								  --
static int findMaxVal ( int [ ] arr , int n , int num , int m int findMaxVal ( int arr [ ] , int n , int num , int maxLimit int findMaxVal ( int arr [ ] , int n , int num , int maxLimit failure : #Results: 7, 10
  int ind ;						      	int ind ;						      int ind ;							  
  int val ;						      	int val ;						      int val ;							  
  int [ ] [ ] dp = new int [ n ] [ maxLimit + 1 ] ;	      	int dp [ n ] [ maxLimit + 1 ] ;				      int dp [ n ] [ maxLimit + 1 ] ;				  
  for ( ind = 0 ;					      	for ( ind = 0 ;						      for ( ind = 0 ;						  
  ind < n ;						      	ind < n ;						      ind < n ;							  
  ind ++ ) {						      	ind ++ ) {						      ind ++ ) {						  
    for ( val = 0 ;					      	  for ( val = 0 ;					    	for ( val = 0 ;						  
    val <= maxLimit ;					      	  val <= maxLimit ;					    	val <= maxLimit ;					  
    val ++ ) {						      	  val ++ ) {						    	val ++ ) {						  
      if ( ind == 0 ) {					      	    if ( ind == 0 ) {					    	  if ( ind == 0 ) {					  
	if ( num - arr [ ind ] == val || num + arr [ ind ] == 	      if ( num - arr [ ind ] == val || num + arr [ ind ] == 	    if ( num - arr [ ind ] == val || num + arr [ ind ] == 
	  dp [ ind ] [ val ] = 1 ;			      		dp [ ind ] [ val ] = 1 ;			    	    else dp [ ind ] [ val ] = 0 ;			  
	}						      	      }							    	  }							  
	else {						      	      else {						    	  else {						  
	  dp [ ind ] [ val ] = 0 ;			      		dp [ ind ] [ val ] = 0 ;			    	    if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= m 
	}						      	      }							    	      if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || d 
      }							      	    }							    	    }							  
      else {						      	    else {						    	    else if ( val - arr [ ind ] >= 0 ) dp [ ind ] [ val ] 
	if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= m 	      if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= m 	    else if ( val + arr [ ind ] <= maxLimit ) dp [ ind ]  
	  if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 || d 		dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ i 	    else dp [ ind ] [ val ] = 0 ;			  
	}						      	      }							    	  }							  
	else if ( val - arr [ ind ] >= 0 ) {		      	      else if ( val - arr [ ind ] >= 0 ) {		    	}							  
	  dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ i 		dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ i   }								  
	}						      	      }							      for ( val = maxLimit ;					  
	else if ( val + arr [ ind ] <= maxLimit ) {	      	      else if ( val + arr [ ind ] <= maxLimit ) {	      val >= 0 ;						  
	  dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ i 		dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ i   val -- ) {						  
	}						      	      }							    	if ( dp [ n - 1 ] [ val ] == 1 ) return val ;		  
	else {						      	      else {						      }								  
	  dp [ ind ] [ val ] = 0 ;			      		dp [ ind ] [ val ] = 0 ;			      return - 1 ;						  
	}						      	      }							    }								  
      }							      	    }							    								  
    }							      	  }							    								  
  }							      	}							    								  
  for ( val = maxLimit ;				      	for ( val = maxLimit ;					    								  
  val >= 0 ;						      	val >= 0 ;						    								  
  val -- ) {						      	val -- ) {						    								  
    if ( dp [ n - 1 ] [ val ] == 1 ) {			      	  if ( dp [ n - 1 ] [ val ] ) {				    								  
      return val ;					      	    return val ;					    								  
    }							      	  }							    								  
  }							      	}							    								  
  return - 1 ;						      	return - 1 ;						    								  
}							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K		      SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K		    SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K		  SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K
--							      --							    --								  --
public static int SumOfKsubArray ( int arr [ ] , int k ) {    int SumOfKsubArray ( int arr [ ] , int n , int k ) {	    int SumOfKsubArray ( int arr [ ] , int k ) {		  script_not_found : None
  int sum = 0 ;						      	int sum = 0 ;						      int sum = 0 ;						  
  Deque < Integer > S = new LinkedList < > ( ) , G = new Link 	deque < int > S ( k ) , G ( k ) ;			      deque < int > S , G ;					  
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  for ( i = 0 ;						      	for ( i = 0 ;						      for ( i = 0 ;						  
  i < k ;						      	i < k ;							      i < k ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >=  	  while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= ar 	while ( ! S . empty ( ) && arr [ S . front ( ) ] >= arr [ 
    while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <=  	  while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= ar 	  S . pop_front ( ) ;					  
    G . addLast ( i ) ;					      	  G . push_back ( i ) ;					    	}							  
    S . addLast ( i ) ;					      	  S . push_back ( i ) ;					    	while ( ! G . empty ( ) && arr [ G . front ( ) ] <= arr [ 
  }							      	}							    	  G . pop_front ( ) ;					  
  for ( ;						      	for ( ;							    	}							  
  i < arr . length ;					      	i < n ;							    	G . push_back ( i ) ;					  
  i ++ ) {						      	i ++ ) {						    	S . push_back ( i ) ;					  
    sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst (  	  sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ;      }								  
    while ( ! S . isEmpty ( ) && S . peekFirst ( ) <= i - k ) 	  while ( ! S . empty ( ) && S . front ( ) <= i - k ) S . p   for ( ;							  
    while ( ! G . isEmpty ( ) && G . peekFirst ( ) <= i - k ) 	  while ( ! G . empty ( ) && G . front ( ) <= i - k ) G . p   i < arr [ k ] ;						  
    while ( ! S . isEmpty ( ) && arr [ S . peekLast ( ) ] >=  	  while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= ar   i ++ ) {							  
    while ( ! G . isEmpty ( ) && arr [ G . peekLast ( ) ] <=  	  while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= ar 	sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ;	  
    G . addLast ( i ) ;					      	  G . push_back ( i ) ;					    	while ( ! S . empty ( ) && S . front ( ) <= i - k ) {	  
    S . addLast ( i ) ;					      	  S . push_back ( i ) ;					    	  S . pop_front ( ) ;					  
  }							      	}							    	}							  
  sum += arr [ S . peekFirst ( ) ] + arr [ G . peekFirst ( )  	sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ;	    	while ( ! G . empty ( ) && G . front ( ) <= i - k ) {	  
  return sum ;						      	return sum ;						    	  G . pop_front ( ) ;					  
}							      }								    	}							  
							      								    	while ( ! S . empty ( ) && arr [ S . front ( ) ] >= arr [ 
							      								    	  S . pop_front ( ) ;					  
							      								    	}							  
							      								    	while ( ! G . empty ( ) && arr [ G . front ( ) ] <= arr [ 
							      								    	  G . pop_front ( ) ;					  
							      								    	}							  
							      								    	G . push_back ( i ) ;					  
							      								    	S . push_back ( i ) ;					  
							      								      }								  
							      								      sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ;	  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ROTATIONS_DIVISIBLE_8				      COUNT_ROTATIONS_DIVISIBLE_8				    COUNT_ROTATIONS_DIVISIBLE_8					  COUNT_ROTATIONS_DIVISIBLE_8
--							      --							    --								  --
static int countRotationsDivBy8 ( String n ) {		      int countRotationsDivBy8 ( string n ) {			    int countRotationsDivBy8 ( string n ) {			  success : identical to gold
  int len = n . length ( ) ;				      	int len = n . length ( ) ;				      int len = n . length ( ) ;				  
  int count = 0 ;					      	int count = 0 ;						      int count = 0 ;						  
  if ( len == 1 ) {					      	if ( len == 1 ) {					      if ( len == 1 ) {						  
    int oneDigit = n . charAt ( 0 ) - '0' ;		      	  int oneDigit = n [ 0 ] - '0' ;			    	int oneDigit = n [ 0 ] - '0' ;				  
    if ( oneDigit % 8 == 0 ) return 1 ;			      	  if ( oneDigit % 8 == 0 ) return 1 ;			    	if ( oneDigit % 8 == 0 ) return 1 ;			  
    return 0 ;						      	  return 0 ;						    	return 0 ;						  
  }							      	}							      }								  
  if ( len == 2 ) {					      	if ( len == 2 ) {					      if ( len == 2 ) {						  
    int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charA 	  int first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ;  	int first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ;  
    int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . char 	  int second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; 	int second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; 
    if ( first % 8 == 0 ) count ++ ;			      	  if ( first % 8 == 0 ) count ++ ;			    	if ( first % 8 == 0 ) count ++ ;			  
    if ( second % 8 == 0 ) count ++ ;			      	  if ( second % 8 == 0 ) count ++ ;			    	if ( second % 8 == 0 ) count ++ ;			  
    return count ;					      	  return count ;					    	return count ;						  
  }							      	}							      }								  
  int threeDigit ;					      	int threeDigit ;					      int threeDigit ;						  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < ( len - 2 ) ;					      	i < ( len - 2 ) ;					      i < ( len - 2 ) ;						  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . cha 	  threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0 	threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0 
    if ( threeDigit % 8 == 0 ) count ++ ;		      	  if ( threeDigit % 8 == 0 ) count ++ ;			    	if ( threeDigit % 8 == 0 ) count ++ ;			  
  }							      	}							      }								  
  threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . 	threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0   threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0 
  if ( threeDigit % 8 == 0 ) count ++ ;			      	if ( threeDigit % 8 == 0 ) count ++ ;			      if ( threeDigit % 8 == 0 ) count ++ ;			  
  threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . 	threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1    threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1  
  if ( threeDigit % 8 == 0 ) count ++ ;			      	if ( threeDigit % 8 == 0 ) count ++ ;			      if ( threeDigit % 8 == 0 ) count ++ ;			  
  return count ;					      	return count ;						      return count ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT			      PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT			    PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT			  PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT
--							      --							    --								  --
static void printSpiral ( int [ ] [ ] mat , int r , int c ) { void printSpiral ( int mat [ ] [ MAX ] , int r , int c ) {    void printSpiral ( int * * mat , int r , int c ) {		  script_not_found : None
  int i , a = 0 , b = 2 ;				      	int i , a = 0 , b = 2 ;					      int i , a = 0 , b = 2 ;					  
  int low_row = ( 0 > a ) ? 0 : a ;			      	int low_row = ( 0 > a ) ? 0 : a ;			      int low_row = ( 0 > a ) ? 0 : a ;				  
  int low_column = ( 0 > b ) ? 0 : b - 1 ;		      	int low_column = ( 0 > b ) ? 0 : b - 1 ;		      int low_column = ( 0 > b ) ? 0 : b - 1 ;			  
  int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ;	      	int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ;	      int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ;	  
  int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ;      	int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ;	      int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ;	  
  while ( ( low_row > 0 - r && low_column > 0 - c ) ) {	      	while ( ( low_row > 0 - r && low_column > 0 - c ) ) {	      while ( ( low_row > 0 - r && low_column > 0 - c ) ) {	  
    for ( i = low_column + 1 ;				      	  for ( i = low_column + 1 ;				    	for ( i = low_column + 1 ;				  
    i <= high_column && i < c && low_row >= 0 ;		      	  i <= high_column && i < c && low_row >= 0 ;		    	i <= high_column && i < c && low_row >= 0 ;		  
    ++ i ) System . out . print ( mat [ low_row ] [ i ] + " " 	  ++ i ) cout << mat [ low_row ] [ i ] << " " ;		    	++ i ) {						  
    low_row -= 1 ;					      	  low_row -= 1 ;					    	  cout << mat [ low_row ] [ i ] << " " ;		  
    for ( i = low_row + 2 ;				      	  for ( i = low_row + 2 ;				    	}							  
    i <= high_row && i < r && high_column < c ;		      	  i <= high_row && i < r && high_column < c ;		    	low_row -= 1 ;						  
    ++ i ) System . out . print ( mat [ i ] [ high_column ] + 	  ++ i ) cout << mat [ i ] [ high_column ] << " " ;	    	for ( i = low_row + 2 ;					  
    high_column += 1 ;					      	  high_column += 1 ;					    	i <= high_row && i < r && high_column < c ;		  
    for ( i = high_column - 2 ;				      	  for ( i = high_column - 2 ;				    	++ i ) {						  
    i >= low_column && i >= 0 && high_row < r ;		      	  i >= low_column && i >= 0 && high_row < r ;		    	  cout << mat [ i ] [ high_column ] << " " ;		  
    -- i ) System . out . print ( mat [ high_row ] [ i ] + "  	  -- i ) cout << mat [ high_row ] [ i ] << " " ;	    	}							  
    high_row += 1 ;					      	  high_row += 1 ;					    	high_column += 1 ;					  
    for ( i = high_row - 2 ;				      	  for ( i = high_row - 2 ;				    	for ( i = high_column - 2 ;				  
    i > low_row && i >= 0 && low_column >= 0 ;		      	  i > low_row && i >= 0 && low_column >= 0 ;		    	i >= low_column && i >= 0 && high_row < r ;		  
    -- i ) System . out . print ( mat [ i ] [ low_column ] +  	  -- i ) cout << mat [ i ] [ low_column ] << " " ;	    	-- i ) {						  
    low_column -= 1 ;					      	  low_column -= 1 ;					    	  cout << mat [ high_row ] [ i ] << " " ;		  
  }							      	}							    	}							  
  System . out . println ( ) ;				      	cout << endl ;						    	high_row += 1 ;						  
}							      }								    	for ( i = high_row - 2 ;				  
							      								    	i > low_row && i >= 0 && low_column >= 0 ;		  
							      								    	-- i ) {						  
							      								    	  cout << mat [ i ] [ low_column ] << " " ;		  
							      								    	}							  
							      								    	low_column -= 1 ;					  
							      								      }								  
							      								      cout << endl ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERIAN_PATH_UNDIRECTED_GRAPH				      EULERIAN_PATH_UNDIRECTED_GRAPH				    EULERIAN_PATH_UNDIRECTED_GRAPH				  EULERIAN_PATH_UNDIRECTED_GRAPH
--							      --							    --								  --
static void findpath ( int [ ] [ ] graph , int n ) {	      void findpath ( int graph [ ] [ 5 ] , int n ) {		    void findpath ( vector < vector < int >> & graph , int n ) {  script_not_found : None
  Vector < Integer > numofadj = new Vector < > ( ) ;	      	vector < int > numofadj ;				      vector < int > numofadj ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < n ;						      	i < n ;							      i < n ;							  
  i ++ ) numofadj . add ( accumulate ( graph [ i ] , 0 ) ) ;  	i ++ ) numofadj . push_back ( accumulate ( graph [ i ] , gr   i ++ ) {							  
  int startPoint = 0 , numofodd = 0 ;			      	int startpoint = 0 , numofodd = 0 ;			    	numofadj . push_back ( accumulate ( graph [ i ] . begin ( 
  for ( int i = n - 1 ;					      	for ( int i = n - 1 ;					      }								  
  i >= 0 ;						      	i >= 0 ;						      int startPoint = 0 , numofodd = 0 ;			  
  i -- ) {						      	i -- ) {						      for ( int i = n - 1 ;					  
    if ( numofadj . elementAt ( i ) % 2 == 1 ) {	      	  if ( numofadj [ i ] % 2 == 1 ) {			      i >= 0 ;							  
      numofodd ++ ;					      	    numofodd ++ ;					      i -- ) {							  
      startPoint = i ;					      	    startpoint = i ;					    	if ( numofadj [ i ] % 2 == 1 ) {			  
    }							      	  }							    	  numofodd ++ ;						  
  }							      	}							    	  startPoint = i ;					  
  if ( numofodd > 2 ) {					      	if ( numofodd > 2 ) {					    	}							  
    System . out . println ( "No Solution" ) ;		      	  cout << "No Solution" << endl ;			      }								  
    return ;						      	  return ;						      if ( numofodd > 2 ) {					  
  }							      	}							    	cout << "No Solution" << endl ;				  
  Stack < Integer > stack = new Stack < > ( ) ;		      	stack < int > stack ;					    	return ;						  
  Vector < Integer > path = new Vector < > ( ) ;	      	vector < int > path ;					      }								  
  int cur = startPoint ;				      	int cur = startpoint ;					      stack < int > stack ;					  
  while ( ! stack . isEmpty ( ) || accumulate ( graph [ cur ] 	while ( ! stack . empty ( ) or accumulate ( graph [ cur ] ,   vector < int > path ;					  
    if ( accumulate ( graph [ cur ] , 0 ) == 0 ) {	      	  if ( accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 )   int cur = startPoint ;					  
      path . add ( cur ) ;				      	    path . push_back ( cur ) ;				      while ( ! stack . empty ( ) || accumulate ( graph [ cur ] . 
      cur = stack . pop ( ) ;				      	    cur = stack . top ( ) ;				    	if ( accumulate ( graph [ cur ] . begin ( ) , graph [ cur 
    }							      	    stack . pop ( ) ;					    	  path . push_back ( cur ) ;				  
    else {						      	  }							    	  cur = stack . top ( ) ;				  
      for ( int i = 0 ;					      	  else {						    	}							  
      i < n ;						      	    for ( int i = 0 ;					    	else {							  
      i ++ ) {						      	    i < n ;						    	  for ( int i = 0 ;					  
	if ( graph [ cur ] [ i ] == 1 ) {		      	    i ++ ) {						    	  i < n ;						  
	  stack . add ( cur ) ;				      	      if ( graph [ cur ] [ i ] == 1 ) {			    	  i ++ ) {						  
	  graph [ cur ] [ i ] = 0 ;			      		stack . push ( cur ) ;				    	    if ( graph [ cur ] [ i ] == 1 ) {			  
	  graph [ i ] [ cur ] = 0 ;			      		graph [ cur ] [ i ] = 0 ;			    	      stack . push ( cur ) ;				  
	  cur = i ;					      		graph [ i ] [ cur ] = 0 ;			    	      graph [ cur ] [ i ] = 0 ;				  
	  break ;					      		cur = i ;					    	      graph [ i ] [ cur ] = 0 ;				  
	}						      		break ;						    	      cur = i ;						  
      }							      	      }							    	      break ;						  
    }							      	    }							    	    }							  
  }							      	  }							    	  }							  
  for ( int ele : path ) System . out . print ( ele + " -> "  	}							    	}							  
  System . out . println ( cur ) ;			      	for ( auto ele : path ) cout << ele << " -> " ;		      }								  
}							      	cout << cur << endl ;					      for ( int ele : path ) {					  
							      }								    	cout << ele << " -> " ;					  
							      								      }								  
							      								      cout << cur << endl ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L		      MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L		    MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L		  MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L
--							      --							    --								  --
static int findMaxValue ( int [ ] arr , int n ) {	      - 100000000 int findMaxValue ( int arr [ ] , int n ) {	    int findMaxValue ( int * arr , int n ) {			  script_not_found : None
  if ( n < 4 ) {					      	if ( n < 4 ) {						      if ( n < 4 ) cout << "The array should have" << " atleast 4 
    System . out . println ( "The array should have" + " atle 	  printf ( "The array should have atlest 4 elements\n" ) ;    int table1 [ n + 1 ] ;					  
  }							      	  return MIN ;						      int table2 [ n ] ;					  
  int table1 [ ] = new int [ n + 1 ] ;			      	}							      int table3 [ n - 1 ] ;					  
  int table2 [ ] = new int [ n ] ;			      	int table1 [ n + 1 ] , table2 [ n ] , table3 [ n - 1 ] , ta   int table4 [ n - 2 ] ;					  
  int table3 [ ] = new int [ n - 1 ] ;			      	for ( int i = 0 ;					      memset ( table1 , 0 , sizeof ( int ) * n ) ;		  
  int table4 [ ] = new int [ n - 2 ] ;			      	i <= n ;						      memset ( table2 , 0 , sizeof ( int ) * n ) ;		  
  Arrays . fill ( table1 , Integer . MIN_VALUE ) ;	      	i ++ ) table1 [ i ] = table2 [ i ] = table3 [ i ] = table4    memset ( table3 , 0 , sizeof ( int ) * n ) ;		  
  Arrays . fill ( table2 , Integer . MIN_VALUE ) ;	      	for ( int i = n - 1 ;					      memset ( table4 , 0 , sizeof ( int ) * n ) ;		  
  Arrays . fill ( table3 , Integer . MIN_VALUE ) ;	      	i >= 0 ;						      for ( int i = n - 1 ;					  
  Arrays . fill ( table4 , Integer . MIN_VALUE ) ;	      	i -- ) table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] )    i >= 0 ;							  
  for ( int i = n - 1 ;					      	for ( int i = n - 2 ;					      i -- ) table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] )  
  i >= 0 ;						      	i >= 0 ;						      for ( int i = n - 2 ;					  
  i -- ) {						      	i -- ) table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i +   i >= 0 ;							  
    table1 [ i ] = Math . max ( table1 [ i + 1 ] , arr [ i ]  	for ( int i = n - 3 ;					      i -- ) table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 
  }							      	i >= 0 ;						      for ( int i = n - 3 ;					  
  for ( int i = n - 2 ;					      	i -- ) table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i +   i >= 0 ;							  
  i >= 0 ;						      	for ( int i = n - 4 ;					      i -- ) table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 
  i -- ) {						      	i >= 0 ;						      for ( int i = n - 4 ;					  
    table2 [ i ] = Math . max ( table2 [ i + 1 ] , table1 [ i 	i -- ) table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i +   i >= 0 ;							  
  }							      	return table4 [ 0 ] ;					      i -- ) table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 
  for ( int i = n - 3 ;					      }								      return table4 [ 0 ] ;					  
  i >= 0 ;						      								    }								  
  i -- ) table3 [ i ] = Math . max ( table3 [ i + 1 ] , table 								    								  
  for ( int i = n - 4 ;					      								    								  
  i >= 0 ;						      								    								  
  i -- ) table4 [ i ] = Math . max ( table4 [ i + 1 ] , table 								    								  
  return table4 [ 0 ] ;					      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PARTITION_NUMBER_TWO_DIVISBLE_PARTS			      PARTITION_NUMBER_TWO_DIVISBLE_PARTS			    PARTITION_NUMBER_TWO_DIVISBLE_PARTS				  PARTITION_NUMBER_TWO_DIVISBLE_PARTS
--							      --							    --								  --
static void findDivision ( String str , int a , int b ) {     void findDivision ( string & str , int a , int b ) {	    void findDivision ( string str , int a , int b ) {		  script_not_found : None
  int len = str . length ( ) ;				      	int len = str . length ( ) ;				      int len = str . length ( ) ;				  
  int [ ] lr = new int [ len + 1 ] ;			      	vector < int > lr ( len + 1 , 0 ) ;			      int lr [ len + 1 ] ;					  
  lr [ 0 ] = ( ( int ) str . charAt ( 0 ) - ( int ) '0' ) % a 	lr [ 0 ] = ( str [ 0 ] - '0' ) % a ;			      lr [ 0 ] = ( ( int ) str [ 0 ] - ( int ) '0' ) % a ;	  
  for ( int i = 1 ;					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
  i < len ;						      	i < len ;						      i < len ;							  
  i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ( int ) s 	i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( str [ i ]   i ++ ) {							  
  int [ ] rl = new int [ len + 1 ] ;			      	vector < int > rl ( len + 1 , 0 ) ;			    	lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( ( int ) str [  
  rl [ len - 1 ] = ( ( int ) str . charAt ( len - 1 ) - ( int 	rl [ len - 1 ] = ( str [ len - 1 ] - '0' ) % b ;	      }								  
  int power10 = 10 ;					      	int power10 = 10 ;					      int rl [ len + 1 ] ;					  
  for ( int i = len - 2 ;				      	for ( int i = len - 2 ;					      rl [ len - 1 ] = ( ( int ) str [ len - 1 ] - ( int ) '0' )  
  i >= 0 ;						      	i >= 0 ;						      int power10 = 10 ;					  
  i -- ) {						      	i -- ) {						      for ( int i = len - 2 ;					  
    rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str . charAt ( i )  	  rl [ i ] = ( rl [ i + 1 ] + ( str [ i ] - '0' ) * power10   i >= 0 ;							  
    power10 = ( power10 * 10 ) % b ;			      	  power10 = ( power10 * 10 ) % b ;			      i -- ) {							  
  }							      	}							    	rl [ i ] = ( rl [ i + 1 ] + ( ( int ) str [ i ] - ( int ) 
  for ( int i = 0 ;					      	for ( int i = 0 ;					    	power10 = ( power10 * 10 ) % b ;			  
  i < len - 1 ;						      	i < len - 1 ;						      }								  
  i ++ ) {						      	i ++ ) {						      for ( int i = 0 ;						  
    if ( lr [ i ] != 0 ) continue ;			      	  if ( lr [ i ] != 0 ) continue ;			      i < len - 1 ;						  
    if ( rl [ i + 1 ] == 0 ) {				      	  if ( rl [ i + 1 ] == 0 ) {				      i ++ ) {							  
      System . out . println ( "YES" ) ;		      	    cout << "YES\n" ;					    	if ( lr [ i ] != 0 ) continue ;				  
      for ( int k = 0 ;					      	    for ( int k = 0 ;					    	if ( rl [ i + 1 ] == 0 ) {				  
      k <= i ;						      	    k <= i ;						    	  cout << "YES" << endl ;				  
      k ++ ) System . out . print ( str . charAt ( k ) ) ;    	    k ++ ) cout << str [ k ] ;				    	  for ( int k = 0 ;					  
      System . out . print ( ", " ) ;			      	    cout << ", " ;					    	  k <= i ;						  
      for ( int k = i + 1 ;				      	    for ( int k = i + 1 ;				    	  k ++ ) {						  
      k < len ;						      	    k < len ;						    	    cout << str [ k ] ;					  
      k ++ ) System . out . print ( str . charAt ( k ) ) ;    	    k ++ ) cout << str [ k ] ;				    	  }							  
      return ;						      	    return ;						    	  cout << ", " ;					  
    }							      	  }							    	  for ( int k = i + 1 ;					  
  }							      	}							    	  k < len ;						  
  System . out . println ( "NO" ) ;			      	cout << "NO\n" ;					    	  k ++ ) {						  
}							      }								    	    cout << str [ k ] ;					  
							      								    	  }							  
							      								    	  return ;						  
							      								    	}							  
							      								      }								  
							      								      cout << "NO" << endl ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_SPECIFIC_PAIR_IN_MATRIX_1			      FIND_A_SPECIFIC_PAIR_IN_MATRIX_1				    FIND_A_SPECIFIC_PAIR_IN_MATRIX_1				  FIND_A_SPECIFIC_PAIR_IN_MATRIX_1
--							      --							    --								  --
static int findMaxValue ( int N , int mat [ ] [ ] ) {	      int findMaxValue ( int mat [ ] [ N ] ) {			    int findMaxValue ( int N , int mat [ ] [ N ] ) {		  script_not_found : None
  int maxValue = Integer . MIN_VALUE ;			      	int maxValue = INT_MIN ;				      int maxValue = std :: numeric_limits < int > :: min ( ) ;	  
  int maxArr [ ] [ ] = new int [ N ] [ N ] ;		      	int maxArr [ N ] [ N ] ;				      int maxArr [ N ] [ N ] ;					  
  maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ;      	maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ;	      maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ;	  
  int maxv = mat [ N - 1 ] [ N - 1 ] ;			      	int maxv = mat [ N - 1 ] [ N - 1 ] ;			      int maxv = mat [ N - 1 ] [ N - 1 ] ;			  
  for ( int j = N - 2 ;					      	for ( int j = N - 2 ;					      for ( int j = N - 2 ;					  
  j >= 0 ;						      	j >= 0 ;						      j >= 0 ;							  
  j -- ) {						      	j -- ) {						      j -- ) {							  
    if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [  	  if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [  	if ( mat [ N - 1 ] [ j ] > maxv ) {			  
    maxArr [ N - 1 ] [ j ] = maxv ;			      	  maxArr [ N - 1 ] [ j ] = maxv ;			    	  maxv = mat [ N - 1 ] [ j ] ;				  
  }							      	}							    	}							  
  maxv = mat [ N - 1 ] [ N - 1 ] ;			      	maxv = mat [ N - 1 ] [ N - 1 ] ;			    	maxArr [ N - 1 ] [ j ] = maxv ;				  
  for ( int i = N - 2 ;					      	for ( int i = N - 2 ;					      }								  
  i >= 0 ;						      	i >= 0 ;						      maxv = mat [ N - 1 ] [ N - 1 ] ;				  
  i -- ) {						      	i -- ) {						      for ( int i = N - 2 ;					  
    if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N -  	  if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N -    i >= 0 ;							  
    maxArr [ i ] [ N - 1 ] = maxv ;			      	  maxArr [ i ] [ N - 1 ] = maxv ;			      i -- ) {							  
  }							      	}							    	if ( mat [ i ] [ N - 1 ] > maxv ) {			  
  for ( int i = N - 2 ;					      	for ( int i = N - 2 ;					    	  maxv = mat [ i ] [ N - 1 ] ;				  
  i >= 0 ;						      	i >= 0 ;						    	}							  
  i -- ) {						      	i -- ) {						    	maxArr [ i ] [ N - 1 ] = maxv ;				  
    for ( int j = N - 2 ;				      	  for ( int j = N - 2 ;					      }								  
    j >= 0 ;						      	  j >= 0 ;						      for ( int i = N - 2 ;					  
    j -- ) {						      	  j -- ) {						      i >= 0 ;							  
      if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > max 	    if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > max   i -- ) {							  
      maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Mat 	    maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxA 	for ( int j = N - 2 ;					  
    }							      	  }							    	j >= 0 ;						  
  }							      	}							    	j -- ) {						  
  return maxValue ;					      	return maxValue ;					    	  if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > max 
}							      }								    	    maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j 
							      								    	  }							  
							      								    	  maxArr [ i ] [ j ] = std :: max ( mat [ i ] [ j ] , std 
							      								    	}							  
							      								      }								  
							      								      return maxValue ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER	      COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER		    COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER		  COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER
--							      --							    --								  --
static int numofArray ( int n , int m ) {		      int numofArray ( int n , int m ) {			    int numof_array ( int n , int m ) {				  script_not_found : None
  int [ ] [ ] dp = new int [ MAX ] [ MAX ] ;		      	int dp [ MAX ] [ MAX ] ;				      vector < vector < int >> dp ( MAX , vector < int > ( MAX ,  
  Vector < Integer > [ ] di = new Vector [ MAX ] ;	      	vector < int > di [ MAX ] ;				      vector < vector < int >> di ( MAX , vector < int > ( MAX ,  
  Vector < Integer > [ ] mu = new Vector [ MAX ] ;	      	vector < int > mu [ MAX ] ;				      vector < vector < int >> mu ( MAX , vector < int > ( MAX ,  
  for ( int i = 0 ;					      	memset ( dp , 0 , sizeof dp ) ;				      for ( int i = 0 ;						  
  i < MAX ;						      	memset ( di , 0 , sizeof di ) ;				      i < MAX ;							  
  i ++ ) {						      	memset ( mu , 0 , sizeof mu ) ;				      i ++ ) {							  
    for ( int j = 0 ;					      	for ( int i = 1 ;					    	for ( int j = 0 ;					  
    j < MAX ;						      	i <= m ;						    	j < MAX ;						  
    j ++ ) {						      	i ++ ) {						    	j ++ ) dp [ i ] [ j ] = 0 ;				  
      dp [ i ] [ j ] = 0 ;				      	  for ( int j = 2 * i ;					      }								  
    }							      	  j <= m ;						      for ( int i = 0 ;						  
  }							      	  j += i ) {						      i < MAX ;							  
  for ( int i = 0 ;					      	    di [ j ] . push_back ( i ) ;			      i ++ ) {							  
  i < MAX ;						      	    mu [ i ] . push_back ( j ) ;			    	di [ i ] . clear ( ) ;					  
  i ++ ) {						      	  }							    	mu [ i ] . clear ( ) ;					  
    di [ i ] = new Vector < > ( ) ;			      	  di [ i ] . push_back ( i ) ;				      }								  
    mu [ i ] = new Vector < > ( ) ;			      	}							      for ( int i = 1 ;						  
  }							      	for ( int i = 1 ;					      i <= m ;							  
  for ( int i = 1 ;					      	i <= m ;						      i ++ ) {							  
  i <= m ;						      	i ++ ) dp [ 1 ] [ i ] = 1 ;				    	for ( int j = 2 * i ;					  
  i ++ ) {						      	for ( int i = 2 ;					    	j <= m ;						  
    for ( int j = 2 * i ;				      	i <= n ;						    	j += i ) {						  
    j <= m ;						      	i ++ ) {						    	  di [ j ] . push_back ( i ) ;				  
    j += i ) {						      	  for ( int j = 1 ;					    	  mu [ i ] . push_back ( j ) ;				  
      di [ j ] . add ( i ) ;				      	  j <= m ;						    	}							  
      mu [ i ] . add ( j ) ;				      	  j ++ ) {						    	di [ i ] . push_back ( i ) ;				  
    }							      	    dp [ i ] [ j ] = 0 ;				      }								  
    di [ i ] . add ( i ) ;				      	    for ( auto x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1    for ( int i = 1 ;						  
  }							      	    for ( auto x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1    i <= m ;							  
  for ( int i = 1 ;					      	  }							      i ++ ) {							  
  i <= m ;						      	}							    	dp [ 1 ] [ i ] = 1 ;					  
  i ++ ) dp [ 1 ] [ i ] = 1 ;				      	int ans = 0 ;						      }								  
  for ( int i = 2 ;					      	for ( int i = 1 ;					      for ( int i = 2 ;						  
  i <= n ;						      	i <= m ;						      i <= n ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 1 ;					      	  ans += dp [ n ] [ i ] ;				    	for ( int j = 1 ;					  
    j <= m ;						      	  di [ i ] . clear ( ) ;				    	j <= m ;						  
    j ++ ) {						      	  mu [ i ] . clear ( ) ;				    	j ++ ) {						  
      dp [ i ] [ j ] = 0 ;				      	}							    	  dp [ i ] [ j ] = 0 ;					  
      for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 	return ans ;						    	  for ( int x : di [ j ] ) {				  
      for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - }								    	    dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;		  
    }							      								    	  }							  
  }							      								    	  for ( int x : mu [ j ] ) {				  
  int ans = 0 ;						      								    	    dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;		  
  for ( int i = 1 ;					      								    	  }							  
  i <= m ;						      								    	}							  
  i ++ ) {						      								      }								  
    ans += dp [ n ] [ i ] ;				      								      int ans = 0 ;						  
    di [ i ] . clear ( ) ;				      								      for ( int i = 1 ;						  
    mu [ i ] . clear ( ) ;				      								      i <= m ;							  
  }							      								      i ++ ) {							  
  return ans ;						      								    	ans += dp [ n ] [ i ] ;					  
}							      								    	di [ i ] . clear ( ) ;					  
							      								    	mu [ i ] . clear ( ) ;					  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1		      MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1		    MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1		  MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1
--							      --							    --								  --
static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) {  long long int MaximumDecimalValue ( int mat [ ] [ N ] , int n int MaximumDecimalValue ( int mat [ ] [ 2 ] , int n ) {	  script_not_found : None
  int dp [ ] [ ] = new int [ n ] [ n ] ;		      	int dp [ n ] [ n ] ;					      int dp [ n ] [ n ] ;					  
  if ( mat [ 0 ] [ 0 ] == 1 ) {				      	memset ( dp , 0 , sizeof ( dp ) ) ;			      if ( mat [ 0 ] [ 0 ] == 1 ) dp [ 0 ] [ 0 ] = 1 ;		  
    dp [ 0 ] [ 0 ] = 1 ;				      	if ( mat [ 0 ] [ 0 ] == 1 ) dp [ 0 ] [ 0 ] = 1 ;	      for ( int i = 1 ;						  
  }							      	for ( int i = 1 ;					      i < n ;							  
  for ( int i = 1 ;					      	i < n ;							      i ++ ) {							  
  i < n ;						      	i ++ ) {						    	if ( mat [ 0 ] [ i ] == 1 ) dp [ 0 ] [ i ] = ( int ) ( dp 
  i ++ ) {						      	  if ( mat [ 0 ] [ i ] == 1 ) dp [ 0 ] [ i ] = dp [ 0 ] [ i 	else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ;		  
    if ( mat [ 0 ] [ i ] == 1 ) {			      	  else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ;		      }								  
      dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math .  	}							      for ( int i = 1 ;						  
    }							      	for ( int i = 1 ;					      i < n ;							  
    else {						      	i < n ;							      i ++ ) {							  
      dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ;		      	i ++ ) {						    	if ( mat [ i ] [ 0 ] == 1 ) dp [ i ] [ 0 ] = ( int ) ( dp 
    }							      	  if ( mat [ i ] [ 0 ] == 1 ) dp [ i ] [ 0 ] = dp [ i - 1 ] 	else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;		  
  }							      	  else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;		      }								  
  for ( int i = 1 ;					      	}							      for ( int i = 1 ;						  
  i < n ;						      	for ( int i = 1 ;					      i < n ;							  
  i ++ ) {						      	i < n ;							      i ++ ) {							  
    if ( mat [ i ] [ 0 ] == 1 ) {			      	i ++ ) {						    	for ( int j = 1 ;					  
      dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math .  	  for ( int j = 1 ;					    	j < n ;							  
    }							      	  j < n ;						    	j ++ ) {						  
    else {						      	  j ++ ) {						    	  if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = ( int ) (  
      dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;		      	    if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = max ( dp [ 	  else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i 
    }							      	    else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i 	}							  
  }							      	  }							      }								  
  for ( int i = 1 ;					      	}							      return dp [ n - 1 ] [ n - 1 ] ;				  
  i < n ;						      	return dp [ n - 1 ] [ n - 1 ] ;				    }								  
  i ++ ) {						      }								    								  
    for ( int j = 1 ;					      								    								  
    j < n ;						      								    								  
    j ++ ) {						      								    								  
      if ( mat [ i ] [ j ] == 1 ) {			      								    								  
	dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j  								    								  
      }							      								    								  
      else {						      								    								  
	dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp 								    								  
      }							      								    								  
    }							      								    								  
  }							      								    								  
  return dp [ n - 1 ] [ n - 1 ] ;			      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIRECTION_LAST_SQUARE_BLOCK				      DIRECTION_LAST_SQUARE_BLOCK				    DIRECTION_LAST_SQUARE_BLOCK					  DIRECTION_LAST_SQUARE_BLOCK
--							      --							    --								  --
static void direction ( int R , int C ) {		      void direction ( ll R , ll C ) {				    void direction ( int R , int C ) {				  script_not_found : None
  if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) {	      	if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) {	      if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) {	  
    System . out . println ( "Left" ) ;			      	  cout << "Left" << endl ;				    	cout << "Left" << endl ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) {	      	if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) {	      if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) {	  
    System . out . println ( "Up" ) ;			      	  cout << "Up" << endl ;				    	cout << "Up" << endl ;					  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( R == C && R % 2 != 0 && C % 2 != 0 ) {		      	if ( R == C && R % 2 != 0 && C % 2 != 0 ) {		      if ( R == C && R % 2 != 0 && C % 2 != 0 ) {		  
    System . out . println ( "Right" ) ;		      	  cout << "Right" << endl ;				    	cout << "Right" << endl ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( R == C && R % 2 == 0 && C % 2 == 0 ) {		      	if ( R == C && R % 2 == 0 && C % 2 == 0 ) {		      if ( R == C && R % 2 == 0 && C % 2 == 0 ) {		  
    System . out . println ( "Left" ) ;			      	  cout << "Left" << endl ;				    	cout << "Left" << endl ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) {	      	if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) {	      if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) {	  
    System . out . println ( "Right" ) ;		      	  cout << "Right" << endl ;				    	cout << "Right" << endl ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) {	      	if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) {	      if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) {	  
    System . out . println ( "Down" ) ;			      	  cout << "Down" << endl ;				    	cout << "Down" << endl ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) {	      	if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) {	      if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) {	  
    System . out . println ( "Left" ) ;			      	  cout << "Left" << endl ;				    	cout << "Left" << endl ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) {	      	if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) {	      if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) {	  
    System . out . println ( "Up" ) ;			      	  cout << "Up" << endl ;				    	cout << "Up" << endl ;					  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) {	      	if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) {	      if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) {	  
    System . out . println ( "Down" ) ;			      	  cout << "Down" << endl ;				    	cout << "Down" << endl ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
  if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) {	      	if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) {	      if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) {	  
    System . out . println ( "Right" ) ;		      	  cout << "Right" << endl ;				    	cout << "Right" << endl ;				  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER
--							      --							    --								  --
static String findSubString ( String str , String pat ) {     string findSubString ( string str , string pat ) {	    string findSubString ( string str , string pat ) {		  script_not_found : None
  int len1 = str . length ( ) ;				      	int len1 = str . length ( ) ;				      int len1 = str . length ( ) ;				  
  int len2 = pat . length ( ) ;				      	int len2 = pat . length ( ) ;				      int len2 = pat . length ( ) ;				  
  if ( len1 < len2 ) {					      	if ( len1 < len2 ) {					      if ( len1 < len2 ) {					  
    System . out . println ( "No such window exists" ) ;      	  cout << "No such window exists" ;			    	cout << "No such window exists" << endl ;		  
    return "" ;						      	  return "" ;						    	return "" ;						  
  }							      	}							      }								  
  int hash_pat [ ] = new int [ no_of_chars ] ;		      	int hash_pat [ no_of_chars ] = {			      vector < int > hash_pat ( no_of_chars , 0 ) ;		  
  int hash_str [ ] = new int [ no_of_chars ] ;		      	  0 }							      vector < int > hash_str ( no_of_chars , 0 ) ;		  
  for ( int i = 0 ;					      	  ;							      for ( int i = 0 ;						  
  i < len2 ;						      	  int hash_str [ no_of_chars ] = {			      i < len2 ;						  
  i ++ ) hash_pat [ pat . charAt ( i ) ] ++ ;		      	    0 }							      i ++ ) {							  
  int start = 0 , start_index = - 1 , min_len = Integer . MAX 	    ;							    	hash_pat [ pat [ i ] ] ++ ;				  
  int count = 0 ;					      	    for ( int i = 0 ;					      }								  
  for ( int j = 0 ;					      	    i < len2 ;						      int start = 0 , start_index = - 1 , min_len = INT_MAX ;	  
  j < len1 ;						      	    i ++ ) hash_pat [ pat [ i ] ] ++ ;			      int count = 0 ;						  
  j ++ ) {						      	    int start = 0 , start_index = - 1 , min_len = INT_MAX ;   for ( int j = 0 ;						  
    hash_str [ str . charAt ( j ) ] ++ ;		      	    int count = 0 ;					      j < len1 ;						  
    if ( hash_pat [ str . charAt ( j ) ] != 0 && hash_str [ s 	    for ( int j = 0 ;					      j ++ ) {							  
    if ( count == len2 ) {				      	    j < len1 ;						    	hash_str [ str [ j ] ] ++ ;				  
      while ( hash_str [ str . charAt ( start ) ] > hash_pat  	    j ++ ) {						    	if ( hash_pat [ str [ j ] ] != 0 && hash_str [ str [ j ]  
	if ( hash_str [ str . charAt ( start ) ] > hash_pat [ 	      hash_str [ str [ j ] ] ++ ;			    	  count ++ ;						  
	start ++ ;					      	      if ( hash_pat [ str [ j ] ] != 0 && hash_str [ str [  	}							  
      }							      	      if ( count == len2 ) {				    	if ( count == len2 ) {					  
      int len_window = j - start + 1 ;			      		while ( hash_str [ str [ start ] ] > hash_pat [ str 	  while ( hash_str [ str [ start ] ] > hash_pat [ str [ s 
      if ( min_len > len_window ) {			      		  if ( hash_str [ str [ start ] ] > hash_pat [ str  	    if ( hash_str [ str [ start ] ] > hash_pat [ str [ st 
	min_len = len_window ;				      		  start ++ ;					    	      hash_str [ str [ start ] ] -- ;			  
	start_index = start ;				      		}						    	    }							  
      }							      		int len_window = j - start + 1 ;		    	    start ++ ;						  
    }							      		if ( min_len > len_window ) {			    	  }							  
  }							      		  min_len = len_window ;			    	  int len_window = j - start + 1 ;			  
  if ( start_index == - 1 ) {				      		  start_index = start ;				    	  if ( min_len > len_window ) {				  
    System . out . println ( "No such window exists" ) ;      		}						    	    min_len = len_window ;				  
    return "" ;						      	      }							    	    start_index = start ;				  
  }							      	    }							    	  }							  
  return str . substring ( start_index , start_index + min_le 	    if ( start_index == - 1 ) {				    	}							  
}							      	      cout << "No such window exists" ;			      }								  
							      	      return "" ;					      if ( start_index == - 1 ) {				  
							      	    }							    	cout << "No such window exists" << endl ;		  
							      	    return str . substr ( start_index , min_len ) ;	    	return "" ;						  
							      	  }							      }								  
							      								      return str . substr ( start_index , start_index + min_len ) 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERS_FOUR_SQUARE_IDENTITY_1				      EULERS_FOUR_SQUARE_IDENTITY_1				    EULERS_FOUR_SQUARE_IDENTITY_1				  EULERS_FOUR_SQUARE_IDENTITY_1
--							      --							    --								  --
public static void checkEulerFourSquareIdentity ( int a , int void checkEulerFourSquareIdentity ( int a , int b ) {	    void checkEulerFourSquareIdentity ( int a , int b ) {	  script_not_found : None
  int ab = a * b ;					      	int ab = a * b ;					      int ab = a * b ;						  
  boolean flag = false ;				      	bool flag = false ;					      bool flag = false ;					  
  int i = 0 ;						      	int i = 0 ;						      int i = 0 ;						  
  while ( i * i <= ab ) {				      	while ( i * i <= ab ) {					      while ( i * i <= ab ) {					  
    int j = i ;						      	  int j = i ;						    	int j = i ;						  
    while ( i * i + j * j <= ab ) {			      	  while ( i * i + j * j <= ab ) {			    	while ( i * i + j * j <= ab ) {				  
      int k = j ;					      	    int k = j ;						    	  int k = j ;						  
      while ( i * i + j * j + k * k <= ab ) {		      	    while ( i * i + j * j + k * k <= ab ) {		    	  while ( i * i + j * j + k * k <= ab ) {		  
	double l = Math . sqrt ( ab - ( i * i + j * j + k * k 	      double l = sqrt ( ab - ( i * i + j * j + k * k ) ) ;  	    double l = sqrt ( ab - ( i * i + j * j + k * k ) ) ;  
	if ( Math . floor ( l ) == Math . ceil ( l ) && l >=  	      if ( floor ( l ) == ceil ( l ) && l >= k ) {	    	    if ( floor ( l ) == ceil ( l ) && l >= k ) {	  
	  flag = true ;					      		flag = true ;					    	      flag = true ;					  
	  System . out . print ( "i = " + i + "\n" ) ;	      		cout << "i = " << i << "\n" ;			    	      cout << "i = " << i << "\n" ;			  
	  System . out . print ( "j = " + j + "\n" ) ;	      		cout << "j = " << j << "\n" ;			    	      cout << "j = " << j << "\n" ;			  
	  System . out . print ( "k = " + k + "\n" ) ;	      		cout << "k = " << k << "\n" ;			    	      cout << "k = " << k << "\n" ;			  
	  System . out . print ( "l = " + ( int ) l + "\n" )  		cout << "l = " << ( int ) l << "\n" ;		    	      cout << "l = " << ( int ) l << "\n" ;		  
	  System . out . print ( "Product of " + a + " and "  		cout << "Product of " << a << " and " << b << " can 	      cout << "Product of " << a << " and " << b << " can 
	  System . out . print ( ab + " = " + i + "*" + i + " 		cout << ab + " = " << i << "*" << i << " + " << j < 	      cout << ab << " = " << i << "*" << i << " + " << j  
	}						      	      }							    	    }							  
	k += 1 ;					      	      k += 1 ;						    	    k += 1 ;						  
      }							      	    }							    	  }							  
      j += 1 ;						      	    j += 1 ;						    	  j += 1 ;						  
    }							      	  }							    	}							  
    i += 1 ;						      	  i += 1 ;						    	i += 1 ;						  
  }							      	}							      }								  
  if ( flag == false ) {				      	if ( flag == false ) {					      if ( flag == false ) {					  
    System . out . println ( "Solution doesn't exist!" ) ;    	  cout << "Solution doesn't exist!\n" ;			    	cout << "Solution doesn't exist!" << endl ;		  
    return ;						      	  return ;						    	return ;						  
  }							      	}							      }								  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_GEOMETRIC_PROGRESSION				      LONGEST_GEOMETRIC_PROGRESSION				    LONGEST_GEOMETRIC_PROGRESSION				  LONGEST_GEOMETRIC_PROGRESSION
--							      --							    --								  --
static int lenOfLongestGP ( int set [ ] , int n ) {	      int lenOfLongestGP ( int set [ ] , int n ) {		    int lenOfLongestGP ( int set [ ] , int n ) {		  script_not_found : None
  if ( n < 2 ) {					      	if ( n < 2 ) return n ;					      if ( n < 2 ) return n ;					  
    return n ;						      	if ( n == 2 ) return ( set [ 1 ] % set [ 0 ] == 0 ) ;	      if ( n == 2 ) return ( set [ 1 ] % set [ 0 ] == 0 ? 1 : 0 ) 
  }							      	sort ( set , set + n ) ;				      sort ( set , set + n ) ;					  
  if ( n == 2 ) {					      	int L [ n ] [ n ] ;					      int L [ n ] [ n ] ;					  
    return ( set [ 1 ] % set [ 0 ] == 0 ? 1 : 0 ) ;	      	int llgp = 1 ;						      int llgp = 1 ;						  
  }							      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  Arrays . sort ( set ) ;				      	i < n ;							      i < n ;							  
  int L [ ] [ ] = new int [ n ] [ n ] ;			      	++ i ) if ( set [ n - 1 ] % set [ i ] == 0 ) L [ i ] [ n -    ++ i ) {							  
  int llgp = 1 ;					      	else L [ i ] [ n - 1 ] = 1 ;				    	if ( set [ n - 1 ] % set [ i ] == 0 ) L [ i ] [ n - 1 ] = 
  for ( int i = 0 ;					      	for ( int j = n - 2 ;					    	else L [ i ] [ n - 1 ] = 1 ;				  
  i < n ;						      	j >= 1 ;						      }								  
  ++ i ) {						      	-- j ) {						      for ( int j = n - 2 ;					  
    if ( set [ n - 1 ] % set [ i ] == 0 ) {		      	  int i = j - 1 , k = j + 1 ;				      j >= 1 ;							  
      L [ i ] [ n - 1 ] = 2 ;				      	  while ( i >= 0 && k <= n - 1 ) {			      -- j ) {							  
    }							      	    if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) ++ 	int i = j - 1 , k = j + 1 ;				  
    else {						      	    else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] 	while ( i >= 0 && k <= n - 1 ) {			  
      L [ i ] [ n - 1 ] = 1 ;				      	      if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2 ; 	  if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) ++ 
    }							      	      else L [ i ] [ j ] = 1 ;				    	  else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] 
  }							      	      -- i ;						    	    if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2 ; 
  for ( int j = n - 2 ;					      	    }							    	    else L [ i ] [ j ] = 1 ;				  
  j >= 1 ;						      	    else {						    	    -- i ;						  
  -- j ) {						      	      L [ i ] [ j ] = L [ j ] [ k ] + 1 ;		    	  }							  
    int i = j - 1 , k = j + 1 ;				      	      if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ] ;    	  else {						  
    while ( i >= 0 && k <= n - 1 ) {			      	      -- i ;						    	    L [ i ] [ j ] = L [ j ] [ k ] + 1 ;			  
      if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) {  	      ++ k ;						    	    if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ] ;	  
	++ k ;						      	    }							    	    -- i ;						  
      }							      	  }							    	    ++ k ;						  
      else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] 	  while ( i >= 0 ) {					    	  }							  
	if ( set [ j ] % set [ i ] == 0 ) {		      	    if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2 ;   	}							  
	  L [ i ] [ j ] = 2 ;				      	    else L [ i ] [ j ] = 1 ;				    	while ( i >= 0 ) {					  
	}						      	    -- i ;						    	  if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2 ;	  
	else {						      	  }							    	  else L [ i ] [ j ] = 1 ;				  
	  L [ i ] [ j ] = 1 ;				      	}							    	  -- i ;						  
	}						      	return llgp ;						    	}							  
	-- i ;						      }								      }								  
      }							      								      return llgp ;						  
      else {						      								    }								  
	L [ i ] [ j ] = L [ j ] [ k ] + 1 ;		      								    								  
	if ( L [ i ] [ j ] > llgp ) {			      								    								  
	  llgp = L [ i ] [ j ] ;			      								    								  
	}						      								    								  
	-- i ;						      								    								  
	++ k ;						      								    								  
      }							      								    								  
    }							      								    								  
    while ( i >= 0 ) {					      								    								  
      if ( set [ j ] % set [ i ] == 0 ) {		      								    								  
	L [ i ] [ j ] = 2 ;				      								    								  
      }							      								    								  
      else {						      								    								  
	L [ i ] [ j ] = 1 ;				      								    								  
      }							      								    								  
      -- i ;						      								    								  
    }							      								    								  
  }							      								    								  
  return llgp ;						      								    								  
}							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DOOLITTLE_ALGORITHM_LU_DECOMPOSITION			      DOOLITTLE_ALGORITHM_LU_DECOMPOSITION			    DOOLITTLE_ALGORITHM_LU_DECOMPOSITION			  DOOLITTLE_ALGORITHM_LU_DECOMPOSITION
--							      --							    --								  --
static void luDecomposition ( int [ ] [ ] mat , int n ) {     void luDecomposition ( int mat [ ] [ MAX ] , int n ) {	    void lu_decomposition ( int * * mat , int n ) {		  script_not_found : None
  int [ ] [ ] lower = new int [ n ] [ n ] ;		      	int lower [ n ] [ n ] , upper [ n ] [ n ] ;		      int lower [ n ] [ n ] ;					  
  int [ ] [ ] upper = new int [ n ] [ n ] ;		      	memset ( lower , 0 , sizeof ( lower ) ) ;		      int upper [ n ] [ n ] ;					  
  for ( int i = 0 ;					      	memset ( upper , 0 , sizeof ( upper ) ) ;		      for ( int i = 0 ;						  
  i < n ;						      	for ( int i = 0 ;					      i < n ;							  
  i ++ ) {						      	i < n ;							      i ++ ) {							  
    for ( int k = i ;					      	i ++ ) {						    	for ( int k = i ;					  
    k < n ;						      	  for ( int k = i ;					    	k < n ;							  
    k ++ ) {						      	  k < n ;						    	k ++ ) {						  
      int sum = 0 ;					      	  k ++ ) {						    	  int sum = 0 ;						  
      for ( int j = 0 ;					      	    int sum = 0 ;					    	  for ( int j = 0 ;					  
      j < i ;						      	    for ( int j = 0 ;					    	  j < i ;						  
      j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) 	    j < i ;						    	  j ++ ) {						  
      upper [ i ] [ k ] = mat [ i ] [ k ] - sum ;	      	    j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) 	    sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ;	  
    }							      	    upper [ i ] [ k ] = mat [ i ] [ k ] - sum ;		    	  }							  
    for ( int k = i ;					      	  }							    	  upper [ i ] [ k ] = mat [ i ] [ k ] - sum ;		  
    k < n ;						      	  for ( int k = i ;					    	}							  
    k ++ ) {						      	  k < n ;						    	for ( int k = i ;					  
      if ( i == k ) lower [ i ] [ i ] = 1 ;		      	  k ++ ) {						    	k < n ;							  
      else {						      	    if ( i == k ) lower [ i ] [ i ] = 1 ;		    	k ++ ) {						  
	int sum = 0 ;					      	    else {						    	  if ( i == k ) {					  
	for ( int j = 0 ;				      	      int sum = 0 ;					    	    lower [ i ] [ i ] = 1 ;				  
	j < i ;						      	      for ( int j = 0 ;					    	  }							  
	j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] 	      j < i ;						    	  else {						  
	lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper 	      j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] 	    int sum = 0 ;					  
      }							      	      lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper 	    for ( int j = 0 ;					  
    }							      	    }							    	    j < i ;						  
  }							      	  }							    	    j ++ ) {						  
  System . out . println ( setw ( 2 ) + "     Lower Triangula 	}							    	      sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ;  
  for ( int i = 0 ;					      	cout << setw ( 6 ) << "	     Lower Triangular" << setw ( 32 	    }							  
  i < n ;						      	for ( int i = 0 ;					    	    lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper 
  i ++ ) {						      	i < n ;							    	  }							  
    for ( int j = 0 ;					      	i ++ ) {						    	}							  
    j < n ;						      	  for ( int j = 0 ;					      }								  
    j ++ ) System . out . print ( setw ( 4 ) + lower [ i ] [  	  j < n ;						      cout << setw ( 2 ) << "	  Lower Triangular" << setw ( 10  
    System . out . print ( "\t" ) ;			      	  j ++ ) cout << setw ( 6 ) << lower [ i ] [ j ] << "\t" ;    for ( int i = 0 ;						  
    for ( int j = 0 ;					      	  cout << "\t" ;					      i < n ;							  
    j < n ;						      	  for ( int j = 0 ;					      i ++ ) {							  
    j ++ ) System . out . print ( setw ( 4 ) + upper [ i ] [  	  j < n ;						    	for ( int j = 0 ;					  
    System . out . print ( "\n" ) ;			      	  j ++ ) cout << setw ( 6 ) << upper [ i ] [ j ] << "\t" ;  	j < n ;							  
  }							      	  cout << endl ;					    	j ++ ) {						  
}							      	}							    	  cout << setw ( 4 ) << lower [ i ] [ j ] << "\t" ;	  
							      }								    	}							  
							      								    	cout << "\t" ;						  
							      								    	for ( int j = 0 ;					  
							      								    	j < n ;							  
							      								    	j ++ ) {						  
							      								    	  cout << setw ( 4 ) << upper [ i ] [ j ] << "\t" ;	  
							      								    	}							  
							      								    	cout << "\n" ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS		      SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS			    SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS			  SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS
--							      --							    --								  --
static void printSuperSeq ( String a , String b ) {	      void printSuperSeq ( string & a , string & b ) {		    void printSuperSeq ( string a , string b ) {		  script_not_found : None
  int m = a . length ( ) , n = b . length ( ) ;		      	int m = a . length ( ) , n = b . length ( ) ;		      int m = a . length ( ) , n = b . length ( ) ;		  
  int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ;	      	int dp [ m + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( m + 1 , vector < int > ( n +  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i <= m ;						      	i <= m ;						      i <= m ;							  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    for ( int j = 0 ;					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    j <= n ;						      	  j <= n ;						    	j <= n ;						  
    j ++ ) {						      	  j ++ ) {						    	j ++ ) {						  
      if ( i == 0 ) dp [ i ] [ j ] = j ;		      	    if ( ! i ) dp [ i ] [ j ] = j ;			    	  if ( i == 0 ) {					  
      else if ( j == 0 ) dp [ i ] [ j ] = i ;		      	    else if ( ! j ) dp [ i ] [ j ] = i ;		    	    dp [ i ] [ j ] = j ;				  
      else if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 )  	    else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 	  }							  
      else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j 	    else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp 	  else if ( j == 0 ) {					  
    }							      	  }							    	    dp [ i ] [ j ] = i ;				  
  }							      	}							    	  }							  
  String res = "" ;					      	int index = dp [ m ] [ n ] ;				    	  else if ( a [ i - 1 ] == b [ j - 1 ] ) {		  
  int i = m , j = n ;					      	string res ( index + 1 , '\0' ) ;			    	    dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;	  
  while ( i > 0 && j > 0 ) {				      	int i = m , j = n ;					    	  }							  
    if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) {     	while ( i > 0 && j > 0 ) {				    	  else {						  
      res = a . charAt ( i - 1 ) + res ;		      	  if ( a [ i - 1 ] == b [ j - 1 ] ) {			    	    dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [  
      i -- ;						      	    res [ index - 1 ] = a [ i - 1 ] ;			    	  }							  
      j -- ;						      	    i -- ;						    	}							  
    }							      	    j -- ;						      }								  
    else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) {     	    index -- ;						      string res ;						  
      res = a . charAt ( i - 1 ) + res ;		      	  }							      int i = m , j = n ;					  
      i -- ;						      	  else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) {	      while ( i > 0 && j > 0 ) {				  
    }							      	    res [ index - 1 ] = a [ i - 1 ] ;			    	if ( a [ i - 1 ] == b [ j - 1 ] ) {			  
    else {						      	    i -- ;						    	  res = a [ i - 1 ] + res ;				  
      res = b . charAt ( j - 1 ) + res ;		      	    index -- ;						    	  i -- ;						  
      j -- ;						      	  }							    	  j -- ;						  
    }							      	  else {						    	}							  
  }							      	    res [ index - 1 ] = b [ j - 1 ] ;			    	else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) {	  
  while ( i > 0 ) {					      	    j -- ;						    	  res = a [ i - 1 ] + res ;				  
    res = a . charAt ( i - 1 ) + res ;			      	    index -- ;						    	  i -- ;						  
    i -- ;						      	  }							    	}							  
  }							      	}							    	else {							  
  while ( j > 0 ) {					      	while ( i > 0 ) {					    	  res = b [ j - 1 ] + res ;				  
    res = b . charAt ( j - 1 ) + res ;			      	  res [ index - 1 ] = a [ i - 1 ] ;			    	  j -- ;						  
    j -- ;						      	  i -- ;						    	}							  
  }							      	  index -- ;						      }								  
  System . out . println ( res ) ;			      	}							      while ( i > 0 ) {						  
}							      	while ( j > 0 ) {					    	res = a [ i - 1 ] + res ;				  
							      	  res [ index - 1 ] = b [ j - 1 ] ;			    	i -- ;							  
							      	  j -- ;						      }								  
							      	  index -- ;						      while ( j > 0 ) {						  
							      	}							    	res = b [ j - 1 ] + res ;				  
							      	cout << res ;						    	j -- ;							  
							      }								      }								  
							      								      cout << res << endl ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING    DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING    DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING	  DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING
--							      --							    --								  --
static String decode ( String str ) {			      string decode ( string str ) {				    string decode ( string str ) {				  success : None
  Stack < Integer > integerstack = new Stack < > ( ) ;	      	stack < int > integerstack ;				      stack < int > integerstack ;				  
  Stack < Character > stringstack = new Stack < > ( ) ;	      	stack < char > stringstack ;				      stack < char > stringstack ;				  
  String temp = "" , result = "" ;			      	string temp = "" , result = "" ;			      string temp , result ;					  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < str . length ( ) ;				      	i < str . length ( ) ;					      i < str . length ( ) ;					  
  i ++ ) {						      	i ++ ) {						      i ++ ) {							  
    int count = 0 ;					      	  int count = 0 ;					    	int count = 0 ;						  
    if ( Character . isDigit ( str . charAt ( i ) ) ) {	      	  if ( str [ i ] >= '0' && str [ i ] <= '9' ) {		    	if ( isdigit ( str [ i ] ) ) {				  
      while ( Character . isDigit ( str . charAt ( i ) ) ) {  	    while ( str [ i ] >= '0' && str [ i ] <= '9' ) {	    	  while ( isdigit ( str [ i ] ) ) {			  
	count = count * 10 + str . charAt ( i ) - '0' ;	      	      count = count * 10 + str [ i ] - '0' ;		    	    count = count * 10 + str [ i ] - '0' ;		  
	i ++ ;						      	      i ++ ;						    	    i ++ ;						  
      }							      	    }							    	  }							  
      i -- ;						      	    i -- ;						    	  i -- ;						  
      integerstack . push ( count ) ;			      	    integerstack . push ( count ) ;			    	  integerstack . push ( count ) ;			  
    }							      	  }							    	}							  
    else if ( str . charAt ( i ) == ']' ) {		      	  else if ( str [ i ] == ']' ) {			    	else if ( str [ i ] == ']' ) {				  
      temp = "" ;					      	    temp = "" ;						    	  temp = "" ;						  
      count = 0 ;					      	    count = 0 ;						    	  count = 0 ;						  
      if ( ! integerstack . isEmpty ( ) ) {		      	    if ( ! integerstack . empty ( ) ) {			    	  if ( ! integerstack . empty ( ) ) {			  
	count = integerstack . peek ( ) ;		      	      count = integerstack . top ( ) ;			    	    count = integerstack . top ( ) ;			  
	integerstack . pop ( ) ;			      	      integerstack . pop ( ) ;				    	    integerstack . pop ( ) ;				  
      }							      	    }							    	  }							  
      while ( ! stringstack . isEmpty ( ) && stringstack . pe 	    while ( ! stringstack . empty ( ) && stringstack . top  	  while ( ! stringstack . empty ( ) && stringstack . top  
	temp = stringstack . peek ( ) + temp ;		      	      temp = stringstack . top ( ) + temp ;		    	    temp = stringstack . top ( ) + temp ;		  
	stringstack . pop ( ) ;				      	      stringstack . pop ( ) ;				    	    stringstack . pop ( ) ;				  
      }							      	    }							    	  }							  
      if ( ! stringstack . empty ( ) && stringstack . peek (  	    if ( ! stringstack . empty ( ) && stringstack . top ( ) 	  if ( ! stringstack . empty ( ) && stringstack . top ( ) 
      for ( int j = 0 ;					      	    for ( int j = 0 ;					    	  for ( int j = 0 ;					  
      j < count ;					      	    j < count ;						    	  j < count ;						  
      j ++ ) result = result + temp ;			      	    j ++ ) result = result + temp ;			    	  j ++ ) result = result + temp ;			  
      for ( int j = 0 ;					      	    for ( int j = 0 ;					    	  for ( int j = 0 ;					  
      j < result . length ( ) ;				      	    j < result . length ( ) ;				    	  j < result . length ( ) ;				  
      j ++ ) stringstack . push ( result . charAt ( j ) ) ;   	    j ++ ) stringstack . push ( result [ j ] ) ;	    	  j ++ ) stringstack . push ( result [ j ] ) ;		  
      result = "" ;					      	    result = "" ;					    	  result . clear ( ) ;					  
    }							      	  }							    	}							  
    else if ( str . charAt ( i ) == '[' ) {		      	  else if ( str [ i ] == '[' ) {			    	else if ( str [ i ] == '[' ) {				  
      if ( Character . isDigit ( str . charAt ( i - 1 ) ) ) s 	    if ( str [ i - 1 ] >= '0' && str [ i - 1 ] <= '9' ) str 	  if ( isdigit ( str [ i - 1 ] ) ) stringstack . push ( s 
      else {						      	    else {						    	  else {						  
	stringstack . push ( str . charAt ( i ) ) ;	      	      stringstack . push ( str [ i ] ) ;		    	    stringstack . push ( str [ i ] ) ;			  
	integerstack . push ( 1 ) ;			      	      integerstack . push ( 1 ) ;			    	    integerstack . push ( 1 ) ;				  
      }							      	    }							    	  }							  
    }							      	  }							    	}							  
    else stringstack . push ( str . charAt ( i ) ) ;	      	  else stringstack . push ( str [ i ] ) ;		    	else stringstack . push ( str [ i ] ) ;			  
  }							      	}							      }								  
  while ( ! stringstack . isEmpty ( ) ) {		      	while ( ! stringstack . empty ( ) ) {			      while ( ! stringstack . empty ( ) ) {			  
    result = stringstack . peek ( ) + result ;		      	  result = stringstack . top ( ) + result ;		    	result = stringstack . top ( ) + result ;		  
    stringstack . pop ( ) ;				      	  stringstack . pop ( ) ;				    	stringstack . pop ( ) ;					  
  }							      	}							      }								  
  return result ;					      	return result ;						      return result ;						  
}							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE		      NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE		    NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE		  NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE
--							      --							    --								  --
static int numberofways ( String A , String B , int N , int M int numberofways ( string A , string B , int N , int M ) {    int numberofways ( string A , string B , int N , int M ) {	  script_not_found : None
  Vector < Integer > [ ] pos = new Vector [ MAX ] ;	      	vector < int > pos [ MAX ] ;				      vector < vector < int >> pos ;				  
  for ( int i = 0 ;					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
  i < MAX ;						      	i < M ;							      i < MAX ;							  
  i ++ ) pos [ i ] = new Vector < > ( ) ;		      	i ++ ) pos [ B [ i ] ] . push_back ( i + 1 ) ;		      i ++ ) {							  
  for ( int i = 0 ;					      	int dpl [ N + 2 ] [ M + 2 ] ;				    	pos . push_back ( vector < int > ( ) ) ;		  
  i < M ;						      	memset ( dpl , 0 , sizeof ( dpl ) ) ;			      }								  
  i ++ ) pos [ B . charAt ( i ) ] . add ( i + 1 ) ;	      	for ( int i = 1 ;					      for ( int i = 0 ;						  
  int [ ] [ ] dpl = new int [ N + 2 ] [ M + 2 ] ;	      	i <= N ;						      i < M ;							  
  for ( int i = 1 ;					      	i ++ ) {						      i ++ ) {							  
  i <= N ;						      	  for ( int j = 1 ;					    	pos [ B [ i ] ] . push_back ( i + 1 ) ;			  
  i ++ ) {						      	  j <= M ;						      }								  
    for ( int j = 1 ;					      	  j ++ ) {						      vector < vector < int >> dpl ( N + 2 , vector < int > ( M + 
    j <= M ;						      	    if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl   for ( int i = 1 ;						  
    j ++ ) {						      	    else dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl    i <= N ;							  
      if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpl 	  }							      i ++ ) {							  
      else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] 	}							    	for ( int j = 1 ;					  
    }							      	int LCS = dpl [ N ] [ M ] ;				    	j <= M ;						  
  }							      	int dpr [ N + 2 ] [ M + 2 ] ;				    	j ++ ) {						  
  int LCS = dpl [ N ] [ M ] ;				      	memset ( dpr , 0 , sizeof ( dpr ) ) ;			    	  if ( A [ i - 1 ] == B [ j - 1 ] ) {			  
  int [ ] [ ] dpr = new int [ N + 2 ] [ M + 2 ] ;	      	for ( int i = N ;					    	    dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ;	  
  for ( int i = N ;					      	i >= 1 ;						    	  }							  
  i >= 1 ;						      	i -- ) {						    	  else {						  
  i -- ) {						      	  for ( int j = M ;					    	    dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i 
    for ( int j = M ;					      	  j >= 1 ;						    	  }							  
    j >= 1 ;						      	  j -- ) {						    	}							  
    j -- ) {						      	    if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr   }								  
      if ( A . charAt ( i - 1 ) == B . charAt ( j - 1 ) ) dpr 	    else dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr    int LCS = dpl [ N ] [ M ] ;				  
      else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] 	  }							      vector < vector < int >> dpr ( N + 2 , vector < int > ( M + 
    }							      	}							      for ( int i = N ;						  
  }							      	int ans = 0 ;						      i >= 1 ;							  
  int ans = 0 ;						      	for ( int i = 0 ;					      i -- ) {							  
  for ( int i = 0 ;					      	i <= N ;						    	for ( int j = M ;					  
  i <= N ;						      	i ++ ) {						    	j >= 1 ;						  
  i ++ ) {						      	  for ( int j = 0 ;					    	j -- ) {						  
    for ( int j = 0 ;					      	  j < MAX ;						    	  if ( A [ i - 1 ] == B [ j - 1 ] ) {			  
    j < MAX ;						      	  j ++ ) {						    	    dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ;	  
    j ++ ) {						      	    for ( auto x : pos [ j ] ) {			    	  }							  
      for ( int x : pos [ j ] ) {			      	      if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == 	  else {						  
	if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == 		ans ++ ;					    	    dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i 
	  ans ++ ;					      		break ;						    	  }							  
	  break ;					      	      }							    	}							  
	}						      	    }							      }								  
      }							      	  }							      int ans = 0 ;						  
    }							      	}							      for ( int i = 0 ;						  
  }							      	return ans ;						      i <= N ;							  
  return ans ;						      }								      i ++ ) {							  
}							      								    	for ( int j = 0 ;					  
							      								    	j < MAX ;						  
							      								    	j ++ ) {						  
							      								    	  for ( int x : pos [ j ] ) {				  
							      								    	    if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == 
							      								    	      ans ++ ;						  
							      								    	      break ;						  
							      								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
