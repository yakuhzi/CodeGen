========================SOURCE============================    ==========================REF=============================    =========================HYPO=============================	  ==========================OUT=============================
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_AREA_SQUARE					      PROGRAM_AREA_SQUARE					    PROGRAM_AREA_SQUARE						  PROGRAM_AREA_SQUARE
--							      --							    --								  --
def areaSquare ( side ) :				      int areaSquare ( int side ) {				    int areaSquare ( int side ) {				  success : identical to gold
    area = side * side					      	int area = side * side ;				      int area = side * side ;					  
    return area						      	return area ;						      return area ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			      MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			    MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			  MAXIMUM_POINTS_INTERSECTION_N_CIRCLES
--							      --							    --								  --
def intersection ( n ) :				      int intersection ( int n ) {				    int intersection ( int n ) {				  success : identical to gold
    return n * ( n - 1 )				      	return n * ( n - 1 ) ;					      return n * ( n - 1 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TURN_OFF_THE_RIGHTMOST_SET_BIT				      TURN_OFF_THE_RIGHTMOST_SET_BIT				    TURN_OFF_THE_RIGHTMOST_SET_BIT				  TURN_OFF_THE_RIGHTMOST_SET_BIT
--							      --							    --								  --
def fun ( n ) :						      int fun ( unsigned int n ) {				    int fun ( int n ) {						  success : None
    return n & ( n - 1 )				      	return n & ( n - 1 ) ;					      return n & ( n - 1 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CASSINIS_IDENTITY					      CASSINIS_IDENTITY						    CASSINIS_IDENTITY						  CASSINIS_IDENTITY
--							      --							    --								  --
def cassini ( n ) :					      int cassini ( int n ) {					    int cassini ( int n ) {					  failure : #Results: 4, 10
    return - 1 if ( n & 1 ) else 1			      	return ( n & 1 ) ? - 1 : 1 ;				      return - 1 == ( n & 1 ) ? 1 : - 1 ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEXAGONAL_NUMBER					      HEXAGONAL_NUMBER						    HEXAGONAL_NUMBER						  HEXAGONAL_NUMBER
--							      --							    --								  --
def hexagonalNum ( n ) :				      int hexagonalNum ( int n ) {				    int hexagonalNum ( int n ) {				  success : identical to gold
    return n * ( 2 * n - 1 )				      	return n * ( 2 * n - 1 ) ;				      return n * ( 2 * n - 1 ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ADD_1_TO_A_GIVEN_NUMBER_1				      ADD_1_TO_A_GIVEN_NUMBER_1					    ADD_1_TO_A_GIVEN_NUMBER_1					  ADD_1_TO_A_GIVEN_NUMBER_1
--							      --							    --								  --
def addOne ( x ) :					      int addOne ( int x ) {					    int addOne ( int x ) {					  success : identical to gold
    return ( - ( ~ x ) )				      	return ( - ( ~ x ) ) ;					      return ( - ( ~ x ) ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_CIRCUMFERENCE_CIRCLE			      PROGRAM_FIND_CIRCUMFERENCE_CIRCLE				    PROGRAM_FIND_CIRCUMFERENCE_CIRCLE				  PROGRAM_FIND_CIRCUMFERENCE_CIRCLE
--							      --							    --								  --
def circumference ( r ) :				      double circumference ( double r ) {			    double circumference ( double r ) {				  script_not_found : None
    return ( 2 * PI * r )				      	double cir = 2 * PI * r ;				      return ( 2 * PI * r ) ;					  
							      	return cir ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
AREA_SQUARE_CIRCUMSCRIBED_CIRCLE			      AREA_SQUARE_CIRCUMSCRIBED_CIRCLE				    AREA_SQUARE_CIRCUMSCRIBED_CIRCLE				  AREA_SQUARE_CIRCUMSCRIBED_CIRCLE
--							      --							    --								  --
def find_Area ( r ) :					      int find_Area ( int r ) {					    inline int findArea ( int r ) {				  success : None
    return ( 2 * r * r )				      	return ( 2 * r * r ) ;					      return ( 2 * r * r ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			      FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			    FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			  FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT
--							      --							    --								  --
def check ( n ) :					      bool check ( int n ) {					    bool check ( int n ) {					  success : identical to gold
    return 1162261467 % n == 0				      	return 1162261467 % n == 0 ;				      return 1162261467 % n == 0 ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_TWO_HALVES_SORTED				      SORT_ARRAY_TWO_HALVES_SORTED				    SORT_ARRAY_TWO_HALVES_SORTED				  SORT_ARRAY_TWO_HALVES_SORTED
--							      --							    --								  --
def mergeTwoHalf ( A , n ) :				      void mergeTwoHalf ( int A [ ] , int n ) {			    void mergeTwoHalf ( vector < int > & A , int n ) {		  error : SORT_ARRAY_TWO_HALVES_SORTED.cpp: In funct
    A.sort ( )						      	sort ( A , A + n ) ;					      sort ( A . begin ( ) , A . end ( ) ) ;			  ion ‘int main()’: SORT_ARRAY_TWO_HALVES_SORTED.cpp
							      }								    }								  :34:18: error: invalid initialization of non-const
							      								    								   reference of type ‘std::vector<int>&’ from an rva
							      								    								  lue of type ‘__gnu_cxx::__alloc_traits<std::alloca
							      								    								  tor<int>, int>::value_type*’ {aka ‘int*’}
							      								    								   f_filled(&filled_function_param0[i].front(),fille
							      								    								  d_function_param1[i]);		   ^~~~~~~~~
							      								    								  ~~~~~~~~~~~~~~~~~~~~~~~~~ SORT_ARRAY_TWO_HALVES_SO
							      								    								  RTED.cpp:21:6: note: in passing argument 1 of ‘voi
							      								    								  d f_filled(std::vector<int>&, int)’  void f_filled
							      								    								   ( vector < int > & A , int n ) {	  ^~~~~~~~
							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD			      CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD			    CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD				  CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD
--							      --							    --								  --
def isEven ( n ) :					      bool isEven ( int n ) {					    bool isEven ( int n ) {					  success : identical to gold
    return ( n % 2 == 0 )				      	return ( n % 2 == 0 ) ;					      return ( n % 2 == 0 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			      C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			    C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			  C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1
--							      --							    --								  --
def largest ( arr , n ) :				      int largest ( int arr [ ] , int n ) {			    template < typename T > T largest ( T * arr , int n ) {	  error : C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1.cpp
    return max ( arr )					      	return * max_element ( arr , arr + n ) ;		      return max ( arr , arr + n ) ;				  : In instantiation of ‘T f_filled(T*, int) [with T
							      }								    }								   = int]’: C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1.c
							      								    								  pp:32:49:   required from here C_PROGRAM_FIND_LARG
							      								    								  EST_ELEMENT_ARRAY_1.cpp:22:30: error: invalid conv
							      								    								  ersion from ‘int*’ to ‘int’ [-fpermissive]	retu
							      								    								  rn max ( arr , arr + n ) ;
							      								    								  	 ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES		      HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES			    HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES			  HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES
--							      --							    --								  --
def height ( N ) :					      int height ( int N ) {					    int height ( int N ) {					  success : identical to gold
    return math.ceil ( math.log2 ( N + 1 ) ) - 1	      	return ceil ( log2 ( N + 1 ) ) - 1 ;			      return ceil ( log2 ( N + 1 ) ) - 1 ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TRIANGULAR_MATCHSTICK_NUMBER				      TRIANGULAR_MATCHSTICK_NUMBER				    TRIANGULAR_MATCHSTICK_NUMBER				  TRIANGULAR_MATCHSTICK_NUMBER
--							      --							    --								  --
def numberOfSticks ( x ) :				      int numberOfSticks ( int x ) {				    int numberOfSticks ( int x ) {				  success : identical to gold
    return ( 3 * x * ( x + 1 ) ) / 2			      	return ( 3 * x * ( x + 1 ) ) / 2 ;			      return ( 3 * x * ( x + 1 ) ) / 2 ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1			      PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1			    PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1				  PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1
--							      --							    --								  --
def summingSeries ( n ) :				      int summingSeries ( long n ) {				    double summingSeries ( int n ) {				  success : None
    return math.pow ( n , 2 )				      	return pow ( n , 2 ) ;					      return pow ( n , 2 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_PENTAGONAL_NUMBER					      NTH_PENTAGONAL_NUMBER					    NTH_PENTAGONAL_NUMBER					  NTH_PENTAGONAL_NUMBER
--							      --							    --								  --
def pentagonalNum ( n ) :				      int pentagonalNum ( int n ) {				    int pentagonalNum ( int n ) {				  success : identical to gold
    return ( 3 * n * n - n ) / 2			      	return ( 3 * n * n - n ) / 2 ;				      return ( 3 * n * n - n ) / 2 ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			      CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			    CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			  CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1
--							      --							    --								  --
def isEven ( n ) :					      bool isEven ( int n ) {					    bool isEven ( int n ) {					  success : identical to gold
    return ( not ( n & 1 ) )				      	return ( ! ( n & 1 ) ) ;				      return ( ! ( n & 1 ) ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_BINOMIAL_COEFFICIENTS_1				      SUM_BINOMIAL_COEFFICIENTS_1				    SUM_BINOMIAL_COEFFICIENTS_1					  SUM_BINOMIAL_COEFFICIENTS_1
--							      --							    --								  --
def binomialCoeffSum ( n ) :				      int binomialCoeffSum ( int n ) {				    inline double binomialCoeffSum ( int n ) {			  success : None
    return ( 1 << n )					      	return ( 1 << n ) ;					      return ( 1 << n ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GCD_ELEMENTS_GIVEN_RANGE				      GCD_ELEMENTS_GIVEN_RANGE					    GCD_ELEMENTS_GIVEN_RANGE					  GCD_ELEMENTS_GIVEN_RANGE
--							      --							    --								  --
def rangeGCD ( n , m ) :				      int rangeGCD ( int n , int m ) {				    int rangeGCD ( int n , int m ) {				  failure : #Results: 0, 10
    return n if ( n == m ) else 1			      	return ( n == m ) ? n : 1 ;				      return n == ( n == m ) ? 1 : - 1 ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HYPERCUBE_GRAPH						      HYPERCUBE_GRAPH						    HYPERCUBE_GRAPH						  HYPERCUBE_GRAPH
--							      --							    --								  --
def power ( n ) :					      int power ( int n ) {					    int power ( int n ) {					  success : identical to gold
    if n == 1 :						      	if ( n == 1 ) return 2 ;				      if ( n == 1 ) return 2 ;					  
	return 2					      	return 2 * power ( n - 1 ) ;				      return 2 * power ( n - 1 ) ;				  
    return 2 * power ( n - 1 )				      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		      COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		    COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		  COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW
--							      --							    --								  --
def compute_average ( a , b ) :				      int compute_average ( int a , int b ) {			    int compute_average ( int a , int b ) {			  success : None
    return floor ( ( a + b ) / 2 )			      	return ( a + b ) / 2 ;					      return floor ( ( a + b ) / 2 ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE
--							      --							    --								  --
def Circumference ( a ) :				      int Circumference ( int a ) {				    Circumference ( int a ) : a ( a ) {				  error : PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENC
    return ( 4 * a )					      	return 4 * a ;						      printf ( "Circumference %d\n" , ( int ) a ) ;		  E_SQUARE_RECTANGLE.cpp:21:18: error: ISO C++ forbi
							      }								    }								  ds declaration of ‘f_filled’ with no type [-fpermi
							      								    								  ssive]  f_filled ( int a ) : a ( a ) {
							      								    								  	 ^ PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFEREN
							      								    								  CE_SQUARE_RECTANGLE.cpp: In function ‘int f_filled
							      								    								  (int)’: PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENC
							      								    								  E_SQUARE_RECTANGLE.cpp:21:22: error: only construc
							      								    								  tors take member initializers	 f_filled ( int a )
							      								    								  : a ( a ) {			    ^ PYTHON_PROGRAM
							      								    								  _FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE.cpp
							      								    								  :23:1: warning: no return statement in function re
							      								    								  turning non-void [-Wreturn-type]  }  ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_AN_INTEGER_WITH_3_5				      MULTIPLY_AN_INTEGER_WITH_3_5				    MULTIPLY_AN_INTEGER_WITH_3_5				  MULTIPLY_AN_INTEGER_WITH_3_5
--							      --							    --								  --
def multiplyWith3Point5 ( x ) :				      int multiplyWith3Point5 ( int x ) {			    int multiplyWith3Point5 ( int x ) {				  success : identical to gold
    return ( x << 1 ) + x + ( x >> 1 )			      	return ( x << 1 ) + x + ( x >> 1 ) ;			      return ( x << 1 ) + x + ( x >> 1 ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_SLOPE_LINE					      PROGRAM_FIND_SLOPE_LINE					    PROGRAM_FIND_SLOPE_LINE					  PROGRAM_FIND_SLOPE_LINE
--							      --							    --								  --
def slope ( x1 , y1 , x2 , y2 ) :			      float slope ( float x1 , float y1 , float x2 , float y2 ) {   float slope ( int x1 , int y1 , int x2 , int y2 ) {		  failure : #Results: 9, 10
    return ( float ) ( y2 - y1 ) / ( x2 - x1 )		      	return ( y2 - y1 ) / ( x2 - x1 ) ;			      return ( float ) ( y2 - y1 ) / ( x2 - x1 ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FACTORIAL_NUMBER				      C_PROGRAM_FACTORIAL_NUMBER				    C_PROGRAM_FACTORIAL_NUMBER					  C_PROGRAM_FACTORIAL_NUMBER
--							      --							    --								  --
def factorial ( n ) :					      unsigned int factorial ( unsigned int n ) {		    int factorial ( int n ) {					  success : None
    return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 	if ( n == 0 ) return 1 ;				      return 1 == ( n == 1 || n == 0 ) ? n : n * factorial ( n -  
							      	return n * factorial ( n - 1 ) ;			    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS		      DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS		    DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS			  DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS
--							      --							    --								  --
def oppositeSigns ( x , y ) :				      bool oppositeSigns ( int x , int y ) {			    inline bool oppositeSigns ( int x , int y ) {		  success : None
    return ( ( x ^ y ) < 0 )				      	return ( ( x ^ y ) < 0 ) ;				      return ( ( x ^ y ) < 0 ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_TWO_NIBBLES_BYTE					      SWAP_TWO_NIBBLES_BYTE					    SWAP_TWO_NIBBLES_BYTE					  SWAP_TWO_NIBBLES_BYTE
--							      --							    --								  --
def swapNibbles ( x ) :					      int swapNibbles ( int x ) {				    inline int swapNibbles ( int x ) {				  success : None
    return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )	      	return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ;	      return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SUBSTRINGS_STRING				      NUMBER_SUBSTRINGS_STRING					    NUMBER_SUBSTRINGS_STRING					  NUMBER_SUBSTRINGS_STRING
--							      --							    --								  --
def countNonEmptySubstr ( str ) :			      int countNonEmptySubstr ( string str ) {			    int countNonEmptySubstr ( string str ) {			  success : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . size ( ) ;					  
    return int ( n * ( n + 1 ) / 2 )			      	return n * ( n + 1 ) / 2 ;				      return ( int ) ( n * ( n + 1 ) / 2 ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		      COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		    COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		  COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER
--							      --							    --								  --
def getModulo ( n , d ) :				      unsigned int getModulo ( unsigned int n , unsigned int d ) {  int getModulo ( int n , int d ) {				  success : None
    return ( n & ( d - 1 ) )				      	return ( n & ( d - 1 ) ) ;				      return ( n & ( d - 1 ) ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_TERM_SERIES_2_12_36_80_150				      N_TH_TERM_SERIES_2_12_36_80_150				    N_TH_TERM_SERIES_2_12_36_80_150				  N_TH_TERM_SERIES_2_12_36_80_150
--							      --							    --								  --
def nthTerm ( n ) :					      int nthTerm ( int n ) {					    int nthTerm ( int n ) {					  success : identical to gold
    return ( n * n ) + ( n * n * n )			      	return ( n * n ) + ( n * n * n ) ;			      return ( n * n ) + ( n * n * n ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10
--							      --							    --								  --
def isMultipleOf10 ( n ) :				      bool isMultipleOf10 ( int n ) {				    bool isMultipleOf10 ( int n ) {				  success : identical to gold
    return ( n % 15 == 0 )				      	return ( n % 15 == 0 ) ;				      return ( n % 15 == 0 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_FACTORIAL_OF_A_NUMBER			      PROGRAM_FOR_FACTORIAL_OF_A_NUMBER				    PROGRAM_FOR_FACTORIAL_OF_A_NUMBER				  PROGRAM_FOR_FACTORIAL_OF_A_NUMBER
--							      --							    --								  --
def factorial ( n ) :					      unsigned int factorial ( unsigned int n ) {		    int factorial ( int n ) {					  success : None
    return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 	if ( n == 0 ) return 1 ;				      return 1 == ( n == 1 || n == 0 ) ? n : n * factorial ( n -  
							      	return n * factorial ( n - 1 ) ;			    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BREAK_NUMBER_THREE_PARTS_1				      BREAK_NUMBER_THREE_PARTS_1				    BREAK_NUMBER_THREE_PARTS_1					  BREAK_NUMBER_THREE_PARTS_1
--							      --							    --								  --
def count_of_ways ( n ) :				      ll count_of_ways ( ll n ) {				    public : int countOfWays ( int n ) {			  script_not_found : None
    count = 0						      	ll count ;						      int count ;						  
    count = ( n + 1 ) * ( n + 2 ) // 2			      	count = ( n + 1 ) * ( n + 2 ) / 2 ;			      count = ( n + 1 ) * ( n + 2 ) / 2 ;			  
    return count					      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			      BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			    BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			  BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS
--							      --							    --								  --
def gcd ( a , b ) :					      int gcd ( int a , int b ) {				    template < typename T > T gcd ( T a , T b ) {		  success : None
    if a == 0 :						      	if ( a == 0 ) return b ;				      if ( a == 0 ) return b ;					  
	return b					      	return gcd ( b % a , a ) ;				      return gcd ( b % a , a ) ;				  
    return gcd ( b % a , a )				      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_RECTANGLES_NM_GRID				      NUMBER_RECTANGLES_NM_GRID					    NUMBER_RECTANGLES_NM_GRID					  NUMBER_RECTANGLES_NM_GRID
--							      --							    --								  --
def rectCount ( n , m ) :				      int rectCount ( int n , int m ) {				    int rectCount ( int n , int m ) {				  success : identical to gold
    return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4	      	return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;		      return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_VOLUME_ELLIPSOID			      PROGRAM_CALCULATE_VOLUME_ELLIPSOID			    PROGRAM_CALCULATE_VOLUME_ELLIPSOID				  PROGRAM_CALCULATE_VOLUME_ELLIPSOID
--							      --							    --								  --
def volumeOfEllipsoid ( r1 , r2 , r3 ) :		      float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) {  double volumeOfEllipsoid ( double r1 , double r2 , double r3  success : None
    return 1.33 * math.pi * r1 * r2 * r3		      	float pi = 3.14 ;					      return 1.33 * M_PI * r1 * r2 * r3 ;			  
							      	return 1.33 * pi * r1 * r2 * r3 ;			    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR    PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR    PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR	  PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR
--							      --							    --								  --
def getRemainder ( num , divisor ) :			      int getRemainder ( int num , int divisor ) {		    int getRemainder ( int num , int divisor ) {		  success : identical to gold
    return ( num - divisor * ( num // divisor ) )	      	return ( num - divisor * ( num / divisor ) ) ;		      return ( num - divisor * ( num / divisor ) ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			      PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			    PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			  PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES
--							      --							    --								  --
def findMaximumPieces ( n ) :				      int findMaximumPieces ( int n ) {				    int findMaximumPieces ( int n ) {				  success : None
    return int ( 1 + n * ( n + 1 ) / 2 )		      	return 1 + n * ( n + 1 ) / 2 ;				      return int ( 1 + n * ( n + 1 ) / 2 ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1		      FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1		    FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1			  FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1
--							      --							    --								  --
def evenbinomialCoeffSum ( n ) :			      int evenbinomialCoeffSum ( int n ) {			    inline int evenbinomialCoeffSum ( int n ) {			  success : None
    return ( 1 << ( n - 1 ) )				      	return ( 1 << ( n - 1 ) ) ;				      return ( 1 << ( n - 1 ) ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_INCREASING_SUBSEQUENCE				      LONGEST_INCREASING_SUBSEQUENCE				    LONGEST_INCREASING_SUBSEQUENCE				  LONGEST_INCREASING_SUBSEQUENCE
--							      --							    --								  --
def lis ( arr ) :					      int lis ( int arr [ ] , int n ) {				    int lis ( vector < int > arr ) {				  script_not_found : None
    global maximum					      	int max = 1 ;						      maximum = 0 ;						  
    n = len ( arr )					      	_lis ( arr , n , & max ) ;				      int n = arr . size ( ) ;					  
    maximum = 1						      	return max ;						      maximum = 1 ;						  
    _lis ( arr , n )					      }								      _lis ( arr , n ) ;					  
    return maximum					      								      return maximum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_AREA_OCTAGON				      PROGRAM_CALCULATE_AREA_OCTAGON				    PROGRAM_CALCULATE_AREA_OCTAGON				  PROGRAM_CALCULATE_AREA_OCTAGON
--							      --							    --								  --
def areaOctagon ( side ) :				      double areaOctagon ( double side ) {			    inline double areaOctagon ( double side ) {			  success : None
    return ( 2 * ( 1 + ( math.sqrt ( 2 ) ) ) * side * side )  	return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ;   return ( 2 * ( 1 + ( sqrt ( 2 ) ) ) * side * side ) ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			      PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			    PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			  PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON
--							      --							    --								  --
def surface_area_octahedron ( side ) :			      double surface_area_octahedron ( double side ) {		    inline double surface_area_octahedron ( int side ) {	  failure : #Results: 9, 10
    return ( 2 * ( math.sqrt ( 3 ) ) * ( side * side ) )      	return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ;	      return ( 2 * ( sqrt ( 3 ) ) ) * ( side * side ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_CONTAIN_1_N_VALUES				      SORT_ARRAY_CONTAIN_1_N_VALUES				    SORT_ARRAY_CONTAIN_1_N_VALUES				  SORT_ARRAY_CONTAIN_1_N_VALUES
--							      --							    --								  --
def sortit ( arr , n ) :				      void sortit ( int arr [ ] , int n ) {			    void sortit ( int arr [ ] , int n ) {			  success : None
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	arr [ i ] = i + 1				      	i < n ;							      i < n ;							  
							      	i ++ ) {						      i ++ ) arr [ i ] = i + 1 ;				  
							      	  arr [ i ] = i + 1 ;					    }								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS_2					      SUM_PAIRWISE_PRODUCTS_2					    SUM_PAIRWISE_PRODUCTS_2					  SUM_PAIRWISE_PRODUCTS_2
--							      --							    --								  --
def findSum ( n ) :					      long long int findSum ( int n ) {				    int findSum ( int n ) {					  success : None
    return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24     	return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ;	      return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_VOLUME_OCTAHEDRON			      PROGRAM_CALCULATE_VOLUME_OCTAHEDRON			    PROGRAM_CALCULATE_VOLUME_OCTAHEDRON				  PROGRAM_CALCULATE_VOLUME_OCTAHEDRON
--							      --							    --								  --
def vol_of_octahedron ( side ) :			      double vol_of_octahedron ( double side ) {		    inline double vol_of_octahedron ( double side ) {		  success : None
    return ( ( side * side * side ) * ( math.sqrt ( 2 ) / 3 ) 	return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ) ;      return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ) ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	      PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	    PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	  PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM
--							      --							    --								  --
def Resources ( process , need ) :			      int Resources ( int process , int need ) {		    int Resources ( int process , int need ) {			  success : None
    minResources = 0					      	int minResources = 0 ;					      int minResources ;					  
    minResources = process * ( need - 1 ) + 1		      	minResources = process * ( need - 1 ) + 1 ;		      minResources = process * ( need - 1 ) + 1 ;		  
    return minResources					      	return minResources ;					      return minResources ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		      PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		    PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		  PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP
--							      --							    --								  --
def procal ( n ) :					      double procal ( int n ) {					    double procal ( double n ) {				  success : None
    return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 )	      	return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;		      return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	      MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	    MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	  MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS
--							      --							    --								  --
def cost ( a , n ) :					      int cost ( int a [ ] , int n ) {				    int cost ( int a , int n ) {				  error : MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LA
    return ( ( n - 1 ) * min ( a ) )			      	return ( n - 1 ) * ( * min_element ( a , a + n ) ) ;	      return ( ( n - 1 ) * min ( a ) ) ;			  RGER_PAIRS.cpp: In function ‘int f_filled(int, int
							      }								    }								  )’: MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER
							      								    								  _PAIRS.cpp:22:32: error: no matching function for
							      								    								  call to ‘min(int&)’	 return ( ( n - 1 ) * min (
							      								    								  a ) ) ;				  ^ In file
							      								    								  included from /usr/include/c++/8/bits/char_traits.
							      								    								  h:39,			 from /usr/include/c++/8/ios
							      								    								  :40,			from /usr/include/c++/8/ostr
							      								    								  eam:38,		   from /usr/include/c++/8/i
							      								    								  ostream:39,		       from MINIMUM_COST_MAK
							      								    								  E_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS.cpp:8: /usr/i
							      								    								  nclude/c++/8/bits/stl_algobase.h:195:5: note: cand
							      								    								  idate: ‘template<class _Tp> constexpr const _Tp& s
							      								    								  td::min(const _Tp&, const _Tp&)’	min(const _T
							      								    								  p& __a, const _Tp& __b)      ^~~ /usr/include/c++/
							      								    								  8/bits/stl_algobase.h:195:5: note:   template argu
							      								    								  ment deduction/substitution failed: MINIMUM_COST_M
							      								    								  AKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS.cpp:22:32:
							      								    								  note:	  candidate expects 2 arguments, 1 provided
							      								    								     return ( ( n - 1 ) * min ( a ) ) ;
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/bits/char_traits.h:39,
							      								    								     from /usr/include/c++/8/ios:40,
							      								    								    from /usr/include/c++/8/ostream:38,
							      								    								       from /usr/include/c++/8/iostream:39,
							      								    								  	   from MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOV
							      								    								  ING_LARGER_PAIRS.cpp:8: /usr/include/c++/8/bits/st
							      								    								  l_algobase.h:243:5: note: candidate: ‘template<cla
							      								    								  ss _Tp, class _Compare> constexpr const _Tp& std::
							      								    								  min(const _Tp&, const _Tp&, _Compare)’      min(co
							      								    								  nst _Tp& __a, const _Tp& __b, _Compare __comp)
							      								    								    ^~~ /usr/include/c++/8/bits/stl_algobase.h:243:5
							      								    								  : note:   template argument deduction/substitution
							      								    								   failed: MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_L
							      								    								  ARGER_PAIRS.cpp:22:32: note:	 candidate expects 3
							      								    								   arguments, 1 provided    return ( ( n - 1 ) * min
							      								    								   ( a ) ) ;				     ^ In fi
							      								    								  le included from /usr/include/c++/8/algorithm:62,
							      								    								  		   from /usr/include/c++/8/x86_64-re
							      								    								  dhat-linux/bits/stdc++.h:65,			from
							      								    								   MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PA
							      								    								  IRS.cpp:14: /usr/include/c++/8/bits/stl_algo.h:345
							      								    								  0:5: note: candidate: ‘template<class _Tp> constex
							      								    								  pr _Tp std::min(std::initializer_list<_Tp>)’
							      								    								  min(initializer_list<_Tp> __l)      ^~~ /usr/inclu
							      								    								  de/c++/8/bits/stl_algo.h:3450:5: note:   template
							      								    								  argument deduction/substitution failed: MINIMUM_CO
							      								    								  ST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS.cpp:22:
							      								    								  32: note:   mismatched types ‘std::initializer_lis
							      								    								  t<_Tp>’ and ‘int’    return ( ( n - 1 ) * min ( a
							      								    								  ) ) ;					^ In file in
							      								    								  cluded from /usr/include/c++/8/algorithm:62,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:65,		   from MINI
							      								    								  MUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS.c
							      								    								  pp:14: /usr/include/c++/8/bits/stl_algo.h:3456:5:
							      								    								  note: candidate: ‘template<class _Tp, class _Compa
							      								    								  re> constexpr _Tp std::min(std::initializer_list<_
							      								    								  Tp>, _Compare)’      min(initializer_list<_Tp> __l
							      								    								  , _Compare __comp)	  ^~~ /usr/include/c++/8/bit
							      								    								  s/stl_algo.h:3456:5: note:   template argument ded
							      								    								  uction/substitution failed: MINIMUM_COST_MAKE_ARRA
							      								    								  Y_SIZE_1_REMOVING_LARGER_PAIRS.cpp:22:32: note:
							      								    								  mismatched types ‘std::initializer_list<_Tp>’ and
							      								    								  ‘int’	   return ( ( n - 1 ) * min ( a ) ) ;
							      								    								  			    ^ MINIMUM_COST_MAKE_ARRA
							      								    								  Y_SIZE_1_REMOVING_LARGER_PAIRS.cpp: In function ‘i
							      								    								  nt main()’: MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVIN
							      								    								  G_LARGER_PAIRS.cpp:32:21: error: invalid conversio
							      								    								  n from ‘__gnu_cxx::__alloc_traits<std::allocator<i
							      								    								  nt>, int>::value_type*’ {aka ‘int*’} to ‘int’ [-fp
							      								    								  ermissive]	      if(f_filled(&param0[i].front()
							      								    								  ,param1[i]) == f_gold(&param0[i].front(),param1[i]
							      								    								  ))			  ^~~~~~~~~~~~~~~~~~ MINIMUM
							      								    								  _COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS.cpp:
							      								    								  21:20: note:	 initializing argument 1 of ‘int f_f
							      								    								  illed(int, int)’  int f_filled ( int a , int n ) {
							      								    								  		   ~~~~^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW
--							      --							    --								  --
def isPowerOfTwo ( x ) :				      int bool isPowerOfTwo ( int x ) {				    bool isPowerOfTwo ( unsigned x ) {				  script_not_found : None
    return ( x and ( not ( x & ( x - 1 ) ) ) )		      	return x && ( ! ( x & ( x - 1 ) ) ) ;			      return ( x && ( ! ( x & ( x - 1 ) ) ) ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1			      PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1			    PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1				  PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1
--							      --							    --								  --
def factorial ( n ) :					      unsigned int factorial ( unsigned int n ) {		    int factorial ( int n ) {					  success : None
    return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 	int res = 1 , i ;					      return 1 == ( n == 1 || n == 0 ) ? n : n * factorial ( n -  
							      	for ( i = 2 ;						    }								  
							      	i <= n ;						    								  
							      	i ++ ) res *= i ;					    								  
							      	return res ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPETITIVE_ELEMENT_1_N_1				      FIND_REPETITIVE_ELEMENT_1_N_1				    FIND_REPETITIVE_ELEMENT_1_N_1				  FIND_REPETITIVE_ELEMENT_1_N_1
--							      --							    --								  --
def findRepeating ( arr , n ) :				      int findRepeating ( int arr [ ] , int n ) {		    int findRepeating ( int arr [ ] , int n ) {			  error : FIND_REPETITIVE_ELEMENT_1_N_1.cpp: In func
    return sum ( arr ) - ( ( ( n - 1 ) * n ) // 2 )	      	return accumulate ( arr , arr + n , 0 ) - ( ( n - 1 ) * n /   return sum ( arr ) - ( ( ( n - 1 ) * n ) / 2 ) ;		  tion ‘int f_filled(int*, int)’: FIND_REPETITIVE_EL
							      }								    }								  EMENT_1_N_1.cpp:22:10: error: ‘sum’ was not declar
							      								    								  ed in this scope    return sum ( arr ) - ( ( ( n -
							      								    								   1 ) * n ) / 2 ) ;	       ^~~ FIND_REPETITIVE_E
							      								    								  LEMENT_1_N_1.cpp:22:10: note: suggested alternativ
							      								    								  e: ‘fsub’    return sum ( arr ) - ( ( ( n - 1 ) *
							      								    								  n ) / 2 ) ;		^~~	      fsub
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STACK_SET_3_REVERSE_STRING_USING_STACK			      STACK_SET_3_REVERSE_STRING_USING_STACK			    STACK_SET_3_REVERSE_STRING_USING_STACK			  STACK_SET_3_REVERSE_STRING_USING_STACK
--							      --							    --								  --
def reverse ( string ) :				      void reverse ( char str [ ] ) {				    string reverse ( string string ) {				  script_not_found : None
    string = string [ : : - 1 ]				      	int n = strlen ( str ) , i ;				      string . reverse ( ) ;					  
    return string					      	for ( i = 0 ;						      return string ;						  
							      	i < n / 2 ;						    }								  
							      	i ++ ) swap ( & str [ i ] , & str [ n - i - 1 ] ) ;	    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT     PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT	    PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT	  PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT
--							      --							    --								  --
def assignValue ( a , b , x ) :				      int assignValue ( int a , int b , bool x ) {		    int assignValue ( int a , int b , int x ) {			  failure : #Results: 0, 10
    arr = [ a , b ]					      	int arr [ ] = {						      int arr [ ] = {						  
    return ( arr [ x ] )				      	  a , b }						    	a , b }							  
							      	  ;							    	;							  
							      	  return ( arr [ x ] ) ;				    	return ( arr [ x ] ) ;					  
							      	}							      }								  
-							      	-							      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_2				      COUNT_SET_BITS_IN_AN_INTEGER_2				    COUNT_SET_BITS_IN_AN_INTEGER_2				  COUNT_SET_BITS_IN_AN_INTEGER_2
--							      --							    --								  --
def countSetBits ( n ) :				      public : unsigned int countSetBits ( int n ) {		    int countSetBits ( unsigned n ) {				  script_not_found : None
    count = 0						      	unsigned int count = 0 ;				      int count = 0 ;						  
    while ( n ) :					      	while ( n ) {						      while ( ( n ) ) {						  
	n &= ( n - 1 )					      	  n &= ( n - 1 ) ;					    	n &= ( n - 1 ) ;					  
	count += 1					      	  count ++ ;						    	count ++ ;						  
    return count					      	}							      }								  
							      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1		      BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1			    BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1			  BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1
--							      --							    --								  --
def bin ( n ) :						      void bin ( unsigned n ) {					    void bin ( int n ) {					  script_not_found : None
    if ( n > 1 ) :					      	if ( n > 1 ) bin ( n >> 1 ) ;				      if ( ( n > 1 ) && ( n < 2 ) ) bin ( n >> 1 ) ;		  
	bin ( n >> 1 )					      	printf ( "%d" , n & 1 ) ;				      cout << n & 1 << " " ;					  
    print ( n & 1 , end = "" )				      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS		      SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS			    SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS			  SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS
--							      --							    --								  --
def sumOfSeries ( n ) :					      float sumOfSeries ( int n ) {				    double sumOfSeries ( int n ) {				  success : None
    return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) )	      	return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ;		      return ( ( double ) 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ;  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1     SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1	    SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1	  SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1
--							      --							    --								  --
def calculateSum ( n ) :				      long long int calculateSum ( int n ) {			    int calculateSum ( int n ) {				  success : None
    sum = 0						      	long long int sum = 0 ;					      int sum ;							  
    sum = 1 << n					      	sum = 1 << n ;						      sum = 1 << n ;						  
    return ( sum - 1 )					      	return ( sum - 1 ) ;					      return ( sum - 1 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_1				      COUNT_SET_BITS_IN_AN_INTEGER_1				    COUNT_SET_BITS_IN_AN_INTEGER_1				  COUNT_SET_BITS_IN_AN_INTEGER_1
--							      --							    --								  --
def countSetBits ( n ) :				      int countSetBits ( int n ) {				    int countSetBits ( int n ) {				  failure : #Results: 0, 10
    if ( n == 0 ) :					      	if ( n == 0 ) return 0 ;				      if ( ( n == 0 ) || ( n == 1 ) ) return 0 ;		  
	return 0					      	else return ( n & 1 ) + countSetBits ( n >> 1 ) ;	      else return ( n & 1 ) + countSetBits ( n >> 1 ) ;		  
    else :						      }								    }								  
	return ( n & 1 ) + countSetBits ( n >> 1 )	      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_3				      COUNT_SET_BITS_IN_AN_INTEGER_3				    COUNT_SET_BITS_IN_AN_INTEGER_3				  COUNT_SET_BITS_IN_AN_INTEGER_3
--							      --							    --								  --
def countSetBits ( n ) :				      int countSetBits ( int n ) {				    int countSetBits ( int n ) {				  success : None
    if ( n == 0 ) :					      	if ( n == 0 ) return 0 ;				      if ( ( n == 0 ) || ( n == 1 ) ) return 0 ;		  
	return 0					      	else return 1 + countSetBits ( n & ( n - 1 ) ) ;	      else return 1 + countSetBits ( n & ( n - 1 ) ) ;		  
    else :						      }								    }								  
	return 1 + countSetBits ( n & ( n - 1 ) )	      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY		      KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY		    KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY			  KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY
--							      --							    --								  --
def kthSmallest ( arr , n , k ) :			      int kthSmallest ( int arr [ ] , int n , int k ) {		    int kthSmallest ( int arr [ ] , int n , int k ) {		  script_not_found : None
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    return arr [ k - 1 ]				      	return arr [ k - 1 ] ;					      return arr [ k - 1 ] ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE      DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE	    DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE
--							      --							    --								  --
def lis ( arr ) :					      int lis ( int arr [ ] , int n ) {				    int lis ( vector < int > arr ) {				  script_not_found : None
    global maximum					      	int max = 1 ;						      maximum = 0 ;						  
    n = len ( arr )					      	_lis ( arr , n , & max ) ;				      int n = arr . size ( ) ;					  
    maximum = 1						      	return max ;						      maximum = 1 ;						  
    _lis ( arr , n )					      }								      _lis ( arr , n ) ;					  
    return maximum					      								      return maximum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I
--							      --							    --								  --
def getArea ( a ) :					      float getArea ( int a ) {					    double getArea ( double a ) {				  success : None
    area = ( math.pi * a * a ) / 4			      	float area = ( M_PI * a * a ) / 4.0 ;			      double area = ( M_PI * a * a ) / 4 ;			  
    return area						      	return area ;						      return area ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		      C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		    C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		  C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES
--							      --							    --								  --
def repeat ( s , n ) :					      string repeat ( string s , int n ) {			    string repeat ( string s , int n ) {			  success : None
    s1 = s						      	string s1 = s ;						      string s1 = s ;						  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	s += s1						      	i < n ;							      i < n ;							  
    return s						      	i ++ ) s += s1 ;					      i ++ ) {							  
							      	return s ;						    	s += s1 ;						  
							      }								      }								  
							      								      return s ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			      FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			    FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			  FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X
--							      --							    --								  --
def yMod ( y , x ) :					      long long int yMod ( long long int y , long long int x ) {    inline int yMod ( int y , int x ) {				  error : FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X.cp
    return ( y % pow ( 2 , x ) )			      	if ( log2 ( y ) < x ) return y ;			      return ( y % pow ( 2 , x ) ) ;				  p: In function ‘int f_filled(int, int)’: FIND_VALU
							      	if ( x > 63 ) return y ;				    }								  E_OF_Y_MOD_2_RAISED_TO_POWER_X.cpp:24:14: error: i
							      	return ( y % ( 1 << x ) ) ;				    								  nvalid operands of types ‘int’ and ‘__gnu_cxx::__p
							      }								    								  romote_2<int, int, double, double>::__type’ {aka ‘
							      								    								  double’} to binary ‘operator%’    return ( y % pow
							      								    								   ( 2 , x ) ) ;	     ~~^~~~~~~~~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY		      MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY			    MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY			  MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY
--							      --							    --								  --
def minSum ( A ) :					      int minSum ( int A [ ] , int n ) {			    int minSum ( vector < int > & A ) {				  error : MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.c
    min_val = min ( A ) ;				      	int min_val = * min_element ( A , A + n ) ;		      int minVal = min ( A ) ;					  pp: In function ‘int f_filled(std::vector<int>&)’:
    return min_val * ( len ( A ) - 1 )			      	return ( min_val * ( n - 1 ) ) ;			      ;								   MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp:23:2
							      }								      return minVal * ( A . size ( ) - 1 ) ;			  4: error: no matching function for call to ‘min(st
							      								    }								  d::vector<int>&)’    int minVal = min ( A ) ;
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/bits/char_traits.h:39,
							      								    								     from /usr/include/c++/8/ios:40,
							      								    								    from /usr/include/c++/8/ostream:38,
							      								    								       from /usr/include/c++/8/iostream:39,
							      								    								  	   from MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_A
							      								    								  RRAY.cpp:8: /usr/include/c++/8/bits/stl_algobase.h
							      								    								  :195:5: note: candidate: ‘template<class _Tp> cons
							      								    								  texpr const _Tp& std::min(const _Tp&, const _Tp&)’
							      								    								  	min(const _Tp& __a, const _Tp& __b)	 ^~~
							      								    								   /usr/include/c++/8/bits/stl_algobase.h:195:5: not
							      								    								  e:   template argument deduction/substitution fail
							      								    								  ed: MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp:2
							      								    								  3:24: note:	candidate expects 2 arguments, 1 pro
							      								    								  vided	   int minVal = min ( A ) ;
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /bits/char_traits.h:39,		   from /usr
							      								    								  /include/c++/8/ios:40,		  from /usr/
							      								    								  include/c++/8/ostream:38,		     from /u
							      								    								  sr/include/c++/8/iostream:39,			 fro
							      								    								  m MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp:8:
							      								    								  /usr/include/c++/8/bits/stl_algobase.h:243:5: note
							      								    								  : candidate: ‘template<class _Tp, class _Compare>
							      								    								  constexpr const _Tp& std::min(const _Tp&, const _T
							      								    								  p&, _Compare)’      min(const _Tp& __a, const _Tp&
							      								    								   __b, _Compare __comp)      ^~~ /usr/include/c++/8
							      								    								  /bits/stl_algobase.h:243:5: note:   template argum
							      								    								  ent deduction/substitution failed: MINIMUM_SUM_CHO
							      								    								  OSING_MINIMUM_PAIRS_ARRAY.cpp:23:24: note:   candi
							      								    								  date expects 3 arguments, 1 provided	  int minVal
							      								    								   = min ( A ) ;			 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/algorithm:62,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:65,		    from MIN
							      								    								  IMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp:14: /usr
							      								    								  /include/c++/8/bits/stl_algo.h:3450:5: note: candi
							      								    								  date: ‘template<class _Tp> constexpr _Tp std::min(
							      								    								  std::initializer_list<_Tp>)’	    min(initializer_
							      								    								  list<_Tp> __l)      ^~~ /usr/include/c++/8/bits/st
							      								    								  l_algo.h:3450:5: note:   template argument deducti
							      								    								  on/substitution failed: MINIMUM_SUM_CHOOSING_MINIM
							      								    								  UM_PAIRS_ARRAY.cpp:23:24: note:   ‘std::vector<int
							      								    								  >’ is not derived from ‘std::initializer_list<_Tp>
							      								    								  ’    int minVal = min ( A ) ;
							      								    								      ^ In file included from /usr/include/c++/8/alg
							      								    								  orithm:62,		      from /usr/include/c++/
							      								    								  8/x86_64-redhat-linux/bits/stdc++.h:65,
							      								    								  	 from MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARR
							      								    								  AY.cpp:14: /usr/include/c++/8/bits/stl_algo.h:3456
							      								    								  :5: note: candidate: ‘template<class _Tp, class _C
							      								    								  ompare> constexpr _Tp std::min(std::initializer_li
							      								    								  st<_Tp>, _Compare)’	   min(initializer_list<_Tp>
							      								    								   __l, _Compare __comp)      ^~~ /usr/include/c++/8
							      								    								  /bits/stl_algo.h:3456:5: note:   template argument
							      								    								   deduction/substitution failed: MINIMUM_SUM_CHOOSI
							      								    								  NG_MINIMUM_PAIRS_ARRAY.cpp:23:24: note:   ‘std::ve
							      								    								  ctor<int>’ is not derived from ‘std::initializer_l
							      								    								  ist<_Tp>’    int minVal = min ( A ) ;
							      								    								  	      ^ MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_A
							      								    								  RRAY.cpp: In function ‘int main()’: MINIMUM_SUM_CH
							      								    								  OOSING_MINIMUM_PAIRS_ARRAY.cpp:35:21: error: inval
							      								    								  id initialization of non-const reference of type ‘
							      								    								  std::vector<int>&’ from an rvalue of type ‘__gnu_c
							      								    								  xx::__alloc_traits<std::allocator<int>, int>::valu
							      								    								  e_type*’ {aka ‘int*’}		 if(f_filled(&param0
							      								    								  [i].front(),param1[i]) == f_gold(&param0[i].front(
							      								    								  ),param1[i]))			     ^~~~~~~~~~~~~~~
							      								    								  ~~~ MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp:2
							      								    								  2:5: note: in passing argument 1 of ‘int f_filled(
							      								    								  std::vector<int>&)’  int f_filled ( vector < int >
							      								    								   & A ) {	^~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REVERSE_A_STRING_USING_RECURSION			      REVERSE_A_STRING_USING_RECURSION				    REVERSE_A_STRING_USING_RECURSION				  REVERSE_A_STRING_USING_RECURSION
--							      --							    --								  --
def reverse ( string ) :				      void reverse ( string str ) {				    void reverse ( string & string ) {				  script_not_found : None
    if len ( string ) == 0 :				      	if ( str . size ( ) == 0 ) {				      if ( string . size ( ) == 0 ) return ;			  
	return						      	  return ;						      string temp = string [ 0 ] ;				  
    temp = string [ 0 ]					      	}							      reverse ( string . begin ( ) , string . end ( ) ) ;	  
    reverse ( string [ 1 : ] )				      	reverse ( str . substr ( 1 ) ) ;			      cout << temp << "\n" ;					  
    print ( temp , end = '' )				      	cout << str [ 0 ] ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ADD_1_TO_A_GIVEN_NUMBER					      ADD_1_TO_A_GIVEN_NUMBER					    ADD_1_TO_A_GIVEN_NUMBER					  ADD_1_TO_A_GIVEN_NUMBER
--							      --							    --								  --
def addOne ( x ) :					      int addOne ( int x ) {					    int addOne ( int x ) {					  success : None
    m = 1						      	int m = 1 ;						      int m = 1 ;						  
    while ( x & m ) :					      	while ( x & m ) {					      while ( ( x & m ) != 0 ) {				  
	x = x ^ m					      	  x = x ^ m ;						    	x = x ^ m ;						  
	m <<= 1						      	  m <<= 1 ;						    	m <<= 1 ;						  
    x = x ^ m						      	}							      }								  
    return x						      	x = x ^ m ;						      x = x ^ m ;						  
							      	return x ;						      return x ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LINEAR_SEARCH						      LINEAR_SEARCH						    LINEAR_SEARCH						  LINEAR_SEARCH
--							      --							    --								  --
def search ( arr , n , x ) :				      int search ( int arr [ ] , int n , int x ) {		    int search ( int arr [ ] , int n , int x ) {		  script_not_found : None
    for i in range ( 0 , n ) :				      	int i ;							      for ( int i = 0 ;						  
	if ( arr [ i ] == x ) :				      	for ( i = 0 ;						      i != n ;							  
	    return i					      	i < n ;							      ++ i ) if ( ( arr [ i ] == x ) && ( arr [ i ] != 0 ) ) retu 
    return - 1						      	i ++ ) if ( arr [ i ] == x ) return i ;			      return - 1 ;						  
							      	return - 1 ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS
--							      --							    --								  --
def maxSquare ( b , m ) :				      int maxSquare ( int b , int m ) {				    int maxSquare ( int b , int m ) {				  success : identical to gold
    return ( b / m - 1 ) * ( b / m ) / 2		      	return ( b / m - 1 ) * ( b / m ) / 2 ;			      return ( b / m - 1 ) * ( b / m ) / 2 ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_INPUT_INTEGER_STRING			      PROGRAM_CHECK_INPUT_INTEGER_STRING			    PROGRAM_CHECK_INPUT_INTEGER_STRING				  PROGRAM_CHECK_INPUT_INTEGER_STRING
--							      --							    --								  --
def isNumber ( s ) :					      bool isNumber ( string s ) {				    bool isNumber ( string s ) {				  error : PROGRAM_CHECK_INPUT_INTEGER_STRING.cpp: In
    for i in range ( len ( s ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						   function ‘bool f_filled(std::__cxx11::string)’: P
	if s [ i ].isdigit ( ) != True :		      	i < s . length ( ) ;					      i < s . length ( ) ;					  ROGRAM_CHECK_INPUT_INTEGER_STRING.cpp:28:20: error
	    return False				      	i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ;     i ++ ) {							  : request for member ‘isdigit’ in ‘s.std::__cxx11:
    return True						      	return true ;						    	if ( s [ i ] . isdigit ( ) != true ) return false ;	  :basic_string<char>::operator[](((std::__cxx11::ba
							      }								      }								  sic_string<char>::size_type)i))’, which is of non-
							      								      return true ;						  class type ‘__gnu_cxx::__alloc_traits<std::allocat
							      								    }								  or<char>, char>::value_type’ {aka ‘char’}	 if
							      								    								  ( s [ i ] . isdigit ( ) != true ) return false ;
							      								    								  		     ^~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		      POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		    POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		  POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1
--							      --							    --								  --
def printArray ( a , n ) :				      void printArray ( int * a , int n ) {			    void printArray ( int a [ ] , int n ) {			  script_not_found : None
    for i in a :					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	print ( i , end = " " )				      	i < n ;							      i < n ;							  
    print ( )						      	i ++ ) cout << a [ i ] << " " ;				      i ++ ) {							  
							      	cout << endl ;						    	cout << a [ i ] << " " ;				  
							      	return ;						      }								  
							      }								      cout << endl ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			      PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			    PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			  PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON
--							      --							    --								  --
def findArea ( a ) :					      float findArea ( float a ) {				    double findArea ( double a ) {				  success : None
    area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a  	float area ;						      double area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a 
    return area						      	area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a )    return area ;						  
							      	return area ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_PALINDROME_SUBSTRING_SET_1			      LONGEST_PALINDROME_SUBSTRING_SET_1			    LONGEST_PALINDROME_SUBSTRING_SET_1				  LONGEST_PALINDROME_SUBSTRING_SET_1
--							      --							    --								  --
def printSubStr ( st , low , high ) :			      void printSubStr ( string str , int low , int high ) {	    template < typename T > void printSubStr ( T st , int low , i script_not_found : None
    sys.stdout.write ( st [ low : high + 1 ] )		      	for ( int i = low ;					      std :: cout << st . substr ( low , high + 1 ) << std :: end 
    sys.stdout.flush ( )				      	i <= high ;						      std :: cout << std :: endl ;				  
    return ''						      	++ i ) cout << str [ i ] ;				    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING      COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING	    COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING	  COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING
--							      --							    --								  --
def getAbs ( n ) :					      unsigned int getAbs ( int n ) {				    int getAbs ( int n ) {					  script_not_found : None
    mask = n >> ( SIZE_INT * CHARBIT - 1 )		      	int const mask = n >> ( sizeof ( int ) * CHARBIT - 1 ) ;      int mask = n >> ( SIZE_INT * CHARBIT - 1 ) ;		  
    return ( ( n + mask ) ^ mask )			      	return ( ( n + mask ) ^ mask ) ;			      return ( ( n + mask ) ^ mask ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	      COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	    COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	  COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1
--							      --							    --								  --
def countStr ( n ) :					      int countStr ( int n ) {					    int countStr ( int n ) {					  success : None
    return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) ) 	return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ;	      return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ) ;  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		      HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		    HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		  HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER
--							      --							    --								  --
def turnOffK ( n , k ) :				      int turnOffK ( int n , int k ) {				    int turnOffK ( int n , int k ) {				  failure : #Results: 9, 10
    if ( k <= 0 ) :					      	if ( k <= 0 ) return n ;				      if ( ( k <= 0 ) || ( k > n ) ) return n ;			  
	return n					      	return ( n & ~ ( 1 << ( k - 1 ) ) ) ;			      return ( n & ~ ( 1 << ( k - 1 ) ) ) ;			  
    return ( n & ~ ( 1 << ( k - 1 ) ) )			      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES		      MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES		    MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES			  MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES
--							      --							    --								  --
def fib ( n ) :						      int fib ( int n ) {					    int fib ( int n ) {						  script_not_found : None
    if ( n <= 1 ) :					      	if ( n <= 1 ) return n ;				      if ( ( n <= 1 ) || ( n > 2 ) ) return n ;			  
	return n					      	return fib ( n - 1 ) + fib ( n - 2 ) ;			      return fib ( n - 1 ) + fib ( n - 2 ) ;			  
    return fib ( n - 1 ) + fib ( n - 2 )		      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		      FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		    FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		  FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2
--							      --							    --								  --
def getOddOccurrence ( arr ) :				      int getOddOccurrence ( int ar [ ] , int ar_size ) {	    int getOddOccurrence ( int arr [ ] ) {			  error : FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TI
    res = 0						      	int res = 0 ;						      int res = 0 ;						  MES_2.cpp: In function ‘int f_filled(int*)’: FIND_
    for element in arr :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2.cpp:28:
	res = res ^ element				      	i < ar_size ;						      i < arr . length ;					  13: error: request for member ‘length’ in ‘arr’, w
    return res						      	i ++ ) res = res ^ ar [ i ] ;				      i ++ ) {							  hich is of non-class type ‘int*’    i < arr . leng
							      	return res ;						    	res = res ^ arr [ i ] ;					  th ;		    ^~~~~~ FIND_THE_NUMBER_OCCURRING
							      }								      }								  _ODD_NUMBER_OF_TIMES_2.cpp: In function ‘int main(
							      								      return res ;						  )’: FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_
							      								    }								  2.cpp:42:49: error: too many arguments to function
							      								    								   ‘int f_filled(int*)’		 if(f_filled(&param0
							      								    								  [i].front(),param1[i]) == f_gold(&param0[i].front(
							      								    								  ),param1[i]))
							      								    								  	       ^ FIND_THE_NUMBER_OCCURRING_ODD_NUMBE
							      								    								  R_OF_TIMES_2.cpp:25:5: note: declared here  int f_
							      								    								  filled ( int arr [ ] ) {	^~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		      FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		    FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		  FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1
--							      --							    --								  --
def CountSquares ( a , b ) :				      int countSquares ( int a , int b ) {			    int CountSquares ( double a , double b ) {			  script_not_found : None
    return ( math.floor ( math.sqrt ( b ) ) - math.ceil ( mat 	return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ;   return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ; 
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_DIVISORS_1_N_1					      SUM_DIVISORS_1_N_1					    SUM_DIVISORS_1_N_1						  SUM_DIVISORS_1_N_1
--							      --							    --								  --
def divisorSum ( n ) :					      int divisorSum ( int n ) {				    int divisorSum ( int n ) {					  success : None
    sum = 0						      	int sum = 0 ;						      double sum = 0 ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	sum += int ( n / i ) * i			      	i <= n ;						      i <= n ;							  
    return int ( sum )					      	++ i ) sum += ( n / i ) * i ;				      i ++ ) sum += ( int ) ( n / i ) * i ;			  
							      	return sum ;						      return ( int ) sum ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_TRIPLET_SUM_ARRAY_1				      MAXIMUM_TRIPLET_SUM_ARRAY_1				    MAXIMUM_TRIPLET_SUM_ARRAY_1					  MAXIMUM_TRIPLET_SUM_ARRAY_1
--							      --							    --								  --
def maxTripletSum ( arr , n ) :				      int maxTripletSum ( int arr [ ] , int n ) {		    int maxTripletSum ( int arr [ ] , int n ) {			  success : None
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] )  	return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ;	      return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) ;  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_EVEN_LENGTH_PALINDROME				      NTH_EVEN_LENGTH_PALINDROME				    NTH_EVEN_LENGTH_PALINDROME					  NTH_EVEN_LENGTH_PALINDROME
--							      --							    --								  --
def evenlength ( n ) :					      string evenlength ( string n ) {				    public : int evenLength ( vector < int > n ) {		  error : NTH_EVEN_LENGTH_PALINDROME.cpp:25:1: error
    res = n						      	string res = n ;					      int res = n . size ( ) ;					  : expected unqualified-id before ‘public’  public
    for j in range ( len ( n ) - 1 , - 1 , - 1 ) :	      	for ( int j = n . length ( ) - 1 ;			      for ( int j = n . size ( ) - 1 ;				  : int f_filled ( vector < int > n ) {	 ^~~~~~ NTH_
	res += n [ j ]					      	j >= 0 ;						      j >= 0 ;							  EVEN_LENGTH_PALINDROME.cpp: In function ‘int main(
    return res						      	-- j ) res += n [ j ] ;					      j -- ) {							  )’: NTH_EVEN_LENGTH_PALINDROME.cpp:41:12: error: ‘
							      	return res ;						    	res += n [ j ] ;					  f_filled’ was not declared in this scope
							      }								      }								  if(f_filled(param0[i]) == f_gold(param0[i]))
							      								      return res ;						  	 ^~~~~~~~ NTH_EVEN_LENGTH_PALINDROME.cpp:41:
							      								    }								  12: note: suggested alternative: ‘f_gold’
							      								    								   if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  	  ^~~~~~~~	       f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER		      FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER			    FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER			  FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER
--							      --							    --								  --
def findSum ( N , K ) :					      int findSum ( int N , int K ) {				    public : int findSum ( int N , int K ) {			  error : FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER.c
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  pp:25:1: error: expected unqualified-id before ‘pu
    for i in range ( 1 , N + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  blic’	 public : int f_filled ( int N , int K ) {
	ans += ( i % K )				      	i <= N ;						      i <= N ;							  ^~~~~~ FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER.cp
    return ans						      	i ++ ) ans += ( i % K ) ;				      i ++ ) ans += ( i % K ) ;					  p: In function ‘int main()’: FIND_SUM_MODULO_K_FIR
							      	return ans ;						      return ans ;						  ST_N_NATURAL_NUMBER.cpp:40:12: error: ‘f_filled’ w
							      }								    }								  as not declared in this scope		 if(f_filled
							      								    								  (param0[i],param1[i]) == f_gold(param0[i],param1[i
							      								    								  ]))		  ^~~~~~~~ FIND_SUM_MODULO_K_FIRST_N
							      								    								  _NATURAL_NUMBER.cpp:40:12: note: suggested alterna
							      								    								  tive: ‘f_gold’	  if(f_filled(param0[i],para
							      								    								  m1[i]) == f_gold(param0[i],param1[i]))
							      								    								   ^~~~~~~~		f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIME_NUMBERS						      PRIME_NUMBERS						    PRIME_NUMBERS						  PRIME_NUMBERS
--							      --							    --								  --
def isPrime ( n ) :					      bool isPrime ( int n ) {					    bool isPrime ( int n ) {					  failure : #Results: 9, 10
    if ( n <= 1 ) :					      	if ( n <= 1 ) return false ;				      if ( ( n <= 1 ) || ( n > n ) ) return false ;		  
	return False					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
    for i in range ( 2 , n ) :				      	i < n ;							      i < n ;							  
	if ( n % i == 0 ) :				      	i ++ ) if ( n % i == 0 ) return false ;			      i ++ ) if ( ( n % i == 0 ) || ( n % i == 1 ) ) return false 
	    return False				      	return true ;						      return true ;						  
    return True						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE
--							      --							    --								  --
def isPossible ( str , n ) :				      bool isPossible ( string str , int n ) {			    bool isPossible ( string str , int n ) {			  failure : #Results: 6, 10
    l = len ( str )					      	int len = str . length ( ) ;				      int l = str . length ( ) ;				  
    if ( l >= n ) :					      	if ( len >= n ) return true ;				      if ( ( l >= n ) && ( l < n ) ) return true ;		  
	return True					      	return false ;						      return false ;						  
    return False					      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSION						      RECURSION							    RECURSION							  RECURSION
--							      --							    --								  --
def printFun ( test ) :					      void printFun ( int test ) {				    void printFun ( int test ) {				  script_not_found : None
    if ( test < 1 ) :					      	if ( test < 1 ) return ;				      if ( ( test < 1 ) || ( test > 2 ) ) {			  
	return						      	else {							    	return ;						  
    else :						      	  cout << test << " " ;					      }								  
	print ( test , end = " " )			      	  printFun ( test - 1 ) ;				      else {							  
	printFun ( test - 1 )				      	  cout << test << " " ;					    	cout << test << " " ;					  
	print ( test , end = " " )			      	  return ;						    	printFun ( test - 1 ) ;					  
	return						      	}							    	cout << test << " " ;					  
							      }								    	return ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_CONWAY_SEQUENCE					      NEWMAN_CONWAY_SEQUENCE					    NEWMAN_CONWAY_SEQUENCE					  NEWMAN_CONWAY_SEQUENCE
--							      --							    --								  --
def sequence ( n ) :					      int sequence ( int n ) {					    int sequence ( int n ) {					  script_not_found : None
    if n == 1 or n == 2 :				      	if ( n == 1 || n == 2 ) return 1 ;			      if ( n == 1 || n == 2 ) return 1 ;			  
	return 1					      	else return sequence ( sequence ( n - 1 ) ) + sequence ( n    else return sequence ( sequence ( n - 1 ) ) + sequence ( n  
    else :						      }								      ;								  
	return sequence ( sequence ( n - 1 ) ) + sequence ( n 								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2_1					      NEXT_POWER_OF_2_1						    NEXT_POWER_OF_2_1						  NEXT_POWER_OF_2_1
--							      --							    --								  --
def nextPowerOf2 ( n ) :				      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
    p = 1						      	unsigned int p = 1 ;					      int p = 1 ;						  
    if ( n and not ( n & ( n - 1 ) ) ) :		      	if ( n && ! ( n & ( n - 1 ) ) ) return n ;		      if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) return n ;	  
	return n					      	while ( p < n ) p <<= 1 ;				      while ( ( p < n ) && ( p != 0 ) ) p <<= 1 ;		  
    while ( p < n ) :					      	return p ;						      return p ;						  
	p <<= 1						      }								    }								  
    return p						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEONARDO_NUMBER						      LEONARDO_NUMBER						    LEONARDO_NUMBER						  LEONARDO_NUMBER
--							      --							    --								  --
def leonardo ( n ) :					      int leonardo ( int n ) {					    int leonardo ( int n ) {					  script_not_found : None
    if ( n == 0 or n == 1 ) :				      	if ( n == 0 || n == 1 ) return 1 ;			      if ( ( n == 0 || n == 1 ) && ( n == 2 ) ) return 1 ;	  
	return 1					      	return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ;	      return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ;	  
    return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 )    }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2_2					      NEXT_POWER_OF_2_2						    NEXT_POWER_OF_2_2						  NEXT_POWER_OF_2_2
--							      --							    --								  --
def nextPowerOf2 ( n ) :				      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
    n -= 1						      	n -- ;							      n -- ;							  
    n |= n >> 1						      	n |= n >> 1 ;						      n |= n >> 1 ;						  
    n |= n >> 2						      	n |= n >> 2 ;						      n |= n >> 2 ;						  
    n |= n >> 4						      	n |= n >> 4 ;						      n |= n >> 4 ;						  
    n |= n >> 8						      	n |= n >> 8 ;						      n |= n >> 8 ;						  
    n |= n >> 16					      	n |= n >> 16 ;						      n |= n >> 16 ;						  
    n += 1						      	n ++ ;							      n ++ ;							  
    return n						      	return n ;						      return n ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_VOLUME_DODECAHEDRON				      CALCULATE_VOLUME_DODECAHEDRON				    CALCULATE_VOLUME_DODECAHEDRON				  CALCULATE_VOLUME_DODECAHEDRON
--							      --							    --								  --
def vol_of_dodecahedron ( side ) :			      double vol_of_dodecahedron ( int side ) {			    inline double vol_of_dodecahedron ( int side ) {		  success : None
    return ( ( ( 15 + ( 7 * ( math.sqrt ( 5 ) ) ) ) / 4 ) * ( 	return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow (    return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow (  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_POWER_PRIME_NUMBER_P_N				      FINDING_POWER_PRIME_NUMBER_P_N				    FINDING_POWER_PRIME_NUMBER_P_N				  FINDING_POWER_PRIME_NUMBER_P_N
--							      --							    --								  --
def PowerOFPINnfactorial ( n , p ) :			      int PowerOFPINnfactorial ( int n , int p ) {		    int PowerOFPINnfactorial ( int n , int p ) {		  success : None
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  
    temp = p						      	int temp = p ;						      int temp = p ;						  
    while ( temp <= n ) :				      	while ( temp <= n ) {					      while ( ( temp <= n ) && ( temp > 0 ) ) {			  
	ans += n / temp					      	  ans += n / temp ;					    	ans += n / temp ;					  
	temp = temp * p					      	  temp = temp * p ;					    	temp = temp * p ;					  
    return ans						      	}							      }								  
							      	return ans ;						      return ans ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		      COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		    COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		  COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ
--							      --							    --								  --
def find ( n , k ) :					      int find ( int n , int k ) {				    int find ( int n , int k ) {				  failure : #Results: 3, 10
    if ( n + 1 >= k ) :					      	if ( n + 1 >= k ) return ( k - 1 ) ;			      if ( ( n + 1 >= k ) && ( n + 1 <= k ) ) return ( k - 1 ) ;  
	return ( k - 1 )				      	else return ( 2 * n + 1 - k ) ;				      else return ( 2 * n + 1 - k ) ;				  
    else :						      }								    }								  
	return ( 2 * n + 1 - k )			      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2
--							      --							    --								  --
def isPowerOfFour ( n ) :				      bool isPowerOfFour ( unsigned int n ) {			    bool isPowerOfFour ( unsigned n ) {				  success : None
    return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not (  	return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAA   return ( n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0x 
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_SHANKS_WILLIAMS_PRIME				      NEWMAN_SHANKS_WILLIAMS_PRIME				    NEWMAN_SHANKS_WILLIAMS_PRIME				  NEWMAN_SHANKS_WILLIAMS_PRIME
--							      --							    --								  --
def nswp ( n ) :					      int nswp ( int n ) {					    int nswp ( int n ) {					  script_not_found : None
    if n == 0 or n == 1 :				      	if ( n == 0 || n == 1 ) return 1 ;			      if ( n == 0 || n == 1 ) return 1 ;			  
	return 1					      	return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ;		      return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ;		  
    return 2 * nswp ( n - 1 ) + nswp ( n - 2 )		      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			      COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			    COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			  COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER
--							      --							    --								  --
def findTrailingZeros ( n ) :				      int findTrailingZeros ( int n ) {				    int findTrailingZeros ( int n ) {				  failure : #Results: 3, 10
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    i = 5						      	for ( int i = 5 ;					      int i = 5 ;						  
    while ( n / i >= 1 ) :				      	n / i >= 1 ;						      while ( ( n / i >= 1 ) && ( n % i == 0 ) ) {		  
	count += int ( n / i )				      	i *= 5 ) count += n / i ;				    	count += ( int ) ( n / i ) ;				  
	i *= 5						      	return count ;						    	i *= 5 ;						  
    return int ( count )				      }								      }								  
							      								      return ( int ) count ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MISSING_NUMBER					      FIND_THE_MISSING_NUMBER					    FIND_THE_MISSING_NUMBER					  FIND_THE_MISSING_NUMBER
--							      --							    --								  --
def getMissingNo ( A ) :				      int getMissingNo ( int a [ ] , int n ) {			    int getMissingNo ( vector < int > & A ) {			  script_not_found : None
    n = len ( A )					      	int total = ( n + 1 ) * ( n + 2 ) / 2 ;			      int n = A . size ( ) ;					  
    total = ( n + 1 ) * ( n + 2 ) / 2			      	for ( int i = 0 ;					      int total = ( n + 1 ) * ( n + 2 ) / 2 ;			  
    sum_of_A = sum ( A )				      	i < n ;							      int sum_of_A = sum ( A ) ;				  
    return total - sum_of_A				      	i ++ ) total -= a [ i ] ;				      return total - sum_of_A ;					  
							      	return total ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTS_PATHS_POINT_REACH_ORIGIN				      COUNTS_PATHS_POINT_REACH_ORIGIN				    COUNTS_PATHS_POINT_REACH_ORIGIN				  COUNTS_PATHS_POINT_REACH_ORIGIN
--							      --							    --								  --
def countPaths ( n , m ) :				      int countPaths ( int n , int m ) {			    int countPaths ( int n , int m ) {				  script_not_found : None
    if ( n == 0 or m == 0 ) :				      	if ( n == 0 || m == 0 ) return 1 ;			      if ( ( n == 0 || m == 0 ) && ( n > m ) ) return 1 ;	  
	return 1					      	return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1    return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1  
    return ( countPaths ( n - 1 , m ) + countPaths ( n , m -  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2     GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2	    GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2	  GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2
--							      --							    --								  --
def largestPower ( n , p ) :				      int largestPower ( int n , int p ) {			    int largestPower ( int n , int p ) {			  script_not_found : None
    x = 0						      	int x = 0 ;						      int x = 0 ;						  
    while n :						      	while ( n ) {						      while ( n ) {						  
	n /= p						      	  n /= p ;						    	n /= p ;						  
	x += n						      	  x += n ;						    	x += n ;						  
    return x						      	}							      }								  
							      	return x ;						      return x ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		      CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		    CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		  CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN
--							      --							    --								  --
def checkValidity ( a , b , c ) :			      bool checkValidity ( int a , int b , int c ) {		    bool checkValidity ( int a , int b , int c ) {		  success : None
    if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) :   	if ( a + b <= c || a + c <= b || b + c <= a ) return false    if ( ( a + b <= c ) || ( a + c <= b ) || ( b + c <= a ) ) r 
	return False					      	else return true ;					      else return true ;					  
    else :						      }								    }								  
	return True					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY	      QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY		    QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY		  QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY
--							      --							    --								  --
def leftRotate ( arr , n , k ) :			      void leftRotate ( int arr [ ] , int n , int k ) {		    void leftRotate ( int arr [ ] , int n , int k ) {		  script_not_found : None
    for i in range ( k , k + n ) :			      	for ( int i = k ;					      for ( int i = k ;						  
	print ( str ( arr [ i % n ] ) , end = " " )	      	i < k + n ;						      i < k + n ;						  
							      	i ++ ) cout << arr [ i % n ] << " " ;			      i ++ ) cout << setw ( 2 ) << arr [ i % n ] << " " ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LAST_INDEX_CHARACTER_STRING			      FIND_LAST_INDEX_CHARACTER_STRING				    FIND_LAST_INDEX_CHARACTER_STRING				  FIND_LAST_INDEX_CHARACTER_STRING
--							      --							    --								  --
def findLastIndex ( str , x ) :				      int findLastIndex ( string & str , char x ) {		    int findLastIndex ( string str , int x ) {			  script_not_found : None
    index = - 1						      	int index = - 1 ;					      int index = - 1 ;						  
    for i in range ( 0 , len ( str ) ) :		      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if str [ i ] == x :				      	i < str . length ( ) ;					      i != str . size ( ) ;					  
	    index = i					      	i ++ ) if ( str [ i ] == x ) index = i ;		      i ++ ) {							  
    return index					      	return index ;						    	if ( str [ i ] == x ) index = i ;			  
							      }								      }								  
							      								      return index ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_POWER_PRIME_NUMBER_P_N_1			      FINDING_POWER_PRIME_NUMBER_P_N_1				    FINDING_POWER_PRIME_NUMBER_P_N_1				  FINDING_POWER_PRIME_NUMBER_P_N_1
--							      --							    --								  --
def PowerOFPINnfactorial ( n , p ) :			      int PowerOFPINnfactorial ( int n , int p ) {		    int PowerOFPINnfactorial ( int n , int p ) {		  success : None
    ans = 0						      	int ans = 0 ;						      double ans = 0 ;						  
    temp = p						      	int temp = p ;						      double temp = p ;						  
    while ( temp <= n ) :				      	while ( temp <= n ) {					      while ( ( temp <= n ) && ( temp > 0 ) ) {			  
	ans += n / temp					      	  ans += n / temp ;					    	ans += n / temp ;					  
	temp = temp * p					      	  temp = temp * p ;					    	temp = temp * p ;					  
    return int ( ans )					      	}							      }								  
							      	return ans ;						      return ( int ) ans ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LAST_INDEX_CHARACTER_STRING_1			      FIND_LAST_INDEX_CHARACTER_STRING_1			    FIND_LAST_INDEX_CHARACTER_STRING_1				  FIND_LAST_INDEX_CHARACTER_STRING_1
--							      --							    --								  --
def findLastIndex ( str , x ) :				      int findLastIndex ( string & str , char x ) {		    int findLastIndex ( string str , int x ) {			  script_not_found : None
    for i in range ( len ( str ) - 1 , - 1 , - 1 ) :	      	for ( int i = str . length ( ) - 1 ;			      for ( int i = str . size ( ) - 1 ;			  
	if ( str [ i ] == x ) :				      	i >= 0 ;						      i >= 0 ;							  
	    return i					      	i -- ) if ( str [ i ] == x ) return i ;			      i -- ) {							  
    return - 1						      	return - 1 ;						    	if ( ( str [ i ] == x ) && ( str [ i + 1 ] == x ) ) retur 
							      }								      }								  
							      								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP   HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP   HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP	  HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP
--							      --							    --								  --
def printNos ( n ) :					      public : void printNos ( unsigned int n ) {		    void printNos ( int n ) {					  script_not_found : None
    if n > 0 :						      	if ( n > 0 ) {						      if ( n > 0 ) {						  
	printNos ( n - 1 )				      	  printNos ( n - 1 ) ;					    	printNos ( n - 1 ) ;					  
	print ( n , end = ' ' )				      	  cout << n << " " ;					    	cout << n << " " ;					  
							      	}							      }								  
							      	return ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY		      FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY			    FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY			  FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY
--							      --							    --								  --
def findLarger ( arr , n ) :				      void findLarger ( int arr [ ] , int n ) {			    void findLarger ( vector < int > & arr , int n ) {		  script_not_found : None
    x = sorted ( arr )					      	sort ( arr , arr + n ) ;				      sort ( arr . begin ( ) , arr . end ( ) ) ;		  
    for i in range ( n / 2 , n ) :			      	for ( int i = n - 1 ;					      for ( int i = n / 2 ;					  
	print ( x [ i ] ) ,				      	i >= n / 2 ;						      i < n ;							  
							      	i -- ) cout << arr [ i ] << " " ;			      i ++ ) cout << x [ i ] << endl ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE	      SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE		    SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE		  SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE
--							      --							    --								  --
def swap ( xp , yp ) :					      void swap ( int * xp , int * yp ) {			    void swap ( int * xp , int * yp ) {				  script_not_found : None
    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]			      	* xp = * xp ^ * yp ;					      * xp = * yp ^ * yp ;					  
    yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]			      	* yp = * xp ^ * yp ;					      * yp = * xp ^ * yp ;					  
    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]			      	* xp = * xp ^ * yp ;					      * xp = * xp ^ * yp ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N			      FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N			    FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N				  FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N
--							      --							    --								  --
def printFactorialNums ( n ) :				      void printFactorialNums ( int n ) {			    void printFactorialNums ( int n ) {				  script_not_found : None
    fact = 1						      	int fact = 1 ;						      int fact = 1 ;						  
    x = 2						      	int x = 2 ;						      int x = 2 ;						  
    while fact <= n :					      	while ( fact <= n ) {					      while ( fact <= n ) {					  
	print ( fact , end = " " )			      	  cout << fact << " " ;					    	cout << fact << " " ;					  
	fact = fact * x					      	  fact = fact * x ;					    	fact = fact * x ;					  
	x += 1						      	  x ++ ;						    	x ++ ;							  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MISSING_NUMBER_1				      FIND_THE_MISSING_NUMBER_1					    FIND_THE_MISSING_NUMBER_1					  FIND_THE_MISSING_NUMBER_1
--							      --							    --								  --
def getMissingNo ( a , n ) :				      int getMissingNo ( int a [ ] , int n ) {			    int getMissingNo ( int a [ ] , int n ) {			  failure : #Results: 0, 10
    i , total = 0 , 1					      	int i , total = 1 ;					      int i , total = 0 ;					  
    for i in range ( 2 , n + 2 ) :			      	for ( i = 2 ;						      total = 1 ;						  
	total += i					      	i <= ( n + 1 ) ;					      for ( i = 2 ;						  
	total -= a [ i - 2 ]				      	i ++ ) {						      i <= n ;							  
    return total					      	  total += i ;						      i += 2 ) {						  
							      	  total -= a [ i - 2 ] ;				    	total += i ;						  
							      	}							    	total -= a [ i - 2 ] ;					  
							      	return total ;						      }								  
							      }								      return total ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX
--							      --							    --								  --
def numberOfPaths ( m , n ) :				      int numberOfPaths ( int m , int n ) {			    int numberOfPaths ( int m , int n ) {			  script_not_found : None
    if ( m == 1 or n == 1 ) :				      	if ( m == 1 || n == 1 ) return 1 ;			      if ( ( m == 1 || n == 1 ) && ( m == n ) ) return 1 ;	  
	return 1					      	return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n    return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n  
    return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m ,  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		      PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		    PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		  PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING
--							      --							    --								  --
def count ( s , c ) :					      int count ( string s , char c ) {				    int count ( string s , char c ) {				  success : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    for i in range ( len ( s ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( s [ i ] == c ) :				      	i < s . length ( ) ;					      i < s . size ( ) ;					  
	    res = res + 1				      	i ++ ) if ( s [ i ] == c ) res ++ ;			      i ++ ) if ( ( s [ i ] == c ) || ( s [ i ] == ' ' ) ) res =  
    return res						      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1		      MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1			    MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1			  MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1
--							      --							    --								  --
def maxvolume ( s ) :					      int maxvolume ( int s ) {					    int maxvolume ( int s ) {					  success : None
    length = int ( s / 3 )				      	int length = s / 3 ;					      int length = ( int ) ( s / 3 ) ;				  
    s -= length						      	s -= length ;						      s -= length ;						  
    breadth = s / 2					      	int breadth = s / 2 ;					      int breadth = s / 2 ;					  
    height = s - breadth				      	int height = s - breadth ;				      int height = s - breadth ;				  
    return int ( length * breadth * height )		      	return length * breadth * height ;			      return ( int ) ( length * breadth * height ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HORNERS_METHOD_POLYNOMIAL_EVALUATION			      HORNERS_METHOD_POLYNOMIAL_EVALUATION			    HORNERS_METHOD_POLYNOMIAL_EVALUATION			  HORNERS_METHOD_POLYNOMIAL_EVALUATION
--							      --							    --								  --
def horner ( poly , n , x ) :				      int horner ( int poly [ ] , int n , int x ) {		    template < typename T > T horner ( const std :: vector < T >  error : HORNERS_METHOD_POLYNOMIAL_EVALUATION.cpp:
    result = poly [ 0 ]					      	int result = poly [ 0 ] ;				      T result = poly [ 0 ] ;					  In function ‘int main()’: HORNERS_METHOD_POLYNOMIA
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  L_EVALUATION.cpp:43:59: error: no matching functio
	result = result * x + poly [ i ]		      	i < n ;							      i < n ;							  n for call to ‘f_filled(__gnu_cxx::__alloc_traits<
    return result					      	i ++ ) result = result * x + poly [ i ] ;		      ++ i ) {							  std::allocator<int>, int>::value_type*, __gnu_cxx:
							      	return result ;						    	result = result * x + poly [ i ] ;			  :__alloc_traits<std::allocator<int>, int>::value_t
							      }								      }								  ype&, __gnu_cxx::__alloc_traits<std::allocator<int
							      								      return result ;						  >, int>::value_type&)’	  if(f_filled(&param
							      								    }								  0[i].front(),param1[i],param2[i]) == f_gold(&param
							      								    								  0[i].front(),param1[i],param2[i]))
							      								    								  					      ^ HORN
							      								    								  ERS_METHOD_POLYNOMIAL_EVALUATION.cpp:25:27: note:
							      								    								  candidate: ‘template<class T> T f_filled(const std
							      								    								  ::vector<_Tp>&, int, T)’  template < typename T >
							      								    								  T f_filled ( const std :: vector < T > & poly , in
							      								    								  t n , T x ) {				   ^~~~~~~~
							      								    								  HORNERS_METHOD_POLYNOMIAL_EVALUATION.cpp:25:27: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: HORNERS_METHOD_POLYNOMIAL_EVALUATION.cpp:43:5
							      								    								  9: note:   mismatched types ‘const std::vector<_Tp
							      								    								  >’ and ‘__gnu_cxx::__alloc_traits<std::allocator<i
							      								    								  nt>, int>::value_type*’ {aka ‘int*’}		if(f
							      								    								  _filled(&param0[i].front(),param1[i],param2[i]) ==
							      								    								   f_gold(&param0[i].front(),param1[i],param2[i]))
							      								    								  
							      								    								  	  ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1			      NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1			    NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1				  NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1
--							      --							    --								  --
def countDigits ( a , b ) :				      int countDigits ( int a , int b ) {			    int countDigits ( int a , int b ) {				  success : None
    if ( a == 0 or b == 0 ) :				      	if ( a == 0 || b == 0 ) return 1 ;			      if ( ( a == 0 || b == 0 ) && ( b == 0 || a == 0 ) ) return  
	return 1					      	return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) )    return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) )  
    return math.floor ( math.log10 ( abs ( a ) ) + math.log10 }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUICK_WAY_CHECK_CHARACTERS_STRING			      QUICK_WAY_CHECK_CHARACTERS_STRING				    QUICK_WAY_CHECK_CHARACTERS_STRING				  QUICK_WAY_CHECK_CHARACTERS_STRING
--							      --							    --								  --
def allCharactersSame ( s ) :				      bool allCharactersSame ( string s ) {			    bool allCharactersSame ( string s ) {			  success : None
    n = len ( s )					      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	if s [ i ] != s [ 0 ] :				      	i < n ;							      i < n ;							  
	    return False				      	i ++ ) if ( s [ i ] != s [ 0 ] ) return false ;		      i ++ ) {							  
    return True						      	return true ;						    	if ( s [ i ] != s [ 0 ] ) return false ;		  
							      }								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		      CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		    CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		  CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1
--							      --							    --								  --
def isPower ( x , y ) :					      bool isPower ( int x , int y ) {				    int isPower ( double x , double y ) {			  failure : #Results: 6, 10
    res1 = math.log ( y ) / math.log ( x )		      	int res1 = log ( y ) / log ( x ) ;			      double res1 = log ( y ) / log ( x ) ;			  
    res2 = math.log ( y ) / math.log ( x )		      	double res2 = log ( y ) / log ( x ) ;			      double res2 = log ( y ) / log ( x ) ;			  
    return 1 if ( res1 == res2 ) else 0			      	return ( res1 == res2 ) ;				      return 1 == ( res1 == res2 ) ? 0 : 1 ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			      MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			    MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			  MULTIPLICATIVE_INVERSE_UNDER_MODULO_M
--							      --							    --								  --
def modInverse ( a , m ) :				      int modInverse ( int a , int m ) {			    int modInverse ( int a , int m ) {				  script_not_found : None
    a = a % m						      	a = a % m ;						      a = a % m ;						  
    for x in range ( 1 , m ) :				      	for ( int x = 1 ;					      for ( int x = 1 ;						  
	if ( ( a * x ) % m == 1 ) :			      	x < m ;							      x < m ;							  
	    return x					      	x ++ ) if ( ( a * x ) % m == 1 ) return x ;		      x ++ ) if ( ( ( a * x ) % m ) == 1 ) return x ;		  
    return 1						      }								      return 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DOUBLE_FACTORIAL_1					      DOUBLE_FACTORIAL_1					    DOUBLE_FACTORIAL_1						  DOUBLE_FACTORIAL_1
--							      --							    --								  --
def doublefactorial ( n ) :				      unsigned int doublefactorial ( unsigned int n ) {		    int doublefactorial ( int n ) {				  failure : #Results: 3, 10
    res = 1						      	int res = 1 ;						      int res = 1 ;						  
    for i in range ( n , - 1 , - 2 ) :			      	for ( int i = n ;					      for ( int i = n ;						  
	if ( i == 0 or i == 1 ) :			      	i >= 0 ;						      i >= 0 ;							  
	    return res					      	i = i - 2 ) {						      i -- ) {							  
	else :						      	  if ( i == 0 || i == 1 ) return res ;			    	if ( ( i == 0 || i == 1 ) && ( i == 2 ) ) return res ;	  
	    res *= i					      	  else res *= i ;					    	else res *= i ;						  
							      	}							      }								  
							      }								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER		      FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER		    FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER			  FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER
--							      --							    --								  --
def center ( x1 , x2 , y1 , y2 ) :			      void center ( int x1 , int x2 , int y1 , int y2 ) {	    void center ( int x1 , int x2 , int y1 , int y2 ) {		  script_not_found : None
    print ( int ( ( x1 + x2 ) / 2 ) , end = "" )	      	cout << ( float ) ( x1 + x2 ) / 2 << ", " << ( float ) ( y1   cout << ( int ) ( ( x1 + x2 ) / 2 ) << "," << ( int ) ( ( y 
    print ( "," , int ( ( y1 + y2 ) / 2 ) )		      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_EFFICIENTLY_CALCULATE_EX			      PROGRAM_TO_EFFICIENTLY_CALCULATE_EX			    PROGRAM_TO_EFFICIENTLY_CALCULATE_EX				  PROGRAM_TO_EFFICIENTLY_CALCULATE_EX
--							      --							    --								  --
def exponential ( n , x ) :				      float exponential ( int n , float x ) {			    void exponential ( int n , double x ) {			  script_not_found : None
    sum = 1.0						      	float sum = 1.0f ;					      double sum = 1.0 ;					  
    for i in range ( n , 0 , - 1 ) :			      	for ( int i = n - 1 ;					      for ( int i = n ;						  
	sum = 1 + x * sum / i				      	i > 0 ;							      i > 0 ;							  
    print ( "e^x =" , sum )				      	-- i ) sum = 1 + x * sum / i ;				      i -- ) sum = 1 + x * sum / i ;				  
							      	return sum ;						      cout << "e^x =" << sum << endl ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			      C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			    C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			  C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY
--							      --							    --								  --
def largest ( arr , n ) :				      int largest ( int arr [ ] , int n ) {			    int largest ( int arr [ ] , int n ) {			  script_not_found : None
    max = arr [ 0 ]					      	int i ;							      int max = arr [ 0 ] ;					  
    for i in range ( 1 , n ) :				      	int max = arr [ 0 ] ;					      for ( int i = 1 ;						  
	if arr [ i ] > max :				      	for ( i = 1 ;						      i < n ;							  
	    max = arr [ i ]				      	i < n ;							      i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;		  
    return max						      	i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;		      return max ;						  
							      	return max ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2						      NEXT_POWER_OF_2						    NEXT_POWER_OF_2						  NEXT_POWER_OF_2
--							      --							    --								  --
def nextPowerOf2 ( n ) :				      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( unsigned n ) {				  failure : #Results: 2, 10
    count = 0						      	unsigned count = 0 ;					      int count = 0 ;						  
    if ( n and not ( n & ( n - 1 ) ) ) :		      	if ( n && ! ( n & ( n - 1 ) ) ) return n ;		      if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) return n ;	  
	return n					      	while ( n != 0 ) {					      while ( ( n != 0 ) && ( n & ( n - 1 ) ) ) {		  
    while ( n != 0 ) :					      	  n >>= 1 ;						    	n >>= 1 ;						  
	n >>= 1						      	  count += 1 ;						    	count ++ ;						  
	count += 1					      	}							      }								  
    return 1 << count					      	return 1 << count ;					      return 1 << count ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_ROOT_OF_AN_INTEGER				      SQUARE_ROOT_OF_AN_INTEGER					    SQUARE_ROOT_OF_AN_INTEGER					  SQUARE_ROOT_OF_AN_INTEGER
--							      --							    --								  --
def floorSqrt ( x ) :					      int floorSqrt ( int x ) {					    int floorSqrt ( int x ) {					  success : None
    if ( x == 0 or x == 1 ) :				      	if ( x == 0 || x == 1 ) return x ;			      if ( ( x == 0 || x == 1 ) && ( x > 0 ) ) return x ;	  
	return x					      	int i = 1 , result = 1 ;				      int i = 1 ;						  
    i = 1 result = 1					      	while ( result <= x ) {					      int result = 1 ;						  
    while ( result <= x ) :				      	  i ++ ;						      while ( ( result <= x ) || ( result == 0 ) ) {		  
	i += 1						      	  result = i * i ;					    	i ++ ;							  
	result = i * i					      	}							    	result = i * i ;					  
    return i - 1					      	return i - 1 ;						      }								  
							      }								      return i - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING		      HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING			    HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING			  HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING
--							      --							    --								  --
def search ( arr , x ) :				      int search ( int arr [ ] , int n , int x ) {		    int search ( vector < int > & arr , int x ) {		  error : HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING.
    n = len ( arr )					      	for ( int i = 0 ;					      int n = arr . size ( ) ;					  cpp: In function ‘int main()’: HOW_TO_BEGIN_WITH_C
    for j in range ( 0 , n ) :				      	i < n ;							      for ( int j = 0 ;						  OMPETITIVE_PROGRAMMING.cpp:44:21: error: invalid i
	if ( x == arr [ j ] ) :				      	i ++ ) {						      j != n ;							  nitialization of non-const reference of type ‘std:
	    return j					      	  if ( arr [ i ] == x ) return i ;			      ++ j ) {							  :vector<int>&’ from an rvalue of type ‘__gnu_cxx::
    return - 1						      	}							    	if ( ( x == arr [ j ] ) || ( x == arr [ j ] ) ) return j  __alloc_traits<std::allocator<int>, int>::value_ty
							      	return - 1 ;						      }								  pe*’ {aka ‘int*’}	     if(f_filled(&param0[i].
							      }								      return - 1 ;						  front(),param1[i],param2[i]) == f_gold(&param0[i].
							      								    }								  front(),param1[i],param2[i]))
							      								    								   ^~~~~~~~~~~~~~~~~~ HOW_TO_BEGIN_WITH_COMPETITIVE_
							      								    								  PROGRAMMING.cpp:26:5: note: in passing argument 1
							      								    								  of ‘int f_filled(std::vector<int>&, int)’  int f_f
							      								    								  illed ( vector < int > & arr , int x ) {	^~~~
							      								    								  ~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		      CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		    CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		  CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER
--							      --							    --								  --
def isPower ( x , y ) :					      bool isPower ( int x , long int y ) {			    bool isPower ( int x , int y ) {				  success : None
    if ( x == 1 ) :					      	if ( x == 1 ) return ( y == 1 ) ;			      if ( ( x == 1 ) || ( y == 1 ) ) return ( y == 1 ) ;	  
	return ( y == 1 )				      	long int pow = 1 ;					      int pow = 1 ;						  
    pow = 1						      	while ( pow < y ) pow *= x ;				      while ( ( pow < y ) && ( pow != 0 ) ) pow = pow * x ;	  
    while ( pow < y ) :					      	return ( pow == y ) ;					      return ( pow == y ) ;					  
	pow = pow * x					      }								    }								  
    return ( pow == y )					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS			      SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS			    SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS				  SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS
--							      --							    --								  --
def kthgroupsum ( k ) :					      int kthgroupsum ( int k ) {				    int kthgroupsum ( int k ) {					  success : None
    cur = int ( ( k * ( k - 1 ) ) + 1 )			      	int cur = ( k * ( k - 1 ) ) + 1 ;			      int cur = ( int ) ( ( k * ( k - 1 ) ) + 1 ) ;		  
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    while k :						      	while ( k -- ) {					      while ( k ) {						  
	sum += cur					      	  sum += cur ;						    	sum += cur ;						  
	cur += 2					      	  cur += 2 ;						    	cur += 2 ;						  
	k = k - 1					      	}							    	k = k - 1 ;						  
    return sum						      	return sum ;						      }								  
							      }								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SERIES_12_32_52_2N_12				      SUM_SERIES_12_32_52_2N_12					    SUM_SERIES_12_32_52_2N_12					  SUM_SERIES_12_32_52_2N_12
--							      --							    --								  --
def sumOfSeries ( n ) :					      int sumOfSeries ( int n ) {				    int sumOfSeries ( int n ) {					  success : identical to gold
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 )	      	i <= n ;						      i <= n ;							  
    return sum						      	i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ;	      i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ;	  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_20				      CHECK_LARGE_NUMBER_DIVISIBLE_20				    CHECK_LARGE_NUMBER_DIVISIBLE_20				  CHECK_LARGE_NUMBER_DIVISIBLE_20
--							      --							    --								  --
def divisibleBy20 ( num ) :				      bool divisibleBy20 ( string num ) {			    bool divisibleBy20 ( string num ) {				  script_not_found : None
    lastTwoDigits = int ( num [ - 2 : ] )		      	int lastTwoDigits = stoi ( num . substr ( num . length ( )    int lastTwoDigits = ( int ) num . length ( ) - 2 ;	  
    return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 = 	return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4    return ( ( lastTwoDigits % 5 == 0 && lastTwoDigits % 4 == 0 
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_ROOT_OF_A_PERFECT_SQUARE				      SQUARE_ROOT_OF_A_PERFECT_SQUARE				    SQUARE_ROOT_OF_A_PERFECT_SQUARE				  SQUARE_ROOT_OF_A_PERFECT_SQUARE
--							      --							    --								  --
def squareRoot ( n ) :					      public : float squareRoot ( float n ) {			    double squareRoot ( double n ) {				  script_not_found : None
    x = n						      	float x = n ;						      double x = n ;						  
    y = 1						      	float y = 1 ;						      double y = 1 ;						  
    e = 0.000001					      	float e = 0.000001 ;					      double e = 0.000001 ;					  
    while ( x - y > e ) :				      	while ( x - y > e ) {					      while ( ( x - y > e ) && ( y > e ) ) {			  
	x = ( x + y ) / 2				      	  x = ( x + y ) / 2 ;					    	x = ( x + y ) / 2 ;					  
	y = n / x					      	  y = n / x ;						    	y = n / x ;						  
    return x						      	}							      }								  
							      	return x ;						      return x ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS					      SUM_PAIRWISE_PRODUCTS					    SUM_PAIRWISE_PRODUCTS					  SUM_PAIRWISE_PRODUCTS
--							      --							    --								  --
def findSum ( n ) :					      long long int findSum ( int n ) {				    int findSum ( int n ) {					  success : None
    sm = 0						      	long long int sum = 0 ;					      int sm = 0 ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	for j in range ( i , n + 1 ) :			      	i <= n ;						      i <= n ;							  
	    sm = sm + i * j				      	i ++ ) for ( int j = i ;				      i ++ ) {							  
    return sm						      	j <= n ;						    	for ( int j = i ;					  
							      	j ++ ) sum = sum + i * j ;				    	j <= n ;						  
							      	return sum ;						    	j ++ ) {						  
							      }								    	  sm = sm + i * j ;					  
							      								    	}							  
							      								      }								  
							      								      return sm ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GAME_REPLACING_ARRAY_ELEMENTS				      GAME_REPLACING_ARRAY_ELEMENTS				    GAME_REPLACING_ARRAY_ELEMENTS				  GAME_REPLACING_ARRAY_ELEMENTS
--							      --							    --								  --
def playGame ( arr , n ) :				      int playGame ( int arr [ ] , int n ) {			    int playGame ( int arr [ ] , int n ) {			  script_not_found : None
    s = set ( )						      	unordered_set < int > hash ;				      set < int > s ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	s.add ( arr [ i ] )				      	i < n ;							      i < n ;							  
    return 1 if len ( s ) % 2 == 0 else 2		      	i ++ ) hash . insert ( arr [ i ] ) ;			      i ++ ) s . insert ( arr [ i ] ) ;				  
							      	return ( hash . size ( ) % 2 == 0 ? 1 : 2 ) ;		      return 1 == s . size ( ) % 2 ? 2 : 1 ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_IS_DIVISIBLE_BY_29_OR_NOT			      NUMBER_IS_DIVISIBLE_BY_29_OR_NOT				    NUMBER_IS_DIVISIBLE_BY_29_OR_NOT				  NUMBER_IS_DIVISIBLE_BY_29_OR_NOT
--							      --							    --								  --
def isDivisible ( n ) :					      bool isDivisible ( long long int n ) {			    bool isDivisible ( int n ) {				  timeout : None
    while ( int ( n / 100 ) ) :				      	while ( n / 100 ) {					      while ( ( int ) ( n / 100 ) < n ) {			  
	last_digit = int ( n % 10 )			      	  int last_digit = n % 10 ;				    	int lastDigit = ( int ) ( n % 10 ) ;			  
	n = int ( n / 10 )				      	  n /= 10 ;						    	n = ( int ) ( n / 10 ) ;				  
	n += last_digit * 3				      	  n += last_digit * 3 ;					    	n += lastDigit * 3 ;					  
    return ( n % 29 == 0 )				      	}							      }								  
							      	return ( n % 29 == 0 ) ;				      return ( n % 29 == 0 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE    FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE    FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE	  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE
--							      --							    --								  --
def first ( str ) :					      char first ( string str ) {				    int first ( string str ) {					  error : FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATI
    for i in range ( 0 , len ( str ) ) :		      	for ( int i = 0 ;					      for ( int i = 0 ;						  VE_AND_RECURSIVE.cpp: In function ‘int f_filled(st
	if ( str [ i ].istitle ( ) ) :			      	i < str . length ( ) ;					      i != str . size ( ) ;					  d::__cxx11::string)’: FIRST_UPPERCASE_LETTER_IN_A_
	    return str [ i ]				      	i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ;	      i ++ ) {							  STRING_ITERATIVE_AND_RECURSIVE.cpp:28:24: error: r
    return 0						      	return 0 ;						    	if ( ( str [ i ] . istitle ( ) ) && ( str [ i ] . isalpha equest for member ‘istitle’ in ‘str.std::__cxx11::
							      }								      }								  basic_string<char>::operator[](((std::__cxx11::bas
							      								      return 0 ;						  ic_string<char>::size_type)i))’, which is of non-c
							      								    }								  lass type ‘__gnu_cxx::__alloc_traits<std::allocato
							      								    								  r<char>, char>::value_type’ {aka ‘char’}	if (
							      								    								   ( str [ i ] . istitle ( ) ) && ( str [ i ] . isal
							      								    								  pha ( ) ) ) return str [ i ] ;
							      								    								       ^~~~~~~ FIRST_UPPERCASE_LETTER_IN_A_STRING_IT
							      								    								  ERATIVE_AND_RECURSIVE.cpp:28:55: error: request fo
							      								    								  r member ‘isalpha’ in ‘str.std::__cxx11::basic_str
							      								    								  ing<char>::operator[](((std::__cxx11::basic_string
							      								    								  <char>::size_type)i))’, which is of non-class type
							      								    								   ‘__gnu_cxx::__alloc_traits<std::allocator<char>,
							      								    								  char>::value_type’ {aka ‘char’}      if ( ( str [
							      								    								  i ] . istitle ( ) ) && ( str [ i ] . isalpha ( ) )
							      								    								   ) return str [ i ] ;
							      								    								  			     ^~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2
--							      --							    --								  --
def find_extra_element_index ( arrA , arrB ) :		      int find_extra_element_index ( int arrA [ ] , int arrB [ ] ,  template < typename T > int findExtraElementIndex ( const T * script_not_found : None
    extra_element = sum ( arrA ) - sum ( arrB )		      	int extra_element = sum ( arrA , n ) - sum ( arrB , m ) ;     const T extraElement = sum ( arrA ) - sum ( arrB ) ;	  
    return arrA.index ( extra_element )			      	return indexOf ( arrA , extra_element , n ) ;		      return arrA -> find ( extraElement ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		      SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		    SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		  SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX
--							      --							    --								  --
def spiralDiaSum ( n ) :				      int spiralDiaSum ( int n ) {				    int spiralDiaSum ( int n ) {				  script_not_found : None
    if n == 1 :						      	if ( n == 1 ) return 1 ;				      if ( n == 1 ) return 1 ;					  
	return 1					      	return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ;   return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; 
    return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION_1			      PROGRAM_DECIMAL_BINARY_CONVERSION_1			    PROGRAM_DECIMAL_BINARY_CONVERSION_1				  PROGRAM_DECIMAL_BINARY_CONVERSION_1
--							      --							    --								  --
def decToBinary ( n ) :					      int decToBinary ( int n ) {				    void decToBinary ( int n ) {				  script_not_found : None
    for i in range ( 31 , - 1 , - 1 ) :			      	for ( int i = 31 ;					      for ( int i = 31 ;					  
	k = n >> i					      	i >= 0 ;						      i >= 0 ;							  
	if ( k & 1 ) :					      	i -- ) {						      i -- ) {							  
	    print ( "1" , end = "" )			      	  int k = n >> i ;					    	int k = n >> i ;					  
	else :						      	  if ( k & 1 ) cout << "1" ;				    	if ( ( k & 1 ) != 0 ) cout << "1" << " " ;		  
	    print ( "0" , end = "" )			      	  else cout << "0" ;					    	else cout << "0" << " " ;				  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS	      ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS		    ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS		  ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS
--							      --							    --								  --
def search ( arr , n , x ) :				      int search ( int arr [ ] , int n , int x ) {		    int search ( int arr [ ] , int n , int x ) {		  failure : #Results: 9, 10
    i = 0						      	int i ;							      int i ;							  
    for i in range ( i , n ) :				      	for ( i = 0 ;						      for ( i = 0 ;						  
	if ( arr [ i ] == x ) :				      	i < n ;							      i < n ;							  
	    return i					      	i ++ ) {						      i ++ ) if ( ( arr [ i ] == x ) && ( arr [ i + 1 ] == x ) )  
    return - 1						      	  if ( arr [ i ] == x ) return i ;			      return - 1 ;						  
							      	}							    }								  
							      	return - 1 ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSITION_OF_RIGHTMOST_SET_BIT_2				      POSITION_OF_RIGHTMOST_SET_BIT_2				    POSITION_OF_RIGHTMOST_SET_BIT_2				  POSITION_OF_RIGHTMOST_SET_BIT_2
--							      --							    --								  --
def Right_most_setbit ( num ) :				      int Right_most_setbit ( int num ) {			    int Right_most_setbit ( int num ) {				  script_not_found : None
    pos = 1						      	int pos = 1 ;						      int pos = 1 ;						  
    for i in range ( INT_SIZE ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if not ( num & ( 1 << i ) ) :			      	i < INT_SIZE ;						      i < INT_SIZE ;						  
	    pos += 1					      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( ! ( num & ( 1 << i ) ) ) pos ++ ;		    	if ( ! ( num & ( 1 << i ) ) ) pos ++ ;			  
	    break					      	  else break ;						    	else break ;						  
    return pos						      	}							      }								  
							      	return pos ;						      return pos ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	      SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	    SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	  SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS
--							      --							    --								  --
def smallest ( x , y , z ) :				      int smallest ( int x , int y , int z ) {			    int smallest ( int x , int y , int z ) {			  success : None
    c = 0						      	int c = 0 ;						      int c = 0 ;						  
    while ( x and y and z ) :				      	while ( x && y && z ) {					      while ( ( x > 0 && y > 0 && z > 0 ) || ( x < 0 && y < 0 &&  
	x = x - 1					      	  x -- ;						    	x = x - 1 ;						  
	y = y - 1					      	  y -- ;						    	y = y - 1 ;						  
	z = z - 1					      	  z -- ;						    	z = z - 1 ;						  
	c = c + 1					      	  c ++ ;						    	c = c + 1 ;						  
    return c						      	}							      }								  
							      	return c ;						      return c ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY    COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY    COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY	  COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY
--							      --							    --								  --
def countOccurrences ( arr , n , x ) :			      int countOccurrences ( int arr [ ] , int n , int x ) {	    int countOccurrences ( int arr [ ] , int n , int x ) {	  success : identical to gold
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if x == arr [ i ] :				      	i < n ;							      i < n ;							  
	    res += 1					      	i ++ ) if ( x == arr [ i ] ) res ++ ;			      i ++ ) if ( x == arr [ i ] ) res ++ ;			  
    return res						      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME
--							      --							    --								  --
def getSum ( n ) :					      public : int getSum ( int n ) {				    int getSum ( int n ) {					  script_not_found : None
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    while ( n != 0 ) :					      	while ( n != 0 ) {					      while ( ( n != 0 ) && ( n != 1 ) ) {			  
	sum = sum + int ( n % 10 )			      	  sum = sum + n % 10 ;					    	sum = sum + ( int ) ( n % 10 ) ;			  
	n = int ( n / 10 )				      	  n = n / 10 ;						    	n = ( int ) ( n / 10 ) ;				  
    return sum						      	}							      }								  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1	      SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1		    SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1		  SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1
--							      --							    --								  --
def nextPowerOf2 ( n ) :				      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
    p = 1						      	unsigned int p = 1 ;					      int p = 1 ;						  
    if ( n and not ( n & ( n - 1 ) ) ) :		      	if ( n && ! ( n & ( n - 1 ) ) ) return n ;		      if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) return n ;	  
	return n					      	while ( p < n ) p <<= 1 ;				      while ( ( p < n ) && ( p != 0 ) ) p <<= 1 ;		  
    while ( p < n ) :					      	return p ;						      return p ;						  
	p <<= 1						      }								    }								  
    return p						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3
--							      --							    --								  --
def numberOfPaths ( m , n ) :				      int numberOfPaths ( int m , int n ) {			    public : int numberOfPaths ( int m , int n ) {		  error : COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT
    for i in range ( n , ( m + n - 1 ) ) :		      	int path = 1 ;						      for ( int i = n ;						  _NXM_MATRIX_3.cpp:28:1: error: expected unqualifie
	path *= i					      	for ( int i = n ;					      i < ( m + n - 1 ) ;					  d-id before ‘public’	public : int f_filled ( int
	path //= ( i - n + 1 )				      	i < ( m + n - 1 ) ;					      i ++ ) {							  m , int n ) {	 ^~~~~~ COUNT_POSSIBLE_PATHS_TOP_LEF
    return path						      	i ++ ) {						    	path *= i ;						  T_BOTTOM_RIGHT_NXM_MATRIX_3.cpp: In function ‘int
							      	  path *= i ;						    	path /= ( i - n + 1 ) ;					  main()’: COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGH
							      	  path /= ( i - n + 1 ) ;				      }								  T_NXM_MATRIX_3.cpp:45:12: error: ‘f_filled’ was no
							      	}							      return path ;						  t declared in this scope	    if(f_filled(para
							      	return path ;						    }								  m0[i],param1[i]) == f_gold(param0[i],param1[i]))
							      }								    								  	     ^~~~~~~~ COUNT_POSSIBLE_PATHS_TOP_LEFT_
							      								    								  BOTTOM_RIGHT_NXM_MATRIX_3.cpp:45:12: note: suggest
							      								    								  ed alternative: ‘f_gold’	    if(f_filled(para
							      								    								  m0[i],param1[i]) == f_gold(param0[i],param1[i]))
							      								    								  	     ^~~~~~~~		  f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2	      SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2		    SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2		  SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2
--							      --							    --								  --
def nextPowerOf2 ( n ) :				      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
    n -= 1						      	n -- ;							      n -- ;							  
    n |= n >> 1						      	n |= n >> 1 ;						      n |= n >> 1 ;						  
    n |= n >> 2						      	n |= n >> 2 ;						      n |= n >> 2 ;						  
    n |= n >> 4						      	n |= n >> 4 ;						      n |= n >> 4 ;						  
    n |= n >> 8						      	n |= n >> 8 ;						      n |= n >> 8 ;						  
    n |= n >> 16					      	n |= n >> 16 ;						      n |= n >> 16 ;						  
    n += 1						      	n ++ ;							      n ++ ;							  
    return n						      	return n ;						      return n ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			      FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			    FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			  FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2
--							      --							    --								  --
def singleNumber ( nums ) :				      int singleNumber ( int a [ ] , int n ) {			    public : int singleNumber ( vector < int > & nums ) {	  error : FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2.cpp:2
    return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2    	unordered_set < int > s ( a , a + n ) ;			      return ( 3 * sum ( set ( nums ) ) - set ( nums ) ) / 2 ;	  4:1: error: expected unqualified-id before ‘public
							      	int arr_sum = accumulate ( a , a + n , 0 ) ;		    }								  ’  public : int f_filled ( vector < int > & nums )
							      	int set_sum = accumulate ( s . begin ( ) , s . end ( ) , 0  								   {  ^~~~~~ FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2.cp
							      	return ( 3 * set_sum - arr_sum ) / 2 ;			    								  p: In function ‘int main()’: FIND_THE_ELEMENT_THAT
							      }								    								  _APPEARS_ONCE_2.cpp:35:12: error: ‘f_filled’ was n
							      								    								  ot declared in this scope	     if(f_filled(&pa
							      								    								  ram0[i].front(),param1[i]) == f_gold(&param0[i].fr
							      								    								  ont(),param1[i]))		^~~~~~~~ FIND_THE_EL
							      								    								  EMENT_THAT_APPEARS_ONCE_2.cpp:35:12: note: suggest
							      								    								  ed alternative: ‘f_gold’	    if(f_filled(&par
							      								    								  am0[i].front(),param1[i]) == f_gold(&param0[i].fro
							      								    								  nt(),param1[i]))	       ^~~~~~~~
							      								    								  f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	      FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	    FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	  FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN
--							      --							    --								  --
def compute ( a , b ) :					      double compute ( int a , int b ) {			    double compute ( double a , double b ) {			  failure : #Results: 1, 10
    AM = ( a + b ) / 2					      	double AM , GM , HM ;					      double AM = ( a + b ) / 2 ;				  
    GM = math.sqrt ( a * b )				      	AM = ( a + b ) / 2 ;					      double GM = sqrt ( a * b ) ;				  
    HM = ( GM * GM ) / AM				      	GM = sqrt ( a * b ) ;					      double HM = ( GM * GM ) / AM ;				  
    return HM						      	HM = ( GM * GM ) / AM ;					      return HM ;						  
							      	return HM ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION      CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION	    CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION	  CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION
--							      --							    --								  --
def isPerfectSquare ( n ) :				      bool isPerfectSquare ( int n ) {				    bool isPerfectSquare ( int n ) {				  success : None
    i = 1						      	for ( int sum = 0 , i = 1 ;				      int i = 1 ;						  
    the_sum = 0						      	sum < n ;						      int the_sum = 0 ;						  
    while the_sum < n :					      	i += 2 ) {						      while ( the_sum < n ) {					  
	the_sum += i					      	  sum += i ;						    	the_sum += i ;						  
	if the_sum == n :				      	  if ( sum == n ) return true ;				    	if ( the_sum == n ) return true ;			  
	    return True					      	}							    	i += 2 ;						  
	i += 2						      	return false ;						      }								  
    return False					      }								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS		      SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS			    SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS			  SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS
--							      --							    --								  --
def sumBetweenTwoKth ( arr , n , k1 , k2 ) :		      int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2  int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2  script_not_found : None
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    result = 0						      	return accumulate ( arr + k1 , arr + k2 - 1 , 0 ) ;	      int result = 0 ;						  
    for i in range ( k1 , k2 - 1 ) :			      }								      for ( int i = k1 ;					  
	result += arr [ i ]				      								      i <= k2 - 1 ;						  
    return result					      								      i ++ ) result += arr [ i ] ;				  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY		      K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY			    K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY			  K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY
--							      --							    --								  --
def kLargest ( arr , k ) :				      void kLargest ( int arr [ ] , int n , int k ) {		    void kLargest ( vector < int > & arr , int k ) {		  script_not_found : None
    arr.sort ( reverse = True )				      	sort ( arr , arr + n , greater < int > ( ) ) ;		      sort ( arr . begin ( ) , arr . end ( ) ) ;		  
    for i in range ( k ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	print ( arr [ i ] , end = " " )			      	i < k ;							      i < k ;							  
							      	i ++ ) cout << arr [ i ] << " " ;			      i ++ ) cout << arr [ i ] << " " ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIBONACCI_MODULO_P					      FIBONACCI_MODULO_P					    FIBONACCI_MODULO_P						  FIBONACCI_MODULO_P
--							      --							    --								  --
def findMinZero ( p ) :					      int findMinZero ( int p ) {				    int findMinZero ( int p ) {					  success : None
    first = 1						      	int first = 1 , second = 1 , number = 2 , next = 1 ;	      int first = 1 ;						  
    second = 1						      	while ( next ) {					      int second = 1 ;						  
    number = 2						      	  next = ( first + second ) % p ;			      int number = 2 ;						  
    next = 1						      	  first = second ;					      int next = 1 ;						  
    while ( next ) :					      	  second = next ;					      while ( ( next ) ) {					  
	next = ( first + second ) % p			      	  number ++ ;						    	next = ( first + second ) % p ;				  
	first = second					      	}							    	first = second ;					  
	second = next					      	return number ;						    	second = next ;						  
	number = number + 1				      }								    	number = number + 1 ;					  
    return number					      								      }								  
							      								      return number ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_NTH_CATALAN_NUMBER				      PROGRAM_NTH_CATALAN_NUMBER				    PROGRAM_NTH_CATALAN_NUMBER					  PROGRAM_NTH_CATALAN_NUMBER
--							      --							    --								  --
def catalan ( n ) :					      unsigned long int catalan ( unsigned int n ) {		    double catalan ( int n ) {					  script_not_found : None
    if n <= 1 :						      	if ( n <= 1 ) return 1 ;				      if ( n <= 1 ) return 1 ;					  
	return 1					      	unsigned long int res = 0 ;				      double res = 0 ;						  
    res = 0						      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( n ) :				      	i < n ;							      i < n ;							  
	res += catalan ( i ) * catalan ( n - i - 1 )	      	i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ;	      i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ;	  
    return res						      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES			      SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES			    SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES				  SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES
--							      --							    --								  --
def findS ( s ) :					      int findS ( int s ) {					    int findS ( int s ) {					  success : None
    _sum = 0						      	int sum = 0 ;						      int _sum = 0 ;						  
    n = 1						      	for ( int n = 1 ;					      int n = 1 ;						  
    while ( _sum < s ) :				      	sum < s ;						      while ( ( _sum < s ) && ( _sum < s ) ) {			  
	_sum += n * n					      	n ++ ) {						    	_sum += n * n ;						  
	n += 1						      	  sum += n * n ;					    	n ++ ;							  
    n -= 1						      	  if ( sum == s ) return n ;				      }								  
    if _sum == s :					      	}							      n -- ;							  
	return n					      	return - 1 ;						      if ( _sum == s ) return n ;				  
    return - 1						      }								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_EVEN_FIBONACCI_NUMBER				      NTH_EVEN_FIBONACCI_NUMBER					    NTH_EVEN_FIBONACCI_NUMBER					  NTH_EVEN_FIBONACCI_NUMBER
--							      --							    --								  --
def evenFib ( n ) :					      long int evenFib ( int n ) {				    int evenFib ( int n ) {					  script_not_found : None
    if ( n < 1 ) :					      	if ( n < 1 ) return n ;					      if ( ( n < 1 ) || ( n > 2 ) ) return n ;			  
	return n					      	if ( n == 1 ) return 2 ;				      if ( ( n == 1 ) || ( n == 2 ) ) return 2 ;		  
    if ( n == 1 ) :					      	return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;    return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;  
	return 2					      }								    }								  
    return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) )  								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TRIANGULAR_NUMBERS					      TRIANGULAR_NUMBERS					    TRIANGULAR_NUMBERS						  TRIANGULAR_NUMBERS
--							      --							    --								  --
def isTriangular ( num ) :				      bool isTriangular ( int num ) {				    bool isTriangular ( int num ) {				  success : None
    if ( num < 0 ) :					      	if ( num < 0 ) return false ;				      if ( ( num < 0 ) || ( num > num ) ) return false ;	  
	return False					      	int sum = 0 ;						      int sum = 0 , n = 1 ;					  
    sum , n = 0 , 1					      	for ( int n = 1 ;					      while ( ( sum <= num ) && ( sum != num ) ) {		  
    while ( sum <= num ) :				      	sum <= num ;						    	sum = sum + n ;						  
	sum = sum + n					      	n ++ ) {						    	if ( ( sum == num ) || ( sum == 0 ) ) return true ;	  
	if ( sum == num ) :				      	  sum = sum + n ;					    	n ++ ;							  
	    return True					      	  if ( sum == num ) return true ;			      }								  
	n += 1						      	}							      return false ;						  
    return False					      	return false ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT
--							      --							    --								  --
def check ( st ) :					      int check ( string str ) {				    bool check ( string st ) {					  failure : #Results: 5, 10
    n = len ( st )					      	int n = str . length ( ) ;				      int n = st . length ( ) ;					  
    digitSum = 0					      	int digitSum = 0 ;					      int digitSum = 0 ;					  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	digitSum = digitSum + ( int ) ( st [ i ] )	      	i < n ;							      i != n ;							  
    return ( digitSum % 9 == 0 )			      	i ++ ) digitSum += ( str [ i ] - '0' ) ;		      i ++ ) digitSum = digitSum + ( int ) ( st [ i ] ) ;	  
							      	return ( digitSum % 9 == 0 ) ;				      return ( digitSum % 9 == 0 ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			      PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			    PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			  PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX
--							      --							    --								  --
def transpose ( A , B ) :				      void transpose ( int A [ ] [ N ] , int B [ ] [ N ] ) {	    void transpose ( const double * A , double * B [ N ] [ N ] )  script_not_found : None
    for i in range ( N ) :				      	int i , j ;						      for ( int i = 0 ;						  
	for j in range ( N ) :				      	for ( i = 0 ;						      i < N ;							  
	    B [ i ] [ j ] = A [ j ] [ i ]		      	i < N ;							      i ++ ) for ( int j = 0 ;					  
							      	i ++ ) for ( j = 0 ;					      j < N ;							  
							      	j < N ;							      j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ;			  
							      	j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ;			    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		      FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		    FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		  FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO
--							      --							    --								  --
def fib ( n ) :						      int fib ( int n ) {					    int fib ( int n ) {						  script_not_found : None
    if n < 6 :						      	if ( n < 6 ) return f [ n ] ;				      if ( n < 6 ) return f [ n ] ;				  
	return f [ n ]					      	int t = 5 , fn = 5 ;					      int t = 5 ;						  
    t = 5						      	while ( t < n ) {					      int fn = 5 ;						  
    fn = 5						      	  fn = round ( fn * PHI ) ;				      while ( t < n ) {						  
    while t < n :					      	  t ++ ;						    	fn = round ( fn * PHI ) ;				  
	fn = round ( fn * PHI )				      	}							    	t ++ ;							  
	t += 1						      	return fn ;						      }								  
    return fn						      }								      return fn ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW
--							      --							    --								  --
def isPowerOfTwo ( n ) :				      bool isPowerOfTwo ( int n ) {				    bool isPowerOfTwo ( int n ) {				  failure : #Results: 6, 10
    if ( n == 0 ) :					      	if ( n == 0 ) return 0 ;				      if ( ( n == 0 ) || ( n == 1 ) ) return false ;		  
	return False					      	while ( n != 1 ) {					      while ( ( n != 1 ) && ( n % 2 != 0 ) ) {			  
    while ( n != 1 ) :					      	  if ( n % 2 != 0 ) return 0 ;				    	if ( ( n % 2 != 0 ) || ( n % 2 != 1 ) ) return false ;	  
	if ( n % 2 != 0 ) :				      	  n = n / 2 ;						    	n = n / 2 ;						  
	    return False				      	}							      }								  
	n = n // 2					      	return 1 ;						      return true ;						  
    return True						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DIGITS_PRODUCT_TWO_NUMBERS			      NUMBER_DIGITS_PRODUCT_TWO_NUMBERS				    NUMBER_DIGITS_PRODUCT_TWO_NUMBERS				  NUMBER_DIGITS_PRODUCT_TWO_NUMBERS
--							      --							    --								  --
def countDigits ( a , b ) :				      int countDigits ( int a , int b ) {			    int countDigits ( int a , int b ) {				  failure : #Results: 0, 10
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    p = abs ( a * b )					      	int p = abs ( a * b ) ;					      int p = abs ( a * b ) ;					  
    if ( p == 0 ) :					      	if ( p == 0 ) return 1 ;				      if ( ( p == 0 ) || ( p > 10 ) ) return 1 ;		  
	return 1					      	while ( p > 0 ) {					      while ( ( p > 0 ) && ( p < 10 ) ) {			  
    while ( p > 0 ) :					      	  count ++ ;						    	count = count + 1 ;					  
	count = count + 1				      	  p = p / 10 ;						    	p = p / 10 ;						  
	p = p // 10					      	}							      }								  
    return count					      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY    FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY    FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY	  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY
--							      --							    --								  --
def findExtra ( arr1 , arr2 , n ) :			      int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) {	    int findExtra ( int * arr1 , int * arr2 , int n ) {		  failure : #Results: 9, 10
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( arr1 [ i ] != arr2 [ i ] ) :		      	i < n ;							      i != n ;							  
	    return i					      	i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ;	      ++ i ) if ( ( * arr1 ) != ( * arr2 ) ) return i ;		  
    return n						      	return n ;						      return n ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1
--							      --							    --								  --
def reverseStr ( str ) :				      void reverseStr ( string & str ) {			    void reverseStr ( string str ) {				  script_not_found : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . size ( ) ;					  
    i , j = 0 , n - 1					      	for ( int i = 0 , j = n - 1 ;				      int i = 0 , j = n - 1 ;					  
    while i < j :					      	i < j ;							      while ( i < j ) {						  
	str [ i ] , str [ j ] = str [ j ] , str [ i ]	      	i ++ , j -- ) swap ( str [ i ] , str [ j ] ) ;		    	str [ i ] = str [ j ] ;					  
	i += 1						      }								    	i ++ ;							  
	j -= 1						      								    	j -- ;							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			      C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			    C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			  C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE
--							      --							    --								  --
def rotate ( arr , n ) :				      void rotate ( int arr [ ] , int n ) {			    void rotate ( int arr [ ] , int n ) {			  script_not_found : None
    x = arr [ n - 1 ]					      	int x = arr [ n - 1 ] , i ;				      int x = arr [ n - 1 ] ;					  
    for i in range ( n - 1 , 0 , - 1 ) :		      	for ( i = n - 1 ;					      for ( int i = n - 1 ;					  
	arr [ i ] = arr [ i - 1 ]			      	i > 0 ;							      i > 0 ;							  
    arr [ 0 ] = x					      	i -- ) arr [ i ] = arr [ i - 1 ] ;			      i -- ) {							  
							      	arr [ 0 ] = x ;						    	arr [ i ] = arr [ i - 1 ] ;				  
							      }								      }								  
							      								      arr [ 0 ] = x ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARED_TRIANGULAR_NUMBER_SUM_CUBES			      SQUARED_TRIANGULAR_NUMBER_SUM_CUBES			    SQUARED_TRIANGULAR_NUMBER_SUM_CUBES				  SQUARED_TRIANGULAR_NUMBER_SUM_CUBES
--							      --							    --								  --
def findS ( s ) :					      int findS ( int s ) {					    int findS ( int s ) {					  success : None
    _sum = 0						      	int sum = 0 ;						      int _sum = 0 ;						  
    n = 1						      	for ( int n = 1 ;					      int n = 1 ;						  
    while ( _sum < s ) :				      	sum < s ;						      while ( ( _sum < s ) && ( _sum < s ) ) {			  
	_sum += n * n * n				      	n ++ ) {						    	_sum += n * n * n ;					  
	n += 1						      	  sum += n * n * n ;					    	n ++ ;							  
    n -= 1						      	  if ( sum == s ) return n ;				      }								  
    if _sum == s :					      	}							      n -- ;							  
	return n					      	return - 1 ;						      if ( _sum == s ) return n ;				  
    return - 1						      }								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT		  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT
--							      --							    --								  --
def isPowerOfFour ( n ) :				      public : bool isPowerOfFour ( int n ) {			    bool isPowerOfFour ( int n ) {				  script_not_found : None
    if ( n == 0 ) :					      	if ( n == 0 ) return 0 ;				      if ( ( n == 0 ) || ( n == 1 ) ) return false ;		  
	return False					      	while ( n != 1 ) {					      while ( ( n != 1 ) && ( n % 4 != 0 ) ) {			  
    while ( n != 1 ) :					      	  if ( n % 4 != 0 ) return 0 ;				    	if ( ( n % 4 != 0 ) || ( n % 4 != 1 ) ) return false ;	  
	if ( n % 4 != 0 ) :				      	  n = n / 4 ;						    	n = n / 4 ;						  
	    return False				      	}							      }								  
	n = n // 4					      	return 1 ;						      return true ;						  
    return True						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE		      NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE			    NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE			  NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE
--							      --							    --								  --
def answer_query ( a , n , l , r ) :			      int answer_query ( int a [ ] , int n , int l , int r ) {	    int answer_query ( int a [ ] , int n , int l , int r ) {	  failure : #Results: 9, 10
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( l , r ) :				      	for ( int i = l ;					      for ( int i = l ;						  
	if ( a [ i ] == a [ i + 1 ] ) :			      	i < r ;							      i < r ;							  
	    count += 1					      	i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ;	      i ++ ) {							  
    return count					      	return count ;						    	if ( ( a [ i ] == a [ i + 1 ] ) && ( a [ i ] == a [ i + 2 
							      }								    	  count ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		      RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		    RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		  RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS
--							      --							    --								  --
def findFrequency ( arr , n , left , right , element ) :      int findFrequency ( int arr [ ] , int n , int left , int righ int findFrequency ( int arr [ ] , int n , int left , int righ script_not_found : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( left - 1 , right ) :		      	for ( int i = left - 1 ;				      for ( int i = left - 1 ;					  
	if ( arr [ i ] == element ) :			      	i <= right ;						      i < right ;						  
	    count += 1					      	++ i ) if ( arr [ i ] == element ) ++ count ;		      i ++ ) {							  
    return count					      	return count ;						    	if ( ( arr [ i ] == element ) && ( arr [ i ] != 0 ) ) {	  
							      }								    	  count ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING		      QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING		    QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING			  QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING
--							      --							    --								  --
def query ( s , i , j ) :				      void query ( char s [ ] , int i , int j ) {		    void query ( string s , int i , int j ) {			  script_not_found : None
    n = len ( s )					      	int n = strlen ( s ) ;					      int n = s . size ( ) ;					  
    i %= n						      	i %= n ;						      i %= n ;							  
    j %= n						      	j %= n ;						      j %= n ;							  
    print ( "Yes" ) if s [ i ] == s [ j ] else print ( "No" ) 	( s [ i ] == s [ j ] ) ? ( cout << "Yes" << endl ) : ( cout   cout << "Yes" << s [ i ] == s [ j ] ? s [ i ] : s [ j ] ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1     SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1	    SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1	  SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1
--							      --							    --								  --
def smallest ( x , y , z ) :				      int smallest ( int x , int y , int z ) {			    int smallest ( int x , int y , int z ) {			  failure : #Results: 0, 10
    if ( not ( y / x ) ) :				      	if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ;	      if ( ( ! ( y / x ) ) && ( ! ( y / z ) ) ) return y ? ( y /  
	return y if ( not ( y / z ) ) else z		      	return ( ! ( x / z ) ) ? x : z ;			      return x ? ( x / z ) : z ;				  
    return x if ( not ( x / z ) ) else z		      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE     CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE	    CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE	  CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE
--							      --							    --								  --
def check ( degree , n ) :				      bool check ( int degree [ ] , int n ) {			    bool check ( vector < int > degree , int n ) {		  error : CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRE
    deg_sum = sum ( degree )				      	int deg_sum = 0 ;					      int deg_sum = sum ( degree ) ;				  SENT_GRAPH_TREE.cpp: In function ‘bool f_filled(st
    if ( 2 * ( n - 1 ) == deg_sum ) :			      	for ( int i = 0 ;					      if ( ( 2 * ( n - 1 ) ) == deg_sum ) return true ;		  d::vector<int>, int)’: CHECK_WHETHER_GIVEN_DEGREES
	return True					      	i < n ;							      else return false ;					  _VERTICES_REPRESENT_GRAPH_TREE.cpp:26:17: error: ‘
    else :						      	i ++ ) deg_sum += degree [ i ] ;			    }								  sum’ was not declared in this scope	 int deg_sum
	return False					      	return ( 2 * ( n - 1 ) == deg_sum ) ;			    								   = sum ( degree ) ;		       ^~~ CHECK_WHE
							      }								    								  THER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE.c
							      								    								  pp:26:17: note: suggested alternative: ‘fsub’	   i
							      								    								  nt deg_sum = sum ( degree ) ;			 ^~~
							      								    								  		    fsub CHECK_WHETHER_GIVEN_DEGREES
							      								    								  _VERTICES_REPRESENT_GRAPH_TREE.cpp: In function ‘i
							      								    								  nt main()’: CHECK_WHETHER_GIVEN_DEGREES_VERTICES_R
							      								    								  EPRESENT_GRAPH_TREE.cpp:48:21: error: could not co
							      								    								  nvert ‘&(& param0.std::vector<std::vector<int> >::
							      								    								  operator[](((std::vector<std::vector<int> >::size_
							      								    								  type)i)))->std::vector<int>::front()’ from ‘__gnu_
							      								    								  cxx::__alloc_traits<std::allocator<int>, int>::val
							      								    								  ue_type*’ {aka ‘int*’} to ‘std::vector<int>’
							      								    								      if(f_filled(&param0[i].front(),param1[i]) == f
							      								    								  _gold(&param0[i].front(),param1[i]))
							      								    								  	  ^~~~~~~~~~~~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_STRING_ROTATION_PALINDROME			      CHECK_GIVEN_STRING_ROTATION_PALINDROME			    CHECK_GIVEN_STRING_ROTATION_PALINDROME			  CHECK_GIVEN_STRING_ROTATION_PALINDROME
--							      --							    --								  --
def isPalindrome ( string ) :				      bool isPalindrome ( string str ) {			    bool isPalindrome ( string & string ) {			  success : None
    l = 0						      	int l = 0 ;						      int l = 0 ;						  
    h = len ( string ) - 1				      	int h = str . length ( ) - 1 ;				      int h = string . size ( ) - 1 ;				  
    while h > l :					      	while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return    while ( h > l ) {						  
	l += 1						      	return true ;						    	l ++ ;							  
	h -= 1						      }								    	h -- ;							  
	if string [ l - 1 ] != string [ h + 1 ] :	      								    	if ( string [ l - 1 ] != string [ h + 1 ] ) return false  
	    return False				      								      }								  
    return True						      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	      PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	    PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	  PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1
--							      --							    --								  --
def printSquares ( n ) :				      void printSquares ( int n ) {				    void printSquares ( int n ) {				  script_not_found : None
    square = 0						      	int square = 0 , odd = 1 ;				      int square = 0 ;						  
    odd = 1						      	for ( int x = 0 ;					      int odd = 1 ;						  
    for x in range ( 0 , n ) :				      	x < n ;							      for ( int x = 0 ;						  
	print ( square , end = " " )			      	x ++ ) {						      x <= n ;							  
	square = square + odd				      	  cout << square << " " ;				      x ++ ) {							  
	odd = odd + 2					      	  square = square + odd ;				    	cout << square << " " ;					  
							      	  odd = odd + 2 ;					    	square = square + odd ;					  
							      	}							    	odd = odd + 2 ;						  
							      }								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	      MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	    MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	  MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N
--							      --							    --								  --
def minSum ( n ) :					      int minSum ( int n ) {					    int minSum ( int n ) {					  failure : #Results: 0, 10
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    while ( n > 0 ) :					      	while ( n > 0 ) {					      while ( ( n > 0 ) && ( n % 10 == 0 ) ) {			  
	sum += ( n % 10 )				      	  sum += ( n % 10 ) ;					    	sum += ( n % 10 ) ;					  
	n //= 10					      	  n /= 10 ;						    	n /= 10 ;						  
    if ( sum == 1 ) :					      	}							      }								  
	return 10					      	if ( sum == 1 ) return 10 ;				      if ( ( sum == 1 ) || ( sum == 2 ) ) return 10 ;		  
    return sum						      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHANGE_BITS_CAN_MADE_ONE_FLIP_1				      CHANGE_BITS_CAN_MADE_ONE_FLIP_1				    CHANGE_BITS_CAN_MADE_ONE_FLIP_1				  CHANGE_BITS_CAN_MADE_ONE_FLIP_1
--							      --							    --								  --
def isOneFlip ( str ) :					      bool isOneFlip ( string str ) {				    bool isOneFlip ( string str ) {				  error : CHANGE_BITS_CAN_MADE_ONE_FLIP_1.cpp: In fu
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  nction ‘bool f_filled(std::__cxx11::string)’: CHAN
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  GE_BITS_CAN_MADE_ONE_FLIP_1.cpp:31:34: error: inva
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  lid conversion from ‘__gnu_cxx::__alloc_traits<std
	sum += int ( str [ i ] ) - int ( '0' )		      	i < n ;							      i != n ;							  ::allocator<char>, char>::value_type’ {aka ‘char’}
    return ( sum == n - 1 or sum == 1 )			      	i ++ ) sum += str [ i ] - '0' ;				      ++ i ) sum += atoi ( str [ i ] ) - atoi ( "0" ) ;		   to ‘const char*’ [-fpermissive]    ++ i ) sum +=
							      	return ( sum == n - 1 || sum == 1 ) ;			      return ( sum == n - 1 || sum == 1 ) ;			  atoi ( str [ i ] ) - atoi ( "0" ) ;
							      }								    }								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/cstdlib:75,		    from /us
							      								    								  r/include/c++/8/ext/string_conversions.h:41,
							      								    								  	      from /usr/include/c++/8/bits/basic_str
							      								    								  ing.h:6400,		       from /usr/include/c++
							      								    								  /8/string:52,			 from /usr/include/c
							      								    								  ++/8/bits/locale_classes.h:40,		  fr
							      								    								  om /usr/include/c++/8/bits/ios_base.h:41,
							      								    								  	   from /usr/include/c++/8/ios:42,
							      								    								  	  from /usr/include/c++/8/ostream:38,
							      								    								  	     from /usr/include/c++/8/iostream:39,
							      								    								  		 from CHANGE_BITS_CAN_MADE_ONE_FLIP_
							      								    								  1.cpp:8: /usr/include/stdlib.h:104:30: note:	 ini
							      								    								  tializing argument 1 of ‘int atoi(const char*)’  e
							      								    								  xtern int atoi (const char *__nptr)
							      								    								      ~~~~~~~~~~~~^~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS   EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS   EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS	  EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS
--							      --							    --								  --
def squareRootExists ( n , p ) :			      bool squareRootExists ( int n , int p ) {			    bool squareRootExists ( int n , int p ) {			  success : None
    n = n % p						      	n = n % p ;						      n = n % p ;						  
    for x in range ( 2 , p , 1 ) :			      	for ( int x = 2 ;					      for ( int x = 2 ;						  
	if ( ( x * x ) % p == n ) :			      	x < p ;							      x < p ;							  
	    return True					      	x ++ ) if ( ( x * x ) % p == n ) return true ;		      x += 1 ) {						  
    return False					      	return false ;						    	if ( ( ( x * x ) % p == n ) && ( ( x * x ) % p == n ) ) { 
							      }								    	  return true ;						  
							      								    	}							  
							      								      }								  
							      								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		      COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		    COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		  COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX
--							      --							    --								  --
def count ( n , x ) :					      int count ( int n , int x ) {				    public : int count ( int n , int x ) {			  script_not_found : None
    cnt = 0						      	int count = = 0 ;					      int cnt = 0 ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	if i <= x :					      	i <= n && i <= x ;					      i <= n ;							  
	    if x // i <= n and x % i == 0 :		      	i ++ ) {						      i ++ ) {							  
		cnt += 1				      	  if ( x / i <= n && x % i == 0 ) count ++ ;		    	if ( i <= x ) {						  
    return cnt						      	}							    	  if ( x / i <= n && x % i == 0 ) cnt ++ ;		  
							      	return count ;						    	}							  
							      }								      }								  
							      								      return cnt ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		      DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		    DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		  DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT
--							      --							    --								  --
def binomialCoeff ( n , k ) :				      int binomialCoeff ( int n , int k ) {			    int binomialCoeff ( int n , int k ) {			  script_not_found : None
    if k == 0 or k == n :				      	if ( k == 0 || k == n ) return 1 ;			      if ( k == 0 || k == n ) return 1 ;			  
	return 1					      	return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n    return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n  
    return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff (  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX		      SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX			    SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX			  SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX
--							      --							    --								  --
def swapDiagonal ( matrix ) :				      void swapDiagonal ( int matrix [ ] [ N ] ) {		    void swapDiagonal ( int matrix [ N ] [ N ] ) {		  script_not_found : None
    for i in range ( N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = \   	i < N ;							      i < N ;							  
	    matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ]   	i ++ ) swap ( matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1   i ++ ) {							  
							      }								    	matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] =	  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ARC_LENGTH_ANGLE					      ARC_LENGTH_ANGLE						    ARC_LENGTH_ANGLE						  ARC_LENGTH_ANGLE
--							      --							    --								  --
def arcLength ( diameter , angle ) :			      double arcLength ( double diameter , double angle ) {	    double arcLength ( double diameter , double angle ) {	  script_not_found : None
    if angle >= 360 :					      	double pi = 22.0 / 7.0 ;				      if ( angle >= 360 ) {					  
	print ( "Angle cannot be formed" )		      	double arc ;						    	cout << "Angle cannot be formed" << endl ;		  
	return 0					      	if ( angle >= 360 ) {					    	return 0 ;						  
    else :						      	  cout << "Angle cannot" , " be formed" ;		      }								  
	arc = ( 3.142857142857143 * diameter ) * ( angle / 36 	  return 0 ;						      else {							  
	return arc					      	}							    	double arc = ( 3.142857142857143 * diameter ) * ( angle / 
							      	else {							    	return arc ;						  
							      	  arc = ( pi * diameter ) * ( angle / 360.0 ) ;		      }								  
							      	  return arc ;						    }								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM	      RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM		    RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM		  RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM
--							      --							    --								  --
def breakSum ( n ) :					      int breakSum ( int n ) {					    int breakSum ( int n ) {					  timeout : None
    if ( n == 0 or n == 1 ) :				      	if ( n == 0 || n == 1 ) return n ;			      if ( ( n == 0 || n == 1 ) && ( n == 2 || n == 3 ) ) return  
	return n					      	return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + br   return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + br 
    return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 )  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_9_USING_BITWISE_OPERATORS			      DIVISIBILITY_9_USING_BITWISE_OPERATORS			    DIVISIBILITY_9_USING_BITWISE_OPERATORS			  DIVISIBILITY_9_USING_BITWISE_OPERATORS
--							      --							    --								  --
def isDivBy9 ( n ) :					      bool isDivBy9 ( int n ) {					    bool isDivBy9 ( int n ) {					  failure : #Results: 8, 10
    if ( n == 0 or n == 9 ) :				      	if ( n == 0 || n == 9 ) return true ;			      if ( ( n == 0 || n == 9 ) && ( n & 7 ) ) return true ;	  
	return True					      	if ( n < 9 ) return false ;				      if ( ( n < 9 ) || ( n > 9 ) ) return false ;		  
    if ( n < 9 ) :					      	return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )    return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )  
	return False					      }								    }								  
    return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 )  								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_DIVISIBILITY_BINARY_STRING_2K			      CHECK_DIVISIBILITY_BINARY_STRING_2K			    CHECK_DIVISIBILITY_BINARY_STRING_2K				  CHECK_DIVISIBILITY_BINARY_STRING_2K
--							      --							    --								  --
def isDivisible ( str , k ) :				      bool isDivisible ( char str [ ] , int k ) {		    bool isDivisible ( string str , int k ) {			  error : /bin/bash: line 1: 2965374 Aborted
    n = len ( str )					      	int n = strlen ( str ) ;				      int n = str . size ( ) ;					  	   (core dumped) ./CHECK_DIVISIBILITY_BINARY
    c = 0						      	int c = 0 ;						      int c = 0 ;						  _STRING_2K_cpp
    for i in range ( 0 , k ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( str [ n - i - 1 ] == '0' ) :		      	i < k ;							      i <= k ;							  
	    c += 1					      	i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ;		      i ++ ) {							  
    return ( c == k )					      	return ( c == k ) ;					    	if ( ( str [ n - i - 1 ] == '0' ) && ( str [ n - i - 1 ]  
							      }								      }								  
							      								      return ( c == k ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2   SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2   SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2	  SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2
--							      --							    --								  --
def findSum ( n ) :					      int findSum ( int n ) {					    int findSum ( int n ) {					  success : None
    n -= 1						      	n -- ;							      n -- ;							  
    sum = 0						      	int sum = 0 ;						      double sum = 0 ;						  
    sum += ( n * ( n + 1 ) ) / 2			      	sum += ( n * ( n + 1 ) ) / 2 ;				      sum += ( n * ( n + 1 ) ) / 2 ;				  
    sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6	      	sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;		      sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;		  
    return int ( sum )					      	return sum ;						      return ( int ) sum ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2		      N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2			    N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2			  N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2
--							      --							    --								  --
def findNth ( n ) :					      int findNth ( int n ) {					    int findNth ( int n ) {					  success : identical to gold
    nthElement = 19 + ( n - 1 ) * 9			      	int nthElement = 19 + ( n - 1 ) * 9 ;			      int nthElement = 19 + ( n - 1 ) * 9 ;			  
    outliersCount = int ( math.log10 ( nthElement ) ) - 1     	int outliersCount = ( int ) log10 ( nthElement ) - 1 ;	      int outliersCount = ( int ) log10 ( nthElement ) - 1 ;	  
    nthElement += 9 * outliersCount			      	nthElement += 9 * outliersCount ;			      nthElement += 9 * outliersCount ;				  
    return nthElement					      	return nthElement ;					      return nthElement ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION_2			      PROGRAM_DECIMAL_BINARY_CONVERSION_2			    PROGRAM_DECIMAL_BINARY_CONVERSION_2				  PROGRAM_DECIMAL_BINARY_CONVERSION_2
--							      --							    --								  --
def decimalToBinary ( N ) :				      unsigned long long int int decimalToBinary ( int N ) {	    int decimalToBinary ( int N ) {				  script_not_found : None
    B_Number = 0					      	ull B_Number = 0 ;					      int B_Number = 0 ;					  
    cnt = 0						      	int cnt = 0 ;						      int cnt = 0 ;						  
    while ( N != 0 ) :					      	while ( N != 0 ) {					      while ( ( N != 0 ) && ( N != 1 ) ) {			  
	rem = N % 2					      	  int rem = N % 2 ;					    	int rem = N % 2 ;					  
	c = pow ( 10 , cnt )				      	  ull c = pow ( 10 , cnt ) ;				    	int c = pow ( 10 , cnt ) ;				  
	B_Number += rem * c				      	  B_Number += rem * c ;					    	B_Number += rem * c ;					  
	N //= 2						      	  N /= 2 ;						    	N /= 2 ;						  
	cnt += 1					      	  cnt ++ ;						    	cnt ++ ;						  
    return B_Number					      	}							      }								  
							      	return B_Number ;					      return B_Number ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1
--							      --							    --								  --
def first ( str , i ) :					      char first ( string str , int i = 0 ) {			    int first ( char * str , int i ) {				  error : FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATI
    if ( str [ i ] == '\0' ) :				      	if ( str [ i ] == '\0' ) return 0 ;			      if ( ( str [ i ] = '\0' ) == '\0' ) return 0 ;		  VE_AND_RECURSIVE_1.cpp: In function ‘int main()’:
	return 0					      	if ( isupper ( str [ i ] ) ) return str [ i ] ;		      if ( ( str [ i ] = '\0' ) == '\0' ) return i ;		  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_R
    if ( str [ i ].isupper ( ) ) :			      	return first ( str , i + 1 ) ;				      return first ( str , i + 1 ) ;				  ECURSIVE_1.cpp:36:40: error: cannot convert ‘__gnu
	return str [ i ]				      }								    }								  _cxx::__alloc_traits<std::allocator<std::__cxx11::
    return first ( str , i + 1 )			      								    								  basic_string<char> >, std::__cxx11::basic_string<c
							      								    								  har> >::value_type’ {aka ‘std::__cxx11::basic_stri
							      								    								  ng<char>’} to ‘char*’		 if(f_filled(param0[
							      								    								  i],param1[i]) == f_gold(param0[i],param1[i]))
							      								    								  				      ^ FIRST_UPPERC
							      								    								  ASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1.c
							      								    								  pp:23:23: note:   initializing argument 1 of ‘int
							      								    								  f_filled(char*, int)’	 int f_filled ( char * str ,
							      								    								   int i ) {		     ~~~~~~~^~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA
--							      --							    --								  --
def lexSmallest ( a , n ) :				      string lexSmallest ( string a [ ] , int n ) {		    string lexSmallest ( string a , int n ) {			  script_not_found : None
    a.sort ( reverse = True )				      	sort ( a , a + n , compare ) ;				      sort ( a . begin ( ) , a . end ( ) ) ;			  
    answer = ""						      	string answer = "" ;					      string answer = "" ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	answer += a [ i ]				      	i < n ;							      i < n ;							  
    return answer					      	i ++ ) answer += a [ i ] ;				      i ++ ) {							  
							      	return answer ;						    	answer += a [ i ] ;					  
							      }								      }								  
							      								      return answer ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1     GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1	    GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1	  GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1
--							      --							    --								  --
def countSubStr ( st , n ) :				      int countSubStr ( char str [ ] ) {			    int countSubStr ( string st , int n ) {			  script_not_found : None
    m = 0						      	int m = 0 ;						      int m = 0 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( st [ i ] == '1' ) :			      	str [ i ] != '\0' ;					      i <= n ;							  
	    m = m + 1					      	i ++ ) {						      i ++ ) if ( ( st [ i ] == '1' ) || ( st [ i ] == '2' ) ) m  
    return m * ( m - 1 ) // 2				      	  if ( str [ i ] == '1' ) m ++ ;			      return m * ( m - 1 ) / 2 ;				  
							      	}							    }								  
							      	return m * ( m - 1 ) / 2 ;				    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		      PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		    PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		  PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11
--							      --							    --								  --
def remainder ( st ) :					      int remainder ( string str ) {				    int remainder ( string st ) {				  failure : #Results: 6, 10
    ln = len ( st )					      	int len = str . length ( ) ;				      int ln = st . length ( ) ;				  
    rem = 0						      	int num , rem = 0 ;					      int rem = 0 ;						  
    for i in range ( 0 , ln ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	num = rem * 10 + ( int ) ( st [ i ] )		      	i < len ;						      i != ln ;							  
	rem = num % 11					      	i ++ ) {						      ++ i ) {							  
    return rem						      	  num = rem * 10 + ( str [ i ] - '0' ) ;		    	int num = rem * 10 + ( int ) ( st [ i ] ) ;		  
							      	  rem = num % 11 ;					    	rem = num % 11 ;					  
							      	}							      }								  
							      	return rem ;						      return rem ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_ROTATIONS_REQUIRED_GET_STRING			      MINIMUM_ROTATIONS_REQUIRED_GET_STRING			    MINIMUM_ROTATIONS_REQUIRED_GET_STRING			  MINIMUM_ROTATIONS_REQUIRED_GET_STRING
--							      --							    --								  --
def findRotations ( str ) :				      int findRotations ( string str ) {			    int findRotations ( string str ) {				  failure : #Results: 9, 10
    tmp = str + str					      	string tmp = str + str ;				      string tmp = str + str ;					  
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	substring = tmp [ i : n ]			      	i <= n ;						      i <= n ;							  
	if ( str == substring ) :			      	i ++ ) {						      i ++ ) {							  
	    return i					      	  string substring = tmp . substr ( i , str . size ( ) ) ;  	string substring = tmp . substr ( i , n - i ) ;		  
    return n						      	  if ( str == substring ) return i ;			    	if ( ( str == substring ) || ( str == substring ) ) retur 
							      	}							      }								  
							      	return n ;						      return n ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHUFFLE_A_GIVEN_ARRAY					      SHUFFLE_A_GIVEN_ARRAY					    SHUFFLE_A_GIVEN_ARRAY					  SHUFFLE_A_GIVEN_ARRAY
--							      --							    --								  --
def randomize ( arr , n ) :				      void randomize ( int arr [ ] , int n ) {			    template < typename T > void randomize ( T * arr , int n ) {  script_not_found : None
    for i in range ( n - 1 , 0 , - 1 ) :		      	srand ( time ( NULL ) ) ;				      for ( int i = n - 1 ;					  
	j = random.randint ( 0 , i + 1 )		      	for ( int i = n - 1 ;					      i > 0 ;							  
	arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]	      	i > 0 ;							      -- i ) {							  
    return arr						      	i -- ) {						    	int j = rand ( ) % ( i + 1 ) ;				  
							      	  int j = rand ( ) % ( i + 1 ) ;			    	arr [ i ] = arr [ j ] ;					  
							      	  swap ( & arr [ i ] , & arr [ j ] ) ;			    	arr [ j ] = arr [ i ] ;					  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			      PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			    PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			  PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS
--							      --							    --								  --
def gcd ( a , b ) :					      double gcd ( double a , double b ) {			    template < typename T > T gcd ( T a , T b ) {		  script_not_found : None
    if ( a < b ) :					      	if ( a < b ) return gcd ( b , a ) ;			      if ( ( a < b ) && ( b > a ) ) return gcd ( b , a ) ;	  
	return gcd ( b , a )				      	if ( fabs ( b ) < 0.001 ) return a ;			      if ( ( fabs ( b ) < 0.001 ) && ( fabs ( a ) < 0.001 ) ) ret 
    if ( abs ( b ) < 0.001 ) :				      	else return ( gcd ( b , a - floor ( a / b ) * b ) ) ;	      else return ( gcd ( b , a - floor ( a / b ) * b ) ) ;	  
	return a					      }								    }								  
    else :						      								    								  
	return ( gcd ( b , a - math.floor ( a / b ) * b ) )   								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	      TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	    TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	  TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1
--							      --							    --								  --
def countNonDecreasing ( n ) :				      long long int countNonDecreasing ( int n ) {		    int countNonDecreasing ( int n ) {				  failure : #Results: 2, 10
    N = 10						      	int N = 10 ;						      const int N = 10 ;					  
    count = 1						      	long long count = 1 ;					      int count = 1 ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	count = int ( count * ( N + i - 1 ) )		      	i <= n ;						      i <= n ;							  
	count = int ( count / i )			      	i ++ ) {						      ++ i ) {							  
    return count					      	  count *= ( N + i - 1 ) ;				    	count = ( int ) ( count * ( N + i - 1 ) ) ;		  
							      	  count /= i ;						    	count = ( int ) ( count / i ) ;				  
							      	}							      }								  
							      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	      NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	    NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	  NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES
--							      --							    --								  --
def countRect ( n ) :					      int countRect ( int n ) {					    public : int countRect ( int n ) {				  error : NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UN
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  IT_SQUARES.cpp:27:1: error: expected unqualified-i
    for length in range ( 1 , int ( math.sqrt ( n ) ) + 1 ) : 	for ( int length = 1 ;					      for ( int length = 1 ;					  d before ‘public’  public : int f_filled ( int n )
	height = length					      	length <= sqrt ( n ) ;					      length <= ( int ) sqrt ( n ) ;				   {  ^~~~~~ NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N
	while ( height * length <= n ) :		      	++ length ) for ( int height = length ;			      length ++ ) {						  _UNIT_SQUARES.cpp: In function ‘int main()’: NUMBE
	    ans += 1					      	height * length <= n ;					    	int height = length ;					  R_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES.cp
	    height += 1					      	++ height ) ans ++ ;					    	while ( ( height * length <= n ) && ( height * length <=  p:47:12: error: ‘f_filled’ was not declared in thi
    return ans						      	return ans ;						    	  ans ++ ;						  s scope	   if(f_filled(param0[i]) == f_gold(
							      }								    	  height ++ ;						  param0[i]))		  ^~~~~~~~ NUMBER_UNIQUE_REC
							      								    	}							  TANGLES_FORMED_USING_N_UNIT_SQUARES.cpp:47:12: not
							      								      }								  e: suggested alternative: ‘f_gold’	      if(f_f
							      								      return ans ;						  illed(param0[i]) == f_gold(param0[i]))
							      								    }								   ^~~~~~~~		f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHANGE_BITS_CAN_MADE_ONE_FLIP				      CHANGE_BITS_CAN_MADE_ONE_FLIP				    CHANGE_BITS_CAN_MADE_ONE_FLIP				  CHANGE_BITS_CAN_MADE_ONE_FLIP
--							      --							    --								  --
def canMakeAllSame ( str ) :				      bool canMakeAllSame ( string str ) {			    bool canMakeAllSame ( string str ) {			  failure : #Results: 8, 10
    zeros = 0						      	int zeros = 0 , ones = 0 ;				      int zeros = 0 ;						  
    ones = 0						      	for ( char ch : str ) ( ch == '0' ) ? ++ zeros : ++ ones ;    int ones = 0 ;						  
    for i in range ( 0 , len ( str ) ) :		      	return ( zeros == 1 || ones == 1 ) ;			      for ( int i = 0 ;						  
	ch = str [ i ]					      }								      i != str . length ( ) ;					  
	if ( ch == '0' ) :				      								      i ++ ) {							  
	    zeros = zeros + 1				      								    	char ch = str [ i ] ;					  
	else :						      								    	if ( ( ch == '0' ) || ( ch == '1' ) ) zeros = zeros + 1 ; 
	    ones = ones + 1				      								    	else ones = ones + 1 ;					  
    return ( zeros == 1 or ones == 1 )			      								      }								  
							      								      return ( zeros == 1 || ones == 1 ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_1				      DYNAMIC_PROGRAMMING_SET_1					    DYNAMIC_PROGRAMMING_SET_1					  DYNAMIC_PROGRAMMING_SET_1
--							      --							    --								  --
def fib ( n , lookup ) :				      int fib ( int n ) {					    int fib ( int n , int lookup [ ] ) {			  script_not_found : None
    if n == 0 or n == 1 :				      	if ( lookup [ n ] == NIL ) {				      if ( n == 0 || n == 1 ) lookup [ n ] = n ;		  
	lookup [ n ] = n				      	  if ( n <= 1 ) lookup [ n ] = n ;			      if ( lookup [ n ] == 0 ) lookup [ n ] = fib ( n - 1 , looku 
    if lookup [ n ] is None :				      	  else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ;	      return lookup [ n ] ;					  
	lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , 	}							    }								  
    return lookup [ n ]					      	return lookup [ n ] ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE	      SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE		    SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE		  SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE
--							      --							    --								  --
def selectRandom ( x ) :				      int selectRandom ( int x ) {				    int selectRandom ( int x ) {				  script_not_found : None
    res = 0						      	static int res ;					      int res = 0 ;						  
    count = 0						      	static int count = 0 ;					      int count = 0 ;						  
    count += 1						      	count ++ ;						      count ++ ;						  
    if ( count == 1 ) :					      	if ( count == 1 ) res = x ;				      if ( ( count == 1 ) || ( count == 2 ) ) {			  
	res = x						      	else {							    	res = x ;						  
    else :						      	  int i = rand ( ) % count ;				      }								  
	i = random.randrange ( count )			      	  if ( i == count - 1 ) res = x ;			      else {							  
	if ( i == count - 1 ) :				      	}							    	int i = rand ( ) % count ;				  
	    res = x					      	return res ;						    	if ( ( i == count - 1 ) || ( i == count - 2 ) ) {	  
    return res						      }								    	  res = x ;						  
							      								    	}							  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			      PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			    PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			  PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2
--							      --							    --								  --
def transpose ( A ) :					      void transpose ( int A [ ] [ N ] ) {			    void transpose ( int A [ N ] [ N ] ) {			  script_not_found : None
    for i in range ( N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , N ) :			      	i < N ;							      i < N ;							  
	    A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A 	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
							      	j < N ;							      j < N ;							  
							      	j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ;		      j ++ ) A [ i ] [ j ] = A [ j ] [ i ] ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING	      PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING	    PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING		  PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING
--							      --							    --								  --
def printSquares ( n ) :				      void printSquares ( int n ) {				    void printSquares ( int n ) {				  script_not_found : None
    square = 0 ; prev_x = 0 ;				      	int square = 0 , prev_x = 0 ;				      int square = 0 ;						  
    for x in range ( 0 , n ) :				      	for ( int x = 0 ;					      int prev_x = 0 ;						  
	square = ( square + x + prev_x )		      	x < n ;							      ;								  
	print ( square , end = " " )			      	x ++ ) {						      for ( int x = 0 ;						  
	prev_x = x					      	  square = ( square + x + prev_x ) ;			      x <= n ;							  
							      	  cout << square << " " ;				      x ++ ) {							  
							      	  prev_x = x ;						    	square = ( square + x + prev_x ) ;			  
							      	}							    	cout << square << " " ;					  
							      }								    	prev_x = x ;						  
							      								      }								  
							      								      ;								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	      FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	    FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	  FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X
--							      --							    --								  --
def firstFactorialDivisibleNumber ( x ) :		      int firstFactorialDivisibleNumber ( int x ) {		    int firstFactorialDivisibleNumber ( int x ) {		  failure : #Results: 0, 10
    i = 1						      	int i = 1 ;						      int i ;							  
    fact = 1						      	int fact = 1 ;						      int fact = 1 ;						  
    for i in range ( 1 , x ) :				      	for ( i = 1 ;						      for ( i = 1 ;						  
	fact = fact * i					      	i < x ;							      i <= x ;							  
	if ( fact % x == 0 ) :				      	i ++ ) {						      i ++ ) {							  
	    break					      	  fact = fact * i ;					    	fact = fact * i ;					  
    return i						      	  if ( fact % x == 0 ) break ;				    	if ( ( fact % x == 0 ) && ( i % x == 0 ) ) break ;	  
							      	}							      }								  
							      	return i ;						      return i ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTING_INVERSIONS					      COUNTING_INVERSIONS					    COUNTING_INVERSIONS						  COUNTING_INVERSIONS
--							      --							    --								  --
def getInvCount ( arr , n ) :				      int getInvCount ( int arr [ ] , int n ) {			    int getInvCount ( int arr [ ] , int n ) {			  script_not_found : None
    inv_count = 0					      	int inv_count = 0 ;					      int inv_count = 0 ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n - 1 ;						      i < n ;							  
	    if ( arr [ i ] > arr [ j ] ) :		      	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
		inv_count += 1				      	j < n ;							    	for ( int j = i + 1 ;					  
    return inv_count					      	j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ;	    	j < n ;							  
							      	return inv_count ;					    	j ++ ) {						  
							      }								    	  if ( ( arr [ i ] > arr [ j ] ) && ( arr [ i ] < arr [ j 
							      								    	    inv_count ++ ;					  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return inv_count ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			      COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			    COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			  COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY
--							      --							    --								  --
def countPairs ( arr , n ) :				      int countPairs ( int arr [ ] , int n ) {			    public : int countPairs ( int arr [ ] , int n ) {		  error : COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY.cpp
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  :27:1: error: expected unqualified-id before ‘publ
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  ic’  public : int f_filled ( int arr [ ] , int n )
	for j in range ( i + 1 , n ) :			      	i < n ;							      i <= n ;							   {  ^~~~~~ COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY.
	    if ( arr [ i ] == arr [ j ] ) :		      	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  cpp: In function ‘int main()’: COUNT_INDEX_PAIRS_E
		ans += 1				      	j < n ;							    	for ( int j = i + 1 ;					  QUAL_ELEMENTS_ARRAY.cpp:50:12: error: ‘f_filled’ w
    return ans						      	j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ;		    	j <= n ;						  as not declared in this scope		 if(f_filled
							      	return ans ;						    	j ++ ) {						  (&param0[i].front(),param1[i]) == f_gold(&param0[i
							      }								    	  if ( ( arr [ i ] == arr [ j ] ) && ( arr [ i ] != arr [ ].front(),param1[i]))		    ^~~~~~~~ COUNT_I
							      								    	    ans ++ ;						  NDEX_PAIRS_EQUAL_ELEMENTS_ARRAY.cpp:50:12: note: s
							      								    	  }							  uggested alternative: ‘f_gold’	  if(f_fille
							      								    	}							  d(&param0[i].front(),param1[i]) == f_gold(&param0[
							      								      }								  i].front(),param1[i]))	     ^~~~~~~~
							      								      return ans ;						  	f_gold
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2
--							      --							    --								  --
def recursiveReverse ( str , i = 0 ) :			      void recursiveReverse ( string & str , int i = 0 ) {	    void recursiveReverse ( string str , int i ) {		  script_not_found : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . size ( ) ;					  
    if i == n // 2 :					      	if ( i == n / 2 ) return ;				      if ( i == n / 2 ) return ;				  
	return						      	swap ( str [ i ] , str [ n - i - 1 ] ) ;		      str [ i ] = str [ n - i - 1 ] ;				  
    str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ 	recursiveReverse ( str , i + 1 ) ;			      str [ n - i - 1 ] = str [ i ] ;				  
    recursiveReverse ( str , i + 1 )			      }								      recursiveReverse ( str , i + 1 ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE	      QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE		    QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE		  QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE
--							      --							    --								  --
def countInRange ( arr , n , x , y ) :			      int countInRange ( int arr [ ] , int n , int x , int y ) {    int countInRange ( int arr [ ] , int n , int x , int y ) {	  success : None
    count = 0 ;						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      ;								  
	if ( arr [ i ] >= x and arr [ i ] <= y ) :	      	i < n ;							      for ( int i = 0 ;						  
	    count += 1					      	i ++ ) {						      i < n ;							  
    return count					      	  if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ;	      i ++ ) {							  
							      	}							    	if ( ( arr [ i ] >= x && arr [ i ] <= y ) || ( arr [ i ]  
							      	return count ;						    	  count ++ ;						  
							      }								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_INTEGER_OVERFLOW_MULTIPLICATION			      CHECK_INTEGER_OVERFLOW_MULTIPLICATION			    CHECK_INTEGER_OVERFLOW_MULTIPLICATION			  CHECK_INTEGER_OVERFLOW_MULTIPLICATION
--							      --							    --								  --
def isOverflow ( a , b ) :				      bool isOverflow ( long long a , long long b ) {		    bool isOverflow ( int64_t a , int64_t b ) {			  failure : #Results: 2, 10
    if ( a == 0 or b == 0 ) :				      	if ( a == 0 || b == 0 ) return false ;			      if ( ( a == 0 || b == 0 ) && ( a >= - 9223372036854775808 | 
	return False					      	long long result = a * b ;				      int64_t result = a * b ;					  
    result = a * b					      	if ( a == result / b ) return false ;			      if ( ( result >= 9223372036854775807 || result <= - 9223372 
    if ( result >= 9223372036854775807 or result <= - 9223372 	else return true ;					    	std :: cout << result / b << std :: endl ;		  
	result = 0					      }								    	return false ;						  
    if ( a == ( result // b ) ) :			      								      }								  
	print ( result // b )				      								      else return true ;					  
	return False					      								    }								  
    else :						      								    								  
	return True					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON
--							      --							    --								  --
def checkcircle ( r , R , r1 , x1 , y1 ) :		      bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) success : None
    dis = int ( math.sqrt ( x1 * x1 + y1 * y1 ) )	      	int dis = sqrt ( x1 * x1 + y1 * y1 ) ;			      int dis = ( int ) sqrt ( x1 * x1 + y1 * y1 ) ;		  
    return ( dis - r1 >= R and dis + r1 <= r )		      	return ( dis - r1 >= R && dis + r1 <= r ) ;		      return ( dis - r1 >= R && dis + r1 <= r ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_OCTAL_DECIMAL_CONVERSION			      PROGRAM_OCTAL_DECIMAL_CONVERSION				    PROGRAM_OCTAL_DECIMAL_CONVERSION				  PROGRAM_OCTAL_DECIMAL_CONVERSION
--							      --							    --								  --
def octalToDecimal ( n ) :				      int octalToDecimal ( int n ) {				    int octalToDecimal ( int n ) {				  success : None
    num = n						      	int num = n ;						      int num = n ;						  
    dec_value = 0					      	int dec_value = 0 ;					      int decValue = 0 ;					  
    base = 1						      	int base = 1 ;						      int base = 1 ;						  
    temp = num						      	int temp = num ;					      int temp = num ;						  
    while ( temp ) :					      	while ( temp ) {					      while ( ( temp ) ) {					  
	last_digit = temp % 10				      	  int last_digit = temp % 10 ;				    	int lastDigit = temp % 10 ;				  
	temp = int ( temp / 10 )			      	  temp = temp / 10 ;					    	temp = ( int ) ( temp / 10 ) ;				  
	dec_value += last_digit * base			      	  dec_value += last_digit * base ;			    	decValue += lastDigit * base ;				  
	base = base * 8					      	  base = base * 8 ;					    	base = base * 8 ;					  
    return dec_value					      	}							      }								  
							      	return dec_value ;					      return decValue ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC		      PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC			    PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC			  PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC
--							      --							    --								  --
def isSymmetric ( mat , N ) :				      bool isSymmetric ( int mat [ ] [ MAX ] , int N ) {	    bool isSymmetric ( int * * mat , int N ) {			  script_not_found : None
    for i in range ( N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( N ) :				      	i < N ;							      i < N ;							  
	    if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) :	      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		return False				      	j < N ;							    	for ( int j = 0 ;					  
    return True						      	j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return fal 	j < N ;							  
							      	return true ;						    	j ++ ) {						  
							      }								    	  if ( ( mat [ i ] [ j ] != mat [ j ] [ i ] ) && ( mat [  
							      								    	    return false ;					  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHUFFLE_A_DECK_OF_CARDS_3				      SHUFFLE_A_DECK_OF_CARDS_3					    SHUFFLE_A_DECK_OF_CARDS_3					  SHUFFLE_A_DECK_OF_CARDS_3
--							      --							    --								  --
def shuffle ( card , n ) :				      void shuffle ( int card [ ] , int n ) {			    void shuffle ( int card [ ] , int n ) {			  script_not_found : None
    for i in range ( n ) :				      	srand ( time ( 0 ) ) ;					      for ( int i = 0 ;						  
	r = i + ( random.randint ( 0 , 55 ) % ( 52 - i ) )    	for ( int i = 0 ;					      i < n ;							  
	tmp = card [ i ]				      	i < n ;							      i ++ ) {							  
	card [ i ] = card [ r ]				      	i ++ ) {						    	int r = i + ( rand ( ) % 55 ) % ( 52 - i ) ;		  
	card [ r ] = tmp				      	  int r = i + ( rand ( ) % ( 52 - i ) ) ;		    	int tmp = card [ i ] ;					  
							      	  swap ( card [ i ] , card [ r ] ) ;			    	card [ i ] = card [ r ] ;				  
							      	}							    	card [ r ] = tmp ;					  
							      }								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		      MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		    MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		  MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET
--							      --							    --								  --
def minRevolutions ( r , x1 , y1 , x2 , y2 ) :		      int minRevolutions ( double r , int x1 , int y1 , int x2 , in double minRevolutions ( int r , double x1 , double y1 , doubl script_not_found : None
    d = math.sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * 	double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) *   double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * 
    return math.ceil ( d // ( 2 * r ) )			      	return ceil ( d / ( 2 * r ) ) ;				      return ceil ( d / ( 2 * r ) ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	      ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	    ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	  ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX
--							      --							    --								  --
def countCommon ( mat , n ) :				      int countCommon ( int mat [ ] [ MAX ] , int n ) {		    int countCommon ( int * * mat , int n ) {			  script_not_found : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] :	      	i < n ;							      i < n ;							  
	    res = res + 1				      	i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) re   i ++ ) {							  
    return res						      	return res ;						    	if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) {	  
							      }								    	  res = res + 1 ;					  
							      								    	}							  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_PROGRAM_PRIME_NUMBER				      RECURSIVE_PROGRAM_PRIME_NUMBER				    RECURSIVE_PROGRAM_PRIME_NUMBER				  RECURSIVE_PROGRAM_PRIME_NUMBER
--							      --							    --								  --
def isPrime ( n , i = 2 ) :				      bool isPrime ( int n , int i = 2 ) {			    bool isPrime ( int n , int i = 2 ) {			  failure : #Results: 4, 10
    if ( n <= 2 ) :					      	if ( n <= 2 ) return ( n == 2 ) ? true : false ;	      if ( ( n <= 2 ) || ( n == 2 ) ) return true ? ( n == 2 ) :  
	return True if ( n == 2 ) else False		      	if ( n % i == 0 ) return false ;			      if ( ( n % i == 0 ) || ( n % i == 1 ) ) return false ;	  
    if ( n % i == 0 ) :					      	if ( i * i > n ) return true ;				      if ( ( i * i > n ) && ( i * i > n ) ) return true ;	  
	return False					      	return isPrime ( n , i + 1 ) ;				      return isPrime ( n , i + 1 ) ;				  
    if ( i * i > n ) :					      }								    }								  
	return true					      								    								  
    return isPrime ( n , i + 1 )			      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1   DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1   DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1	  DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1
--							      --							    --								  --
def maxProd ( n ) :					      int maxProd ( int n ) {					    int maxProd ( int n ) {					  failure : #Results: 9, 10
    if ( n == 2 or n == 3 ) :				      	if ( n == 2 || n == 3 ) return ( n - 1 ) ;		      if ( ( n == 2 || n == 3 ) && ( n > 4 ) ) return ( n - 1 ) ; 
	return ( n - 1 )				      	int res = 1 ;						      int res = 1 ;						  
    res = 1						      	while ( n > 4 ) {					      while ( ( n > 4 ) && ( n > 3 ) ) {			  
    while ( n > 4 ) :					      	  n -= 3 ;						    	n -= 3 ;						  
	n -= 3						      	  res *= 3 ;						    	res *= 3 ;						  
	res *= 3					      	}							      }								  
    return ( n * res )					      	return ( n * res ) ;					      return ( n * res ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			      MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			    MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			  MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS
--							      --							    --								  --
def minTime ( arr , n , m ) :				      int minTime ( int arr [ ] , int n , int m ) {		    int minTime ( int arr [ ] , int n , int m ) {		  script_not_found : None
    t = 0						      	int t = 0 ;						      int t = 0 ;						  
    while ( 1 ) :					      	while ( 1 ) {						      while ( ( 1 ) ) {						  
	items = 0					      	  int items = 0 ;					    	int items = 0 ;						  
	for i in range ( n ) :				      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
	    items += ( t // arr [ i ] )			      	  i < n ;						    	i < n ;							  
	if ( items >= m ) :				      	  i ++ ) items += ( t / arr [ i ] ) ;			    	i ++ ) {						  
	    return t					      	  if ( items >= m ) return t ;				    	  items += ( t / arr [ i ] ) ;				  
	t += 1						      	  t ++ ;						    	}							  
							      	}							    	if ( ( items >= m ) && ( items < n ) ) {		  
							      }								    	  return t ;						  
							      								    	}							  
							      								    	t ++ ;							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES			      POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES			    POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES				  POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES
--							      --							    --								  --
def isPossibleTriangle ( arr , N ) :			      bool isPossibleTriangle ( int arr [ ] , int N ) {		    bool isPossibleTriangle ( int arr [ ] , int N ) {		  failure : #Results: 9, 10
    if N < 3 :						      	if ( N < 3 ) return false ;				      if ( N < 3 ) return false ;				  
	return False					      	sort ( arr , arr + N ) ;				      sort ( arr , arr + N - 2 ) ;				  
    arr.sort ( )					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( N - 2 ) :				      	i < N - 2 ;						      i < N - 2 ;						  
	if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] :	      	i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) ret   i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) ret 
	    return True					      }								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2		      MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2		    MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2			  MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2
--							      --							    --								  --
def middleOfThree ( a , b , c ) :			      int middleOfThree ( int a , int b , int c ) {		    int middleOfThree ( int a , int b , int c ) {		  failure : #Results: 4, 10
    x = a - b						      	int x = a - b ;						      int x = a - b ;						  
    y = b - c						      	int y = b - c ;						      int y = b - c ;						  
    z = a - c						      	int z = a - c ;						      int z = a - c ;						  
    if x * y > 0 :					      	if ( x * y > 0 ) return b ;				      if ( x * y > 0 ) return b ;				  
	return b					      	else if ( x * z > 0 ) return c ;			      else if ( ( x * z > 0 ) && ( y * z < 0 ) ) return a ;	  
    elif ( x * z > 0 ) :				      	else return a ;						      else return a ;						  
	return						      }								    }								  
    else :						      								    								  
	return a					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPETITIVE_ELEMENT_1_N_1_1				      FIND_REPETITIVE_ELEMENT_1_N_1_1				    FIND_REPETITIVE_ELEMENT_1_N_1_1				  FIND_REPETITIVE_ELEMENT_1_N_1_1
--							      --							    --								  --
def findRepeating ( arr , n ) :				      int findRepeating ( int arr [ ] , int n ) {		    public : int findRepeating ( int arr [ ] , int n ) {	  error : FIND_REPETITIVE_ELEMENT_1_N_1_1.cpp:28:1:
    s = set ( )						      	unordered_set < int > s ;				      set < int > s ;						  error: expected unqualified-id before ‘public’  pu
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  blic : int f_filled ( int arr [ ] , int n ) {	 ^~~
	if arr [ i ] in s :				      	i < n ;							      i < n ;							  ~~~ FIND_REPETITIVE_ELEMENT_1_N_1_1.cpp: In functi
	    return arr [ i ]				      	i ++ ) {						      i ++ ) {							  on ‘int main()’: FIND_REPETITIVE_ELEMENT_1_N_1_1.c
	s.add ( arr [ i ] )				      	  if ( s . find ( arr [ i ] ) != s . end ( ) ) return arr [ 	if ( arr [ i ] == s . end ( ) ) return arr [ i ] ;	  pp:46:12: error: ‘f_filled’ was not declared in th
    rteurn - 1						      	  s . insert ( arr [ i ] ) ;				    	s . insert ( arr [ i ] ) ;				  is scope	    if(f_filled(&param0[i].front(),p
							      	}							      }								  aram1[i]) == f_gold(&param0[i].front(),param1[i]))
							      	return - 1 ;						      rteurn = - 1 ;						  	       ^~~~~~~~ FIND_REPETITIVE_ELEMENT_1_N_
							      }								    }								  1_1.cpp:46:12: note: suggested alternative: ‘f_gol
							      								    								  d’	      if(f_filled(&param0[i].front(),param1[
							      								    								  i]) == f_gold(&param0[i].front(),param1[i]))
							      								    								  	 ^~~~~~~~	      f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AREA_QUADRILATERAL				      MAXIMUM_AREA_QUADRILATERAL				    MAXIMUM_AREA_QUADRILATERAL					  MAXIMUM_AREA_QUADRILATERAL
--							      --							    --								  --
def maxArea ( a , b , c , d ) :				      double maxArea ( double a , double b , double c , double d )  double maxArea ( double a , double b , double c , double d )  script_not_found : None
    semiperimeter = ( a + b + c + d ) / 2		      	double semiperimeter = ( a + b + c + d ) / 2 ;		      double semiperimeter = ( a + b + c + d ) / 2 ;		  
    return math.sqrt ( ( semiperimeter - a ) * ( semiperimete 	return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b )   return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) 
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DIGITS_FACTORIAL_SET_1				      COUNT_DIGITS_FACTORIAL_SET_1				    COUNT_DIGITS_FACTORIAL_SET_1				  COUNT_DIGITS_FACTORIAL_SET_1
--							      --							    --								  --
def findDigits ( n ) :					      int findDigits ( int n ) {				    int findDigits ( int n ) {					  failure : #Results: 0, 10
    if ( n < 0 ) :					      	if ( n < 0 ) return 0 ;					      if ( ( n < 0 ) || ( n <= 1 ) ) return 0 ;			  
	return 0					      	if ( n <= 1 ) return 1 ;				      if ( ( n <= n + 1 ) || ( n <= n + 1 ) ) return 1 ;	  
    if ( n <= 1 ) :					      	double digits = 0 ;					      double digits = 0 ;					  
	return 1					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
    digits = 0						      	i <= n ;						      i <= n ;							  
    for i in range ( 2 , n + 1 ) :			      	i ++ ) digits += log10 ( i ) ;				      i ++ ) digits += log10 ( i ) ;				  
	digits += math.log10 ( i )			      	return floor ( digits ) + 1 ;				      return floor ( digits ) + 1 ;				  
    return math.floor ( digits ) + 1			      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	      CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	    CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	  CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT
--							      --							    --								  --
def isInorder ( arr , n ) :				      bool isInorder ( int arr [ ] , int n ) {			    bool isInorder ( int arr [ ] , int n ) {			  failure : #Results: 8, 10
    if ( n == 0 or n == 1 ) :				      	if ( n == 0 || n == 1 ) return true ;			      if ( ( n == 0 || n == 1 ) && ( arr [ 0 ] > arr [ 1 ] ) ) re 
	return True					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
    for i in range ( 1 , n , 1 ) :			      	i < n ;							      i < n ;							  
	if ( arr [ i - 1 ] > arr [ i ] ) :		      	i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ;	      i += 1 ) if ( ( arr [ i - 1 ] > arr [ i ] ) && ( arr [ i ]  
	    return False				      	return true ;						      return true ;						  
    return True						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_ARRAY_MAJORITY_ELEMENT				      CHECK_ARRAY_MAJORITY_ELEMENT				    CHECK_ARRAY_MAJORITY_ELEMENT				  CHECK_ARRAY_MAJORITY_ELEMENT
--							      --							    --								  --
def isMajority ( a ) :					      bool isMajority ( int a [ ] , int n ) {			    bool isMajority ( vector < int > a ) {			  error : CHECK_ARRAY_MAJORITY_ELEMENT.cpp: In funct
    mp = { }						      	unordered_map < int , int > mp ;			      map < int , int > mp ;					  ion ‘bool f_filled(std::vector<int>)’: CHECK_ARRAY
    for i in a :					      	for ( int i = 0 ;					      for ( int i = 0 ;						  _MAJORITY_ELEMENT.cpp:38:17: error: cannot convert
	if i in mp : mp [ i ] += 1			      	i < n ;							      i < a . size ( ) ;					   ‘std::pair<const int, int>’ to ‘int’ in initializ
	else : mp [ i ] = 1				      	i ++ ) mp [ a [ i ] ] ++ ;				      i ++ ) {							  ation	   for ( int x : mp ) {			 ^~
    for x in mp :					      	for ( auto x : mp ) if ( x . second >= n / 2 ) return true  	if ( a [ i ] < a [ i + 1 ] ) {				  CHECK_ARRAY_MAJORITY_ELEMENT.cpp:40:18: error: exp
	if mp [ x ] >= len ( a ) // 2 :			      	return false ;						    	  mp [ i ] ++ ;						  ected ‘;’ before ‘int’	return true
	    return True					      }								    	}							  	    ^			; CHECK_ARRAY_MAJORI
    return False					      								    	else {							  TY_ELEMENT.cpp:42:1:	int main() {  ~~~
							      								    	  mp [ i ] = 1 ;					       CHECK_ARRAY_MAJORITY_ELEMENT.cpp:42:12: error
							      								    	}							  : a function-definition is not allowed here before
							      								      }								   ‘{’ token  int main() {	       ^ CHECK_ARRAY
							      								      for ( int x : mp ) {					  _MAJORITY_ELEMENT.cpp:55:1: error: expected ‘}’ at
							      								    	if ( mp [ x ] >= a . size ( ) / 2 ) {			   end of input	 }  ^ CHECK_ARRAY_MAJORITY_ELEMENT.c
							      								    	  return true						  pp:39:41: note: to match this ‘{’	 if ( mp [ x
							      								    								   ] >= a . size ( ) / 2 ) {
							      								    								  		    ^ CHECK_ARRAY_MAJORITY_ELEMENT.c
							      								    								  pp:55:1: error: expected ‘}’ at end of input	}  ^
							      								    								   CHECK_ARRAY_MAJORITY_ELEMENT.cpp:38:22: note: to
							      								    								  match this ‘{’    for ( int x : mp ) {
							      								    								  	     ^ CHECK_ARRAY_MAJORITY_ELEMENT.cpp:55:1
							      								    								  : error: expected ‘}’ at end of input	 }  ^ CHECK_
							      								    								  ARRAY_MAJORITY_ELEMENT.cpp:26:36: note: to match t
							      								    								  his ‘{’  bool f_filled ( vector < int > a ) {
							      								    								  				  ^ CHECK_ARRAY_MAJO
							      								    								  RITY_ELEMENT.cpp:55:1: warning: control reaches en
							      								    								  d of non-void function [-Wreturn-type]  }  ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3		      COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3		    COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3			  COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3
--							      --							    --								  --
def findStep ( n ) :					      public : int findStep ( int n ) {				    int findStep ( int n ) {					  script_not_found : None
    if ( n == 1 or n == 0 ) :				      	if ( n == 1 || n == 0 ) return 1 ;			      if ( ( n == 1 || n == 0 ) && ( n == 2 ) ) return 1 ;	  
	return 1					      	else if ( n == 2 ) return 2 ;				      else if ( ( n == 2 ) && ( n == 3 ) ) return 2 ;		  
    elif ( n == 2 ) :					      	else return findStep ( n - 3 ) + findStep ( n - 2 ) + findS   else return findStep ( n - 3 ) + findStep ( n - 2 ) + findS 
	return 2					      }								    }								  
    else :						      								    								  
	return findStep ( n - 3 ) + findStep ( n - 2 ) + find 								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			      NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			    NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			  NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES
--							      --							    --								  --
def findPosition ( k , n ) :				      int findPosition ( int k , int n ) {			    int findPosition ( int k , int n ) {			  script_not_found : None
    f1 = 0						      	unsigned long long int f1 = 0 , f2 = 1 , f3 ;		      int f1 = 0 ;						  
    f2 = 1						      	for ( int i = 2 ;					      int f2 = 1 ;						  
    i = 2						      	i <= MAX ;						      int i = 2 ;						  
    while i != 0 :					      	i ++ ) {						      while ( i != 0 ) {					  
	f3 = f1 + f2					      	  f3 = f1 + f2 ;					    	int f3 = f1 + f2 ;					  
	f1 = f2						      	  f1 = f2 ;						    	f1 = f2 ;						  
	f2 = f3						      	  f2 = f3 ;						    	f2 = f3 ;						  
	if f2 % k == 0 :				      	  if ( f2 % k == 0 ) return n * i ;			    	if ( f2 % k == 0 ) return n * i ;			  
	    return n * i				      	}							    	i ++ ;							  
	i += 1						      }								      }								  
    return						      								      return 0 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	      MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	    MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	  MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY
--							      --							    --								  --
def minimum_cost ( a , n ) :				      int minimum_cost ( int a [ ] , int n ) {			    public : int minimumCost ( int a [ ] , int n ) {		  error : MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRES
    mn = sys.maxsize					      	int mn = INT_MAX ;					      int mn = INT_MAX ;					  ENTED_ARRAY.cpp:29:1: error: expected unqualified-
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  id before ‘public’  public : int f_filled ( int a
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  [ ] , int n ) {  ^~~~~~ MINIMUM_COST_CONNECT_WEIGH
	mn = min ( a [ i ] , mn )			      	i < n ;							      i < n ;							  TED_NODES_REPRESENTED_ARRAY.cpp: In function ‘int
	sum += a [ i ]					      	i ++ ) {						      i ++ ) {							  main()’: MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRE
    return mn * ( sum - mn )				      	  mn = min ( a [ i ] , mn ) ;				    	mn = min ( a [ i ] , mn ) ;				  SENTED_ARRAY.cpp:48:12: error: ‘f_filled’ was not
							      	  sum += a [ i ] ;					    	sum += a [ i ] ;					  declared in this scope	  if(f_filled(&param
							      	}							      }								  0[i].front(),param1[i]) == f_gold(&param0[i].front
							      	return mn * ( sum - mn ) ;				      return mn * ( sum - mn ) ;				  (),param1[i]))	     ^~~~~~~~ MINIMUM_COST_C
							      }								    }								  ONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY.cpp:48:12:
							      								    								   note: suggested alternative: ‘f_gold’	  if
							      								    								  (f_filled(&param0[i].front(),param1[i]) == f_gold(
							      								    								  &param0[i].front(),param1[i]))	     ^~~~~~~
							      								    								  ~		f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_DIGIT_RAISED_POWER_B				      K_TH_DIGIT_RAISED_POWER_B					    K_TH_DIGIT_RAISED_POWER_B					  K_TH_DIGIT_RAISED_POWER_B
--							      --							    --								  --
def kthdigit ( a , b , k ) :				      int kthdigit ( int a , int b , int k ) {			    int kthdigit ( int a , int b , int k ) {			  failure : #Results: 6, 10
    p = a ** b						      	int p = pow ( a , b ) ;					      int p = a * b ;						  
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    while ( p > 0 and count < k ) :			      	while ( p > 0 && count < k ) {				      while ( ( p > 0 ) && ( count < k ) ) {			  
	rem = p % 10					      	  int rem = p % 10 ;					    	int rem = p % 10 ;					  
	count = count + 1				      	  count ++ ;						    	count = count + 1 ;					  
	if ( count == k ) :				      	  if ( count == k ) return rem ;			    	if ( ( count == k ) && ( p > 0 ) ) return rem ;		  
	    return rem					      	  p = p / 10 ;						    	p = p / 10 ;						  
	p = p / 10					      	}							      }								  
							      	return 0 ;						      return 0 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1		      COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1			    COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1			  COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1
--							      --							    --								  --
def numberOfWays ( x ) :				      int numberOfWays ( int x ) {				    int numberOfWays ( int x ) {				  timeout : None
    if x == 0 or x == 1 :				      	int dp [ x + 1 ] ;					      if ( x == 0 || x == 1 ) return 1 ;			  
	return 1					      	dp [ 0 ] = dp [ 1 ] = 1 ;				      else return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOf 
    else :						      	for ( int i = 2 ;					    }								  
	return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberO 	i <= x ;						    								  
							      	i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; 								  
							      	return dp [ x ] ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1		      FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1		    FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1			  FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1
--							      --							    --								  --
def sumNodes ( l ) :					      int sumNodes ( int l ) {					    int sumNodes ( int l ) {					  script_not_found : None
    leafNodeCount = math.pow ( 2 , l - 1 )		      	int leafNodeCount = pow ( 2 , l - 1 ) ;			      int leafNodeCount = pow ( 2 , l - 1 ) ;			  
    sumLastLevel = 0					      	int sumLastLevel = 0 ;					      int sumLastLevel ;					  
    sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 )  	sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) /    sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) )  
    sum = sumLastLevel * l				      	int sum = sumLastLevel * l ;				      int sum = sumLastLevel * l ;				  
    return int ( sum )					      	return sum ;						      return ( int ) sum ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEONARDO_NUMBER_1					      LEONARDO_NUMBER_1						    LEONARDO_NUMBER_1						  LEONARDO_NUMBER_1
--							      --							    --								  --
def leonardo ( n ) :					      int leonardo ( int n ) {					    int leonardo ( int n ) {					  success : None
    dp = [ ]						      	int dp [ n + 1 ] ;					      int dp [ n ] ;						  
    dp.append ( 1 )					      	dp [ 0 ] = dp [ 1 ] = 1 ;				      dp [ 0 ] = 1 ;						  
    dp.append ( 1 )					      	for ( int i = 2 ;					      dp [ 1 ] = 1 ;						  
    for i in range ( 2 , n + 1 ) :			      	i <= n ;						      for ( int i = 2 ;						  
	dp.append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 )	      	i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ;	      i <= n ;							  
    return dp [ n ]					      	return dp [ n ] ;					      i ++ ) {							  
							      }								    	dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ;		  
							      								      }								  
							      								      return dp [ n ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_ADDITION_TWO_MATRICES				      C_PROGRAM_ADDITION_TWO_MATRICES				    C_PROGRAM_ADDITION_TWO_MATRICES				  C_PROGRAM_ADDITION_TWO_MATRICES
--							      --							    --								  --
def add ( A , B , C ) :					      void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N  void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N  script_not_found : None
    for i in range ( N ) :				      	int i , j ;						      for ( int i = 0 ;						  
	for j in range ( N ) :				      	for ( i = 0 ;						      i < N ;							  
	    C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ]     	i < N ;							      i ++ ) for ( int j = 0 ;					  
							      	i ++ ) for ( j = 0 ;					      j < N ;							  
							      	j < N ;							      j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;	  
							      	j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;	    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	      PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	    PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	  PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1
--							      --							    --								  --
def arraySortedOrNot ( arr , n ) :			      bool arraySortedOrNot ( int arr [ ] , int n ) {		    bool arraySortedOrNot ( int arr [ ] , int n ) {		  failure : #Results: 5, 10
    if ( n == 0 or n == 1 ) :				      	if ( n == 0 || n == 1 ) return true ;			      if ( ( n == 0 || n == 1 ) && ( arr [ 0 ] > arr [ 1 ] ) ) re 
	return True					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
    for i in range ( 1 , n ) :				      	i < n ;							      i < n ;							  
	if ( arr [ i - 1 ] > arr [ i ] ) :		      	i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ;	      i ++ ) if ( ( arr [ i - 1 ] > arr [ i ] ) && ( arr [ i ] >  
	    return False				      	return true ;						      return true ;						  
    return True						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS_1					      SUM_PAIRWISE_PRODUCTS_1					    SUM_PAIRWISE_PRODUCTS_1					  SUM_PAIRWISE_PRODUCTS_1
--							      --							    --								  --
def findSum ( n ) :					      long long int findSum ( int n ) {				    int findSum ( int n ) {					  success : None
    multiTerms = n * ( n + 1 ) // 2			      	long long int multiTerms = n * ( n + 1 ) / 2 ;		      int multiTerms = n * ( n + 1 ) / 2 ;			  
    sm = multiTerms					      	long long int sum = multiTerms ;			      int sm = multiTerms ;					  
    for i in range ( 2 , n + 1 ) :			      	for ( int i = 2 ;					      for ( int i = 2 ;						  
	multiTerms = multiTerms - ( i - 1 )		      	i <= n ;						      i <= n ;							  
	sm = sm + multiTerms * i			      	i ++ ) {						      i ++ ) {							  
    return sm						      	  multiTerms = multiTerms - ( i - 1 ) ;			    	multiTerms = multiTerms - ( i - 1 ) ;			  
							      	  sum = sum + multiTerms * i ;				    	sm = sm + multiTerms * i ;				  
							      	}							      }								  
							      	return sum ;						      return sm ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_STRING_START_END_GEEKS			      PROGRAM_FIND_STRING_START_END_GEEKS			    PROGRAM_FIND_STRING_START_END_GEEKS				  PROGRAM_FIND_STRING_START_END_GEEKS
--							      --							    --								  --
def isCornerPresent ( str , corner ) :			      bool isCornerPresent ( string str , string corner ) {	    bool isCornerPresent ( string str , string corner ) {	  failure : #Results: 5, 10
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . size ( ) ;					  
    cl = len ( corner )					      	int cl = corner . length ( ) ;				      int cl = corner . size ( ) ;				  
    if ( n < cl ) :					      	if ( n < cl ) return false ;				      if ( ( n < cl ) || ( n > cl ) ) return false ;		  
	return False					      	return ( str . substr ( 0 , cl ) . compare ( corner ) == 0    return ( ( str . substr ( 0 , cl ) == corner ) && ( str . s 
    return ( ( str [ : cl ] == corner ) and ( str [ n - cl :  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX		      PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX		    PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX			  PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX
--							      --							    --								  --
def isDiagonalMatrix ( mat ) :				      bool isDiagonalMatrix ( int mat [ N ] [ N ] ) {		    bool isDiagonalMatrix ( int * * mat ) {			  script_not_found : None
    for i in range ( 0 , N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( 0 , N ) :			      	i < N ;							      i != N ;							  
	    if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) :  	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		return False				      	j < N ;							    	for ( int j = 0 ;					  
    return True						      	j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return 	j != N ;						  
							      	return true ;						    	j ++ ) {						  
							      }								    	  if ( ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) || ( (  
							      								    	}							  
							      								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	      MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	    MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	  MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1
--							      --							    --								  --
def minimumflip ( mat , n ) :				      int minimumflip ( int mat [ ] [ N ] , int n ) {		    int minimumflip ( int * * mat , int n ) {			  script_not_found : None
    flip = 0						      	int flip = 0 ;						      int flip = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i ) :				      	i < n ;							      i < n ;							  
	    if mat [ i ] [ j ] != mat [ j ] [ i ] :	      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		flip += 1				      	j < i ;							    	for ( int j = 0 ;					  
    return flip						      	j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ;  	j < i ;							  
							      	return flip ;						    	j ++ ) {						  
							      }								    	  if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) {		  
							      								    	    flip ++ ;						  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return flip ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		      FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		    FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		  FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME
--							      --							    --								  --
def findIndex ( n ) :					      int findIndex ( int n ) {					    int findIndex ( int n ) {					  failure : #Results: 0, 10
    if ( n <= 1 ) :					      	if ( n <= 1 ) return n ;				      if ( ( n <= 1 ) || ( n > n ) ) return n ;			  
	return n					      	int a = 0 , b = 1 , c = 1 ;				      int a = 0 ;						  
    a = 0						      	int res = 1 ;						      int b = 1 ;						  
    b = 1						      	while ( c < n ) {					      int c = 1 ;						  
    c = 1						      	  c = a + b ;						      int res = 1 ;						  
    res = 1						      	  res ++ ;						      while ( ( c < n ) && ( res == 1 ) ) {			  
    while ( c < n ) :					      	  a = b ;						    	c = a + b ;						  
	c = a + b					      	  b = c ;						    	res = res + 1 ;						  
	res = res + 1					      	}							    	a = b ;							  
	a = b						      	return res ;						    	b = c ;							  
	b = c						      }								      }								  
    return res						      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				      CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				    CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				  CONSTRUCT_ARRAY_PAIR_SUM_ARRAY
--							      --							    --								  --
def constructArr ( arr , pair , n ) :			      void constructArr ( int arr [ ] , int pair [ ] , int n ) {    void constructArr ( int * arr , int pair [ ] , int n ) {	  script_not_found : None
    arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] )  	arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) /    arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) /  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	arr [ i ] = pair [ i - 1 ] - arr [ 0 ]		      	i < n ;							      i < n ;							  
							      	i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ;		      i ++ ) {							  
							      }								    	arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ;		  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MARKOV_MATRIX						      MARKOV_MATRIX						    MARKOV_MATRIX						  MARKOV_MATRIX
--							      --							    --								  --
def checkMarkov ( m ) :					      bool checkMarkov ( double m [ ] [ n ] ) {			    bool checkMarkov ( vector < vector < int >> & m ) {		  script_not_found : None
    for i in range ( 0 , len ( m ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	sm = 0						      	i < n ;							      i != m . size ( ) ;					  
	for j in range ( 0 , len ( m [ i ] ) ) :	      	i ++ ) {						      i ++ ) {							  
	    sm = sm + m [ i ] [ j ]			      	  double sum = 0 ;					    	int sm = 0 ;						  
	if ( sm != 1 ) :				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    return False				      	  j < n ;						    	j != m [ i ] . size ( ) ;				  
    return True						      	  j ++ ) sum = sum + m [ i ] [ j ] ;			    	j ++ ) sm = sm + m [ i ] [ j ] ;			  
							      	  if ( sum != 1 ) return false ;			    	if ( ( sm != 1 ) && ( sm != 0 ) ) return false ;	  
							      	}							      }								  
							      	return true ;						      return true ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MODULUS_TWO_FLOAT_DOUBLE_NUMBERS			      MODULUS_TWO_FLOAT_DOUBLE_NUMBERS				    MODULUS_TWO_FLOAT_DOUBLE_NUMBERS				  MODULUS_TWO_FLOAT_DOUBLE_NUMBERS
--							      --							    --								  --
def findMod ( a , b ) :					      double findMod ( double a , double b ) {			    int findMod ( int a , int b ) {				  failure : #Results: 5, 10
    if ( a < 0 ) :					      	double mod ;						      if ( ( a < 0 ) || ( b < 0 ) ) a = - a ;			  
	a = - a						      	if ( a < 0 ) mod = - a ;				      if ( ( b < 0 ) || ( a > b ) ) b = - b ;			  
    if ( b < 0 ) :					      	else mod = a ;						      int mod = a ;						  
	b = - b						      	if ( b < 0 ) b = - b ;					      while ( ( mod >= b ) && ( mod < a ) ) mod = mod - b ;	  
    mod = a						      	while ( mod >= b ) mod = mod - b ;			      if ( ( a < 0 ) || ( b < a ) ) return - mod ;		  
    while ( mod >= b ) :				      	if ( a < 0 ) return - mod ;				      return mod ;						  
	mod = mod - b					      	return mod ;						    }								  
    if ( a < 0 ) :					      }								    								  
	return - mod					      								    								  
    return mod						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE			  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE
--							      --							    --								  --
def recursiveReverse ( str ) :				      void recursiveReverse ( string & str ) {			    void recursiveReverse ( vector < string > & str ) {		  script_not_found : None
    stack = [ ]						      	stack < char > st ;					      stack < string > stack ;					  
    for i in range ( len ( str ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	stack.append ( str [ i ] )			      	i < str . length ( ) ;					      i < str . size ( ) ;					  
    for i in range ( len ( str ) ) :			      	i ++ ) st . push ( str [ i ] ) ;			      i ++ ) {							  
	str [ i ] = stack.pop ( )			      	for ( int i = 0 ;					    	stack . push ( str [ i ] ) ;				  
							      	i < str . length ( ) ;					      }								  
							      	i ++ ) {						      for ( int i = 0 ;						  
							      	  str [ i ] = st . top ( ) ;				      i < str . size ( ) ;					  
							      	  st . pop ( ) ;					      i ++ ) {							  
							      	}							    	str [ i ] = stack . top ( ) ;				  
							      }								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_SUBTRACTION_MATICES				      C_PROGRAM_SUBTRACTION_MATICES				    C_PROGRAM_SUBTRACTION_MATICES				  C_PROGRAM_SUBTRACTION_MATICES
--							      --							    --								  --
def multiply ( A , B , C ) :				      void multiply ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] void multiply ( int A [ N ] [ N ] , int B [ N ] [ N ] , int C script_not_found : None
    for i in range ( N ) :				      	int i , j ;						      for ( int i = 0 ;						  
	for j in range ( N ) :				      	for ( i = 0 ;						      i < N ;							  
	    C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]     	i < N ;							      i ++ ) for ( int j = 0 ;					  
							      	i ++ ) for ( j = 0 ;					      j < N ;							  
							      	j < N ;							      j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;	  
							      	j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;	    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	      MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	    MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	  MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED
--							      --							    --								  --
def minValue ( A , B , n ) :				      int minValue ( int A [ ] , int B [ ] , int n ) {		    int minValue ( int A [ ] , int B [ ] , int n ) {		  success : identical to gold
    sorted ( A )					      	sort ( A , A + n ) ;					      sort ( A , A + n ) ;					  
    sorted ( B )					      	sort ( B , B + n ) ;					      sort ( B , B + n ) ;					  
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	result += ( A [ i ] * B [ n - i - 1 ] )		      	i < n ;							      i < n ;							  
    return result					      	i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ;	      i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ;		  
							      	return result ;						      return result ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS
--							      --							    --								  --
def decToBin ( n ) :					      string decToBin ( int n ) {				    string decToBin ( int n ) {					  failure : #Results: 0, 10
    if ( n == 0 ) :					      	if ( n == 0 ) return "0" ;				      if ( ( n == 0 ) || ( n == 1 ) ) return "0" ;		  
	return "0"					      	string bin = "" ;					      string bin = "" ;						  
    bin = ""						      	while ( n > 0 ) {					      while ( ( n > 0 ) && ( n & 1 == 0 ) ) {			  
    while ( n > 0 ) :					      	  bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ;		    	if ( ( n & 1 ) == 0 ) bin = "0" + bin ;			  
	if ( n & 1 == 0 ) :				      	  n >>= 1 ;						    	else bin = "1" + bin ;					  
	    bin = '0' + bin				      	}							    	n = n >> 1 ;						  
	else :						      	return bin ;						      }								  
	    bin = '1' + bin				      }								      return bin ;						  
	n = n >> 1					      								    }								  
    return bin						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ROTATE_MATRIX_180_DEGREE				      ROTATE_MATRIX_180_DEGREE					    ROTATE_MATRIX_180_DEGREE					  ROTATE_MATRIX_180_DEGREE
--							      --							    --								  --
def rotateMatrix ( mat ) :				      void rotateMatrix ( int mat [ ] [ N ] ) {			    void rotateMatrix ( int mat [ ] [ N ] ) {			  script_not_found : None
    i = N - 1						      	for ( int i = N - 1 ;					      int i = N - 1 ;						  
    while ( i >= 0 ) :					      	i >= 0 ;						      while ( ( i >= 0 ) && ( i < N ) ) {			  
	j = N - 1					      	i -- ) {						    	int j = N - 1 ;						  
	while ( j >= 0 ) :				      	  for ( int j = N - 1 ;					    	while ( ( j >= 0 ) && ( j < N ) ) {			  
	    print ( mat [ i ] [ j ] , end = " " )	      	  j >= 0 ;						    	  cout << mat [ i ] [ j ] << " " ;			  
	    j = j - 1					      	  j -- ) printf ( "%d " , mat [ i ] [ j ] ) ;		    	  j = j - 1 ;						  
	print ( )					      	  printf ( "\n" ) ;					    	}							  
	i = i - 1					      	}							    	cout << endl ;						  
							      }								    	i = i - 1 ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA
--							      --							    --								  --
def russianPeasant ( a , b ) :				      unsigned int russianPeasant ( unsigned int a , unsigned int b int russianPeasant ( int a , int b ) {			  failure : #Results: 0, 10
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    while ( b > 0 ) :					      	while ( b > 0 ) {					      while ( ( b > 0 ) && ( ( b & 1 ) != 0 ) ) {		  
	if ( b & 1 ) :					      	  if ( b & 1 ) res = res + a ;				    	if ( ( b & 1 ) != 0 ) res = res + a ;			  
	    res = res + a				      	  a = a << 1 ;						    	a = a << 1 ;						  
	a = a << 1					      	  b = b >> 1 ;						    	b = b >> 1 ;						  
	b = b >> 1					      	}							      }								  
    return res						      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPLIT_ARRAY_ADD_FIRST_PART_END				      SPLIT_ARRAY_ADD_FIRST_PART_END				    SPLIT_ARRAY_ADD_FIRST_PART_END				  SPLIT_ARRAY_ADD_FIRST_PART_END
--							      --							    --								  --
def splitArr ( arr , n , k ) :				      void splitArr ( int arr [ ] , int n , int k ) {		    void splitArr ( int arr [ ] , int n , int k ) {		  error : double free or corruption (out) /bin/bash:
    for i in range ( 0 , k ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						   line 1: 2965541 Aborted		   (core dum
	x = arr [ 0 ]					      	i < k ;							      i <= k ;							  ped) ./SPLIT_ARRAY_ADD_FIRST_PART_END_cpp
	for j in range ( 0 , n - 1 ) :			      	i ++ ) {						      i ++ ) {							  
	    arr [ j ] = arr [ j + 1 ]			      	  int x = arr [ 0 ] ;					    	int x = arr [ 0 ] ;					  
	arr [ n - 1 ] = x				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
							      	  j < n - 1 ;						    	j <= n - 1 ;						  
							      	  ++ j ) arr [ j ] = arr [ j + 1 ] ;			    	j ++ ) arr [ j ] = arr [ j + 1 ] ;			  
							      	  arr [ n - 1 ] = x ;					    	arr [ n - 1 ] = x ;					  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B			      COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B				    COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B				  COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B
--							      --							    --								  --
def CountPairs ( n ) :					      int CountPairs ( int n ) {				    public : int CountPairs ( int n ) {				  error : COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B.cpp:30:1:
    k = n						      	int k = n ;						      int k = n ;						   error: expected unqualified-id before ‘public’  p
    imin = 1						      	int imin = 1 ;						      int imin = 1 ;						  ublic : int f_filled ( int n ) {  ^~~~~~ COUNT_NUM
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  BER_PAIRS_N_B_N_GCD_B_B.cpp: In function ‘int main
    while ( imin <= n ) :				      	while ( imin <= n ) {					      while ( ( imin <= n ) && ( ans < k ) ) {			  ()’: COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B.cpp:49:12: e
	imax = n / k					      	  int imax = n / k ;					    	int imax = n / k ;					  rror: ‘f_filled’ was not declared in this scope
	ans += k * ( imax - imin + 1 )			      	  ans += k * ( imax - imin + 1 ) ;			    	ans += k * ( imax - imin + 1 ) ;			  	 if(f_filled(param0[i]) == f_gold(param0[i])
	imin = imax + 1					      	  imin = imax + 1 ;					    	imin = imax + 1 ;					  )		^~~~~~~~ COUNT_NUMBER_PAIRS_N_B_N_GC
	k = n / imin					      	  k = n / imin ;					    	k = n / imin ;						  D_B_B.cpp:49:12: note: suggested alternative: ‘f_g
    return ans						      	}							      }								  old’		if(f_filled(param0[i]) == f_gold(par
							      	return ans ;						      return ans ;						  am0[i]))	       ^~~~~~~~		    f_gold
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION     DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION	    DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION	  DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION
--							      --							    --								  --
def lastPosition ( n , m , k ) :			      int lastPosition ( int n , int m , int k ) {		    int lastPosition ( int n , int m , int k ) {		  failure : #Results: 5, 10
    if ( m <= n - k + 1 ) :				      	if ( m <= n - k + 1 ) return m + k - 1 ;		      if ( ( m <= n - k + 1 ) && ( m > n - k + 1 ) ) return m + k 
	return m + k - 1				      	m = m - ( n - k + 1 ) ;					      m = m - ( n - k + 1 ) ;					  
    m = m - ( n - k + 1 )				      	return ( m % n == 0 ) ? n : ( m % n ) ;			      if ( ( m % n == 0 ) && ( m % n == 0 ) ) return n ;	  
    if ( m % n == 0 ) :					      }								      else return m % n ;					  
	return n					      								    }								  
    else :						      								    								  
	return m % n					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PAPER_CUT_MINIMUM_NUMBER_SQUARES			      PAPER_CUT_MINIMUM_NUMBER_SQUARES				    PAPER_CUT_MINIMUM_NUMBER_SQUARES				  PAPER_CUT_MINIMUM_NUMBER_SQUARES
--							      --							    --								  --
def minimumSquare ( a , b ) :				      int minimumSquare ( int a , int b ) {			    int minimumSquare ( int a , int b ) {			  timeout : None
    result = 0						      	long long result = 0 , rem = 0 ;			      int result = 0 ;						  
    rem = 0						      	if ( a < b ) swap ( a , b ) ;				      int rem ;							  
    if ( a < b ) :					      	while ( b > 0 ) {					      if ( ( a < b ) || ( b < a ) ) {				  
	a , b = b , a					      	  result += a / b ;					    	a = b ;							  
    while ( b > 0 ) :					      	  long long rem = a % b ;				    	b = a ;							  
	result += int ( a / b )				      	  a = b ;						      }								  
	rem = int ( a % b )				      	  b = rem ;						      while ( ( b > 0 ) && ( a % b == 0 ) ) {			  
	a = b						      	}							    	result += ( int ) ( a / b ) ;				  
	b = rem						      	return result ;						    	rem = ( int ) ( a % b == 0 ) ;				  
    return result					      }								    	a = b ;							  
							      								    	b = rem ;						  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS		      PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS		    PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS			  PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS
--							      --							    --								  --
def printFibonacciNumbers ( n ) :			      void printFibonacciNumbers ( int n ) {			    void printFibonacciNumbers ( int n ) {			  script_not_found : None
    f1 = 0						      	int f1 = 0 , f2 = 1 , i ;				      int f1 = 0 ;						  
    f2 = 1						      	if ( n < 1 ) return ;					      int f2 = 1 ;						  
    if ( n < 1 ) :					      	for ( i = 1 ;						      if ( ( n < 1 ) || ( n > n ) ) return ;			  
	return						      	i <= n ;						      for ( int x = 0 ;						  
    for x in range ( 0 , n ) :				      	i ++ ) {						      x <= n ;							  
	print ( f2 , end = " " )			      	  cout << f2 << " " ;					      x ++ ) {							  
	next = f1 + f2					      	  int next = f1 + f2 ;					    	cout << f2 << " " ;					  
	f1 = f2						      	  f1 = f2 ;						    	int next = f1 + f2 ;					  
	f2 = next					      	  f2 = next ;						    	f1 = f2 ;						  
							      	}							    	f2 = next ;						  
							      }								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION		      LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION			    LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION			  LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION
--							      --							    --								  --
def minLexRotation ( str_ ) :				      string minLexRotation ( string str ) {			    public : int minLexRotation ( string str_ ) {		  error : LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION.
    n = len ( str_ )					      	int n = str . length ( ) ;				      int n = str_ . size ( ) ;					  cpp:28:1: error: expected unqualified-id before ‘p
    arr = [ 0 ] * n					      	string arr [ n ] ;					      int arr [ n ] = {						  ublic’  public : int f_filled ( string str_ ) {  ^
    concat = str_ + str_				      	string concat = str + str ;				    	0 }							  ~~~~~ LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION.cp
    for i in range ( n ) :				      	for ( int i = 0 ;					    	;							  p: In function ‘int main()’: LEXICOGRAPHICALLY_MIN
	arr [ i ] = concat [ i : n + i ]		      	i < n ;							    	string concat = str_ + str_ ;				  IMUM_STRING_ROTATION.cpp:49:12: error: ‘f_filled’
    arr.sort ( )					      	i ++ ) arr [ i ] = concat . substr ( i , n ) ;		    	for ( int i = 0 ;					  was not declared in this scope	  if(f_fille
    return arr [ 0 ]					      	sort ( arr , arr + n ) ;				    	i < n ;							  d(param0[i]) == f_gold(param0[i]))		 ^~~
							      	return arr [ 0 ] ;					    	i ++ ) {						  ~~~~~ LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION.cp
							      }								    	  arr [ i ] = concat . substr ( i , n - i ) ;		  p:49:12: note: suggested alternative: ‘f_gold’
							      								    	}							  	if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    	sort ( arr , arr + n ) ;				  	       ^~~~~~~~		    f_gold
							      								    	return arr [ 0 ] ;					  
							      								      }								  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN
--							      --							    --								  --
def search ( arr , n , x ) :				      int search ( int arr [ ] , int n , int x ) {		    int search ( int arr [ ] , int n , int x ) {		  failure : #Results: 5, 10
    i = 0						      	int i = 0 ;						      int i = 0 ;						  
    while ( i <= n - 1 ) :				      	while ( i <= n - 1 ) {					      while ( ( i <= n - 1 ) && ( arr [ i ] == x ) ) {		  
	if ( arr [ i ] == x ) :				      	  if ( arr [ i ] == x ) return i ;			    	if ( ( arr [ i ] == x ) || ( arr [ i ] == 0 ) ) return i  
	    return i					      	  i += abs ( arr [ i ] - x ) ;				    	i += abs ( arr [ i ] - x ) ;				  
	i += abs ( arr [ i ] - x )			      	}							      }								  
    return - 1						      	return - 1 ;						      return - 1 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			      HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			    HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			  HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN
--							      --							    --								  --
def findHeight ( parent , n ) :				      int findHeight ( int * parent , int n ) {			    int findHeight ( int * parent , int n ) {			  script_not_found : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	p = i						      	i < n ;							      i < n ;							  
	current = 1					      	i ++ ) {						      i ++ ) {							  
	while ( parent [ p ] != - 1 ) :			      	  int p = i , current = 1 ;				    	int p = i ;						  
	    current += 1				      	  while ( parent [ p ] != - 1 ) {			    	int current = 1 ;					  
	    p = parent [ p ]				      	    current ++ ;					    	while ( ( parent [ p ] != - 1 ) && ( parent [ p ] != - 1  
	res = max ( res , current )			      	    p = parent [ p ] ;					    	  current ++ ;						  
    return res						      	  }							    	  p = parent [ p ] ;					  
							      	  res = max ( res , current ) ;				    	}							  
							      	}							    	res = max ( res , current ) ;				  
							      	return res ;						      }								  
							      }								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER   MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER   MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER	  MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER
--							      --							    --								  --
def maxPrefix ( s , t ) :				      int maxPrefix ( char s [ ] , char t [ ] ) {		    int maxPrefix ( string s , string t ) {			  error : /bin/bash: line 1: 2965633 Aborted
    count = 0						      	int count = 0 ;						      int count = 0 ;						  	   (core dumped) ./MAXIMUM_LENGTH_PREFIX_ONE
    for i in range ( 0 , len ( t ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  _STRING_OCCURS_SUBSEQUENCE_ANOTHER_cpp
	if ( count == len ( s ) ) :			      	i < strlen ( t ) ;					      ;								  
	    break					      	i ++ ) {						      i ++ ) {							  
	if ( t [ i ] == s [ count ] ) :			      	  if ( count == strlen ( s ) ) break ;			    	if ( ( count == s . size ( ) ) && ( i < t . size ( ) ) )  
	    count = count + 1				      	  if ( t [ i ] == s [ count ] ) count ++ ;		    	if ( ( t [ i ] == s [ count ] ) && ( i < t . size ( ) ) ) 
    return count					      	}							      }								  
							      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN
--							      --							    --								  --
def findMaximum ( arr , low , high ) :			      int findMaximum ( int arr [ ] , int low , int high ) {	    int findMaximum ( int arr [ ] , int low , int high ) {	  failure : #Results: 7, 10
    max = arr [ low ]					      	int max = arr [ low ] ;					      int max = arr [ low ] ;					  
    i = low						      	int i ;							      int i ;							  
    for i in range ( high + 1 ) :			      	for ( i = low + 1 ;					      for ( i = low ;						  
	if arr [ i ] > max :				      	i <= high ;						      i < high ;						  
	    max = arr [ i ]				      	i ++ ) {						      i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;		  
    return max						      	  if ( arr [ i ] > max ) max = arr [ i ] ;		      return max ;						  
							      	  else break ;						    }								  
							      	}							    								  
							      	return max ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING	      CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING		    CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING		  CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING
--							      --							    --								  --
def findSum ( str1 ) :					      int findSum ( string str ) {				    int findSum ( string str1 ) {				  failure : #Results: 4, 10
    temp = ""						      	string temp = "" ;					      string temp = "" ;					  
    Sum = 0						      	int sum = 0 ;						      int Sum = 0 ;						  
    for ch in str1 :					      	for ( char ch : str ) {					      for ( int i = 0 ;						  
	if ( ch.isdigit ( ) ) :				      	  if ( isdigit ( ch ) ) temp += ch ;			      i < str1 . length ( ) ;					  
	    temp += ch					      	  else {						      i ++ ) {							  
	else :						      	    sum += atoi ( temp . c_str ( ) ) ;			    	char ch = str1 [ i ] ;					  
	    Sum += int ( temp )				      	    temp = "" ;						    	if ( ( ch = tolower ( ch ) ) == ' ' ) temp += ch ;	  
	    temp = "0"					      	  }							    	else {							  
    return Sum + int ( temp )				      	}							    	  Sum += atoi ( temp . c_str ( ) ) ;			  
							      	return sum + atoi ( temp . c_str ( ) ) ;		    	  temp = "0" ;						  
							      }								    	}							  
							      								      }								  
							      								      return Sum + atoi ( temp . c_str ( ) ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MIRROR_IMAGE_POINT_2_D_PLANE			      FIND_MIRROR_IMAGE_POINT_2_D_PLANE				    FIND_MIRROR_IMAGE_POINT_2_D_PLANE				  FIND_MIRROR_IMAGE_POINT_2_D_PLANE
--							      --							    --								  --
def mirrorImage ( a , b , c , x1 , y1 ) :		      pair < double , double > mirrorImage ( double a , double b ,  pair < int , int > mirrorImage ( int a , int b , int c , int  script_not_found : None
    temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b )  	double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b *   double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * 
    x = temp * a + x1					      	double x = temp * a + x1 ;				      double x = temp * a + x1 ;				  
    y = temp * b + y1					      	double y = temp * b + y1 ;				      double y = temp * b + y1 ;				  
    return ( x , y )					      	return make_pair ( x , y ) ;				      return make_pair ( x , y ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO		      MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO		    MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO			  MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO
--							      --							    --								  --
def moduloMultiplication ( a , b , mod ) :		      long long moduloMultiplication ( long long a , long long b ,  int moduloMultiplication ( int a , int b , int mod ) {	  success : None
    res = 0 ;						      	long long res = 0 ;					      int res = 0 ;						  
    a = a % mod ;					      	a %= mod ;						      ;								  
    while ( b ) :					      	while ( b ) {						      a = a % mod ;						  
	if ( b & 1 ) :					      	  if ( b & 1 ) res = ( res + a ) % mod ;		      while ( ( b ) ) {						  
	    res = ( res + a ) % mod ;			      	  a = ( 2 * a ) % mod ;					    	if ( ( b & 1 ) ) res = ( res + a ) % mod ;		  
	a = ( 2 * a ) % mod ;				      	  b >>= 1 ;						    	a = ( 2 * a ) % mod ;					  
	b >>= 1 ;					      	}							    	b >>= 1 ;						  
    return res ;					      	return res ;						      }								  
							      }								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1		      MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1		    MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1			  MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1
--							      --							    --								  --
def subset ( arr , n ) :				      int subset ( int arr [ ] , int n ) {			    int subset ( int arr [ ] , int n ) {			  error : MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1
    mp = { i : 0 for i in range ( 10 ) }		      	unordered_map < int , int > mp ;			      map < int , int > mp {					  .cpp: In function ‘int f_filled(int*, int)’: MINIM
    for i in range ( n ) :				      	for ( int i = 0 ;					    	i , 0 }							  UM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1.cpp:29:5: er
	mp [ arr [ i ] ] += 1				      	i < n ;							    	;							  ror: ‘i’ was not declared in this scope      i , 0
    res = 0						      	i ++ ) mp [ arr [ i ] ] ++ ;				    	for ( int i = 0 ;					   }	  ^ MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS
    for key , value in mp.items ( ) :			      	int res = 0 ;						    	i < 10 ;						  _1.cpp:29:11: error: no matching function for call
	res = max ( res , value )			      	for ( auto x : mp ) res = max ( res , x . second ) ;	    	i ++ ) mp [ arr [ i ] ] ++ ;				   to ‘std::map<int, int>::map(<brace-enclosed initi
    return res						      	return res ;						    	int res = 0 ;						  alizer list>)’      i , 0 }		 ^ In file i
							      }								    	for ( map < int , int > :: iterator it = mp . begin ( ) ; ncluded from /usr/include/c++/8/map:61,
							      								    	it != mp . end ( ) ;					  	 from /usr/include/c++/8/x86_64-redhat-linux
							      								    	it ++ ) res = max ( res , it -> first ) ;		  /bits/stdc++.h:81,		      from MINIMUM_N
							      								    	return res ;						  UMBER_SUBSETS_DISTINCT_ELEMENTS_1.cpp:14: /usr/inc
							      								      }								  lude/c++/8/bits/stl_map.h:288:2: note: candidate:
							      								    								  ‘template<class _InputIterator> std::map<_Key, _Tp
							      								    								  , _Compare, _Alloc>::map(_InputIterator, _InputIte
							      								    								  rator, const _Compare&, const allocator_type&)’
							      								    								  map(_InputIterator __first, _InputIterator __last,
							      								    								     ^~~ /usr/include/c++/8/bits/stl_map.h:288:2: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: /usr/include/c++/8/bits/stl_map.h:271:2: note
							      								    								  : candidate: ‘template<class _InputIterator> std::
							      								    								  map<_Key, _Tp, _Compare, _Alloc>::map(_InputIterat
							      								    								  or, _InputIterator)’	 map(_InputIterator __first,
							      								    								   _InputIterator __last)   ^~~ /usr/include/c++/8/b
							      								    								  its/stl_map.h:271:2: note:   template argument ded
							      								    								  uction/substitution failed: /usr/include/c++/8/bit
							      								    								  s/stl_map.h:254:2: note: candidate: ‘template<clas
							      								    								  s _InputIterator> std::map<_Key, _Tp, _Compare, _A
							      								    								  lloc>::map(_InputIterator, _InputIterator, const a
							      								    								  llocator_type&)’   map(_InputIterator __first, _In
							      								    								  putIterator __last,	^~~ /usr/include/c++/8/bits/
							      								    								  stl_map.h:254:2: note:   template argument deducti
							      								    								  on/substitution failed: /usr/include/c++/8/bits/st
							      								    								  l_map.h:248:7: note: candidate: ‘std::map<_Key, _T
							      								    								  p, _Compare, _Alloc>::map(std::initializer_list<st
							      								    								  d::pair<const _Key, _Tp> >, const allocator_type&)
							      								    								   [with _Key = int; _Tp = int; _Compare = std::less
							      								    								  <int>; _Alloc = std::allocator<std::pair<const int
							      								    								  , int> >; std::map<_Key, _Tp, _Compare, _Alloc>::a
							      								    								  llocator_type = std::allocator<std::pair<const int
							      								    								  , int> >]’	    map(initializer_list<value_type>
							      								    								   __l, const allocator_type& __a)	  ^~~ /usr/i
							      								    								  nclude/c++/8/bits/stl_map.h:248:7: note:   convers
							      								    								  ion of argument 1 would be ill-formed: /usr/includ
							      								    								  e/c++/8/bits/stl_map.h:242:7: note: candidate: ‘st
							      								    								  d::map<_Key, _Tp, _Compare, _Alloc>::map(std::map<
							      								    								  _Key, _Tp, _Compare, _Alloc>&&, const allocator_ty
							      								    								  pe&) [with _Key = int; _Tp = int; _Compare = std::
							      								    								  less<int>; _Alloc = std::allocator<std::pair<const
							      								    								   int, int> >; std::map<_Key, _Tp, _Compare, _Alloc
							      								    								  >::allocator_type = std::allocator<std::pair<const
							      								    								   int, int> >]’	map(map&& __m, const allocat
							      								    								  or_type& __a)	       ^~~ /usr/include/c++/8/bits/s
							      								    								  tl_map.h:242:7: note:	  conversion of argument 1 w
							      								    								  ould be ill-formed: /usr/include/c++/8/bits/stl_ma
							      								    								  p.h:238:7: note: candidate: ‘std::map<_Key, _Tp, _
							      								    								  Compare, _Alloc>::map(const std::map<_Key, _Tp, _C
							      								    								  ompare, _Alloc>&, const allocator_type&) [with _Ke
							      								    								  y = int; _Tp = int; _Compare = std::less<int>; _Al
							      								    								  loc = std::allocator<std::pair<const int, int> >;
							      								    								  std::map<_Key, _Tp, _Compare, _Alloc>::allocator_t
							      								    								  ype = std::allocator<std::pair<const int, int> >]’
							      								    								  	  map(const map& __m, const allocator_type&
							      								    								  __a)	      ^~~ /usr/include/c++/8/bits/stl_map.h:
							      								    								  238:7: note:	 conversion of argument 1 would be i
							      								    								  ll-formed: /usr/include/c++/8/bits/stl_map.h:234:7
							      								    								  : note: candidate: ‘std::map<_Key, _Tp, _Compare,
							      								    								  _Alloc>::map(const allocator_type&) [with _Key = i
							      								    								  nt; _Tp = int; _Compare = std::less<int>; _Alloc =
							      								    								   std::allocator<std::pair<const int, int> >; std::
							      								    								  map<_Key, _Tp, _Compare, _Alloc>::allocator_type =
							      								    								   std::allocator<std::pair<const int, int> >]’
							      								    								     map(const allocator_type& __a)	   ^~~ /usr/
							      								    								  include/c++/8/bits/stl_map.h:234:7: note:   candid
							      								    								  ate expects 1 argument, 2 provided /usr/include/c+
							      								    								  +/8/bits/stl_map.h:226:7: note: candidate: ‘std::m
							      								    								  ap<_Key, _Tp, _Compare, _Alloc>::map(std::initiali
							      								    								  zer_list<std::pair<const _Key, _Tp> >, const _Comp
							      								    								  are&, const allocator_type&) [with _Key = int; _Tp
							      								    								   = int; _Compare = std::less<int>; _Alloc = std::a
							      								    								  llocator<std::pair<const int, int> >; std::map<_Ke
							      								    								  y, _Tp, _Compare, _Alloc>::allocator_type = std::a
							      								    								  llocator<std::pair<const int, int> >]’	map(
							      								    								  initializer_list<value_type> __l,	   ^~~ /usr/
							      								    								  include/c++/8/bits/stl_map.h:226:7: note:   conver
							      								    								  sion of argument 1 would be ill-formed: /usr/inclu
							      								    								  de/c++/8/bits/stl_map.h:213:7: note: candidate: ‘s
							      								    								  td::map<_Key, _Tp, _Compare, _Alloc>::map(std::map
							      								    								  <_Key, _Tp, _Compare, _Alloc>&&) [with _Key = int;
							      								    								   _Tp = int; _Compare = std::less<int>; _Alloc = st
							      								    								  d::allocator<std::pair<const int, int> >]’
							      								    								  map(map&&) = default;	       ^~~ /usr/include/c++/
							      								    								  8/bits/stl_map.h:213:7: note:	  candidate expects
							      								    								  1 argument, 2 provided /usr/include/c++/8/bits/stl
							      								    								  _map.h:205:7: note: candidate: ‘std::map<_Key, _Tp
							      								    								  , _Compare, _Alloc>::map(const std::map<_Key, _Tp,
							      								    								   _Compare, _Alloc>&) [with _Key = int; _Tp = int;
							      								    								  _Compare = std::less<int>; _Alloc = std::allocator
							      								    								  <std::pair<const int, int> >]’	map(const ma
							      								    								  p&) = default;	^~~ /usr/include/c++/8/bits/
							      								    								  stl_map.h:205:7: note:   candidate expects 1 argum
							      								    								  ent, 2 provided /usr/include/c++/8/bits/stl_map.h:
							      								    								  192:7: note: candidate: ‘std::map<_Key, _Tp, _Comp
							      								    								  are, _Alloc>::map(const _Compare&, const allocator
							      								    								  _type&) [with _Key = int; _Tp = int; _Compare = st
							      								    								  d::less<int>; _Alloc = std::allocator<std::pair<co
							      								    								  nst int, int> >; std::map<_Key, _Tp, _Compare, _Al
							      								    								  loc>::allocator_type = std::allocator<std::pair<co
							      								    								  nst int, int> >]’	   map(const _Compare& __com
							      								    								  p,	    ^~~ /usr/include/c++/8/bits/stl_map.h:19
							      								    								  2:7: note:   conversion of argument 1 would be ill
							      								    								  -formed: /usr/include/c++/8/bits/stl_map.h:183:7:
							      								    								  note: candidate: ‘std::map<_Key, _Tp, _Compare, _A
							      								    								  lloc>::map() [with _Key = int; _Tp = int; _Compare
							      								    								   = std::less<int>; _Alloc = std::allocator<std::pa
							      								    								  ir<const int, int> >]’	map() = default;
							      								    								      ^~~ /usr/include/c++/8/bits/stl_map.h:183:7: n
							      								    								  ote:	 candidate expects 0 arguments, 2 provided
							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_DIFFERENCE_PAIR_1				      FIND_MINIMUM_DIFFERENCE_PAIR_1				    FIND_MINIMUM_DIFFERENCE_PAIR_1				  FIND_MINIMUM_DIFFERENCE_PAIR_1
--							      --							    --								  --
def findMinDiff ( arr , n ) :				      int findMinDiff ( int arr [ ] , int n ) {			    int findMinDiff ( int arr [ ] , int n ) {			  failure : #Results: 9, 10
    arr = sorted ( arr )				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    diff = 10 ** 20					      	int diff = INT_MAX ;					      int diff = 10 * 20 ;					  
    for i in range ( n - 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if arr [ i + 1 ] - arr [ i ] < diff :		      	i < n - 1 ;						      i < n - 1 ;						  
	    diff = arr [ i + 1 ] - arr [ i ]		      	i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [   i ++ ) {							  
    return diff						      	return diff ;						    	if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i +  
							      }								      }								  
							      								      return diff ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		      FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		    FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		  FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS
--							      --							    --								  --
def CountSquares ( a , b ) :				      int countSquares ( int a , int b ) {			    int CountSquares ( int a , int b ) {			  failure : #Results: 5, 10
    cnt = 0						      	int cnt = 0 ;						      int cnt = 0 ;						  
    for i in range ( a , b + 1 ) :			      	for ( int i = a ;					      for ( int i = a ;						  
	j = 1 ;						      	i <= b ;						      i <= b ;							  
	while j * j <= i :				      	i ++ ) for ( int j = 1 ;				      i ++ ) {							  
	    if j * j == i :				      	j * j <= i ;						    	int j = 1 ;						  
		cnt = cnt + 1				      	j ++ ) if ( j * j == i ) cnt ++ ;			    	;							  
	    j = j + 1					      	return cnt ;						    	while ( j * j <= i ) {					  
	i = i + 1					      }								    	  if ( j * j == i ) cnt = cnt + 1 ;			  
    return cnt						      								    	  j = j + 1 ;						  
							      								    	}							  
							      								    	i = i + 1 ;						  
							      								      }								  
							      								      return cnt ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BREAK_NUMBER_THREE_PARTS				      BREAK_NUMBER_THREE_PARTS					    BREAK_NUMBER_THREE_PARTS					  BREAK_NUMBER_THREE_PARTS
--							      --							    --								  --
def count_of_ways ( n ) :				      ll count_of_ways ( ll n ) {				    public : int countOfWays ( int n ) {			  script_not_found : None
    count = 0						      	ll count = 0 ;						      int count = 0 ;						  
    for i in range ( 0 , n + 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( 0 , n + 1 ) :			      	i <= n ;						      i <= n ;							  
	    for k in range ( 0 , n + 1 ) :		      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		if ( i + j + k == n ) :			      	j <= n ;						    	for ( int j = 0 ;					  
		    count = count + 1			      	j ++ ) for ( int k = 0 ;				    	j <= n ;						  
    return count					      	k <= n ;						    	j ++ ) {						  
							      	k ++ ) if ( i + j + k == n ) count ++ ;			    	  for ( int k = 0 ;					  
							      	return count ;						    	  k <= n ;						  
							      }								    	  k ++ ) {						  
							      								    	    if ( ( i + j + k ) == n ) {				  
							      								    	      count = count + 1 ;				  
							      								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FRIENDS_PAIRING_PROBLEM_2				      FRIENDS_PAIRING_PROBLEM_2					    FRIENDS_PAIRING_PROBLEM_2					  FRIENDS_PAIRING_PROBLEM_2
--							      --							    --								  --
def countFriendsPairings ( n ) :			      int countFriendsPairings ( int n ) {			    public : int countFriendsPairings ( int n ) {		  error : FRIENDS_PAIRING_PROBLEM_2.cpp:32:1: error:
    a , b , c = 1 , 2 , 0				      	int a = 1 , b = 2 , c = 0 ;				      int a = 1 , b = 2 , c = 0 ;				   expected unqualified-id before ‘public’  public :
    if ( n <= 2 ) :					      	if ( n <= 2 ) {						      if ( ( n <= 2 ) && ( n > 3 ) ) return n ;			   int f_filled ( int n ) {  ^~~~~~ FRIENDS_PAIRING_
	return n					      	  return n ;						      for ( int i = 3 ;						  PROBLEM_2.cpp: In function ‘int main()’: FRIENDS_P
    for i in range ( 3 , n + 1 ) :			      	}							      i <= n ;							  AIRING_PROBLEM_2.cpp:51:12: error: ‘f_filled’ was
	c = b + ( i - 1 ) * a				      	for ( int i = 3 ;					      i ++ ) {							  not declared in this scope	      if(f_filled(pa
	a = b						      	i <= n ;						    	c = b + ( i - 1 ) * a ;					  ram0[i]) == f_gold(param0[i]))	     ^~~~~~~
	b = c						      	i ++ ) {						    	a = b ;							  ~ FRIENDS_PAIRING_PROBLEM_2.cpp:51:12: note: sugge
    return c						      	  c = b + ( i - 1 ) * a ;				    	b = c ;							  sted alternative: ‘f_gold’	      if(f_filled(pa
							      	  a = b ;						      }								  ram0[i]) == f_gold(param0[i]))	     ^~~~~~~
							      	  b = c ;						      return c ;						  ~		f_gold
							      	}							    }								  
							      	return c ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1	      EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1		    EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1		  EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1
--							      --							    --								  --
def exponentiation ( bas , exp ) :			      long exponentiation ( long base , long exp ) {		    long long exponentiation ( long long bas , long long exp ) {  script_not_found : None
    t = 1						      	long t = 1L ;						      long long t = 1 ;						  
    while ( exp > 0 ) :					      	while ( exp > 0 ) {					      while ( ( exp > 0 ) && ( exp < N ) ) {			  
	if ( exp % 2 != 0 ) :				      	  if ( exp % 2 != 0 ) t = ( t * base ) % N ;		    	if ( ( exp % 2 != 0 ) || ( exp % 2 == 0 ) ) t = ( t * bas 
	    t = ( t * bas ) % N				      	  base = ( base * base ) % N ;				    	bas = ( bas * bas ) % N ;				  
	bas = ( bas * bas ) % N				      	  exp /= 2 ;						    	exp = ( long long ) ( exp / 2 ) ;			  
	exp = int ( exp / 2 )				      	}							      }								  
    return t % N					      	return t % N ;						      return t % N ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y
--							      --							    --								  --
def countSolutions ( n ) :				      int countSolutions ( int n ) {				    int countSolutions ( int n ) {				  success : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    x = 0						      	for ( int x = 0 ;					      int x = 0 ;						  
    while ( x * x < n ) :				      	x * x < n ;						      while ( ( x * x < n ) && ( x * x < n ) ) {		  
	y = 0						      	x ++ ) for ( int y = 0 ;				    	int y = 0 ;						  
	while ( x * x + y * y < n ) :			      	x * x + y * y < n ;					    	while ( ( x * x + y * y < n ) && ( x * x + y * y < n ) )  
	    res = res + 1				      	y ++ ) res ++ ;						    	  res = res + 1 ;					  
	    y = y + 1					      	return res ;						    	  y = y + 1 ;						  
	x = x + 1					      }								    	}							  
    return res						      								    	x = x + 1 ;						  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			      DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			    DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			  DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM
--							      --							    --								  --
def maximizecube ( l , b , h ) :			      void maximizecube ( int l , int b , int h ) {		    void maximizecube ( int l , int b , int h ) {		  script_not_found : None
    side = gcd ( l , gcd ( b , h ) )			      	int side = __gcd ( l , __gcd ( b , h ) ) ;		      int side = gcd ( l , gcd ( b , h ) ) ;			  
    num = int ( l / side )				      	int num = l / side ;					      int num = ( int ) ( l / side ) ;				  
    num = int ( num * b / side )			      	num = ( num * b / side ) ;				      num = ( int ) ( num * b / side ) ;			  
    num = int ( num * h / side )			      	num = ( num * h / side ) ;				      num = ( int ) ( num * h / side ) ;			  
    print ( side , num )				      	cout << side << " " << num << endl ;			      cout << side << " " << num << endl ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_XOR_VALUE_PAIR					      MINIMUM_XOR_VALUE_PAIR					    MINIMUM_XOR_VALUE_PAIR					  MINIMUM_XOR_VALUE_PAIR
--							      --							    --								  --
def minXOR ( arr , n ) :				      int minXOR ( int arr [ ] , int n ) {			    int minXOR ( int arr [ ] , int n ) {			  success : None
    arr.sort ( )					      	int min_xor = INT_MAX ;					      sort ( arr , arr + n ) ;					  
    min_xor = 999999					      	for ( int i = 0 ;					      int min_xor = 999999 ;					  
    val = 0						      	i < n ;							      int val ;							  
    for i in range ( 0 , n - 1 ) :			      	i ++ ) for ( int j = i + 1 ;				      for ( int i = 0 ;						  
	for j in range ( i + 1 , n - 1 ) :		      	j < n ;							      i <= n - 1 ;						  
	    val = arr [ i ] ^ arr [ j ]			      	j ++ ) min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] ) ;    i ++ ) {							  
	    min_xor = min ( min_xor , val )		      	return min_xor ;					    	for ( int j = i + 1 ;					  
    return min_xor					      }								    	j <= n - 1 ;						  
							      								    	j ++ ) {						  
							      								    	  val = arr [ i ] ^ arr [ j ] ;				  
							      								    	  min_xor = min ( min_xor , val ) ;			  
							      								    	}							  
							      								      }								  
							      								      return min_xor ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		      FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		    FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		  FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1
--							      --							    --								  --
def maxProduct ( arr , n ) :				      int maxProduct ( int arr [ ] , int n ) {			    int maxProduct ( int arr [ ] , int n ) {			  success : identical to gold
    if n < 3 :						      	if ( n < 3 ) return - 1 ;				      if ( n < 3 ) return - 1 ;					  
	return - 1					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    arr.sort ( )					      	return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [    return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [  
    return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_BY_7					      DIVISIBILITY_BY_7						    DIVISIBILITY_BY_7						  DIVISIBILITY_BY_7
--							      --							    --								  --
def isDivisibleBy7 ( num ) :				      int isDivisibleBy7 ( int num ) {				    bool isDivisibleBy7 ( int num ) {				  timeout : None
    if num < 0 :					      	if ( num < 0 ) return isDivisibleBy7 ( - num ) ;	      if ( num < 0 ) return isDivisibleBy7 ( - num ) ;		  
	return isDivisibleBy7 ( - num )			      	if ( num == 0 || num == 7 ) return 1 ;			      if ( ( num == 0 || num == 7 ) && ( num < 10 ) ) return true 
    if ( num == 0 or num == 7 ) :			      	if ( num < 10 ) return 0 ;				      if ( ( num < 10 ) && ( num > 7 ) ) return false ;		  
	return True					      	return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 1   return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 1 
    if ( num < 10 ) :					      }								    }								  
	return False					      								    								  
    return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERIAN_NUMBER						      EULERIAN_NUMBER						    EULERIAN_NUMBER						  EULERIAN_NUMBER
--							      --							    --								  --
def eulerian ( n , m ) :				      int eulerian ( int n , int m ) {				    double eulerian ( int n , int m ) {				  script_not_found : None
    if ( m >= n or n == 0 ) :				      	if ( m >= n || n == 0 ) return 0 ;			      if ( ( m >= n || n == 0 ) && ( m > 0 ) ) return 0 ;	  
	return 0					      	if ( m == 0 ) return 1 ;				      if ( ( m == 0 ) || ( m < 0 ) ) return 1 ;			  
    if ( m == 0 ) :					      	return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) *   return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) 
	return 1					      }								    }								  
    return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	      RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	    RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	  RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY
--							      --							    --								  --
def recSearch ( arr , l , r , x ) :			      int recSearch ( int arr [ ] , int l , int r , int x ) {	    int recSearch ( int arr [ ] , int l , int r , int x ) {	  success : identical to gold
    if r < l :						      	if ( r < l ) return - 1 ;				      if ( r < l ) return - 1 ;					  
	return - 1					      	if ( arr [ l ] == x ) return l ;			      if ( arr [ l ] == x ) return l ;				  
    if arr [ l ] == x :					      	if ( arr [ r ] == x ) return r ;			      if ( arr [ r ] == x ) return r ;				  
	return l					      	return recSearch ( arr , l + 1 , r - 1 , x ) ;		      return recSearch ( arr , l + 1 , r - 1 , x ) ;		  
    if arr [ r ] == x :					      }								    }								  
	return r					      								    								  
    return recSearch ( arr , l + 1 , r - 1 , x )	      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS
--							      --							    --								  --
def numofsubset ( arr , n ) :				      int numofsubset ( int arr [ ] , int n ) {			    int numofsubset ( int arr [ ] , int n ) {			  error : COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_
    x = sorted ( arr )					      	sort ( arr , arr + n ) ;				      int x [ n ] ;						  CONSECUTIVE_NUMBERS.cpp: In function ‘int f_filled
    count = 1						      	int count = 1 ;						      sort ( x , x + n ) ;					  (int*, int)’: COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQU
    for i in range ( 0 , n - 1 ) :			      	for ( int i = 0 ;					      int count = 1 ;						  ENCES_CONSECUTIVE_NUMBERS.cpp:42:12: error: a func
	if ( x [ i ] + 1 != x [ i + 1 ] ) :		      	i < n - 1 ;						      for ( int i = 0 ;						  tion-definition is not allowed here before ‘{’ tok
	    count = count + 1				      	i ++ ) {						      i <= n - 1 ;						  en  int main() {	       ^ COUNT_MINIMUM_NUMBE
    return count					      	  if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ;	      i ++ ) {							  R_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS.cpp:55:
							      	}							    	if ( ( x [ i ] + 1 != x [ i + 1 ] ) && ( x [ i ] + 1 != x 1: error: expected ‘}’ at end of input  }  ^ COUNT
							      	return count ;						    	  count = count + 1 ;					  _MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_N
							      }								    	}							  UMBERS.cpp:28:38: note: to match this ‘{’  int f_f
							      								      }								  illed ( int arr [ ] , int n ) {
							      								      return count ;						  		      ^
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_BINARY_DECIMAL_CONVERSION_1			      PROGRAM_BINARY_DECIMAL_CONVERSION_1			    PROGRAM_BINARY_DECIMAL_CONVERSION_1				  PROGRAM_BINARY_DECIMAL_CONVERSION_1
--							      --							    --								  --
def binaryToDecimal ( n ) :				      int binaryToDecimal ( string n ) {			    int binaryToDecimal ( string n ) {				  failure : #Results: 6, 10
    num = n						      	string num = n ;					      string num = n ;						  
    dec_value = 0					      	int dec_value = 0 ;					      int decValue = 0 ;					  
    base1 = 1						      	int base = 1 ;						      int base1 = 1 ;						  
    len1 = len ( num )					      	int len = num . length ( ) ;				      int len1 = num . length ( ) ;				  
    for i in range ( len1 - 1 , - 1 , - 1 ) :		      	for ( int i = len - 1 ;					      for ( int i = len1 - 1 ;					  
	if ( num [ i ] == '1' ) :			      	i >= 0 ;						      i >= 0 ;							  
	    dec_value += base1				      	i -- ) {						      i -- ) {							  
	base1 = base1 * 2				      	  if ( num [ i ] == '1' ) dec_value += base ;		    	if ( ( num [ i ] == '1' ) || ( num [ i ] == '0' ) ) decVa 
    return dec_value					      	  base = base * 2 ;					    	base1 = base1 * 2 ;					  
							      	}							      }								  
							      	return dec_value ;					      return decValue ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	      COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	    COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	  COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS
--							      --							    --								  --
def countSubstringWithEqualEnds ( s ) :			      int countSubstringWithEqualEnds ( string s ) {		    int countSubstringWithEqualEnds ( string s ) {		  success : None
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    n = len ( s )					      	int n = s . length ( ) ;				      int n = s . size ( ) ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i , n ) :			      	i < n ;							      i < n ;							  
	    if ( s [ i ] == s [ j ] ) :			      	i ++ ) for ( int j = i ;				      i ++ ) {							  
		result = result + 1			      	j < n ;							    	for ( int j = i ;					  
    return result					      	j ++ ) if ( s [ i ] == s [ j ] ) result ++ ;		    	j < n ;							  
							      	return result ;						    	j ++ ) {						  
							      }								    	  if ( ( s [ i ] == s [ j ] ) && ( s [ i ] == s [ j ] ) ) 
							      								    	    result = result + 1 ;				  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BINARY_SEARCH_1						      BINARY_SEARCH_1						    BINARY_SEARCH_1						  BINARY_SEARCH_1
--							      --							    --								  --
def binarySearch ( arr , l , r , x ) :			      int binarySearch ( int arr [ ] , int l , int r , int x ) {    int binarySearch ( int arr [ ] , int l , int r , int x ) {	  script_not_found : None
    while l <= r :					      	while ( l <= r ) {					      while ( l <= r ) {					  
	mid = l + ( r - l ) // 2			      	  int m = l + ( r - l ) / 2 ;				    	int mid = l + ( r - l ) / 2 ;				  
	if arr [ mid ] == x :				      	  if ( arr [ m ] == x ) return m ;			    	if ( arr [ mid ] == x ) return mid ;			  
	    return mid					      	  if ( arr [ m ] < x ) l = m + 1 ;			    	else if ( arr [ mid ] < x ) l = mid + 1 ;		  
	elif arr [ mid ] < x :				      	  else r = m - 1 ;					    	else r = mid - 1 ;					  
	    l = mid + 1					      	}							      }								  
	else :						      	return - 1 ;						      return - 1 ;						  
	    r = mid - 1					      }								    }								  
    return - 1						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION			      PROGRAM_DECIMAL_BINARY_CONVERSION				    PROGRAM_DECIMAL_BINARY_CONVERSION				  PROGRAM_DECIMAL_BINARY_CONVERSION
--							      --							    --								  --
def decToBinary ( n ) :					      void decToBinary ( int n ) {				    void decToBinary ( int n ) {				  script_not_found : None
    binaryNum = [ 0 ] * n				      	int binaryNum [ 32 ] ;					      int binaryNum [ n ] ;					  
    i = 0						      	int i = 0 ;						      int i = 0 ;						  
    while ( n > 0 ) :					      	while ( n > 0 ) {					      while ( ( n > 0 ) && ( i < n ) ) {			  
	binaryNum [ i ] = n % 2				      	  binaryNum [ i ] = n % 2 ;				    	binaryNum [ i ] = n % 2 ;				  
	n = int ( n / 2 )				      	  n = n / 2 ;						    	n = ( int ) ( n / 2 ) ;					  
	i += 1						      	  i ++ ;						    	i ++ ;							  
    for j in range ( i - 1 , - 1 , - 1 ) :		      	}							      }								  
	print ( binaryNum [ j ] , end = "" )		      	for ( int j = i - 1 ;					      for ( int j = i - 1 ;					  
							      	j >= 0 ;						      j >= 0 ;							  
							      	j -- ) cout << binaryNum [ j ] ;			      j -- ) {							  
							      }								    	cout << binaryNum [ j ] << " " ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		      HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		    HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		  HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION
--							      --							    --								  --
def mulmod ( a , b , mod ) :				      ll mulmod ( ll a , ll b , ll mod ) {			    int mulmod ( int a , int b , int mod ) {			  script_not_found : None
    res = 0						      	ll res = 0 ;						      int res = 0 ;						  
    a = a % mod						      	a = a % mod ;						      a = a % mod ;						  
    while ( b > 0 ) :					      	while ( b > 0 ) {					      while ( ( b > 0 ) && ( ( b % 2 == 1 ) || ( b % 2 == 0 ) ) ) 
	if ( b % 2 == 1 ) :				      	  if ( b % 2 == 1 ) res = ( res + a ) % mod ;		    	if ( ( b % 2 == 1 ) || ( b % 2 == 0 ) ) res = ( res + a ) 
	    res = ( res + a ) % mod			      	  a = ( a * 2 ) % mod ;					    	a = ( a * 2 ) % mod ;					  
	a = ( a * 2 ) % mod				      	  b /= 2 ;						    	b /= 2 ;						  
	b //= 2						      	}							      }								  
    return res % mod					      	return res % mod ;					      return res %						  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NON_REPEATING_ELEMENT_1					      NON_REPEATING_ELEMENT_1					    NON_REPEATING_ELEMENT_1					  NON_REPEATING_ELEMENT_1
--							      --							    --								  --
def firstNonRepeating ( arr , n ) :			      int firstNonRepeating ( int arr [ ] , int n ) {		    int firstNonRepeating ( int arr [ ] , int n ) {		  success : None
    mp = defaultdict ( lambda : 0 )			      	unordered_map < int , int > mp ;			      map < int , int > mp ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	mp [ arr [ i ] ] += 1				      	i < n ;							      i < n ;							  
    for i in range ( n ) :				      	i ++ ) mp [ arr [ i ] ] ++ ;				      i ++ ) mp [ arr [ i ] ] ++ ;				  
	if mp [ arr [ i ] ] == 1 :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    return arr [ i ]				      	i < n ;							      i < n ;							  
    return - 1						      	i ++ ) if ( mp [ arr [ i ] ] == 1 ) return arr [ i ] ;	      i ++ ) if ( mp [ arr [ i ] ] == 1 ) return arr [ i ] ;	  
							      	return - 1 ;						      return - 1 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS		      MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS			    MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS			  MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS
--							      --							    --								  --
def middleOfThree ( a , b , c ) :			      int middleOfThree ( int a , int b , int c ) {		    int middleOfThree ( int a , int b , int c ) {		  error : MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS.
    if ( ( a < b and b < c ) or ( c < b and b < a ) ) :	      	if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ;    if ( ( ( a < b && b < c ) || ( c < b && b < a ) ) && ( ( b  cpp: In function ‘int f_filled(int, int, int)’: MI
	return b					      	else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return   if ( ( ( b < a && a < c ) || ( c < a && a < b ) ) && ( ( c  DDLE_OF_THREE_USING_MINIMUM_COMPARISONS.cpp:25:76:
    if ( ( b < a and a < c ) or ( c < a and a < b ) ) :	      	else return c ;						    								   error: expected ‘)’ before ‘int’    if ( ( ( b <
	return a					      }								    								  a && a < c ) || ( c < a && a < b ) ) && ( ( c < a
    else :						      								    								  && a < b )
	return c					      								    								  		   ~		       ^
							      								    								  
							      								    								  		 ) MIDDLE_OF_THREE_USING_MINIMUM_COM
							      								    								  PARISONS.cpp:27:1:  int main() {  ~~~
							      								    								  
							      								    								  	     MIDDLE_OF_THREE_USING_MINIMUM_COMPARISO
							      								    								  NS.cpp:41:2: error: expected ‘)’ at end of input
							      								    								  }  ~^	  ) MIDDLE_OF_THREE_USING_MINIMUM_COMPARISON
							      								    								  S.cpp:25:6: note: to match this ‘(’	 if ( ( ( b
							      								    								  < a && a < c ) || ( c < a && a < b ) ) && ( ( c <
							      								    								  a && a < b )	     ^ MIDDLE_OF_THREE_USING_MINIMUM
							      								    								  _COMPARISONS.cpp:41:1: error: expected statement a
							      								    								  t end of input  }  ^ MIDDLE_OF_THREE_USING_MINIMUM
							      								    								  _COMPARISONS.cpp:41:1: error: expected ‘}’ at end
							      								    								  of input MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS
							      								    								  .cpp:23:40: note: to match this ‘{’  int f_filled
							      								    								  ( int a , int b , int c ) {
							      								    								  		    ^ MIDDLE_OF_THREE_USING_MINIMUM_
							      								    								  COMPARISONS.cpp:41:1: warning: control reaches end
							      								    								   of non-void function [-Wreturn-type]	 }  ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_
--							      --							    --								  --
def multiply ( x , y ) :				      public : int multiply ( int x , int y ) {			    int multiply ( int x , int y ) {				  script_not_found : None
    if ( y == 0 ) :					      	if ( y == 0 ) return 0 ;				      if ( ( y == 0 ) || ( y > 0 ) ) return 0 ;			  
	return 0					      	if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ;	      if ( ( y < 0 ) || ( y < - 1 ) ) return ( x + multiply ( x , 
    if ( y > 0 ) :					      	if ( y < 0 ) return - multiply ( x , - y ) ;		      if ( ( y < 0 ) || ( y < - 1 ) ) return - multiply ( x , - y 
	return ( x + multiply ( x , y - 1 ) )		      }								      return 0 ;						  
    if ( y < 0 ) :					      								    }								  
	return - multiply ( x , - y )			      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LOWER_CASE_UPPER_CASE_INTERESTING_FACT			      LOWER_CASE_UPPER_CASE_INTERESTING_FACT			    LOWER_CASE_UPPER_CASE_INTERESTING_FACT			  LOWER_CASE_UPPER_CASE_INTERESTING_FACT
--							      --							    --								  --
def to_upper ( string ) :				      string to_upper ( string & in ) {				    void to_upper ( std :: string & string ) {			  script_not_found : None
    for i in range ( len ( string ) ) :			      	for ( int i = 0 ;					      for ( size_t i = 0 ;					  
	if ( 'a' <= string [ i ] <= 'z' ) :		      	i < in . length ( ) ;					      i < string . size ( ) ;					  
	    string = ( string [ 0 : i ] + chr ( ord ( string  	i ++ ) if ( 'a' <= in [ i ] <= 'z' ) in [ i ] = in [ i ] -    ++ i ) {							  
    return string					      	return in ;						    	if ( ( 'a' <= string [ i ] && string [ i ] <= 'z' ) || (  
							      }								    	  string . erase ( i , 1 ) ;				  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS	      MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS		    MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS		  MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS
--							      --							    --								  --
def findMinSum ( a , b , n ) :				      long long int findMinSum ( int a [ ] , int b [ ] , int n ) {  int findMinSum ( vector < int > & a , vector < int > & b , in script_not_found : None
    a.sort ( )						      	sort ( a , a + n ) ;					      sort ( a . begin ( ) , a . end ( ) ) ;			  
    b.sort ( )						      	sort ( b , b + n ) ;					      sort ( b . begin ( ) , b . end ( ) ) ;			  
    sum = 0						      	long long int sum = 0 ;					      int sum = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	sum = sum + abs ( a [ i ] - b [ i ] )		      	i < n ;							      i < n ;							  
    return sum						      	i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ) ;		      i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ) ;		  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	      DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	    DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	  DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1
--							      --							    --								  --
def checkCount ( arr , n , k ) :			      bool checkCount ( int arr [ ] , int n , int k ) {		    bool checkCount ( int arr [ ] , int n , int k ) {		  success : None
    mp = defaultdict ( lambda : 0 )			      	unordered_map < int , int > hash ;			      map < int , int > mp ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	mp [ arr [ i ] ] += 1				      	i < n ;							      i < n ;							  
    for key , values in mp.items ( ) :			      	i ++ ) hash [ arr [ i ] ] ++ ;				      i ++ ) mp [ arr [ i ] ] ++ ;				  
	if values > 2 * k :				      	for ( auto x : hash ) if ( x . second > 2 * k ) return fals   for ( map < int , int > :: iterator it = mp . begin ( ) ;	  
	    return False				      	return true ;						      it != mp . end ( ) ;					  
    return True						      }								      it ++ ) if ( it -> second > 2 * k ) return false ;	  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_NON_FIBONACCI_NUMBER				      NTH_NON_FIBONACCI_NUMBER					    NTH_NON_FIBONACCI_NUMBER					  NTH_NON_FIBONACCI_NUMBER
--							      --							    --								  --
def nonFibonacci ( n ) :				      int nonFibonacci ( int n ) {				    public : int nonFibonacci ( int n ) {			  error : NTH_NON_FIBONACCI_NUMBER.cpp:29:1: error:
    prevPrev = 1					      	int prevPrev = 1 , prev = 2 , curr = 3 ;		      int prevPrev = 1 ;					  expected unqualified-id before ‘public’  public :
    prev = 2						      	while ( n > 0 ) {					      int prev = 2 ;						  int f_filled ( int n ) {  ^~~~~~ NTH_NON_FIBONACCI
    curr = 3						      	  prevPrev = prev ;					      int curr = 3 ;						  _NUMBER.cpp: In function ‘int main()’: NTH_NON_FIB
    while n > 0 :					      	  prev = curr ;						      while ( n > 0 ) {						  ONACCI_NUMBER.cpp:49:12: error: ‘f_filled’ was not
	prevPrev = prev					      	  curr = prevPrev + prev ;				    	prevPrev = prev ;					   declared in this scope	   if(f_filled(param
	prev = curr					      	  n = n - ( curr - prev - 1 ) ;				    	prev = curr ;						  0[i]) == f_gold(param0[i]))		  ^~~~~~~~ N
	curr = prevPrev + prev				      	}							    	curr = prevPrev + prev ;				  TH_NON_FIBONACCI_NUMBER.cpp:49:12: note: suggested
	n = n - ( curr - prev - 1 )			      	n = n + ( curr - prev - 1 ) ;				    	n = n - ( curr - prev - 1 ) ;				   alternative: ‘f_gold’	  if(f_filled(param0
    n = n + ( curr - prev - 1 )				      	return prev + n ;					      }								  [i]) == f_gold(param0[i]))		 ^~~~~~~~
    return prev + n					      }								      n = n + ( curr - prev - 1 ) ;				  	    f_gold
							      								      return prev + n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_XOR_VALUE_PAIR_1				      MINIMUM_XOR_VALUE_PAIR_1					    MINIMUM_XOR_VALUE_PAIR_1					  MINIMUM_XOR_VALUE_PAIR_1
--							      --							    --								  --
def minXOR ( arr , n ) :				      int minXOR ( int arr [ ] , int n ) {			    int minXOR ( int arr [ ] , int n ) {			  failure : #Results: 9, 10
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    minXor = int ( sys.float_info.max )			      	int minXor = INT_MAX ;					      int minXor = ( int ) INT_MAX ;				  
    val = 0						      	int val = 0 ;						      int val ;							  
    for i in range ( 0 , n - 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	val = arr [ i ] ^ arr [ i + 1 ]			      	i < n - 1 ;						      i <= n - 1 ;						  
	minXor = min ( minXor , val )			      	i ++ ) {						      i ++ ) {							  
    return minXor					      	  val = arr [ i ] ^ arr [ i + 1 ] ;			    	val = arr [ i ] ^ arr [ i + 1 ] ;			  
							      	  minXor = min ( minXor , val ) ;			    	minXor = min ( minXor , val ) ;				  
							      	}							      }								  
							      	return minXor ;						      return minXor ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1
--							      --							    --								  --
def isPowerOfFour ( n ) :				      bool isPowerOfFour ( unsigned int n ) {			    bool isPowerOfFour ( unsigned n ) {				  error : FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_
    count = 0						      	int count = 0 ;						      int count = 0 ;						  4_OR_NOT_1.cpp: In function ‘bool f_filled(unsigne
    if ( n and ( not ( n & ( n - 1 ) ) ) ) :		      	if ( n && ! ( n & ( n - 1 ) ) ) {			      if ( ( n > 0 ) && ( ! ( n & ( n - 1 ) ) ) ) {		  d int)’: FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF
	while ( n > 1 ) :				      	  while ( n > 1 ) {					    	while ( ( n > 1 ) && ( n & ( n - 1 ) ) ) {		  _4_OR_NOT_1.cpp:46:12: error: a function-definitio
	    n >>= 1					      	    n >>= 1 ;						    	  n >>= 1 ;						  n is not allowed here before ‘{’ token  int main()
	    count += 1					      	    count += 1 ;					    	  count ++ ;						   {		 ^ FIND_WHETHER_A_GIVEN_NUMBER_IS_A_
	if ( count % 2 == 0 ) :				      	  }							    	}							  POWER_OF_4_OR_NOT_1.cpp:58:1: error: expected ‘}’
	    return True					      	  return ( count % 2 == 0 ) ? 1 : 0 ;			    	if ( ( count % 2 == 0 ) && ( n & ( n - 1 ) ) ) {	  at end of input  }  ^ FIND_WHETHER_A_GIVEN_NUMBER_
	else :						      	}							    	  return true ;						  IS_A_POWER_OF_4_OR_NOT_1.cpp:29:30: note: to match
	    return False				      	return 0 ;						    	}							   this ‘{’  bool f_filled ( unsigned n ) {
							      }								    	else {							  			^
							      								    	  return false ;					  
							      								    	}							  
							      								      }								  
							      								      return false ;						  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NON_REPEATING_ELEMENT					      NON_REPEATING_ELEMENT					    NON_REPEATING_ELEMENT					  NON_REPEATING_ELEMENT
--							      --							    --								  --
def firstNonRepeating ( arr , n ) :			      int firstNonRepeating ( int arr [ ] , int n ) {		    int firstNonRepeating ( int arr [ ] , int n ) {		  error : NON_REPEATING_ELEMENT.cpp: In function ‘in
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  t f_filled(int*, int)’: NON_REPEATING_ELEMENT.cpp:
	j = 0						      	i < n ;							      i < n ;							  39:33: error: expected ‘]’ before ‘int’      if (
	while ( j < n ) :				      	i ++ ) {						      i ++ ) {							  ( j == n ) && ( arr [ i
	    if ( i != j and arr [ i ] == arr [ j ] ) :	      	  int j ;						    	int j = 0 ;						  	 ^				    ] NON_RE
		break					      	  for ( j = 0 ;						    	while ( ( j < n ) && ( arr [ i ] == arr [ j ] ) ) {	  PEATING_ELEMENT.cpp:41:1:  int main() {  ~~~
	    j += 1					      	  j < n ;						    	  if ( ( i != j && arr [ i ] == arr [ j ] ) || ( j == n ) 			   NON_REPEATING_ELEMENT.cpp
	if ( j == n ) :					      	  j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ;    	  j ++ ;						  :39:33: error: expected ‘)’ before ‘int’	if (
	    return arr [ i ]				      	  if ( j == n ) return arr [ i ] ;			    	}							   ( j == n ) && ( arr [ i			   ~
    return - 1						      	}							    	if ( ( j == n ) && ( arr [ i				  	  ^				     ) NON_R
							      	return - 1 ;						    								  EPEATING_ELEMENT.cpp:41:1:  int main() {  ~~~
							      }								    								  			    NON_REPEATING_ELEMENT.cp
							      								    								  p:54:2: error: expected ‘)’ at end of input  }  ~^
							      								    								     ) NON_REPEATING_ELEMENT.cpp:39:8: note: to matc
							      								    								  h this ‘(’	  if ( ( j == n ) && ( arr [ i
							      								    								     ^ NON_REPEATING_ELEMENT.cpp:54:1: error: expect
							      								    								  ed statement at end of input	}  ^ NON_REPEATING_E
							      								    								  LEMENT.cpp:54:1: error: expected ‘}’ at end of inp
							      								    								  ut NON_REPEATING_ELEMENT.cpp:33:10: note: to match
							      								    								   this ‘{’    i ++ ) {		  ^ NON_REPEATING_EL
							      								    								  EMENT.cpp:54:1: error: expected ‘}’ at end of inpu
							      								    								  t  }	^ NON_REPEATING_ELEMENT.cpp:30:38: note: to
							      								    								  match this ‘{’  int f_filled ( int arr [ ] , int n
							      								    								   ) {					     ^ NON_R
							      								    								  EPEATING_ELEMENT.cpp:54:1: warning: no return stat
							      								    								  ement in function returning non-void [-Wreturn-typ
							      								    								  e]  }	 ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC	      MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC	    MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC		  MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC
--							      --							    --								  --
def power ( x , y , p ) :				      int power ( int x , unsigned int y , int p ) {		    int power ( int x , int y , int p ) {			  failure : #Results: 4, 10
    res = 1						      	int res = 1 ;						      int res = 1 ;						  
    x = x % p						      	x = x % p ;						      x = x % p ;						  
    while ( y > 0 ) :					      	while ( y > 0 ) {					      while ( ( y > 0 ) && ( ( y & 1 ) == 1 ) ) {		  
	if ( ( y & 1 ) == 1 ) :				      	  if ( y & 1 ) res = ( res * x ) % p ;			    	if ( ( ( y & 1 ) == 1 ) || ( ( y & 2 ) == 2 ) ) res = ( r 
	    res = ( res * x ) % p			      	  y = y >> 1 ;						    	y = y >> 1 ;						  
	y = y >> 1					      	  x = ( x * x ) % p ;					    	x = ( x * x ) % p ;					  
	x = ( x * x ) % p				      	}							      }								  
    return res						      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K	      PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K		    PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K		  PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K
--							      --							    --								  --
def isPossible ( a , b , n , k ) :			      bool isPossible ( int a [ ] , int b [ ] , int n , int k ) {   bool isPossible ( int * a , int * b , int n , int k ) {	  error : /bin/bash: line 1: 2965575 Segmentation fa
    a.sort ( reverse = True )				      	sort ( a , a + n ) ;					      sort ( a , b + n ) ;					  ult	   (core dumped) ./PERMUTE_TWO_ARRAYS_SUM_EV
    b.sort ( )						      	sort ( b , b + n , greater < int > ( ) ) ;		      sort ( b , a + n ) ;					  ERY_PAIR_GREATER_EQUAL_K_cpp
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( a [ i ] + b [ i ] < k ) :			      	i < n ;							      i < n ;							  
	    return False				      	i ++ ) if ( a [ i ] + b [ i ] < k ) return false ;	      i ++ ) {							  
    return True						      	return true ;						    	if ( ( a [ i ] + b [ i ] < k ) && ( a [ i ] + b [ i ] > k 
							      }								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		      PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		    PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		  PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2
--							      --							    --								  --
def printDistinct ( arr , n ) :				      void printDistinct ( int arr [ ] , int n ) {		    void printDistinct ( int arr [ ] , int n ) {		  script_not_found : None
    s = dict ( )					      	unordered_set < int > s ;				      map < int , int > s ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( arr [ i ] not in s.keys ( ) ) :		      	i < n ;							      i < n ;							  
	    s [ arr [ i ] ] = arr [ i ]			      	i ++ ) {						      i ++ ) {							  
	    print ( arr [ i ] , end = " " )		      	  if ( s . find ( arr [ i ] ) == s . end ( ) ) {	    	if ( ( arr [ i ] != 0 ) && ( arr [ i ] != 1 ) ) {	  
							      	    s . insert ( arr [ i ] ) ;				    	  s [ arr [ i ] ] = arr [ i ] ;				  
							      	    cout << arr [ i ] << " " ;				    	  cout << arr [ i ] << " " ;				  
							      	  }							    	}							  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND
--							      --							    --								  --
def countSeq ( n ) :					      int countSeq ( int n ) {					    int countSeq ( int n ) {					  success : None
    nCr = 1						      	int nCr = 1 , res = 1 ;					      int nCr = 1 ;						  
    res = 1						      	for ( int r = 1 ;					      int res = 1 ;						  
    for r in range ( 1 , n + 1 ) :			      	r <= n ;						      for ( int r = 1 ;						  
	nCr = ( nCr * ( n + 1 - r ) ) / r ;		      	r ++ ) {						      r <= n ;							  
	res += nCr * nCr ;				      	  nCr = ( nCr * ( n + 1 - r ) ) / r ;			      r ++ ) {							  
    return res ;					      	  res += nCr * nCr ;					    	nCr = ( nCr * ( n + 1 - r ) ) / r ;			  
							      	}							    	;							  
							      	return res ;						    	res += nCr * nCr ;					  
							      }								    	;							  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI
--							      --							    --								  --
def countNegative ( M , n , m ) :			      int countNegative ( int M [ ] [ 4 ] , int n , int m ) {	    int countNegative ( int * * M , int n , int m ) {		  script_not_found : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( m ) :				      	i < n ;							      i < n ;							  
	    if M [ i ] [ j ] < 0 :			      	i ++ ) {						      i ++ ) {							  
		count += 1				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    else :					      	  j < m ;						    	j < m ;							  
		break					      	  j ++ ) {						    	j ++ ) {						  
    return count					      	    if ( M [ i ] [ j ] < 0 ) count += 1 ;		    	  if ( M [ i ] [ j ] < 0 ) {				  
							      	    else break ;					    	    count ++ ;						  
							      	  }							    	  }							  
							      	}							    	  else {						  
							      	return count ;						    	    break ;						  
							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		      PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		    PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		  PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES
--							      --							    --								  --
def isPrime ( p ) :					      bool isPrime ( int p ) {					    bool isPrime ( int p ) {					  failure : #Results: 8, 10
    checkNumber = 2 ** p - 1				      	long long checkNumber = pow ( 2 , p ) - 1 ;		      int checkNumber = 2 * p - 1 ;				  
    nextval = 4 % checkNumber				      	long long nextval = 4 % checkNumber ;			      int nextval = 4 % checkNumber ;				  
    for i in range ( 1 , p - 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	nextval = ( nextval * nextval - 2 ) % checkNumber     	i < p - 1 ;						      i <= p - 1 ;						  
    if ( nextval == 0 ) : return True			      	i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;    i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;  
    else : return False					      	return ( nextval == 0 ) ;				      if ( ( nextval == 0 ) && ( nextval != 1 ) ) return true ;	  
							      }								      else return false ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_PERIMETER_N_BLOCKS				      MINIMUM_PERIMETER_N_BLOCKS				    MINIMUM_PERIMETER_N_BLOCKS					  MINIMUM_PERIMETER_N_BLOCKS
--							      --							    --								  --
def minPerimeter ( n ) :				      int minPerimeter ( int n ) {				    int minPerimeter ( int n ) {				  success : None
    l = math.sqrt ( n )					      	int l = sqrt ( n ) ;					      int l = sqrt ( n ) ;					  
    sq = l * l						      	int sq = l * l ;					      int sq = l * l ;						  
    if ( sq == n ) :					      	if ( sq == n ) return l * 4 ;				      if ( ( sq == n ) && ( l == n ) ) {			  
	return l * 4					      	else {							    	return l * 4 ;						  
    else :						      	  long long int row = n / l ;				      }								  
	row = n / l					      	  long long int perimeter = 2 * ( l + row ) ;		      else {							  
	perimeter = 2 * ( l + row )			      	  if ( n % l != 0 ) perimeter += 2 ;			    	int row = n / l ;					  
	if ( n % l != 0 ) :				      	  return perimeter ;					    	int perimeter = 2 * ( l + row ) ;			  
	    perimeter += 2				      	}							    	if ( ( n % l != 0 ) && ( perimeter > 0 ) ) {		  
	return perimeter				      }								    	  perimeter += 2 ;					  
							      								    	}							  
							      								    	return perimeter ;					  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_CONWAY_SEQUENCE_1				      NEWMAN_CONWAY_SEQUENCE_1					    NEWMAN_CONWAY_SEQUENCE_1					  NEWMAN_CONWAY_SEQUENCE_1
--							      --							    --								  --
def sequence ( n ) :					      int sequence ( int n ) {					    int sequence ( int n ) {					  error : NEWMAN_CONWAY_SEQUENCE_1.cpp: In function
    f = array.array ( 'i' , [ 0 , 1 , 1 ] )		      	int f [ n + 1 ] ;					      array < int , n > f ;					  ‘int f_filled(int)’: NEWMAN_CONWAY_SEQUENCE_1.cpp:
    for i in range ( 3 , n + 1 ) :			      	int i ;							      f . push_back ( 0 ) ;					  30:19: error: ‘n’ is not a constant expression
	r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]	      	f [ 0 ] = 0 ;						      f . push_back ( 1 ) ;					  array < int , n > f ;			   ^ NEWMAN_
	f.append ( r ) ;				      	f [ 1 ] = 1 ;						      f . push_back ( 1 ) ;					  CONWAY_SEQUENCE_1.cpp:30:19: note: in template arg
    return r						      	f [ 2 ] = 1 ;						      for ( int i = 3 ;						  ument for type ‘long unsigned int’ NEWMAN_CONWAY_S
							      	for ( i = 3 ;						      i <= n ;							  EQUENCE_1.cpp:31:7: error: request for member ‘pus
							      	i <= n ;						      i ++ ) {							  h_back’ in ‘f’, which is of non-class type ‘int’
							      	i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]  	int r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;	    f . push_back ( 0 ) ;	 ^~~~~~~~~ NEWMAN_CO
							      	return f [ n ] ;					    	f . push_back ( r ) ;					  NWAY_SEQUENCE_1.cpp:32:7: error: request for membe
							      }								    	;							  r ‘push_back’ in ‘f’, which is of non-class type ‘
							      								      }								  int’	  f . push_back ( 1 ) ;	       ^~~~~~~~~ NEW
							      								      return r ;						  MAN_CONWAY_SEQUENCE_1.cpp:33:7: error: request for
							      								    }								   member ‘push_back’ in ‘f’, which is of non-class
							      								    								  type ‘int’	f . push_back ( 1 ) ;	     ^~~~~~~
							      								    								  ~~ NEWMAN_CONWAY_SEQUENCE_1.cpp:37:27: error: inva
							      								    								  lid types ‘int[int]’ for array subscript	int
							      								    								  r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;
							      								    								  			   ^ NEWMAN_CONWAY_SEQUENCE_
							      								    								  1.cpp:37:51: error: invalid types ‘int[int]’ for a
							      								    								  rray subscript      int r = f [ f [ i - 1 ] ] + f
							      								    								  [ i - f [ i - 1 ] ] ;
							      								    								  			 ^ NEWMAN_CONWAY_SEQUENCE_1.
							      								    								  cpp:38:9: error: request for member ‘push_back’ in
							      								    								   ‘f’, which is of non-class type ‘int’      f . pu
							      								    								  sh_back ( r ) ;	   ^~~~~~~~~ NEWMAN_CONWAY_S
							      								    								  EQUENCE_1.cpp:41:10: error: ‘r’ was not declared i
							      								    								  n this scope	  return r ;	       ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		      NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		    NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		  NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N
--							      --							    --								  --
def countIntegralSolutions ( n ) :			      int countIntegralSolutions ( int n ) {			    int countIntegralSolutions ( int n ) {			  success : None
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    for i in range ( n + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( n + 1 ) :			      	i <= n ;						      i < n + 1 ;						  
	    for k in range ( n + 1 ) :			      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		if i + j + k == n :			      	j <= n - i ;						    	for ( int j = 0 ;					  
		    result += 1				      	j ++ ) for ( int k = 0 ;				    	j < n + 1 ;						  
    return result					      	k <= ( n - i - j ) ;					    	j ++ ) {						  
							      	k ++ ) if ( i + j + k == n ) result ++ ;		    	  for ( int k = 0 ;					  
							      	return result ;						    	  k < n + 1 ;						  
							      }								    	  k ++ ) {						  
							      								    	    if ( i + j + k == n ) {				  
							      								    	      result ++ ;					  
							      								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_GAMES_PLAYED_WINNER				      MAXIMUM_GAMES_PLAYED_WINNER				    MAXIMUM_GAMES_PLAYED_WINNER					  MAXIMUM_GAMES_PLAYED_WINNER
--							      --							    --								  --
def maxGameByWinner ( N ) :				      int maxGameByWinner ( int N ) {				    public : int maxGameByWinner ( int N ) {			  error : MAXIMUM_GAMES_PLAYED_WINNER.cpp:29:1: erro
    dp = [ 0 for i in range ( N ) ]			      	int dp [ N ] ;						      vector < int > dp ( N ) ;					  r: expected unqualified-id before ‘public’  public
    dp [ 0 ] = 1					      	dp [ 0 ] = 1 ;						      dp [ 0 ] = 1 ;						   : int f_filled ( int N ) {  ^~~~~~ MAXIMUM_GAMES_
    dp [ 1 ] = 2					      	dp [ 1 ] = 2 ;						      dp [ 1 ] = 2 ;						  PLAYED_WINNER.cpp: In function ‘int main()’: MAXIM
    i = 1						      	int i = 2 ;						      int i = 1 ;						  UM_GAMES_PLAYED_WINNER.cpp:47:12: error: ‘f_filled
    while dp [ i ] <= N :				      	do {							      while ( dp [ i ] <= N ) {					  ’ was not declared in this scope	    if(f_fil
	i = i + 1					      	  dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ;		    	i = i + 1 ;						  led(param0[i]) == f_gold(param0[i]))		   ^
	dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]		      	}							    	dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ;		  ~~~~~~~ MAXIMUM_GAMES_PLAYED_WINNER.cpp:47:12: not
    return ( i - 1 )					      	while ( dp [ i ++ ] <= N ) ;				      }								  e: suggested alternative: ‘f_gold’	      if(f_f
							      	return ( i - 2 ) ;					      return ( i - 1 ) ;					  illed(param0[i]) == f_gold(param0[i]))
							      }								    }								   ^~~~~~~~		f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2
--							      --							    --								  --
def numberOfPaths ( p , q ) :				      int numberOfPaths ( int m , int n ) {			    public : int numberOfPaths ( int p , int q ) {		  error : COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT
    dp = [ 1 for i in range ( q ) ]			      	int dp [ n ] = {					      vector < int > dp ( q , 1 ) ;				  _NXM_MATRIX_2.cpp:33:1: error: expected unqualifie
    for i in range ( p - 1 ) :				      	  1 }							      for ( int i = 0 ;						  d-id before ‘public’	public : int f_filled ( int
	for j in range ( 1 , q ) :			      	  ;							      i < q ;							  p , int q ) {	 ^~~~~~ COUNT_POSSIBLE_PATHS_TOP_LEF
	    dp [ j ] += dp [ j - 1 ]			      	  dp [ 0 ] = 1 ;					      i ++ ) {							  T_BOTTOM_RIGHT_NXM_MATRIX_2.cpp: In function ‘int
    return dp [ q - 1 ]					      	  for ( int i = 0 ;					    	for ( int j = 1 ;					  main()’: COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGH
							      	  i < m ;						    	j < q ;							  T_NXM_MATRIX_2.cpp:54:12: error: ‘f_filled’ was no
							      	  i ++ ) {						    	j ++ ) {						  t declared in this scope	    if(f_filled(para
							      	    for ( int j = 1 ;					    	  dp [ j ] += dp [ j - 1 ] ;				  m0[i],param1[i]) == f_gold(param0[i],param1[i]))
							      	    j < n ;						    	}							  	     ^~~~~~~~ COUNT_POSSIBLE_PATHS_TOP_LEFT_
							      	    j ++ ) {						      }								  BOTTOM_RIGHT_NXM_MATRIX_2.cpp:54:12: note: suggest
							      	      dp [ j ] += dp [ j - 1 ] ;			      return dp [ q - 1 ] ;					  ed alternative: ‘f_gold’	    if(f_filled(para
							      	    }							    }								  m0[i],param1[i]) == f_gold(param0[i],param1[i]))
							      	  }							    								  	     ^~~~~~~~		  f_gold
							      	  return dp [ n - 1 ] ;					    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY		      MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY		    MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY			  MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY
--							      --							    --								  --
def minOperation ( arr , n ) :				      int minOperation ( int arr [ ] , int n ) {		    public : int minOperation ( int arr [ ] , int n ) {		  error : MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRA
    Hash = defaultdict ( lambda : 0 )			      	unordered_map < int , int > hash ;			      std :: map < int , int > Hash ;				  Y.cpp:27:1: error: expected unqualified-id before
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  ‘public’  public : int f_filled ( int arr [ ] , in
	Hash [ arr [ i ] ] += 1				      	i < n ;							      i != n ;							  t n ) {  ^~~~~~ MINIMUM_OPERATION_MAKE_ELEMENTS_EQ
    max_count = 0					      	i ++ ) hash [ arr [ i ] ] ++ ;				      ++ i ) Hash [ arr [ i ] ] ++ ;				  UAL_ARRAY.cpp: In function ‘int main()’: MINIMUM_O
    for i in Hash :					      	int max_count = 0 ;					      int maxCount = 0 ;					  PERATION_MAKE_ELEMENTS_EQUAL_ARRAY.cpp:46:12: erro
	if max_count < Hash [ i ] :			      	for ( auto i : hash ) if ( max_count < i . second ) max_cou   for ( int i = 0 ;						  r: ‘f_filled’ was not declared in this scope
	    max_count = Hash [ i ]			      	return ( n - max_count ) ;				      i != Hash . size ( ) ;					      if(f_filled(&param0[i].front(),param1[i]) == f
    return n - max_count				      }								      ++ i ) if ( maxCount < Hash [ i ] ) maxCount = Hash [ i ] ; _gold(&param0[i].front(),param1[i]))		   ^
							      								      return n - maxCount ;					  ~~~~~~~ MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRA
							      								    }								  Y.cpp:46:12: note: suggested alternative: ‘f_gold’
							      								    								  	    if(f_filled(&param0[i].front(),param1[i]
							      								    								  ) == f_gold(&param0[i].front(),param1[i]))
							      								    								       ^~~~~~~~		    f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BUBBLE_SORT						      BUBBLE_SORT						    BUBBLE_SORT							  BUBBLE_SORT
--							      --							    --								  --
def bubbleSort ( arr ) :				      void bubbleSort ( int arr [ ] , int n ) {			    void bubbleSort ( vector < int > & arr ) {			  script_not_found : None
    n = len ( arr )					      	int i , j ;						      int n = arr . size ( ) ;					  
    for i in range ( n ) :				      	for ( i = 0 ;						      for ( int i = 0 ;						  
	for j in range ( 0 , n - i - 1 ) :		      	i < n - 1 ;						      i < n ;							  
	    if arr [ j ] > arr [ j + 1 ] :		      	i ++ ) for ( j = 0 ;					      i ++ ) {							  
		arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , a 	j < n - i - 1 ;						    	for ( int j = 0 ;					  
							      	j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) swap ( & arr [ j ]  	j <= n - i - 1 ;					  
							      }								    	j ++ ) {						  
							      								    	  if ( arr [ j ] > arr [ j + 1 ] ) {			  
							      								    	    arr [ j ] = arr [ j + 1 ] ;				  
							      								    	    arr [ j + 1 ] = arr [ j ] ;				  
							      								    	  }							  
							      								    	}							  
							      								      }								  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_WAYS_BREAK_STRING_BRACKET_FORM			      PRINT_WAYS_BREAK_STRING_BRACKET_FORM			    PRINT_WAYS_BREAK_STRING_BRACKET_FORM			  PRINT_WAYS_BREAK_STRING_BRACKET_FORM
--							      --							    --								  --
def findCombinations ( string , index , out ) :		      void findCombinations ( string str , int index , string out ) void findCombinations ( string & string , int index , string  script_not_found : None
    if index == len ( string ) :			      	if ( index == str . length ( ) ) cout << out << endl ;	      if ( index == string . size ( ) ) cout << endl ;		  
	print ( out )					      	for ( int i = index ;					      for ( int i = index ;					  
    for i in range ( index , len ( string ) , 1 ) :	      	i < str . length ( ) ;					      i < string . size ( ) ;					  
	findCombinations ( string , i + 1 , out + "(" + strin 	i ++ ) findCombinations ( str , i + 1 , out + "(" + str . s   i += 1 ) findCombinations ( string , i + 1 , out + "(" + st 
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DIVISIBLE_PAIRS_ARRAY				      COUNT_DIVISIBLE_PAIRS_ARRAY				    COUNT_DIVISIBLE_PAIRS_ARRAY					  COUNT_DIVISIBLE_PAIRS_ARRAY
--							      --							    --								  --
def countDivisibles ( arr , n ) :			      int countDivisibles ( int arr [ ] , int n ) {		    public : int countDivisibles ( int arr [ ] , int n ) {	  script_not_found : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i <= n ;							  
	    if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % ar 	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
		res += 1				      	j < n ;							    	for ( int j = i + 1 ;					  
    return res						      	j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ 	j <= n ;						  
							      	return res ;						    	j ++ ) {						  
							      }								    	  if ( ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [  
-							      -								    	    res-						  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM   DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM   DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM	  DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM
--							      --							    --								  --
def maxTasks ( high , low , n ) :			      int maxTasks ( int high [ ] , int low [ ] , int n ) {	    int maxTasks ( int high [ ] , int low [ ] , int n ) {	  success : None
    if ( n <= 0 ) :					      	if ( n <= 0 ) return 0 ;				      if ( ( n <= 0 ) || ( n > ( int ) n ) ) return 0 ;		  
	return 0					      	return max ( high [ n - 1 ] + maxTasks ( high , low , ( n -   return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 
    return max ( high [ n - 1 ] + maxTasks ( high , low , ( n }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY		      PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY		    PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY			  PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY
--							      --							    --								  --
def printDistinct ( arr , n ) :				      void printDistinct ( int arr [ ] , int n ) {		    void printDistinct ( int arr [ ] , int n ) {		  script_not_found : None
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	d = 0						      	i < n ;							      i <= n ;							  
	for j in range ( 0 , i ) :			      	i ++ ) {						      i ++ ) {							  
	    if ( arr [ i ] == arr [ j ] ) :		      	  int j ;						    	int d = 0 ;						  
		d = 1					      	  for ( j = 0 ;						    	for ( int j = 0 ;					  
		break					      	  j < i ;						    	j <= i ;						  
	if ( d == 0 ) :					      	  j ++ ) if ( arr [ i ] == arr [ j ] ) break ;		    	j ++ ) {						  
	    print ( arr [ i ] )				      	  if ( i == j ) cout << arr [ i ] << " " ;		    	  if ( ( arr [ i ] == arr [ j ] ) && ( arr [ i ] != arr [ 
							      	}							    	    d = 1 ;						  
							      }								    	    break ;						  
							      								    	  }							  
							      								    	}							  
-							      -								    	if ( ( d == 0 ) || ( d == 1 ) )-			  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		      FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		    FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		  FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS
--							      --							    --								  --
def findElements ( arr , n ) :				      void findElements ( int arr [ ] , int n ) {		    void findElements ( int arr [ ] , int n ) {			  script_not_found : None
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	count = 0					      	i < n ;							      i < n ;							  
	for j in range ( 0 , n ) :			      	i ++ ) {						      i ++ ) {							  
	    if arr [ j ] > arr [ i ] :			      	  int count = 0 ;					    	int count = 0 ;						  
		count = count + 1			      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	if count >= 2 :					      	  j < n ;						    	j <= n ;						  
	    print ( arr [ i ] , end = " " )		      	  j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ;	    	j ++ ) {						  
							      	  if ( count >= 2 ) cout << arr [ i ] << " " ;		    	  if ( arr [ j ] > arr [ i ] ) {			  
							      	}							    	    count = count + 1 ;					  
							      }								    	  }							  
							      								    	}							  
							      								    	if ( count >= 2 ) {					  
							      								    	  cout << arr [ i ] << " " ;				  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION
--							      --							    --								  --
def nearestSmallerEqFib ( n ) :				      int nearestSmallerEqFib ( int n ) {			    int nearestSmallerEqFib ( int n ) {				  failure : #Results: 0, 10
    if ( n == 0 or n == 1 ) :				      	if ( n == 0 || n == 1 ) return n ;			      if ( ( n == 0 || n == 1 ) && ( n == 2 || n == 3 ) ) return  
	return n					      	int f1 = 0 , f2 = 1 , f3 = 1 ;				      int f1 = 0 , f2 = 1 , f3 = 1 ;				  
    f1 , f2 , f3 = 0 , 1 , 1				      	while ( f3 <= n ) {					      while ( ( f3 <= n ) && ( f1 < f2 ) ) {			  
    while ( f3 <= n ) :					      	  f1 = f2 ;						    	f1 = f2 ;						  
	f1 = f2 ;					      	  f2 = f3 ;						    	f2 = f3 ;						  
	f2 = f3 ;					      	  f3 = f1 + f2 ;					    	f3 = f1 + f2 ;						  
	f3 = f1 + f2 ;					      	}							      }								  
    return f2 ;						      	return f2 ;						      return f2 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_DIFFERENCE_PAIR				      FIND_MINIMUM_DIFFERENCE_PAIR				    FIND_MINIMUM_DIFFERENCE_PAIR				  FIND_MINIMUM_DIFFERENCE_PAIR
--							      --							    --								  --
def findMinDiff ( arr , n ) :				      int findMinDiff ( int arr [ ] , int n ) {			    int findMinDiff ( int arr [ ] , int n ) {			  success : None
    diff = 10 ** 20					      	int diff = INT_MAX ;					      int diff = 10 * 20 ;					  
    for i in range ( n - 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n - 1 ;						      i < n - 1 ;						  
	    if abs ( arr [ i ] - arr [ j ] ) < diff :	      	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
		diff = abs ( arr [ i ] - arr [ j ] )	      	j < n ;							    	for ( int j = i + 1 ;					  
    return diff						      	j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = a 	j < n ;							  
							      	return diff ;						    	j ++ ) {						  
							      }								    	  if ( abs ( arr [ i ] - arr [ j ] ) < diff ) {		  
							      								    	    diff = abs ( arr [ i ] - arr [ j ] ) ;		  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return diff ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE
--							      --							    --								  --
def subArray ( arr , n ) :				      void subArray ( int arr [ ] , int n ) {			    void subArray ( int arr [ ] , int n ) {			  script_not_found : None
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i , n ) :			      	i < n ;							      i <= n ;							  
	    for k in range ( i , j + 1 ) :		      	i ++ ) {						      i ++ ) {							  
		print ( arr [ k ] , end = "" )		      	  for ( int j = i ;					    	for ( int j = i ;					  
	    print ( "\n" , end = "" )			      	  j < n ;						    	j <= n ;						  
							      	  j ++ ) {						    	j ++ ) {						  
							      	    for ( int k = i ;					    	  for ( int k = i ;					  
							      	    k <= j ;						    	  k <= j ;						  
							      	    k ++ ) cout << arr [ k ] << " " ;			    	  k ++ ) {						  
							      	    cout << endl ;					    	    cout << arr [ k ] << " " ;				  
							      	  }							    	  }							  
							      	}							    	  cout << "\n" << "" << endl ;				  
							      }								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			      SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			    SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			  SUM_MANHATTAN_DISTANCES_PAIRS_POINTS
--							      --							    --								  --
def distancesum ( x , y , n ) :				      int distancesum ( int x [ ] , int y [ ] , int n ) {	    int distancesum ( int * x , int * y , int n ) {		  success : None
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i < n ;							  
	    sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i  	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
    return sum						      	j < n ;							    	for ( int j = i + 1 ;					  
							      	j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - 	j < n ;							  
							      	return sum ;						    	j ++ ) {						  
							      }								    	  sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y  
							      								    	}							  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	      WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	    WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	  WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS
--							      --							    --								  --
def CountWays ( n ) :					      int countWays ( int n ) {					    int CountWays ( int n ) {					  failure : #Results: 0, 10
    table = [ 0 ] * ( n + 1 )				      	int table [ n + 1 ] ;					      int table [ n + 1 ] ;					  
    table [ 0 ] = 1					      	memset ( table , 0 , sizeof ( table ) ) ;		      table [ 0 ] = 1 ;						  
    for i in range ( 1 , n ) :				      	table [ 0 ] = 1 ;					      for ( int i = 1 ;						  
	for j in range ( i , n + 1 ) :			      	for ( int i = 1 ;					      i <= n ;							  
	    table [ j ] += table [ j - i ]		      	i < n ;							      i ++ ) {							  
    return table [ n ]					      	i ++ ) for ( int j = i ;				    	for ( int j = i ;					  
							      	j <= n ;						    	j <= n ;						  
							      	j ++ ) table [ j ] += table [ j - i ] ;			    	j ++ ) {						  
							      	return table [ n ] ;					    	  table [ j ] += table [ j - i ] ;			  
							      }								    	}							  
							      								      }								  
							      								      return table [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		      FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		    FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		  FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY
--							      --							    --								  --
def maxSubarrayXOR ( arr , n ) :			      int maxSubarrayXOR ( int arr [ ] , int n ) {		    int maxSubarrayXOR ( int arr [ ] , int n ) {		  success : None
    ans = - 2147483648					      	int ans = INT_MIN ;					      int ans = - 2147483648 ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	curr_xor = 0					      	i < n ;							      i < n ;							  
	for j in range ( i , n ) :			      	i ++ ) {						      i ++ ) {							  
	    curr_xor = curr_xor ^ arr [ j ]		      	  int curr_xor = 0 ;					    	int curr_xor = 0 ;					  
	    ans = max ( ans , curr_xor )		      	  for ( int j = i ;					    	for ( int j = i ;					  
    return ans						      	  j < n ;						    	j < n ;							  
							      	  j ++ ) {						    	j ++ ) {						  
							      	    curr_xor = curr_xor ^ arr [ j ] ;			    	  curr_xor = curr_xor ^ arr [ j ] ;			  
							      	    ans = max ( ans , curr_xor ) ;			    	  ans = max ( ans , curr_xor ) ;			  
							      	  }							    	}							  
							      	}							      }								  
							      	return ans ;						      return ans ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_PRINT_IDENTITY_MATRIX_1				      PROGRAM_PRINT_IDENTITY_MATRIX_1				    PROGRAM_PRINT_IDENTITY_MATRIX_1				  PROGRAM_PRINT_IDENTITY_MATRIX_1
--							      --							    --								  --
def isIdentity ( mat , N ) :				      bool isIdentity ( int mat [ ] [ MAX ] , int N ) {		    bool isIdentity ( int mat [ ] [ N ] , int N ) {		  script_not_found : None
    for row in range ( N ) :				      	for ( int row = 0 ;					      for ( int row = 0 ;					  
	for col in range ( N ) :			      	row < N ;						      row < N ;							  
	    if ( row == col and mat [ row ] [ col ] != 1 ) :  	row ++ ) {						      row ++ ) {						  
		return False				      	  for ( int col = 0 ;					    	for ( int col = 0 ;					  
	    elif ( row != col and mat [ row ] [ col ] != 0 )  	  col < N ;						    	col < N ;						  
		return False				      	  col ++ ) {						    	col ++ ) {						  
    return True						      	    if ( row == col && mat [ row ] [ col ] != 1 ) return fa 	  if ( ( row == col && mat [ row ] [ col ] != 1 ) || ( ro 
							      	    else if ( row != col && mat [ row ] [ col ] != 0 ) retu 	    return false ;					  
							      	  }							    	  }							  
							      	}							    	  else if ( ( row != col && mat [ row ] [		  
							      	return true ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		      SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		    SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		  SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1
--							      --							    --								  --
def insertSorted ( arr , n , key , capacity ) :		      int insertSorted ( int arr [ ] , int n , int key , int capaci int insertSorted ( int * arr , int n , int key , int capacity failure : #Results: 4, 10
    if ( n >= capacity ) :				      	if ( n >= capacity ) return n ;				      if ( ( n >= capacity ) && ( n < capacity ) ) return n ;	  
	return n					      	int i ;							      int i = n - 1 ;						  
    i = n - 1						      	for ( i = n - 1 ;					      while ( i >= 0 && arr [ i ] > key ) {			  
    while i >= 0 and arr [ i ] > key :			      	( i >= 0 && arr [ i ] > key ) ;				    	arr [ i + 1 ] = arr [ i ] ;				  
	arr [ i + 1 ] = arr [ i ]			      	i -- ) arr [ i + 1 ] = arr [ i ] ;			    	i -- ;							  
	i -= 1						      	arr [ i + 1 ] = key ;					      }								  
    arr [ i + 1 ] = key					      	return ( n + 1 ) ;					      arr [ i + 1 ] = key ;					  
    return ( n + 1 )					      }								      return ( n + 1 ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY		      MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY		    MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY			  MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY
--							      --							    --								  --
def solve ( arr , n ) :					      int solve ( int arr [ ] , int n ) {			    public : int solve ( int arr [ ] , int n ) {		  error : MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRA
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  Y.cpp:29:1: error: expected unqualified-id before
    a = 0 b = 0						      	int a = 0 , b = 0 ;					      int a = 0 , b = 0 ;					  ‘public’  public : int f_filled ( int arr [ ] , in
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  t n ) {  ^~~~~~ MINIMUM_SUM_TWO_NUMBERS_FORMED_DIG
	if ( i % 2 != 0 ) :				      	i < n ;							      i < n ;							  ITS_ARRAY.cpp: In function ‘int main()’: MINIMUM_S
	    a = a * 10 + arr [ i ]			      	i ++ ) {						      i ++ ) {							  UM_TWO_NUMBERS_FORMED_DIGITS_ARRAY.cpp:48:12: erro
	else :						      	  if ( i & 1 ) a = a * 10 + arr [ i ] ;			    	if ( ( i % 2 != 0 ) && ( arr [ i ] != 0 ) ) a = a * 10 +  r: ‘f_filled’ was not declared in this scope
	    b = b * 10 + arr [ i ]			      	  else b = b * 10 + arr [ i ] ;				    	else b = b * 10 + arr [ i ] ;				      if(f_filled(&param0[i].front(),param1[i]) == f
    return a + b					      	}							      }								  _gold(&param0[i].front(),param1[i]))		   ^
							      	return a + b ;						      return a + b ;						  ~~~~~~~ MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRA
							      }								    }								  Y.cpp:48:12: note: suggested alternative: ‘f_gold’
							      								    								  	    if(f_filled(&param0[i].front(),param1[i]
							      								    								  ) == f_gold(&param0[i].front(),param1[i]))
							      								    								       ^~~~~~~~		    f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
OVERLAPPING_SUM_TWO_ARRAY				      OVERLAPPING_SUM_TWO_ARRAY					    OVERLAPPING_SUM_TWO_ARRAY					  OVERLAPPING_SUM_TWO_ARRAY
--							      --							    --								  --
def findSum ( A , B , n ) :				      int findSum ( int A [ ] , int B [ ] , int n ) {		    public : int findSum ( vector < int > A , vector < int > B ,  error : OVERLAPPING_SUM_TWO_ARRAY.cpp:30:1: error:
    Hash = defaultdict ( lambda : 0 )			      	unordered_map < int , int > hash ;			      unordered_map < int , int > Hash ;			   expected unqualified-id before ‘public’  public :
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						   int f_filled ( vector < int > A , vector < int >
	Hash [ A [ i ] ] += 1				      	i < n ;							      i != n ;							  B , int n ) {	 ^~~~~~ OVERLAPPING_SUM_TWO_ARRAY.cp
	Hash [ B [ i ] ] += 1				      	i ++ ) {						      ++ i ) {							  p: In function ‘int main()’: OVERLAPPING_SUM_TWO_A
    Sum = 0						      	  hash [ A [ i ] ] ++ ;					    	Hash [ A [ i ] ] ++ ;					  RRAY.cpp:53:12: error: ‘f_filled’ was not declared
    for x in Hash :					      	  hash [ B [ i ] ] ++ ;					    	Hash [ B [ i ] ] ++ ;					   in this scope	  if(f_filled(&param0[i].fro
	if Hash [ x ] == 1 :				      	}							      }								  nt(),&param1[i].front(),param2[i]) == f_gold(&para
	    Sum += x					      	int sum = 0 ;						      int Sum = 0 ;						  m0[i].front(),&param1[i].front(),param2[i]))
    return Sum						      	for ( auto x : hash ) if ( x . second == 1 ) sum += x . fir   for ( auto x : Hash ) {					  	 ^~~~~~~~ OVERLAPPING_SUM_TWO_ARRAY.cpp:53:1
							      	return sum ;						    	if ( Hash [ x ] == 1 ) Sum += x ;			  2: note: suggested alternative: ‘f_gold’
							      }								      }								  if(f_filled(&param0[i].front(),&param1[i].front(),
							      								      return Sum ;						  param2[i]) == f_gold(&param0[i].front(),&param1[i]
							      								    }								  .front(),param2[i]))		   ^~~~~~~~
							      								    								      f_gold
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			      FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			    FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			  FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM
--							      --							    --								  --
def maxLen ( arr ) :					      int maxLen ( int arr [ ] , int n ) {			    int maxLen ( int arr [ ] ) {				  error : FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM.cpp:
    max_len = 0						      	int max_len = 0 ;					      int maxLen = 0 ;						  In function ‘int f_filled(int*)’: FIND_THE_LARGEST
    for i in range ( len ( arr ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  _SUBARRAY_WITH_0_SUM.cpp:36:13: error: request for
	curr_sum = 0					      	i < n ;							      i < arr . length ;					   member ‘length’ in ‘arr’, which is of non-class t
	for j in range ( i , len ( arr ) ) :		      	i ++ ) {						      i ++ ) {							  ype ‘int*’	i < arr . length ;		^~~~
	    curr_sum += arr [ j ]			      	  int curr_sum = 0 ;					    	int currSum = 0 ;					  ~~ FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM.cpp:40:15:
	    if curr_sum == 0 :				      	  for ( int j = i ;					    	for ( int j = i ;					   error: request for member ‘length’ in ‘arr’, whic
		max_len = max ( max_len , j - i + 1 )	      	  j < n ;						    	j < arr . length ;					  h is of non-class type ‘int*’	     j < arr . lengt
    return max_len					      	  j ++ ) {						    	j ++ ) {						  h ;		     ^~~~~~ FIND_THE_LARGEST_SUBARRA
							      	    curr_sum += arr [ j ] ;				    	  currSum += arr [ j ] ;				  Y_WITH_0_SUM.cpp: In function ‘int main()’: FIND_T
							      	    if ( curr_sum == 0 ) max_len = max ( max_len , j - i +  	  if ( currSum == 0 ) maxLen = max ( maxLen , j - i + 1 ) HE_LARGEST_SUBARRAY_WITH_0_SUM.cpp:56:49: error: t
							      	  }							    	}							  oo many arguments to function ‘int f_filled(int*)’
							      	}							      }								  	    if(f_filled(&param0[i].front(),param1[i]
							      	return max_len ;					      return maxLen ;						  ) == f_gold(&param0[i].front(),param1[i]))
							      }								    }								  					    ^ FIND_T
							      								    								  HE_LARGEST_SUBARRAY_WITH_0_SUM.cpp:33:5: note: dec
							      								    								  lared here  int f_filled ( int arr [ ] ) {	  ^~
							      								    								  ~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	      FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	    FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	  FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE
--							      --							    --								  --
def minRadius ( k , x , y , n ) :			      int minRadius ( int k , int x [ ] , int y [ ] , int n ) {	    int minRadius ( int k , double * x , double * y , int n ) {	  error : FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_IN
    dis = [ 0 ] * n					      	int dis [ n ] ;						      int dis [ n ] ;						  SIDE_CIRCLE.cpp: In function ‘int main()’: FIND_MI
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      dis [ 0 ] = 0 ;						  NIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE.cpp
	dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ]     	i < n ;							      for ( int i = 0 ;						  :45:31: error: cannot convert ‘__gnu_cxx::__alloc_
    dis.sort ( )					      	i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ;    i <= n ;							  traits<std::allocator<int>, int>::value_type*’ {ak
    return dis [ k - 1 ]				      	sort ( dis , dis + n ) ;				      i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ;  a ‘int*’} to ‘double*’	  if(f_filled(param0
							      	return dis [ k - 1 ] ;					      sort ( dis , dis + k - 1 ) ;				  [i],&param1[i].front(),&param2[i].front(),param3[i
							      }								      return dis [ k - 1 ] ;					  ]) == f_gold(param0[i],&param1[i].front(),&param2[
							      								    }								  i].front(),param3[i]))
							      								    								      ^~~~~~~~~~~~~~~~~~ FIND_MINIMUM_RADIUS_ATLEAST
							      								    								  _K_POINT_LIE_INSIDE_CIRCLE.cpp:26:33: note:	init
							      								    								  ializing argument 2 of ‘int f_filled(int, double*,
							      								    								   double*, int)’  int f_filled ( int k , double * x
							      								    								   , double * y , int n ) {
							      								    								  ~~~~~~~~~^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS   GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS   GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS	  GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS
--							      --							    --								  --
def generate ( ones , zeroes , str , len1 ) :		      void generate ( int ones , int zeroes , string str , int len  void generate ( int ones , int zeroes , string str , int len1 script_not_found : None
    if ( len1 == len ( str ) ) :			      	if ( len == str . length ( ) ) {			      if ( ( len1 == str . size ( ) ) || ( ones == zeroes ) ) {	  
	print ( str , end = " " )			      	  cout << str << "  " ;					    	cout << str << " " ;					  
	return						      	  return ;						    	return ;						  
    generate ( ones + 1 , zeroes , str + "1" , len1 )	      	}							      }								  
    if ( ones > zeroes ) :				      	generate ( ones + 1 , zeroes , str + "1" , len ) ;	      generate ( ones + 1 , zeroes , str + "1" , len1 ) ;	  
	generate ( ones , zeroes + 1 , str + "0" , len1 )     	if ( ones > zeroes ) generate ( ones , zeroes + 1 , str + "   if ( ( ones > zeroes ) || ( zeroes > ones ) ) {		  
							      }								    	generate ( ones , zeroes + 1 , str + "0" , len1 ) ;	  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE
--							      --							    --								  --
def search ( arr , n , x ) :				      int search ( int arr [ ] , int n , int x ) {		    int search ( int arr [ ] , int n , int x ) {		  failure : number is not present! number is not pre
    i = 0						      	int i = 0 ;						      int i = 0 ;						  sent! number is not present!number is not present!
    while ( i < n ) :					      	while ( i < n ) {					      while ( ( i < n ) && ( arr [ i ] == x ) ) {		   number is not present! number is not present!numb
	if ( arr [ i ] == x ) :				      	  if ( arr [ i ] == x ) return i ;			    	if ( ( arr [ i ] == x ) || ( arr [ i ] == 0 ) ) return i  er is not present! number is not present!number is
	    return i					      	  i = i + abs ( arr [ i ] - x ) ;			    	i = i + abs ( arr [ i ] - x ) ;				   not present! number is not present!number is not
	i = i + abs ( arr [ i ] - x )			      	}							      }								  present! number is not present!number is not prese
    print ( "number is not present!" )			      	cout << "number is not present!" ;			      cout << "number is not present!" << endl ;		  nt! number is not present!number is not present! n
    return - 1						      	return - 1 ;						      return - 1 ;						  umber is not present!number is not present! number
							      }								    }								   is not present!#Results: 8, 10
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCHING_ARRAY_ADJACENT_DIFFER_K			      SEARCHING_ARRAY_ADJACENT_DIFFER_K				    SEARCHING_ARRAY_ADJACENT_DIFFER_K				  SEARCHING_ARRAY_ADJACENT_DIFFER_K
--							      --							    --								  --
def search ( arr , n , x , k ) :			      int search ( int arr [ ] , int n , int x , int k ) {	    int search ( int arr [ ] , int n , int x , int k ) {	  error : SEARCHING_ARRAY_ADJACENT_DIFFER_K.cpp:33:1
    i = 0						      	int i = 0 ;						      int i = 0 ;						  1: warning: missing terminating " character	 cou
    while ( i < n ) :					      	while ( i < n ) {					      while ( ( i < n ) && ( arr [ i ] == x ) ) {		  t << "	    ^ SEARCHING_ARRAY_ADJACENT_DIFFE
	if ( arr [ i ] == x ) :				      	  if ( arr [ i ] == x ) return i ;			    	if ( ( arr [ i ] == x ) || ( arr [ i ] == 0 ) ) return i  R_K.cpp:33:11: error: missing terminating " charac
	    return i					      	  i = i + max ( 1 , abs ( arr [ i ] - x ) / k ) ;	    	i = i + max ( 1 , ( int ) ( abs ( arr [ i ] - x ) / k ) ) ter SEARCHING_ARRAY_ADJACENT_DIFFER_K.cpp: In func
	i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) ) 	}							      }								  tion ‘int f_filled(int*, int, int, int)’: SEARCHIN
    print ( "number is not present!" )			      	cout << "number is not present!" ;			      cout << "							  G_ARRAY_ADJACENT_DIFFER_K.cpp:35:1: error: expecte
    return - 1						      	return - 1 ;						    								  d primary-expression before ‘int’  int main() {  ^
							      }								    								  ~~ SEARCHING_ARRAY_ADJACENT_DIFFER_K.cpp:50:1: err
							      								    								  or: expected ‘}’ at end of input  }  ^ SEARCHING_A
							      								    								  RRAY_ADJACENT_DIFFER_K.cpp:27:54: note: to match t
							      								    								  his ‘{’  int f_filled ( int arr [ ] , int n , int
							      								    								  x , int k ) {
							      								    								  		    ^ SEARCHING_ARRAY_ADJACENT_DIFFE
							      								    								  R_K.cpp:50:1: warning: control reaches end of non-
							      								    								  void function [-Wreturn-type]	 }  ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_DIFFERENCE_EQUAL_K				      COUNT_PAIRS_DIFFERENCE_EQUAL_K				    COUNT_PAIRS_DIFFERENCE_EQUAL_K				  COUNT_PAIRS_DIFFERENCE_EQUAL_K
--							      --							    --								  --
def countPairsWithDiffK ( arr , n , k ) :		      int countPairsWithDiffK ( int arr [ ] , int n , int k ) {	    int countPairsWithDiffK ( int arr [ ] , int n , int k ) {	  success : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i <= n ;							  
	    if arr [ i ] - arr [ j ] == k or arr [ j ] - arr  	i ++ ) {						      i ++ ) {							  
		count += 1				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    return count					      	  j < n ;						    	j <= n ;						  
							      	  j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr 	j ++ ) {						  
							      	}							    	  if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i  
							      	return count ;						    	    count ++ ;						  
							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI
--							      --							    --								  --
def countNegative ( M , n , m ) :			      int countNegative ( int M [ ] [ 4 ] , int n , int m ) {	    public : int countNegative ( vector < vector < int >> & M , i script_not_found : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    i = 0						      	int i = 0 ;						      int i = 0 ;						  
    j = m - 1						      	int j = m - 1 ;						      int j = m - 1 ;						  
    while j >= 0 and i < n :				      	while ( j >= 0 && i < n ) {				      while ( j >= 0 && i < n ) {				  
	if M [ i ] [ j ] < 0 :				      	  if ( M [ i ] [ j ] < 0 ) {				    	if ( M [ i ] [ j ] < 0 ) {				  
	    count += ( j + 1 )				      	    count += j + 1 ;					    	  count += ( j + 1 ) ;					  
	    i += 1					      	    i += 1 ;						    	  i ++ ;						  
	else :						      	  }							    	}							  
	    j -= 1					      	  else j -= 1 ;						    	else {							  
    return count					      	}							    	  j -- ;						  
							      	return count ;						    	}							  
							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		      CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		    CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		  CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION
--							      --							    --								  --
def findMinX ( num , rem , k ) :			      int findMinX ( int num [ ] , int rem [ ] , int k ) {	    int findMinX ( int * num , int * rem , int k ) {		  script_not_found : None
    x = 1						      	int x = 1 ;						      int x = 1 ;						  
    while ( True ) :					      	while ( true ) {					      while ( ( true ) ) {					  
	j = 0						      	  int j ;						    	int j = 0 ;						  
	while ( j < k ) :				      	  for ( j = 0 ;						    	while ( ( j < k ) && ( x % num [ j ] != rem [ j ] ) ) {	  
	    if ( x % num [ j ] != rem [ j ] ) :		      	  j < k ;						    	  if ( ( x % num [ j ] != rem [ j ] ) && ( j < k ) ) brea 
		break					      	  j ++ ) if ( x % num [ j ] != rem [ j ] ) break ;	    	  j ++ ;						  
	    j += 1					      	  if ( j == k ) return x ;				    	}							  
	if ( j == k ) :					      	  x ++ ;						    	if ( ( j == k ) || ( j == k )				  
	    return x					      	}							    								  
	x += 1						      	return x ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_CONSECUTIVE_DUPLICATES_STRING			      REMOVE_CONSECUTIVE_DUPLICATES_STRING			    REMOVE_CONSECUTIVE_DUPLICATES_STRING			  REMOVE_CONSECUTIVE_DUPLICATES_STRING
--							      --							    --								  --
def removeDuplicates ( S ) :				      void removeDuplicates ( char S [ ] ) {			    void removeDuplicates ( vector < int > & S ) {		  script_not_found : None
    n = len ( S )					      	int n = strlen ( S ) ;					      int n = S . size ( ) ;					  
    if ( n < 2 ) :					      	if ( n < 2 ) return ;					      if ( ( n < 2 ) || ( n > n ) ) return ;			  
	return						      	int j = 0 ;						      int j = 0 ;						  
    j = 0						      	for ( int i = 1 ;					      for ( int i = 0 ;						  
    for i in range ( n ) :				      	i < n ;							      i < n ;							  
	if ( S [ j ] != S [ i ] ) :			      	i ++ ) {						      i ++ ) {							  
	    j += 1					      	  if ( S [ j ] != S [ i ] ) {				    	if ( ( S [ j ] != S [ i ] ) && ( S [ j ] != S [ i ] ) ) { 
	    S [ j ] = S [ i ]				      	    j ++ ;						    	  j ++ ;						  
    j += 1						      	    S [ j ] = S [ i ] ;					    	  S [ j ] = S [ i ] ;					  
    S = S [ : j ]					      	  }							    	}							  
    return S						      	}							    								  
							      	j ++ ;							    								  
							      	S [ j ] = '\0' ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION		      DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION			    DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION			  DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION
--							      --							    --								  --
def distributingBalls ( k , n , string ) :		      bool distributingBalls ( int k , int n , string str ) {	    bool distributingBalls ( int k , int n , string & s ) {	  script_not_found : None
    a = [ 0 ] * MAX_CHAR				      	int a [ MAX_CHAR ] = {					      int a [ MAX_CHAR ] = {					  
    for i in range ( n ) :				      	  0 }							    	0 }							  
	a [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1	      	  ;							    	;							  
    for i in range ( MAX_CHAR ) :			      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
	if ( a [ i ] > k ) :				      	  i < n ;						    	i < n ;							  
	    return False				      	  i ++ ) {						    	i ++ ) a [ ( int ) string [ i ] - ( int ) 'a' ] ++ ;	  
    return True						      	    a [ str [ i ] - 'a' ] ++ ;				    	for ( int i = 0 ;					  
							      	  }							    	i < MAX_CHAR ;						  
							      	  for ( int i = 0 ;					    	i ++ ) if ( ( a [ i ] > k ) && ( a [ i ] < n ) ) return f 
							      	  i < MAX_CHAR ;					    								  
							      	  i ++ ) if ( a [ i ] > k ) return false ;		    								  
							      	  return true ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_INSERTION_SORT				      RECURSIVE_INSERTION_SORT					    RECURSIVE_INSERTION_SORT					  RECURSIVE_INSERTION_SORT
--							      --							    --								  --
def insertionSortRecursive ( arr , n ) :		      void insertionSortRecursive ( int arr [ ] , int n ) {	    void insertionSortRecursive ( int arr [ ] , int n ) {	  script_not_found : None
    if n <= 1 :						      	if ( n <= 1 ) return ;					      if ( n <= 1 ) return ;					  
	return						      	insertionSortRecursive ( arr , n - 1 ) ;		      insertionSortRecursive ( arr , n - 1 ) ;			  
    insertionSortRecursive ( arr , n - 1 )		      	int last = arr [ n - 1 ] ;				      int last = arr [ n - 1 ] ;				  
    last = arr [ n - 1 ]				      	int j = n - 2 ;						      int j = n - 2 ;						  
    j = n - 2						      	while ( j >= 0 && arr [ j ] > last ) {			      while ( ( j >= 0 && arr [ j ] > last ) || ( j < 0 && arr [  
    while ( j >= 0 and arr [ j ] > last ) :		      	  arr [ j + 1 ] = arr [ j ] ;				    	arr [ j + 1 ] = arr [ j ] ;				  
	arr [ j + 1 ] = arr [ j ]			      	  j -- ;						    	j = j - 1 ;						  
	j = j - 1					      	}							      }								  
    arr [ j + 1 ] = last				      	arr [ j + 1 ] = last ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			      CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			    CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			  CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT
--							      --							    --								  --
def areEqual ( arr1 , arr2 , n , m ) :			      bool areEqual ( int arr1 [ ] , int arr2 [ ] , int n , int m ) bool areEqual ( int * arr1 , int * arr2 , int n , int m ) {	  script_not_found : None
    if ( n != m ) :					      	if ( n != m ) return false ;				      if ( ( n != m ) || ( n < 0 ) || ( n > 0 ) ) return false ;  
	return False ;					      	sort ( arr1 , arr1 + n ) ;				      ;								  
    arr1.sort ( ) ;					      	sort ( arr2 , arr2 + m ) ;				      sort ( arr1 , arr1 + n ) ;				  
    arr2.sort ( ) ;					      	for ( int i = 0 ;					      sort ( arr2 , arr2 + n ) ;				  
    for i in range ( 0 , n - 1 ) :			      	i < n ;							      for ( int i = 0 ;						  
	if ( arr1 [ i ] != arr2 [ i ] ) :		      	i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ;	      i <= n - 1 ;						  
	    return False ;				      	return true ;						      i ++ ) if ( ( * arr1 ) [ i ] != ( * arr2			  
    return True ;					      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		      FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		    FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		  FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES
--							      --							    --								  --
def getOddOccurrence ( arr , arr_size ) :		      int getOddOccurrence ( int arr [ ] , int arr_size ) {	    int getOddOccurrence ( int arr [ ] , int arr_size ) {	  error : FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TI
    for i in range ( 0 , arr_size ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  MES.cpp: In function ‘int f_filled(int*, int)’: FI
	count = 0					      	i < arr_size ;						      i != arr_size ;						  ND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES.cpp:50
	for j in range ( 0 , arr_size ) :		      	i ++ ) {						      i ++ ) {							  :12: error: a function-definition is not allowed h
	    if arr [ i ] == arr [ j ] :			      	  int count = 0 ;					    	int count = 0 ;						  ere before ‘{’ token	int main() {		 ^ F
		count += 1				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  IND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES.cpp:6
	if ( count % 2 != 0 ) :				      	  j < arr_size ;					    	j != arr_size ;						  3:1: error: expected ‘}’ at end of input  }  ^ FIN
	    return arr [ i ]				      	  j ++ ) {						    	j ++ ) {						  D_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES.cpp:32:
    return - 1						      	    if ( arr [ i ] == arr [ j ] ) count ++ ;		    	  if ( arr [ i ] == arr [ j ] ) {			  45: note: to match this ‘{’  int f_filled ( int ar
							      	  }							    	    count ++ ;						  r [ ] , int arr_size ) {
							      	  if ( count % 2 != 0 ) return arr [ i ] ;		    	  }							  		      ^ FIND_THE_NUMBER_OCCURRING_OD
							      	}							    	}							  D_NUMBER_OF_TIMES.cpp:63:1: warning: control reach
							      	return - 1 ;						    	if ( ( count % 2 != 0 ) && ( count % 2 != 0 ) ) {	  es end of non-void function [-Wreturn-type]  }  ^
							      }								    	  return arr [ i ] ;					  
							      								    	}							  
							      								      }								  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY   CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY   CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY	  CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY
--							      --							    --								  --
def checkIsAP ( arr , n ) :				      bool checkIsAP ( int arr [ ] , int n ) {			    bool checkIsAP ( int arr [ ] , int n ) {			  success : None
    if ( n == 1 ) : return True				      	if ( n == 1 ) return true ;				      if ( ( n == 1 ) || ( n == 2 ) ) return true ;		  
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    d = arr [ 1 ] - arr [ 0 ]				      	int d = arr [ 1 ] - arr [ 0 ] ;				      int d = arr [ 1 ] - arr [ 0 ] ;				  
    for i in range ( 2 , n ) :				      	for ( int i = 2 ;					      for ( int i = 2 ;						  
	if ( arr [ i ] - arr [ i - 1 ] != d ) :		      	i < n ;							      i < n ;							  
	    return False				      	i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ;   i ++ ) if ( ( arr [ i ] - arr [ i - 1 ] ) != d ) return fal 
    return True						      	return true ;						      return true ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL	      MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL	    MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL		  MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL
--							      --							    --								  --
def minOps ( arr , n , k ) :				      int minOps ( int arr [ ] , int n , int k ) {		    int minOps ( int arr [ ] , int n , int k ) {		  error : MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMEN
    max1 = max ( arr )					      	int max = * max_element ( arr , arr + n ) ;		      int max1 = max ( arr ) ;					  TS_EQUAL.cpp: In function ‘int f_filled(int*, int,
    res = 0						      	int res = 0 ;						      double res = 0 ;						   int)’: MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMEN
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  TS_EQUAL.cpp:30:24: error: no matching function fo
	if ( ( max1 - arr [ i ] ) % k != 0 ) :		      	i < n ;							      i <= n ;							  r call to ‘max(int*&)’    int max1 = max ( arr ) ;
	    return - 1					      	i ++ ) {						      i ++ ) {							  			   ^ In file included from /
	else :						      	  if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ;	    	if ( ( ( max1 - arr [ i ] ) % k != 0 ) && ( ( max1 - arr  usr/include/c++/8/bits/char_traits.h:39,
	    res += ( max1 - arr [ i ] ) / k		      	  else res += ( max - arr [ i ] ) / k ;			    	else res += ( max1 - arr [ i ] ) / k ;			  	  from /usr/include/c++/8/ios:40,
    return int ( res )					      	}							    								  	 from /usr/include/c++/8/ostream:38,
							      	return res ;						    								  	    from /usr/include/c++/8/iostream:39,
							      }								    								  		from MINIMUM_INCREMENT_K_OPERATIONS_
							      								    								  MAKE_ELEMENTS_EQUAL.cpp:8: /usr/include/c++/8/bits
							      								    								  /stl_algobase.h:219:5: note: candidate: ‘template<
							      								    								  class _Tp> constexpr const _Tp& std::max(const _Tp
							      								    								  &, const _Tp&)’      max(const _Tp& __a, const _Tp
							      								    								  & __b)      ^~~ /usr/include/c++/8/bits/stl_algoba
							      								    								  se.h:219:5: note:   template argument deduction/su
							      								    								  bstitution failed: MINIMUM_INCREMENT_K_OPERATIONS_
							      								    								  MAKE_ELEMENTS_EQUAL.cpp:30:24: note:	 candidate e
							      								    								  xpects 2 arguments, 1 provided    int max1 = max (
							      								    								   arr ) ;			   ^ In file include
							      								    								  d from /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  		  from /usr/include/c++/8/ios:40,
							      								    								  		 from /usr/include/c++/8/ostream:38,
							      								    								  		    from /usr/include/c++/8/iostream
							      								    								  :39,			from MINIMUM_INCREMENT_K_OPE
							      								    								  RATIONS_MAKE_ELEMENTS_EQUAL.cpp:8: /usr/include/c+
							      								    								  +/8/bits/stl_algobase.h:265:5: note: candidate: ‘t
							      								    								  emplate<class _Tp, class _Compare> constexpr const
							      								    								   _Tp& std::max(const _Tp&, const _Tp&, _Compare)’
							      								    								       max(const _Tp& __a, const _Tp& __b, _Compare
							      								    								  __comp)      ^~~ /usr/include/c++/8/bits/stl_algob
							      								    								  ase.h:265:5: note:   template argument deduction/s
							      								    								  ubstitution failed: MINIMUM_INCREMENT_K_OPERATIONS
							      								    								  _MAKE_ELEMENTS_EQUAL.cpp:30:24: note:	  candidate
							      								    								  expects 3 arguments, 1 provided    int max1 = max
							      								    								  ( arr ) ;			    ^ In file includ
							      								    								  ed from /usr/include/c++/8/algorithm:62,
							      								    								  	  from /usr/include/c++/8/x86_64-redhat-linu
							      								    								  x/bits/stdc++.h:65,		       from MINIMUM_
							      								    								  INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL.cpp:14:
							      								    								   /usr/include/c++/8/bits/stl_algo.h:3462:5: note:
							      								    								  candidate: ‘template<class _Tp> constexpr _Tp std:
							      								    								  :max(std::initializer_list<_Tp>)’	 max(initial
							      								    								  izer_list<_Tp> __l)	   ^~~ /usr/include/c++/8/bi
							      								    								  ts/stl_algo.h:3462:5: note:	template argument de
							      								    								  duction/substitution failed: MINIMUM_INCREMENT_K_O
							      								    								  PERATIONS_MAKE_ELEMENTS_EQUAL.cpp:30:24: note:   m
							      								    								  ismatched types ‘std::initializer_list<_Tp>’ and ‘
							      								    								  int*’	   int max1 = max ( arr ) ;
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /algorithm:62,		  from /usr/include/
							      								    								  c++/8/x86_64-redhat-linux/bits/stdc++.h:65,
							      								    								  	     from MINIMUM_INCREMENT_K_OPERATIONS_MAK
							      								    								  E_ELEMENTS_EQUAL.cpp:14: /usr/include/c++/8/bits/s
							      								    								  tl_algo.h:3468:5: note: candidate: ‘template<class
							      								    								   _Tp, class _Compare> constexpr _Tp std::max(std::
							      								    								  initializer_list<_Tp>, _Compare)’	 max(initial
							      								    								  izer_list<_Tp> __l, _Compare __comp)	    ^~~ /usr
							      								    								  /include/c++/8/bits/stl_algo.h:3468:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: MINI
							      								    								  MUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL.cpp
							      								    								  :30:24: note:	  mismatched types ‘std::initializer
							      								    								  _list<_Tp>’ and ‘int*’    int max1 = max ( arr ) ;
							      								    								  			   ^ MINIMUM_INCREMENT_K_OPE
							      								    								  RATIONS_MAKE_ELEMENTS_EQUAL.cpp:39:12: error: a fu
							      								    								  nction-definition is not allowed here before ‘{’ t
							      								    								  oken	int main() {		 ^ MINIMUM_INCREMENT
							      								    								  _K_OPERATIONS_MAKE_ELEMENTS_EQUAL.cpp:53:1: error:
							      								    								   expected ‘}’ at end of input	 }  ^ MINIMUM_INCREM
							      								    								  ENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL.cpp:34:10: no
							      								    								  te: to match this ‘{’	   i ++ ) {	      ^ MINI
							      								    								  MUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL.cpp
							      								    								  :53:1: error: expected ‘}’ at end of input  }	 ^ M
							      								    								  INIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL.
							      								    								  cpp:29:46: note: to match this ‘{’  int f_filled (
							      								    								   int arr [ ] , int n , int k ) {
							      								    								  			       ^ MINIMUM_INCREMENT_K
							      								    								  _OPERATIONS_MAKE_ELEMENTS_EQUAL.cpp:53:1: warning:
							      								    								   control reaches end of non-void function [-Wretur
							      								    								  n-type]  }  ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
