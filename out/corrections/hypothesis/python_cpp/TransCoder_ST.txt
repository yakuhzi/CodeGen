========================SOURCE============================    ==========================REF=============================    =========================HYPO=============================	  ==========================OUT=============================
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_AREA_SQUARE					      PROGRAM_AREA_SQUARE					    PROGRAM_AREA_SQUARE						  PROGRAM_AREA_SQUARE
--							      --							    --								  --
def areaSquare ( side ) :				      int areaSquare ( int side ) {				    double area_square ( double side ) {			  success : None
    area = side * side					      	int area = side * side ;				      double area = side * side ;				  
    return area						      	return area ;						      return area ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			      MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			    MAXIMUM_POINTS_INTERSECTION_N_CIRCLES			  MAXIMUM_POINTS_INTERSECTION_N_CIRCLES
--							      --							    --								  --
def intersection ( n ) :				      int intersection ( int n ) {				    double intersection ( double n ) {				  success : None
    return n * ( n - 1 )				      	return n * ( n - 1 ) ;					      return n * ( n - 1 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TURN_OFF_THE_RIGHTMOST_SET_BIT				      TURN_OFF_THE_RIGHTMOST_SET_BIT				    TURN_OFF_THE_RIGHTMOST_SET_BIT				  TURN_OFF_THE_RIGHTMOST_SET_BIT
--							      --							    --								  --
def fun ( n ) :						      int fun ( unsigned int n ) {				    int fun ( int n ) {						  success : None
    return n & ( n - 1 )				      	return n & ( n - 1 ) ;					      return n & ( n - 1 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CASSINIS_IDENTITY					      CASSINIS_IDENTITY						    CASSINIS_IDENTITY						  CASSINIS_IDENTITY
--							      --							    --								  --
def cassini ( n ) :					      int cassini ( int n ) {					    int cassini ( int n ) {					  success : None
    return - 1 if ( n & 1 ) else 1			      	return ( n & 1 ) ? - 1 : 1 ;				      return ( n & 1 ) != 0 ? - 1 : 1 ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEXAGONAL_NUMBER					      HEXAGONAL_NUMBER						    HEXAGONAL_NUMBER						  HEXAGONAL_NUMBER
--							      --							    --								  --
def hexagonalNum ( n ) :				      int hexagonalNum ( int n ) {				    double hexagonalNum ( double n ) {				  success : None
    return n * ( 2 * n - 1 )				      	return n * ( 2 * n - 1 ) ;				      return n * ( 2 * n - 1 ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ADD_1_TO_A_GIVEN_NUMBER_1				      ADD_1_TO_A_GIVEN_NUMBER_1					    ADD_1_TO_A_GIVEN_NUMBER_1					  ADD_1_TO_A_GIVEN_NUMBER_1
--							      --							    --								  --
def addOne ( x ) :					      int addOne ( int x ) {					    int addOne ( int x ) {					  success : identical to gold
    return ( - ( ~ x ) )				      	return ( - ( ~ x ) ) ;					      return ( - ( ~ x ) ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_CIRCUMFERENCE_CIRCLE			      PROGRAM_FIND_CIRCUMFERENCE_CIRCLE				    PROGRAM_FIND_CIRCUMFERENCE_CIRCLE				  PROGRAM_FIND_CIRCUMFERENCE_CIRCLE
--							      --							    --								  --
def circumference ( r ) :				      double circumference ( double r ) {			    double circumference ( double r ) {				  script_not_found : None
    return ( 2 * PI * r )				      	double cir = 2 * PI * r ;				      return ( 2 * PI * r ) ;					  
							      	return cir ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
AREA_SQUARE_CIRCUMSCRIBED_CIRCLE			      AREA_SQUARE_CIRCUMSCRIBED_CIRCLE				    AREA_SQUARE_CIRCUMSCRIBED_CIRCLE				  AREA_SQUARE_CIRCUMSCRIBED_CIRCLE
--							      --							    --								  --
def find_Area ( r ) :					      int find_Area ( int r ) {					    int findArea ( int r ) {					  success : None
    return ( 2 * r * r )				      	return ( 2 * r * r ) ;					      return ( 2 * r * r ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			      FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			    FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT			  FIND_WHETHER_GIVEN_INTEGER_POWER_3_NOT
--							      --							    --								  --
def check ( n ) :					      bool check ( int n ) {					    bool check ( int n ) {					  success : identical to gold
    return 1162261467 % n == 0				      	return 1162261467 % n == 0 ;				      return 1162261467 % n == 0 ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_TWO_HALVES_SORTED				      SORT_ARRAY_TWO_HALVES_SORTED				    SORT_ARRAY_TWO_HALVES_SORTED				  SORT_ARRAY_TWO_HALVES_SORTED
--							      --							    --								  --
def mergeTwoHalf ( A , n ) :				      void mergeTwoHalf ( int A [ ] , int n ) {			    void mergeTwoHalf ( int * A , int n ) {			  success : None
    A.sort ( )						      	sort ( A , A + n ) ;					      sort ( A , A + n ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD			      CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD			    CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD				  CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD
--							      --							    --								  --
def isEven ( n ) :					      bool isEven ( int n ) {					    bool isEven ( int n ) {					  success : identical to gold
    return ( n % 2 == 0 )				      	return ( n % 2 == 0 ) ;					      return ( n % 2 == 0 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			      C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			    C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1			  C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1
--							      --							    --								  --
def largest ( arr , n ) :				      int largest ( int arr [ ] , int n ) {			    template < typename T > T max ( T * arr , T n ) {		  error : C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1.cpp
    return max ( arr )					      	return * max_element ( arr , arr + n ) ;		      return std :: max ( arr , arr + n ) ;			  : In function ‘T f_filled(T*, T)’: C_PROGRAM_FIND_
							      }								    }								  LARGEST_ELEMENT_ARRAY_1.cpp:22:17: error: ‘f_fille
							      								    								  d’ is not a member of ‘std’	 return std :: f_fil
							      								    								  led ( arr , arr + n ) ;		   ^~~~~~~~
							      								    								  C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY_1.cpp:22:17:
							      								    								  note: suggested alternative: ‘fill’	 return std
							      								    								  :: f_filled ( arr , arr + n ) ;		   ^
							      								    								  ~~~~~~~		   fill
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES		      HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES			    HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES			  HEIGHT_COMPLETE_BINARY_TREE_HEAP_N_NODES
--							      --							    --								  --
def height ( N ) :					      int height ( int N ) {					    double height ( double N ) {				  success : None
    return math.ceil ( math.log2 ( N + 1 ) ) - 1	      	return ceil ( log2 ( N + 1 ) ) - 1 ;			      return ceil ( log2 ( N + 1 ) ) - 1 ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TRIANGULAR_MATCHSTICK_NUMBER				      TRIANGULAR_MATCHSTICK_NUMBER				    TRIANGULAR_MATCHSTICK_NUMBER				  TRIANGULAR_MATCHSTICK_NUMBER
--							      --							    --								  --
def numberOfSticks ( x ) :				      int numberOfSticks ( int x ) {				    double numberOfSticks ( double x ) {			  success : None
    return ( 3 * x * ( x + 1 ) ) / 2			      	return ( 3 * x * ( x + 1 ) ) / 2 ;			      return ( 3 * x * ( x + 1 ) ) / 2 ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1			      PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1			    PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1				  PROGRAM_PRINT_SUM_GIVEN_NTH_TERM_1
--							      --							    --								  --
def summingSeries ( n ) :				      int summingSeries ( long n ) {				    double summingSeries ( double n ) {				  success : None
    return math.pow ( n , 2 )				      	return pow ( n , 2 ) ;					      return pow ( n , 2 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_PENTAGONAL_NUMBER					      NTH_PENTAGONAL_NUMBER					    NTH_PENTAGONAL_NUMBER					  NTH_PENTAGONAL_NUMBER
--							      --							    --								  --
def pentagonalNum ( n ) :				      int pentagonalNum ( int n ) {				    double pentagonalNum ( double n ) {				  success : None
    return ( 3 * n * n - n ) / 2			      	return ( 3 * n * n - n ) / 2 ;				      return ( 3 * n * n - n ) / 2 ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			      CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			    CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1			  CHECK_WHETHER_GIVEN_NUMBER_EVEN_ODD_1
--							      --							    --								  --
def isEven ( n ) :					      bool isEven ( int n ) {					    bool isEven ( int n ) {					  success : identical to gold
    return ( not ( n & 1 ) )				      	return ( ! ( n & 1 ) ) ;				      return ( ! ( n & 1 ) ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_BINOMIAL_COEFFICIENTS_1				      SUM_BINOMIAL_COEFFICIENTS_1				    SUM_BINOMIAL_COEFFICIENTS_1					  SUM_BINOMIAL_COEFFICIENTS_1
--							      --							    --								  --
def binomialCoeffSum ( n ) :				      int binomialCoeffSum ( int n ) {				    int binomialCoeffSum ( int n ) {				  success : identical to gold
    return ( 1 << n )					      	return ( 1 << n ) ;					      return ( 1 << n ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GCD_ELEMENTS_GIVEN_RANGE				      GCD_ELEMENTS_GIVEN_RANGE					    GCD_ELEMENTS_GIVEN_RANGE					  GCD_ELEMENTS_GIVEN_RANGE
--							      --							    --								  --
def rangeGCD ( n , m ) :				      int rangeGCD ( int n , int m ) {				    int rangeGCD ( int n , int m ) {				  success : identical to gold
    return n if ( n == m ) else 1			      	return ( n == m ) ? n : 1 ;				      return ( n == m ) ? n : 1 ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HYPERCUBE_GRAPH						      HYPERCUBE_GRAPH						    HYPERCUBE_GRAPH						  HYPERCUBE_GRAPH
--							      --							    --								  --
def power ( n ) :					      int power ( int n ) {					    int power ( int n ) {					  success : identical to gold
    if n == 1 :						      	if ( n == 1 ) return 2 ;				      if ( n == 1 ) return 2 ;					  
	return 2					      	return 2 * power ( n - 1 ) ;				      return 2 * power ( n - 1 ) ;				  
    return 2 * power ( n - 1 )				      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		      COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		    COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW		  COMPUTE_AVERAGE_TWO_NUMBERS_WITHOUT_OVERFLOW
--							      --							    --								  --
def compute_average ( a , b ) :				      int compute_average ( int a , int b ) {			    double computeAverage ( double a , double b ) {		  success : None
    return floor ( ( a + b ) / 2 )			      	return ( a + b ) / 2 ;					      return floor ( ( a + b ) / 2 ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE  PYTHON_PROGRAM_FIND_PERIMETER_CIRCUMFERENCE_SQUARE_RECTANGLE
--							      --							    --								  --
def Circumference ( a ) :				      int Circumference ( int a ) {				    double Circumference ( double a ) {				  success : None
    return ( 4 * a )					      	return 4 * a ;						      return ( 4 * a ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_AN_INTEGER_WITH_3_5				      MULTIPLY_AN_INTEGER_WITH_3_5				    MULTIPLY_AN_INTEGER_WITH_3_5				  MULTIPLY_AN_INTEGER_WITH_3_5
--							      --							    --								  --
def multiplyWith3Point5 ( x ) :				      int multiplyWith3Point5 ( int x ) {			    int multiplyWith3Point5 ( int x ) {				  success : identical to gold
    return ( x << 1 ) + x + ( x >> 1 )			      	return ( x << 1 ) + x + ( x >> 1 ) ;			      return ( x << 1 ) + x + ( x >> 1 ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_SLOPE_LINE					      PROGRAM_FIND_SLOPE_LINE					    PROGRAM_FIND_SLOPE_LINE					  PROGRAM_FIND_SLOPE_LINE
--							      --							    --								  --
def slope ( x1 , y1 , x2 , y2 ) :			      float slope ( float x1 , float y1 , float x2 , float y2 ) {   double slope ( double x1 , double y1 , double x2 , double y2  success : None
    return ( float ) ( y2 - y1 ) / ( x2 - x1 )		      	return ( y2 - y1 ) / ( x2 - x1 ) ;			      return ( ( double ) ( y2 - y1 ) ) / ( x2 - x1 ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FACTORIAL_NUMBER				      C_PROGRAM_FACTORIAL_NUMBER				    C_PROGRAM_FACTORIAL_NUMBER					  C_PROGRAM_FACTORIAL_NUMBER
--							      --							    --								  --
def factorial ( n ) :					      unsigned int factorial ( unsigned int n ) {		    int factorial ( int n ) {					  success : None
    return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 	if ( n == 0 ) return 1 ;				      return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; 
							      	return n * factorial ( n - 1 ) ;			    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS		      DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS		    DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS			  DETECT_IF_TWO_INTEGERS_HAVE_OPPOSITE_SIGNS
--							      --							    --								  --
def oppositeSigns ( x , y ) :				      bool oppositeSigns ( int x , int y ) {			    bool oppositeSigns ( int x , int y ) {			  success : identical to gold
    return ( ( x ^ y ) < 0 )				      	return ( ( x ^ y ) < 0 ) ;				      return ( ( x ^ y ) < 0 ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_TWO_NIBBLES_BYTE					      SWAP_TWO_NIBBLES_BYTE					    SWAP_TWO_NIBBLES_BYTE					  SWAP_TWO_NIBBLES_BYTE
--							      --							    --								  --
def swapNibbles ( x ) :					      int swapNibbles ( int x ) {				    int swapNibbles ( int x ) {					  success : identical to gold
    return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 )	      	return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ;	      return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SUBSTRINGS_STRING				      NUMBER_SUBSTRINGS_STRING					    NUMBER_SUBSTRINGS_STRING					  NUMBER_SUBSTRINGS_STRING
--							      --							    --								  --
def countNonEmptySubstr ( str ) :			      int countNonEmptySubstr ( string str ) {			    int countNonEmptySubstr ( string str ) {			  success : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    return int ( n * ( n + 1 ) / 2 )			      	return n * ( n + 1 ) / 2 ;				      return ( int ) ( n * ( n + 1 ) / 2 ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		      COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		    COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER		  COMPUTE_MODULUS_DIVISION_BY_A_POWER_OF_2_NUMBER
--							      --							    --								  --
def getModulo ( n , d ) :				      unsigned int getModulo ( unsigned int n , unsigned int d ) {  int getModulo ( int n , int d ) {				  success : None
    return ( n & ( d - 1 ) )				      	return ( n & ( d - 1 ) ) ;				      return ( n & ( d - 1 ) ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_TERM_SERIES_2_12_36_80_150				      N_TH_TERM_SERIES_2_12_36_80_150				    N_TH_TERM_SERIES_2_12_36_80_150				  N_TH_TERM_SERIES_2_12_36_80_150
--							      --							    --								  --
def nthTerm ( n ) :					      int nthTerm ( int n ) {					    double nthTerm ( double n ) {				  success : None
    return ( n * n ) + ( n * n * n )			      	return ( n * n ) + ( n * n * n ) ;			      return ( n * n ) + ( n * n * n ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10 EFFICIENT_WAY_CHECK_WHETHER_N_TH_FIBONACCI_NUMBER_MULTIPLE_10
--							      --							    --								  --
def isMultipleOf10 ( n ) :				      bool isMultipleOf10 ( int n ) {				    bool isMultipleOf10 ( int n ) {				  success : identical to gold
    return ( n % 15 == 0 )				      	return ( n % 15 == 0 ) ;				      return ( n % 15 == 0 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_FACTORIAL_OF_A_NUMBER			      PROGRAM_FOR_FACTORIAL_OF_A_NUMBER				    PROGRAM_FOR_FACTORIAL_OF_A_NUMBER				  PROGRAM_FOR_FACTORIAL_OF_A_NUMBER
--							      --							    --								  --
def factorial ( n ) :					      unsigned int factorial ( unsigned int n ) {		    int factorial ( int n ) {					  success : None
    return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 	if ( n == 0 ) return 1 ;				      return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; 
							      	return n * factorial ( n - 1 ) ;			    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BREAK_NUMBER_THREE_PARTS_1				      BREAK_NUMBER_THREE_PARTS_1				    BREAK_NUMBER_THREE_PARTS_1					  BREAK_NUMBER_THREE_PARTS_1
--							      --							    --								  --
def count_of_ways ( n ) :				      ll count_of_ways ( ll n ) {				    int countOfWays ( int n ) {					  script_not_found : None
    count = 0						      	ll count ;						      int count = 0 ;						  
    count = ( n + 1 ) * ( n + 2 ) // 2			      	count = ( n + 1 ) * ( n + 2 ) / 2 ;			      count = ( n + 1 ) * ( n + 2 ) / 2 ;			  
    return count					      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			      BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			    BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS			  BASIC_AND_EXTENDED_EUCLIDEAN_ALGORITHMS
--							      --							    --								  --
def gcd ( a , b ) :					      int gcd ( int a , int b ) {				    int gcd ( int a , int b ) {					  success : identical to gold
    if a == 0 :						      	if ( a == 0 ) return b ;				      if ( a == 0 ) return b ;					  
	return b					      	return gcd ( b % a , a ) ;				      return gcd ( b % a , a ) ;				  
    return gcd ( b % a , a )				      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_RECTANGLES_NM_GRID				      NUMBER_RECTANGLES_NM_GRID					    NUMBER_RECTANGLES_NM_GRID					  NUMBER_RECTANGLES_NM_GRID
--							      --							    --								  --
def rectCount ( n , m ) :				      int rectCount ( int n , int m ) {				    int rectCount ( int n , int m ) {				  success : identical to gold
    return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4	      	return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;		      return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_VOLUME_ELLIPSOID			      PROGRAM_CALCULATE_VOLUME_ELLIPSOID			    PROGRAM_CALCULATE_VOLUME_ELLIPSOID				  PROGRAM_CALCULATE_VOLUME_ELLIPSOID
--							      --							    --								  --
def volumeOfEllipsoid ( r1 , r2 , r3 ) :		      float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) {  double volumeOfEllipsoid ( double r1 , double r2 , double r3  error : PROGRAM_CALCULATE_VOLUME_ELLIPSOID.cpp: In
    return 1.33 * math.pi * r1 * r2 * r3		      	float pi = 3.14 ;					      return 1.33 * M_PI * r1 * r2 * r3 * r3 * r3 * r3 * r3 * r3   function ‘double f_filled(double, double, double)
							      	return 1.33 * pi * r1 * r2 * r3 ;			    								  ’: PROGRAM_CALCULATE_VOLUME_ELLIPSOID.cpp:25:1: er
							      }								    								  ror: expected primary-expression before ‘int’	 int
							      								    								   main() {  ^~~ PROGRAM_CALCULATE_VOLUME_ELLIPSOID.
							      								    								  cpp:23:228: error: expected ‘;’ before ‘int’	  re
							      								    								  turn 1.33 * M_PI * r1 * r2 * r3 * r3 * r3 * r3 * r
							      								    								  3 * r3 * r3 * r3 * r3 * r3 * r3 * r3 * r3 * r3 * r
							      								    								  3 * r3 * r3 * r3 * r3 * r3 * r3 * r3 * r3 * r3 * r
							      								    								  3 * r3 * r3 * r3 * r3 * r3 * r3 * r3 * r3 * r3 * r
							      								    								  3 * r3 * r3 * r3 * r3 *
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								    ^
							      								    								  
							      								    								  
							      								    								  
							      								    								  				  ; PROGRAM_CALCULAT
							      								    								  E_VOLUME_ELLIPSOID.cpp:25:1:	int main() {  ~~~
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  			 PROGRAM_CALCULATE_VOLUME_EL
							      								    								  LIPSOID.cpp:25:12: error: a function-definition is
							      								    								   not allowed here before ‘{’ token  int main() {
							      								    								  	     ^ PROGRAM_CALCULATE_VOLUME_ELLIPSOID.cp
							      								    								  p:39:1: error: expected ‘}’ at end of input  }  ^
							      								    								  PROGRAM_CALCULATE_VOLUME_ELLIPSOID.cpp:22:55: note
							      								    								  : to match this ‘{’  double f_filled ( double r1 ,
							      								    								   double r2 , double r3 ) {
							      								    								  				  ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR    PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR    PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR	  PROGRAM_TO_FIND_REMAINDER_WITHOUT_USING_MODULO_OR_OPERATOR
--							      --							    --								  --
def getRemainder ( num , divisor ) :			      int getRemainder ( int num , int divisor ) {		    int getRemainder ( int num , int divisor ) {		  success : identical to gold
    return ( num - divisor * ( num // divisor ) )	      	return ( num - divisor * ( num / divisor ) ) ;		      return ( num - divisor * ( num / divisor ) ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			      PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			    PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES			  PIZZA_CUT_PROBLEM_CIRCLE_DIVISION_LINES
--							      --							    --								  --
def findMaximumPieces ( n ) :				      int findMaximumPieces ( int n ) {				    int findMaximumPieces ( int n ) {				  success : None
    return int ( 1 + n * ( n + 1 ) / 2 )		      	return 1 + n * ( n + 1 ) / 2 ;				      return int ( 1 + n * ( n + 1 ) / 2 ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1		      FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1		    FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1			  FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS_1
--							      --							    --								  --
def evenbinomialCoeffSum ( n ) :			      int evenbinomialCoeffSum ( int n ) {			    int evenbinomialCoeffSum ( int n ) {			  success : identical to gold
    return ( 1 << ( n - 1 ) )				      	return ( 1 << ( n - 1 ) ) ;				      return ( 1 << ( n - 1 ) ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_INCREASING_SUBSEQUENCE				      LONGEST_INCREASING_SUBSEQUENCE				    LONGEST_INCREASING_SUBSEQUENCE				  LONGEST_INCREASING_SUBSEQUENCE
--							      --							    --								  --
def lis ( arr ) :					      int lis ( int arr [ ] , int n ) {				    int lis ( int * arr ) {					  script_not_found : None
    global maximum					      	int max = 1 ;						      int maximum ;						  
    n = len ( arr )					      	_lis ( arr , n , & max ) ;				      int n = sizeof ( arr ) / sizeof ( int ) ;			  
    maximum = 1						      	return max ;						      maximum = 1 ;						  
    _lis ( arr , n )					      }								      lis ( arr , n ) ;						  
    return maximum					      								      return maximum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_AREA_OCTAGON				      PROGRAM_CALCULATE_AREA_OCTAGON				    PROGRAM_CALCULATE_AREA_OCTAGON				  PROGRAM_CALCULATE_AREA_OCTAGON
--							      --							    --								  --
def areaOctagon ( side ) :				      double areaOctagon ( double side ) {			    double areaOctagon ( double side ) {			  success : None
    return ( 2 * ( 1 + ( math.sqrt ( 2 ) ) ) * side * side )  	return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ;   return ( 2 * ( 1 + ( sqrt ( 2 ) ) ) * side * side ) ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			      PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			    PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON			  PROGRAM_FOR_SURFACE_AREA_OF_OCTAHEDRON
--							      --							    --								  --
def surface_area_octahedron ( side ) :			      double surface_area_octahedron ( double side ) {		    double surfaceAreaOctahedron ( double side ) {		  success : None
    return ( 2 * ( math.sqrt ( 3 ) ) * ( side * side ) )      	return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ;	      return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_CONTAIN_1_N_VALUES				      SORT_ARRAY_CONTAIN_1_N_VALUES				    SORT_ARRAY_CONTAIN_1_N_VALUES				  SORT_ARRAY_CONTAIN_1_N_VALUES
--							      --							    --								  --
def sortit ( arr , n ) :				      void sortit ( int arr [ ] , int n ) {			    int sortit ( int * arr , int n ) {				  success : None
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	arr [ i ] = i + 1				      	i < n ;							      i < n ;							  
							      	i ++ ) {						      i ++ ) arr [ i ] = i + 1 ;				  
							      	  arr [ i ] = i + 1 ;					      return n ;						  
							      	}							    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS_2					      SUM_PAIRWISE_PRODUCTS_2					    SUM_PAIRWISE_PRODUCTS_2					  SUM_PAIRWISE_PRODUCTS_2
--							      --							    --								  --
def findSum ( n ) :					      long long int findSum ( int n ) {				    double findSum ( double n ) {				  success : None
    return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24     	return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ;	      return n * ( n + 1 ) * ( n + 2 ) * ( 3 * n + 1 ) / 24 ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CALCULATE_VOLUME_OCTAHEDRON			      PROGRAM_CALCULATE_VOLUME_OCTAHEDRON			    PROGRAM_CALCULATE_VOLUME_OCTAHEDRON				  PROGRAM_CALCULATE_VOLUME_OCTAHEDRON
--							      --							    --								  --
def vol_of_octahedron ( side ) :			      double vol_of_octahedron ( double side ) {		    double volOfOctahedron ( double side ) {			  success : None
    return ( ( side * side * side ) * ( math.sqrt ( 2 ) / 3 ) 	return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ) ;      return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ) ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	      PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	    PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM	  PROGRAM_FOR_DEADLOCK_FREE_CONDITION_IN_OPERATING_SYSTEM
--							      --							    --								  --
def Resources ( process , need ) :			      int Resources ( int process , int need ) {		    int Resources ( int process , int need ) {			  success : identical to gold
    minResources = 0					      	int minResources = 0 ;					      int minResources = 0 ;					  
    minResources = process * ( need - 1 ) + 1		      	minResources = process * ( need - 1 ) + 1 ;		      minResources = process * ( need - 1 ) + 1 ;		  
    return minResources					      	return minResources ;					      return minResources ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		      PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		    PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP		  PROBABILITY_THREE_RANDOMLY_CHOSEN_NUMBERS_AP
--							      --							    --								  --
def procal ( n ) :					      double procal ( int n ) {					    double procal ( double n ) {				  success : None
    return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 )	      	return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;		      return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	      MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	    MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS	  MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS
--							      --							    --								  --
def cost ( a , n ) :					      int cost ( int a [ ] , int n ) {				    double cost ( double a , double n ) {			  error : MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LA
    return ( ( n - 1 ) * min ( a ) )			      	return ( n - 1 ) * ( * min_element ( a , a + n ) ) ;	      return ( ( n - 1 ) * min ( a ) ) ;			  RGER_PAIRS.cpp: In function ‘double f_filled(doubl
							      }								    }								  e, double)’: MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVI
							      								    								  NG_LARGER_PAIRS.cpp:22:32: error: no matching func
							      								    								  tion for call to ‘min(double&)’    return ( ( n -
							      								    								  1 ) * min ( a ) ) ;
							      								    								    ^ In file included from /usr/include/c++/8/bits/
							      								    								  char_traits.h:39,		     from /usr/inclu
							      								    								  de/c++/8/ios:40,		    from /usr/includ
							      								    								  e/c++/8/ostream:38,		       from /usr/inc
							      								    								  lude/c++/8/iostream:39,		   from MINI
							      								    								  MUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS.c
							      								    								  pp:8: /usr/include/c++/8/bits/stl_algobase.h:195:5
							      								    								  : note: candidate: ‘template<class _Tp> constexpr
							      								    								  const _Tp& std::min(const _Tp&, const _Tp&)’
							      								    								  min(const _Tp& __a, const _Tp& __b)	   ^~~ /usr/
							      								    								  include/c++/8/bits/stl_algobase.h:195:5: note:   t
							      								    								  emplate argument deduction/substitution failed: MI
							      								    								  NIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS
							      								    								  .cpp:22:32: note:   candidate expects 2 arguments,
							      								    								   1 provided	 return ( ( n - 1 ) * min ( a ) ) ;
							      								    								  				  ^ In file included
							      								    								   from /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  		 from /usr/include/c++/8/ios:40,
							      								    								  		from /usr/include/c++/8/ostream:38,
							      								    								  		   from /usr/include/c++/8/iostream:
							      								    								  39,		       from MINIMUM_COST_MAKE_ARRAY_
							      								    								  SIZE_1_REMOVING_LARGER_PAIRS.cpp:8: /usr/include/c
							      								    								  ++/8/bits/stl_algobase.h:243:5: note: candidate: ‘
							      								    								  template<class _Tp, class _Compare> constexpr cons
							      								    								  t _Tp& std::min(const _Tp&, const _Tp&, _Compare)’
							      								    								  	min(const _Tp& __a, const _Tp& __b, _Compare
							      								    								   __comp)	^~~ /usr/include/c++/8/bits/stl_algo
							      								    								  base.h:243:5: note:	template argument deduction/
							      								    								  substitution failed: MINIMUM_COST_MAKE_ARRAY_SIZE_
							      								    								  1_REMOVING_LARGER_PAIRS.cpp:22:32: note:   candida
							      								    								  te expects 3 arguments, 1 provided	return ( ( n
							      								    								   - 1 ) * min ( a ) ) ;
							      								    								       ^ In file included from /usr/include/c++/8/al
							      								    								  gorithm:62,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:65,
							      								    								  	  from MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVI
							      								    								  NG_LARGER_PAIRS.cpp:14: /usr/include/c++/8/bits/st
							      								    								  l_algo.h:3450:5: note: candidate: ‘template<class
							      								    								  _Tp> constexpr _Tp std::min(std::initializer_list<
							      								    								  _Tp>)’      min(initializer_list<_Tp> __l)	  ^~
							      								    								  ~ /usr/include/c++/8/bits/stl_algo.h:3450:5: note:
							      								    								     template argument deduction/substitution failed
							      								    								  : MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_P
							      								    								  AIRS.cpp:22:32: note:	  mismatched types ‘std::ini
							      								    								  tializer_list<_Tp>’ and ‘double’    return ( ( n -
							      								    								   1 ) * min ( a ) ) ;
							      								    								     ^ In file included from /usr/include/c++/8/algo
							      								    								  rithm:62,		     from /usr/include/c++/8
							      								    								  /x86_64-redhat-linux/bits/stdc++.h:65,
							      								    								  	from MINIMUM_COST_MAKE_ARRAY_SIZE_1_REMOVING
							      								    								  _LARGER_PAIRS.cpp:14: /usr/include/c++/8/bits/stl_
							      								    								  algo.h:3456:5: note: candidate: ‘template<class _T
							      								    								  p, class _Compare> constexpr _Tp std::min(std::ini
							      								    								  tializer_list<_Tp>, _Compare)’      min(initialize
							      								    								  r_list<_Tp> __l, _Compare __comp)	 ^~~ /usr/in
							      								    								  clude/c++/8/bits/stl_algo.h:3456:5: note:   templa
							      								    								  te argument deduction/substitution failed: MINIMUM
							      								    								  _COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS.cpp:
							      								    								  22:32: note:	 mismatched types ‘std::initializer_
							      								    								  list<_Tp>’ and ‘double’    return ( ( n - 1 ) * mi
							      								    								  n ( a ) ) ;				      ^ MINI
							      								    								  MUM_COST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS.c
							      								    								  pp: In function ‘int main()’: MINIMUM_COST_MAKE_AR
							      								    								  RAY_SIZE_1_REMOVING_LARGER_PAIRS.cpp:32:21: error:
							      								    								   cannot convert ‘__gnu_cxx::__alloc_traits<std::al
							      								    								  locator<int>, int>::value_type*’ {aka ‘int*’} to ‘
							      								    								  double’	   if(f_filled(&param0[i].front(),pa
							      								    								  ram1[i]) == f_gold(&param0[i].front(),param1[i]))
							      								    								  		       ^~~~~~~~~~~~~~~~~~ MINIMUM_CO
							      								    								  ST_MAKE_ARRAY_SIZE_1_REMOVING_LARGER_PAIRS.cpp:21:
							      								    								  26: note:   initializing argument 1 of ‘double f_f
							      								    								  illed(double, double)’  double f_filled ( double a
							      								    								   , double n ) {		     ~~~~~~~^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW
--							      --							    --								  --
def isPowerOfTwo ( x ) :				      int bool isPowerOfTwo ( int x ) {				    bool isPowerOfTwo ( uint64_t x ) {				  script_not_found : None
    return ( x and ( not ( x & ( x - 1 ) ) ) )		      	return x && ( ! ( x & ( x - 1 ) ) ) ;			      return ( x > 0 ) && ( ! ( x & ( x - 1 ) ) ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1			      PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1			    PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1				  PROGRAM_FOR_FACTORIAL_OF_A_NUMBER_1
--							      --							    --								  --
def factorial ( n ) :					      unsigned int factorial ( unsigned int n ) {		    int factorial ( int n ) {					  success : None
    return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 	int res = 1 , i ;					      return ( n == 1 || n == 0 ) ? 1 : n * factorial ( n - 1 ) ; 
							      	for ( i = 2 ;						    }								  
							      	i <= n ;						    								  
							      	i ++ ) res *= i ;					    								  
							      	return res ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPETITIVE_ELEMENT_1_N_1				      FIND_REPETITIVE_ELEMENT_1_N_1				    FIND_REPETITIVE_ELEMENT_1_N_1				  FIND_REPETITIVE_ELEMENT_1_N_1
--							      --							    --								  --
def findRepeating ( arr , n ) :				      int findRepeating ( int arr [ ] , int n ) {		    int findRepeating ( int * arr , int n ) {			  failure : #Results: 0, 10
    return sum ( arr ) - ( ( ( n - 1 ) * n ) // 2 )	      	return accumulate ( arr , arr + n , 0 ) - ( ( n - 1 ) * n /   return memcmp ( arr , arr + ( ( n - 1 ) * n ) / 2 , n ) ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STACK_SET_3_REVERSE_STRING_USING_STACK			      STACK_SET_3_REVERSE_STRING_USING_STACK			    STACK_SET_3_REVERSE_STRING_USING_STACK			  STACK_SET_3_REVERSE_STRING_USING_STACK
--							      --							    --								  --
def reverse ( string ) :				      void reverse ( char str [ ] ) {				    string reverse ( string string ) {				  script_not_found : None
    string = string [ : : - 1 ]				      	int n = strlen ( str ) , i ;				      string result = string . substr ( 0 , string . length ( ) - 
    return string					      	for ( i = 0 ;						      return result ;						  
							      	i < n / 2 ;						    }								  
							      	i ++ ) swap ( & str [ i ] , & str [ n - i - 1 ] ) ;	    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT     PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT	    PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT	  PROGRAMMING_PUZZLE_ASSIGN_VALUE_WITHOUT_CONTROL_STATEMENT
--							      --							    --								  --
def assignValue ( a , b , x ) :				      int assignValue ( int a , int b , bool x ) {		    double assignValue ( double a , double b , int x ) {	  failure : #Results: 0, 10
    arr = [ a , b ]					      	int arr [ ] = {						      double * arr = new double [ 2 ] ;				  
    return ( arr [ x ] )				      	  a , b }						      arr [ 0 ] = a ;						  
							      	  ;							      arr [ 1 ] = b ;						  
							      	  return ( arr [ x ] ) ;				      return ( arr [ x ] ) ;					  
							      	}							    }								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_2				      COUNT_SET_BITS_IN_AN_INTEGER_2				    COUNT_SET_BITS_IN_AN_INTEGER_2				  COUNT_SET_BITS_IN_AN_INTEGER_2
--							      --							    --								  --
def countSetBits ( n ) :				      public : unsigned int countSetBits ( int n ) {		    int countSetBits ( int n ) {				  script_not_found : None
    count = 0						      	unsigned int count = 0 ;				      int count = 0 ;						  
    while ( n ) :					      	while ( n ) {						      while ( ( n ) ) {						  
	n &= ( n - 1 )					      	  n &= ( n - 1 ) ;					    	n &= ( n - 1 ) ;					  
	count += 1					      	  count ++ ;						    	count ++ ;						  
    return count					      	}							      }								  
							      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1		      BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1			    BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1			  BINARY_REPRESENTATION_OF_A_GIVEN_NUMBER_1
--							      --							    --								  --
def bin ( n ) :						      void bin ( unsigned n ) {					    int bin ( int n ) {						  script_not_found : None
    if ( n > 1 ) :					      	if ( n > 1 ) bin ( n >> 1 ) ;				      if ( ( n > 1 ) ) bin ( n >> 1 ) ;				  
	bin ( n >> 1 )					      	printf ( "%d" , n & 1 ) ;				      cout << n & 1 << " " ;					  
    print ( n & 1 , end = "" )				      }								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS		      SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS			    SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS			  SUM_SERIES_0_6_0_06_0_006_0_0006_N_TERMS
--							      --							    --								  --
def sumOfSeries ( n ) :					      float sumOfSeries ( int n ) {				    double sumOfSeries ( int n ) {				  success : None
    return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) )	      	return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ;		      return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ) ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1     SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1	    SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1	  SUM_OF_ALL_ELEMENTS_UP_TO_NTH_ROW_IN_A_PASCALS_TRIANGLE_1
--							      --							    --								  --
def calculateSum ( n ) :				      long long int calculateSum ( int n ) {			    int calculateSum ( int n ) {				  success : None
    sum = 0						      	long long int sum = 0 ;					      int sum = 0 ;						  
    sum = 1 << n					      	sum = 1 << n ;						      sum = 1 << n ;						  
    return ( sum - 1 )					      	return ( sum - 1 ) ;					      return ( sum - 1 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_1				      COUNT_SET_BITS_IN_AN_INTEGER_1				    COUNT_SET_BITS_IN_AN_INTEGER_1				  COUNT_SET_BITS_IN_AN_INTEGER_1
--							      --							    --								  --
def countSetBits ( n ) :				      int countSetBits ( int n ) {				    int countSetBits ( int n ) {				  success : None
    if ( n == 0 ) :					      	if ( n == 0 ) return 0 ;				      if ( ( n == 0 ) ) return 0 ;				  
	return 0					      	else return ( n & 1 ) + countSetBits ( n >> 1 ) ;	      else return ( n & 1 ) + countSetBits ( n >> 1 ) ;		  
    else :						      }								    }								  
	return ( n & 1 ) + countSetBits ( n >> 1 )	      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SET_BITS_IN_AN_INTEGER_3				      COUNT_SET_BITS_IN_AN_INTEGER_3				    COUNT_SET_BITS_IN_AN_INTEGER_3				  COUNT_SET_BITS_IN_AN_INTEGER_3
--							      --							    --								  --
def countSetBits ( n ) :				      int countSetBits ( int n ) {				    int countSetBits ( int n ) {				  success : None
    if ( n == 0 ) :					      	if ( n == 0 ) return 0 ;				      if ( ( n == 0 ) ) return 0 ;				  
	return 0					      	else return 1 + countSetBits ( n & ( n - 1 ) ) ;	      else return 1 + countSetBits ( n & ( n - 1 ) ) ;		  
    else :						      }								    }								  
	return 1 + countSetBits ( n & ( n - 1 ) )	      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY		      KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY		    KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY			  KTH_SMALLESTLARGEST_ELEMENT_UNSORTED_ARRAY
--							      --							    --								  --
def kthSmallest ( arr , n , k ) :			      int kthSmallest ( int arr [ ] , int n , int k ) {		    int kthSmallest ( int * arr , int n , int k ) {		  script_not_found : None
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    return arr [ k - 1 ]				      	return arr [ k - 1 ] ;					      return arr [ k - 1 ] ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE      DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE	    DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE
--							      --							    --								  --
def lis ( arr ) :					      int lis ( int arr [ ] , int n ) {				    int lis ( int * arr ) {					  script_not_found : None
    global maximum					      	int max = 1 ;						      int maximum ;						  
    n = len ( arr )					      	_lis ( arr , n , & max ) ;				      int n = sizeof ( arr ) / sizeof ( int ) ;			  
    maximum = 1						      	return max ;						      maximum = 1 ;						  
    _lis ( arr , n )					      }								      lis ( arr , n ) ;						  
    return maximum					      								      return maximum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I AREA_OF_THE_CIRCLE_THAT_HAS_A_SQUARE_AND_A_CIRCLE_INSCRIBED_I
--							      --							    --								  --
def getArea ( a ) :					      float getArea ( int a ) {					    double getArea ( double a ) {				  success : None
    area = ( math.pi * a * a ) / 4			      	float area = ( M_PI * a * a ) / 4.0 ;			      double area = ( M_PI * a * a ) / 4 ;			  
    return area						      	return area ;						      return area ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		      C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		    C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES		  C_PROGRAM_CONCATENATE_STRING_GIVEN_NUMBER_TIMES
--							      --							    --								  --
def repeat ( s , n ) :					      string repeat ( string s , int n ) {			    string repeat ( string s , int n ) {			  success : identical to gold
    s1 = s						      	string s1 = s ;						      string s1 = s ;						  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	s += s1						      	i < n ;							      i < n ;							  
    return s						      	i ++ ) s += s1 ;					      i ++ ) s += s1 ;						  
							      	return s ;						      return s ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			      FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			    FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X			  FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X
--							      --							    --								  --
def yMod ( y , x ) :					      long long int yMod ( long long int y , long long int x ) {    int yMod ( int y , int x ) {				  error : FIND_VALUE_OF_Y_MOD_2_RAISED_TO_POWER_X.cp
    return ( y % pow ( 2 , x ) )			      	if ( log2 ( y ) < x ) return y ;			      return ( y % pow ( 2 , x ) ) ;				  p: In function ‘int f_filled(int, int)’: FIND_VALU
							      	if ( x > 63 ) return y ;				    }								  E_OF_Y_MOD_2_RAISED_TO_POWER_X.cpp:24:14: error: i
							      	return ( y % ( 1 << x ) ) ;				    								  nvalid operands of types ‘int’ and ‘__gnu_cxx::__p
							      }								    								  romote_2<int, int, double, double>::__type’ {aka ‘
							      								    								  double’} to binary ‘operator%’    return ( y % pow
							      								    								   ( 2 , x ) ) ;	     ~~^~~~~~~~~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY		      MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY			    MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY			  MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY
--							      --							    --								  --
def minSum ( A ) :					      int minSum ( int A [ ] , int n ) {			    double minSum ( double * A ) {				  error : MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.c
    min_val = min ( A ) ;				      	int min_val = * min_element ( A , A + n ) ;		      double minVal = min ( A ) ;				  pp: In function ‘double f_filled(double*)’: MINIMU
    return min_val * ( len ( A ) - 1 )			      	return ( min_val * ( n - 1 ) ) ;			      ;								  M_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp:23:27: erro
							      }								      return minVal * ( A - 1 ) ;				  r: no matching function for call to ‘min(double*&)
							      								    }								  ’    double minVal = min ( A ) ;
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/bits/char_traits.h:39,		     from /u
							      								    								  sr/include/c++/8/ios:40,		    from /us
							      								    								  r/include/c++/8/ostream:38,		       from
							      								    								  /usr/include/c++/8/iostream:39,		   f
							      								    								  rom MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp:8
							      								    								  : /usr/include/c++/8/bits/stl_algobase.h:195:5: no
							      								    								  te: candidate: ‘template<class _Tp> constexpr cons
							      								    								  t _Tp& std::min(const _Tp&, const _Tp&)’	min(
							      								    								  const _Tp& __a, const _Tp& __b)      ^~~ /usr/incl
							      								    								  ude/c++/8/bits/stl_algobase.h:195:5: note:   templ
							      								    								  ate argument deduction/substitution failed: MINIMU
							      								    								  M_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp:23:27: note
							      								    								  :   candidate expects 2 arguments, 1 provided	   d
							      								    								  ouble minVal = min ( A ) ;
							      								    								      ^ In file included from /usr/include/c++/8/bit
							      								    								  s/char_traits.h:39,		       from /usr/inc
							      								    								  lude/c++/8/ios:40,		      from /usr/incl
							      								    								  ude/c++/8/ostream:38,			 from /usr/i
							      								    								  nclude/c++/8/iostream:39,		     from MI
							      								    								  NIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp:8: /usr
							      								    								  /include/c++/8/bits/stl_algobase.h:243:5: note: ca
							      								    								  ndidate: ‘template<class _Tp, class _Compare> cons
							      								    								  texpr const _Tp& std::min(const _Tp&, const _Tp&,
							      								    								  _Compare)’	  min(const _Tp& __a, const _Tp& __b
							      								    								  , _Compare __comp)	  ^~~ /usr/include/c++/8/bit
							      								    								  s/stl_algobase.h:243:5: note:	  template argument
							      								    								  deduction/substitution failed: MINIMUM_SUM_CHOOSIN
							      								    								  G_MINIMUM_PAIRS_ARRAY.cpp:23:27: note:   candidate
							      								    								   expects 3 arguments, 1 provided    double minVal
							      								    								  = min ( A ) ;				   ^ In file
							      								    								   included from /usr/include/c++/8/algorithm:62,
							      								    								  		 from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:65,		      from M
							      								    								  INIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp:14: /u
							      								    								  sr/include/c++/8/bits/stl_algo.h:3450:5: note: can
							      								    								  didate: ‘template<class _Tp> constexpr _Tp std::mi
							      								    								  n(std::initializer_list<_Tp>)’      min(initialize
							      								    								  r_list<_Tp> __l)	^~~ /usr/include/c++/8/bits/
							      								    								  stl_algo.h:3450:5: note:   template argument deduc
							      								    								  tion/substitution failed: MINIMUM_SUM_CHOOSING_MIN
							      								    								  IMUM_PAIRS_ARRAY.cpp:23:27: note:   mismatched typ
							      								    								  es ‘std::initializer_list<_Tp>’ and ‘double*’	   d
							      								    								  ouble minVal = min ( A ) ;
							      								    								      ^ In file included from /usr/include/c++/8/alg
							      								    								  orithm:62,		      from /usr/include/c++/
							      								    								  8/x86_64-redhat-linux/bits/stdc++.h:65,
							      								    								  	 from MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARR
							      								    								  AY.cpp:14: /usr/include/c++/8/bits/stl_algo.h:3456
							      								    								  :5: note: candidate: ‘template<class _Tp, class _C
							      								    								  ompare> constexpr _Tp std::min(std::initializer_li
							      								    								  st<_Tp>, _Compare)’	   min(initializer_list<_Tp>
							      								    								   __l, _Compare __comp)      ^~~ /usr/include/c++/8
							      								    								  /bits/stl_algo.h:3456:5: note:   template argument
							      								    								   deduction/substitution failed: MINIMUM_SUM_CHOOSI
							      								    								  NG_MINIMUM_PAIRS_ARRAY.cpp:23:27: note:   mismatch
							      								    								  ed types ‘std::initializer_list<_Tp>’ and ‘double*
							      								    								  ’    double minVal = min ( A ) ;
							      								    								  	    ^ MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARR
							      								    								  AY.cpp:25:17: error: invalid operands of types ‘do
							      								    								  uble’ and ‘double*’ to binary ‘operator*’    retur
							      								    								  n minVal * ( A - 1 ) ;	   ~~~~~~~^~~~~~~~~~
							      								    								  ~ MINIMUM_SUM_CHOOSING_MINIMUM_PAIRS_ARRAY.cpp: In
							      								    								   function ‘int main()’: MINIMUM_SUM_CHOOSING_MINIM
							      								    								  UM_PAIRS_ARRAY.cpp:35:21: error: cannot convert ‘_
							      								    								  _gnu_cxx::__alloc_traits<std::allocator<int>, int>
							      								    								  ::value_type*’ {aka ‘int*’} to ‘double*’
							      								    								  if(f_filled(&param0[i].front(),param1[i]) == f_gol
							      								    								  d(&param0[i].front(),param1[i]))
							      								    								      ^~~~~~~~~~~~~~~~~~ MINIMUM_SUM_CHOOSING_MINIMU
							      								    								  M_PAIRS_ARRAY.cpp:22:28: note:   initializing argu
							      								    								  ment 1 of ‘double f_filled(double*)’	double f_fil
							      								    								  led ( double * A ) {			  ~~~~~~~~~^
							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REVERSE_A_STRING_USING_RECURSION			      REVERSE_A_STRING_USING_RECURSION				    REVERSE_A_STRING_USING_RECURSION				  REVERSE_A_STRING_USING_RECURSION
--							      --							    --								  --
def reverse ( string ) :				      void reverse ( string str ) {				    int getNum ( string str ) {					  script_not_found : None
    if len ( string ) == 0 :				      	if ( str . size ( ) == 0 ) {				      int num = 0 ;						  
	return						      	  return ;						      for ( int i = 0 ;						  
    temp = string [ 0 ]					      	}							      i < str . length ( ) ;					  
    reverse ( string [ 1 : ] )				      	reverse ( str . substr ( 1 ) ) ;			      i ++ ) {							  
    print ( temp , end = '' )				      	cout << str [ 0 ] ;					    	char temp = str [ i ] ;					  
							      }								    	if ( temp == ' ' ) num ++ ;				  
							      								    	else if ( temp == '\t' ) num ++ ;			  
							      								    	else if ( temp == '\n' ) num ++ ;			  
							      								    	else if ( temp == ' ' ) num ++ ;			  
							      								    	else if ( temp == '\r' ) num ++ ;			  
							      								    	else if ( temp == '\t' ) num ++ ;			  
							      								      }								  
							      								      return num ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ADD_1_TO_A_GIVEN_NUMBER					      ADD_1_TO_A_GIVEN_NUMBER					    ADD_1_TO_A_GIVEN_NUMBER					  ADD_1_TO_A_GIVEN_NUMBER
--							      --							    --								  --
def addOne ( x ) :					      int addOne ( int x ) {					    int addOne ( int x ) {					  success : None
    m = 1						      	int m = 1 ;						      int m = 1 ;						  
    while ( x & m ) :					      	while ( x & m ) {					      while ( ( x & m ) != 0 ) {				  
	x = x ^ m					      	  x = x ^ m ;						    	x = x ^ m ;						  
	m <<= 1						      	  m <<= 1 ;						    	m <<= 1 ;						  
    x = x ^ m						      	}							      }								  
    return x						      	x = x ^ m ;						      x = x ^ m ;						  
							      	return x ;						      return x ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LINEAR_SEARCH						      LINEAR_SEARCH						    LINEAR_SEARCH						  LINEAR_SEARCH
--							      --							    --								  --
def search ( arr , n , x ) :				      int search ( int arr [ ] , int n , int x ) {		    int search ( int * arr , int n , int x ) {			  script_not_found : None
    for i in range ( 0 , n ) :				      	int i ;							      for ( int i = 0 ;						  
	if ( arr [ i ] == x ) :				      	for ( i = 0 ;						      i != n ;							  
	    return i					      	i < n ;							      i ++ ) if ( ( arr [ i ] == x ) ) return i ;		  
    return - 1						      	i ++ ) if ( arr [ i ] == x ) return i ;			      return - 1 ;						  
							      	return - 1 ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS MAXIMUM_NUMBER_OF_SQUARES_THAT_CAN_BE_FIT_IN_A_RIGHT_ANGLE_IS
--							      --							    --								  --
def maxSquare ( b , m ) :				      int maxSquare ( int b , int m ) {				    double maxSquare ( double b , double m ) {			  failure : #Results: 0, 10
    return ( b / m - 1 ) * ( b / m ) / 2		      	return ( b / m - 1 ) * ( b / m ) / 2 ;			      return ( b / m - 1 ) * ( b / m ) / 2 ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_INPUT_INTEGER_STRING			      PROGRAM_CHECK_INPUT_INTEGER_STRING			    PROGRAM_CHECK_INPUT_INTEGER_STRING				  PROGRAM_CHECK_INPUT_INTEGER_STRING
--							      --							    --								  --
def isNumber ( s ) :					      bool isNumber ( string s ) {				    bool isNumber ( string s ) {				  success : None
    for i in range ( len ( s ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if s [ i ].isdigit ( ) != True :		      	i < s . length ( ) ;					      i < s . length ( ) ;					  
	    return False				      	i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ;     i ++ ) {							  
    return True						      	return true ;						    	if ( isdigit ( s [ i ] ) != true ) return false ;	  
							      }								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		      POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		    POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1		  POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS_1
--							      --							    --								  --
def printArray ( a , n ) :				      void printArray ( int * a , int n ) {			    void printArray ( int * a , int n ) {			  script_not_found : None
    for i in a :					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	print ( i , end = " " )				      	i < n ;							      i < n ;							  
    print ( )						      	i ++ ) cout << a [ i ] << " " ;				      i ++ ) cout << a [ i ] << " " ;				  
							      	cout << endl ;						      cout << endl ;						  
							      	return ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			      PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			    PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON			  PROGRAM_TO_FIND_THE_AREA_OF_PENTAGON
--							      --							    --								  --
def findArea ( a ) :					      float findArea ( float a ) {				    double findArea ( double a ) {				  success : None
    area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a  	float area ;						      double area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a 
    return area						      	area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a )    return area ;						  
							      	return area ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_PALINDROME_SUBSTRING_SET_1			      LONGEST_PALINDROME_SUBSTRING_SET_1			    LONGEST_PALINDROME_SUBSTRING_SET_1				  LONGEST_PALINDROME_SUBSTRING_SET_1
--							      --							    --								  --
def printSubStr ( st , low , high ) :			      void printSubStr ( string str , int low , int high ) {	    string printSubStr ( string st , int low , int high ) {	  script_not_found : None
    sys.stdout.write ( st [ low : high + 1 ] )		      	for ( int i = low ;					      cout << st . substr ( low , high + 1 ) ;			  
    sys.stdout.flush ( )				      	i <= high ;						      cout << flush ;						  
    return ''						      	++ i ) cout << str [ i ] ;				      return st ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING      COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING	    COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING	  COMPUTE_THE_INTEGER_ABSOLUTE_VALUE_ABS_WITHOUT_BRANCHING
--							      --							    --								  --
def getAbs ( n ) :					      unsigned int getAbs ( int n ) {				    int getAbs ( int n ) {					  script_not_found : None
    mask = n >> ( SIZE_INT * CHARBIT - 1 )		      	int const mask = n >> ( sizeof ( int ) * CHARBIT - 1 ) ;      int mask = n >> ( SIZE_INT * CHARBIT - 1 ) ;		  
    return ( ( n + mask ) ^ mask )			      	return ( ( n + mask ) ^ mask ) ;			      return ( ( n + mask ) ^ mask ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	      COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	    COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1	  COUNT_STRINGS_CAN_FORMED_USING_B_C_GIVEN_CONSTRAINTS_1
--							      --							    --								  --
def countStr ( n ) :					      int countStr ( int n ) {					    int countStr ( int n ) {					  success : None
    return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) ) 	return 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ;	      return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) / 2 ) ) ;  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		      HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		    HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER		  HOW_TO_TURN_OFF_A_PARTICULAR_BIT_IN_A_NUMBER
--							      --							    --								  --
def turnOffK ( n , k ) :				      int turnOffK ( int n , int k ) {				    int turnOffK ( int n , int k ) {				  success : None
    if ( k <= 0 ) :					      	if ( k <= 0 ) return n ;				      if ( ( k <= 0 ) ) return n ;				  
	return n					      	return ( n & ~ ( 1 << ( k - 1 ) ) ) ;			      return ( n & ~ ( 1 << ( k - 1 ) ) ) ;			  
    return ( n & ~ ( 1 << ( k - 1 ) ) )			      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES		      MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES		    MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES			  MASTER_THEOREM_SUBTRACT_CONQUER_RECURRENCES
--							      --							    --								  --
def fib ( n ) :						      int fib ( int n ) {					    int fib ( int n ) {						  script_not_found : None
    if ( n <= 1 ) :					      	if ( n <= 1 ) return n ;				      if ( ( n <= 1 ) ) return n ;				  
	return n					      	return fib ( n - 1 ) + fib ( n - 2 ) ;			      return fib ( n - 1 ) + fib ( n - 2 ) ;			  
    return fib ( n - 1 ) + fib ( n - 2 )		      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		      FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		    FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2		  FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2
--							      --							    --								  --
def getOddOccurrence ( arr ) :				      int getOddOccurrence ( int ar [ ] , int ar_size ) {	    int getOddOccurrence ( int * arr ) {			  error : FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TI
    res = 0						      	int res = 0 ;						      int res = 0 ;						  MES_2.cpp: In function ‘int f_filled(int*)’: FIND_
    for element in arr :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2.cpp:28:
	res = res ^ element				      	i < ar_size ;						      i < arr -> length ;					  14: error: request for member ‘length’ in ‘* arr’,
    return res						      	i ++ ) res = res ^ ar [ i ] ;				      i ++ ) res = res ^ arr -> element [ i ] ;			   which is of non-class type ‘int’    i < arr -> le
							      	return res ;						      return res ;						  ngth ;	       ^~~~~~ FIND_THE_NUMBER_OCCURR
							      }								    }								  ING_ODD_NUMBER_OF_TIMES_2.cpp:29:29: error: reques
							      								    								  t for member ‘element’ in ‘* arr’, which is of non
							      								    								  -class type ‘int’    i ++ ) res = res ^ arr -> ele
							      								    								  ment [ i ] ;				    ^~~~~~~
							      								    								  FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2.cp
							      								    								  p: In function ‘int main()’: FIND_THE_NUMBER_OCCUR
							      								    								  RING_ODD_NUMBER_OF_TIMES_2.cpp:40:49: error: too m
							      								    								  any arguments to function ‘int f_filled(int*)’
							      								    								  	if(f_filled(&param0[i].front(),param1[i]) ==
							      								    								   f_gold(&param0[i].front(),param1[i]))
							      								    								  					^ FIND_THE_N
							      								    								  UMBER_OCCURRING_ODD_NUMBER_OF_TIMES_2.cpp:25:5: no
							      								    								  te: declared here  int f_filled ( int * arr ) {
							      								    								     ^~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		      FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		    FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1		  FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS_1
--							      --							    --								  --
def CountSquares ( a , b ) :				      int countSquares ( int a , int b ) {			    double CountSquares ( double a , double b ) {		  script_not_found : None
    return ( math.floor ( math.sqrt ( b ) ) - math.ceil ( mat 	return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ;   return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ; 
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_DIVISORS_1_N_1					      SUM_DIVISORS_1_N_1					    SUM_DIVISORS_1_N_1						  SUM_DIVISORS_1_N_1
--							      --							    --								  --
def divisorSum ( n ) :					      int divisorSum ( int n ) {				    int divisorSum ( int n ) {					  success : None
    sum = 0						      	int sum = 0 ;						      double sum = 0 ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	sum += int ( n / i ) * i			      	i <= n ;						      i <= n ;							  
    return int ( sum )					      	++ i ) sum += ( n / i ) * i ;				      i ++ ) sum += ( int ) ( n / i ) * i ;			  
							      	return sum ;						      return ( int ) sum ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_TRIPLET_SUM_ARRAY_1				      MAXIMUM_TRIPLET_SUM_ARRAY_1				    MAXIMUM_TRIPLET_SUM_ARRAY_1					  MAXIMUM_TRIPLET_SUM_ARRAY_1
--							      --							    --								  --
def maxTripletSum ( arr , n ) :				      int maxTripletSum ( int arr [ ] , int n ) {		    int maxTripletSum ( int * arr , int n ) {			  success : None
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] )  	return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ;	      return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) ;  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_EVEN_LENGTH_PALINDROME				      NTH_EVEN_LENGTH_PALINDROME				    NTH_EVEN_LENGTH_PALINDROME					  NTH_EVEN_LENGTH_PALINDROME
--							      --							    --								  --
def evenlength ( n ) :					      string evenlength ( string n ) {				    int evenLength ( string n ) {				  error : NTH_EVEN_LENGTH_PALINDROME.cpp: In functio
    res = n						      	string res = n ;					      int res = n . length ( ) ;				  n ‘int main()’: NTH_EVEN_LENGTH_PALINDROME.cpp:39:
    for j in range ( len ( n ) - 1 , - 1 , - 1 ) :	      	for ( int j = n . length ( ) - 1 ;			      for ( int j = n . length ( ) - 1 ;			  32: error: no match for ‘operator==’ (operand type
	res += n [ j ]					      	j >= 0 ;						      j >= 0 ;							  s are ‘int’ and ‘std::__cxx11::string’ {aka ‘std::
    return res						      	-- j ) res += n [ j ] ;					      -- j ) res += n [ j ] ;					  __cxx11::basic_string<char>’})	  if(f_fille
							      	return res ;						      return res ;						  d(param0[i]) == f_gold(param0[i]))		 ~~~
							      }								    }								  ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~ In file incl
							      								    								  uded from /usr/include/c++/8/regex:62,
							      								    								  	from /usr/include/c++/8/x86_64-redhat-linux/
							      								    								  bits/stdc++.h:110,		      from NTH_EVEN_
							      								    								  LENGTH_PALINDROME.cpp:14: /usr/include/c++/8/bits/
							      								    								  regex.h:980:5: note: candidate: ‘template<class _B
							      								    								  iIter> bool std::__cxx11::operator==(const std::__
							      								    								  cxx11::sub_match<_BiIter>&, const std::__cxx11::su
							      								    								  b_match<_BiIter>&)’	   operator==(const sub_matc
							      								    								  h<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs
							      								    								  )	 ^~~~~~~~ /usr/include/c++/8/bits/regex.h:98
							      								    								  0:5: note:   template argument deduction/substitut
							      								    								  ion failed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51:
							      								    								  note:	  mismatched types ‘const std::__cxx11::sub_
							      								    								  match<_BiIter>’ and ‘int’	     if(f_filled(par
							      								    								  am0[i]) == f_gold(param0[i]))
							      								    								  				 ^ In file included
							      								    								  from /usr/include/c++/8/regex:62,
							      								    								   from /usr/include/c++/8/x86_64-redhat-linux/bits/
							      								    								  stdc++.h:110,			 from NTH_EVEN_LENGT
							      								    								  H_PALINDROME.cpp:14: /usr/include/c++/8/bits/regex
							      								    								  .h:1053:5: note: candidate: ‘template<class _Bi_it
							      								    								  er, class _Ch_traits, class _Ch_alloc> bool std::_
							      								    								  _cxx11::operator==(std::__cxx11::__sub_match_strin
							      								    								  g<_Bi_iter, _Ch_traits, _Ch_alloc>&, const std::__
							      								    								  cxx11::sub_match<_BiIter>&)’	    operator==(const
							      								    								   __sub_match_string<_Bi_iter, _Ch_traits, _Ch_allo
							      								    								  c>& __lhs,	  ^~~~~~~~ /usr/include/c++/8/bits/r
							      								    								  egex.h:1053:5: note:	 template argument deduction
							      								    								  /substitution failed: NTH_EVEN_LENGTH_PALINDROME.c
							      								    								  pp:39:51: note:   mismatched types ‘std::__cxx11::
							      								    								  __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc
							      								    								  >’ and ‘int’		if(f_filled(param0[i]) == f_
							      								    								  gold(param0[i]))
							      								    								  		    ^ In file included from /usr/inc
							      								    								  lude/c++/8/regex:62,			from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  		    from NTH_EVEN_LENGTH_PALINDROME.
							      								    								  cpp:14: /usr/include/c++/8/bits/regex.h:1133:5: no
							      								    								  te: candidate: ‘template<class _Bi_iter, class _Ch
							      								    								  _traits, class _Ch_alloc> bool std::__cxx11::opera
							      								    								  tor==(const std::__cxx11::sub_match<_BiIter>&, std
							      								    								  ::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits
							      								    								  , _Ch_alloc>&)’      operator==(const sub_match<_B
							      								    								  i_iter>& __lhs,      ^~~~~~~~ /usr/include/c++/8/b
							      								    								  its/regex.h:1133:5: note:   template argument dedu
							      								    								  ction/substitution failed: NTH_EVEN_LENGTH_PALINDR
							      								    								  OME.cpp:39:51: note:	 mismatched types ‘const std
							      								    								  ::__cxx11::sub_match<_BiIter>’ and ‘int’
							      								    								  if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						^ In
							      								    								   file included from /usr/include/c++/8/regex:62,
							      								    								  		  from /usr/include/c++/8/x86_64-red
							      								    								  hat-linux/bits/stdc++.h:110,			from
							      								    								   NTH_EVEN_LENGTH_PALINDROME.cpp:14: /usr/include/c
							      								    								  ++/8/bits/regex.h:1213:5: note: candidate: ‘templa
							      								    								  te<class _Bi_iter> bool std::__cxx11::operator==(c
							      								    								  onst typename std::iterator_traits<_Iter>::value_t
							      								    								  ype*, const std::__cxx11::sub_match<_BiIter>&)’
							      								    								     operator==(typename iterator_traits<_Bi_iter>::
							      								    								  value_type const* __lhs,	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/regex.h:1213:5: note:   template argu
							      								    								  ment deduction/substitution failed: NTH_EVEN_LENGT
							      								    								  H_PALINDROME.cpp:39:51: note:	  ‘std::__cxx11::str
							      								    								  ing’ {aka ‘std::__cxx11::basic_string<char>’} is n
							      								    								  ot derived from ‘const std::__cxx11::sub_match<_Bi
							      								    								  Iter>’	  if(f_filled(param0[i]) == f_gold(p
							      								    								  aram0[i]))
							      								    								  	      ^ In file included from /usr/include/c
							      								    								  ++/8/regex:62,		  from /usr/include/
							      								    								  c++/8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  	      from NTH_EVEN_LENGTH_PALINDROME.cpp:14
							      								    								  : /usr/include/c++/8/bits/regex.h:1287:5: note: ca
							      								    								  ndidate: ‘template<class _Bi_iter> bool std::__cxx
							      								    								  11::operator==(const std::__cxx11::sub_match<_BiIt
							      								    								  er>&, const typename std::iterator_traits<_Iter>::
							      								    								  value_type*)’	     operator==(const sub_match<_Bi_
							      								    								  iter>& __lhs,	     ^~~~~~~~ /usr/include/c++/8/bit
							      								    								  s/regex.h:1287:5: note:   template argument deduct
							      								    								  ion/substitution failed: NTH_EVEN_LENGTH_PALINDROM
							      								    								  E.cpp:39:51: note:   mismatched types ‘const std::
							      								    								  __cxx11::sub_match<_BiIter>’ and ‘int’	  if
							      								    								  (f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/regex:62,
							      								    								  		from /usr/include/c++/8/x86_64-redha
							      								    								  t-linux/bits/stdc++.h:110,		      from N
							      								    								  TH_EVEN_LENGTH_PALINDROME.cpp:14: /usr/include/c++
							      								    								  /8/bits/regex.h:1361:5: note: candidate: ‘template
							      								    								  <class _Bi_iter> bool std::__cxx11::operator==(con
							      								    								  st typename std::iterator_traits<_Iter>::value_typ
							      								    								  e&, const std::__cxx11::sub_match<_BiIter>&)’
							      								    								   operator==(typename iterator_traits<_Bi_iter>::va
							      								    								  lue_type const& __lhs,      ^~~~~~~~ /usr/include/
							      								    								  c++/8/bits/regex.h:1361:5: note:   template argume
							      								    								  nt deduction/substitution failed: NTH_EVEN_LENGTH_
							      								    								  PALINDROME.cpp:39:51: note:	‘std::__cxx11::strin
							      								    								  g’ {aka ‘std::__cxx11::basic_string<char>’} is not
							      								    								   derived from ‘const std::__cxx11::sub_match<_BiIt
							      								    								  er>’		if(f_filled(param0[i]) == f_gold(par
							      								    								  am0[i]))
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/regex:62,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  	    from NTH_EVEN_LENGTH_PALINDROME.cpp:14:
							      								    								  /usr/include/c++/8/bits/regex.h:1441:5: note: cand
							      								    								  idate: ‘template<class _Bi_iter> bool std::__cxx11
							      								    								  ::operator==(const std::__cxx11::sub_match<_BiIter
							      								    								  >&, const typename std::iterator_traits<_Iter>::va
							      								    								  lue_type&)’	   operator==(const sub_match<_Bi_it
							      								    								  er>& __lhs,	   ^~~~~~~~ /usr/include/c++/8/bits/
							      								    								  regex.h:1441:5: note:	  template argument deductio
							      								    								  n/substitution failed: NTH_EVEN_LENGTH_PALINDROME.
							      								    								  cpp:39:51: note:   mismatched types ‘const std::__
							      								    								  cxx11::sub_match<_BiIter>’ and ‘int’		if(f
							      								    								  _filled(param0[i]) == f_gold(param0[i]))
							      								    								  					    ^ In fil
							      								    								  e included from /usr/include/c++/8/regex:62,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:110,		    from NTH
							      								    								  _EVEN_LENGTH_PALINDROME.cpp:14: /usr/include/c++/8
							      								    								  /bits/regex.h:1957:5: note: candidate: ‘template<c
							      								    								  lass _Bi_iter, class _Alloc> bool std::__cxx11::op
							      								    								  erator==(const std::__cxx11::match_results<_BiIter
							      								    								  , _Alloc>&, const std::__cxx11::match_results<_BiI
							      								    								  ter, _Alloc>&)’      operator==(const match_result
							      								    								  s<_Bi_iter, _Alloc>& __m1,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/regex.h:1957:5: note:	 template ar
							      								    								  gument deduction/substitution failed: NTH_EVEN_LEN
							      								    								  GTH_PALINDROME.cpp:39:51: note:   mismatched types
							      								    								   ‘const std::__cxx11::match_results<_BiIter, _Allo
							      								    								  c>’ and ‘int’		 if(f_filled(param0[i]) == f
							      								    								  _gold(param0[i]))
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/iosfwd:40,		  from /usr/
							      								    								  include/c++/8/ios:38,			 from /usr/i
							      								    								  nclude/c++/8/ostream:38,		    from /us
							      								    								  r/include/c++/8/iostream:39,			from
							      								    								   NTH_EVEN_LENGTH_PALINDROME.cpp:8: /usr/include/c+
							      								    								  +/8/bits/postypes.h:216:5: note: candidate: ‘templ
							      								    								  ate<class _StateT> bool std::operator==(const std:
							      								    								  :fpos<_StateT>&, const std::fpos<_StateT>&)’
							      								    								  operator==(const fpos<_StateT>& __lhs, const fpos<
							      								    								  _StateT>& __rhs)	^~~~~~~~ /usr/include/c++/8/
							      								    								  bits/postypes.h:216:5: note:	 template argument d
							      								    								  eduction/substitution failed: NTH_EVEN_LENGTH_PALI
							      								    								  NDROME.cpp:39:51: note:   mismatched types ‘const
							      								    								  std::fpos<_StateT>’ and ‘int’		 if(f_filled
							      								    								  (param0[i]) == f_gold(param0[i]))
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/bits/stl_algobase.h:64
							      								    								  ,		     from /usr/include/c++/8/bits/ch
							      								    								  ar_traits.h:39,		   from /usr/include
							      								    								  /c++/8/ios:40,		  from /usr/include/
							      								    								  c++/8/ostream:38,		     from /usr/inclu
							      								    								  de/c++/8/iostream:39,			 from NTH_EV
							      								    								  EN_LENGTH_PALINDROME.cpp:8: /usr/include/c++/8/bit
							      								    								  s/stl_pair.h:448:5: note: candidate: ‘template<cla
							      								    								  ss _T1, class _T2> constexpr bool std::operator==(
							      								    								  const std::pair<_T1, _T2>&, const std::pair<_T1, _
							      								    								  T2>&)’      operator==(const pair<_T1, _T2>& __x,
							      								    								  const pair<_T1, _T2>& __y)	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/stl_pair.h:448:5: note:   template
							      								    								  argument deduction/substitution failed: NTH_EVEN_L
							      								    								  ENGTH_PALINDROME.cpp:39:51: note:   mismatched typ
							      								    								  es ‘const std::pair<_T1, _T2>’ and ‘int’
							      								    								  if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						^ In
							      								    								   file included from /usr/include/c++/8/bits/stl_al
							      								    								  gobase.h:67,			from /usr/include/c+
							      								    								  +/8/bits/char_traits.h:39,		      from /
							      								    								  usr/include/c++/8/ios:40,		     from /u
							      								    								  sr/include/c++/8/ostream:38,			from
							      								    								   /usr/include/c++/8/iostream:39,
							      								    								  from NTH_EVEN_LENGTH_PALINDROME.cpp:8: /usr/includ
							      								    								  e/c++/8/bits/stl_iterator.h:302:5: note: candidate
							      								    								  : ‘template<class _Iterator> bool std::operator==(
							      								    								  const std::reverse_iterator<_Iterator>&, const std
							      								    								  ::reverse_iterator<_Iterator>&)’	operator==(c
							      								    								  onst reverse_iterator<_Iterator>& __x,      ^~~~~~
							      								    								  ~~ /usr/include/c++/8/bits/stl_iterator.h:302:5: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:
							      								    								    mismatched types ‘const std::reverse_iterator<_I
							      								    								  terator>’ and ‘int’	       if(f_filled(param0[i]
							      								    								  ) == f_gold(param0[i]))
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/bits/stl_algobase.h:67,
							      								    								  	   from /usr/include/c++/8/bits/char_traits.
							      								    								  h:39,			 from /usr/include/c++/8/ios
							      								    								  :40,			from /usr/include/c++/8/ostr
							      								    								  eam:38,		   from /usr/include/c++/8/i
							      								    								  ostream:39,		       from NTH_EVEN_LENGTH_
							      								    								  PALINDROME.cpp:8: /usr/include/c++/8/bits/stl_iter
							      								    								  ator.h:340:5: note: candidate: ‘template<class _It
							      								    								  eratorL, class _IteratorR> bool std::operator==(co
							      								    								  nst std::reverse_iterator<_Iterator>&, const std::
							      								    								  reverse_iterator<_IteratorR>&)’      operator==(co
							      								    								  nst reverse_iterator<_IteratorL>& __x,      ^~~~~~
							      								    								  ~~ /usr/include/c++/8/bits/stl_iterator.h:340:5: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:
							      								    								    mismatched types ‘const std::reverse_iterator<_I
							      								    								  terator>’ and ‘int’	       if(f_filled(param0[i]
							      								    								  ) == f_gold(param0[i]))
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/bits/stl_algobase.h:67,
							      								    								  	   from /usr/include/c++/8/bits/char_traits.
							      								    								  h:39,			 from /usr/include/c++/8/ios
							      								    								  :40,			from /usr/include/c++/8/ostr
							      								    								  eam:38,		   from /usr/include/c++/8/i
							      								    								  ostream:39,		       from NTH_EVEN_LENGTH_
							      								    								  PALINDROME.cpp:8: /usr/include/c++/8/bits/stl_iter
							      								    								  ator.h:1115:5: note: candidate: ‘template<class _I
							      								    								  teratorL, class _IteratorR> bool std::operator==(c
							      								    								  onst std::move_iterator<_IteratorL>&, const std::m
							      								    								  ove_iterator<_IteratorR>&)’	   operator==(const
							      								    								  move_iterator<_IteratorL>& __x,      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/stl_iterator.h:1115:5: note:
							      								    								   template argument deduction/substitution failed:
							      								    								  NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:	mism
							      								    								  atched types ‘const std::move_iterator<_IteratorL>
							      								    								  ’ and ‘int’	       if(f_filled(param0[i]) == f_g
							      								    								  old(param0[i]))
							      								    								  		   ^ In file included from /usr/incl
							      								    								  ude/c++/8/bits/stl_algobase.h:67,
							      								    								   from /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  		 from /usr/include/c++/8/ios:40,
							      								    								  		from /usr/include/c++/8/ostream:38,
							      								    								  		   from /usr/include/c++/8/iostream:
							      								    								  39,		       from NTH_EVEN_LENGTH_PALINDRO
							      								    								  ME.cpp:8: /usr/include/c++/8/bits/stl_iterator.h:1
							      								    								  121:5: note: candidate: ‘template<class _Iterator>
							      								    								   bool std::operator==(const std::move_iterator<_It
							      								    								  eratorL>&, const std::move_iterator<_IteratorL>&)’
							      								    								  	operator==(const move_iterator<_Iterator>& _
							      								    								  _x,	   ^~~~~~~~ /usr/include/c++/8/bits/stl_iter
							      								    								  ator.h:1121:5: note:	 template argument deduction
							      								    								  /substitution failed: NTH_EVEN_LENGTH_PALINDROME.c
							      								    								  pp:39:51: note:   mismatched types ‘const std::mov
							      								    								  e_iterator<_IteratorL>’ and ‘int’	     if(f_fi
							      								    								  lled(param0[i]) == f_gold(param0[i]))
							      								    								  					 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/string:41,
							      								    								  	    from /usr/include/c++/8/bits/locale_clas
							      								    								  ses.h:40,		     from /usr/include/c++/8
							      								    								  /bits/ios_base.h:41,			from /usr/in
							      								    								  clude/c++/8/ios:42,		       from /usr/inc
							      								    								  lude/c++/8/ostream:38,		  from /usr/
							      								    								  include/c++/8/iostream:39,		      from N
							      								    								  TH_EVEN_LENGTH_PALINDROME.cpp:8: /usr/include/c++/
							      								    								  8/bits/allocator.h:146:5: note: candidate: ‘templa
							      								    								  te<class _T1, class _T2> bool std::operator==(cons
							      								    								  t std::allocator<_CharT>&, const std::allocator<_T
							      								    								  2>&)’	     operator==(const allocator<_T1>&, const
							      								    								   allocator<_T2>&)	 ^~~~~~~~ /usr/include/c++/8
							      								    								  /bits/allocator.h:146:5: note:   template argument
							      								    								   deduction/substitution failed: NTH_EVEN_LENGTH_PA
							      								    								  LINDROME.cpp:39:51: note:   mismatched types ‘cons
							      								    								  t std::allocator<_CharT>’ and ‘int’	       if(f_
							      								    								  filled(param0[i]) == f_gold(param0[i]))
							      								    								  					   ^ In file
							      								    								   included from /usr/include/c++/8/string:41,
							      								    								  	      from /usr/include/c++/8/bits/locale_cl
							      								    								  asses.h:40,		       from /usr/include/c++
							      								    								  /8/bits/ios_base.h:41,		  from /usr/
							      								    								  include/c++/8/ios:42,			 from /usr/i
							      								    								  nclude/c++/8/ostream:38,		    from /us
							      								    								  r/include/c++/8/iostream:39,			from
							      								    								   NTH_EVEN_LENGTH_PALINDROME.cpp:8: /usr/include/c+
							      								    								  +/8/bits/allocator.h:152:5: note: candidate: ‘temp
							      								    								  late<class _Tp> bool std::operator==(const std::al
							      								    								  locator<_CharT>&, const std::allocator<_CharT>&)’
							      								    								       operator==(const allocator<_Tp>&, const alloc
							      								    								  ator<_Tp>&)	   ^~~~~~~~ /usr/include/c++/8/bits/
							      								    								  allocator.h:152:5: note:   template argument deduc
							      								    								  tion/substitution failed: NTH_EVEN_LENGTH_PALINDRO
							      								    								  ME.cpp:39:51: note:	mismatched types ‘const std:
							      								    								  :allocator<_CharT>’ and ‘int’		 if(f_filled
							      								    								  (param0[i]) == f_gold(param0[i]))
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/string:52,
							      								    								  	from /usr/include/c++/8/bits/locale_classes.
							      								    								  h:40,			 from /usr/include/c++/8/bit
							      								    								  s/ios_base.h:41,		    from /usr/includ
							      								    								  e/c++/8/ios:42,		   from /usr/include
							      								    								  /c++/8/ostream:38,		      from /usr/incl
							      								    								  ude/c++/8/iostream:39,		  from NTH_E
							      								    								  VEN_LENGTH_PALINDROME.cpp:8: /usr/include/c++/8/bi
							      								    								  ts/basic_string.h:6048:5: note: candidate: ‘templa
							      								    								  te<class _CharT, class _Traits, class _Alloc> bool
							      								    								   std::operator==(const std::__cxx11::basic_string<
							      								    								  _CharT, _Traits, _Alloc>&, const std::__cxx11::bas
							      								    								  ic_string<_CharT, _Traits, _Alloc>&)’	     operato
							      								    								  r==(const basic_string<_CharT, _Traits, _Alloc>& _
							      								    								  _lhs,	     ^~~~~~~~ /usr/include/c++/8/bits/basic_
							      								    								  string.h:6048:5: note:   template argument deducti
							      								    								  on/substitution failed: NTH_EVEN_LENGTH_PALINDROME
							      								    								  .cpp:39:51: note:   mismatched types ‘const std::_
							      								    								  _cxx11::basic_string<_CharT, _Traits, _Alloc>’ and
							      								    								   ‘int’	  if(f_filled(param0[i]) == f_gold(p
							      								    								  aram0[i]))
							      								    								  	      ^ In file included from /usr/include/c
							      								    								  ++/8/string:52,		   from /usr/include
							      								    								  /c++/8/bits/locale_classes.h:40,
							      								    								  from /usr/include/c++/8/bits/ios_base.h:41,
							      								    								  	     from /usr/include/c++/8/ios:42,
							      								    								  	    from /usr/include/c++/8/ostream:38,
							      								    								  	       from /usr/include/c++/8/iostream:39,
							      								    								  		   from NTH_EVEN_LENGTH_PALINDROME.c
							      								    								  pp:8: /usr/include/c++/8/bits/basic_string.h:6056:
							      								    								  5: note: candidate: ‘template<class _CharT> typena
							      								    								  me __gnu_cxx::__enable_if<std::__is_char<_Tp>::__v
							      								    								  alue, bool>::__type std::operator==(const std::__c
							      								    								  xx11::basic_string<_CharT>&, const std::__cxx11::b
							      								    								  asic_string<_CharT>&)’      operator==(const basic
							      								    								  _string<_CharT>& __lhs,      ^~~~~~~~ /usr/include
							      								    								  /c++/8/bits/basic_string.h:6056:5: note:   templat
							      								    								  e argument deduction/substitution failed: NTH_EVEN
							      								    								  _LENGTH_PALINDROME.cpp:39:51: note:	mismatched t
							      								    								  ypes ‘const std::__cxx11::basic_string<_CharT>’ an
							      								    								  d ‘int’	   if(f_filled(param0[i]) == f_gold(
							      								    								  param0[i]))
							      								    								  	       ^ In file included from /usr/include/
							      								    								  c++/8/string:52,		    from /usr/includ
							      								    								  e/c++/8/bits/locale_classes.h:40,
							      								    								   from /usr/include/c++/8/bits/ios_base.h:41,
							      								    								  	      from /usr/include/c++/8/ios:42,
							      								    								  	     from /usr/include/c++/8/ostream:38,
							      								    								  		from /usr/include/c++/8/iostream:39,
							      								    								  		    from NTH_EVEN_LENGTH_PALINDROME.
							      								    								  cpp:8: /usr/include/c++/8/bits/basic_string.h:6070
							      								    								  :5: note: candidate: ‘template<class _CharT, class
							      								    								   _Traits, class _Alloc> bool std::operator==(const
							      								    								   _CharT*, const std::__cxx11::basic_string<_CharT,
							      								    								   _Traits, _Alloc>&)’	    operator==(const _CharT*
							      								    								   __lhs,      ^~~~~~~~ /usr/include/c++/8/bits/basi
							      								    								  c_string.h:6070:5: note:   template argument deduc
							      								    								  tion/substitution failed: NTH_EVEN_LENGTH_PALINDRO
							      								    								  ME.cpp:39:51: note:	mismatched types ‘const _Cha
							      								    								  rT*’ and ‘int’	  if(f_filled(param0[i]) ==
							      								    								  f_gold(param0[i]))
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/string:52,		   from /usr
							      								    								  /include/c++/8/bits/locale_classes.h:40,
							      								    								  	  from /usr/include/c++/8/bits/ios_base.h:41
							      								    								  ,		     from /usr/include/c++/8/ios:42,
							      								    								  		    from /usr/include/c++/8/ostream:
							      								    								  38,		       from /usr/include/c++/8/iostr
							      								    								  eam:39,		   from NTH_EVEN_LENGTH_PALI
							      								    								  NDROME.cpp:8: /usr/include/c++/8/bits/basic_string
							      								    								  .h:6082:5: note: candidate: ‘template<class _CharT
							      								    								  , class _Traits, class _Alloc> bool std::operator=
							      								    								  =(const std::__cxx11::basic_string<_CharT, _Traits
							      								    								  , _Alloc>&, const _CharT*)’	   operator==(const
							      								    								  basic_string<_CharT, _Traits, _Alloc>& __lhs,
							      								    								   ^~~~~~~~ /usr/include/c++/8/bits/basic_string.h:6
							      								    								  082:5: note:	 template argument deduction/substit
							      								    								  ution failed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51
							      								    								  : note:   mismatched types ‘const std::__cxx11::ba
							      								    								  sic_string<_CharT, _Traits, _Alloc>’ and ‘int’
							      								    								  	if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  
							      								    								    ^ In file included from /usr/include/c++/8/bits/
							      								    								  ios_base.h:46,		  from /usr/include/
							      								    								  c++/8/ios:42,			 from /usr/include/c
							      								    								  ++/8/ostream:38,		    from /usr/includ
							      								    								  e/c++/8/iostream:39,			from NTH_EVE
							      								    								  N_LENGTH_PALINDROME.cpp:8: /usr/include/c++/8/syst
							      								    								  em_error:292:3: note: candidate: ‘bool std::operat
							      								    								  or==(const std::error_code&, const std::error_code
							      								    								  &)’	 operator==(const error_code& __lhs, const e
							      								    								  rror_code& __rhs) noexcept	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/system_error:292:3: note:   no known conve
							      								    								  rsion for argument 1 from ‘int’ to ‘const std::err
							      								    								  or_code&’ /usr/include/c++/8/system_error:297:3: n
							      								    								  ote: candidate: ‘bool std::operator==(const std::e
							      								    								  rror_code&, const std::error_condition&)’    opera
							      								    								  tor==(const error_code& __lhs, const error_conditi
							      								    								  on& __rhs) noexcept	 ^~~~~~~~ /usr/include/c++/8
							      								    								  /system_error:297:3: note:   no known conversion f
							      								    								  or argument 1 from ‘int’ to ‘const std::error_code
							      								    								  &’ /usr/include/c++/8/system_error:304:3: note: ca
							      								    								  ndidate: ‘bool std::operator==(const std::error_co
							      								    								  ndition&, const std::error_code&)’	operator==(c
							      								    								  onst error_condition& __lhs, const error_code& __r
							      								    								  hs) noexcept	  ^~~~~~~~ /usr/include/c++/8/system
							      								    								  _error:304:3: note:	no known conversion for argu
							      								    								  ment 1 from ‘int’ to ‘const std::error_condition&’
							      								    								   /usr/include/c++/8/system_error:311:3: note: cand
							      								    								  idate: ‘bool std::operator==(const std::error_cond
							      								    								  ition&, const std::error_condition&)’	   operator=
							      								    								  =(const error_condition& __lhs,    ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/system_error:311:3: note:   no known
							      								    								  conversion for argument 1 from ‘int’ to ‘const std
							      								    								  ::error_condition&’ In file included from /usr/inc
							      								    								  lude/c++/8/bits/locale_facets.h:48,
							      								    								     from /usr/include/c++/8/bits/basic_ios.h:37,
							      								    								  		 from /usr/include/c++/8/ios:44,
							      								    								  		from /usr/include/c++/8/ostream:38,
							      								    								  		   from /usr/include/c++/8/iostream:
							      								    								  39,		       from NTH_EVEN_LENGTH_PALINDRO
							      								    								  ME.cpp:8: /usr/include/c++/8/bits/streambuf_iterat
							      								    								  or.h:203:5: note: candidate: ‘template<class _Char
							      								    								  T, class _Traits> bool std::operator==(const std::
							      								    								  istreambuf_iterator<_CharT, _Traits>&, const std::
							      								    								  istreambuf_iterator<_CharT, _Traits>&)’      opera
							      								    								  tor==(const istreambuf_iterator<_CharT, _Traits>&
							      								    								  __a,	    ^~~~~~~~ /usr/include/c++/8/bits/streamb
							      								    								  uf_iterator.h:203:5: note:   template argument ded
							      								    								  uction/substitution failed: NTH_EVEN_LENGTH_PALIND
							      								    								  ROME.cpp:39:51: note:	  mismatched types ‘const st
							      								    								  d::istreambuf_iterator<_CharT, _Traits>’ and ‘int’
							      								    								  	    if(f_filled(param0[i]) == f_gold(param0[
							      								    								  i]))
							      								    								  	^ In file included from /usr/include/c++/8/v
							      								    								  ector:64,		     from NTH_EVEN_LENGTH_PA
							      								    								  LINDROME.cpp:11: /usr/include/c++/8/bits/stl_vecto
							      								    								  r.h:1753:5: note: candidate: ‘template<class _Tp,
							      								    								  class _Alloc> bool std::operator==(const std::vect
							      								    								  or<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
							      								    								  ’	 operator==(const vector<_Tp, _Alloc>& __x,
							      								    								  const vector<_Tp, _Alloc>& __y)      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/stl_vector.h:1753:5: note:   t
							      								    								  emplate argument deduction/substitution failed: NT
							      								    								  H_EVEN_LENGTH_PALINDROME.cpp:39:51: note:   mismat
							      								    								  ched types ‘const std::vector<_Tp, _Alloc>’ and ‘i
							      								    								  nt’	       if(f_filled(param0[i]) == f_gold(para
							      								    								  m0[i]))
							      								    								  	   ^ In file included from /usr/include/c++/
							      								    								  8/tuple:39,		       from /usr/include/c++
							      								    								  /8/bits/unique_ptr.h:37,		    from /us
							      								    								  r/include/c++/8/bits/locale_conv.h:41,
							      								    								  	from /usr/include/c++/8/locale:43,
							      								    								  	  from /usr/include/c++/8/iomanip:43,
							      								    								  	     from NTH_EVEN_LENGTH_PALINDROME.cpp:13:
							      								    								   /usr/include/c++/8/array:252:5: note: candidate:
							      								    								  ‘template<class _Tp, long unsigned int _Nm> bool s
							      								    								  td::operator==(const std::array<_Tp, _Nm>&, const
							      								    								  std::array<_Tp, _Nm>&)’      operator==(const arra
							      								    								  y<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
							      								    								       ^~~~~~~~ /usr/include/c++/8/array:252:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:   m
							      								    								  ismatched types ‘const std::array<_Tp, _Nm>’ and ‘
							      								    								  int’		if(f_filled(param0[i]) == f_gold(par
							      								    								  am0[i]))
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/bits/unique_ptr.h:37,		    from /us
							      								    								  r/include/c++/8/bits/locale_conv.h:41,
							      								    								  	from /usr/include/c++/8/locale:43,
							      								    								  	  from /usr/include/c++/8/iomanip:43,
							      								    								  	     from NTH_EVEN_LENGTH_PALINDROME.cpp:13:
							      								    								   /usr/include/c++/8/tuple:1413:5: note: candidate:
							      								    								   ‘template<class ... _TElements, class ... _UEleme
							      								    								  nts> constexpr bool std::operator==(const std::tup
							      								    								  le<_Tps ...>&, const std::tuple<_Elements ...>&)’
							      								    								       operator==(const tuple<_TElements...>& __t,
							      								    								      ^~~~~~~~ /usr/include/c++/8/tuple:1413:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:   m
							      								    								  ismatched types ‘const std::tuple<_Tps ...>’ and ‘
							      								    								  int’		if(f_filled(param0[i]) == f_gold(par
							      								    								  am0[i]))
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/bits/locale_conv.h:41,		     from /u
							      								    								  sr/include/c++/8/locale:43,		       from
							      								    								  /usr/include/c++/8/iomanip:43,		  fr
							      								    								  om NTH_EVEN_LENGTH_PALINDROME.cpp:13: /usr/include
							      								    								  /c++/8/bits/unique_ptr.h:693:5: note: candidate: ‘
							      								    								  template<class _Tp, class _Dp, class _Up, class _E
							      								    								  p> bool std::operator==(const std::unique_ptr<_Tp,
							      								    								   _Dp>&, const std::unique_ptr<_Up, _Ep>&)’	  op
							      								    								  erator==(const unique_ptr<_Tp, _Dp>& __x,	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/bits/unique_ptr.h:693:5:
							      								    								  note:	  template argument deduction/substitution f
							      								    								  ailed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:
							      								    								     mismatched types ‘const std::unique_ptr<_Tp, _D
							      								    								  p>’ and ‘int’		 if(f_filled(param0[i]) == f
							      								    								  _gold(param0[i]))
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/bits/locale_conv.h:41,
							      								    								    from /usr/include/c++/8/locale:43,
							      								    								      from /usr/include/c++/8/iomanip:43,
							      								    								  	 from NTH_EVEN_LENGTH_PALINDROME.cpp:13: /us
							      								    								  r/include/c++/8/bits/unique_ptr.h:699:5: note: can
							      								    								  didate: ‘template<class _Tp, class _Dp> bool std::
							      								    								  operator==(const std::unique_ptr<_Tp, _Dp>&, std::
							      								    								  nullptr_t)’	   operator==(const unique_ptr<_Tp,
							      								    								  _Dp>& __x, nullptr_t) noexcept      ^~~~~~~~ /usr/
							      								    								  include/c++/8/bits/unique_ptr.h:699:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: NTH_
							      								    								  EVEN_LENGTH_PALINDROME.cpp:39:51: note:   mismatch
							      								    								  ed types ‘const std::unique_ptr<_Tp, _Dp>’ and ‘in
							      								    								  t’	      if(f_filled(param0[i]) == f_gold(param
							      								    								  0[i]))
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /bits/locale_conv.h:41,		   from /usr
							      								    								  /include/c++/8/locale:43,		     from /u
							      								    								  sr/include/c++/8/iomanip:43,			from
							      								    								   NTH_EVEN_LENGTH_PALINDROME.cpp:13: /usr/include/c
							      								    								  ++/8/bits/unique_ptr.h:704:5: note: candidate: ‘te
							      								    								  mplate<class _Tp, class _Dp> bool std::operator==(
							      								    								  std::nullptr_t, const std::unique_ptr<_Tp, _Dp>&)’
							      								    								  	operator==(nullptr_t, const unique_ptr<_Tp,
							      								    								  _Dp>& __x) noexcept	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/unique_ptr.h:704:5: note:   template argum
							      								    								  ent deduction/substitution failed: NTH_EVEN_LENGTH
							      								    								  _PALINDROME.cpp:39:51: note:	 ‘std::__cxx11::stri
							      								    								  ng’ {aka ‘std::__cxx11::basic_string<char>’} is no
							      								    								  t derived from ‘const std::unique_ptr<_Tp, _Dp>’
							      								    								  	  if(f_filled(param0[i]) == f_gold(param0[i]
							      								    								  ))
							      								    								      ^ In file included from /usr/include/c++/8/cco
							      								    								  mplex:39,		     from /usr/include/c++/8
							      								    								  /x86_64-redhat-linux/bits/stdc++.h:52,
							      								    								  	from NTH_EVEN_LENGTH_PALINDROME.cpp:14: /usr
							      								    								  /include/c++/8/complex:458:5: note: candidate: ‘te
							      								    								  mplate<class _Tp> constexpr bool std::operator==(c
							      								    								  onst std::complex<_Tp>&, const std::complex<_Tp>&)
							      								    								  ’	 operator==(const complex<_Tp>& __x, const c
							      								    								  omplex<_Tp>& __y)	 ^~~~~~~~ /usr/include/c++/8
							      								    								  /complex:458:5: note:	  template argument deductio
							      								    								  n/substitution failed: NTH_EVEN_LENGTH_PALINDROME.
							      								    								  cpp:39:51: note:   mismatched types ‘const std::co
							      								    								  mplex<_Tp>’ and ‘int’		 if(f_filled(param0[
							      								    								  i]) == f_gold(param0[i]))
							      								    								  			     ^ In file included from
							      								    								   /usr/include/c++/8/ccomplex:39,
							      								    								  from /usr/include/c++/8/x86_64-redhat-linux/bits/s
							      								    								  tdc++.h:52,		       from NTH_EVEN_LENGTH_
							      								    								  PALINDROME.cpp:14: /usr/include/c++/8/complex:463:
							      								    								  5: note: candidate: ‘template<class _Tp> constexpr
							      								    								   bool std::operator==(const std::complex<_Tp>&, co
							      								    								  nst _Tp&)’	  operator==(const complex<_Tp>& __x
							      								    								  , const _Tp& __y)	 ^~~~~~~~ /usr/include/c++/8
							      								    								  /complex:463:5: note:	  template argument deductio
							      								    								  n/substitution failed: NTH_EVEN_LENGTH_PALINDROME.
							      								    								  cpp:39:51: note:   mismatched types ‘const std::co
							      								    								  mplex<_Tp>’ and ‘int’		 if(f_filled(param0[
							      								    								  i]) == f_gold(param0[i]))
							      								    								  			     ^ In file included from
							      								    								   /usr/include/c++/8/ccomplex:39,
							      								    								  from /usr/include/c++/8/x86_64-redhat-linux/bits/s
							      								    								  tdc++.h:52,		       from NTH_EVEN_LENGTH_
							      								    								  PALINDROME.cpp:14: /usr/include/c++/8/complex:468:
							      								    								  5: note: candidate: ‘template<class _Tp> constexpr
							      								    								   bool std::operator==(const _Tp&, const std::compl
							      								    								  ex<_Tp>&)’	  operator==(const _Tp& __x, const c
							      								    								  omplex<_Tp>& __y)	 ^~~~~~~~ /usr/include/c++/8
							      								    								  /complex:468:5: note:	  template argument deductio
							      								    								  n/substitution failed: NTH_EVEN_LENGTH_PALINDROME.
							      								    								  cpp:39:51: note:   ‘std::__cxx11::string’ {aka ‘st
							      								    								  d::__cxx11::basic_string<char>’} is not derived fr
							      								    								  om ‘const std::complex<_Tp>’		if(f_filled(
							      								    								  param0[i]) == f_gold(param0[i]))
							      								    								  				    ^ In file includ
							      								    								  ed from /usr/include/c++/8/deque:64,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:68,		   from NTH_EVEN_LEN
							      								    								  GTH_PALINDROME.cpp:14: /usr/include/c++/8/bits/stl
							      								    								  _deque.h:268:5: note: candidate: ‘template<class _
							      								    								  Tp, class _Ref, class _Ptr> bool std::operator==(c
							      								    								  onst std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const
							      								    								   std::_Deque_iterator<_Tp, _Ref, _Ptr>&)’	 ope
							      								    								  rator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __
							      								    								  x,	  ^~~~~~~~ /usr/include/c++/8/bits/stl_deque
							      								    								  .h:268:5: note:   template argument deduction/subs
							      								    								  titution failed: NTH_EVEN_LENGTH_PALINDROME.cpp:39
							      								    								  :51: note:   mismatched types ‘const std::_Deque_i
							      								    								  terator<_Tp, _Ref, _Ptr>’ and ‘int’	       if(f_
							      								    								  filled(param0[i]) == f_gold(param0[i]))
							      								    								  					   ^ In file
							      								    								   included from /usr/include/c++/8/deque:64,
							      								    								  	     from /usr/include/c++/8/x86_64-redhat-l
							      								    								  inux/bits/stdc++.h:68,		  from NTH_E
							      								    								  VEN_LENGTH_PALINDROME.cpp:14: /usr/include/c++/8/b
							      								    								  its/stl_deque.h:275:5: note: candidate: ‘template<
							      								    								  class _Tp, class _RefL, class _PtrL, class _RefR,
							      								    								  class _PtrR> bool std::operator==(const std::_Dequ
							      								    								  e_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_it
							      								    								  erator<_Tp, _RefR, _PtrR>&)’	    operator==(const
							      								    								   _Deque_iterator<_Tp, _RefL, _PtrL>& __x,	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/bits/stl_deque.h:275:5: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:
							      								    								    mismatched types ‘const std::_Deque_iterator<_Tp
							      								    								  , _Ref, _Ptr>’ and ‘int’	    if(f_filled(para
							      								    								  m0[i]) == f_gold(param0[i]))
							      								    								  				^ In file included f
							      								    								  rom /usr/include/c++/8/deque:64,
							      								    								  from /usr/include/c++/8/x86_64-redhat-linux/bits/s
							      								    								  tdc++.h:68,		       from NTH_EVEN_LENGTH_
							      								    								  PALINDROME.cpp:14: /usr/include/c++/8/bits/stl_deq
							      								    								  ue.h:2277:5: note: candidate: ‘template<class _Tp,
							      								    								   class _Alloc> bool std::operator==(const std::deq
							      								    								  ue<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)’
							      								    								  	operator==(const deque<_Tp, _Alloc>& __x,
							      								    								     ^~~~~~~~ /usr/include/c++/8/bits/stl_deque.h:22
							      								    								  77:5: note:	template argument deduction/substitu
							      								    								  tion failed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51:
							      								    								   note:   mismatched types ‘const std::deque<_Tp, _
							      								    								  Alloc>’ and ‘int’	     if(f_filled(param0[i])
							      								    								  == f_gold(param0[i]))
							      								    								  			 ^ In file included from /us
							      								    								  r/include/c++/8/functional:59,		  fr
							      								    								  om /usr/include/c++/8/x86_64-redhat-linux/bits/std
							      								    								  c++.h:71,		     from NTH_EVEN_LENGTH_PA
							      								    								  LINDROME.cpp:14: /usr/include/c++/8/bits/std_funct
							      								    								  ion.h:745:5: note: candidate: ‘template<class _Res
							      								    								  , class ... _Args> bool std::operator==(const std:
							      								    								  :function<_Res(_ArgTypes ...)>&, std::nullptr_t)’
							      								    								       operator==(const function<_Res(_Args...)>& __
							      								    								  f, nullptr_t) noexcept      ^~~~~~~~ /usr/include/
							      								    								  c++/8/bits/std_function.h:745:5: note:   template
							      								    								  argument deduction/substitution failed: NTH_EVEN_L
							      								    								  ENGTH_PALINDROME.cpp:39:51: note:   mismatched typ
							      								    								  es ‘const std::function<_Res(_ArgTypes ...)>’ and
							      								    								  ‘int’		 if(f_filled(param0[i]) == f_gold(pa
							      								    								  ram0[i]))
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/functional:59,		      from /usr/incl
							      								    								  ude/c++/8/x86_64-redhat-linux/bits/stdc++.h:71,
							      								    								  		 from NTH_EVEN_LENGTH_PALINDROME.cpp
							      								    								  :14: /usr/include/c++/8/bits/std_function.h:751:5:
							      								    								   note: candidate: ‘template<class _Res, class ...
							      								    								  _Args> bool std::operator==(std::nullptr_t, const
							      								    								  std::function<_Res(_ArgTypes ...)>&)’	     operato
							      								    								  r==(nullptr_t, const function<_Res(_Args...)>& __f
							      								    								  ) noexcept	  ^~~~~~~~ /usr/include/c++/8/bits/s
							      								    								  td_function.h:751:5: note:   template argument ded
							      								    								  uction/substitution failed: NTH_EVEN_LENGTH_PALIND
							      								    								  ROME.cpp:39:51: note:	  ‘std::__cxx11::string’ {ak
							      								    								  a ‘std::__cxx11::basic_string<char>’} is not deriv
							      								    								  ed from ‘const std::function<_Res(_ArgTypes ...)>’
							      								    								  	    if(f_filled(param0[i]) == f_gold(param0[
							      								    								  i]))
							      								    								  	^ In file included from /usr/include/c++/8/i
							      								    								  terator:66,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:77,
							      								    								  	  from NTH_EVEN_LENGTH_PALINDROME.cpp:14: /u
							      								    								  sr/include/c++/8/bits/stream_iterator.h:130:5: not
							      								    								  e: candidate: ‘template<class _Tp, class _CharT, c
							      								    								  lass _Traits, class _Dist> bool std::operator==(co
							      								    								  nst std::istream_iterator<_Tp, _CharT, _Traits, _D
							      								    								  ist>&, const std::istream_iterator<_Tp, _CharT, _T
							      								    								  raits, _Dist>&)’	operator==(const istream_ite
							      								    								  rator<_Tp, _CharT, _Traits, _Dist>& __x,	^~~~
							      								    								  ~~~~ /usr/include/c++/8/bits/stream_iterator.h:130
							      								    								  :5: note:   template argument deduction/substituti
							      								    								  on failed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: n
							      								    								  ote:	 mismatched types ‘const std::istream_iterat
							      								    								  or<_Tp, _CharT, _Traits, _Dist>’ and ‘int’
							      								    								    if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						  ^
							      								    								  In file included from /usr/include/c++/8/list:63,
							      								    								  		   from /usr/include/c++/8/x86_64-re
							      								    								  dhat-linux/bits/stdc++.h:79,			from
							      								    								   NTH_EVEN_LENGTH_PALINDROME.cpp:14: /usr/include/c
							      								    								  ++/8/bits/stl_list.h:344:5: note: candidate: ‘temp
							      								    								  late<class _Val> bool std::operator==(const std::_
							      								    								  List_iterator<_Tp>&, const std::_List_const_iterat
							      								    								  or<_Tp>&)’	  operator==(const _List_iterator<_V
							      								    								  al>& __x,	 ^~~~~~~~ /usr/include/c++/8/bits/st
							      								    								  l_list.h:344:5: note:	  template argument deductio
							      								    								  n/substitution failed: NTH_EVEN_LENGTH_PALINDROME.
							      								    								  cpp:39:51: note:   mismatched types ‘const std::_L
							      								    								  ist_iterator<_Tp>’ and ‘int’		if(f_filled(
							      								    								  param0[i]) == f_gold(param0[i]))
							      								    								  				    ^ In file includ
							      								    								  ed from /usr/include/c++/8/list:63,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:79,		  from NTH_EVEN_LENG
							      								    								  TH_PALINDROME.cpp:14: /usr/include/c++/8/bits/stl_
							      								    								  list.h:1987:5: note: candidate: ‘template<class _T
							      								    								  p, class _Alloc> bool std::operator==(const std::_
							      								    								  _cxx11::list<_Tp, _Alloc>&, const std::__cxx11::li
							      								    								  st<_Tp, _Alloc>&)’	  operator==(const list<_Tp,
							      								    								   _Alloc>& __x, const list<_Tp, _Alloc>& __y)
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/stl_list.h:1987:5
							      								    								  : note:   template argument deduction/substitution
							      								    								   failed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: not
							      								    								  e:   mismatched types ‘const std::__cxx11::list<_T
							      								    								  p, _Alloc>’ and ‘int’		 if(f_filled(param0[
							      								    								  i]) == f_gold(param0[i]))
							      								    								  			     ^ In file included from
							      								    								   /usr/include/c++/8/map:60,		       from
							      								    								  /usr/include/c++/8/x86_64-redhat-linux/bits/stdc++
							      								    								  .h:81,		  from NTH_EVEN_LENGTH_PALIN
							      								    								  DROME.cpp:14: /usr/include/c++/8/bits/stl_tree.h:4
							      								    								  06:5: note: candidate: ‘template<class _Val> bool
							      								    								  std::operator==(const std::_Rb_tree_iterator<_Tp>&
							      								    								  , const std::_Rb_tree_const_iterator<_Val>&)’
							      								    								   operator==(const _Rb_tree_iterator<_Val>& __x,
							      								    								     ^~~~~~~~ /usr/include/c++/8/bits/stl_tree.h:406
							      								    								  :5: note:   template argument deduction/substituti
							      								    								  on failed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: n
							      								    								  ote:	 mismatched types ‘const std::_Rb_tree_itera
							      								    								  tor<_Tp>’ and ‘int’	       if(f_filled(param0[i]
							      								    								  ) == f_gold(param0[i]))
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/map:60,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :81,			from NTH_EVEN_LENGTH_PALINDR
							      								    								  OME.cpp:14: /usr/include/c++/8/bits/stl_tree.h:155
							      								    								  6:5: note: candidate: ‘template<class _Key, class
							      								    								  _Val, class _KeyOfValue, class _Compare, class _Al
							      								    								  loc> bool std::operator==(const std::_Rb_tree<_Key
							      								    								  , _Val, _KeyOfValue, _Compare, _Alloc>&, const std
							      								    								  ::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _All
							      								    								  oc>&)’      operator==(const _Rb_tree<_Key, _Val,
							      								    								  _KeyOfValue, _Compare, _Alloc>& __x,	    ^~~~~~~~
							      								    								   /usr/include/c++/8/bits/stl_tree.h:1556:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:	 mis
							      								    								  matched types ‘const std::_Rb_tree<_Key, _Val, _Ke
							      								    								  yOfValue, _Compare, _Alloc>’ and ‘int’	  if
							      								    								  (f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/map:61,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:81,		   from NTH_
							      								    								  EVEN_LENGTH_PALINDROME.cpp:14: /usr/include/c++/8/
							      								    								  bits/stl_map.h:1434:5: note: candidate: ‘template<
							      								    								  class _Key, class _Tp, class _Compare, class _Allo
							      								    								  c> bool std::operator==(const std::map<_Key, _Tp,
							      								    								  _Compare, _Alloc>&, const std::map<_Key, _Tp, _Com
							      								    								  pare, _Alloc>&)’	operator==(const map<_Key, _
							      								    								  Tp, _Compare, _Alloc>& __x,	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/stl_map.h:1434:5: note:   template
							      								    								   argument deduction/substitution failed: NTH_EVEN_
							      								    								  LENGTH_PALINDROME.cpp:39:51: note:   mismatched ty
							      								    								  pes ‘const std::map<_Key, _Tp, _Compare, _Alloc>’
							      								    								  and ‘int’	     if(f_filled(param0[i]) == f_gol
							      								    								  d(param0[i]))
							      								    								  		 ^ In file included from /usr/includ
							      								    								  e/c++/8/map:62,		   from /usr/include
							      								    								  /c++/8/x86_64-redhat-linux/bits/stdc++.h:81,
							      								    								  	      from NTH_EVEN_LENGTH_PALINDROME.cpp:14
							      								    								  : /usr/include/c++/8/bits/stl_multimap.h:1098:5: n
							      								    								  ote: candidate: ‘template<class _Key, class _Tp, c
							      								    								  lass _Compare, class _Alloc> bool std::operator==(
							      								    								  const std::multimap<_Key, _Tp, _Compare, _Alloc>&,
							      								    								   const std::multimap<_Key, _Tp, _Compare, _Alloc>&
							      								    								  )’	  operator==(const multimap<_Key, _Tp, _Comp
							      								    								  are, _Alloc>& __x,	  ^~~~~~~~ /usr/include/c++/
							      								    								  8/bits/stl_multimap.h:1098:5: note:	template arg
							      								    								  ument deduction/substitution failed: NTH_EVEN_LENG
							      								    								  TH_PALINDROME.cpp:39:51: note:   mismatched types
							      								    								  ‘const std::multimap<_Key, _Tp, _Compare, _Alloc>’
							      								    								   and ‘int’	      if(f_filled(param0[i]) == f_go
							      								    								  ld(param0[i]))
							      								    								  		  ^ In file included from /usr/inclu
							      								    								  de/c++/8/bits/shared_ptr.h:52,		  fr
							      								    								  om /usr/include/c++/8/memory:81,
							      								    								  from /usr/include/c++/8/x86_64-redhat-linux/bits/s
							      								    								  tdc++.h:82,		       from NTH_EVEN_LENGTH_
							      								    								  PALINDROME.cpp:14: /usr/include/c++/8/bits/shared_
							      								    								  ptr_base.h:1410:5: note: candidate: ‘template<clas
							      								    								  s _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> b
							      								    								  ool std::operator==(const std::__shared_ptr<_Tp1,
							      								    								  _Lp>&, const std::__shared_ptr<_Tp2, _Lp>&)’
							      								    								  operator==(const __shared_ptr<_Tp1, _Lp>& __a,
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr_base
							      								    								  .h:1410:5: note:   template argument deduction/sub
							      								    								  stitution failed: NTH_EVEN_LENGTH_PALINDROME.cpp:3
							      								    								  9:51: note:	mismatched types ‘const std::__share
							      								    								  d_ptr<_Tp1, _Lp>’ and ‘int’	       if(f_filled(p
							      								    								  aram0[i]) == f_gold(param0[i]))
							      								    								  				   ^ In file include
							      								    								  d from /usr/include/c++/8/bits/shared_ptr.h:52,
							      								    								  		 from /usr/include/c++/8/memory:81,
							      								    								  		   from /usr/include/c++/8/x86_64-re
							      								    								  dhat-linux/bits/stdc++.h:82,			from
							      								    								   NTH_EVEN_LENGTH_PALINDROME.cpp:14: /usr/include/c
							      								    								  ++/8/bits/shared_ptr_base.h:1416:5: note: candidat
							      								    								  e: ‘template<class _Tp, __gnu_cxx::_Lock_policy _L
							      								    								  p> bool std::operator==(const std::__shared_ptr<_T
							      								    								  p, _Lp>&, std::nullptr_t)’	  operator==(const _
							      								    								  _shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
							      								    								     ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr_bas
							      								    								  e.h:1416:5: note:   template argument deduction/su
							      								    								  bstitution failed: NTH_EVEN_LENGTH_PALINDROME.cpp:
							      								    								  39:51: note:	 mismatched types ‘const std::__shar
							      								    								  ed_ptr<_Tp, _Lp>’ and ‘int’	       if(f_filled(p
							      								    								  aram0[i]) == f_gold(param0[i]))
							      								    								  				   ^ In file include
							      								    								  d from /usr/include/c++/8/bits/shared_ptr.h:52,
							      								    								  		 from /usr/include/c++/8/memory:81,
							      								    								  		   from /usr/include/c++/8/x86_64-re
							      								    								  dhat-linux/bits/stdc++.h:82,			from
							      								    								   NTH_EVEN_LENGTH_PALINDROME.cpp:14: /usr/include/c
							      								    								  ++/8/bits/shared_ptr_base.h:1421:5: note: candidat
							      								    								  e: ‘template<class _Tp, __gnu_cxx::_Lock_policy _L
							      								    								  p> bool std::operator==(std::nullptr_t, const std:
							      								    								  :__shared_ptr<_Tp, _Lp>&)’	  operator==(nullptr
							      								    								  _t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
							      								    								     ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr_bas
							      								    								  e.h:1421:5: note:   template argument deduction/su
							      								    								  bstitution failed: NTH_EVEN_LENGTH_PALINDROME.cpp:
							      								    								  39:51: note:	 ‘std::__cxx11::string’ {aka ‘std::_
							      								    								  _cxx11::basic_string<char>’} is not derived from ‘
							      								    								  const std::__shared_ptr<_Tp, _Lp>’	      if(f_f
							      								    								  illed(param0[i]) == f_gold(param0[i]))
							      								    								  					  ^ In file
							      								    								  included from /usr/include/c++/8/memory:81,
							      								    								  	     from /usr/include/c++/8/x86_64-redhat-l
							      								    								  inux/bits/stdc++.h:82,		  from NTH_E
							      								    								  VEN_LENGTH_PALINDROME.cpp:14: /usr/include/c++/8/b
							      								    								  its/shared_ptr.h:383:5: note: candidate: ‘template
							      								    								  <class _Tp, class _Up> bool std::operator==(const
							      								    								  std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&
							      								    								  )’	  operator==(const shared_ptr<_Tp>& __a, con
							      								    								  st shared_ptr<_Up>& __b) noexcept	 ^~~~~~~~ /u
							      								    								  sr/include/c++/8/bits/shared_ptr.h:383:5: note:
							      								    								  template argument deduction/substitution failed: N
							      								    								  TH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:   misma
							      								    								  tched types ‘const std::shared_ptr<_Tp>’ and ‘int’
							      								    								  	    if(f_filled(param0[i]) == f_gold(param0[
							      								    								  i]))
							      								    								  	^ In file included from /usr/include/c++/8/m
							      								    								  emory:81,		     from /usr/include/c++/8
							      								    								  /x86_64-redhat-linux/bits/stdc++.h:82,
							      								    								  	from NTH_EVEN_LENGTH_PALINDROME.cpp:14: /usr
							      								    								  /include/c++/8/bits/shared_ptr.h:388:5: note: cand
							      								    								  idate: ‘template<class _Tp> bool std::operator==(c
							      								    								  onst std::shared_ptr<_Tp>&, std::nullptr_t)’
							      								    								  operator==(const shared_ptr<_Tp>& __a, nullptr_t)
							      								    								  noexcept	^~~~~~~~ /usr/include/c++/8/bits/sha
							      								    								  red_ptr.h:388:5: note:   template argument deducti
							      								    								  on/substitution failed: NTH_EVEN_LENGTH_PALINDROME
							      								    								  .cpp:39:51: note:   mismatched types ‘const std::s
							      								    								  hared_ptr<_Tp>’ and ‘int’	     if(f_filled(par
							      								    								  am0[i]) == f_gold(param0[i]))
							      								    								  				 ^ In file included
							      								    								  from /usr/include/c++/8/memory:81,
							      								    								    from /usr/include/c++/8/x86_64-redhat-linux/bits
							      								    								  /stdc++.h:82,			 from NTH_EVEN_LENGT
							      								    								  H_PALINDROME.cpp:14: /usr/include/c++/8/bits/share
							      								    								  d_ptr.h:393:5: note: candidate: ‘template<class _T
							      								    								  p> bool std::operator==(std::nullptr_t, const std:
							      								    								  :shared_ptr<_Tp>&)’	   operator==(nullptr_t, con
							      								    								  st shared_ptr<_Tp>& __a) noexcept	 ^~~~~~~~ /u
							      								    								  sr/include/c++/8/bits/shared_ptr.h:393:5: note:
							      								    								  template argument deduction/substitution failed: N
							      								    								  TH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:   ‘std:
							      								    								  :__cxx11::string’ {aka ‘std::__cxx11::basic_string
							      								    								  <char>’} is not derived from ‘const std::shared_pt
							      								    								  r<_Tp>’	   if(f_filled(param0[i]) == f_gold(
							      								    								  param0[i]))
							      								    								  	       ^ In file included from /usr/include/
							      								    								  c++/8/queue:64,		   from /usr/include
							      								    								  /c++/8/x86_64-redhat-linux/bits/stdc++.h:86,
							      								    								  	      from NTH_EVEN_LENGTH_PALINDROME.cpp:14
							      								    								  : /usr/include/c++/8/bits/stl_queue.h:330:5: note:
							      								    								   candidate: ‘template<class _Tp, class _Seq> bool
							      								    								  std::operator==(const std::queue<_Tp, _Seq>&, cons
							      								    								  t std::queue<_Tp, _Seq>&)’	  operator==(const q
							      								    								  ueue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
							      								    								  	^~~~~~~~ /usr/include/c++/8/bits/stl_queue.h
							      								    								  :330:5: note:	  template argument deduction/substi
							      								    								  tution failed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:5
							      								    								  1: note:   mismatched types ‘const std::queue<_Tp,
							      								    								   _Seq>’ and ‘int’	     if(f_filled(param0[i])
							      								    								  == f_gold(param0[i]))
							      								    								  			 ^ In file included from /us
							      								    								  r/include/c++/8/set:61,		   from /usr
							      								    								  /include/c++/8/x86_64-redhat-linux/bits/stdc++.h:8
							      								    								  7,		      from NTH_EVEN_LENGTH_PALINDROM
							      								    								  E.cpp:14: /usr/include/c++/8/bits/stl_set.h:958:5:
							      								    								   note: candidate: ‘template<class _Key, class _Com
							      								    								  pare, class _Alloc> bool std::operator==(const std
							      								    								  ::set<_Key, _Compare, _Alloc>&, const std::set<_Ke
							      								    								  y, _Compare, _Alloc>&)’      operator==(const set<
							      								    								  _Key, _Compare, _Alloc>& __x,	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/stl_set.h:958:5: note:   templat
							      								    								  e argument deduction/substitution failed: NTH_EVEN
							      								    								  _LENGTH_PALINDROME.cpp:39:51: note:	mismatched t
							      								    								  ypes ‘const std::set<_Key, _Compare, _Alloc>’ and
							      								    								  ‘int’		 if(f_filled(param0[i]) == f_gold(pa
							      								    								  ram0[i]))
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/set:62,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:87,
							      								    								  	  from NTH_EVEN_LENGTH_PALINDROME.cpp:14: /u
							      								    								  sr/include/c++/8/bits/stl_multiset.h:943:5: note:
							      								    								  candidate: ‘template<class _Key, class _Compare, c
							      								    								  lass _Alloc> bool std::operator==(const std::multi
							      								    								  set<_Key, _Compare, _Alloc>&, const std::multiset<
							      								    								  _Key, _Compare, _Alloc>&)’	  operator==(const m
							      								    								  ultiset<_Key, _Compare, _Alloc>& __x,	     ^~~~~~~
							      								    								  ~ /usr/include/c++/8/bits/stl_multiset.h:943:5: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:
							      								    								   mismatched types ‘const std::multiset<_Key, _Comp
							      								    								  are, _Alloc>’ and ‘int’	   if(f_filled(param
							      								    								  0[i]) == f_gold(param0[i]))
							      								    								  			       ^ In file included fr
							      								    								  om /usr/include/c++/8/stack:61,		   f
							      								    								  rom /usr/include/c++/8/x86_64-redhat-linux/bits/st
							      								    								  dc++.h:89,		      from NTH_EVEN_LENGTH_P
							      								    								  ALINDROME.cpp:14: /usr/include/c++/8/bits/stl_stac
							      								    								  k.h:305:5: note: candidate: ‘template<class _Tp, c
							      								    								  lass _Seq> bool std::operator==(const std::stack<_
							      								    								  Tp, _Seq>&, const std::stack<_Tp, _Seq>&)’	  op
							      								    								  erator==(const stack<_Tp, _Seq>& __x, const stack<
							      								    								  _Tp, _Seq>& __y)	^~~~~~~~ /usr/include/c++/8/
							      								    								  bits/stl_stack.h:305:5: note:	  template argument
							      								    								  deduction/substitution failed: NTH_EVEN_LENGTH_PAL
							      								    								  INDROME.cpp:39:51: note:   mismatched types ‘const
							      								    								   std::stack<_Tp, _Seq>’ and ‘int’	     if(f_fi
							      								    								  lled(param0[i]) == f_gold(param0[i]))
							      								    								  					 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/valarray:592,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:95,		    from NTH
							      								    								  _EVEN_LENGTH_PALINDROME.cpp:14: /usr/include/c++/8
							      								    								  /bits/valarray_after.h:414:5: note: candidate: ‘te
							      								    								  mplate<class _Dom1, class _Dom2> std::_Expr<std::_
							      								    								  BinClos<std::__equal_to, std::_Expr, std::_Expr, _
							      								    								  Dom1, _Dom2>, typename std::__fun<std::__equal_to,
							      								    								   typename _Dom1::value_type>::result_type> std::op
							      								    								  erator==(const std::_Expr<_Dom1, typename _Dom1::v
							      								    								  alue_type>&, const std::_Expr<_Dom2, typename _Dom
							      								    								  2::value_type>&)’	 _DEFINE_EXPR_BINARY_OPERATO
							      								    								  R(==, __equal_to)	 ^~~~~~~~~~~~~~~~~~~~~~~~~~~
							      								    								  ~ /usr/include/c++/8/bits/valarray_after.h:414:5:
							      								    								  note:	  template argument deduction/substitution f
							      								    								  ailed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:
							      								    								     mismatched types ‘const std::_Expr<_Dom1, typen
							      								    								  ame _Dom1::value_type>’ and ‘int’	     if(f_fi
							      								    								  lled(param0[i]) == f_gold(param0[i]))
							      								    								  					 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/valarray:592,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:95,		    from NTH
							      								    								  _EVEN_LENGTH_PALINDROME.cpp:14: /usr/include/c++/8
							      								    								  /bits/valarray_after.h:414:5: note: candidate: ‘te
							      								    								  mplate<class _Dom> std::_Expr<std::_BinClos<std::_
							      								    								  _equal_to, std::_Expr, std::_Constant, _Dom, typen
							      								    								  ame _Dom::value_type>, typename std::__fun<std::__
							      								    								  equal_to, typename _Dom1::value_type>::result_type
							      								    								  > std::operator==(const std::_Expr<_Dom1, typename
							      								    								   _Dom1::value_type>&, const typename _Dom::value_t
							      								    								  ype&)’      _DEFINE_EXPR_BINARY_OPERATOR(==, __equ
							      								    								  al_to)      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/valarray_after.h:414:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: NTH_
							      								    								  EVEN_LENGTH_PALINDROME.cpp:39:51: note:   mismatch
							      								    								  ed types ‘const std::_Expr<_Dom1, typename _Dom1::
							      								    								  value_type>’ and ‘int’	  if(f_filled(param0
							      								    								  [i]) == f_gold(param0[i]))
							      								    								  			      ^ In file included fro
							      								    								  m /usr/include/c++/8/valarray:592,
							      								    								    from /usr/include/c++/8/x86_64-redhat-linux/bits
							      								    								  /stdc++.h:95,			 from NTH_EVEN_LENGT
							      								    								  H_PALINDROME.cpp:14: /usr/include/c++/8/bits/valar
							      								    								  ray_after.h:414:5: note: candidate: ‘template<clas
							      								    								  s _Dom> std::_Expr<std::_BinClos<std::__equal_to,
							      								    								  std::_Constant, std::_Expr, typename _Dom::value_t
							      								    								  ype, _Dom>, typename std::__fun<std::__equal_to, t
							      								    								  ypename _Dom1::value_type>::result_type> std::oper
							      								    								  ator==(const typename _Dom::value_type&, const std
							      								    								  ::_Expr<_Dom1, typename _Dom1::value_type>&)’
							      								    								   _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)
							      								    								   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/b
							      								    								  its/valarray_after.h:414:5: note:   template argum
							      								    								  ent deduction/substitution failed: NTH_EVEN_LENGTH
							      								    								  _PALINDROME.cpp:39:51: note:	 ‘std::__cxx11::stri
							      								    								  ng’ {aka ‘std::__cxx11::basic_string<char>’} is no
							      								    								  t derived from ‘const std::_Expr<_Dom1, typename _
							      								    								  Dom1::value_type>’	      if(f_filled(param0[i])
							      								    								   == f_gold(param0[i]))
							      								    								  			  ^ In file included from /u
							      								    								  sr/include/c++/8/valarray:592,		  fr
							      								    								  om /usr/include/c++/8/x86_64-redhat-linux/bits/std
							      								    								  c++.h:95,		     from NTH_EVEN_LENGTH_PA
							      								    								  LINDROME.cpp:14: /usr/include/c++/8/bits/valarray_
							      								    								  after.h:414:5: note: candidate: ‘template<class _D
							      								    								  om> std::_Expr<std::_BinClos<std::__equal_to, std:
							      								    								  :_Expr, std::_ValArray, _Dom, typename _Dom::value
							      								    								  _type>, typename std::__fun<std::__equal_to, typen
							      								    								  ame _Dom1::value_type>::result_type> std::operator
							      								    								  ==(const std::_Expr<_Dom1, typename _Dom1::value_t
							      								    								  ype>&, const std::valarray<typename _Dom::value_ty
							      								    								  pe>&)’      _DEFINE_EXPR_BINARY_OPERATOR(==, __equ
							      								    								  al_to)      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/valarray_after.h:414:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: NTH_
							      								    								  EVEN_LENGTH_PALINDROME.cpp:39:51: note:   mismatch
							      								    								  ed types ‘const std::_Expr<_Dom1, typename _Dom1::
							      								    								  value_type>’ and ‘int’	  if(f_filled(param0
							      								    								  [i]) == f_gold(param0[i]))
							      								    								  			      ^ In file included fro
							      								    								  m /usr/include/c++/8/valarray:592,
							      								    								    from /usr/include/c++/8/x86_64-redhat-linux/bits
							      								    								  /stdc++.h:95,			 from NTH_EVEN_LENGT
							      								    								  H_PALINDROME.cpp:14: /usr/include/c++/8/bits/valar
							      								    								  ray_after.h:414:5: note: candidate: ‘template<clas
							      								    								  s _Dom> std::_Expr<std::_BinClos<std::__equal_to,
							      								    								  std::_ValArray, std::_Expr, typename _Dom::value_t
							      								    								  ype, _Dom>, typename std::__fun<std::__equal_to, t
							      								    								  ypename _Dom1::value_type>::result_type> std::oper
							      								    								  ator==(const std::valarray<typename _Dom::value_ty
							      								    								  pe>&, const std::_Expr<_Dom1, typename _Dom1::valu
							      								    								  e_type>&)’	  _DEFINE_EXPR_BINARY_OPERATOR(==, _
							      								    								  _equal_to)	  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/
							      								    								  include/c++/8/bits/valarray_after.h:414:5: note:
							      								    								   template argument deduction/substitution failed:
							      								    								  NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:	‘std
							      								    								  ::__cxx11::string’ {aka ‘std::__cxx11::basic_strin
							      								    								  g<char>’} is not derived from ‘const std::_Expr<_D
							      								    								  om1, typename _Dom1::value_type>’	     if(f_fi
							      								    								  lled(param0[i]) == f_gold(param0[i]))
							      								    								  					 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/x86_64-redhat-linu
							      								    								  x/bits/stdc++.h:95,		       from NTH_EVEN
							      								    								  _LENGTH_PALINDROME.cpp:14: /usr/include/c++/8/vala
							      								    								  rray:1184:1: note: candidate: ‘template<class _Tp>
							      								    								   std::_Expr<std::_BinClos<std::__equal_to, std::_V
							      								    								  alArray, std::_ValArray, _Tp, _Tp>, typename std::
							      								    								  __fun<std::__equal_to, _Tp>::result_type> std::ope
							      								    								  rator==(const std::valarray<_Tp>&, const std::vala
							      								    								  rray<_Tp>&)’	_DEFINE_BINARY_OPERATOR(==, __equal_
							      								    								  to)  ^~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/va
							      								    								  larray:1184:1: note:	 template argument deduction
							      								    								  /substitution failed: NTH_EVEN_LENGTH_PALINDROME.c
							      								    								  pp:39:51: note:   mismatched types ‘const std::val
							      								    								  array<_Tp>’ and ‘int’		 if(f_filled(param0[
							      								    								  i]) == f_gold(param0[i]))
							      								    								  			     ^ In file included from
							      								    								   /usr/include/c++/8/x86_64-redhat-linux/bits/stdc+
							      								    								  +.h:95,		   from NTH_EVEN_LENGTH_PALI
							      								    								  NDROME.cpp:14: /usr/include/c++/8/valarray:1184:1:
							      								    								   note: candidate: ‘template<class _Tp> std::_Expr<
							      								    								  std::_BinClos<std::__equal_to, std::_ValArray, std
							      								    								  ::_Constant, _Tp, _Tp>, typename std::__fun<std::_
							      								    								  _equal_to, _Tp>::result_type> std::operator==(cons
							      								    								  t std::valarray<_Tp>&, const _Tp&)’  _DEFINE_BINAR
							      								    								  Y_OPERATOR(==, __equal_to)  ^~~~~~~~~~~~~~~~~~~~~~
							      								    								  ~ /usr/include/c++/8/valarray:1184:1: note:	temp
							      								    								  late argument deduction/substitution failed: NTH_E
							      								    								  VEN_LENGTH_PALINDROME.cpp:39:51: note:   mismatche
							      								    								  d types ‘const std::valarray<_Tp>’ and ‘int’
							      								    								      if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  
							      								    								  ^ In file included from /usr/include/c++/8/x86_64-
							      								    								  redhat-linux/bits/stdc++.h:95,		  fr
							      								    								  om NTH_EVEN_LENGTH_PALINDROME.cpp:14: /usr/include
							      								    								  /c++/8/valarray:1184:1: note: candidate: ‘template
							      								    								  <class _Tp> std::_Expr<std::_BinClos<std::__equal_
							      								    								  to, std::_Constant, std::_ValArray, _Tp, _Tp>, typ
							      								    								  ename std::__fun<std::__equal_to, _Tp>::result_typ
							      								    								  e> std::operator==(const _Tp&, const std::valarray
							      								    								  <_Tp>&)’  _DEFINE_BINARY_OPERATOR(==, __equal_to)
							      								    								   ^~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/valarr
							      								    								  ay:1184:1: note:   template argument deduction/sub
							      								    								  stitution failed: NTH_EVEN_LENGTH_PALINDROME.cpp:3
							      								    								  9:51: note:	‘std::__cxx11::string’ {aka ‘std::__
							      								    								  cxx11::basic_string<char>’} is not derived from ‘c
							      								    								  onst std::valarray<_Tp>’	    if(f_filled(para
							      								    								  m0[i]) == f_gold(param0[i]))
							      								    								  				^ In file included f
							      								    								  rom /usr/include/c++/8/forward_list:38,
							      								    								  	 from /usr/include/c++/8/x86_64-redhat-linux
							      								    								  /bits/stdc++.h:104,		       from NTH_EVEN
							      								    								  _LENGTH_PALINDROME.cpp:14: /usr/include/c++/8/bits
							      								    								  /forward_list.h:272:5: note: candidate: ‘template<
							      								    								  class _Tp> bool std::operator==(const std::_Fwd_li
							      								    								  st_iterator<_Tp>&, const std::_Fwd_list_const_iter
							      								    								  ator<_Tp>&)’	    operator==(const _Fwd_list_itera
							      								    								  tor<_Tp>& __x,      ^~~~~~~~ /usr/include/c++/8/bi
							      								    								  ts/forward_list.h:272:5: note:   template argument
							      								    								   deduction/substitution failed: NTH_EVEN_LENGTH_PA
							      								    								  LINDROME.cpp:39:51: note:   mismatched types ‘cons
							      								    								  t std::_Fwd_list_iterator<_Tp>’ and ‘int’
							      								    								   if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						 ^ I
							      								    								  n file included from /usr/include/c++/8/forward_li
							      								    								  st:40,		  from /usr/include/c++/8/x8
							      								    								  6_64-redhat-linux/bits/stdc++.h:104,
							      								    								      from NTH_EVEN_LENGTH_PALINDROME.cpp:14: /usr/i
							      								    								  nclude/c++/8/bits/forward_list.tcc:369:5: note: ca
							      								    								  ndidate: ‘template<class _Tp, class _Alloc> bool s
							      								    								  td::operator==(const std::forward_list<_Tp, _Alloc
							      								    								  >&, const std::forward_list<_Tp, _Alloc>&)’	   o
							      								    								  perator==(const forward_list<_Tp, _Alloc>& __lx,
							      								    								      ^~~~~~~~ /usr/include/c++/8/bits/forward_list.
							      								    								  tcc:369:5: note:   template argument deduction/sub
							      								    								  stitution failed: NTH_EVEN_LENGTH_PALINDROME.cpp:3
							      								    								  9:51: note:	mismatched types ‘const std::forward
							      								    								  _list<_Tp, _Alloc>’ and ‘int’		 if(f_filled
							      								    								  (param0[i]) == f_gold(param0[i]))
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/future:39,
							      								    								  	from /usr/include/c++/8/x86_64-redhat-linux/
							      								    								  bits/stdc++.h:105,		      from NTH_EVEN_
							      								    								  LENGTH_PALINDROME.cpp:14: /usr/include/c++/8/threa
							      								    								  d:277:3: note: candidate: ‘bool std::operator==(st
							      								    								  d::thread::id, std::thread::id)’    operator==(thr
							      								    								  ead::id __x, thread::id __y) noexcept	   ^~~~~~~~
							      								    								  /usr/include/c++/8/thread:277:3: note:   no known
							      								    								  conversion for argument 1 from ‘int’ to ‘std::thre
							      								    								  ad::id’ In file included from /usr/include/c++/8/r
							      								    								  andom:51,		     from /usr/include/c++/8
							      								    								  /x86_64-redhat-linux/bits/stdc++.h:108,
							      								    								  	 from NTH_EVEN_LENGTH_PALINDROME.cpp:14: /us
							      								    								  r/include/c++/8/bits/random.tcc:1881:5: note: cand
							      								    								  idate: ‘template<class _RealType1> bool std::opera
							      								    								  tor==(const std::normal_distribution<_RealType>&,
							      								    								  const std::normal_distribution<_RealType>&)’
							      								    								  operator==(const std::normal_distribution<_RealTyp
							      								    								  e>& __d1,	 ^~~~~~~~ /usr/include/c++/8/bits/ra
							      								    								  ndom.tcc:1881:5: note:   template argument deducti
							      								    								  on/substitution failed: NTH_EVEN_LENGTH_PALINDROME
							      								    								  .cpp:39:51: note:   mismatched types ‘const std::n
							      								    								  ormal_distribution<_RealType>’ and ‘int’
							      								    								  if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						^ In
							      								    								   file included from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:111,		       from
							      								    								  NTH_EVEN_LENGTH_PALINDROME.cpp:14: /usr/include/c+
							      								    								  +/8/scoped_allocator:459:5: note: candidate: ‘temp
							      								    								  late<class _OutA1, class _OutA2, class ... _InA> b
							      								    								  ool std::operator==(const std::scoped_allocator_ad
							      								    								  aptor<_OutA1, _InA ...>&, const std::scoped_alloca
							      								    								  tor_adaptor<_InnerHead, _InnerTail ...>&)’	  op
							      								    								  erator==(const scoped_allocator_adaptor<_OutA1, _I
							      								    								  nA...>& __a,	    ^~~~~~~~ /usr/include/c++/8/scop
							      								    								  ed_allocator:459:5: note:   template argument dedu
							      								    								  ction/substitution failed: NTH_EVEN_LENGTH_PALINDR
							      								    								  OME.cpp:39:51: note:	 mismatched types ‘const std
							      								    								  ::scoped_allocator_adaptor<_OutA1, _InA ...>’ and
							      								    								  ‘int’		 if(f_filled(param0[i]) == f_gold(pa
							      								    								  ram0[i]))
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/unordered_map:47,			 from /usr/i
							      								    								  nclude/c++/8/x86_64-redhat-linux/bits/stdc++.h:117
							      								    								  ,		     from NTH_EVEN_LENGTH_PALINDROME
							      								    								  .cpp:14: /usr/include/c++/8/bits/unordered_map.h:2
							      								    								  057:5: note: candidate: ‘template<class _Key, clas
							      								    								  s _Tp, class _Hash, class _Pred, class _Alloc> boo
							      								    								  l std::operator==(const std::unordered_map<_Key, _
							      								    								  Tp, _Hash, _Pred, _Alloc>&, const std::unordered_m
							      								    								  ap<_Key, _Tp, _Hash, _Pred, _Alloc>&)’      operat
							      								    								  or==(const unordered_map<_Key, _Tp, _Hash, _Pred,
							      								    								  _Alloc>& __x,	     ^~~~~~~~ /usr/include/c++/8/bit
							      								    								  s/unordered_map.h:2057:5: note:   template argumen
							      								    								  t deduction/substitution failed: NTH_EVEN_LENGTH_P
							      								    								  ALINDROME.cpp:39:51: note:   mismatched types ‘con
							      								    								  st std::unordered_map<_Key, _Tp, _Hash, _Pred, _Al
							      								    								  loc>’ and ‘int’	   if(f_filled(param0[i]) ==
							      								    								   f_gold(param0[i]))
							      								    								  		       ^ In file included from /usr/
							      								    								  include/c++/8/unordered_map:47,		   f
							      								    								  rom /usr/include/c++/8/x86_64-redhat-linux/bits/st
							      								    								  dc++.h:117,		       from NTH_EVEN_LENGTH_
							      								    								  PALINDROME.cpp:14: /usr/include/c++/8/bits/unorder
							      								    								  ed_map.h:2069:5: note: candidate: ‘template<class
							      								    								  _Key, class _Tp, class _Hash, class _Pred, class _
							      								    								  Alloc> bool std::operator==(const std::unordered_m
							      								    								  ultimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const s
							      								    								  td::unordered_multimap<_Key, _Tp, _Hash, _Pred, _A
							      								    								  lloc>&)’	operator==(const unordered_multimap<
							      								    								  _Key, _Tp, _Hash, _Pred, _Alloc>& __x,      ^~~~~~
							      								    								  ~~ /usr/include/c++/8/bits/unordered_map.h:2069:5:
							      								    								   note:   template argument deduction/substitution
							      								    								  failed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note
							      								    								  :   mismatched types ‘const std::unordered_multima
							      								    								  p<_Key, _Tp, _Hash, _Pred, _Alloc>’ and ‘int’
							      								    								       if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  
							      								    								   ^ In file included from /usr/include/c++/8/unorde
							      								    								  red_set:47,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:118,
							      								    								  	   from NTH_EVEN_LENGTH_PALINDROME.cpp:14: /
							      								    								  usr/include/c++/8/bits/unordered_set.h:1669:5: not
							      								    								  e: candidate: ‘template<class _Value, class _Hash,
							      								    								   class _Pred, class _Alloc> bool std::operator==(c
							      								    								  onst std::unordered_set<_Value, _Hash, _Pred, _All
							      								    								  oc>&, const std::unordered_set<_Value, _Hash, _Pre
							      								    								  d, _Alloc>&)’	     operator==(const unordered_set<
							      								    								  _Value, _Hash, _Pred, _Alloc>& __x,	   ^~~~~~~~
							      								    								  /usr/include/c++/8/bits/unordered_set.h:1669:5: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note:
							      								    								   mismatched types ‘const std::unordered_set<_Value
							      								    								  , _Hash, _Pred, _Alloc>’ and ‘int’	      if(f_f
							      								    								  illed(param0[i]) == f_gold(param0[i]))
							      								    								  					  ^ In file
							      								    								  included from /usr/include/c++/8/unordered_set:47,
							      								    								  		    from /usr/include/c++/8/x86_64-r
							      								    								  edhat-linux/bits/stdc++.h:118,		  fr
							      								    								  om NTH_EVEN_LENGTH_PALINDROME.cpp:14: /usr/include
							      								    								  /c++/8/bits/unordered_set.h:1681:5: note: candidat
							      								    								  e: ‘template<class _Value, class _Hash, class _Pre
							      								    								  d, class _Alloc> bool std::operator==(const std::u
							      								    								  nordered_multiset<_Value, _Hash, _Pred, _Alloc>&,
							      								    								  const std::unordered_multiset<_Value, _Hash, _Pred
							      								    								  , _Alloc>&)’	    operator==(const unordered_multi
							      								    								  set<_Value, _Hash, _Pred, _Alloc>& __x,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/unordered_set.h:1681:5
							      								    								  : note:   template argument deduction/substitution
							      								    								   failed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: not
							      								    								  e:   mismatched types ‘const std::unordered_multis
							      								    								  et<_Value, _Hash, _Pred, _Alloc>’ and ‘int’
							      								    								     if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						   ^
							      								    								   In file included from /usr/include/c++/8/bits/stl
							      								    								  _algobase.h:67,		   from /usr/include
							      								    								  /c++/8/bits/char_traits.h:39,			 fro
							      								    								  m /usr/include/c++/8/ios:40,			from
							      								    								   /usr/include/c++/8/ostream:38,		   f
							      								    								  rom /usr/include/c++/8/iostream:39,
							      								    								     from NTH_EVEN_LENGTH_PALINDROME.cpp:8: /usr/inc
							      								    								  lude/c++/8/bits/stl_iterator.h:863:5: note: candid
							      								    								  ate: ‘template<class _IteratorL, class _IteratorR,
							      								    								   class _Container> bool __gnu_cxx::operator==(cons
							      								    								  t __gnu_cxx::__normal_iterator<_IteratorL, _Contai
							      								    								  ner>&, const __gnu_cxx::__normal_iterator<_Iterato
							      								    								  rR, _Container>&)’	  operator==(const __normal_
							      								    								  iterator<_IteratorL, _Container>& __lhs,	^~~~
							      								    								  ~~~~ /usr/include/c++/8/bits/stl_iterator.h:863:5:
							      								    								   note:   template argument deduction/substitution
							      								    								  failed: NTH_EVEN_LENGTH_PALINDROME.cpp:39:51: note
							      								    								  :   mismatched types ‘const __gnu_cxx::__normal_it
							      								    								  erator<_IteratorL, _Container>’ and ‘int’
							      								    								   if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						 ^ I
							      								    								  n file included from /usr/include/c++/8/bits/stl_a
							      								    								  lgobase.h:67,			 from /usr/include/c
							      								    								  ++/8/bits/char_traits.h:39,		       from
							      								    								  /usr/include/c++/8/ios:40,		      from /
							      								    								  usr/include/c++/8/ostream:38,			 fro
							      								    								  m /usr/include/c++/8/iostream:39,
							      								    								   from NTH_EVEN_LENGTH_PALINDROME.cpp:8: /usr/inclu
							      								    								  de/c++/8/bits/stl_iterator.h:870:5: note: candidat
							      								    								  e: ‘template<class _Iterator, class _Container> bo
							      								    								  ol __gnu_cxx::operator==(const __gnu_cxx::__normal
							      								    								  _iterator<_Iterator, _Container>&, const __gnu_cxx
							      								    								  ::__normal_iterator<_Iterator, _Container>&)’
							      								    								   operator==(const __normal_iterator<_Iterator, _Co
							      								    								  ntainer>& __lhs,	^~~~~~~~ /usr/include/c++/8/
							      								    								  bits/stl_iterator.h:870:5: note:   template argume
							      								    								  nt deduction/substitution failed: NTH_EVEN_LENGTH_
							      								    								  PALINDROME.cpp:39:51: note:	mismatched types ‘co
							      								    								  nst __gnu_cxx::__normal_iterator<_Iterator, _Conta
							      								    								  iner>’ and ‘int’	    if(f_filled(param0[i]) =
							      								    								  = f_gold(param0[i]))
							      								    								  			^ In file included from /usr
							      								    								  /include/c++/8/x86_64-redhat-linux/bits/c++allocat
							      								    								  or.h:33,		    from /usr/include/c++/8/
							      								    								  bits/allocator.h:46,			from /usr/in
							      								    								  clude/c++/8/string:41,		  from /usr/
							      								    								  include/c++/8/bits/locale_classes.h:40,
							      								    								  	 from /usr/include/c++/8/bits/ios_base.h:41,
							      								    								  		    from /usr/include/c++/8/ios:42,
							      								    								  		   from /usr/include/c++/8/ostream:3
							      								    								  8,		      from /usr/include/c++/8/iostre
							      								    								  am:39,		  from NTH_EVEN_LENGTH_PALIN
							      								    								  DROME.cpp:8: /usr/include/c++/8/ext/new_allocator.
							      								    								  h:155:5: note: candidate: ‘template<class _Tp> boo
							      								    								  l __gnu_cxx::operator==(const __gnu_cxx::new_alloc
							      								    								  ator<_Tp>&, const __gnu_cxx::new_allocator<_Tp>&)’
							      								    								  	operator==(const new_allocator<_Tp>&, const
							      								    								  new_allocator<_Tp>&)	    ^~~~~~~~ /usr/include/c+
							      								    								  +/8/ext/new_allocator.h:155:5: note:	 template ar
							      								    								  gument deduction/substitution failed: NTH_EVEN_LEN
							      								    								  GTH_PALINDROME.cpp:39:51: note:   mismatched types
							      								    								   ‘const __gnu_cxx::new_allocator<_Tp>’ and ‘int’
							      								    								  	  if(f_filled(param0[i]) == f_gold(param0[i]
							      								    								  ))
							      								    								      ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER		      FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER			    FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER			  FIND_SUM_MODULO_K_FIRST_N_NATURAL_NUMBER
--							      --							    --								  --
def findSum ( N , K ) :					      int findSum ( int N , int K ) {				    int findSum ( int N , int K ) {				  success : identical to gold
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  
    for i in range ( 1 , N + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	ans += ( i % K )				      	i <= N ;						      i <= N ;							  
    return ans						      	i ++ ) ans += ( i % K ) ;				      i ++ ) ans += ( i % K ) ;					  
							      	return ans ;						      return ans ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIME_NUMBERS						      PRIME_NUMBERS						    PRIME_NUMBERS						  PRIME_NUMBERS
--							      --							    --								  --
def isPrime ( n ) :					      bool isPrime ( int n ) {					    bool isPrime ( int n ) {					  success : None
    if ( n <= 1 ) :					      	if ( n <= 1 ) return false ;				      if ( ( n <= 1 ) ) return false ;				  
	return False					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
    for i in range ( 2 , n ) :				      	i < n ;							      i < n ;							  
	if ( n % i == 0 ) :				      	i ++ ) if ( n % i == 0 ) return false ;			      i ++ ) if ( ( n % i ) == 0 ) return false ;		  
	    return False				      	return true ;						      return true ;						  
    return True						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE CHECK_IF_STRING_REMAINS_PALINDROME_AFTER_REMOVING_GIVEN_NUMBE
--							      --							    --								  --
def isPossible ( str , n ) :				      bool isPossible ( string str , int n ) {			    bool isPossible ( string str , int n ) {			  failure : #Results: 6, 10
    l = len ( str )					      	int len = str . length ( ) ;				      int l = str . length ( ) ;				  
    if ( l >= n ) :					      	if ( len >= n ) return true ;				      if ( ( l >= n ) && ( l < n ) ) return true ;		  
	return True					      	return false ;						      return false ;						  
    return False					      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSION						      RECURSION							    RECURSION							  RECURSION
--							      --							    --								  --
def printFun ( test ) :					      void printFun ( int test ) {				    int printFun ( int test ) {					  script_not_found : None
    if ( test < 1 ) :					      	if ( test < 1 ) return ;				      if ( ( test < 1 ) ) return test ;				  
	return						      	else {							      else {							  
    else :						      	  cout << test << " " ;					    	cout << test << " " ;					  
	print ( test , end = " " )			      	  printFun ( test - 1 ) ;				    	printFun ( test - 1 ) ;					  
	printFun ( test - 1 )				      	  cout << test << " " ;					    	cout << test << " " ;					  
	print ( test , end = " " )			      	  return ;						    	return test ;						  
	return						      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_CONWAY_SEQUENCE					      NEWMAN_CONWAY_SEQUENCE					    NEWMAN_CONWAY_SEQUENCE					  NEWMAN_CONWAY_SEQUENCE
--							      --							    --								  --
def sequence ( n ) :					      int sequence ( int n ) {					    int sequence ( int n ) {					  script_not_found : None
    if n == 1 or n == 2 :				      	if ( n == 1 || n == 2 ) return 1 ;			      if ( n == 1 || n == 2 ) return 1 ;			  
	return 1					      	else return sequence ( sequence ( n - 1 ) ) + sequence ( n    else return sequence ( sequence ( n - 1 ) ) + sequence ( n  
    else :						      }								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
	return sequence ( sequence ( n - 1 ) ) + sequence ( n 								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2_1					      NEXT_POWER_OF_2_1						    NEXT_POWER_OF_2_1						  NEXT_POWER_OF_2_1
--							      --							    --								  --
def nextPowerOf2 ( n ) :				      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
    p = 1						      	unsigned int p = 1 ;					      int p = 1 ;						  
    if ( n and not ( n & ( n - 1 ) ) ) :		      	if ( n && ! ( n & ( n - 1 ) ) ) return n ;		      if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) return n ;	  
	return n					      	while ( p < n ) p <<= 1 ;				      while ( ( p < n ) ) p <<= 1 ;				  
    while ( p < n ) :					      	return p ;						      return p ;						  
	p <<= 1						      }								    }								  
    return p						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEONARDO_NUMBER						      LEONARDO_NUMBER						    LEONARDO_NUMBER						  LEONARDO_NUMBER
--							      --							    --								  --
def leonardo ( n ) :					      int leonardo ( int n ) {					    int leonardo ( int n ) {					  script_not_found : None
    if ( n == 0 or n == 1 ) :				      	if ( n == 0 || n == 1 ) return 1 ;			      if ( ( n == 0 ) || ( n == 1 ) ) return 1 ;		  
	return 1					      	return leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ;	      return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ;	  
    return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 )    }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2_2					      NEXT_POWER_OF_2_2						    NEXT_POWER_OF_2_2						  NEXT_POWER_OF_2_2
--							      --							    --								  --
def nextPowerOf2 ( n ) :				      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
    n -= 1						      	n -- ;							      n -- ;							  
    n |= n >> 1						      	n |= n >> 1 ;						      n |= n >> 1 ;						  
    n |= n >> 2						      	n |= n >> 2 ;						      n |= n >> 2 ;						  
    n |= n >> 4						      	n |= n >> 4 ;						      n |= n >> 4 ;						  
    n |= n >> 8						      	n |= n >> 8 ;						      n |= n >> 8 ;						  
    n |= n >> 16					      	n |= n >> 16 ;						      n |= n >> 16 ;						  
    n += 1						      	n ++ ;							      n ++ ;							  
    return n						      	return n ;						      return n ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_VOLUME_DODECAHEDRON				      CALCULATE_VOLUME_DODECAHEDRON				    CALCULATE_VOLUME_DODECAHEDRON				  CALCULATE_VOLUME_DODECAHEDRON
--							      --							    --								  --
def vol_of_dodecahedron ( side ) :			      double vol_of_dodecahedron ( int side ) {			    double volOfDodecahedron ( double side ) {			  success : None
    return ( ( ( 15 + ( 7 * ( math.sqrt ( 5 ) ) ) ) / 4 ) * ( 	return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow (    return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow (  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_POWER_PRIME_NUMBER_P_N				      FINDING_POWER_PRIME_NUMBER_P_N				    FINDING_POWER_PRIME_NUMBER_P_N				  FINDING_POWER_PRIME_NUMBER_P_N
--							      --							    --								  --
def PowerOFPINnfactorial ( n , p ) :			      int PowerOFPINnfactorial ( int n , int p ) {		    double PowerOFPINnfactorial ( double n , double p ) {	  failure : #Results: 2, 10
    ans = 0						      	int ans = 0 ;						      double ans = 0 ;						  
    temp = p						      	int temp = p ;						      double temp = p ;						  
    while ( temp <= n ) :				      	while ( temp <= n ) {					      while ( ( temp <= n ) && ( temp > n ) ) {			  
	ans += n / temp					      	  ans += n / temp ;					    	ans += n / temp ;					  
	temp = temp * p					      	  temp = temp * p ;					    	temp = temp * p ;					  
    return ans						      	}							      }								  
							      	return ans ;						      return ans ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		      COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		    COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ		  COUNT_FREQUENCY_K_MATRIX_SIZE_N_MATRIXI_J_IJ
--							      --							    --								  --
def find ( n , k ) :					      int find ( int n , int k ) {				    int find ( int n , int k ) {				  success : None
    if ( n + 1 >= k ) :					      	if ( n + 1 >= k ) return ( k - 1 ) ;			      if ( ( n + 1 ) >= k ) return ( k - 1 ) ;			  
	return ( k - 1 )				      	else return ( 2 * n + 1 - k ) ;				      else return ( 2 * n + 1 - k ) ;				  
    else :						      }								    }								  
	return ( 2 * n + 1 - k )			      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2	  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_2
--							      --							    --								  --
def isPowerOfFour ( n ) :				      bool isPowerOfFour ( unsigned int n ) {			    bool isPowerOfFour ( int n ) {				  success : None
    return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not (  	return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAA   return ( n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0x 
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_SHANKS_WILLIAMS_PRIME				      NEWMAN_SHANKS_WILLIAMS_PRIME				    NEWMAN_SHANKS_WILLIAMS_PRIME				  NEWMAN_SHANKS_WILLIAMS_PRIME
--							      --							    --								  --
def nswp ( n ) :					      int nswp ( int n ) {					    int nswp ( int n ) {					  script_not_found : None
    if n == 0 or n == 1 :				      	if ( n == 0 || n == 1 ) return 1 ;			      if ( n == 0 || n == 1 ) return 1 ;			  
	return 1					      	return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ;		      return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ;		  
    return 2 * nswp ( n - 1 ) + nswp ( n - 2 )		      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			      COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			    COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER			  COUNT_TRAILING_ZEROES_FACTORIAL_NUMBER
--							      --							    --								  --
def findTrailingZeros ( n ) :				      int findTrailingZeros ( int n ) {				    int findTrailingZeros ( double n ) {			  success : None
    count = 0						      	int count = 0 ;						      double count = 0 ;					  
    i = 5						      	for ( int i = 5 ;					      double i = 5 ;						  
    while ( n / i >= 1 ) :				      	n / i >= 1 ;						      while ( ( n / i ) >= 1 ) {				  
	count += int ( n / i )				      	i *= 5 ) count += n / i ;				    	count += ( int ) ( n / i ) ;				  
	i *= 5						      	return count ;						    	i *= 5 ;						  
    return int ( count )				      }								      }								  
							      								      return ( int ) count ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MISSING_NUMBER					      FIND_THE_MISSING_NUMBER					    FIND_THE_MISSING_NUMBER					  FIND_THE_MISSING_NUMBER
--							      --							    --								  --
def getMissingNo ( A ) :				      int getMissingNo ( int a [ ] , int n ) {			    double getMissingNo ( string A ) {				  script_not_found : None
    n = len ( A )					      	int total = ( n + 1 ) * ( n + 2 ) / 2 ;			      int n = A . length ( ) ;					  
    total = ( n + 1 ) * ( n + 2 ) / 2			      	for ( int i = 0 ;					      double total = ( n + 1 ) * ( n + 2 ) / 2 ;		  
    sum_of_A = sum ( A )				      	i < n ;							      double sumOfA = A . length ( ) ;				  
    return total - sum_of_A				      	i ++ ) total -= a [ i ] ;				      return total - sumOfA ;					  
							      	return total ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTS_PATHS_POINT_REACH_ORIGIN				      COUNTS_PATHS_POINT_REACH_ORIGIN				    COUNTS_PATHS_POINT_REACH_ORIGIN				  COUNTS_PATHS_POINT_REACH_ORIGIN
--							      --							    --								  --
def countPaths ( n , m ) :				      int countPaths ( int n , int m ) {			    int countPaths ( int n , int m ) {				  script_not_found : None
    if ( n == 0 or m == 0 ) :				      	if ( n == 0 || m == 0 ) return 1 ;			      if ( ( n == 0 ) || ( m == 0 ) ) return 1 ;		  
	return 1					      	return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1    return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1  
    return ( countPaths ( n - 1 , m ) + countPaths ( n , m -  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2     GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2	    GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2	  GIVEN_P_AND_N_FIND_THE_LARGEST_X_SUCH_THAT_PX_DIVIDES_N_2
--							      --							    --								  --
def largestPower ( n , p ) :				      int largestPower ( int n , int p ) {			    double largestPower ( double n , double p ) {		  script_not_found : None
    x = 0						      	int x = 0 ;						      double x = 0 ;						  
    while n :						      	while ( n ) {						      while ( n ) {						  
	n /= p						      	  n /= p ;						    	n /= p ;						  
	x += n						      	  x += n ;						    	x += n ;						  
    return x						      	}							      }								  
							      	return x ;						      return x ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		      CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		    CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN		  CHECK_WHETHER_TRIANGLE_VALID_NOT_SIDES_GIVEN
--							      --							    --								  --
def checkValidity ( a , b , c ) :			      bool checkValidity ( int a , int b , int c ) {		    bool checkValidity ( double a , double b , double c ) {	  success : None
    if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) :   	if ( a + b <= c || a + c <= b || b + c <= a ) return false    if ( ( a + b <= c ) || ( a + c <= b ) || ( b + c <= a ) ) r 
	return False					      	else return true ;					      else return true ;					  
    else :						      }								    }								  
	return True					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY	      QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY		    QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY		  QUICKLY_FIND_MULTIPLE_LEFT_ROTATIONS_OF_AN_ARRAY
--							      --							    --								  --
def leftRotate ( arr , n , k ) :			      void leftRotate ( int arr [ ] , int n , int k ) {		    int leftRotate ( int * arr , int n , int k ) {		  script_not_found : None
    for i in range ( k , k + n ) :			      	for ( int i = k ;					      for ( int i = k ;						  
	print ( str ( arr [ i % n ] ) , end = " " )	      	i < k + n ;						      i < k + n ;						  
							      	i ++ ) cout << arr [ i % n ] << " " ;			      i ++ ) cout << arr [ i % n ] << " " ;			  
							      }								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LAST_INDEX_CHARACTER_STRING			      FIND_LAST_INDEX_CHARACTER_STRING				    FIND_LAST_INDEX_CHARACTER_STRING				  FIND_LAST_INDEX_CHARACTER_STRING
--							      --							    --								  --
def findLastIndex ( str , x ) :				      int findLastIndex ( string & str , char x ) {		    int findLastIndex ( string str , char x ) {			  script_not_found : None
    index = - 1						      	int index = - 1 ;					      int index = - 1 ;						  
    for i in range ( 0 , len ( str ) ) :		      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if str [ i ] == x :				      	i < str . length ( ) ;					      i != str . length ( ) ;					  
	    index = i					      	i ++ ) if ( str [ i ] == x ) index = i ;		      i ++ ) {							  
    return index					      	return index ;						    	if ( str [ i ] == x ) index = i ;			  
							      }								      }								  
							      								      return index ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_POWER_PRIME_NUMBER_P_N_1			      FINDING_POWER_PRIME_NUMBER_P_N_1				    FINDING_POWER_PRIME_NUMBER_P_N_1				  FINDING_POWER_PRIME_NUMBER_P_N_1
--							      --							    --								  --
def PowerOFPINnfactorial ( n , p ) :			      int PowerOFPINnfactorial ( int n , int p ) {		    int PowerOFPINnfactorial ( int n , int p ) {		  failure : #Results: 5, 10
    ans = 0						      	int ans = 0 ;						      double ans = 0 ;						  
    temp = p						      	int temp = p ;						      double temp = p ;						  
    while ( temp <= n ) :				      	while ( temp <= n ) {					      while ( ( temp <= n ) && ( temp > n ) ) {			  
	ans += n / temp					      	  ans += n / temp ;					    	ans += n / temp ;					  
	temp = temp * p					      	  temp = temp * p ;					    	temp = temp * p ;					  
    return int ( ans )					      	}							      }								  
							      	return ans ;						      return ( int ) ans ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LAST_INDEX_CHARACTER_STRING_1			      FIND_LAST_INDEX_CHARACTER_STRING_1			    FIND_LAST_INDEX_CHARACTER_STRING_1				  FIND_LAST_INDEX_CHARACTER_STRING_1
--							      --							    --								  --
def findLastIndex ( str , x ) :				      int findLastIndex ( string & str , char x ) {		    int findLastIndex ( string str , char x ) {			  script_not_found : None
    for i in range ( len ( str ) - 1 , - 1 , - 1 ) :	      	for ( int i = str . length ( ) - 1 ;			      for ( int i = str . length ( ) - 1 ;			  
	if ( str [ i ] == x ) :				      	i >= 0 ;						      i >= 0 ;							  
	    return i					      	i -- ) if ( str [ i ] == x ) return i ;			      i -- ) {							  
    return - 1						      	return - 1 ;						    	if ( ( str [ i ] == x ) ) return i ;			  
							      }								      }								  
							      								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP   HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP   HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP	  HOW_WILL_YOU_PRINT_NUMBERS_FROM_1_TO_200_WITHOUT_USING_LOOP
--							      --							    --								  --
def printNos ( n ) :					      public : void printNos ( unsigned int n ) {		    void printNos ( int n ) {					  script_not_found : None
    if n > 0 :						      	if ( n > 0 ) {						      if ( n > 0 ) {						  
	printNos ( n - 1 )				      	  printNos ( n - 1 ) ;					    	printNos ( n - 1 ) ;					  
	print ( n , end = ' ' )				      	  cout << n << " " ;					    	cout << n << " " ;					  
							      	}							      }								  
							      	return ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY		      FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY			    FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY			  FIND_ELEMENTS_LARGER_HALF_ELEMENTS_ARRAY
--							      --							    --								  --
def findLarger ( arr , n ) :				      void findLarger ( int arr [ ] , int n ) {			    int findLarger ( int * arr , int n ) {			  script_not_found : None
    x = sorted ( arr )					      	sort ( arr , arr + n ) ;				      int * p = arr ;						  
    for i in range ( n / 2 , n ) :			      	for ( int i = n - 1 ;					      for ( int i = n / 2 ;					  
	print ( x [ i ] ) ,				      	i >= n / 2 ;						      i < n ;							  
							      	i -- ) cout << arr [ i ] << " " ;			      i ++ ) cout << p [ i ] << endl ;				  
							      }								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE	      SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE		    SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE		  SWAP_TWO_NUMBERS_WITHOUT_USING_TEMPORARY_VARIABLE
--							      --							    --								  --
def swap ( xp , yp ) :					      void swap ( int * xp , int * yp ) {			    void swap ( int * xp , int * yp ) {				  script_not_found : None
    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]			      	* xp = * xp ^ * yp ;					      xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;				  
    yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]			      	* yp = * xp ^ * yp ;					      yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;				  
    xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ]			      	* xp = * xp ^ * yp ;					      xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N			      FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N			    FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N				  FIND_FACTORIAL_NUMBERS_LESS_EQUAL_N
--							      --							    --								  --
def printFactorialNums ( n ) :				      void printFactorialNums ( int n ) {			    void printFactorialNums ( int n ) {				  script_not_found : None
    fact = 1						      	int fact = 1 ;						      int fact = 1 ;						  
    x = 2						      	int x = 2 ;						      int x = 2 ;						  
    while fact <= n :					      	while ( fact <= n ) {					      while ( fact <= n ) {					  
	print ( fact , end = " " )			      	  cout << fact << " " ;					    	cout << fact << " " ;					  
	fact = fact * x					      	  fact = fact * x ;					    	fact = fact * x ;					  
	x += 1						      	  x ++ ;						    	x ++ ;							  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MISSING_NUMBER_1				      FIND_THE_MISSING_NUMBER_1					    FIND_THE_MISSING_NUMBER_1					  FIND_THE_MISSING_NUMBER_1
--							      --							    --								  --
def getMissingNo ( a , n ) :				      int getMissingNo ( int a [ ] , int n ) {			    int getMissingNo ( int a [ ] , int n ) {			  failure : #Results: 0, 10
    i , total = 0 , 1					      	int i , total = 1 ;					      int i , total = 0 ;					  
    for i in range ( 2 , n + 2 ) :			      	for ( i = 2 ;						      for ( i = 2 ;						  
	total += i					      	i <= ( n + 1 ) ;					      i <= n ;							  
	total -= a [ i - 2 ]				      	i ++ ) {						      i ++ ) {							  
    return total					      	  total += i ;						    	total += i ;						  
							      	  total -= a [ i - 2 ] ;				    	total -= a [ i - 2 ] ;					  
							      	}							      }								  
							      	return total ;						      return total ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX
--							      --							    --								  --
def numberOfPaths ( m , n ) :				      int numberOfPaths ( int m , int n ) {			    int numberOfPaths ( int m , int n ) {			  script_not_found : None
    if ( m == 1 or n == 1 ) :				      	if ( m == 1 || n == 1 ) return 1 ;			      if ( ( m == 1 || n == 1 ) ) return 1 ;			  
	return 1					      	return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n    return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n  
    return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m ,  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		      PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		    PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING		  PROGRAM_COUNT_OCCURRENCE_GIVEN_CHARACTER_STRING
--							      --							    --								  --
def count ( s , c ) :					      int count ( string s , char c ) {				    int count ( string s , char c ) {				  success : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    for i in range ( len ( s ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( s [ i ] == c ) :				      	i < s . length ( ) ;					      i < s . length ( ) ;					  
	    res = res + 1				      	i ++ ) if ( s [ i ] == c ) res ++ ;			      i ++ ) if ( ( s [ i ] == c ) ) res = res + 1 ;		  
    return res						      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1		      MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1			    MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1			  MAXIMIZE_VOLUME_CUBOID_GIVEN_SUM_SIDES_1
--							      --							    --								  --
def maxvolume ( s ) :					      int maxvolume ( int s ) {					    int maxvolume ( double s ) {				  failure : #Results: 9, 10
    length = int ( s / 3 )				      	int length = s / 3 ;					      int length = ( int ) ( s / 3 ) ;				  
    s -= length						      	s -= length ;						      s -= length ;						  
    breadth = s / 2					      	int breadth = s / 2 ;					      double breadth = s / 2 ;					  
    height = s - breadth				      	int height = s - breadth ;				      double height = s - breadth ;				  
    return int ( length * breadth * height )		      	return length * breadth * height ;			      return ( int ) ( length * breadth * height ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HORNERS_METHOD_POLYNOMIAL_EVALUATION			      HORNERS_METHOD_POLYNOMIAL_EVALUATION			    HORNERS_METHOD_POLYNOMIAL_EVALUATION			  HORNERS_METHOD_POLYNOMIAL_EVALUATION
--							      --							    --								  --
def horner ( poly , n , x ) :				      int horner ( int poly [ ] , int n , int x ) {		    double horner ( double * poly , int n , double x ) {	  error : HORNERS_METHOD_POLYNOMIAL_EVALUATION.cpp:
    result = poly [ 0 ]					      	int result = poly [ 0 ] ;				      double result = poly [ 0 ] ;				  In function ‘int main()’: HORNERS_METHOD_POLYNOMIA
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  L_EVALUATION.cpp:41:21: error: cannot convert ‘__g
	result = result * x + poly [ i ]		      	i < n ;							      i < n ;							  nu_cxx::__alloc_traits<std::allocator<int>, int>::
    return result					      	i ++ ) result = result * x + poly [ i ] ;		      i ++ ) result = result * x + poly [ i ] ;			  value_type*’ {aka ‘int*’} to ‘double*’	  if
							      	return result ;						      return result ;						  (f_filled(&param0[i].front(),param1[i],param2[i])
							      }								    }								  == f_gold(&param0[i].front(),param1[i],param2[i]))
							      								    								  			^~~~~~~~~~~~~~~~~~ HORNERS_M
							      								    								  ETHOD_POLYNOMIAL_EVALUATION.cpp:25:28: note:	 ini
							      								    								  tializing argument 1 of ‘double f_filled(double*,
							      								    								  int, double)’	 double f_filled ( double * poly , i
							      								    								  nt n , double x ) {			 ~~~~~~~~~^~
							      								    								  ~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1			      NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1			    NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1				  NUMBER_DIGITS_PRODUCT_TWO_NUMBERS_1
--							      --							    --								  --
def countDigits ( a , b ) :				      int countDigits ( int a , int b ) {			    int countDigits ( int a , int b ) {				  success : None
    if ( a == 0 or b == 0 ) :				      	if ( a == 0 || b == 0 ) return 1 ;			      if ( ( a == 0 ) || ( b == 0 ) ) return 1 ;		  
	return 1					      	return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) )    return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) )  
    return math.floor ( math.log10 ( abs ( a ) ) + math.log10 }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUICK_WAY_CHECK_CHARACTERS_STRING			      QUICK_WAY_CHECK_CHARACTERS_STRING				    QUICK_WAY_CHECK_CHARACTERS_STRING				  QUICK_WAY_CHECK_CHARACTERS_STRING
--							      --							    --								  --
def allCharactersSame ( s ) :				      bool allCharactersSame ( string s ) {			    bool allCharactersSame ( string s ) {			  success : None
    n = len ( s )					      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	if s [ i ] != s [ 0 ] :				      	i < n ;							      i < n ;							  
	    return False				      	i ++ ) if ( s [ i ] != s [ 0 ] ) return false ;		      i ++ ) {							  
    return True						      	return true ;						    	if ( s [ i ] != s [ 0 ] ) return false ;		  
							      }								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		      CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		    CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1		  CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER_1
--							      --							    --								  --
def isPower ( x , y ) :					      bool isPower ( int x , int y ) {				    int isPower ( double x , double y ) {			  failure : #Results: 4, 10
    res1 = math.log ( y ) / math.log ( x )		      	int res1 = log ( y ) / log ( x ) ;			      double res1 = log ( y ) / log ( x ) ;			  
    res2 = math.log ( y ) / math.log ( x )		      	double res2 = log ( y ) / log ( x ) ;			      double res2 = log ( y ) / log ( x ) ;			  
    return 1 if ( res1 == res2 ) else 0			      	return ( res1 == res2 ) ;				      return ( res1 == res2 ) ? 1 : 0 ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			      MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			    MULTIPLICATIVE_INVERSE_UNDER_MODULO_M			  MULTIPLICATIVE_INVERSE_UNDER_MODULO_M
--							      --							    --								  --
def modInverse ( a , m ) :				      int modInverse ( int a , int m ) {			    int modInverse ( int a , int m ) {				  script_not_found : None
    a = a % m						      	a = a % m ;						      a = a % m ;						  
    for x in range ( 1 , m ) :				      	for ( int x = 1 ;					      for ( int x = 1 ;						  
	if ( ( a * x ) % m == 1 ) :			      	x < m ;							      x < m ;							  
	    return x					      	x ++ ) if ( ( a * x ) % m == 1 ) return x ;		      x ++ ) if ( ( ( a * x ) % m ) == 1 ) return x ;		  
    return 1						      }								      return 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DOUBLE_FACTORIAL_1					      DOUBLE_FACTORIAL_1					    DOUBLE_FACTORIAL_1						  DOUBLE_FACTORIAL_1
--							      --							    --								  --
def doublefactorial ( n ) :				      unsigned int doublefactorial ( unsigned int n ) {		    int doublefactorial ( int n ) {				  failure : #Results: 5, 10
    res = 1						      	int res = 1 ;						      int res = 1 ;						  
    for i in range ( n , - 1 , - 2 ) :			      	for ( int i = n ;					      for ( int i = n ;						  
	if ( i == 0 or i == 1 ) :			      	i >= 0 ;						      i >= 0 ;							  
	    return res					      	i = i - 2 ) {						      i -- ) {							  
	else :						      	  if ( i == 0 || i == 1 ) return res ;			    	if ( ( i == 0 || i == 1 ) ) return res ;		  
	    res *= i					      	  else res *= i ;					    	else res *= i ;						  
							      	}							      }								  
							      }								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER		      FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER		    FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER			  FIND_CENTER_CIRCLE_USING_ENDPOINTS_DIAMETER
--							      --							    --								  --
def center ( x1 , x2 , y1 , y2 ) :			      void center ( int x1 , int x2 , int y1 , int y2 ) {	    void center ( double x1 , double x2 , double y1 , double y2 ) script_not_found : None
    print ( int ( ( x1 + x2 ) / 2 ) , end = "" )	      	cout << ( float ) ( x1 + x2 ) / 2 << ", " << ( float ) ( y1   cout << setprecision ( 5 ) << ( int ) ( ( x1 + x2 ) / 2 ) < 
    print ( "," , int ( ( y1 + y2 ) / 2 ) )		      }								      cout << "," << ( int ) ( ( y1 + y2 ) / 2 ) << " " ;	  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_EFFICIENTLY_CALCULATE_EX			      PROGRAM_TO_EFFICIENTLY_CALCULATE_EX			    PROGRAM_TO_EFFICIENTLY_CALCULATE_EX				  PROGRAM_TO_EFFICIENTLY_CALCULATE_EX
--							      --							    --								  --
def exponential ( n , x ) :				      float exponential ( int n , float x ) {			    double exponential ( int n , double x ) {			  script_not_found : None
    sum = 1.0						      	float sum = 1.0f ;					      double sum = 1.0 ;					  
    for i in range ( n , 0 , - 1 ) :			      	for ( int i = n - 1 ;					      for ( int i = n ;						  
	sum = 1 + x * sum / i				      	i > 0 ;							      i > 0 ;							  
    print ( "e^x =" , sum )				      	-- i ) sum = 1 + x * sum / i ;				      i -- ) sum = 1 + x * sum / i ;				  
							      	return sum ;						      cout << "e^x =" << sum << endl ;				  
							      }								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			      C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			    C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY			  C_PROGRAM_FIND_LARGEST_ELEMENT_ARRAY
--							      --							    --								  --
def largest ( arr , n ) :				      int largest ( int arr [ ] , int n ) {			    int largest ( int * arr , int n ) {				  script_not_found : None
    max = arr [ 0 ]					      	int i ;							      int max = arr [ 0 ] ;					  
    for i in range ( 1 , n ) :				      	int max = arr [ 0 ] ;					      for ( int i = 1 ;						  
	if arr [ i ] > max :				      	for ( i = 1 ;						      i < n ;							  
	    max = arr [ i ]				      	i < n ;							      i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;		  
    return max						      	i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;		      return max ;						  
							      	return max ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_POWER_OF_2						      NEXT_POWER_OF_2						    NEXT_POWER_OF_2						  NEXT_POWER_OF_2
--							      --							    --								  --
def nextPowerOf2 ( n ) :				      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
    count = 0						      	unsigned count = 0 ;					      int count = 0 ;						  
    if ( n and not ( n & ( n - 1 ) ) ) :		      	if ( n && ! ( n & ( n - 1 ) ) ) return n ;		      if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) return n ;	  
	return n					      	while ( n != 0 ) {					      while ( ( n != 0 ) ) {					  
    while ( n != 0 ) :					      	  n >>= 1 ;						    	n >>= 1 ;						  
	n >>= 1						      	  count += 1 ;						    	count ++ ;						  
	count += 1					      	}							      }								  
    return 1 << count					      	return 1 << count ;					      return 1 << count ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_ROOT_OF_AN_INTEGER				      SQUARE_ROOT_OF_AN_INTEGER					    SQUARE_ROOT_OF_AN_INTEGER					  SQUARE_ROOT_OF_AN_INTEGER
--							      --							    --								  --
def floorSqrt ( x ) :					      int floorSqrt ( int x ) {					    int floorSqrt ( int x ) {					  failure : #Results: 0, 10
    if ( x == 0 or x == 1 ) :				      	if ( x == 0 || x == 1 ) return x ;			      if ( ( x == 0 ) || ( x == 1 ) ) return x ;		  
	return x					      	int i = 1 , result = 1 ;				      int i = 1 ;						  
    i = 1 result = 1					      	while ( result <= x ) {					      int result = 1 ;						  
    while ( result <= x ) :				      	  i ++ ;						      while ( ( result <= x ) && ( result >= x ) ) {		  
	i += 1						      	  result = i * i ;					    	i ++ ;							  
	result = i * i					      	}							    	result = i * i ;					  
    return i - 1					      	return i - 1 ;						      }								  
							      }								      return i - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING		      HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING			    HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING			  HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING
--							      --							    --								  --
def search ( arr , x ) :				      int search ( int arr [ ] , int n , int x ) {		    int search ( string arr , char x ) {			  error : HOW_TO_BEGIN_WITH_COMPETITIVE_PROGRAMMING.
    n = len ( arr )					      	for ( int i = 0 ;					      int n = arr . length ( ) ;				  cpp: In function ‘int main()’: HOW_TO_BEGIN_WITH_C
    for j in range ( 0 , n ) :				      	i < n ;							      for ( int j = 0 ;						  OMPETITIVE_PROGRAMMING.cpp:42:21: error: could not
	if ( x == arr [ j ] ) :				      	i ++ ) {						      j != n ;							   convert ‘&(& param0.std::vector<std::vector<int>
	    return j					      	  if ( arr [ i ] == x ) return i ;			      j ++ ) if ( ( x == arr [ j ] ) ) return j ;		  >::operator[](((std::vector<std::vector<int> >::si
    return - 1						      	}							      return - 1 ;						  ze_type)i)))->std::vector<int>::front()’ from ‘__g
							      	return - 1 ;						    }								  nu_cxx::__alloc_traits<std::allocator<int>, int>::
							      }								    								  value_type*’ {aka ‘int*’} to ‘std::__cxx11::string
							      								    								  ’ {aka ‘std::__cxx11::basic_string<char>’}
							      								    								    if(f_filled(&param0[i].front(),param1[i],param2[
							      								    								  i]) == f_gold(&param0[i].front(),param1[i],param2[
							      								    								  i]))			    ^~~~~~~~~~~~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		      CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		    CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER		  CHECK_IF_A_NUMBER_IS_POWER_OF_ANOTHER_NUMBER
--							      --							    --								  --
def isPower ( x , y ) :					      bool isPower ( int x , long int y ) {			    bool isPower ( int x , int y ) {				  success : None
    if ( x == 1 ) :					      	if ( x == 1 ) return ( y == 1 ) ;			      if ( ( x == 1 ) ) return ( y == 1 ) ;			  
	return ( y == 1 )				      	long int pow = 1 ;					      int pow = 1 ;						  
    pow = 1						      	while ( pow < y ) pow *= x ;				      while ( ( pow < y ) ) pow = pow * x ;			  
    while ( pow < y ) :					      	return ( pow == y ) ;					      return ( pow == y ) ;					  
	pow = pow * x					      }								    }								  
    return ( pow == y )					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS			      SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS			    SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS				  SUM_K_TH_GROUP_ODD_POSITIVE_NUMBERS
--							      --							    --								  --
def kthgroupsum ( k ) :					      int kthgroupsum ( int k ) {				    int kthgroupsum ( int k ) {					  success : None
    cur = int ( ( k * ( k - 1 ) ) + 1 )			      	int cur = ( k * ( k - 1 ) ) + 1 ;			      int cur = ( int ) ( ( k * ( k - 1 ) ) + 1 ) ;		  
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    while k :						      	while ( k -- ) {					      while ( k ) {						  
	sum += cur					      	  sum += cur ;						    	sum += cur ;						  
	cur += 2					      	  cur += 2 ;						    	cur += 2 ;						  
	k = k - 1					      	}							    	k = k - 1 ;						  
    return sum						      	return sum ;						      }								  
							      }								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SERIES_12_32_52_2N_12				      SUM_SERIES_12_32_52_2N_12					    SUM_SERIES_12_32_52_2N_12					  SUM_SERIES_12_32_52_2N_12
--							      --							    --								  --
def sumOfSeries ( n ) :					      int sumOfSeries ( int n ) {				    int sumOfSeries ( int n ) {					  success : identical to gold
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 )	      	i <= n ;						      i <= n ;							  
    return sum						      	i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ;	      i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ;	  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_20				      CHECK_LARGE_NUMBER_DIVISIBLE_20				    CHECK_LARGE_NUMBER_DIVISIBLE_20				  CHECK_LARGE_NUMBER_DIVISIBLE_20
--							      --							    --								  --
def divisibleBy20 ( num ) :				      bool divisibleBy20 ( string num ) {			    bool divisibleBy20 ( string num ) {				  script_not_found : None
    lastTwoDigits = int ( num [ - 2 : ] )		      	int lastTwoDigits = stoi ( num . substr ( num . length ( )    int lastTwoDigits = atoi ( num . substr ( num . length ( )  
    return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 = 	return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4    return ( ( lastTwoDigits % 5 == 0 && lastTwoDigits % 4 == 0 
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_ROOT_OF_A_PERFECT_SQUARE				      SQUARE_ROOT_OF_A_PERFECT_SQUARE				    SQUARE_ROOT_OF_A_PERFECT_SQUARE				  SQUARE_ROOT_OF_A_PERFECT_SQUARE
--							      --							    --								  --
def squareRoot ( n ) :					      public : float squareRoot ( float n ) {			    double squareRoot ( double n ) {				  script_not_found : None
    x = n						      	float x = n ;						      double x = n ;						  
    y = 1						      	float y = 1 ;						      double y = 1 ;						  
    e = 0.000001					      	float e = 0.000001 ;					      double e = 0.000001 ;					  
    while ( x - y > e ) :				      	while ( x - y > e ) {					      while ( ( x - y > e ) ) {					  
	x = ( x + y ) / 2				      	  x = ( x + y ) / 2 ;					    	x = ( x + y ) / 2 ;					  
	y = n / x					      	  y = n / x ;						    	y = n / x ;						  
    return x						      	}							      }								  
							      	return x ;						      return x ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS					      SUM_PAIRWISE_PRODUCTS					    SUM_PAIRWISE_PRODUCTS					  SUM_PAIRWISE_PRODUCTS
--							      --							    --								  --
def findSum ( n ) :					      long long int findSum ( int n ) {				    int findSum ( int n ) {					  success : None
    sm = 0						      	long long int sum = 0 ;					      int sm = 0 ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	for j in range ( i , n + 1 ) :			      	i <= n ;						      i <= n ;							  
	    sm = sm + i * j				      	i ++ ) for ( int j = i ;				      i ++ ) {							  
    return sm						      	j <= n ;						    	for ( int j = i ;					  
							      	j ++ ) sum = sum + i * j ;				    	j <= n ;						  
							      	return sum ;						    	j ++ ) sm = sm + i * j ;				  
							      }								      }								  
							      								      return sm ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GAME_REPLACING_ARRAY_ELEMENTS				      GAME_REPLACING_ARRAY_ELEMENTS				    GAME_REPLACING_ARRAY_ELEMENTS				  GAME_REPLACING_ARRAY_ELEMENTS
--							      --							    --								  --
def playGame ( arr , n ) :				      int playGame ( int arr [ ] , int n ) {			    int playGame ( int * arr , int n ) {			  script_not_found : None
    s = set ( )						      	unordered_set < int > hash ;				      set < int > s ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	s.add ( arr [ i ] )				      	i < n ;							      i < n ;							  
    return 1 if len ( s ) % 2 == 0 else 2		      	i ++ ) hash . insert ( arr [ i ] ) ;			      i ++ ) s . insert ( arr [ i ] ) ;				  
							      	return ( hash . size ( ) % 2 == 0 ? 1 : 2 ) ;		      return s . size ( ) % 2 == 0 ? 1 : 2 ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_IS_DIVISIBLE_BY_29_OR_NOT			      NUMBER_IS_DIVISIBLE_BY_29_OR_NOT				    NUMBER_IS_DIVISIBLE_BY_29_OR_NOT				  NUMBER_IS_DIVISIBLE_BY_29_OR_NOT
--							      --							    --								  --
def isDivisible ( n ) :					      bool isDivisible ( long long int n ) {			    bool isDivisible ( long n ) {				  success : None
    while ( int ( n / 100 ) ) :				      	while ( n / 100 ) {					      while ( ( int ) ( n / 100 ) ) {				  
	last_digit = int ( n % 10 )			      	  int last_digit = n % 10 ;				    	int lastDigit = ( int ) ( n % 10 ) ;			  
	n = int ( n / 10 )				      	  n /= 10 ;						    	n = ( long ) ( n / 10 ) ;				  
	n += last_digit * 3				      	  n += last_digit * 3 ;					    	n += lastDigit * 3 ;					  
    return ( n % 29 == 0 )				      	}							      }								  
							      	return ( n % 29 == 0 ) ;				      return ( n % 29 == 0 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE    FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE    FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE	  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE
--							      --							    --								  --
def first ( str ) :					      char first ( string str ) {				    string first ( string str ) {				  error : FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATI
    for i in range ( 0 , len ( str ) ) :		      	for ( int i = 0 ;					      for ( int i = 0 ;						  VE_AND_RECURSIVE.cpp: In function ‘std::__cxx11::s
	if ( str [ i ].istitle ( ) ) :			      	i < str . length ( ) ;					      i != str . length ( ) ;					  tring f_filled(std::__cxx11::string)’: FIRST_UPPER
	    return str [ i ]				      	i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ;	      i ++ ) {							  CASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cp
    return 0						      	return 0 ;						    	if ( ( str [ i ] ) . istitle ( ) ) return str [ i ] ;	  p:28:26: error: request for member ‘istitle’ in ‘s
							      }								      }								  tr.std::__cxx11::basic_string<char>::operator[](((
							      								      return 0 ;						  std::__cxx11::basic_string<char>::size_type)i))’,
							      								    }								  which is of non-class type ‘__gnu_cxx::__alloc_tra
							      								    								  its<std::allocator<char>, char>::value_type’ {aka
							      								    								  ‘char’}      if ( ( str [ i ] ) . istitle ( ) ) re
							      								    								  turn str [ i ] ;			     ^~~~~~~
							      								    								   FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_
							      								    								  RECURSIVE.cpp:28:55: error: could not convert ‘str
							      								    								  .std::__cxx11::basic_string<char>::operator[](((st
							      								    								  d::__cxx11::basic_string<char>::size_type)i))’ fro
							      								    								  m ‘__gnu_cxx::__alloc_traits<std::allocator<char>,
							      								    								   char>::value_type’ {aka ‘char’} to ‘std::__cxx11:
							      								    								  :string’ {aka ‘std::__cxx11::basic_string<char>’}
							      								    								       if ( ( str [ i ] ) . istitle ( ) ) return str
							      								    								   [ i ] ;
							      								    								  		^ FIRST_UPPERCASE_LETTER_IN_A_STRING
							      								    								  _ITERATIVE_AND_RECURSIVE.cpp: In function ‘int mai
							      								    								  n()’: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE
							      								    								  _AND_RECURSIVE.cpp:39:32: error: no match for ‘ope
							      								    								  rator==’ (operand types are ‘std::__cxx11::string’
							      								    								   {aka ‘std::__cxx11::basic_string<char>’} and ‘cha
							      								    								  r’)	       if(f_filled(param0[i]) == f_gold(para
							      								    								  m0[i]))	      ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~
							      								    								  ~~~~~~~~~~ In file included from /usr/include/c++/
							      								    								  8/regex:62,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  	   from FIRST_UPPERCASE_LETTER_IN_A_STRING_I
							      								    								  TERATIVE_AND_RECURSIVE.cpp:14: /usr/include/c++/8/
							      								    								  bits/regex.h:980:5: note: candidate: ‘template<cla
							      								    								  ss _BiIter> bool std::__cxx11::operator==(const st
							      								    								  d::__cxx11::sub_match<_BiIter>&, const std::__cxx1
							      								    								  1::sub_match<_BiIter>&)’	operator==(const sub
							      								    								  _match<_BiIter>& __lhs, const sub_match<_BiIter>&
							      								    								  __rhs)      ^~~~~~~~ /usr/include/c++/8/bits/regex
							      								    								  .h:980:5: note:   template argument deduction/subs
							      								    								  titution failed: FIRST_UPPERCASE_LETTER_IN_A_STRIN
							      								    								  G_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:   ‘std:
							      								    								  :__cxx11::string’ {aka ‘std::__cxx11::basic_string
							      								    								  <char>’} is not derived from ‘const std::__cxx11::
							      								    								  sub_match<_BiIter>’	       if(f_filled(param0[i]
							      								    								  ) == f_gold(param0[i]))
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/regex:62,		       from
							      								    								  /usr/include/c++/8/x86_64-redhat-linux/bits/stdc++
							      								    								  .h:110,		   from FIRST_UPPERCASE_LETT
							      								    								  ER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /us
							      								    								  r/include/c++/8/bits/regex.h:1053:5: note: candida
							      								    								  te: ‘template<class _Bi_iter, class _Ch_traits, cl
							      								    								  ass _Ch_alloc> bool std::__cxx11::operator==(std::
							      								    								  __cxx11::__sub_match_string<_Bi_iter, _Ch_traits,
							      								    								  _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter
							      								    								  >&)’	    operator==(const __sub_match_string<_Bi_
							      								    								  iter, _Ch_traits, _Ch_alloc>& __lhs,	    ^~~~~~~~
							      								    								   /usr/include/c++/8/bits/regex.h:1053:5: note:   t
							      								    								  emplate argument deduction/substitution failed: FI
							      								    								  RST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_REC
							      								    								  URSIVE.cpp:39:51: note:   mismatched types ‘const
							      								    								  std::__cxx11::sub_match<_BiIter>’ and ‘char’
							      								    								      if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  
							      								    								  ^ In file included from /usr/include/c++/8/regex:6
							      								    								  2,		      from /usr/include/c++/8/x86_64
							      								    								  -redhat-linux/bits/stdc++.h:110,
							      								    								  from FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_
							      								    								  AND_RECURSIVE.cpp:14: /usr/include/c++/8/bits/rege
							      								    								  x.h:1133:5: note: candidate: ‘template<class _Bi_i
							      								    								  ter, class _Ch_traits, class _Ch_alloc> bool std::
							      								    								  __cxx11::operator==(const std::__cxx11::sub_match<
							      								    								  _BiIter>&, std::__cxx11::__sub_match_string<_Bi_it
							      								    								  er, _Ch_traits, _Ch_alloc>&)’	     operator==(cons
							      								    								  t sub_match<_Bi_iter>& __lhs,	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/regex.h:1133:5: note:   template
							      								    								   argument deduction/substitution failed: FIRST_UPP
							      								    								  ERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.
							      								    								  cpp:39:51: note:   ‘std::__cxx11::string’ {aka ‘st
							      								    								  d::__cxx11::basic_string<char>’} is not derived fr
							      								    								  om ‘const std::__cxx11::sub_match<_BiIter>’
							      								    								     if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						   ^
							      								    								   In file included from /usr/include/c++/8/regex:62
							      								    								  ,		     from /usr/include/c++/8/x86_64-
							      								    								  redhat-linux/bits/stdc++.h:110,		   f
							      								    								  rom FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_A
							      								    								  ND_RECURSIVE.cpp:14: /usr/include/c++/8/bits/regex
							      								    								  .h:1213:5: note: candidate: ‘template<class _Bi_it
							      								    								  er> bool std::__cxx11::operator==(const typename s
							      								    								  td::iterator_traits<_Iter>::value_type*, const std
							      								    								  ::__cxx11::sub_match<_BiIter>&)’	operator==(t
							      								    								  ypename iterator_traits<_Bi_iter>::value_type cons
							      								    								  t* __lhs,	 ^~~~~~~~ /usr/include/c++/8/bits/re
							      								    								  gex.h:1213:5: note:	template argument deduction/
							      								    								  substitution failed: FIRST_UPPERCASE_LETTER_IN_A_S
							      								    								  TRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:   m
							      								    								  ismatched types ‘const std::__cxx11::sub_match<_Bi
							      								    								  Iter>’ and ‘char’	     if(f_filled(param0[i])
							      								    								  == f_gold(param0[i]))
							      								    								  			 ^ In file included from /us
							      								    								  r/include/c++/8/regex:62,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :110,			 from FIRST_UPPERCASE_LETTER
							      								    								  _IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/
							      								    								  include/c++/8/bits/regex.h:1287:5: note: candidate
							      								    								  : ‘template<class _Bi_iter> bool std::__cxx11::ope
							      								    								  rator==(const std::__cxx11::sub_match<_BiIter>&, c
							      								    								  onst typename std::iterator_traits<_Iter>::value_t
							      								    								  ype*)’      operator==(const sub_match<_Bi_iter>&
							      								    								  __lhs,      ^~~~~~~~ /usr/include/c++/8/bits/regex
							      								    								  .h:1287:5: note:   template argument deduction/sub
							      								    								  stitution failed: FIRST_UPPERCASE_LETTER_IN_A_STRI
							      								    								  NG_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:	‘std
							      								    								  ::__cxx11::string’ {aka ‘std::__cxx11::basic_strin
							      								    								  g<char>’} is not derived from ‘const std::__cxx11:
							      								    								  :sub_match<_BiIter>’		if(f_filled(param0[i
							      								    								  ]) == f_gold(param0[i]))
							      								    								  			    ^ In file included from
							      								    								  /usr/include/c++/8/regex:62,			from
							      								    								   /usr/include/c++/8/x86_64-redhat-linux/bits/stdc+
							      								    								  +.h:110,		    from FIRST_UPPERCASE_LET
							      								    								  TER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /u
							      								    								  sr/include/c++/8/bits/regex.h:1361:5: note: candid
							      								    								  ate: ‘template<class _Bi_iter> bool std::__cxx11::
							      								    								  operator==(const typename std::iterator_traits<_It
							      								    								  er>::value_type&, const std::__cxx11::sub_match<_B
							      								    								  iIter>&)’	 operator==(typename iterator_traits
							      								    								  <_Bi_iter>::value_type const& __lhs,	    ^~~~~~~~
							      								    								   /usr/include/c++/8/bits/regex.h:1361:5: note:   t
							      								    								  emplate argument deduction/substitution failed: FI
							      								    								  RST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_REC
							      								    								  URSIVE.cpp:39:51: note:   mismatched types ‘const
							      								    								  std::__cxx11::sub_match<_BiIter>’ and ‘char’
							      								    								      if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  
							      								    								  ^ In file included from /usr/include/c++/8/regex:6
							      								    								  2,		      from /usr/include/c++/8/x86_64
							      								    								  -redhat-linux/bits/stdc++.h:110,
							      								    								  from FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_
							      								    								  AND_RECURSIVE.cpp:14: /usr/include/c++/8/bits/rege
							      								    								  x.h:1441:5: note: candidate: ‘template<class _Bi_i
							      								    								  ter> bool std::__cxx11::operator==(const std::__cx
							      								    								  x11::sub_match<_BiIter>&, const typename std::iter
							      								    								  ator_traits<_Iter>::value_type&)’	 operator==(
							      								    								  const sub_match<_Bi_iter>& __lhs,	 ^~~~~~~~ /u
							      								    								  sr/include/c++/8/bits/regex.h:1441:5: note:	temp
							      								    								  late argument deduction/substitution failed: FIRST
							      								    								  _UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURS
							      								    								  IVE.cpp:39:51: note:	 ‘std::__cxx11::string’ {aka
							      								    								   ‘std::__cxx11::basic_string<char>’} is not derive
							      								    								  d from ‘const std::__cxx11::sub_match<_BiIter>’
							      								    								  	 if(f_filled(param0[i]) == f_gold(param0[i])
							      								    								  )
							      								    								     ^ In file included from /usr/include/c++/8/rege
							      								    								  x:62,			 from /usr/include/c++/8/x86
							      								    								  _64-redhat-linux/bits/stdc++.h:110,
							      								    								     from FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATI
							      								    								  VE_AND_RECURSIVE.cpp:14: /usr/include/c++/8/bits/r
							      								    								  egex.h:1957:5: note: candidate: ‘template<class _B
							      								    								  i_iter, class _Alloc> bool std::__cxx11::operator=
							      								    								  =(const std::__cxx11::match_results<_BiIter, _Allo
							      								    								  c>&, const std::__cxx11::match_results<_BiIter, _A
							      								    								  lloc>&)’	operator==(const match_results<_Bi_i
							      								    								  ter, _Alloc>& __m1,	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/regex.h:1957:5: note:	  template argument
							      								    								  deduction/substitution failed: FIRST_UPPERCASE_LET
							      								    								  TER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51:
							      								    								   note:   ‘std::__cxx11::string’ {aka ‘std::__cxx11
							      								    								  ::basic_string<char>’} is not derived from ‘const
							      								    								  std::__cxx11::match_results<_BiIter, _Alloc>’
							      								    								       if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  
							      								    								   ^ In file included from /usr/include/c++/8/iosfwd
							      								    								  :40,			from /usr/include/c++/8/ios:
							      								    								  38,		       from /usr/include/c++/8/ostre
							      								    								  am:38,		  from /usr/include/c++/8/io
							      								    								  stream:39,		      from FIRST_UPPERCASE_L
							      								    								  ETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:8: /
							      								    								  usr/include/c++/8/bits/postypes.h:216:5: note: can
							      								    								  didate: ‘template<class _StateT> bool std::operato
							      								    								  r==(const std::fpos<_StateT>&, const std::fpos<_St
							      								    								  ateT>&)’	operator==(const fpos<_StateT>& __lh
							      								    								  s, const fpos<_StateT>& __rhs)      ^~~~~~~~ /usr/
							      								    								  include/c++/8/bits/postypes.h:216:5: note:   templ
							      								    								  ate argument deduction/substitution failed: FIRST_
							      								    								  UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSI
							      								    								  VE.cpp:39:51: note:	‘std::__cxx11::string’ {aka
							      								    								  ‘std::__cxx11::basic_string<char>’} is not derived
							      								    								   from ‘const std::fpos<_StateT>’	    if(f_fil
							      								    								  led(param0[i]) == f_gold(param0[i]))
							      								    								  					^ In file in
							      								    								  cluded from /usr/include/c++/8/bits/stl_algobase.h
							      								    								  :64,			from /usr/include/c++/8/bits
							      								    								  /char_traits.h:39,		      from /usr/incl
							      								    								  ude/c++/8/ios:40,		     from /usr/inclu
							      								    								  de/c++/8/ostream:38,			from /usr/in
							      								    								  clude/c++/8/iostream:39,		    from FIR
							      								    								  ST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECU
							      								    								  RSIVE.cpp:8: /usr/include/c++/8/bits/stl_pair.h:44
							      								    								  8:5: note: candidate: ‘template<class _T1, class _
							      								    								  T2> constexpr bool std::operator==(const std::pair
							      								    								  <_T1, _T2>&, const std::pair<_T1, _T2>&)’	 ope
							      								    								  rator==(const pair<_T1, _T2>& __x, const pair<_T1,
							      								    								   _T2>& __y)	   ^~~~~~~~ /usr/include/c++/8/bits/
							      								    								  stl_pair.h:448:5: note:   template argument deduct
							      								    								  ion/substitution failed: FIRST_UPPERCASE_LETTER_IN
							      								    								  _A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:
							      								    								     ‘std::__cxx11::string’ {aka ‘std::__cxx11::basi
							      								    								  c_string<char>’} is not derived from ‘const std::p
							      								    								  air<_T1, _T2>’	  if(f_filled(param0[i]) ==
							      								    								  f_gold(param0[i]))
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/bits/stl_algobase.h:67,
							      								    								      from /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  		    from /usr/include/c++/8/ios:40,
							      								    								  		   from /usr/include/c++/8/ostream:3
							      								    								  8,		      from /usr/include/c++/8/iostre
							      								    								  am:39,		  from FIRST_UPPERCASE_LETTE
							      								    								  R_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:8: /usr/
							      								    								  include/c++/8/bits/stl_iterator.h:302:5: note: can
							      								    								  didate: ‘template<class _Iterator> bool std::opera
							      								    								  tor==(const std::reverse_iterator<_Iterator>&, con
							      								    								  st std::reverse_iterator<_Iterator>&)’      operat
							      								    								  or==(const reverse_iterator<_Iterator>& __x,
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/stl_iterator.h:30
							      								    								  2:5: note:   template argument deduction/substitut
							      								    								  ion failed: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITE
							      								    								  RATIVE_AND_RECURSIVE.cpp:39:51: note:	  ‘std::__cx
							      								    								  x11::string’ {aka ‘std::__cxx11::basic_string<char
							      								    								  >’} is not derived from ‘const std::reverse_iterat
							      								    								  or<_Iterator>’	  if(f_filled(param0[i]) ==
							      								    								  f_gold(param0[i]))
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/bits/stl_algobase.h:67,
							      								    								      from /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  		    from /usr/include/c++/8/ios:40,
							      								    								  		   from /usr/include/c++/8/ostream:3
							      								    								  8,		      from /usr/include/c++/8/iostre
							      								    								  am:39,		  from FIRST_UPPERCASE_LETTE
							      								    								  R_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:8: /usr/
							      								    								  include/c++/8/bits/stl_iterator.h:340:5: note: can
							      								    								  didate: ‘template<class _IteratorL, class _Iterato
							      								    								  rR> bool std::operator==(const std::reverse_iterat
							      								    								  or<_Iterator>&, const std::reverse_iterator<_Itera
							      								    								  torR>&)’	operator==(const reverse_iterator<_I
							      								    								  teratorL>& __x,      ^~~~~~~~ /usr/include/c++/8/b
							      								    								  its/stl_iterator.h:340:5: note:   template argumen
							      								    								  t deduction/substitution failed: FIRST_UPPERCASE_L
							      								    								  ETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:5
							      								    								  1: note:   ‘std::__cxx11::string’ {aka ‘std::__cxx
							      								    								  11::basic_string<char>’} is not derived from ‘cons
							      								    								  t std::reverse_iterator<_Iterator>’	       if(f_
							      								    								  filled(param0[i]) == f_gold(param0[i]))
							      								    								  					   ^ In file
							      								    								   included from /usr/include/c++/8/bits/stl_algobas
							      								    								  e.h:67,		   from /usr/include/c++/8/b
							      								    								  its/char_traits.h:39,			 from /usr/i
							      								    								  nclude/c++/8/ios:40,			from /usr/in
							      								    								  clude/c++/8/ostream:38,		   from /usr
							      								    								  /include/c++/8/iostream:39,		       from
							      								    								  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_R
							      								    								  ECURSIVE.cpp:8: /usr/include/c++/8/bits/stl_iterat
							      								    								  or.h:1115:5: note: candidate: ‘template<class _Ite
							      								    								  ratorL, class _IteratorR> bool std::operator==(con
							      								    								  st std::move_iterator<_IteratorL>&, const std::mov
							      								    								  e_iterator<_IteratorR>&)’	 operator==(const mo
							      								    								  ve_iterator<_IteratorL>& __x,	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/stl_iterator.h:1115:5: note:   t
							      								    								  emplate argument deduction/substitution failed: FI
							      								    								  RST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_REC
							      								    								  URSIVE.cpp:39:51: note:   ‘std::__cxx11::string’ {
							      								    								  aka ‘std::__cxx11::basic_string<char>’} is not der
							      								    								  ived from ‘const std::move_iterator<_IteratorL>’
							      								    								  	  if(f_filled(param0[i]) == f_gold(param0[i]
							      								    								  ))
							      								    								      ^ In file included from /usr/include/c++/8/bit
							      								    								  s/stl_algobase.h:67,			from /usr/in
							      								    								  clude/c++/8/bits/char_traits.h:39,
							      								    								    from /usr/include/c++/8/ios:40,
							      								    								   from /usr/include/c++/8/ostream:38,
							      								    								      from /usr/include/c++/8/iostream:39,
							      								    								  	  from FIRST_UPPERCASE_LETTER_IN_A_STRING_IT
							      								    								  ERATIVE_AND_RECURSIVE.cpp:8: /usr/include/c++/8/bi
							      								    								  ts/stl_iterator.h:1121:5: note: candidate: ‘templa
							      								    								  te<class _Iterator> bool std::operator==(const std
							      								    								  ::move_iterator<_IteratorL>&, const std::move_iter
							      								    								  ator<_IteratorL>&)’	   operator==(const move_ite
							      								    								  rator<_Iterator>& __x,      ^~~~~~~~ /usr/include/
							      								    								  c++/8/bits/stl_iterator.h:1121:5: note:   template
							      								    								   argument deduction/substitution failed: FIRST_UPP
							      								    								  ERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.
							      								    								  cpp:39:51: note:   ‘std::__cxx11::string’ {aka ‘st
							      								    								  d::__cxx11::basic_string<char>’} is not derived fr
							      								    								  om ‘const std::move_iterator<_IteratorL>’
							      								    								   if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						 ^ I
							      								    								  n file included from /usr/include/c++/8/string:41,
							      								    								  		    from /usr/include/c++/8/bits/loc
							      								    								  ale_classes.h:40,		     from /usr/inclu
							      								    								  de/c++/8/bits/ios_base.h:41,			from
							      								    								   /usr/include/c++/8/ios:42,		       from
							      								    								  /usr/include/c++/8/ostream:38,		  fr
							      								    								  om /usr/include/c++/8/iostream:39,
							      								    								    from FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIV
							      								    								  E_AND_RECURSIVE.cpp:8: /usr/include/c++/8/bits/all
							      								    								  ocator.h:146:5: note: candidate: ‘template<class _
							      								    								  T1, class _T2> bool std::operator==(const std::all
							      								    								  ocator<_CharT>&, const std::allocator<_T2>&)’
							      								    								   operator==(const allocator<_T1>&, const allocator
							      								    								  <_T2>&)      ^~~~~~~~ /usr/include/c++/8/bits/allo
							      								    								  cator.h:146:5: note:	 template argument deduction
							      								    								  /substitution failed: FIRST_UPPERCASE_LETTER_IN_A_
							      								    								  STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:
							      								    								  ‘std::__cxx11::string’ {aka ‘std::__cxx11::basic_s
							      								    								  tring<char>’} is not derived from ‘const std::allo
							      								    								  cator<_CharT>’	  if(f_filled(param0[i]) ==
							      								    								  f_gold(param0[i]))
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/string:41,		   from /usr
							      								    								  /include/c++/8/bits/locale_classes.h:40,
							      								    								  	  from /usr/include/c++/8/bits/ios_base.h:41
							      								    								  ,		     from /usr/include/c++/8/ios:42,
							      								    								  		    from /usr/include/c++/8/ostream:
							      								    								  38,		       from /usr/include/c++/8/iostr
							      								    								  eam:39,		   from FIRST_UPPERCASE_LETT
							      								    								  ER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:8: /usr
							      								    								  /include/c++/8/bits/allocator.h:152:5: note: candi
							      								    								  date: ‘template<class _Tp> bool std::operator==(co
							      								    								  nst std::allocator<_CharT>&, const std::allocator<
							      								    								  _CharT>&)’	  operator==(const allocator<_Tp>&,
							      								    								  const allocator<_Tp>&)      ^~~~~~~~ /usr/include/
							      								    								  c++/8/bits/allocator.h:152:5: note:	template arg
							      								    								  ument deduction/substitution failed: FIRST_UPPERCA
							      								    								  SE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:
							      								    								  39:51: note:	 ‘std::__cxx11::string’ {aka ‘std::_
							      								    								  _cxx11::basic_string<char>’} is not derived from ‘
							      								    								  const std::allocator<_CharT>’		 if(f_filled
							      								    								  (param0[i]) == f_gold(param0[i]))
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/string:52,
							      								    								  	from /usr/include/c++/8/bits/locale_classes.
							      								    								  h:40,			 from /usr/include/c++/8/bit
							      								    								  s/ios_base.h:41,		    from /usr/includ
							      								    								  e/c++/8/ios:42,		   from /usr/include
							      								    								  /c++/8/ostream:38,		      from /usr/incl
							      								    								  ude/c++/8/iostream:39,		  from FIRST
							      								    								  _UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURS
							      								    								  IVE.cpp:8: /usr/include/c++/8/bits/basic_string.h:
							      								    								  6048:5: note: candidate: ‘template<class _CharT, c
							      								    								  lass _Traits, class _Alloc> bool std::operator==(c
							      								    								  onst std::__cxx11::basic_string<_CharT, _Traits, _
							      								    								  Alloc>&, const std::__cxx11::basic_string<_CharT,
							      								    								  _Traits, _Alloc>&)’	   operator==(const basic_st
							      								    								  ring<_CharT, _Traits, _Alloc>& __lhs,	     ^~~~~~~
							      								    								  ~ /usr/include/c++/8/bits/basic_string.h:6048:5: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE
							      								    								  _AND_RECURSIVE.cpp:39:51: note:   mismatched types
							      								    								   ‘const std::__cxx11::basic_string<_CharT, _Traits
							      								    								  , _Alloc>’ and ‘char’		 if(f_filled(param0[
							      								    								  i]) == f_gold(param0[i]))
							      								    								  			     ^ In file included from
							      								    								   /usr/include/c++/8/string:52,		  fr
							      								    								  om /usr/include/c++/8/bits/locale_classes.h:40,
							      								    								  		 from /usr/include/c++/8/bits/ios_ba
							      								    								  se.h:41,		    from /usr/include/c++/8/
							      								    								  ios:42,		   from /usr/include/c++/8/o
							      								    								  stream:38,		      from /usr/include/c++/
							      								    								  8/iostream:39,		  from FIRST_UPPERCA
							      								    								  SE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:
							      								    								  8: /usr/include/c++/8/bits/basic_string.h:6056:5:
							      								    								  note: candidate: ‘template<class _CharT> typename
							      								    								  __gnu_cxx::__enable_if<std::__is_char<_Tp>::__valu
							      								    								  e, bool>::__type std::operator==(const std::__cxx1
							      								    								  1::basic_string<_CharT>&, const std::__cxx11::basi
							      								    								  c_string<_CharT>&)’	   operator==(const basic_st
							      								    								  ring<_CharT>& __lhs,	    ^~~~~~~~ /usr/include/c+
							      								    								  +/8/bits/basic_string.h:6056:5: note:	  template a
							      								    								  rgument deduction/substitution failed: FIRST_UPPER
							      								    								  CASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cp
							      								    								  p:39:51: note:   mismatched types ‘const std::__cx
							      								    								  x11::basic_string<_CharT>’ and ‘char’		 if(
							      								    								  f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  					     ^ In fi
							      								    								  le included from /usr/include/c++/8/string:52,
							      								    								  		from /usr/include/c++/8/bits/locale_
							      								    								  classes.h:40,			 from /usr/include/c
							      								    								  ++/8/bits/ios_base.h:41,		    from /us
							      								    								  r/include/c++/8/ios:42,		   from /usr
							      								    								  /include/c++/8/ostream:38,		      from /
							      								    								  usr/include/c++/8/iostream:39,		  fr
							      								    								  om FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AN
							      								    								  D_RECURSIVE.cpp:8: /usr/include/c++/8/bits/basic_s
							      								    								  tring.h:6070:5: note: candidate: ‘template<class _
							      								    								  CharT, class _Traits, class _Alloc> bool std::oper
							      								    								  ator==(const _CharT*, const std::__cxx11::basic_st
							      								    								  ring<_CharT, _Traits, _Alloc>&)’	operator==(c
							      								    								  onst _CharT* __lhs,	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/basic_string.h:6070:5: note:	 template ar
							      								    								  gument deduction/substitution failed: FIRST_UPPERC
							      								    								  ASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp
							      								    								  :39:51: note:	  mismatched types ‘const _CharT*’ a
							      								    								  nd ‘std::__cxx11::basic_string<char>’		 if(
							      								    								  f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  					     ^ In fi
							      								    								  le included from /usr/include/c++/8/string:52,
							      								    								  		from /usr/include/c++/8/bits/locale_
							      								    								  classes.h:40,			 from /usr/include/c
							      								    								  ++/8/bits/ios_base.h:41,		    from /us
							      								    								  r/include/c++/8/ios:42,		   from /usr
							      								    								  /include/c++/8/ostream:38,		      from /
							      								    								  usr/include/c++/8/iostream:39,		  fr
							      								    								  om FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AN
							      								    								  D_RECURSIVE.cpp:8: /usr/include/c++/8/bits/basic_s
							      								    								  tring.h:6082:5: note: candidate: ‘template<class _
							      								    								  CharT, class _Traits, class _Alloc> bool std::oper
							      								    								  ator==(const std::__cxx11::basic_string<_CharT, _T
							      								    								  raits, _Alloc>&, const _CharT*)’	operator==(c
							      								    								  onst basic_string<_CharT, _Traits, _Alloc>& __lhs,
							      								    								  	^~~~~~~~ /usr/include/c++/8/bits/basic_strin
							      								    								  g.h:6082:5: note:   template argument deduction/su
							      								    								  bstitution failed: FIRST_UPPERCASE_LETTER_IN_A_STR
							      								    								  ING_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:	 mis
							      								    								  matched types ‘const _CharT*’ and ‘char’
							      								    								  if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						^ In
							      								    								   file included from /usr/include/c++/8/bits/ios_ba
							      								    								  se.h:46,		    from /usr/include/c++/8/
							      								    								  ios:42,		   from /usr/include/c++/8/o
							      								    								  stream:38,		      from /usr/include/c++/
							      								    								  8/iostream:39,		  from FIRST_UPPERCA
							      								    								  SE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:
							      								    								  8: /usr/include/c++/8/system_error:292:3: note: ca
							      								    								  ndidate: ‘bool std::operator==(const std::error_co
							      								    								  de&, const std::error_code&)’	   operator==(const
							      								    								  error_code& __lhs, const error_code& __rhs) noexce
							      								    								  pt	^~~~~~~~ /usr/include/c++/8/system_error:292
							      								    								  :3: note:   no known conversion for argument 1 fro
							      								    								  m ‘std::__cxx11::string’ {aka ‘std::__cxx11::basic
							      								    								  _string<char>’} to ‘const std::error_code&’ /usr/i
							      								    								  nclude/c++/8/system_error:297:3: note: candidate:
							      								    								  ‘bool std::operator==(const std::error_code&, cons
							      								    								  t std::error_condition&)’    operator==(const erro
							      								    								  r_code& __lhs, const error_condition& __rhs) noexc
							      								    								  ept	 ^~~~~~~~ /usr/include/c++/8/system_error:29
							      								    								  7:3: note:   no known conversion for argument 1 fr
							      								    								  om ‘std::__cxx11::string’ {aka ‘std::__cxx11::basi
							      								    								  c_string<char>’} to ‘const std::error_code&’ /usr/
							      								    								  include/c++/8/system_error:304:3: note: candidate:
							      								    								   ‘bool std::operator==(const std::error_condition&
							      								    								  , const std::error_code&)’	operator==(const err
							      								    								  or_condition& __lhs, const error_code& __rhs) noex
							      								    								  cept	  ^~~~~~~~ /usr/include/c++/8/system_error:3
							      								    								  04:3: note:	no known conversion for argument 1 f
							      								    								  rom ‘std::__cxx11::string’ {aka ‘std::__cxx11::bas
							      								    								  ic_string<char>’} to ‘const std::error_condition&’
							      								    								   /usr/include/c++/8/system_error:311:3: note: cand
							      								    								  idate: ‘bool std::operator==(const std::error_cond
							      								    								  ition&, const std::error_condition&)’	   operator=
							      								    								  =(const error_condition& __lhs,    ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/system_error:311:3: note:   no known
							      								    								  conversion for argument 1 from ‘std::__cxx11::stri
							      								    								  ng’ {aka ‘std::__cxx11::basic_string<char>’} to ‘c
							      								    								  onst std::error_condition&’ In file included from
							      								    								  /usr/include/c++/8/bits/locale_facets.h:48,
							      								    								  	     from /usr/include/c++/8/bits/basic_ios.
							      								    								  h:37,			 from /usr/include/c++/8/ios
							      								    								  :44,			from /usr/include/c++/8/ostr
							      								    								  eam:38,		   from /usr/include/c++/8/i
							      								    								  ostream:39,		       from FIRST_UPPERCASE_
							      								    								  LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:8:
							      								    								  /usr/include/c++/8/bits/streambuf_iterator.h:203:5
							      								    								  : note: candidate: ‘template<class _CharT, class _
							      								    								  Traits> bool std::operator==(const std::istreambuf
							      								    								  _iterator<_CharT, _Traits>&, const std::istreambuf
							      								    								  _iterator<_CharT, _Traits>&)’	     operator==(cons
							      								    								  t istreambuf_iterator<_CharT, _Traits>& __a,
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/streambuf_iterato
							      								    								  r.h:203:5: note:   template argument deduction/sub
							      								    								  stitution failed: FIRST_UPPERCASE_LETTER_IN_A_STRI
							      								    								  NG_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:	‘std
							      								    								  ::__cxx11::string’ {aka ‘std::__cxx11::basic_strin
							      								    								  g<char>’} is not derived from ‘const std::istreamb
							      								    								  uf_iterator<_CharT, _Traits>’		 if(f_filled
							      								    								  (param0[i]) == f_gold(param0[i]))
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/vector:64,
							      								    								  	from FIRST_UPPERCASE_LETTER_IN_A_STRING_ITER
							      								    								  ATIVE_AND_RECURSIVE.cpp:11: /usr/include/c++/8/bit
							      								    								  s/stl_vector.h:1753:5: note: candidate: ‘template<
							      								    								  class _Tp, class _Alloc> bool std::operator==(cons
							      								    								  t std::vector<_Tp, _Alloc>&, const std::vector<_Tp
							      								    								  , _Alloc>&)’	    operator==(const vector<_Tp, _Al
							      								    								  loc>& __x, const vector<_Tp, _Alloc>& __y)	  ^~
							      								    								  ~~~~~~ /usr/include/c++/8/bits/stl_vector.h:1753:5
							      								    								  : note:   template argument deduction/substitution
							      								    								   failed: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERAT
							      								    								  IVE_AND_RECURSIVE.cpp:39:51: note:   ‘std::__cxx11
							      								    								  ::string’ {aka ‘std::__cxx11::basic_string<char>’}
							      								    								   is not derived from ‘const std::vector<_Tp, _Allo
							      								    								  c>’	       if(f_filled(param0[i]) == f_gold(para
							      								    								  m0[i]))
							      								    								  	   ^ In file included from /usr/include/c++/
							      								    								  8/tuple:39,		       from /usr/include/c++
							      								    								  /8/bits/unique_ptr.h:37,		    from /us
							      								    								  r/include/c++/8/bits/locale_conv.h:41,
							      								    								  	from /usr/include/c++/8/locale:43,
							      								    								  	  from /usr/include/c++/8/iomanip:43,
							      								    								  	     from FIRST_UPPERCASE_LETTER_IN_A_STRING
							      								    								  _ITERATIVE_AND_RECURSIVE.cpp:13: /usr/include/c++/
							      								    								  8/array:252:5: note: candidate: ‘template<class _T
							      								    								  p, long unsigned int _Nm> bool std::operator==(con
							      								    								  st std::array<_Tp, _Nm>&, const std::array<_Tp, _N
							      								    								  m>&)’	     operator==(const array<_Tp, _Nm>& __one
							      								    								  , const array<_Tp, _Nm>& __two)      ^~~~~~~~ /usr
							      								    								  /include/c++/8/array:252:5: note:   template argum
							      								    								  ent deduction/substitution failed: FIRST_UPPERCASE
							      								    								  _LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39
							      								    								  :51: note:   ‘std::__cxx11::string’ {aka ‘std::__c
							      								    								  xx11::basic_string<char>’} is not derived from ‘co
							      								    								  nst std::array<_Tp, _Nm>’	     if(f_filled(par
							      								    								  am0[i]) == f_gold(param0[i]))
							      								    								  				 ^ In file included
							      								    								  from /usr/include/c++/8/bits/unique_ptr.h:37,
							      								    								  	       from /usr/include/c++/8/bits/locale_c
							      								    								  onv.h:41,		     from /usr/include/c++/8
							      								    								  /locale:43,		       from /usr/include/c++
							      								    								  /8/iomanip:43,		  from FIRST_UPPERCA
							      								    								  SE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:
							      								    								  13: /usr/include/c++/8/tuple:1413:5: note: candida
							      								    								  te: ‘template<class ... _TElements, class ... _UEl
							      								    								  ements> constexpr bool std::operator==(const std::
							      								    								  tuple<_Tps ...>&, const std::tuple<_Elements ...>&
							      								    								  )’	  operator==(const tuple<_TElements...>& __t
							      								    								  ,	 ^~~~~~~~ /usr/include/c++/8/tuple:1413:5: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE
							      								    								  _AND_RECURSIVE.cpp:39:51: note:   ‘std::__cxx11::s
							      								    								  tring’ {aka ‘std::__cxx11::basic_string<char>’} is
							      								    								   not derived from ‘const std::tuple<_Tps ...>’
							      								    								  	if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  
							      								    								    ^ In file included from /usr/include/c++/8/bits/
							      								    								  locale_conv.h:41,		     from /usr/inclu
							      								    								  de/c++/8/locale:43,		       from /usr/inc
							      								    								  lude/c++/8/iomanip:43,		  from FIRST
							      								    								  _UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURS
							      								    								  IVE.cpp:13: /usr/include/c++/8/bits/unique_ptr.h:6
							      								    								  93:5: note: candidate: ‘template<class _Tp, class
							      								    								  _Dp, class _Up, class _Ep> bool std::operator==(co
							      								    								  nst std::unique_ptr<_Tp, _Dp>&, const std::unique_
							      								    								  ptr<_Up, _Ep>&)’	operator==(const unique_ptr<
							      								    								  _Tp, _Dp>& __x,      ^~~~~~~~ /usr/include/c++/8/b
							      								    								  its/unique_ptr.h:693:5: note:	  template argument
							      								    								  deduction/substitution failed: FIRST_UPPERCASE_LET
							      								    								  TER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51:
							      								    								   note:   ‘std::__cxx11::string’ {aka ‘std::__cxx11
							      								    								  ::basic_string<char>’} is not derived from ‘const
							      								    								  std::unique_ptr<_Tp, _Dp>’	      if(f_filled(pa
							      								    								  ram0[i]) == f_gold(param0[i]))
							      								    								  				  ^ In file included
							      								    								   from /usr/include/c++/8/bits/locale_conv.h:41,
							      								    								  		 from /usr/include/c++/8/locale:43,
							      								    								  		   from /usr/include/c++/8/iomanip:4
							      								    								  3,		      from FIRST_UPPERCASE_LETTER_IN
							      								    								  _A_STRING_ITERATIVE_AND_RECURSIVE.cpp:13: /usr/inc
							      								    								  lude/c++/8/bits/unique_ptr.h:699:5: note: candidat
							      								    								  e: ‘template<class _Tp, class _Dp> bool std::opera
							      								    								  tor==(const std::unique_ptr<_Tp, _Dp>&, std::nullp
							      								    								  tr_t)’      operator==(const unique_ptr<_Tp, _Dp>&
							      								    								   __x, nullptr_t) noexcept	 ^~~~~~~~ /usr/inclu
							      								    								  de/c++/8/bits/unique_ptr.h:699:5: note:   template
							      								    								   argument deduction/substitution failed: FIRST_UPP
							      								    								  ERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.
							      								    								  cpp:39:51: note:   ‘std::__cxx11::string’ {aka ‘st
							      								    								  d::__cxx11::basic_string<char>’} is not derived fr
							      								    								  om ‘const std::unique_ptr<_Tp, _Dp>’		if(f
							      								    								  _filled(param0[i]) == f_gold(param0[i]))
							      								    								  					    ^ In fil
							      								    								  e included from /usr/include/c++/8/bits/locale_con
							      								    								  v.h:41,		   from /usr/include/c++/8/l
							      								    								  ocale:43,		     from /usr/include/c++/8
							      								    								  /iomanip:43,			from FIRST_UPPERCASE
							      								    								  _LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:13
							      								    								  : /usr/include/c++/8/bits/unique_ptr.h:704:5: note
							      								    								  : candidate: ‘template<class _Tp, class _Dp> bool
							      								    								  std::operator==(std::nullptr_t, const std::unique_
							      								    								  ptr<_Tp, _Dp>&)’	operator==(nullptr_t, const
							      								    								  unique_ptr<_Tp, _Dp>& __x) noexcept	   ^~~~~~~~
							      								    								  /usr/include/c++/8/bits/unique_ptr.h:704:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_
							      								    								  RECURSIVE.cpp:39:51: note:   mismatched types ‘con
							      								    								  st std::unique_ptr<_Tp, _Dp>’ and ‘char’
							      								    								  if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						^ In
							      								    								   file included from /usr/include/c++/8/ccomplex:39
							      								    								  ,		     from /usr/include/c++/8/x86_64-
							      								    								  redhat-linux/bits/stdc++.h:52,		  fr
							      								    								  om FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AN
							      								    								  D_RECURSIVE.cpp:14: /usr/include/c++/8/complex:458
							      								    								  :5: note: candidate: ‘template<class _Tp> constexp
							      								    								  r bool std::operator==(const std::complex<_Tp>&, c
							      								    								  onst std::complex<_Tp>&)’	 operator==(const co
							      								    								  mplex<_Tp>& __x, const complex<_Tp>& __y)	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/complex:458:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: FIR
							      								    								  ST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECU
							      								    								  RSIVE.cpp:39:51: note:   ‘std::__cxx11::string’ {a
							      								    								  ka ‘std::__cxx11::basic_string<char>’} is not deri
							      								    								  ved from ‘const std::complex<_Tp>’	      if(f_f
							      								    								  illed(param0[i]) == f_gold(param0[i]))
							      								    								  					  ^ In file
							      								    								  included from /usr/include/c++/8/ccomplex:39,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:52,		    from FIR
							      								    								  ST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECU
							      								    								  RSIVE.cpp:14: /usr/include/c++/8/complex:463:5: no
							      								    								  te: candidate: ‘template<class _Tp> constexpr bool
							      								    								   std::operator==(const std::complex<_Tp>&, const _
							      								    								  Tp&)’	     operator==(const complex<_Tp>& __x, con
							      								    								  st _Tp& __y)	    ^~~~~~~~ /usr/include/c++/8/comp
							      								    								  lex:463:5: note:   template argument deduction/sub
							      								    								  stitution failed: FIRST_UPPERCASE_LETTER_IN_A_STRI
							      								    								  NG_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:	‘std
							      								    								  ::__cxx11::string’ {aka ‘std::__cxx11::basic_strin
							      								    								  g<char>’} is not derived from ‘const std::complex<
							      								    								  _Tp>’		 if(f_filled(param0[i]) == f_gold(pa
							      								    								  ram0[i]))
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/ccomplex:39,		    from /usr/includ
							      								    								  e/c++/8/x86_64-redhat-linux/bits/stdc++.h:52,
							      								    								  	       from FIRST_UPPERCASE_LETTER_IN_A_STRI
							      								    								  NG_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/include/c+
							      								    								  +/8/complex:468:5: note: candidate: ‘template<clas
							      								    								  s _Tp> constexpr bool std::operator==(const _Tp&,
							      								    								  const std::complex<_Tp>&)’	  operator==(const _
							      								    								  Tp& __x, const complex<_Tp>& __y)	 ^~~~~~~~ /u
							      								    								  sr/include/c++/8/complex:468:5: note:	  template a
							      								    								  rgument deduction/substitution failed: FIRST_UPPER
							      								    								  CASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cp
							      								    								  p:39:51: note:   mismatched types ‘const std::comp
							      								    								  lex<_Tp>’ and ‘char’		if(f_filled(param0[i
							      								    								  ]) == f_gold(param0[i]))
							      								    								  			    ^ In file included from
							      								    								  /usr/include/c++/8/deque:64,			from
							      								    								   /usr/include/c++/8/x86_64-redhat-linux/bits/stdc+
							      								    								  +.h:68,		   from FIRST_UPPERCASE_LETT
							      								    								  ER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /us
							      								    								  r/include/c++/8/bits/stl_deque.h:268:5: note: cand
							      								    								  idate: ‘template<class _Tp, class _Ref, class _Ptr
							      								    								  > bool std::operator==(const std::_Deque_iterator<
							      								    								  _Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp,
							      								    								   _Ref, _Ptr>&)’      operator==(const _Deque_itera
							      								    								  tor<_Tp, _Ref, _Ptr>& __x,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/stl_deque.h:268:5: note:   template
							      								    								   argument deduction/substitution failed: FIRST_UPP
							      								    								  ERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.
							      								    								  cpp:39:51: note:   ‘std::__cxx11::string’ {aka ‘st
							      								    								  d::__cxx11::basic_string<char>’} is not derived fr
							      								    								  om ‘const std::_Deque_iterator<_Tp, _Ref, _Ptr>’
							      								    								  	  if(f_filled(param0[i]) == f_gold(param0[i]
							      								    								  ))
							      								    								      ^ In file included from /usr/include/c++/8/deq
							      								    								  ue:64,		  from /usr/include/c++/8/x8
							      								    								  6_64-redhat-linux/bits/stdc++.h:68,
							      								    								     from FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATI
							      								    								  VE_AND_RECURSIVE.cpp:14: /usr/include/c++/8/bits/s
							      								    								  tl_deque.h:275:5: note: candidate: ‘template<class
							      								    								   _Tp, class _RefL, class _PtrL, class _RefR, class
							      								    								   _PtrR> bool std::operator==(const std::_Deque_ite
							      								    								  rator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterato
							      								    								  r<_Tp, _RefR, _PtrR>&)’      operator==(const _Deq
							      								    								  ue_iterator<_Tp, _RefL, _PtrL>& __x,	    ^~~~~~~~
							      								    								   /usr/include/c++/8/bits/stl_deque.h:275:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_
							      								    								  RECURSIVE.cpp:39:51: note:   ‘std::__cxx11::string
							      								    								  ’ {aka ‘std::__cxx11::basic_string<char>’} is not
							      								    								  derived from ‘const std::_Deque_iterator<_Tp, _Ref
							      								    								  , _Ptr>’	    if(f_filled(param0[i]) == f_gold
							      								    								  (param0[i]))
							      								    								  		^ In file included from /usr/include
							      								    								  /c++/8/deque:64,		    from /usr/includ
							      								    								  e/c++/8/x86_64-redhat-linux/bits/stdc++.h:68,
							      								    								  	       from FIRST_UPPERCASE_LETTER_IN_A_STRI
							      								    								  NG_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/include/c+
							      								    								  +/8/bits/stl_deque.h:2277:5: note: candidate: ‘tem
							      								    								  plate<class _Tp, class _Alloc> bool std::operator=
							      								    								  =(const std::deque<_Tp, _Alloc>&, const std::deque
							      								    								  <_Tp, _Alloc>&)’	operator==(const deque<_Tp,
							      								    								  _Alloc>& __x,	     ^~~~~~~~ /usr/include/c++/8/bit
							      								    								  s/stl_deque.h:2277:5: note:	template argument de
							      								    								  duction/substitution failed: FIRST_UPPERCASE_LETTE
							      								    								  R_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: n
							      								    								  ote:	 ‘std::__cxx11::string’ {aka ‘std::__cxx11::
							      								    								  basic_string<char>’} is not derived from ‘const st
							      								    								  d::deque<_Tp, _Alloc>’	  if(f_filled(param0
							      								    								  [i]) == f_gold(param0[i]))
							      								    								  			      ^ In file included fro
							      								    								  m /usr/include/c++/8/functional:59,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:71,		  from FIRST_UPPERCA
							      								    								  SE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:
							      								    								  14: /usr/include/c++/8/bits/std_function.h:745:5:
							      								    								  note: candidate: ‘template<class _Res, class ... _
							      								    								  Args> bool std::operator==(const std::function<_Re
							      								    								  s(_ArgTypes ...)>&, std::nullptr_t)’	    operator
							      								    								  ==(const function<_Res(_Args...)>& __f, nullptr_t)
							      								    								   noexcept	 ^~~~~~~~ /usr/include/c++/8/bits/st
							      								    								  d_function.h:745:5: note:   template argument dedu
							      								    								  ction/substitution failed: FIRST_UPPERCASE_LETTER_
							      								    								  IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: not
							      								    								  e:   ‘std::__cxx11::string’ {aka ‘std::__cxx11::ba
							      								    								  sic_string<char>’} is not derived from ‘const std:
							      								    								  :function<_Res(_ArgTypes ...)>’	   if(f_fill
							      								    								  ed(param0[i]) == f_gold(param0[i]))
							      								    								  				       ^ In file inc
							      								    								  luded from /usr/include/c++/8/functional:59,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:71,		   from FIRS
							      								    								  T_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECUR
							      								    								  SIVE.cpp:14: /usr/include/c++/8/bits/std_function.
							      								    								  h:751:5: note: candidate: ‘template<class _Res, cl
							      								    								  ass ... _Args> bool std::operator==(std::nullptr_t
							      								    								  , const std::function<_Res(_ArgTypes ...)>&)’
							      								    								   operator==(nullptr_t, const function<_Res(_Args..
							      								    								  .)>& __f) noexcept	  ^~~~~~~~ /usr/include/c++/
							      								    								  8/bits/std_function.h:751:5: note:   template argu
							      								    								  ment deduction/substitution failed: FIRST_UPPERCAS
							      								    								  E_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:3
							      								    								  9:51: note:	mismatched types ‘const std::functio
							      								    								  n<_Res(_ArgTypes ...)>’ and ‘char’	      if(f_f
							      								    								  illed(param0[i]) == f_gold(param0[i]))
							      								    								  					  ^ In file
							      								    								  included from /usr/include/c++/8/iterator:66,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:77,		    from FIR
							      								    								  ST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECU
							      								    								  RSIVE.cpp:14: /usr/include/c++/8/bits/stream_itera
							      								    								  tor.h:130:5: note: candidate: ‘template<class _Tp,
							      								    								   class _CharT, class _Traits, class _Dist> bool st
							      								    								  d::operator==(const std::istream_iterator<_Tp, _Ch
							      								    								  arT, _Traits, _Dist>&, const std::istream_iterator
							      								    								  <_Tp, _CharT, _Traits, _Dist>&)’	operator==(c
							      								    								  onst istream_iterator<_Tp, _CharT, _Traits, _Dist>
							      								    								  & __x,      ^~~~~~~~ /usr/include/c++/8/bits/strea
							      								    								  m_iterator.h:130:5: note:   template argument dedu
							      								    								  ction/substitution failed: FIRST_UPPERCASE_LETTER_
							      								    								  IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: not
							      								    								  e:   ‘std::__cxx11::string’ {aka ‘std::__cxx11::ba
							      								    								  sic_string<char>’} is not derived from ‘const std:
							      								    								  :istream_iterator<_Tp, _CharT, _Traits, _Dist>’
							      								    								  	 if(f_filled(param0[i]) == f_gold(param0[i])
							      								    								  )
							      								    								     ^ In file included from /usr/include/c++/8/list
							      								    								  :63,			from /usr/include/c++/8/x86_
							      								    								  64-redhat-linux/bits/stdc++.h:79,
							      								    								   from FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE
							      								    								  _AND_RECURSIVE.cpp:14: /usr/include/c++/8/bits/stl
							      								    								  _list.h:344:5: note: candidate: ‘template<class _V
							      								    								  al> bool std::operator==(const std::_List_iterator
							      								    								  <_Tp>&, const std::_List_const_iterator<_Tp>&)’
							      								    								     operator==(const _List_iterator<_Val>& __x,
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/stl_list.h:344:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERA
							      								    								  TIVE_AND_RECURSIVE.cpp:39:51: note:	‘std::__cxx1
							      								    								  1::string’ {aka ‘std::__cxx11::basic_string<char>’
							      								    								  } is not derived from ‘const std::_List_iterator<_
							      								    								  Tp>’		if(f_filled(param0[i]) == f_gold(par
							      								    								  am0[i]))
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/list:63,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:79,
							      								    								  	  from FIRST_UPPERCASE_LETTER_IN_A_STRING_IT
							      								    								  ERATIVE_AND_RECURSIVE.cpp:14: /usr/include/c++/8/b
							      								    								  its/stl_list.h:1987:5: note: candidate: ‘template<
							      								    								  class _Tp, class _Alloc> bool std::operator==(cons
							      								    								  t std::__cxx11::list<_Tp, _Alloc>&, const std::__c
							      								    								  xx11::list<_Tp, _Alloc>&)’	  operator==(const l
							      								    								  ist<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __
							      								    								  y)	  ^~~~~~~~ /usr/include/c++/8/bits/stl_list.
							      								    								  h:1987:5: note:   template argument deduction/subs
							      								    								  titution failed: FIRST_UPPERCASE_LETTER_IN_A_STRIN
							      								    								  G_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:   ‘std:
							      								    								  :__cxx11::string’ {aka ‘std::__cxx11::basic_string
							      								    								  <char>’} is not derived from ‘const std::__cxx11::
							      								    								  list<_Tp, _Alloc>’	      if(f_filled(param0[i])
							      								    								   == f_gold(param0[i]))
							      								    								  			  ^ In file included from /u
							      								    								  sr/include/c++/8/map:60,		    from /us
							      								    								  r/include/c++/8/x86_64-redhat-linux/bits/stdc++.h:
							      								    								  81,		       from FIRST_UPPERCASE_LETTER_I
							      								    								  N_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/in
							      								    								  clude/c++/8/bits/stl_tree.h:406:5: note: candidate
							      								    								  : ‘template<class _Val> bool std::operator==(const
							      								    								   std::_Rb_tree_iterator<_Tp>&, const std::_Rb_tree
							      								    								  _const_iterator<_Val>&)’	operator==(const _Rb
							      								    								  _tree_iterator<_Val>& __x,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/stl_tree.h:406:5: note:   template
							      								    								  argument deduction/substitution failed: FIRST_UPPE
							      								    								  RCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.c
							      								    								  pp:39:51: note:   ‘std::__cxx11::string’ {aka ‘std
							      								    								  ::__cxx11::basic_string<char>’} is not derived fro
							      								    								  m ‘const std::_Rb_tree_iterator<_Tp>’		 if(
							      								    								  f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  					     ^ In fi
							      								    								  le included from /usr/include/c++/8/map:60,
							      								    								  	     from /usr/include/c++/8/x86_64-redhat-l
							      								    								  inux/bits/stdc++.h:81,		  from FIRST
							      								    								  _UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURS
							      								    								  IVE.cpp:14: /usr/include/c++/8/bits/stl_tree.h:155
							      								    								  6:5: note: candidate: ‘template<class _Key, class
							      								    								  _Val, class _KeyOfValue, class _Compare, class _Al
							      								    								  loc> bool std::operator==(const std::_Rb_tree<_Key
							      								    								  , _Val, _KeyOfValue, _Compare, _Alloc>&, const std
							      								    								  ::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _All
							      								    								  oc>&)’      operator==(const _Rb_tree<_Key, _Val,
							      								    								  _KeyOfValue, _Compare, _Alloc>& __x,	    ^~~~~~~~
							      								    								   /usr/include/c++/8/bits/stl_tree.h:1556:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_
							      								    								  RECURSIVE.cpp:39:51: note:   ‘std::__cxx11::string
							      								    								  ’ {aka ‘std::__cxx11::basic_string<char>’} is not
							      								    								  derived from ‘const std::_Rb_tree<_Key, _Val, _Key
							      								    								  OfValue, _Compare, _Alloc>’	       if(f_filled(p
							      								    								  aram0[i]) == f_gold(param0[i]))
							      								    								  				   ^ In file include
							      								    								  d from /usr/include/c++/8/map:61,
							      								    								   from /usr/include/c++/8/x86_64-redhat-linux/bits/
							      								    								  stdc++.h:81,			from FIRST_UPPERCASE
							      								    								  _LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14
							      								    								  : /usr/include/c++/8/bits/stl_map.h:1434:5: note:
							      								    								  candidate: ‘template<class _Key, class _Tp, class
							      								    								  _Compare, class _Alloc> bool std::operator==(const
							      								    								   std::map<_Key, _Tp, _Compare, _Alloc>&, const std
							      								    								  ::map<_Key, _Tp, _Compare, _Alloc>&)’	     operato
							      								    								  r==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
							      								    								      ^~~~~~~~ /usr/include/c++/8/bits/stl_map.h:143
							      								    								  4:5: note:   template argument deduction/substitut
							      								    								  ion failed: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITE
							      								    								  RATIVE_AND_RECURSIVE.cpp:39:51: note:	  ‘std::__cx
							      								    								  x11::string’ {aka ‘std::__cxx11::basic_string<char
							      								    								  >’} is not derived from ‘const std::map<_Key, _Tp,
							      								    								   _Compare, _Alloc>’	       if(f_filled(param0[i]
							      								    								  ) == f_gold(param0[i]))
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/map:62,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :81,			from FIRST_UPPERCASE_LETTER_
							      								    								  IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/i
							      								    								  nclude/c++/8/bits/stl_multimap.h:1098:5: note: can
							      								    								  didate: ‘template<class _Key, class _Tp, class _Co
							      								    								  mpare, class _Alloc> bool std::operator==(const st
							      								    								  d::multimap<_Key, _Tp, _Compare, _Alloc>&, const s
							      								    								  td::multimap<_Key, _Tp, _Compare, _Alloc>&)’
							      								    								  operator==(const multimap<_Key, _Tp, _Compare, _Al
							      								    								  loc>& __x,	  ^~~~~~~~ /usr/include/c++/8/bits/s
							      								    								  tl_multimap.h:1098:5: note:	template argument de
							      								    								  duction/substitution failed: FIRST_UPPERCASE_LETTE
							      								    								  R_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: n
							      								    								  ote:	 ‘std::__cxx11::string’ {aka ‘std::__cxx11::
							      								    								  basic_string<char>’} is not derived from ‘const st
							      								    								  d::multimap<_Key, _Tp, _Compare, _Alloc>’
							      								    								   if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  						 ^ I
							      								    								  n file included from /usr/include/c++/8/bits/share
							      								    								  d_ptr.h:52,		       from /usr/include/c++
							      								    								  /8/memory:81,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:82,
							      								    								  	    from FIRST_UPPERCASE_LETTER_IN_A_STRING_
							      								    								  ITERATIVE_AND_RECURSIVE.cpp:14: /usr/include/c++/8
							      								    								  /bits/shared_ptr_base.h:1410:5: note: candidate: ‘
							      								    								  template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_
							      								    								  policy _Lp> bool std::operator==(const std::__shar
							      								    								  ed_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,
							      								    								  _Lp>&)’      operator==(const __shared_ptr<_Tp1, _
							      								    								  Lp>& __a,	 ^~~~~~~~ /usr/include/c++/8/bits/sh
							      								    								  ared_ptr_base.h:1410:5: note:	  template argument
							      								    								  deduction/substitution failed: FIRST_UPPERCASE_LET
							      								    								  TER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51:
							      								    								   note:   ‘std::__cxx11::string’ {aka ‘std::__cxx11
							      								    								  ::basic_string<char>’} is not derived from ‘const
							      								    								  std::__shared_ptr<_Tp1, _Lp>’		 if(f_filled
							      								    								  (param0[i]) == f_gold(param0[i]))
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/bits/shared_ptr.h:52,
							      								    								  		   from /usr/include/c++/8/memory:81
							      								    								  ,		     from /usr/include/c++/8/x86_64-
							      								    								  redhat-linux/bits/stdc++.h:82,		  fr
							      								    								  om FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AN
							      								    								  D_RECURSIVE.cpp:14: /usr/include/c++/8/bits/shared
							      								    								  _ptr_base.h:1416:5: note: candidate: ‘template<cla
							      								    								  ss _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::ope
							      								    								  rator==(const std::__shared_ptr<_Tp, _Lp>&, std::n
							      								    								  ullptr_t)’	  operator==(const __shared_ptr<_Tp,
							      								    								   _Lp>& __a, nullptr_t) noexcept      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/shared_ptr_base.h:1416:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AN
							      								    								  D_RECURSIVE.cpp:39:51: note:	 ‘std::__cxx11::stri
							      								    								  ng’ {aka ‘std::__cxx11::basic_string<char>’} is no
							      								    								  t derived from ‘const std::__shared_ptr<_Tp, _Lp>’
							      								    								  	    if(f_filled(param0[i]) == f_gold(param0[
							      								    								  i]))
							      								    								  	^ In file included from /usr/include/c++/8/b
							      								    								  its/shared_ptr.h:52,			from /usr/in
							      								    								  clude/c++/8/memory:81,		  from /usr/
							      								    								  include/c++/8/x86_64-redhat-linux/bits/stdc++.h:82
							      								    								  ,		     from FIRST_UPPERCASE_LETTER_IN_
							      								    								  A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/incl
							      								    								  ude/c++/8/bits/shared_ptr_base.h:1421:5: note: can
							      								    								  didate: ‘template<class _Tp, __gnu_cxx::_Lock_poli
							      								    								  cy _Lp> bool std::operator==(std::nullptr_t, const
							      								    								   std::__shared_ptr<_Tp, _Lp>&)’      operator==(nu
							      								    								  llptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexce
							      								    								  pt	  ^~~~~~~~ /usr/include/c++/8/bits/shared_pt
							      								    								  r_base.h:1421:5: note:   template argument deducti
							      								    								  on/substitution failed: FIRST_UPPERCASE_LETTER_IN_
							      								    								  A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:
							      								    								    mismatched types ‘const std::__shared_ptr<_Tp, _
							      								    								  Lp>’ and ‘char’	   if(f_filled(param0[i]) ==
							      								    								   f_gold(param0[i]))
							      								    								  		       ^ In file included from /usr/
							      								    								  include/c++/8/memory:81,		    from /us
							      								    								  r/include/c++/8/x86_64-redhat-linux/bits/stdc++.h:
							      								    								  82,		       from FIRST_UPPERCASE_LETTER_I
							      								    								  N_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/in
							      								    								  clude/c++/8/bits/shared_ptr.h:383:5: note: candida
							      								    								  te: ‘template<class _Tp, class _Up> bool std::oper
							      								    								  ator==(const std::shared_ptr<_Tp>&, const std::sha
							      								    								  red_ptr<_Tp>&)’      operator==(const shared_ptr<_
							      								    								  Tp>& __a, const shared_ptr<_Up>& __b) noexcept
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr.h:38
							      								    								  3:5: note:   template argument deduction/substitut
							      								    								  ion failed: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITE
							      								    								  RATIVE_AND_RECURSIVE.cpp:39:51: note:	  ‘std::__cx
							      								    								  x11::string’ {aka ‘std::__cxx11::basic_string<char
							      								    								  >’} is not derived from ‘const std::shared_ptr<_Tp
							      								    								  >’	      if(f_filled(param0[i]) == f_gold(param
							      								    								  0[i]))
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /memory:81,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:82,
							      								    								  	  from FIRST_UPPERCASE_LETTER_IN_A_STRING_IT
							      								    								  ERATIVE_AND_RECURSIVE.cpp:14: /usr/include/c++/8/b
							      								    								  its/shared_ptr.h:388:5: note: candidate: ‘template
							      								    								  <class _Tp> bool std::operator==(const std::shared
							      								    								  _ptr<_Tp>&, std::nullptr_t)’	    operator==(const
							      								    								   shared_ptr<_Tp>& __a, nullptr_t) noexcept	  ^~
							      								    								  ~~~~~~ /usr/include/c++/8/bits/shared_ptr.h:388:5:
							      								    								   note:   template argument deduction/substitution
							      								    								  failed: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATI
							      								    								  VE_AND_RECURSIVE.cpp:39:51: note:   ‘std::__cxx11:
							      								    								  :string’ {aka ‘std::__cxx11::basic_string<char>’}
							      								    								  is not derived from ‘const std::shared_ptr<_Tp>’
							      								    								  	  if(f_filled(param0[i]) == f_gold(param0[i]
							      								    								  ))
							      								    								      ^ In file included from /usr/include/c++/8/mem
							      								    								  ory:81,		   from /usr/include/c++/8/x
							      								    								  86_64-redhat-linux/bits/stdc++.h:82,
							      								    								      from FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERAT
							      								    								  IVE_AND_RECURSIVE.cpp:14: /usr/include/c++/8/bits/
							      								    								  shared_ptr.h:393:5: note: candidate: ‘template<cla
							      								    								  ss _Tp> bool std::operator==(std::nullptr_t, const
							      								    								   std::shared_ptr<_Tp>&)’	operator==(nullptr_t
							      								    								  , const shared_ptr<_Tp>& __a) noexcept      ^~~~~~
							      								    								  ~~ /usr/include/c++/8/bits/shared_ptr.h:393:5: not
							      								    								  e:   template argument deduction/substitution fail
							      								    								  ed: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_A
							      								    								  ND_RECURSIVE.cpp:39:51: note:	  mismatched types ‘
							      								    								  const std::shared_ptr<_Tp>’ and ‘char’	  if
							      								    								  (f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/queue:64,
							      								    								  		from /usr/include/c++/8/x86_64-redha
							      								    								  t-linux/bits/stdc++.h:86,		     from FI
							      								    								  RST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_REC
							      								    								  URSIVE.cpp:14: /usr/include/c++/8/bits/stl_queue.h
							      								    								  :330:5: note: candidate: ‘template<class _Tp, clas
							      								    								  s _Seq> bool std::operator==(const std::queue<_Tp,
							      								    								   _Seq>&, const std::queue<_Tp, _Seq>&)’      opera
							      								    								  tor==(const queue<_Tp, _Seq>& __x, const queue<_Tp
							      								    								  , _Seq>& __y)	     ^~~~~~~~ /usr/include/c++/8/bit
							      								    								  s/stl_queue.h:330:5: note:   template argument ded
							      								    								  uction/substitution failed: FIRST_UPPERCASE_LETTER
							      								    								  _IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: no
							      								    								  te:	‘std::__cxx11::string’ {aka ‘std::__cxx11::b
							      								    								  asic_string<char>’} is not derived from ‘const std
							      								    								  ::queue<_Tp, _Seq>’	       if(f_filled(param0[i]
							      								    								  ) == f_gold(param0[i]))
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/set:61,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :87,			from FIRST_UPPERCASE_LETTER_
							      								    								  IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/i
							      								    								  nclude/c++/8/bits/stl_set.h:958:5: note: candidate
							      								    								  : ‘template<class _Key, class _Compare, class _All
							      								    								  oc> bool std::operator==(const std::set<_Key, _Com
							      								    								  pare, _Alloc>&, const std::set<_Key, _Compare, _Al
							      								    								  loc>&)’      operator==(const set<_Key, _Compare,
							      								    								  _Alloc>& __x,	     ^~~~~~~~ /usr/include/c++/8/bit
							      								    								  s/stl_set.h:958:5: note:   template argument deduc
							      								    								  tion/substitution failed: FIRST_UPPERCASE_LETTER_I
							      								    								  N_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: note
							      								    								  :   ‘std::__cxx11::string’ {aka ‘std::__cxx11::bas
							      								    								  ic_string<char>’} is not derived from ‘const std::
							      								    								  set<_Key, _Compare, _Alloc>’		if(f_filled(
							      								    								  param0[i]) == f_gold(param0[i]))
							      								    								  				    ^ In file includ
							      								    								  ed from /usr/include/c++/8/set:62,
							      								    								    from /usr/include/c++/8/x86_64-redhat-linux/bits
							      								    								  /stdc++.h:87,			 from FIRST_UPPERCAS
							      								    								  E_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:1
							      								    								  4: /usr/include/c++/8/bits/stl_multiset.h:943:5: n
							      								    								  ote: candidate: ‘template<class _Key, class _Compa
							      								    								  re, class _Alloc> bool std::operator==(const std::
							      								    								  multiset<_Key, _Compare, _Alloc>&, const std::mult
							      								    								  iset<_Key, _Compare, _Alloc>&)’      operator==(co
							      								    								  nst multiset<_Key, _Compare, _Alloc>& __x,	  ^~
							      								    								  ~~~~~~ /usr/include/c++/8/bits/stl_multiset.h:943:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERA
							      								    								  TIVE_AND_RECURSIVE.cpp:39:51: note:	‘std::__cxx1
							      								    								  1::string’ {aka ‘std::__cxx11::basic_string<char>’
							      								    								  } is not derived from ‘const std::multiset<_Key, _
							      								    								  Compare, _Alloc>’	     if(f_filled(param0[i])
							      								    								  == f_gold(param0[i]))
							      								    								  			 ^ In file included from /us
							      								    								  r/include/c++/8/stack:61,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :89,			from FIRST_UPPERCASE_LETTER_
							      								    								  IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/i
							      								    								  nclude/c++/8/bits/stl_stack.h:305:5: note: candida
							      								    								  te: ‘template<class _Tp, class _Seq> bool std::ope
							      								    								  rator==(const std::stack<_Tp, _Seq>&, const std::s
							      								    								  tack<_Tp, _Seq>&)’	  operator==(const stack<_Tp
							      								    								  , _Seq>& __x, const stack<_Tp, _Seq>& __y)	  ^~
							      								    								  ~~~~~~ /usr/include/c++/8/bits/stl_stack.h:305:5:
							      								    								  note:	  template argument deduction/substitution f
							      								    								  ailed: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIV
							      								    								  E_AND_RECURSIVE.cpp:39:51: note:   ‘std::__cxx11::
							      								    								  string’ {aka ‘std::__cxx11::basic_string<char>’} i
							      								    								  s not derived from ‘const std::stack<_Tp, _Seq>’
							      								    								  	  if(f_filled(param0[i]) == f_gold(param0[i]
							      								    								  ))
							      								    								      ^ In file included from /usr/include/c++/8/val
							      								    								  array:592,		      from /usr/include/c++/
							      								    								  8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  	 from FIRST_UPPERCASE_LETTER_IN_A_STRING_ITE
							      								    								  RATIVE_AND_RECURSIVE.cpp:14: /usr/include/c++/8/bi
							      								    								  ts/valarray_after.h:414:5: note: candidate: ‘templ
							      								    								  ate<class _Dom1, class _Dom2> std::_Expr<std::_Bin
							      								    								  Clos<std::__equal_to, std::_Expr, std::_Expr, _Dom
							      								    								  1, _Dom2>, typename std::__fun<std::__equal_to, ty
							      								    								  pename _Dom1::value_type>::result_type> std::opera
							      								    								  tor==(const std::_Expr<_Dom1, typename _Dom1::valu
							      								    								  e_type>&, const std::_Expr<_Dom2, typename _Dom2::
							      								    								  value_type>&)’      _DEFINE_EXPR_BINARY_OPERATOR(=
							      								    								  =, __equal_to)      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /
							      								    								  usr/include/c++/8/bits/valarray_after.h:414:5: not
							      								    								  e:   template argument deduction/substitution fail
							      								    								  ed: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_A
							      								    								  ND_RECURSIVE.cpp:39:51: note:	  ‘std::__cxx11::str
							      								    								  ing’ {aka ‘std::__cxx11::basic_string<char>’} is n
							      								    								  ot derived from ‘const std::_Expr<_Dom1, typename
							      								    								  _Dom1::value_type>’	       if(f_filled(param0[i]
							      								    								  ) == f_gold(param0[i]))
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/valarray:592,		   f
							      								    								  rom /usr/include/c++/8/x86_64-redhat-linux/bits/st
							      								    								  dc++.h:95,		      from FIRST_UPPERCASE_L
							      								    								  ETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14:
							      								    								  /usr/include/c++/8/bits/valarray_after.h:414:5: no
							      								    								  te: candidate: ‘template<class _Dom> std::_Expr<st
							      								    								  d::_BinClos<std::__equal_to, std::_Expr, std::_Con
							      								    								  stant, _Dom, typename _Dom::value_type>, typename
							      								    								  std::__fun<std::__equal_to, typename _Dom1::value_
							      								    								  type>::result_type> std::operator==(const std::_Ex
							      								    								  pr<_Dom1, typename _Dom1::value_type>&, const type
							      								    								  name _Dom::value_type&)’	_DEFINE_EXPR_BINARY_
							      								    								  OPERATOR(==, __equal_to)	^~~~~~~~~~~~~~~~~~~~
							      								    								  ~~~~~~~~ /usr/include/c++/8/bits/valarray_after.h:
							      								    								  414:5: note:	 template argument deduction/substit
							      								    								  ution failed: FIRST_UPPERCASE_LETTER_IN_A_STRING_I
							      								    								  TERATIVE_AND_RECURSIVE.cpp:39:51: note:   ‘std::__
							      								    								  cxx11::string’ {aka ‘std::__cxx11::basic_string<ch
							      								    								  ar>’} is not derived from ‘const std::_Expr<_Dom1,
							      								    								   typename _Dom1::value_type>’		 if(f_filled
							      								    								  (param0[i]) == f_gold(param0[i]))
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/valarray:592,
							      								    								  	   from /usr/include/c++/8/x86_64-redhat-lin
							      								    								  ux/bits/stdc++.h:95,			from FIRST_U
							      								    								  PPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIV
							      								    								  E.cpp:14: /usr/include/c++/8/bits/valarray_after.h
							      								    								  :414:5: note: candidate: ‘template<class _Dom> std
							      								    								  ::_Expr<std::_BinClos<std::__equal_to, std::_Const
							      								    								  ant, std::_Expr, typename _Dom::value_type, _Dom>,
							      								    								   typename std::__fun<std::__equal_to, typename _Do
							      								    								  m1::value_type>::result_type> std::operator==(cons
							      								    								  t typename _Dom::value_type&, const std::_Expr<_Do
							      								    								  m1, typename _Dom1::value_type>&)’	  _DEFINE_EX
							      								    								  PR_BINARY_OPERATOR(==, __equal_to)	  ^~~~~~~~~~
							      								    								  ~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/bits/valarra
							      								    								  y_after.h:414:5: note:   template argument deducti
							      								    								  on/substitution failed: FIRST_UPPERCASE_LETTER_IN_
							      								    								  A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:
							      								    								    mismatched types ‘const std::_Expr<_Dom1, typena
							      								    								  me _Dom1::value_type>’ and ‘char’	     if(f_fi
							      								    								  lled(param0[i]) == f_gold(param0[i]))
							      								    								  					 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/valarray:592,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:95,		    from FIR
							      								    								  ST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECU
							      								    								  RSIVE.cpp:14: /usr/include/c++/8/bits/valarray_aft
							      								    								  er.h:414:5: note: candidate: ‘template<class _Dom>
							      								    								   std::_Expr<std::_BinClos<std::__equal_to, std::_E
							      								    								  xpr, std::_ValArray, _Dom, typename _Dom::value_ty
							      								    								  pe>, typename std::__fun<std::__equal_to, typename
							      								    								   _Dom1::value_type>::result_type> std::operator==(
							      								    								  const std::_Expr<_Dom1, typename _Dom1::value_type
							      								    								  >&, const std::valarray<typename _Dom::value_type>
							      								    								  &)’	   _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_
							      								    								  to)	   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/include
							      								    								  /c++/8/bits/valarray_after.h:414:5: note:   templa
							      								    								  te argument deduction/substitution failed: FIRST_U
							      								    								  PPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIV
							      								    								  E.cpp:39:51: note:   ‘std::__cxx11::string’ {aka ‘
							      								    								  std::__cxx11::basic_string<char>’} is not derived
							      								    								  from ‘const std::_Expr<_Dom1, typename _Dom1::valu
							      								    								  e_type>’	    if(f_filled(param0[i]) == f_gold
							      								    								  (param0[i]))
							      								    								  		^ In file included from /usr/include
							      								    								  /c++/8/valarray:592,			from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  		   from FIRST_UPPERCASE_LETTER_IN_A_
							      								    								  STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/includ
							      								    								  e/c++/8/bits/valarray_after.h:414:5: note: candida
							      								    								  te: ‘template<class _Dom> std::_Expr<std::_BinClos
							      								    								  <std::__equal_to, std::_ValArray, std::_Expr, type
							      								    								  name _Dom::value_type, _Dom>, typename std::__fun<
							      								    								  std::__equal_to, typename _Dom1::value_type>::resu
							      								    								  lt_type> std::operator==(const std::valarray<typen
							      								    								  ame _Dom::value_type>&, const std::_Expr<_Dom1, ty
							      								    								  pename _Dom1::value_type>&)’	    _DEFINE_EXPR_BIN
							      								    								  ARY_OPERATOR(==, __equal_to)	    ^~~~~~~~~~~~~~~~
							      								    								  ~~~~~~~~~~~~ /usr/include/c++/8/bits/valarray_afte
							      								    								  r.h:414:5: note:   template argument deduction/sub
							      								    								  stitution failed: FIRST_UPPERCASE_LETTER_IN_A_STRI
							      								    								  NG_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:	mism
							      								    								  atched types ‘const std::_Expr<_Dom1, typename _Do
							      								    								  m1::value_type>’ and ‘char’	       if(f_filled(p
							      								    								  aram0[i]) == f_gold(param0[i]))
							      								    								  				   ^ In file include
							      								    								  d from /usr/include/c++/8/x86_64-redhat-linux/bits
							      								    								  /stdc++.h:95,			 from FIRST_UPPERCAS
							      								    								  E_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:1
							      								    								  4: /usr/include/c++/8/valarray:1184:1: note: candi
							      								    								  date: ‘template<class _Tp> std::_Expr<std::_BinClo
							      								    								  s<std::__equal_to, std::_ValArray, std::_ValArray,
							      								    								   _Tp, _Tp>, typename std::__fun<std::__equal_to, _
							      								    								  Tp>::result_type> std::operator==(const std::valar
							      								    								  ray<_Tp>&, const std::valarray<_Tp>&)’  _DEFINE_BI
							      								    								  NARY_OPERATOR(==, __equal_to)	 ^~~~~~~~~~~~~~~~~~~
							      								    								  ~~~~ /usr/include/c++/8/valarray:1184:1: note:   t
							      								    								  emplate argument deduction/substitution failed: FI
							      								    								  RST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_REC
							      								    								  URSIVE.cpp:39:51: note:   ‘std::__cxx11::string’ {
							      								    								  aka ‘std::__cxx11::basic_string<char>’} is not der
							      								    								  ived from ‘const std::valarray<_Tp>’		if(f
							      								    								  _filled(param0[i]) == f_gold(param0[i]))
							      								    								  					    ^ In fil
							      								    								  e included from /usr/include/c++/8/x86_64-redhat-l
							      								    								  inux/bits/stdc++.h:95,		  from FIRST
							      								    								  _UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURS
							      								    								  IVE.cpp:14: /usr/include/c++/8/valarray:1184:1: no
							      								    								  te: candidate: ‘template<class _Tp> std::_Expr<std
							      								    								  ::_BinClos<std::__equal_to, std::_ValArray, std::_
							      								    								  Constant, _Tp, _Tp>, typename std::__fun<std::__eq
							      								    								  ual_to, _Tp>::result_type> std::operator==(const s
							      								    								  td::valarray<_Tp>&, const _Tp&)’  _DEFINE_BINARY_O
							      								    								  PERATOR(==, __equal_to)  ^~~~~~~~~~~~~~~~~~~~~~~ /
							      								    								  usr/include/c++/8/valarray:1184:1: note:   templat
							      								    								  e argument deduction/substitution failed: FIRST_UP
							      								    								  PERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE
							      								    								  .cpp:39:51: note:   ‘std::__cxx11::string’ {aka ‘s
							      								    								  td::__cxx11::basic_string<char>’} is not derived f
							      								    								  rom ‘const std::valarray<_Tp>’	  if(f_fille
							      								    								  d(param0[i]) == f_gold(param0[i]))
							      								    								  				      ^ In file incl
							      								    								  uded from /usr/include/c++/8/x86_64-redhat-linux/b
							      								    								  its/stdc++.h:95,		    from FIRST_UPPER
							      								    								  CASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cp
							      								    								  p:14: /usr/include/c++/8/valarray:1184:1: note: ca
							      								    								  ndidate: ‘template<class _Tp> std::_Expr<std::_Bin
							      								    								  Clos<std::__equal_to, std::_Constant, std::_ValArr
							      								    								  ay, _Tp, _Tp>, typename std::__fun<std::__equal_to
							      								    								  , _Tp>::result_type> std::operator==(const _Tp&, c
							      								    								  onst std::valarray<_Tp>&)’  _DEFINE_BINARY_OPERATO
							      								    								  R(==, __equal_to)  ^~~~~~~~~~~~~~~~~~~~~~~ /usr/in
							      								    								  clude/c++/8/valarray:1184:1: note:   template argu
							      								    								  ment deduction/substitution failed: FIRST_UPPERCAS
							      								    								  E_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:3
							      								    								  9:51: note:	mismatched types ‘const std::valarra
							      								    								  y<_Tp>’ and ‘char’	      if(f_filled(param0[i])
							      								    								   == f_gold(param0[i]))
							      								    								  			  ^ In file included from /u
							      								    								  sr/include/c++/8/forward_list:38,
							      								    								   from /usr/include/c++/8/x86_64-redhat-linux/bits/
							      								    								  stdc++.h:104,			 from FIRST_UPPERCAS
							      								    								  E_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:1
							      								    								  4: /usr/include/c++/8/bits/forward_list.h:272:5: n
							      								    								  ote: candidate: ‘template<class _Tp> bool std::ope
							      								    								  rator==(const std::_Fwd_list_iterator<_Tp>&, const
							      								    								   std::_Fwd_list_const_iterator<_Tp>&)’      operat
							      								    								  or==(const _Fwd_list_iterator<_Tp>& __x,	^~~~
							      								    								  ~~~~ /usr/include/c++/8/bits/forward_list.h:272:5:
							      								    								   note:   template argument deduction/substitution
							      								    								  failed: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATI
							      								    								  VE_AND_RECURSIVE.cpp:39:51: note:   ‘std::__cxx11:
							      								    								  :string’ {aka ‘std::__cxx11::basic_string<char>’}
							      								    								  is not derived from ‘const std::_Fwd_list_iterator
							      								    								  <_Tp>’	  if(f_filled(param0[i]) == f_gold(p
							      								    								  aram0[i]))
							      								    								  	      ^ In file included from /usr/include/c
							      								    								  ++/8/forward_list:40,			 from /usr/i
							      								    								  nclude/c++/8/x86_64-redhat-linux/bits/stdc++.h:104
							      								    								  ,		     from FIRST_UPPERCASE_LETTER_IN_
							      								    								  A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/incl
							      								    								  ude/c++/8/bits/forward_list.tcc:369:5: note: candi
							      								    								  date: ‘template<class _Tp, class _Alloc> bool std:
							      								    								  :operator==(const std::forward_list<_Tp, _Alloc>&,
							      								    								   const std::forward_list<_Tp, _Alloc>&)’	oper
							      								    								  ator==(const forward_list<_Tp, _Alloc>& __lx,
							      								    								   ^~~~~~~~ /usr/include/c++/8/bits/forward_list.tcc
							      								    								  :369:5: note:	  template argument deduction/substi
							      								    								  tution failed: FIRST_UPPERCASE_LETTER_IN_A_STRING_
							      								    								  ITERATIVE_AND_RECURSIVE.cpp:39:51: note:   ‘std::_
							      								    								  _cxx11::string’ {aka ‘std::__cxx11::basic_string<c
							      								    								  har>’} is not derived from ‘const std::forward_lis
							      								    								  t<_Tp, _Alloc>’	   if(f_filled(param0[i]) ==
							      								    								   f_gold(param0[i]))
							      								    								  		       ^ In file included from /usr/
							      								    								  include/c++/8/future:39,		    from /us
							      								    								  r/include/c++/8/x86_64-redhat-linux/bits/stdc++.h:
							      								    								  105,			from FIRST_UPPERCASE_LETTER_
							      								    								  IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/i
							      								    								  nclude/c++/8/thread:277:3: note: candidate: ‘bool
							      								    								  std::operator==(std::thread::id, std::thread::id)’
							      								    								      operator==(thread::id __x, thread::id __y) noe
							      								    								  xcept	   ^~~~~~~~ /usr/include/c++/8/thread:277:3:
							      								    								   note:   no known conversion for argument 1 from ‘
							      								    								  std::__cxx11::string’ {aka ‘std::__cxx11::basic_st
							      								    								  ring<char>’} to ‘std::thread::id’ In file included
							      								    								   from /usr/include/c++/8/random:51,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:108,		   from FIRST_UPPERC
							      								    								  ASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp
							      								    								  :14: /usr/include/c++/8/bits/random.tcc:1881:5: no
							      								    								  te: candidate: ‘template<class _RealType1> bool st
							      								    								  d::operator==(const std::normal_distribution<_Real
							      								    								  Type>&, const std::normal_distribution<_RealType>&
							      								    								  )’	  operator==(const std::normal_distribution<
							      								    								  _RealType>& __d1,	 ^~~~~~~~ /usr/include/c++/8
							      								    								  /bits/random.tcc:1881:5: note:   template argument
							      								    								   deduction/substitution failed: FIRST_UPPERCASE_LE
							      								    								  TTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51
							      								    								  : note:   ‘std::__cxx11::string’ {aka ‘std::__cxx1
							      								    								  1::basic_string<char>’} is not derived from ‘const
							      								    								   std::normal_distribution<_RealType>’		 if(
							      								    								  f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  					     ^ In fi
							      								    								  le included from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:111,		    from FIR
							      								    								  ST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECU
							      								    								  RSIVE.cpp:14: /usr/include/c++/8/scoped_allocator:
							      								    								  459:5: note: candidate: ‘template<class _OutA1, cl
							      								    								  ass _OutA2, class ... _InA> bool std::operator==(c
							      								    								  onst std::scoped_allocator_adaptor<_OutA1, _InA ..
							      								    								  .>&, const std::scoped_allocator_adaptor<_InnerHea
							      								    								  d, _InnerTail ...>&)’	     operator==(const scoped
							      								    								  _allocator_adaptor<_OutA1, _InA...>& __a,	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/scoped_allocator:459:5: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE
							      								    								  _AND_RECURSIVE.cpp:39:51: note:   ‘std::__cxx11::s
							      								    								  tring’ {aka ‘std::__cxx11::basic_string<char>’} is
							      								    								   not derived from ‘const std::scoped_allocator_ada
							      								    								  ptor<_OutA1, _InA ...>’	   if(f_filled(param
							      								    								  0[i]) == f_gold(param0[i]))
							      								    								  			       ^ In file included fr
							      								    								  om /usr/include/c++/8/unordered_map:47,
							      								    								  	 from /usr/include/c++/8/x86_64-redhat-linux
							      								    								  /bits/stdc++.h:117,		       from FIRST_UP
							      								    								  PERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE
							      								    								  .cpp:14: /usr/include/c++/8/bits/unordered_map.h:2
							      								    								  057:5: note: candidate: ‘template<class _Key, clas
							      								    								  s _Tp, class _Hash, class _Pred, class _Alloc> boo
							      								    								  l std::operator==(const std::unordered_map<_Key, _
							      								    								  Tp, _Hash, _Pred, _Alloc>&, const std::unordered_m
							      								    								  ap<_Key, _Tp, _Hash, _Pred, _Alloc>&)’      operat
							      								    								  or==(const unordered_map<_Key, _Tp, _Hash, _Pred,
							      								    								  _Alloc>& __x,	     ^~~~~~~~ /usr/include/c++/8/bit
							      								    								  s/unordered_map.h:2057:5: note:   template argumen
							      								    								  t deduction/substitution failed: FIRST_UPPERCASE_L
							      								    								  ETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:5
							      								    								  1: note:   ‘std::__cxx11::string’ {aka ‘std::__cxx
							      								    								  11::basic_string<char>’} is not derived from ‘cons
							      								    								  t std::unordered_map<_Key, _Tp, _Hash, _Pred, _All
							      								    								  oc>’		if(f_filled(param0[i]) == f_gold(par
							      								    								  am0[i]))
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/unordered_map:47,			from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:117,
							      								    								  		    from FIRST_UPPERCASE_LETTER_IN_A
							      								    								  _STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/inclu
							      								    								  de/c++/8/bits/unordered_map.h:2069:5: note: candid
							      								    								  ate: ‘template<class _Key, class _Tp, class _Hash,
							      								    								   class _Pred, class _Alloc> bool std::operator==(c
							      								    								  onst std::unordered_multimap<_Key, _Tp, _Hash, _Pr
							      								    								  ed, _Alloc>&, const std::unordered_multimap<_Key,
							      								    								  _Tp, _Hash, _Pred, _Alloc>&)’	     operator==(cons
							      								    								  t unordered_multimap<_Key, _Tp, _Hash, _Pred, _All
							      								    								  oc>& __x,	 ^~~~~~~~ /usr/include/c++/8/bits/un
							      								    								  ordered_map.h:2069:5: note:	template argument de
							      								    								  duction/substitution failed: FIRST_UPPERCASE_LETTE
							      								    								  R_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: n
							      								    								  ote:	 ‘std::__cxx11::string’ {aka ‘std::__cxx11::
							      								    								  basic_string<char>’} is not derived from ‘const st
							      								    								  d::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Al
							      								    								  loc>’		 if(f_filled(param0[i]) == f_gold(pa
							      								    								  ram0[i]))
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/unordered_set:47,			 from /usr/i
							      								    								  nclude/c++/8/x86_64-redhat-linux/bits/stdc++.h:118
							      								    								  ,		     from FIRST_UPPERCASE_LETTER_IN_
							      								    								  A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14: /usr/incl
							      								    								  ude/c++/8/bits/unordered_set.h:1669:5: note: candi
							      								    								  date: ‘template<class _Value, class _Hash, class _
							      								    								  Pred, class _Alloc> bool std::operator==(const std
							      								    								  ::unordered_set<_Value, _Hash, _Pred, _Alloc>&, co
							      								    								  nst std::unordered_set<_Value, _Hash, _Pred, _Allo
							      								    								  c>&)’	     operator==(const unordered_set<_Value,
							      								    								  _Hash, _Pred, _Alloc>& __x,	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/unordered_set.h:1669:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: FIR
							      								    								  ST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECU
							      								    								  RSIVE.cpp:39:51: note:   ‘std::__cxx11::string’ {a
							      								    								  ka ‘std::__cxx11::basic_string<char>’} is not deri
							      								    								  ved from ‘const std::unordered_set<_Value, _Hash,
							      								    								  _Pred, _Alloc>’	   if(f_filled(param0[i]) ==
							      								    								   f_gold(param0[i]))
							      								    								  		       ^ In file included from /usr/
							      								    								  include/c++/8/unordered_set:47,		   f
							      								    								  rom /usr/include/c++/8/x86_64-redhat-linux/bits/st
							      								    								  dc++.h:118,		       from FIRST_UPPERCASE_
							      								    								  LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:14:
							      								    								   /usr/include/c++/8/bits/unordered_set.h:1681:5: n
							      								    								  ote: candidate: ‘template<class _Value, class _Has
							      								    								  h, class _Pred, class _Alloc> bool std::operator==
							      								    								  (const std::unordered_multiset<_Value, _Hash, _Pre
							      								    								  d, _Alloc>&, const std::unordered_multiset<_Value,
							      								    								   _Hash, _Pred, _Alloc>&)’	 operator==(const un
							      								    								  ordered_multiset<_Value, _Hash, _Pred, _Alloc>& __
							      								    								  x,	  ^~~~~~~~ /usr/include/c++/8/bits/unordered
							      								    								  _set.h:1681:5: note:	 template argument deduction
							      								    								  /substitution failed: FIRST_UPPERCASE_LETTER_IN_A_
							      								    								  STRING_ITERATIVE_AND_RECURSIVE.cpp:39:51: note:
							      								    								  ‘std::__cxx11::string’ {aka ‘std::__cxx11::basic_s
							      								    								  tring<char>’} is not derived from ‘const std::unor
							      								    								  dered_multiset<_Value, _Hash, _Pred, _Alloc>’
							      								    								       if(f_filled(param0[i]) == f_gold(param0[i]))
							      								    								  
							      								    								   ^ In file included from /usr/include/c++/8/bits/s
							      								    								  tl_algobase.h:67,		     from /usr/inclu
							      								    								  de/c++/8/bits/char_traits.h:39,		   f
							      								    								  rom /usr/include/c++/8/ios:40,		  fr
							      								    								  om /usr/include/c++/8/ostream:38,
							      								    								   from /usr/include/c++/8/iostream:39,
							      								    								       from FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERA
							      								    								  TIVE_AND_RECURSIVE.cpp:8: /usr/include/c++/8/bits/
							      								    								  stl_iterator.h:863:5: note: candidate: ‘template<c
							      								    								  lass _IteratorL, class _IteratorR, class _Containe
							      								    								  r> bool __gnu_cxx::operator==(const __gnu_cxx::__n
							      								    								  ormal_iterator<_IteratorL, _Container>&, const __g
							      								    								  nu_cxx::__normal_iterator<_IteratorR, _Container>&
							      								    								  )’	  operator==(const __normal_iterator<_Iterat
							      								    								  orL, _Container>& __lhs,	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/stl_iterator.h:863:5: note:   templat
							      								    								  e argument deduction/substitution failed: FIRST_UP
							      								    								  PERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE
							      								    								  .cpp:39:51: note:   ‘std::__cxx11::string’ {aka ‘s
							      								    								  td::__cxx11::basic_string<char>’} is not derived f
							      								    								  rom ‘const __gnu_cxx::__normal_iterator<_IteratorL
							      								    								  , _Container>’	  if(f_filled(param0[i]) ==
							      								    								  f_gold(param0[i]))
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/bits/stl_algobase.h:67,
							      								    								      from /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  		    from /usr/include/c++/8/ios:40,
							      								    								  		   from /usr/include/c++/8/ostream:3
							      								    								  8,		      from /usr/include/c++/8/iostre
							      								    								  am:39,		  from FIRST_UPPERCASE_LETTE
							      								    								  R_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cpp:8: /usr/
							      								    								  include/c++/8/bits/stl_iterator.h:870:5: note: can
							      								    								  didate: ‘template<class _Iterator, class _Containe
							      								    								  r> bool __gnu_cxx::operator==(const __gnu_cxx::__n
							      								    								  ormal_iterator<_Iterator, _Container>&, const __gn
							      								    								  u_cxx::__normal_iterator<_Iterator, _Container>&)’
							      								    								  	operator==(const __normal_iterator<_Iterator
							      								    								  , _Container>& __lhs,	     ^~~~~~~~ /usr/include/c
							      								    								  ++/8/bits/stl_iterator.h:870:5: note:	  template a
							      								    								  rgument deduction/substitution failed: FIRST_UPPER
							      								    								  CASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE.cp
							      								    								  p:39:51: note:   ‘std::__cxx11::string’ {aka ‘std:
							      								    								  :__cxx11::basic_string<char>’} is not derived from
							      								    								   ‘const __gnu_cxx::__normal_iterator<_Iterator, _C
							      								    								  ontainer>’	      if(f_filled(param0[i]) == f_go
							      								    								  ld(param0[i]))
							      								    								  		  ^ In file included from /usr/inclu
							      								    								  de/c++/8/x86_64-redhat-linux/bits/c++allocator.h:3
							      								    								  3,		      from /usr/include/c++/8/bits/a
							      								    								  llocator.h:46,		  from /usr/include/
							      								    								  c++/8/string:41,		    from /usr/includ
							      								    								  e/c++/8/bits/locale_classes.h:40,
							      								    								   from /usr/include/c++/8/bits/ios_base.h:41,
							      								    								  	      from /usr/include/c++/8/ios:42,
							      								    								  	     from /usr/include/c++/8/ostream:38,
							      								    								  		from /usr/include/c++/8/iostream:39,
							      								    								  		    from FIRST_UPPERCASE_LETTER_IN_A
							      								    								  _STRING_ITERATIVE_AND_RECURSIVE.cpp:8: /usr/includ
							      								    								  e/c++/8/ext/new_allocator.h:155:5: note: candidate
							      								    								  : ‘template<class _Tp> bool __gnu_cxx::operator==(
							      								    								  const __gnu_cxx::new_allocator<_Tp>&, const __gnu_
							      								    								  cxx::new_allocator<_Tp>&)’	  operator==(const n
							      								    								  ew_allocator<_Tp>&, const new_allocator<_Tp>&)
							      								    								    ^~~~~~~~ /usr/include/c++/8/ext/new_allocator.h:
							      								    								  155:5: note:	 template argument deduction/substit
							      								    								  ution failed: FIRST_UPPERCASE_LETTER_IN_A_STRING_I
							      								    								  TERATIVE_AND_RECURSIVE.cpp:39:51: note:   ‘std::__
							      								    								  cxx11::string’ {aka ‘std::__cxx11::basic_string<ch
							      								    								  ar>’} is not derived from ‘const __gnu_cxx::new_al
							      								    								  locator<_Tp>’		 if(f_filled(param0[i]) == f
							      								    								  _gold(param0[i]))
							      								    								  		     ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY_2
--							      --							    --								  --
def find_extra_element_index ( arrA , arrB ) :		      int find_extra_element_index ( int arrA [ ] , int arrB [ ] ,  int findExtraElementIndex ( int * arrA , int * arrB ) {	  script_not_found : None
    extra_element = sum ( arrA ) - sum ( arrB )		      	int extra_element = sum ( arrA , n ) - sum ( arrB , m ) ;     int extraElement = std :: distance ( arrA , arrB ) - std :: 
    return arrA.index ( extra_element )			      	return indexOf ( arrA , extra_element , n ) ;		      return arrA [ extraElement ] ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		      SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		    SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX		  SUM_DIAGONALS_SPIRAL_ODD_ORDER_SQUARE_MATRIX
--							      --							    --								  --
def spiralDiaSum ( n ) :				      int spiralDiaSum ( int n ) {				    int spiralDiaSum ( int n ) {				  script_not_found : None
    if n == 1 :						      	if ( n == 1 ) return 1 ;				      if ( n == 1 ) return 1 ;					  
	return 1					      	return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ;   return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; 
    return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION_1			      PROGRAM_DECIMAL_BINARY_CONVERSION_1			    PROGRAM_DECIMAL_BINARY_CONVERSION_1				  PROGRAM_DECIMAL_BINARY_CONVERSION_1
--							      --							    --								  --
def decToBinary ( n ) :					      int decToBinary ( int n ) {				    void decToBinary ( int n ) {				  script_not_found : None
    for i in range ( 31 , - 1 , - 1 ) :			      	for ( int i = 31 ;					      for ( int i = 31 ;					  
	k = n >> i					      	i >= 0 ;						      i >= 0 ;							  
	if ( k & 1 ) :					      	i -- ) {						      -- i ) {							  
	    print ( "1" , end = "" )			      	  int k = n >> i ;					    	int k = n >> i ;					  
	else :						      	  if ( k & 1 ) cout << "1" ;				    	if ( ( k & 1 ) != 0 ) cout << "1" << endl ;		  
	    print ( "0" , end = "" )			      	  else cout << "0" ;					    	else cout << "0" << endl ;				  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS	      ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS		    ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS		  ANALYSIS_OF_ALGORITHMS_SET_2_ASYMPTOTIC_ANALYSIS
--							      --							    --								  --
def search ( arr , n , x ) :				      int search ( int arr [ ] , int n , int x ) {		    int search ( int * arr , int n , int x ) {			  success : None
    i = 0						      	int i ;							      int i ;							  
    for i in range ( i , n ) :				      	for ( i = 0 ;						      for ( i = 0 ;						  
	if ( arr [ i ] == x ) :				      	i < n ;							      i < n ;							  
	    return i					      	i ++ ) {						      i ++ ) if ( ( arr [ i ] == x ) ) return i ;		  
    return - 1						      	  if ( arr [ i ] == x ) return i ;			      return - 1 ;						  
							      	}							    }								  
							      	return - 1 ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSITION_OF_RIGHTMOST_SET_BIT_2				      POSITION_OF_RIGHTMOST_SET_BIT_2				    POSITION_OF_RIGHTMOST_SET_BIT_2				  POSITION_OF_RIGHTMOST_SET_BIT_2
--							      --							    --								  --
def Right_most_setbit ( num ) :				      int Right_most_setbit ( int num ) {			    int Right_most_setbit ( int num ) {				  script_not_found : None
    pos = 1						      	int pos = 1 ;						      int pos = 1 ;						  
    for i in range ( INT_SIZE ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if not ( num & ( 1 << i ) ) :			      	i < INT_SIZE ;						      i < INT_SIZE ;						  
	    pos += 1					      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( ! ( num & ( 1 << i ) ) ) pos ++ ;		    	if ( ! ( num & ( 1 << i ) ) ) pos ++ ;			  
	    break					      	  else break ;						    	else break ;						  
    return pos						      	}							      }								  
							      	return pos ;						      return pos ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	      SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	    SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS	  SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS
--							      --							    --								  --
def smallest ( x , y , z ) :				      int smallest ( int x , int y , int z ) {			    int smallest ( int x , int y , int z ) {			  success : None
    c = 0						      	int c = 0 ;						      int c = 0 ;						  
    while ( x and y and z ) :				      	while ( x && y && z ) {					      while ( ( x > 0 ) && ( y > 0 ) && ( z > 0 ) ) {		  
	x = x - 1					      	  x -- ;						    	x = x - 1 ;						  
	y = y - 1					      	  y -- ;						    	y = y - 1 ;						  
	z = z - 1					      	  z -- ;						    	z = z - 1 ;						  
	c = c + 1					      	  c ++ ;						    	c = c + 1 ;						  
    return c						      	}							      }								  
							      	return c ;						      return c ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY    COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY    COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY	  COUNT_NUMBER_OF_OCCURRENCES_OR_FREQUENCY_IN_A_SORTED_ARRAY
--							      --							    --								  --
def countOccurrences ( arr , n , x ) :			      int countOccurrences ( int arr [ ] , int n , int x ) {	    int countOccurrences ( int * arr , int n , int x ) {	  success : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if x == arr [ i ] :				      	i < n ;							      i < n ;							  
	    res += 1					      	i ++ ) if ( x == arr [ i ] ) res ++ ;			      i ++ ) {							  
    return res						      	return res ;						    	if ( x == arr [ i ] ) res ++ ;				  
							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME HOW_CAN_WE_SUM_THE_DIGITS_OF_A_GIVEN_NUMBER_IN_SINGLE_STATEME
--							      --							    --								  --
def getSum ( n ) :					      public : int getSum ( int n ) {				    int getSum ( int n ) {					  script_not_found : None
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    while ( n != 0 ) :					      	while ( n != 0 ) {					      while ( ( n != 0 ) && ( n % 10 == 0 ) ) {			  
	sum = sum + int ( n % 10 )			      	  sum = sum + n % 10 ;					    	sum = sum + ( int ) ( n % 10 ) ;			  
	n = int ( n / 10 )				      	  n = n / 10 ;						    	n = ( n / 10 ) ;					  
    return sum						      	}							      }								  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1	      SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1		    SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1		  SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_1
--							      --							    --								  --
def nextPowerOf2 ( n ) :				      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
    p = 1						      	unsigned int p = 1 ;					      int p = 1 ;						  
    if ( n and not ( n & ( n - 1 ) ) ) :		      	if ( n && ! ( n & ( n - 1 ) ) ) return n ;		      if ( ( n > 0 ) && ! ( n & ( n - 1 ) ) ) return n ;	  
	return n					      	while ( p < n ) p <<= 1 ;				      while ( ( p < n ) ) p <<= 1 ;				  
    while ( p < n ) :					      	return p ;						      return p ;						  
	p <<= 1						      }								    }								  
    return p						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_3
--							      --							    --								  --
def numberOfPaths ( m , n ) :				      int numberOfPaths ( int m , int n ) {			    int numberOfPaths ( int m , int n ) {			  failure : #Results: 0, 10
    for i in range ( n , ( m + n - 1 ) ) :		      	int path = 1 ;						      int path = 0 ;						  
	path *= i					      	for ( int i = n ;					      for ( int i = n ;						  
	path //= ( i - n + 1 )				      	i < ( m + n - 1 ) ;					      i < ( m + n - 1 ) ;					  
    return path						      	i ++ ) {						      i ++ ) {							  
							      	  path *= i ;						    	path *= i ;						  
							      	  path /= ( i - n + 1 ) ;				    	path /= ( i - n + 1 ) ;					  
							      	}							      }								  
							      	return path ;						      return path ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2	      SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2		    SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2		  SMALLEST_POWER_OF_2_GREATER_THAN_OR_EQUAL_TO_N_2
--							      --							    --								  --
def nextPowerOf2 ( n ) :				      unsigned int nextPowerOf2 ( unsigned int n ) {		    int nextPowerOf2 ( int n ) {				  success : None
    n -= 1						      	n -- ;							      n -- ;							  
    n |= n >> 1						      	n |= n >> 1 ;						      n |= n >> 1 ;						  
    n |= n >> 2						      	n |= n >> 2 ;						      n |= n >> 2 ;						  
    n |= n >> 4						      	n |= n >> 4 ;						      n |= n >> 4 ;						  
    n |= n >> 8						      	n |= n >> 8 ;						      n |= n >> 8 ;						  
    n |= n >> 16					      	n |= n >> 16 ;						      n |= n >> 16 ;						  
    n += 1						      	n ++ ;							      n ++ ;							  
    return n						      	return n ;						      return n ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			      FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			    FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2			  FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2
--							      --							    --								  --
def singleNumber ( nums ) :				      int singleNumber ( int a [ ] , int n ) {			    double singleNumber ( vector < double > nums ) {		  error : FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2.cpp:
    return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2    	unordered_set < int > s ( a , a + n ) ;			      return ( 3 * sum ( set ( nums ) ) - set ( nums ) ) / 2 ;	  In function ‘double f_filled(std::vector<double>)’
							      	int arr_sum = accumulate ( a , a + n , 0 ) ;		    }								  : FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2.cpp:25:26:
							      	int set_sum = accumulate ( s . begin ( ) , s . end ( ) , 0  								  error: missing template arguments before ‘(’ token
							      	return ( 3 * set_sum - arr_sum ) / 2 ;			    								      return ( 3 * sum ( set ( nums ) ) - set ( nums
							      }								    								   ) ) / 2 ;			       ^ FIND_THE_EL
							      								    								  EMENT_THAT_APPEARS_ONCE_2.cpp:25:16: error: ‘sum’
							      								    								  was not declared in this scope    return ( 3 * sum
							      								    								   ( set ( nums ) ) - set ( nums ) ) / 2 ;
							      								    								  	 ^~~ FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2.cp
							      								    								  p:25:16: note: suggested alternative: ‘nums’	  re
							      								    								  turn ( 3 * sum ( set ( nums ) ) - set ( nums ) ) /
							      								    								   2 ;		       ^~~		   nums FIND
							      								    								  _THE_ELEMENT_THAT_APPEARS_ONCE_2.cpp:25:43: error:
							      								    								   missing template arguments before ‘(’ token	  re
							      								    								  turn ( 3 * sum ( set ( nums ) ) - set ( nums ) ) /
							      								    								   2 ;						  ^
							      								    								  FIND_THE_ELEMENT_THAT_APPEARS_ONCE_2.cpp: In funct
							      								    								  ion ‘int main()’: FIND_THE_ELEMENT_THAT_APPEARS_ON
							      								    								  CE_2.cpp:35:21: error: could not convert ‘&(& para
							      								    								  m0.std::vector<std::vector<int> >::operator[](((st
							      								    								  d::vector<std::vector<int> >::size_type)i)))->std:
							      								    								  :vector<int>::front()’ from ‘__gnu_cxx::__alloc_tr
							      								    								  aits<std::allocator<int>, int>::value_type*’ {aka
							      								    								  ‘int*’} to ‘std::vector<double>’	    if(f_fil
							      								    								  led(&param0[i].front(),param1[i]) == f_gold(&param
							      								    								  0[i].front(),param1[i]))			^~~~
							      								    								  ~~~~~~~~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	      FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	    FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN	  FIND_HARMONIC_MEAN_USING_ARITHMETIC_MEAN_GEOMETRIC_MEAN
--							      --							    --								  --
def compute ( a , b ) :					      double compute ( int a , int b ) {			    double compute ( double a , double b ) {			  failure : #Results: 1, 10
    AM = ( a + b ) / 2					      	double AM , GM , HM ;					      double AM = ( a + b ) / 2 ;				  
    GM = math.sqrt ( a * b )				      	AM = ( a + b ) / 2 ;					      double GM = sqrt ( a * b ) ;				  
    HM = ( GM * GM ) / AM				      	GM = sqrt ( a * b ) ;					      double HM = ( GM * GM ) / AM ;				  
    return HM						      	HM = ( GM * GM ) / AM ;					      return HM ;						  
							      	return HM ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION      CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION	    CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION	  CHECK_NUMBER_IS_PERFECT_SQUARE_USING_ADDITIONSUBTRACTION
--							      --							    --								  --
def isPerfectSquare ( n ) :				      bool isPerfectSquare ( int n ) {				    bool isPerfectSquare ( int n ) {				  success : None
    i = 1						      	for ( int sum = 0 , i = 1 ;				      int i = 1 ;						  
    the_sum = 0						      	sum < n ;						      int theSum = 0 ;						  
    while the_sum < n :					      	i += 2 ) {						      while ( theSum < n ) {					  
	the_sum += i					      	  sum += i ;						    	theSum += i ;						  
	if the_sum == n :				      	  if ( sum == n ) return true ;				    	if ( theSum == n ) return true ;			  
	    return True					      	}							    	i += 2 ;						  
	i += 2						      	return false ;						      }								  
    return False					      }								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS		      SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS			    SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS			  SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS
--							      --							    --								  --
def sumBetweenTwoKth ( arr , n , k1 , k2 ) :		      int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2  double sumBetweenTwoKth ( double * arr , int n , int k1 , int script_not_found : None
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    result = 0						      	return accumulate ( arr + k1 , arr + k2 - 1 , 0 ) ;	      double result = 0 ;					  
    for i in range ( k1 , k2 - 1 ) :			      }								      for ( int i = k1 ;					  
	result += arr [ i ]				      								      i <= k2 - 1 ;						  
    return result					      								      i ++ ) result += arr [ i ] ;				  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY		      K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY			    K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY			  K_LARGESTOR_SMALLEST_ELEMENTS_IN_AN_ARRAY
--							      --							    --								  --
def kLargest ( arr , k ) :				      void kLargest ( int arr [ ] , int n , int k ) {		    int kLargest ( int * arr , int k ) {			  script_not_found : None
    arr.sort ( reverse = True )				      	sort ( arr , arr + n , greater < int > ( ) ) ;		      sort ( arr , arr + k ) ;					  
    for i in range ( k ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	print ( arr [ i ] , end = " " )			      	i < k ;							      i < k ;							  
							      	i ++ ) cout << arr [ i ] << " " ;			      i ++ ) cout << arr [ i ] << " " ;				  
							      }								      return k ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIBONACCI_MODULO_P					      FIBONACCI_MODULO_P					    FIBONACCI_MODULO_P						  FIBONACCI_MODULO_P
--							      --							    --								  --
def findMinZero ( p ) :					      int findMinZero ( int p ) {				    int findMinZero ( int p ) {					  failure : #Results: 0, 10
    first = 1						      	int first = 1 , second = 1 , number = 2 , next = 1 ;	      int first = 1 ;						  
    second = 1						      	while ( next ) {					      int second = 1 ;						  
    number = 2						      	  next = ( first + second ) % p ;			      int number = 2 ;						  
    next = 1						      	  first = second ;					      int next = 1 ;						  
    while ( next ) :					      	  second = next ;					      while ( ( next = first + second ) > p ) {			  
	next = ( first + second ) % p			      	  number ++ ;						    	next = ( first + second ) % p ;				  
	first = second					      	}							    	first = second ;					  
	second = next					      	return number ;						    	second = next ;						  
	number = number + 1				      }								    	number = number + 1 ;					  
    return number					      								      }								  
							      								      return number ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_NTH_CATALAN_NUMBER				      PROGRAM_NTH_CATALAN_NUMBER				    PROGRAM_NTH_CATALAN_NUMBER					  PROGRAM_NTH_CATALAN_NUMBER
--							      --							    --								  --
def catalan ( n ) :					      unsigned long int catalan ( unsigned int n ) {		    double catalan ( int n ) {					  script_not_found : None
    if n <= 1 :						      	if ( n <= 1 ) return 1 ;				      if ( n <= 1 ) return 1 ;					  
	return 1					      	unsigned long int res = 0 ;				      double res = 0 ;						  
    res = 0						      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( n ) :				      	i < n ;							      i < n ;							  
	res += catalan ( i ) * catalan ( n - i - 1 )	      	i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ;	      i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ;	  
    return res						      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES			      SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES			    SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES				  SQUARE_PYRAMIDAL_NUMBER_SUM_SQUARES
--							      --							    --								  --
def findS ( s ) :					      int findS ( int s ) {					    int findS ( int s ) {					  success : None
    _sum = 0						      	int sum = 0 ;						      int _sum = 0 ;						  
    n = 1						      	for ( int n = 1 ;					      int n = 1 ;						  
    while ( _sum < s ) :				      	sum < s ;						      while ( ( _sum < s ) && ( _sum < s ) ) {			  
	_sum += n * n					      	n ++ ) {						    	_sum += n * n ;						  
	n += 1						      	  sum += n * n ;					    	n ++ ;							  
    n -= 1						      	  if ( sum == s ) return n ;				      }								  
    if _sum == s :					      	}							      n -- ;							  
	return n					      	return - 1 ;						      if ( _sum == s ) return n ;				  
    return - 1						      }								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_EVEN_FIBONACCI_NUMBER				      NTH_EVEN_FIBONACCI_NUMBER					    NTH_EVEN_FIBONACCI_NUMBER					  NTH_EVEN_FIBONACCI_NUMBER
--							      --							    --								  --
def evenFib ( n ) :					      long int evenFib ( int n ) {				    int evenFib ( int n ) {					  script_not_found : None
    if ( n < 1 ) :					      	if ( n < 1 ) return n ;					      if ( ( n < 1 ) ) return n ;				  
	return n					      	if ( n == 1 ) return 2 ;				      if ( ( n == 1 ) ) return 2 ;				  
    if ( n == 1 ) :					      	return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;    return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ;  
	return 2					      }								    }								  
    return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) )  								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TRIANGULAR_NUMBERS					      TRIANGULAR_NUMBERS					    TRIANGULAR_NUMBERS						  TRIANGULAR_NUMBERS
--							      --							    --								  --
def isTriangular ( num ) :				      bool isTriangular ( int num ) {				    bool isTriangular ( int num ) {				  success : None
    if ( num < 0 ) :					      	if ( num < 0 ) return false ;				      if ( ( num < 0 ) ) return false ;				  
	return False					      	int sum = 0 ;						      int sum = 0 , n = 1 ;					  
    sum , n = 0 , 1					      	for ( int n = 1 ;					      while ( ( sum <= num ) ) {				  
    while ( sum <= num ) :				      	sum <= num ;						    	sum = sum + n ;						  
	sum = sum + n					      	n ++ ) {						    	if ( ( sum == num ) ) return true ;			  
	if ( sum == num ) :				      	  sum = sum + n ;					    	n ++ ;							  
	    return True					      	  if ( sum == num ) return true ;			      }								  
	n += 1						      	}							      return false ;						  
    return False					      	return false ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_9_NOT
--							      --							    --								  --
def check ( st ) :					      int check ( string str ) {				    bool check ( string st ) {					  failure : #Results: 5, 10
    n = len ( st )					      	int n = str . length ( ) ;				      int n = st . length ( ) ;					  
    digitSum = 0					      	int digitSum = 0 ;					      int digitSum = 0 ;					  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	digitSum = digitSum + ( int ) ( st [ i ] )	      	i < n ;							      i != n ;							  
    return ( digitSum % 9 == 0 )			      	i ++ ) digitSum += ( str [ i ] - '0' ) ;		      i ++ ) digitSum = digitSum + ( int ) ( st [ i ] ) ;	  
							      	return ( digitSum % 9 == 0 ) ;				      return ( digitSum % 9 == 0 ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			      PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			    PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX			  PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX
--							      --							    --								  --
def transpose ( A , B ) :				      void transpose ( int A [ ] [ N ] , int B [ ] [ N ] ) {	    void transpose ( int * * A , int * * B ) {			  script_not_found : None
    for i in range ( N ) :				      	int i , j ;						      for ( int i = 0 ;						  
	for j in range ( N ) :				      	for ( i = 0 ;						      i < N ;							  
	    B [ i ] [ j ] = A [ j ] [ i ]		      	i < N ;							      i ++ ) {							  
							      	i ++ ) for ( j = 0 ;					    	for ( int j = 0 ;					  
							      	j < N ;							    	j < N ;							  
							      	j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ;			    	j ++ ) {						  
							      }								    	  B [ i ] [ j ] = A [ j ] [ i ] ;			  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		      FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		    FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO		  FIND_NTH_FIBONACCI_NUMBER_USING_GOLDEN_RATIO
--							      --							    --								  --
def fib ( n ) :						      int fib ( int n ) {					    int fib ( int n ) {						  script_not_found : None
    if n < 6 :						      	if ( n < 6 ) return f [ n ] ;				      if ( n < 6 ) return f [ n ] ;				  
	return f [ n ]					      	int t = 5 , fn = 5 ;					      int t = 5 ;						  
    t = 5						      	while ( t < n ) {					      int fn = 5 ;						  
    fn = 5						      	  fn = round ( fn * PHI ) ;				      while ( t < n ) {						  
    while t < n :					      	  t ++ ;						    	fn = round ( fn * PHI ) ;				  
	fn = round ( fn * PHI )				      	}							    	t ++ ;							  
	t += 1						      	return fn ;						      }								  
    return fn						      }								      return fn ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW WRITE_ONE_LINE_C_FUNCTION_TO_FIND_WHETHER_A_NO_IS_POWER_OF_TW
--							      --							    --								  --
def isPowerOfTwo ( n ) :				      bool isPowerOfTwo ( int n ) {				    bool isPowerOfTwo ( int n ) {				  success : None
    if ( n == 0 ) :					      	if ( n == 0 ) return 0 ;				      if ( ( n == 0 ) ) return false ;				  
	return False					      	while ( n != 1 ) {					      while ( ( n != 1 ) ) {					  
    while ( n != 1 ) :					      	  if ( n % 2 != 0 ) return 0 ;				    	if ( ( n % 2 != 0 ) ) return false ;			  
	if ( n % 2 != 0 ) :				      	  n = n / 2 ;						    	n = n / 2 ;						  
	    return False				      	}							      }								  
	n = n // 2					      	return 1 ;						      return true ;						  
    return True						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DIGITS_PRODUCT_TWO_NUMBERS			      NUMBER_DIGITS_PRODUCT_TWO_NUMBERS				    NUMBER_DIGITS_PRODUCT_TWO_NUMBERS				  NUMBER_DIGITS_PRODUCT_TWO_NUMBERS
--							      --							    --								  --
def countDigits ( a , b ) :				      int countDigits ( int a , int b ) {			    int countDigits ( int a , int b ) {				  success : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    p = abs ( a * b )					      	int p = abs ( a * b ) ;					      int p = abs ( a * b ) ;					  
    if ( p == 0 ) :					      	if ( p == 0 ) return 1 ;				      if ( ( p == 0 ) ) return 1 ;				  
	return 1					      	while ( p > 0 ) {					      while ( ( p > 0 ) ) {					  
    while ( p > 0 ) :					      	  count ++ ;						    	count = count + 1 ;					  
	count = count + 1				      	  p = p / 10 ;						    	p = p / 10 ;						  
	p = p // 10					      	}							      }								  
    return count					      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY    FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY    FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY	  FIND_INDEX_OF_AN_EXTRA_ELEMENT_PRESENT_IN_ONE_SORTED_ARRAY
--							      --							    --								  --
def findExtra ( arr1 , arr2 , n ) :			      int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) {	    int findExtra ( int * arr1 , int * arr2 , int n ) {		  success : None
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( arr1 [ i ] != arr2 [ i ] ) :		      	i < n ;							      i != n ;							  
	    return i					      	i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ;	      i ++ ) {							  
    return n						      	return n ;						    	if ( ( arr1 [ i ] != arr2 [ i ] ) && ( arr1 [ i ] != arr2 
							      }								      }								  
							      								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1		  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_1
--							      --							    --								  --
def reverseStr ( str ) :				      void reverseStr ( string & str ) {			    void reverseStr ( string str ) {				  script_not_found : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    i , j = 0 , n - 1					      	for ( int i = 0 , j = n - 1 ;				      int i = 0 , j = n - 1 ;					  
    while i < j :					      	i < j ;							      while ( i < j ) {						  
	str [ i ] , str [ j ] = str [ j ] , str [ i ]	      	i ++ , j -- ) swap ( str [ i ] , str [ j ] ) ;		    	str [ i ] = str [ j ] ;					  
	i += 1						      }								    	i ++ ;							  
	j -= 1						      								    	j -- ;							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			      C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			    C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE			  C_PROGRAM_CYCLICALLY_ROTATE_ARRAY_ONE
--							      --							    --								  --
def rotate ( arr , n ) :				      void rotate ( int arr [ ] , int n ) {			    void rotate ( int * arr , int n ) {				  script_not_found : None
    x = arr [ n - 1 ]					      	int x = arr [ n - 1 ] , i ;				      int x = arr [ n - 1 ] ;					  
    for i in range ( n - 1 , 0 , - 1 ) :		      	for ( i = n - 1 ;					      for ( int i = n - 1 ;					  
	arr [ i ] = arr [ i - 1 ]			      	i > 0 ;							      i > 0 ;							  
    arr [ 0 ] = x					      	i -- ) arr [ i ] = arr [ i - 1 ] ;			      i -- ) arr [ i ] = arr [ i - 1 ] ;			  
							      	arr [ 0 ] = x ;						      arr [ 0 ] = x ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARED_TRIANGULAR_NUMBER_SUM_CUBES			      SQUARED_TRIANGULAR_NUMBER_SUM_CUBES			    SQUARED_TRIANGULAR_NUMBER_SUM_CUBES				  SQUARED_TRIANGULAR_NUMBER_SUM_CUBES
--							      --							    --								  --
def findS ( s ) :					      int findS ( int s ) {					    int findS ( int s ) {					  success : None
    _sum = 0						      	int sum = 0 ;						      int _sum = 0 ;						  
    n = 1						      	for ( int n = 1 ;					      int n = 1 ;						  
    while ( _sum < s ) :				      	sum < s ;						      while ( ( _sum < s ) && ( _sum < s ) ) {			  
	_sum += n * n * n				      	n ++ ) {						    	_sum += n * n * n ;					  
	n += 1						      	  sum += n * n * n ;					    	n ++ ;							  
    n -= 1						      	  if ( sum == s ) return n ;				      }								  
    if _sum == s :					      	}							      n -- ;							  
	return n					      	return - 1 ;						      if ( _sum == s ) return n ;				  
    return - 1						      }								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT		  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT
--							      --							    --								  --
def isPowerOfFour ( n ) :				      public : bool isPowerOfFour ( int n ) {			    bool isPowerOfFour ( int n ) {				  script_not_found : None
    if ( n == 0 ) :					      	if ( n == 0 ) return 0 ;				      if ( ( n == 0 ) ) return false ;				  
	return False					      	while ( n != 1 ) {					      while ( ( n != 1 ) ) {					  
    while ( n != 1 ) :					      	  if ( n % 4 != 0 ) return 0 ;				    	if ( ( n % 4 ) != 0 ) return false ;			  
	if ( n % 4 != 0 ) :				      	  n = n / 4 ;						    	n = n / 4 ;						  
	    return False				      	}							      }								  
	n = n // 4					      	return 1 ;						      return true ;						  
    return True						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE		      NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE			    NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE			  NUMBER_INDEXES_EQUAL_ELEMENTS_GIVEN_RANGE
--							      --							    --								  --
def answer_query ( a , n , l , r ) :			      int answer_query ( int a [ ] , int n , int l , int r ) {	    int answerQuery ( int * a , int n , int l , int r ) {	  success : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( l , r ) :				      	for ( int i = l ;					      for ( int i = l ;						  
	if ( a [ i ] == a [ i + 1 ] ) :			      	i < r ;							      i < r ;							  
	    count += 1					      	i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ;	      i ++ ) {							  
    return count					      	return count ;						    	if ( ( a [ i ] == a [ i + 1 ] ) ) count ++ ;		  
							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		      RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		    RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS		  RANGE_QUERIES_FOR_FREQUENCIES_OF_ARRAY_ELEMENTS
--							      --							    --								  --
def findFrequency ( arr , n , left , right , element ) :      int findFrequency ( int arr [ ] , int n , int left , int righ int findFrequency ( int * arr , int n , int left , int right  script_not_found : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( left - 1 , right ) :		      	for ( int i = left - 1 ;				      for ( int i = left - 1 ;					  
	if ( arr [ i ] == element ) :			      	i <= right ;						      i < right ;						  
	    count += 1					      	++ i ) if ( arr [ i ] == element ) ++ count ;		      i ++ ) {							  
    return count					      	return count ;						    	if ( ( arr [ i ] == element ) ) count ++ ;		  
							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING		      QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING		    QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING			  QUERIES_FOR_CHARACTERS_IN_A_REPEATED_STRING
--							      --							    --								  --
def query ( s , i , j ) :				      void query ( char s [ ] , int i , int j ) {		    int query ( string s , int i , int j ) {			  script_not_found : None
    n = len ( s )					      	int n = strlen ( s ) ;					      int n = s . length ( ) ;					  
    i %= n						      	i %= n ;						      i %= n ;							  
    j %= n						      	j %= n ;						      j %= n ;							  
    print ( "Yes" ) if s [ i ] == s [ j ] else print ( "No" ) 	( s [ i ] == s [ j ] ) ? ( cout << "Yes" << endl ) : ( cout   return s [ i ] == s [ j ] ? i : j ;			  
							      }								      return i * i * i * i * i * i * i * i * i * i * i * i * i *  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1     SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1	    SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1	  SMALLEST_OF_THREE_INTEGERS_WITHOUT_COMPARISON_OPERATORS_1
--							      --							    --								  --
def smallest ( x , y , z ) :				      int smallest ( int x , int y , int z ) {			    int smallest ( int x , int y , int z ) {			  success : None
    if ( not ( y / x ) ) :				      	if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ;	      if ( ( ! ( y / x ) ) ) return ( ( ! ( y / z ) ) ) ? y : z ; 
	return y if ( not ( y / z ) ) else z		      	return ( ! ( x / z ) ) ? x : z ;			      return ( ( ! ( x / z ) ) ) ? x : z ;			  
    return x if ( not ( x / z ) ) else z		      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE     CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE	    CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE	  CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_TREE
--							      --							    --								  --
def check ( degree , n ) :				      bool check ( int degree [ ] , int n ) {			    bool check ( double * degree , int n ) {			  error : CHECK_WHETHER_GIVEN_DEGREES_VERTICES_REPRE
    deg_sum = sum ( degree )				      	int deg_sum = 0 ;					      double deg_sum = pow ( degree [ 0 ] , n ) ;		  SENT_GRAPH_TREE.cpp: In function ‘int main()’: CHE
    if ( 2 * ( n - 1 ) == deg_sum ) :			      	for ( int i = 0 ;					      if ( ( 2 * ( n - 1 ) ) == deg_sum ) return true ;		  CK_WHETHER_GIVEN_DEGREES_VERTICES_REPRESENT_GRAPH_
	return True					      	i < n ;							      else return false ;					  TREE.cpp:48:21: error: cannot convert ‘__gnu_cxx::
    else :						      	i ++ ) deg_sum += degree [ i ] ;			    }								  __alloc_traits<std::allocator<int>, int>::value_ty
	return False					      	return ( 2 * ( n - 1 ) == deg_sum ) ;			    								  pe*’ {aka ‘int*’} to ‘double*’	  if(f_fille
							      }								    								  d(&param0[i].front(),param1[i]) == f_gold(&param0[
							      								    								  i].front(),param1[i]))		      ^~~~~~
							      								    								  ~~~~~~~~~~~~ CHECK_WHETHER_GIVEN_DEGREES_VERTICES_
							      								    								  REPRESENT_GRAPH_TREE.cpp:25:26: note:	  initializi
							      								    								  ng argument 1 of ‘bool f_filled(double*, int)’  bo
							      								    								  ol f_filled ( double * degree , int n ) {
							      								    								  	   ~~~~~~~~~^~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_STRING_ROTATION_PALINDROME			      CHECK_GIVEN_STRING_ROTATION_PALINDROME			    CHECK_GIVEN_STRING_ROTATION_PALINDROME			  CHECK_GIVEN_STRING_ROTATION_PALINDROME
--							      --							    --								  --
def isPalindrome ( string ) :				      bool isPalindrome ( string str ) {			    bool isPalindrome ( string string ) {			  success : None
    l = 0						      	int l = 0 ;						      int l = 0 ;						  
    h = len ( string ) - 1				      	int h = str . length ( ) - 1 ;				      int h = string . length ( ) - 1 ;				  
    while h > l :					      	while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return    while ( h > l ) {						  
	l += 1						      	return true ;						    	l ++ ;							  
	h -= 1						      }								    	h -- ;							  
	if string [ l - 1 ] != string [ h + 1 ] :	      								    	if ( string [ l - 1 ] != string [ h + 1 ] ) return false  
	    return False				      								      }								  
    return True						      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	      PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	    PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1	  PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING_1
--							      --							    --								  --
def printSquares ( n ) :				      void printSquares ( int n ) {				    void printSquares ( int n ) {				  script_not_found : None
    square = 0						      	int square = 0 , odd = 1 ;				      int square = 0 ;						  
    odd = 1						      	for ( int x = 0 ;					      int odd = 1 ;						  
    for x in range ( 0 , n ) :				      	x < n ;							      for ( int x = 0 ;						  
	print ( square , end = " " )			      	x ++ ) {						      x <= n ;							  
	square = square + odd				      	  cout << square << " " ;				      x ++ ) {							  
	odd = odd + 2					      	  square = square + odd ;				    	cout << square << " " ;					  
							      	  odd = odd + 2 ;					    	square = square + odd ;					  
							      	}							    	odd = odd + 2 ;						  
							      }								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	      MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	    MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N	  MINIMIZE_THE_SUM_OF_DIGITS_OF_A_AND_B_SUCH_THAT_A_B_N
--							      --							    --								  --
def minSum ( n ) :					      int minSum ( int n ) {					    int minSum ( int n ) {					  failure : #Results: 0, 10
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    while ( n > 0 ) :					      	while ( n > 0 ) {					      while ( ( n > 0 ) && ( n % 10 == 0 ) ) {			  
	sum += ( n % 10 )				      	  sum += ( n % 10 ) ;					    	sum += ( n % 10 ) ;					  
	n //= 10					      	  n /= 10 ;						    	n /= 10 ;						  
    if ( sum == 1 ) :					      	}							      }								  
	return 10					      	if ( sum == 1 ) return 10 ;				      if ( ( sum == 1 ) ) return 10 ;				  
    return sum						      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHANGE_BITS_CAN_MADE_ONE_FLIP_1				      CHANGE_BITS_CAN_MADE_ONE_FLIP_1				    CHANGE_BITS_CAN_MADE_ONE_FLIP_1				  CHANGE_BITS_CAN_MADE_ONE_FLIP_1
--							      --							    --								  --
def isOneFlip ( str ) :					      bool isOneFlip ( string str ) {				    bool isOneFlip ( string str ) {				  error : CHANGE_BITS_CAN_MADE_ONE_FLIP_1.cpp: In fu
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  nction ‘bool f_filled(std::__cxx11::string)’: CHAN
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  GE_BITS_CAN_MADE_ONE_FLIP_1.cpp:31:34: error: inva
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  lid conversion from ‘__gnu_cxx::__alloc_traits<std
	sum += int ( str [ i ] ) - int ( '0' )		      	i < n ;							      i != n ;							  ::allocator<char>, char>::value_type’ {aka ‘char’}
    return ( sum == n - 1 or sum == 1 )			      	i ++ ) sum += str [ i ] - '0' ;				      i ++ ) sum += atoi ( str [ i ] ) - atoi ( "0" ) ;		   to ‘const char*’ [-fpermissive]    i ++ ) sum +=
							      	return ( sum == n - 1 || sum == 1 ) ;			      return ( sum == n - 1 || sum == 1 ) ;			  atoi ( str [ i ] ) - atoi ( "0" ) ;
							      }								    }								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/cstdlib:75,		    from /us
							      								    								  r/include/c++/8/ext/string_conversions.h:41,
							      								    								  	      from /usr/include/c++/8/bits/basic_str
							      								    								  ing.h:6400,		       from /usr/include/c++
							      								    								  /8/string:52,			 from /usr/include/c
							      								    								  ++/8/bits/locale_classes.h:40,		  fr
							      								    								  om /usr/include/c++/8/bits/ios_base.h:41,
							      								    								  	   from /usr/include/c++/8/ios:42,
							      								    								  	  from /usr/include/c++/8/ostream:38,
							      								    								  	     from /usr/include/c++/8/iostream:39,
							      								    								  		 from CHANGE_BITS_CAN_MADE_ONE_FLIP_
							      								    								  1.cpp:8: /usr/include/stdlib.h:104:30: note:	 ini
							      								    								  tializing argument 1 of ‘int atoi(const char*)’  e
							      								    								  xtern int atoi (const char *__nptr)
							      								    								      ~~~~~~~~~~~~^~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS   EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS   EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS	  EULERS_CRITERION_CHECK_IF_SQUARE_ROOT_UNDER_MODULO_P_EXISTS
--							      --							    --								  --
def squareRootExists ( n , p ) :			      bool squareRootExists ( int n , int p ) {			    bool squareRootExists ( int n , int p ) {			  success : None
    n = n % p						      	n = n % p ;						      n = n % p ;						  
    for x in range ( 2 , p , 1 ) :			      	for ( int x = 2 ;					      for ( int x = 2 ;						  
	if ( ( x * x ) % p == n ) :			      	x < p ;							      x < p ;							  
	    return True					      	x ++ ) if ( ( x * x ) % p == n ) return true ;		      x += 1 ) {						  
    return False					      	return false ;						    	if ( ( ( x * x ) % p == n ) ) return true ;		  
							      }								      }								  
							      								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		      COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		    COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX		  COUNT_ENTRIES_EQUAL_TO_X_IN_A_SPECIAL_MATRIX
--							      --							    --								  --
def count ( n , x ) :					      int count ( int n , int x ) {				    int count ( int n , int x ) {				  script_not_found : None
    cnt = 0						      	int count = = 0 ;					      int cnt = 0 ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	if i <= x :					      	i <= n && i <= x ;					      i <= n ;							  
	    if x // i <= n and x % i == 0 :		      	i ++ ) {						      i ++ ) {							  
		cnt += 1				      	  if ( x / i <= n && x % i == 0 ) count ++ ;		    	if ( i <= x ) {						  
    return cnt						      	}							    	  if ( x / i <= n && x % i == 0 ) cnt ++ ;		  
							      	return count ;						    	}							  
							      }								      }								  
							      								      return cnt ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		      DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		    DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT		  DYNAMIC_PROGRAMMING_SET_9_BINOMIAL_COEFFICIENT
--							      --							    --								  --
def binomialCoeff ( n , k ) :				      int binomialCoeff ( int n , int k ) {			    int binomialCoeff ( int n , int k ) {			  script_not_found : None
    if k == 0 or k == n :				      	if ( k == 0 || k == n ) return 1 ;			      if ( k == 0 || k == n ) return 1 ;			  
	return 1					      	return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n    return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n  
    return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff (  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX		      SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX			    SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX			  SWAP_MAJOR_MINOR_DIAGONALS_SQUARE_MATRIX
--							      --							    --								  --
def swapDiagonal ( matrix ) :				      void swapDiagonal ( int matrix [ ] [ N ] ) {		    void swapDiagonal ( int * * matrix ) {			  script_not_found : None
    for i in range ( N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1 ] = \   	i < N ;							      i < N ;							  
	    matrix [ i ] [ N - i - 1 ] , matrix [ i ] [ i ]   	i ++ ) swap ( matrix [ i ] [ i ] , matrix [ i ] [ N - i - 1   i ++ ) {							  
							      }								    	matrix [ i ] [ i ] = matrix [ i ] [ N - i - 1 ] =	  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ARC_LENGTH_ANGLE					      ARC_LENGTH_ANGLE						    ARC_LENGTH_ANGLE						  ARC_LENGTH_ANGLE
--							      --							    --								  --
def arcLength ( diameter , angle ) :			      double arcLength ( double diameter , double angle ) {	    double arcLength ( double diameter , double angle ) {	  script_not_found : None
    if angle >= 360 :					      	double pi = 22.0 / 7.0 ;				      if ( angle >= 360 ) {					  
	print ( "Angle cannot be formed" )		      	double arc ;						    	cout << "Angle cannot be formed" << endl ;		  
	return 0					      	if ( angle >= 360 ) {					    	return 0 ;						  
    else :						      	  cout << "Angle cannot" , " be formed" ;		      }								  
	arc = ( 3.142857142857143 * diameter ) * ( angle / 36 	  return 0 ;						      else {							  
	return arc					      	}							    	double arc = ( 3.142857142857143 * diameter ) * ( angle / 
							      	else {							    	return arc ;						  
							      	  arc = ( pi * diameter ) * ( angle / 360.0 ) ;		      }								  
							      	  return arc ;						    }								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM	      RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM		    RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM		  RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM
--							      --							    --								  --
def breakSum ( n ) :					      int breakSum ( int n ) {					    int breakSum ( int n ) {					  success : None
    if ( n == 0 or n == 1 ) :				      	if ( n == 0 || n == 1 ) return n ;			      if ( ( n == 0 ) || ( n == 1 ) ) return n ;		  
	return n					      	return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + br   return max < int > ( ( breakSum ( n / 2 ) + breakSum ( n /  
    return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 )  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_9_USING_BITWISE_OPERATORS			      DIVISIBILITY_9_USING_BITWISE_OPERATORS			    DIVISIBILITY_9_USING_BITWISE_OPERATORS			  DIVISIBILITY_9_USING_BITWISE_OPERATORS
--							      --							    --								  --
def isDivBy9 ( n ) :					      bool isDivBy9 ( int n ) {					    bool isDivBy9 ( int n ) {					  success : None
    if ( n == 0 or n == 9 ) :				      	if ( n == 0 || n == 9 ) return true ;			      if ( ( n == 0 ) || ( n == 9 ) ) return true ;		  
	return True					      	if ( n < 9 ) return false ;				      if ( ( n < 9 ) ) return false ;				  
    if ( n < 9 ) :					      	return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )    return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) )  
	return False					      }								    }								  
    return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 )  								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_DIVISIBILITY_BINARY_STRING_2K			      CHECK_DIVISIBILITY_BINARY_STRING_2K			    CHECK_DIVISIBILITY_BINARY_STRING_2K				  CHECK_DIVISIBILITY_BINARY_STRING_2K
--							      --							    --								  --
def isDivisible ( str , k ) :				      bool isDivisible ( char str [ ] , int k ) {		    bool isDivisible ( string str , int k ) {			  error : /bin/bash: line 1: 1846226 Aborted
    n = len ( str )					      	int n = strlen ( str ) ;				      int n = str . length ( ) ;				  	   (core dumped) ./CHECK_DIVISIBILITY_BINARY
    c = 0						      	int c = 0 ;						      int c = 0 ;						  _STRING_2K_cpp
    for i in range ( 0 , k ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( str [ n - i - 1 ] == '0' ) :		      	i < k ;							      i <= k ;							  
	    c += 1					      	i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ;		      i ++ ) {							  
    return ( c == k )					      	return ( c == k ) ;					    	if ( ( str [ n - i - 1 ] == '0' ) ) c ++ ;		  
							      }								      }								  
							      								      return ( c == k ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2   SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2   SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2	  SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS_2
--							      --							    --								  --
def findSum ( n ) :					      int findSum ( int n ) {					    int findSum ( int n ) {					  success : None
    n -= 1						      	n -- ;							      n -- ;							  
    sum = 0						      	int sum = 0 ;						      double sum = 0 ;						  
    sum += ( n * ( n + 1 ) ) / 2			      	sum += ( n * ( n + 1 ) ) / 2 ;				      sum += ( n * ( n + 1 ) ) / 2 ;				  
    sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6	      	sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;		      sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;		  
    return int ( sum )					      	return sum ;						      return ( int ) sum ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2		      N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2			    N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2			  N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN_2
--							      --							    --								  --
def findNth ( n ) :					      int findNth ( int n ) {					    int findNth ( int n ) {					  success : identical to gold
    nthElement = 19 + ( n - 1 ) * 9			      	int nthElement = 19 + ( n - 1 ) * 9 ;			      int nthElement = 19 + ( n - 1 ) * 9 ;			  
    outliersCount = int ( math.log10 ( nthElement ) ) - 1     	int outliersCount = ( int ) log10 ( nthElement ) - 1 ;	      int outliersCount = ( int ) log10 ( nthElement ) - 1 ;	  
    nthElement += 9 * outliersCount			      	nthElement += 9 * outliersCount ;			      nthElement += 9 * outliersCount ;				  
    return nthElement					      	return nthElement ;					      return nthElement ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION_2			      PROGRAM_DECIMAL_BINARY_CONVERSION_2			    PROGRAM_DECIMAL_BINARY_CONVERSION_2				  PROGRAM_DECIMAL_BINARY_CONVERSION_2
--							      --							    --								  --
def decimalToBinary ( N ) :				      unsigned long long int int decimalToBinary ( int N ) {	    int decimalToBinary ( int N ) {				  script_not_found : None
    B_Number = 0					      	ull B_Number = 0 ;					      int B_Number = 0 ;					  
    cnt = 0						      	int cnt = 0 ;						      int cnt = 0 ;						  
    while ( N != 0 ) :					      	while ( N != 0 ) {					      while ( ( N != 0 ) && ( N != 1 ) ) {			  
	rem = N % 2					      	  int rem = N % 2 ;					    	int rem = N % 2 ;					  
	c = pow ( 10 , cnt )				      	  ull c = pow ( 10 , cnt ) ;				    	int c = pow ( 10 , cnt ) ;				  
	B_Number += rem * c				      	  B_Number += rem * c ;					    	B_Number += rem * c ;					  
	N //= 2						      	  N /= 2 ;						    	N /= 2 ;						  
	cnt += 1					      	  cnt ++ ;						    	cnt ++ ;						  
    return B_Number					      	}							      }								  
							      	return B_Number ;					      return B_Number ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1  FIRST_UPPERCASE_LETTER_IN_A_STRING_ITERATIVE_AND_RECURSIVE_1
--							      --							    --								  --
def first ( str , i ) :					      char first ( string str , int i = 0 ) {			    char first ( string str , int i ) {				  error : /bin/bash: line 1: 1846671 Aborted
    if ( str [ i ] == '\0' ) :				      	if ( str [ i ] == '\0' ) return 0 ;			      if ( ( str [ i ] == '\0' ) ) return 0 ;			  	   (core dumped) ./FIRST_UPPERCASE_LETTER_IN
	return 0					      	if ( isupper ( str [ i ] ) ) return str [ i ] ;		      if ( isupper ( str [ i ] ) ) return str [ i ] ;		  _A_STRING_ITERATIVE_AND_RECURSIVE_1_cpp
    if ( str [ i ].isupper ( ) ) :			      	return first ( str , i + 1 ) ;				      return first ( str , i + 1 ) ;				  
	return str [ i ]				      }								    }								  
    return first ( str , i + 1 )			      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA LEXICOGRAPHICALLY_SMALLEST_STRING_OBTAINED_CONCATENATING_ARRA
--							      --							    --								  --
def lexSmallest ( a , n ) :				      string lexSmallest ( string a [ ] , int n ) {		    string lexSmallest ( string a , int n ) {			  script_not_found : None
    a.sort ( reverse = True )				      	sort ( a , a + n , compare ) ;				      sort ( a . begin ( ) , a . end ( ) ) ;			  
    answer = ""						      	string answer = "" ;					      string answer ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	answer += a [ i ]				      	i < n ;							      i < n ;							  
    return answer					      	i ++ ) answer += a [ i ] ;				      i ++ ) answer += a [ i ] ;				  
							      	return answer ;						      return answer ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1     GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1	    GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1	  GIVEN_BINARY_STRING_COUNT_NUMBER_SUBSTRINGS_START_END_1_1
--							      --							    --								  --
def countSubStr ( st , n ) :				      int countSubStr ( char str [ ] ) {			    int countSubStr ( string st , int n ) {			  script_not_found : None
    m = 0						      	int m = 0 ;						      int m = 0 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( st [ i ] == '1' ) :			      	str [ i ] != '\0' ;					      i != n ;							  
	    m = m + 1					      	i ++ ) {						      i ++ ) {							  
    return m * ( m - 1 ) // 2				      	  if ( str [ i ] == '1' ) m ++ ;			    	if ( ( st [ i ] == '1' ) ) m = m + 1 ;			  
							      	}							      }								  
							      	return m * ( m - 1 ) / 2 ;				      return m * ( m - 1 ) / 2 ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		      PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		    PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11		  PROGRAM_FIND_REMAINDER_LARGE_NUMBER_DIVIDED_11
--							      --							    --								  --
def remainder ( st ) :					      int remainder ( string str ) {				    int remainder ( string st ) {				  failure : #Results: 6, 10
    ln = len ( st )					      	int len = str . length ( ) ;				      int ln = st . length ( ) ;				  
    rem = 0						      	int num , rem = 0 ;					      int rem = 0 ;						  
    for i in range ( 0 , ln ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	num = rem * 10 + ( int ) ( st [ i ] )		      	i < len ;						      i != ln ;							  
	rem = num % 11					      	i ++ ) {						      i ++ ) {							  
    return rem						      	  num = rem * 10 + ( str [ i ] - '0' ) ;		    	int num = rem * 10 + ( int ) st [ i ] ;			  
							      	  rem = num % 11 ;					    	rem = num % 11 ;					  
							      	}							      }								  
							      	return rem ;						      return rem ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_ROTATIONS_REQUIRED_GET_STRING			      MINIMUM_ROTATIONS_REQUIRED_GET_STRING			    MINIMUM_ROTATIONS_REQUIRED_GET_STRING			  MINIMUM_ROTATIONS_REQUIRED_GET_STRING
--							      --							    --								  --
def findRotations ( str ) :				      int findRotations ( string str ) {			    int findRotations ( string str ) {				  failure : #Results: 9, 10
    tmp = str + str					      	string tmp = str + str ;				      string tmp = str + str ;					  
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	substring = tmp [ i : n ]			      	i <= n ;						      i <= n ;							  
	if ( str == substring ) :			      	i ++ ) {						      i ++ ) {							  
	    return i					      	  string substring = tmp . substr ( i , str . size ( ) ) ;  	string substring = tmp . substr ( i , n - i - 1 ) ;	  
    return n						      	  if ( str == substring ) return i ;			    	if ( ( str == substring ) || ( str == substring ) ) retur 
							      	}							      }								  
							      	return n ;						      return n ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHUFFLE_A_GIVEN_ARRAY					      SHUFFLE_A_GIVEN_ARRAY					    SHUFFLE_A_GIVEN_ARRAY					  SHUFFLE_A_GIVEN_ARRAY
--							      --							    --								  --
def randomize ( arr , n ) :				      void randomize ( int arr [ ] , int n ) {			    int randomize ( int * arr , int n ) {			  script_not_found : None
    for i in range ( n - 1 , 0 , - 1 ) :		      	srand ( time ( NULL ) ) ;				      for ( int i = n - 1 ;					  
	j = random.randint ( 0 , i + 1 )		      	for ( int i = n - 1 ;					      i > 0 ;							  
	arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]	      	i > 0 ;							      i -- ) {							  
    return arr						      	i -- ) {						    	int j = rand ( ) % ( i + 1 ) ;				  
							      	  int j = rand ( ) % ( i + 1 ) ;			    	arr [ i ] = arr [ j ] ;					  
							      	  swap ( & arr [ i ] , & arr [ j ] ) ;			    	arr [ j ] = arr [ i ] ;					  
							      	}							      }								  
							      }								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			      PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			    PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS			  PROGRAM_FIND_GCD_FLOATING_POINT_NUMBERS
--							      --							    --								  --
def gcd ( a , b ) :					      double gcd ( double a , double b ) {			    double gcd ( double a , double b ) {			  script_not_found : None
    if ( a < b ) :					      	if ( a < b ) return gcd ( b , a ) ;			      if ( ( a < b ) ) return gcd ( b , a ) ;			  
	return gcd ( b , a )				      	if ( fabs ( b ) < 0.001 ) return a ;			      if ( ( fabs ( b ) < 0.001 ) ) return a ;			  
    if ( abs ( b ) < 0.001 ) :				      	else return ( gcd ( b , a - floor ( a / b ) * b ) ) ;	      else return ( gcd ( b , a - floor ( a / b ) * b ) ) ;	  
	return a					      }								    }								  
    else :						      								    								  
	return ( gcd ( b , a - math.floor ( a / b ) * b ) )   								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	      TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	    TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1	  TOTAL_NUMBER_OF_NON_DECREASING_NUMBERS_WITH_N_DIGITS_1
--							      --							    --								  --
def countNonDecreasing ( n ) :				      long long int countNonDecreasing ( int n ) {		    int countNonDecreasing ( int n ) {				  failure : #Results: 2, 10
    N = 10						      	int N = 10 ;						      const int N = 10 ;					  
    count = 1						      	long long count = 1 ;					      int count = 1 ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	count = int ( count * ( N + i - 1 ) )		      	i <= n ;						      i <= n ;							  
	count = int ( count / i )			      	i ++ ) {						      i ++ ) {							  
    return count					      	  count *= ( N + i - 1 ) ;				    	count = ( int ) ( count * ( N + i - 1 ) ) ;		  
							      	  count /= i ;						    	count = ( int ) ( count / i ) ;				  
							      	}							      }								  
							      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	      NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	    NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES	  NUMBER_UNIQUE_RECTANGLES_FORMED_USING_N_UNIT_SQUARES
--							      --							    --								  --
def countRect ( n ) :					      int countRect ( int n ) {					    int countRect ( int n ) {					  timeout : None
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  
    for length in range ( 1 , int ( math.sqrt ( n ) ) + 1 ) : 	for ( int length = 1 ;					      for ( int length = 1 ;					  
	height = length					      	length <= sqrt ( n ) ;					      ( int ) sqrt ( n ) + 1 < n ;				  
	while ( height * length <= n ) :		      	++ length ) for ( int height = length ;			      length ++ ) {						  
	    ans += 1					      	height * length <= n ;					    	int height = length ;					  
	    height += 1					      	++ height ) ans ++ ;					    	while ( ( height * length <= n ) ) {			  
    return ans						      	return ans ;						    	  ans ++ ;						  
							      }								    	  height ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHANGE_BITS_CAN_MADE_ONE_FLIP				      CHANGE_BITS_CAN_MADE_ONE_FLIP				    CHANGE_BITS_CAN_MADE_ONE_FLIP				  CHANGE_BITS_CAN_MADE_ONE_FLIP
--							      --							    --								  --
def canMakeAllSame ( str ) :				      bool canMakeAllSame ( string str ) {			    bool canMakeAllSame ( string str ) {			  failure : #Results: 8, 10
    zeros = 0						      	int zeros = 0 , ones = 0 ;				      int zeros = 0 ;						  
    ones = 0						      	for ( char ch : str ) ( ch == '0' ) ? ++ zeros : ++ ones ;    int ones = 0 ;						  
    for i in range ( 0 , len ( str ) ) :		      	return ( zeros == 1 || ones == 1 ) ;			      for ( int i = 0 ;						  
	ch = str [ i ]					      }								      i != str . length ( ) ;					  
	if ( ch == '0' ) :				      								      i ++ ) {							  
	    zeros = zeros + 1				      								    	char ch = str [ i ] ;					  
	else :						      								    	if ( ( ch == '0' ) || ( ch == '1' ) ) zeros = zeros + 1 ; 
	    ones = ones + 1				      								    	else ones = ones + 1 ;					  
    return ( zeros == 1 or ones == 1 )			      								      }								  
							      								      return ( zeros == 1 || ones == 1 ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_1				      DYNAMIC_PROGRAMMING_SET_1					    DYNAMIC_PROGRAMMING_SET_1					  DYNAMIC_PROGRAMMING_SET_1
--							      --							    --								  --
def fib ( n , lookup ) :				      int fib ( int n ) {					    int fib ( int n , int lookup [ ] ) {			  script_not_found : None
    if n == 0 or n == 1 :				      	if ( lookup [ n ] == NIL ) {				      if ( n == 0 || n == 1 ) lookup [ n ] = n ;		  
	lookup [ n ] = n				      	  if ( n <= 1 ) lookup [ n ] = n ;			      if ( lookup [ n ] == 0 ) lookup [ n ] = fib ( n - 1 , looku 
    if lookup [ n ] is None :				      	  else lookup [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ;	      return lookup [ n ] ;					  
	lookup [ n ] = fib ( n - 1 , lookup ) + fib ( n - 2 , 	}							    }								  
    return lookup [ n ]					      	return lookup [ n ] ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE	      SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE		    SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE		  SELECT_A_RANDOM_NUMBER_FROM_STREAM_WITH_O1_SPACE
--							      --							    --								  --
def selectRandom ( x ) :				      int selectRandom ( int x ) {				    int selectRandom ( int x ) {				  script_not_found : None
    res = 0						      	static int res ;					      int res = 0 ;						  
    count = 0						      	static int count = 0 ;					      int count = 0 ;						  
    count += 1						      	count ++ ;						      count ++ ;						  
    if ( count == 1 ) :					      	if ( count == 1 ) res = x ;				      if ( ( count == 1 ) ) res = x ;				  
	res = x						      	else {							      else {							  
    else :						      	  int i = rand ( ) % count ;				    	int i = rand ( ) % count ;				  
	i = random.randrange ( count )			      	  if ( i == count - 1 ) res = x ;			    	if ( ( i == count - 1 ) ) res = x ;			  
	if ( i == count - 1 ) :				      	}							      }								  
	    res = x					      	return res ;						      return res ;						  
    return res						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			      PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			    PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2			  PROGRAM_TO_FIND_TRANSPOSE_OF_A_MATRIX_2
--							      --							    --								  --
def transpose ( A ) :					      void transpose ( int A [ ] [ N ] ) {			    void transpose ( int * * A ) {				  script_not_found : None
    for i in range ( N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , N ) :			      	i < N ;							      i < N ;							  
	    A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A 	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
							      	j < N ;							    	for ( int j = i + 1 ;					  
							      	j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ;		    	j < N ;							  
							      }								    	j ++ ) A [ i ] [ j ] = A [ j ] [ i ] ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING	      PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING	    PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING		  PRINT_SQUARES_FIRST_N_NATURAL_NUMBERS_WITHOUT_USING
--							      --							    --								  --
def printSquares ( n ) :				      void printSquares ( int n ) {				    int printSquares ( int n ) {				  script_not_found : None
    square = 0 ; prev_x = 0 ;				      	int square = 0 , prev_x = 0 ;				      int square = 0 ;						  
    for x in range ( 0 , n ) :				      	for ( int x = 0 ;					      int prevX = 0 ;						  
	square = ( square + x + prev_x )		      	x < n ;							      for ( int x = 0 ;						  
	print ( square , end = " " )			      	x ++ ) {						      x <= n ;							  
	prev_x = x					      	  square = ( square + x + prev_x ) ;			      x ++ ) {							  
							      	  cout << square << " " ;				    	square = ( square + x + prevX ) ;			  
							      	  prev_x = x ;						    	cout << square << " " ;					  
							      	}							    	prevX = x ;						  
							      }								      }								  
							      								      return square ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	      FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	    FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X	  FIND_FIRST_NATURAL_NUMBER_WHOSE_FACTORIAL_DIVISIBLE_X
--							      --							    --								  --
def firstFactorialDivisibleNumber ( x ) :		      int firstFactorialDivisibleNumber ( int x ) {		    int firstFactorialDivisibleNumber ( int x ) {		  success : None
    i = 1						      	int i = 1 ;						      int i = 1 ;						  
    fact = 1						      	int fact = 1 ;						      int fact = 1 ;						  
    for i in range ( 1 , x ) :				      	for ( i = 1 ;						      for ( ;							  
	fact = fact * i					      	i < x ;							      i < x ;							  
	if ( fact % x == 0 ) :				      	i ++ ) {						      i ++ ) {							  
	    break					      	  fact = fact * i ;					    	fact = fact * i ;					  
    return i						      	  if ( fact % x == 0 ) break ;				    	if ( ( fact % x == 0 ) ) break ;			  
							      	}							      }								  
							      	return i ;						      return i ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTING_INVERSIONS					      COUNTING_INVERSIONS					    COUNTING_INVERSIONS						  COUNTING_INVERSIONS
--							      --							    --								  --
def getInvCount ( arr , n ) :				      int getInvCount ( int arr [ ] , int n ) {			    int getInvCount ( int * arr , int n ) {			  script_not_found : None
    inv_count = 0					      	int inv_count = 0 ;					      int invCount = 0 ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n - 1 ;						      i < n ;							  
	    if ( arr [ i ] > arr [ j ] ) :		      	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
		inv_count += 1				      	j < n ;							    	for ( int j = i + 1 ;					  
    return inv_count					      	j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ;	    	j < n ;							  
							      	return inv_count ;					    	j ++ ) {						  
							      }								    	  if ( ( arr [ i ] > arr [ j ] ) ) invCount ++ ;	  
							      								    	}							  
							      								      }								  
							      								      return invCount ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			      COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			    COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY			  COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY
--							      --							    --								  --
def countPairs ( arr , n ) :				      int countPairs ( int arr [ ] , int n ) {			    int countPairs ( int * arr , int n ) {			  success : None
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i <= n ;							  
	    if ( arr [ i ] == arr [ j ] ) :		      	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
		ans += 1				      	j < n ;							    	for ( int j = i + 1 ;					  
    return ans						      	j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ;		    	j < n ;							  
							      	return ans ;						    	j ++ ) {						  
							      }								    	  if ( ( arr [ i ] == arr [ j ] ) ) ans ++ ;		  
							      								    	}							  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2		  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE_2
--							      --							    --								  --
def recursiveReverse ( str , i = 0 ) :			      void recursiveReverse ( string & str , int i = 0 ) {	    void recursiveReverse ( string str , int i ) {		  script_not_found : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    if i == n // 2 :					      	if ( i == n / 2 ) return ;				      if ( i == n / 2 ) return ;				  
	return						      	swap ( str [ i ] , str [ n - i - 1 ] ) ;		      str [ i ] = str [ n - i - 1 ] ;				  
    str [ i ] , str [ n - i - 1 ] = str [ n - i - 1 ] , str [ 	recursiveReverse ( str , i + 1 ) ;			      str [ n - i - 1 ] = str [ i ] ;				  
    recursiveReverse ( str , i + 1 )			      }								      recursiveReverse ( str , i + 1 ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE	      QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE		    QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE		  QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE
--							      --							    --								  --
def countInRange ( arr , n , x , y ) :			      int countInRange ( int arr [ ] , int n , int x , int y ) {    int countInRange ( double * arr , int n , double x , double y error : QUERIES_COUNTS_ARRAY_ELEMENTS_VALUES_GIVEN
    count = 0 ;						      	int count = 0 ;						      int count = 0 ;						  _RANGE.cpp: In function ‘int main()’: QUERIES_COUN
    for i in range ( n ) :				      	for ( int i = 0 ;					      ;								  TS_ARRAY_ELEMENTS_VALUES_GIVEN_RANGE.cpp:47:21: er
	if ( arr [ i ] >= x and arr [ i ] <= y ) :	      	i < n ;							      for ( int i = 0 ;						  ror: cannot convert ‘__gnu_cxx::__alloc_traits<std
	    count += 1					      	i ++ ) {						      i < n ;							  ::allocator<int>, int>::value_type*’ {aka ‘int*’}
    return count					      	  if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ;	      i ++ ) {							  to ‘double*’		if(f_filled(&param0[i].front
							      	}							    	if ( ( arr [ i ] >= x && arr [ i ] <= y ) ) count ++ ;	  (),param1[i],param2[i],param3[i]) == f_gold(&param
							      	return count ;						      }								  0[i].front(),param1[i],param2[i],param3[i]))
							      }								      return count ;						  		  ^~~~~~~~~~~~~~~~~~ QUERIES_COUNTS_
							      								    }								  ARRAY_ELEMENTS_VALUES_GIVEN_RANGE.cpp:27:25: note:
							      								    								     initializing argument 1 of ‘int f_filled(double
							      								    								  *, int, double, double)’  int f_filled ( double *
							      								    								  arr , int n , double x , double y ) {
							      								    								      ~~~~~~~~~^~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_INTEGER_OVERFLOW_MULTIPLICATION			      CHECK_INTEGER_OVERFLOW_MULTIPLICATION			    CHECK_INTEGER_OVERFLOW_MULTIPLICATION			  CHECK_INTEGER_OVERFLOW_MULTIPLICATION
--							      --							    --								  --
def isOverflow ( a , b ) :				      bool isOverflow ( long long a , long long b ) {		    bool isOverflow ( long a , long b ) {			  error : CHECK_INTEGER_OVERFLOW_MULTIPLICATION.cpp:
    if ( a == 0 or b == 0 ) :				      	if ( a == 0 || b == 0 ) return false ;			      if ( ( a == 0 ) || ( b == 0 ) ) return false ;		  27:59: warning: integer constant is so large that
	return False					      	long long result = a * b ;				      long result = a * b ;					  it is unsigned    if ( ( result >= 922337203685477
    result = a * b					      	if ( a == result / b ) return false ;			      if ( ( result >= 9223372036854775807 ) || ( result <= - 922 5807 ) || ( result <= - 9223372036854775808 ) ) re
    if ( result >= 9223372036854775807 or result <= - 9223372 	else return true ;					      if ( ( a == ( result /= b ) ) ) {				  sult = 0 ;
	result = 0					      }								    	cout << result /= b << endl ;				  		      ^~~~~~~~~~~~~~~~~~~ CHECK_INTE
    if ( a == ( result // b ) ) :			      								    	return false ;						  GER_OVERFLOW_MULTIPLICATION.cpp: In function ‘bool
	print ( result // b )				      								      }								   f_filled(long int, long int)’: CHECK_INTEGER_OVER
	return False					      								      else return true ;					  FLOW_MULTIPLICATION.cpp:29:25: error: invalid oper
    else :						      								    }								  ands of types ‘long int’ and ‘<unresolved overload
	return True					      								    								  ed function type>’ to binary ‘operator<<’	 cou
							      								    								  t << result /= b << endl ;
							      								    								  ~~^~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON CHECK_GIVEN_CIRCLE_LIES_COMPLETELY_INSIDE_RING_FORMED_TWO_CON
--							      --							    --								  --
def checkcircle ( r , R , r1 , x1 , y1 ) :		      bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) bool checkcircle ( double r , double R , double r1 , double x success : None
    dis = int ( math.sqrt ( x1 * x1 + y1 * y1 ) )	      	int dis = sqrt ( x1 * x1 + y1 * y1 ) ;			      int dis = ( int ) sqrt ( x1 * x1 + y1 * y1 ) ;		  
    return ( dis - r1 >= R and dis + r1 <= r )		      	return ( dis - r1 >= R && dis + r1 <= r ) ;		      return ( dis - r1 >= R && dis + r1 <= r ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_OCTAL_DECIMAL_CONVERSION			      PROGRAM_OCTAL_DECIMAL_CONVERSION				    PROGRAM_OCTAL_DECIMAL_CONVERSION				  PROGRAM_OCTAL_DECIMAL_CONVERSION
--							      --							    --								  --
def octalToDecimal ( n ) :				      int octalToDecimal ( int n ) {				    int octalToDecimal ( int n ) {				  success : None
    num = n						      	int num = n ;						      int num = n ;						  
    dec_value = 0					      	int dec_value = 0 ;					      int decValue = 0 ;					  
    base = 1						      	int base = 1 ;						      int base = 1 ;						  
    temp = num						      	int temp = num ;					      int temp = num ;						  
    while ( temp ) :					      	while ( temp ) {					      while ( ( temp ) ) {					  
	last_digit = temp % 10				      	  int last_digit = temp % 10 ;				    	int lastDigit = temp % 10 ;				  
	temp = int ( temp / 10 )			      	  temp = temp / 10 ;					    	temp = ( int ) ( temp / 10 ) ;				  
	dec_value += last_digit * base			      	  dec_value += last_digit * base ;			    	decValue += lastDigit * base ;				  
	base = base * 8					      	  base = base * 8 ;					    	base = base * 8 ;					  
    return dec_value					      	}							      }								  
							      	return dec_value ;					      return decValue ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC		      PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC			    PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC			  PROGRAM_TO_CHECK_IF_A_MATRIX_IS_SYMMETRIC
--							      --							    --								  --
def isSymmetric ( mat , N ) :				      bool isSymmetric ( int mat [ ] [ MAX ] , int N ) {	    bool isSymmetric ( int * * mat , int N ) {			  script_not_found : None
    for i in range ( N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( N ) :				      	i < N ;							      i < N ;							  
	    if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) :	      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		return False				      	j < N ;							    	for ( int j = 0 ;					  
    return True						      	j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return fal 	j < N ;							  
							      	return true ;						    	j ++ ) {						  
							      }								    	  if ( ( mat [ i ] [ j ] != mat [ j ] [ i ] ) && ( mat [  
							      								    	}							  
							      								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHUFFLE_A_DECK_OF_CARDS_3				      SHUFFLE_A_DECK_OF_CARDS_3					    SHUFFLE_A_DECK_OF_CARDS_3					  SHUFFLE_A_DECK_OF_CARDS_3
--							      --							    --								  --
def shuffle ( card , n ) :				      void shuffle ( int card [ ] , int n ) {			    int getNum ( int * array , int count ) {			  script_not_found : None
    for i in range ( n ) :				      	srand ( time ( 0 ) ) ;					      int i = 0 ;						  
	r = i + ( random.randint ( 0 , 55 ) % ( 52 - i ) )    	for ( int i = 0 ;					      for ( int j = 0 ;						  
	tmp = card [ i ]				      	i < n ;							      j < count ;						  
	card [ i ] = card [ r ]				      	i ++ ) {						      j ++ ) {							  
	card [ r ] = tmp				      	  int r = i + ( rand ( ) % ( 52 - i ) ) ;		    	int r = j + ( rand ( ) % 55 ) % ( 52 - i ) ;		  
							      	  swap ( card [ i ] , card [ r ] ) ;			    	int tmp = array [ i ] ;					  
							      	}							    	array [ i ] = array [ r ] ;				  
							      }								    	array [ r ] = tmp ;					  
							      								      }								  
							      								      return i ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		      MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		    MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET		  MINIMUM_REVOLUTIONS_MOVE_CENTER_CIRCLE_TARGET
--							      --							    --								  --
def minRevolutions ( r , x1 , y1 , x2 , y2 ) :		      int minRevolutions ( double r , int x1 , int y1 , int x2 , in double minRevolutions ( double r , double x1 , double y1 , do script_not_found : None
    d = math.sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * 	double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) *   double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * 
    return math.ceil ( d // ( 2 * r ) )			      	return ceil ( d / ( 2 * r ) ) ;				      return ceil ( d / ( 2 * r ) ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	      ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	    ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX	  ROW_WISE_COMMON_ELEMENTS_TWO_DIAGONALS_SQUARE_MATRIX
--							      --							    --								  --
def countCommon ( mat , n ) :				      int countCommon ( int mat [ ] [ MAX ] , int n ) {		    int countCommon ( int * * mat , int n ) {			  script_not_found : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] :	      	i < n ;							      i < n ;							  
	    res = res + 1				      	i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) re   i ++ ) {							  
    return res						      	return res ;						    	if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res = r 
							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_PROGRAM_PRIME_NUMBER				      RECURSIVE_PROGRAM_PRIME_NUMBER				    RECURSIVE_PROGRAM_PRIME_NUMBER				  RECURSIVE_PROGRAM_PRIME_NUMBER
--							      --							    --								  --
def isPrime ( n , i = 2 ) :				      bool isPrime ( int n , int i = 2 ) {			    bool isPrime ( int n , int i ) {				  success : None
    if ( n <= 2 ) :					      	if ( n <= 2 ) return ( n == 2 ) ? true : false ;	      if ( ( n <= 2 ) ) return ( n == 2 ) ? true : false ;	  
	return True if ( n == 2 ) else False		      	if ( n % i == 0 ) return false ;			      if ( ( n % i ) == 0 ) return false ;			  
    if ( n % i == 0 ) :					      	if ( i * i > n ) return true ;				      if ( ( i * i ) > n ) return true ;			  
	return False					      	return isPrime ( n , i + 1 ) ;				      return isPrime ( n , i + 1 ) ;				  
    if ( i * i > n ) :					      }								    }								  
	return true					      								    								  
    return isPrime ( n , i + 1 )			      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1   DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1   DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1	  DYNAMIC_PROGRAMMING_SET_36_CUT_A_ROPE_TO_MAXIMIZE_PRODUCT_1
--							      --							    --								  --
def maxProd ( n ) :					      int maxProd ( int n ) {					    int maxProd ( int n ) {					  success : None
    if ( n == 2 or n == 3 ) :				      	if ( n == 2 || n == 3 ) return ( n - 1 ) ;		      if ( ( n == 2 ) || ( n == 3 ) ) return ( n - 1 ) ;	  
	return ( n - 1 )				      	int res = 1 ;						      int res = 1 ;						  
    res = 1						      	while ( n > 4 ) {					      while ( ( n > 4 ) ) {					  
    while ( n > 4 ) :					      	  n -= 3 ;						    	n -= 3 ;						  
	n -= 3						      	  res *= 3 ;						    	res *= 3 ;						  
	res *= 3					      	}							      }								  
    return ( n * res )					      	return ( n * res ) ;					      return ( n * res ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			      MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			    MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS			  MINIMUM_TIME_REQUIRED_PRODUCE_M_ITEMS
--							      --							    --								  --
def minTime ( arr , n , m ) :				      int minTime ( int arr [ ] , int n , int m ) {		    int minTime ( int * arr , int n , int m ) {			  script_not_found : None
    t = 0						      	int t = 0 ;						      int t = 0 ;						  
    while ( 1 ) :					      	while ( 1 ) {						      while ( ( 1 ) ) {						  
	items = 0					      	  int items = 0 ;					    	int items = 0 ;						  
	for i in range ( n ) :				      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
	    items += ( t // arr [ i ] )			      	  i < n ;						    	i < n ;							  
	if ( items >= m ) :				      	  i ++ ) items += ( t / arr [ i ] ) ;			    	i ++ ) items += ( t / arr [ i ] ) ;			  
	    return t					      	  if ( items >= m ) return t ;				    	if ( ( items >= m ) ) return t ;			  
	t += 1						      	  t ++ ;						    	t ++ ;							  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES			      POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES			    POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES				  POSSIBLE_FORM_TRIANGLE_ARRAY_VALUES
--							      --							    --								  --
def isPossibleTriangle ( arr , N ) :			      bool isPossibleTriangle ( int arr [ ] , int N ) {		    bool isPossibleTriangle ( int * arr , int N ) {		  failure : #Results: 9, 10
    if N < 3 :						      	if ( N < 3 ) return false ;				      if ( N < 3 ) return false ;				  
	return False					      	sort ( arr , arr + N ) ;				      sort ( arr , arr + N ) ;					  
    arr.sort ( )					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( N - 2 ) :				      	i < N - 2 ;						      i < N - 2 ;						  
	if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] :	      	i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) ret   i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) ret 
	    return True					      }								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2		      MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2		    MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2			  MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_2
--							      --							    --								  --
def middleOfThree ( a , b , c ) :			      int middleOfThree ( int a , int b , int c ) {		    int middleOfThree ( int a , int b , int c ) {		  success : None
    x = a - b						      	int x = a - b ;						      int x = a - b ;						  
    y = b - c						      	int y = b - c ;						      int y = b - c ;						  
    z = a - c						      	int z = a - c ;						      int z = a - c ;						  
    if x * y > 0 :					      	if ( x * y > 0 ) return b ;				      if ( x * y > 0 ) return b ;				  
	return b					      	else if ( x * z > 0 ) return c ;			      else if ( ( x * z > 0 ) ) return c ;			  
    elif ( x * z > 0 ) :				      	else return a ;						      else return a ;						  
	return						      }								    }								  
    else :						      								    								  
	return a					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPETITIVE_ELEMENT_1_N_1_1				      FIND_REPETITIVE_ELEMENT_1_N_1_1				    FIND_REPETITIVE_ELEMENT_1_N_1_1				  FIND_REPETITIVE_ELEMENT_1_N_1_1
--							      --							    --								  --
def findRepeating ( arr , n ) :				      int findRepeating ( int arr [ ] , int n ) {		    int findRepeating ( int * arr , int n ) {			  error : FIND_REPETITIVE_ELEMENT_1_N_1_1.cpp: In fu
    s = set ( )						      	unordered_set < int > s ;				      set < int > s ;						  nction ‘int f_filled(int*, int)’: FIND_REPETITIVE_
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  ELEMENT_1_N_1_1.cpp:36:10: error: ‘rteurn’ was not
	if arr [ i ] in s :				      	i < n ;							      i < n ;							   declared in this scope    return rteurn - 1 ;
	    return arr [ i ]				      	i ++ ) {						      i ++ ) {							  	 ^~~~~~ FIND_REPETITIVE_ELEMENT_1_N_1_1.cpp:
	s.add ( arr [ i ] )				      	  if ( s . find ( arr [ i ] ) != s . end ( ) ) return arr [ 	if ( s . count ( arr [ i ] ) ) return arr [ i ] ;	  36:10: note: suggested alternative: ‘extern’	  re
    rteurn - 1						      	  s . insert ( arr [ i ] ) ;				    	s . insert ( arr [ i ] ) ;				  turn rteurn - 1 ;	      ^~~~~~	       exter
							      	}							      }								  n
							      	return - 1 ;						      return rteurn - 1 ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AREA_QUADRILATERAL				      MAXIMUM_AREA_QUADRILATERAL				    MAXIMUM_AREA_QUADRILATERAL					  MAXIMUM_AREA_QUADRILATERAL
--							      --							    --								  --
def maxArea ( a , b , c , d ) :				      double maxArea ( double a , double b , double c , double d )  double maxArea ( double a , double b , double c , double d )  script_not_found : None
    semiperimeter = ( a + b + c + d ) / 2		      	double semiperimeter = ( a + b + c + d ) / 2 ;		      double semiperimeter = ( a + b + c + d ) / 2 ;		  
    return math.sqrt ( ( semiperimeter - a ) * ( semiperimete 	return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b )   return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) 
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DIGITS_FACTORIAL_SET_1				      COUNT_DIGITS_FACTORIAL_SET_1				    COUNT_DIGITS_FACTORIAL_SET_1				  COUNT_DIGITS_FACTORIAL_SET_1
--							      --							    --								  --
def findDigits ( n ) :					      int findDigits ( int n ) {				    int findDigits ( int n ) {					  success : None
    if ( n < 0 ) :					      	if ( n < 0 ) return 0 ;					      if ( ( n < 0 ) ) return 0 ;				  
	return 0					      	if ( n <= 1 ) return 1 ;				      if ( ( n <= 1 ) ) return 1 ;				  
    if ( n <= 1 ) :					      	double digits = 0 ;					      double digits = 0 ;					  
	return 1					      	for ( int i = 2 ;					      for ( int i = 2 ;						  
    digits = 0						      	i <= n ;						      i <= n ;							  
    for i in range ( 2 , n + 1 ) :			      	i ++ ) digits += log10 ( i ) ;				      i ++ ) digits += log10 ( i ) ;				  
	digits += math.log10 ( i )			      	return floor ( digits ) + 1 ;				      return floor ( digits ) + 1 ;				  
    return math.floor ( digits ) + 1			      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	      CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	    CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT	  CHECK_ARRAY_REPRESENTS_INORDER_BINARY_SEARCH_TREE_NOT
--							      --							    --								  --
def isInorder ( arr , n ) :				      bool isInorder ( int arr [ ] , int n ) {			    bool isInorder ( int * arr , int n ) {			  success : None
    if ( n == 0 or n == 1 ) :				      	if ( n == 0 || n == 1 ) return true ;			      if ( ( n == 0 ) || ( n == 1 ) ) return true ;		  
	return True					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
    for i in range ( 1 , n , 1 ) :			      	i < n ;							      i < n ;							  
	if ( arr [ i - 1 ] > arr [ i ] ) :		      	i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ;	      i += 1 ) if ( ( arr [ i - 1 ] > arr [ i ] ) ) return false  
	    return False				      	return true ;						      return true ;						  
    return True						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_ARRAY_MAJORITY_ELEMENT				      CHECK_ARRAY_MAJORITY_ELEMENT				    CHECK_ARRAY_MAJORITY_ELEMENT				  CHECK_ARRAY_MAJORITY_ELEMENT
--							      --							    --								  --
def isMajority ( a ) :					      bool isMajority ( int a [ ] , int n ) {			    bool isMajority ( string a ) {				  error : CHECK_ARRAY_MAJORITY_ELEMENT.cpp: In funct
    mp = { }						      	unordered_map < int , int > mp ;			      map < int , int > mp ;					  ion ‘int main()’: CHECK_ARRAY_MAJORITY_ELEMENT.cpp
    for i in a :					      	for ( int i = 0 ;					      for ( int i = 0 ;						  :55:21: error: could not convert ‘&(& param0.std::
	if i in mp : mp [ i ] += 1			      	i < n ;							      i < a . length ( ) ;					  vector<std::vector<int> >::operator[](((std::vecto
	else : mp [ i ] = 1				      	i ++ ) mp [ a [ i ] ] ++ ;				      i ++ ) {							  r<std::vector<int> >::size_type)i)))->std::vector<
    for x in mp :					      	for ( auto x : mp ) if ( x . second >= n / 2 ) return true  	if ( mp . count ( i ) ) {				  int>::front()’ from ‘__gnu_cxx::__alloc_traits<std
	if mp [ x ] >= len ( a ) // 2 :			      	return false ;						    	  mp [ i ] ++ ;						  ::allocator<int>, int>::value_type*’ {aka ‘int*’}
	    return True					      }								    	}							  to ‘std::__cxx11::string’ {aka ‘std::__cxx11::basi
    return False					      								    	else {							  c_string<char>’}	    if(f_filled(&param0[i].f
							      								    	  mp [ i ] = 1 ;					  ront(),param1[i]) == f_gold(&param0[i].front(),par
							      								    	}							  am1[i]))			^~~~~~~~~~~~~~~~~~
							      								      }								  
							      								      for ( int x = 0 ;						  
							      								      x < mp . size ( ) ;					  
							      								      x ++ ) {							  
							      								    	if ( mp [ x ] >= a . length ( ) / 2 ) {			  
							      								    	  return true ;						  
							      								    	}							  
							      								      }								  
							      								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3		      COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3		    COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3			  COUNT_WAYS_REACH_NTH_STAIR_USING_STEP_1_2_3
--							      --							    --								  --
def findStep ( n ) :					      public : int findStep ( int n ) {				    int findStep ( int n ) {					  script_not_found : None
    if ( n == 1 or n == 0 ) :				      	if ( n == 1 || n == 0 ) return 1 ;			      if ( ( n == 1 ) || ( n == 0 ) ) return 1 ;		  
	return 1					      	else if ( n == 2 ) return 2 ;				      else if ( ( n == 2 ) ) return 2 ;				  
    elif ( n == 2 ) :					      	else return findStep ( n - 3 ) + findStep ( n - 2 ) + findS   else return findStep ( n - 3 ) + findStep ( n - 2 ) + findS 
	return 2					      }								    }								  
    else :						      								    								  
	return findStep ( n - 3 ) + findStep ( n - 2 ) + find 								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			      NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			    NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES			  NTH_MULTIPLE_NUMBER_FIBONACCI_SERIES
--							      --							    --								  --
def findPosition ( k , n ) :				      int findPosition ( int k , int n ) {			    int findPosition ( int k , int n ) {			  script_not_found : None
    f1 = 0						      	unsigned long long int f1 = 0 , f2 = 1 , f3 ;		      int f1 = 0 ;						  
    f2 = 1						      	for ( int i = 2 ;					      int f2 = 1 ;						  
    i = 2						      	i <= MAX ;						      int i = 2 ;						  
    while i != 0 :					      	i ++ ) {						      while ( i != 0 ) {					  
	f3 = f1 + f2					      	  f3 = f1 + f2 ;					    	int f3 = f1 + f2 ;					  
	f1 = f2						      	  f1 = f2 ;						    	f1 = f2 ;						  
	f2 = f3						      	  f2 = f3 ;						    	f2 = f3 ;						  
	if f2 % k == 0 :				      	  if ( f2 % k == 0 ) return n * i ;			    	if ( f2 % k == 0 ) return n * i ;			  
	    return n * i				      	}							    	i ++ ;							  
	i += 1						      }								      }								  
    return						      								      return 0 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	      MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	    MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY	  MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY
--							      --							    --								  --
def minimum_cost ( a , n ) :				      int minimum_cost ( int a [ ] , int n ) {			    double minimumCost ( double * a , int n ) {			  error : MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRES
    mn = sys.maxsize					      	int mn = INT_MAX ;					      double mn = std :: numeric_limits < double > :: max ( ) ;	  ENTED_ARRAY.cpp: In function ‘int main()’: MINIMUM
    sum = 0						      	int sum = 0 ;						      double sum = 0 ;						  _COST_CONNECT_WEIGHTED_NODES_REPRESENTED_ARRAY.cpp
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  :48:21: error: cannot convert ‘__gnu_cxx::__alloc_
	mn = min ( a [ i ] , mn )			      	i < n ;							      i < n ;							  traits<std::allocator<int>, int>::value_type*’ {ak
	sum += a [ i ]					      	i ++ ) {						      i ++ ) {							  a ‘int*’} to ‘double*’	  if(f_filled(&param
    return mn * ( sum - mn )				      	  mn = min ( a [ i ] , mn ) ;				    	mn = std :: min ( a [ i ] , mn ) ;			  0[i].front(),param1[i]) == f_gold(&param0[i].front
							      	  sum += a [ i ] ;					    	sum += a [ i ] ;					  (),param1[i]))		      ^~~~~~~~~~~~~~
							      	}							      }								  ~~~~ MINIMUM_COST_CONNECT_WEIGHTED_NODES_REPRESENT
							      	return mn * ( sum - mn ) ;				      return mn * ( sum - mn ) ;				  ED_ARRAY.cpp:29:28: note:   initializing argument
							      }								    }								  1 of ‘double f_filled(double*, int)’	double f_fil
							      								    								  led ( double * a , int n ) {			  ~~
							      								    								  ~~~~~~~^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_DIGIT_RAISED_POWER_B				      K_TH_DIGIT_RAISED_POWER_B					    K_TH_DIGIT_RAISED_POWER_B					  K_TH_DIGIT_RAISED_POWER_B
--							      --							    --								  --
def kthdigit ( a , b , k ) :				      int kthdigit ( int a , int b , int k ) {			    int kthdigit ( int a , int b , int k ) {			  failure : #Results: 6, 10
    p = a ** b						      	int p = pow ( a , b ) ;					      int p = a * b ;						  
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    while ( p > 0 and count < k ) :			      	while ( p > 0 && count < k ) {				      while ( ( p > 0 ) && ( count < k ) ) {			  
	rem = p % 10					      	  int rem = p % 10 ;					    	int rem = p % 10 ;					  
	count = count + 1				      	  count ++ ;						    	count = count + 1 ;					  
	if ( count == k ) :				      	  if ( count == k ) return rem ;			    	if ( ( count == k ) ) return rem ;			  
	    return rem					      	  p = p / 10 ;						    	p = p / 10 ;						  
	p = p / 10					      	}							      }								  
							      	return 0 ;						      return 0 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1		      COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1			    COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1			  COUNTING_PAIRS_PERSON_CAN_FORM_PAIR_ONE_1
--							      --							    --								  --
def numberOfWays ( x ) :				      int numberOfWays ( int x ) {				    int numberOfWays ( int x ) {				  timeout : None
    if x == 0 or x == 1 :				      	int dp [ x + 1 ] ;					      if ( x == 0 || x == 1 ) return 1 ;			  
	return 1					      	dp [ 0 ] = dp [ 1 ] = 1 ;				      else return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOf 
    else :						      	for ( int i = 2 ;					    }								  
	return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberO 	i <= x ;						    								  
							      	i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; 								  
							      	return dp [ x ] ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1		      FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1		    FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1			  FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE_1
--							      --							    --								  --
def sumNodes ( l ) :					      int sumNodes ( int l ) {					    int sumNodes ( int l ) {					  script_not_found : None
    leafNodeCount = math.pow ( 2 , l - 1 )		      	int leafNodeCount = pow ( 2 , l - 1 ) ;			      double leafNodeCount = pow ( 2 , l - 1 ) ;		  
    sumLastLevel = 0					      	int sumLastLevel = 0 ;					      double sumLastLevel ;					  
    sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 )  	sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) /    sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) )  
    sum = sumLastLevel * l				      	int sum = sumLastLevel * l ;				      double sum = sumLastLevel * l ;				  
    return int ( sum )					      	return sum ;						      return ( int ) sum ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEONARDO_NUMBER_1					      LEONARDO_NUMBER_1						    LEONARDO_NUMBER_1						  LEONARDO_NUMBER_1
--							      --							    --								  --
def leonardo ( n ) :					      int leonardo ( int n ) {					    int leonardo ( int n ) {					  success : None
    dp = [ ]						      	int dp [ n + 1 ] ;					      int dp [ n + 1 ] ;					  
    dp.append ( 1 )					      	dp [ 0 ] = dp [ 1 ] = 1 ;				      dp [ 0 ] = 1 ;						  
    dp.append ( 1 )					      	for ( int i = 2 ;					      dp [ 1 ] = 1 ;						  
    for i in range ( 2 , n + 1 ) :			      	i <= n ;						      for ( int i = 2 ;						  
	dp.append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 )	      	i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ;	      i <= n ;							  
    return dp [ n ]					      	return dp [ n ] ;					      i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ;	  
							      }								      return dp [ n ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_ADDITION_TWO_MATRICES				      C_PROGRAM_ADDITION_TWO_MATRICES				    C_PROGRAM_ADDITION_TWO_MATRICES				  C_PROGRAM_ADDITION_TWO_MATRICES
--							      --							    --								  --
def add ( A , B , C ) :					      void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N  void add ( int * A , int * B , int * C ) {			  script_not_found : None
    for i in range ( N ) :				      	int i , j ;						      for ( int i = 0 ;						  
	for j in range ( N ) :				      	for ( i = 0 ;						      i < N ;							  
	    C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ]     	i < N ;							      i ++ ) {							  
							      	i ++ ) for ( j = 0 ;					    	for ( int j = 0 ;					  
							      	j < N ;							    	j < N ;							  
							      	j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;	    	j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ;	  
							      }								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	      PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	    PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1	  PROGRAM_CHECK_ARRAY_SORTED_NOT_ITERATIVE_RECURSIVE_1
--							      --							    --								  --
def arraySortedOrNot ( arr , n ) :			      bool arraySortedOrNot ( int arr [ ] , int n ) {		    bool arraySortedOrNot ( int * arr , int n ) {		  success : None
    if ( n == 0 or n == 1 ) :				      	if ( n == 0 || n == 1 ) return true ;			      if ( ( n == 0 ) || ( n == 1 ) ) return true ;		  
	return True					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
    for i in range ( 1 , n ) :				      	i < n ;							      i < n ;							  
	if ( arr [ i - 1 ] > arr [ i ] ) :		      	i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ;	      i ++ ) if ( ( arr [ i - 1 ] > arr [ i ] ) ) return false ;  
	    return False				      	return true ;						      return true ;						  
    return True						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_PAIRWISE_PRODUCTS_1					      SUM_PAIRWISE_PRODUCTS_1					    SUM_PAIRWISE_PRODUCTS_1					  SUM_PAIRWISE_PRODUCTS_1
--							      --							    --								  --
def findSum ( n ) :					      long long int findSum ( int n ) {				    int findSum ( int n ) {					  success : None
    multiTerms = n * ( n + 1 ) // 2			      	long long int multiTerms = n * ( n + 1 ) / 2 ;		      int multiTerms = n * ( n + 1 ) / 2 ;			  
    sm = multiTerms					      	long long int sum = multiTerms ;			      int sm = multiTerms ;					  
    for i in range ( 2 , n + 1 ) :			      	for ( int i = 2 ;					      for ( int i = 2 ;						  
	multiTerms = multiTerms - ( i - 1 )		      	i <= n ;						      i <= n ;							  
	sm = sm + multiTerms * i			      	i ++ ) {						      i ++ ) {							  
    return sm						      	  multiTerms = multiTerms - ( i - 1 ) ;			    	multiTerms = multiTerms - ( i - 1 ) ;			  
							      	  sum = sum + multiTerms * i ;				    	sm = sm + multiTerms * i ;				  
							      	}							      }								  
							      	return sum ;						      return sm ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_STRING_START_END_GEEKS			      PROGRAM_FIND_STRING_START_END_GEEKS			    PROGRAM_FIND_STRING_START_END_GEEKS				  PROGRAM_FIND_STRING_START_END_GEEKS
--							      --							    --								  --
def isCornerPresent ( str , corner ) :			      bool isCornerPresent ( string str , string corner ) {	    bool isCornerPresent ( string str , string corner ) {	  success : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    cl = len ( corner )					      	int cl = corner . length ( ) ;				      int cl = corner . length ( ) ;				  
    if ( n < cl ) :					      	if ( n < cl ) return false ;				      if ( ( n < cl ) ) return false ;				  
	return False					      	return ( str . substr ( 0 , cl ) . compare ( corner ) == 0    return ( ( str . substr ( 0 , cl ) == corner ) && ( str . s 
    return ( ( str [ : cl ] == corner ) and ( str [ n - cl :  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX		      PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX		    PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX			  PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX
--							      --							    --								  --
def isDiagonalMatrix ( mat ) :				      bool isDiagonalMatrix ( int mat [ N ] [ N ] ) {		    bool isDiagonalMatrix ( int * * mat ) {			  script_not_found : None
    for i in range ( 0 , N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( 0 , N ) :			      	i < N ;							      i != N ;							  
	    if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) :  	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		return False				      	j < N ;							    	for ( int j = 0 ;					  
    return True						      	j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return 	j != N ;						  
							      	return true ;						    	j ++ ) {						  
							      }								    	  if ( ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) ) retur 
							      								    	}							  
							      								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	      MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	    MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1	  MINIMUM_FLIP_REQUIRED_MAKE_BINARY_MATRIX_SYMMETRIC_1
--							      --							    --								  --
def minimumflip ( mat , n ) :				      int minimumflip ( int mat [ ] [ N ] , int n ) {		    int minimumflip ( int * * mat , int n ) {			  script_not_found : None
    flip = 0						      	int flip = 0 ;						      int flip = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i ) :				      	i < n ;							      i < n ;							  
	    if mat [ i ] [ j ] != mat [ j ] [ i ] :	      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		flip += 1				      	j < i ;							    	for ( int j = 0 ;					  
    return flip						      	j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ;  	j < i ;							  
							      	return flip ;						    	j ++ ) {						  
							      }								    	  if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ;	  
							      								    	}							  
							      								      }								  
							      								      return flip ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		      FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		    FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME		  FIND_INDEX_GIVEN_FIBONACCI_NUMBER_CONSTANT_TIME
--							      --							    --								  --
def findIndex ( n ) :					      int findIndex ( int n ) {					    int findIndex ( int n ) {					  success : None
    if ( n <= 1 ) :					      	if ( n <= 1 ) return n ;				      if ( ( n <= 1 ) ) return n ;				  
	return n					      	int a = 0 , b = 1 , c = 1 ;				      int a = 0 ;						  
    a = 0						      	int res = 1 ;						      int b = 1 ;						  
    b = 1						      	while ( c < n ) {					      int c = 1 ;						  
    c = 1						      	  c = a + b ;						      int res = 1 ;						  
    res = 1						      	  res ++ ;						      while ( ( c < n ) ) {					  
    while ( c < n ) :					      	  a = b ;						    	c = a + b ;						  
	c = a + b					      	  b = c ;						    	res = res + 1 ;						  
	res = res + 1					      	}							    	a = b ;							  
	a = b						      	return res ;						    	b = c ;							  
	b = c						      }								      }								  
    return res						      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				      CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				    CONSTRUCT_ARRAY_PAIR_SUM_ARRAY				  CONSTRUCT_ARRAY_PAIR_SUM_ARRAY
--							      --							    --								  --
def constructArr ( arr , pair , n ) :			      void constructArr ( int arr [ ] , int pair [ ] , int n ) {    int getNum ( int * num ) {					  script_not_found : None
    arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] )  	arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) /    int i ;							  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( i = 0 ;						  
	arr [ i ] = pair [ i - 1 ] - arr [ 0 ]		      	i < n ;							      i < 4 ;							  
							      	i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ;		      i ++ ) {							  
							      }								    	if ( num [ i ] == 0 ) num [ i ] = i + 1 ;		  
							      								    	else num [ i ] = num [ i ] - 1 ;			  
							      								      }								  
							      								      return i ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MARKOV_MATRIX						      MARKOV_MATRIX						    MARKOV_MATRIX						  MARKOV_MATRIX
--							      --							    --								  --
def checkMarkov ( m ) :					      bool checkMarkov ( double m [ ] [ n ] ) {			    bool checkMarkov ( int * m ) {				  script_not_found : None
    for i in range ( 0 , len ( m ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	sm = 0						      	i < n ;							      i != sizeof ( m ) / sizeof ( int ) ;			  
	for j in range ( 0 , len ( m [ i ] ) ) :	      	i ++ ) {						      i ++ ) {							  
	    sm = sm + m [ i ] [ j ]			      	  double sum = 0 ;					    	int sm = 0 ;						  
	if ( sm != 1 ) :				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    return False				      	  j < n ;						    	j != sizeof ( m [ i ] ) / sizeof ( int ) ;		  
    return True						      	  j ++ ) sum = sum + m [ i ] [ j ] ;			    	j ++ ) sm = sm + m [ i ] [ j ] ;			  
							      	  if ( sum != 1 ) return false ;			    	if ( ( sm != 1 ) ) return false ;			  
							      	}							      }								  
							      	return true ;						      return true ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MODULUS_TWO_FLOAT_DOUBLE_NUMBERS			      MODULUS_TWO_FLOAT_DOUBLE_NUMBERS				    MODULUS_TWO_FLOAT_DOUBLE_NUMBERS				  MODULUS_TWO_FLOAT_DOUBLE_NUMBERS
--							      --							    --								  --
def findMod ( a , b ) :					      double findMod ( double a , double b ) {			    int findMod ( int a , int b ) {				  failure : #Results: 7, 10
    if ( a < 0 ) :					      	double mod ;						      if ( ( a < 0 ) ) a = - a ;				  
	a = - a						      	if ( a < 0 ) mod = - a ;				      if ( ( b < 0 ) ) b = - b ;				  
    if ( b < 0 ) :					      	else mod = a ;						      int mod = a ;						  
	b = - b						      	if ( b < 0 ) b = - b ;					      while ( ( mod >= b ) ) mod = mod - b ;			  
    mod = a						      	while ( mod >= b ) mod = mod - b ;			      if ( ( a < 0 ) ) return - mod ;				  
    while ( mod >= b ) :				      	if ( a < 0 ) return - mod ;				      return mod ;						  
	mod = mod - b					      	return mod ;						    }								  
    if ( a < 0 ) :					      }								    								  
	return - mod					      								    								  
    return mod						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE		      PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE		    PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE			  PROGRAM_REVERSE_STRING_ITERATIVE_RECURSIVE
--							      --							    --								  --
def recursiveReverse ( str ) :				      void recursiveReverse ( string & str ) {			    void recursiveReverse ( string str ) {			  script_not_found : None
    stack = [ ]						      	stack < char > st ;					      stack < char > stack ;					  
    for i in range ( len ( str ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	stack.append ( str [ i ] )			      	i < str . length ( ) ;					      i < str . length ( ) ;					  
    for i in range ( len ( str ) ) :			      	i ++ ) st . push ( str [ i ] ) ;			      i ++ ) stack . push ( str [ i ] ) ;			  
	str [ i ] = stack.pop ( )			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
							      	i < str . length ( ) ;					      i < str . length ( ) ;					  
							      	i ++ ) {						      i ++ ) str [ i ] = stack . top ( ) ;			  
							      	  str [ i ] = st . top ( ) ;				    }								  
							      	  st . pop ( ) ;					    								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_SUBTRACTION_MATICES				      C_PROGRAM_SUBTRACTION_MATICES				    C_PROGRAM_SUBTRACTION_MATICES				  C_PROGRAM_SUBTRACTION_MATICES
--							      --							    --								  --
def multiply ( A , B , C ) :				      void multiply ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] void multiply ( int * * A , int * * B , int * * C ) {	  script_not_found : None
    for i in range ( N ) :				      	int i , j ;						      for ( int i = 0 ;						  
	for j in range ( N ) :				      	for ( i = 0 ;						      i < N ;							  
	    C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ]     	i < N ;							      i ++ ) {							  
							      	i ++ ) for ( j = 0 ;					    	for ( int j = 0 ;					  
							      	j < N ;							    	j < N ;							  
							      	j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;	    	j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ;	  
							      }								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	      MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	    MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED	  MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED
--							      --							    --								  --
def minValue ( A , B , n ) :				      int minValue ( int A [ ] , int B [ ] , int n ) {		    double minValue ( double * A , double * B , int n ) {	  error : MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIO
    sorted ( A )					      	sort ( A , A + n ) ;					      sort ( A ) ;						  NS_ALLOWED.cpp: In function ‘double f_filled(doubl
    sorted ( B )					      	sort ( B , B + n ) ;					      sort ( B ) ;						  e*, double*, int)’: MINIMIZE_SUM_PRODUCT_TWO_ARRAY
    result = 0						      	int result = 0 ;					      double result = 0 ;					  S_PERMUTATIONS_ALLOWED.cpp:28:12: error: no matchi
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  ng function for call to ‘sort(double*&)’    sort (
	result += ( A [ i ] * B [ n - i - 1 ] )		      	i < n ;							      i < n ;							   A ) ;	     ^ In file included from /usr/in
    return result					      	i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ;	      i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ;		  clude/c++/8/algorithm:62,		     from /u
							      	return result ;						      return result ;						  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      }								    }								  :65,			from MINIMIZE_SUM_PRODUCT_TW
							      								    								  O_ARRAYS_PERMUTATIONS_ALLOWED.cpp:14: /usr/include
							      								    								  /c++/8/bits/stl_algo.h:4824:5: note: candidate: ‘t
							      								    								  emplate<class _RAIter> void std::sort(_RAIter, _RA
							      								    								  Iter)’      sort(_RandomAccessIterator __first, _R
							      								    								  andomAccessIterator __last)	   ^~~~ /usr/include
							      								    								  /c++/8/bits/stl_algo.h:4824:5: note:	 template ar
							      								    								  gument deduction/substitution failed: MINIMIZE_SUM
							      								    								  _PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED.cpp:28:12
							      								    								  : note:   candidate expects 2 arguments, 1 provide
							      								    								  d    sort ( A ) ;		^ In file included f
							      								    								  rom /usr/include/c++/8/algorithm:62,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:65,		   from MINIMIZE_SUM
							      								    								  _PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED.cpp:14: /
							      								    								  usr/include/c++/8/bits/stl_algo.h:4854:5: note: ca
							      								    								  ndidate: ‘template<class _RAIter, class _Compare>
							      								    								  void std::sort(_RAIter, _RAIter, _Compare)’	   s
							      								    								  ort(_RandomAccessIterator __first, _RandomAccessIt
							      								    								  erator __last,      ^~~~ /usr/include/c++/8/bits/s
							      								    								  tl_algo.h:4854:5: note:   template argument deduct
							      								    								  ion/substitution failed: MINIMIZE_SUM_PRODUCT_TWO_
							      								    								  ARRAYS_PERMUTATIONS_ALLOWED.cpp:28:12: note:	 can
							      								    								  didate expects 3 arguments, 1 provided    sort ( A
							      								    								   ) ;		   ^ MINIMIZE_SUM_PRODUCT_TWO_ARRAYS
							      								    								  _PERMUTATIONS_ALLOWED.cpp:29:12: error: no matchin
							      								    								  g function for call to ‘sort(double*&)’    sort (
							      								    								  B ) ;		    ^ In file included from /usr/inc
							      								    								  lude/c++/8/algorithm:62,		    from /us
							      								    								  r/include/c++/8/x86_64-redhat-linux/bits/stdc++.h:
							      								    								  65,		       from MINIMIZE_SUM_PRODUCT_TWO
							      								    								  _ARRAYS_PERMUTATIONS_ALLOWED.cpp:14: /usr/include/
							      								    								  c++/8/bits/stl_algo.h:4824:5: note: candidate: ‘te
							      								    								  mplate<class _RAIter> void std::sort(_RAIter, _RAI
							      								    								  ter)’	     sort(_RandomAccessIterator __first, _Ra
							      								    								  ndomAccessIterator __last)	  ^~~~ /usr/include/
							      								    								  c++/8/bits/stl_algo.h:4824:5: note:	template arg
							      								    								  ument deduction/substitution failed: MINIMIZE_SUM_
							      								    								  PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED.cpp:29:12:
							      								    								   note:   candidate expects 2 arguments, 1 provided
							      								    								      sort ( B ) ;	       ^ In file included fr
							      								    								  om /usr/include/c++/8/algorithm:62,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:65,		  from MINIMIZE_SUM_
							      								    								  PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLOWED.cpp:14: /u
							      								    								  sr/include/c++/8/bits/stl_algo.h:4854:5: note: can
							      								    								  didate: ‘template<class _RAIter, class _Compare> v
							      								    								  oid std::sort(_RAIter, _RAIter, _Compare)’	  so
							      								    								  rt(_RandomAccessIterator __first, _RandomAccessIte
							      								    								  rator __last,	     ^~~~ /usr/include/c++/8/bits/st
							      								    								  l_algo.h:4854:5: note:   template argument deducti
							      								    								  on/substitution failed: MINIMIZE_SUM_PRODUCT_TWO_A
							      								    								  RRAYS_PERMUTATIONS_ALLOWED.cpp:29:12: note:	cand
							      								    								  idate expects 3 arguments, 1 provided	   sort ( B
							      								    								  ) ;		  ^ MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_
							      								    								  PERMUTATIONS_ALLOWED.cpp: In function ‘int main()’
							      								    								  : MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALL
							      								    								  OWED.cpp:45:21: error: cannot convert ‘__gnu_cxx::
							      								    								  __alloc_traits<std::allocator<int>, int>::value_ty
							      								    								  pe*’ {aka ‘int*’} to ‘double*’	  if(f_fille
							      								    								  d(&param0[i].front(),&param1[i].front(),param2[i])
							      								    								   == f_gold(&param0[i].front(),&param1[i].front(),p
							      								    								  aram2[i]))			  ^~~~~~~~~~~~~~~~~~
							      								    								   MINIMIZE_SUM_PRODUCT_TWO_ARRAYS_PERMUTATIONS_ALLO
							      								    								  WED.cpp:27:28: note:	 initializing argument 1 of
							      								    								  ‘double f_filled(double*, double*, int)’  double f
							      								    								  _filled ( double * A , double * B , int n ) {
							      								    								  		 ~~~~~~~~~^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS  DECIMAL_BINARY_CONVERSION_WITHOUT_USING_ARITHMETIC_OPERATORS
--							      --							    --								  --
def decToBin ( n ) :					      string decToBin ( int n ) {				    string decToBin ( int n ) {					  success : None
    if ( n == 0 ) :					      	if ( n == 0 ) return "0" ;				      if ( ( n == 0 ) ) return "0" ;				  
	return "0"					      	string bin = "" ;					      string bin ;						  
    bin = ""						      	while ( n > 0 ) {					      while ( ( n > 0 ) ) {					  
    while ( n > 0 ) :					      	  bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ;		    	if ( ( n & 1 ) == 0 ) bin = "0" + bin ;			  
	if ( n & 1 == 0 ) :				      	  n >>= 1 ;						    	else bin = "1" + bin ;					  
	    bin = '0' + bin				      	}							    	n = n >> 1 ;						  
	else :						      	return bin ;						      }								  
	    bin = '1' + bin				      }								      return bin ;						  
	n = n >> 1					      								    }								  
    return bin						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ROTATE_MATRIX_180_DEGREE				      ROTATE_MATRIX_180_DEGREE					    ROTATE_MATRIX_180_DEGREE					  ROTATE_MATRIX_180_DEGREE
--							      --							    --								  --
def rotateMatrix ( mat ) :				      void rotateMatrix ( int mat [ ] [ N ] ) {			    int rotateMatrix ( int * * mat ) {				  script_not_found : None
    i = N - 1						      	for ( int i = N - 1 ;					      int i = N - 1 ;						  
    while ( i >= 0 ) :					      	i >= 0 ;						      while ( ( i >= 0 ) && ( i < N ) ) {			  
	j = N - 1					      	i -- ) {						    	int j = N - 1 ;						  
	while ( j >= 0 ) :				      	  for ( int j = N - 1 ;					    	while ( ( j >= 0 ) ) {					  
	    print ( mat [ i ] [ j ] , end = " " )	      	  j >= 0 ;						    	  cout << mat [ i ] [ j ] << " " ;			  
	    j = j - 1					      	  j -- ) printf ( "%d " , mat [ i ] [ j ] ) ;		    	  j = j - 1 ;						  
	print ( )					      	  printf ( "\n" ) ;					    	}							  
	i = i - 1					      	}							    	cout << endl ;						  
							      }								    	i = i - 1 ;						  
							      								      }								  
							      								      return i ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA FAST_MULTIPLICATION_METHOD_WITHOUT_USING_MULTIPLICATION_OPERA
--							      --							    --								  --
def russianPeasant ( a , b ) :				      unsigned int russianPeasant ( unsigned int a , unsigned int b int russianPeasant ( int a , int b ) {			  success : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    while ( b > 0 ) :					      	while ( b > 0 ) {					      while ( ( b > 0 ) ) {					  
	if ( b & 1 ) :					      	  if ( b & 1 ) res = res + a ;				    	if ( ( b & 1 ) != 0 ) res = res + a ;			  
	    res = res + a				      	  a = a << 1 ;						    	a = a << 1 ;						  
	a = a << 1					      	  b = b >> 1 ;						    	b = b >> 1 ;						  
	b = b >> 1					      	}							      }								  
    return res						      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPLIT_ARRAY_ADD_FIRST_PART_END				      SPLIT_ARRAY_ADD_FIRST_PART_END				    SPLIT_ARRAY_ADD_FIRST_PART_END				  SPLIT_ARRAY_ADD_FIRST_PART_END
--							      --							    --								  --
def splitArr ( arr , n , k ) :				      void splitArr ( int arr [ ] , int n , int k ) {		    void splitArr ( int * arr , int n , int k ) {		  success : None
    for i in range ( 0 , k ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	x = arr [ 0 ]					      	i < k ;							      i != k ;							  
	for j in range ( 0 , n - 1 ) :			      	i ++ ) {						      i ++ ) {							  
	    arr [ j ] = arr [ j + 1 ]			      	  int x = arr [ 0 ] ;					    	int x = arr [ 0 ] ;					  
	arr [ n - 1 ] = x				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
							      	  j < n - 1 ;						    	j <= n - 1 ;						  
							      	  ++ j ) arr [ j ] = arr [ j + 1 ] ;			    	j ++ ) arr [ j ] = arr [ j + 1 ] ;			  
							      	  arr [ n - 1 ] = x ;					    	arr [ n - 1 ] = x ;					  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B			      COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B				    COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B				  COUNT_NUMBER_PAIRS_N_B_N_GCD_B_B
--							      --							    --								  --
def CountPairs ( n ) :					      int CountPairs ( int n ) {				    double CountPairs ( double n ) {				  failure : #Results: 0, 10
    k = n						      	int k = n ;						      double k = n ;						  
    imin = 1						      	int imin = 1 ;						      double imin = 1 ;						  
    ans = 0						      	int ans = 0 ;						      double ans = 0 ;						  
    while ( imin <= n ) :				      	while ( imin <= n ) {					      while ( ( imin <= n ) && ( imin >= n ) ) {		  
	imax = n / k					      	  int imax = n / k ;					    	double imax = n / k ;					  
	ans += k * ( imax - imin + 1 )			      	  ans += k * ( imax - imin + 1 ) ;			    	ans += k * ( imax - imin + 1 ) ;			  
	imin = imax + 1					      	  imin = imax + 1 ;					    	imin = imax + 1 ;					  
	k = n / imin					      	  k = n / imin ;					    	k = n / imin ;						  
    return ans						      	}							      }								  
							      	return ans ;						      return ans ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION     DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION	    DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION	  DISTRIBUTING_M_ITEMS_CIRCLE_SIZE_N_STARTING_K_TH_POSITION
--							      --							    --								  --
def lastPosition ( n , m , k ) :			      int lastPosition ( int n , int m , int k ) {		    int lastPosition ( int n , int m , int k ) {		  success : None
    if ( m <= n - k + 1 ) :				      	if ( m <= n - k + 1 ) return m + k - 1 ;		      if ( ( m <= n - k + 1 ) ) return m + k - 1 ;		  
	return m + k - 1				      	m = m - ( n - k + 1 ) ;					      m = m - ( n - k + 1 ) ;					  
    m = m - ( n - k + 1 )				      	return ( m % n == 0 ) ? n : ( m % n ) ;			      if ( ( m % n == 0 ) ) return n ;				  
    if ( m % n == 0 ) :					      }								      else return m % n ;					  
	return n					      								    }								  
    else :						      								    								  
	return m % n					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PAPER_CUT_MINIMUM_NUMBER_SQUARES			      PAPER_CUT_MINIMUM_NUMBER_SQUARES				    PAPER_CUT_MINIMUM_NUMBER_SQUARES				  PAPER_CUT_MINIMUM_NUMBER_SQUARES
--							      --							    --								  --
def minimumSquare ( a , b ) :				      int minimumSquare ( int a , int b ) {			    int minimumSquare ( int a , int b ) {			  failure : #Results: 6, 10
    result = 0						      	long long result = 0 , rem = 0 ;			      int result = 0 ;						  
    rem = 0						      	if ( a < b ) swap ( a , b ) ;				      int rem ;							  
    if ( a < b ) :					      	while ( b > 0 ) {					      if ( ( a < b ) ) a = b ;					  
	a , b = b , a					      	  result += a / b ;					      while ( ( b > 0 ) ) {					  
    while ( b > 0 ) :					      	  long long rem = a % b ;				    	result += ( int ) ( a / b ) ;				  
	result += int ( a / b )				      	  a = b ;						    	rem = ( int ) ( a % b ) ;				  
	rem = int ( a % b )				      	  b = rem ;						    	a = b ;							  
	a = b						      	}							    	b = rem ;						  
	b = rem						      	return result ;						      }								  
    return result					      }								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS		      PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS		    PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS			  PROGRAM_TO_PRINT_FIRST_N_FIBONACCI_NUMBERS
--							      --							    --								  --
def printFibonacciNumbers ( n ) :			      void printFibonacciNumbers ( int n ) {			    int printFibonacciNumbers ( int n ) {			  script_not_found : None
    f1 = 0						      	int f1 = 0 , f2 = 1 , i ;				      int f1 = 0 ;						  
    f2 = 1						      	if ( n < 1 ) return ;					      int f2 = 1 ;						  
    if ( n < 1 ) :					      	for ( i = 1 ;						      if ( ( n < 1 ) ) return n ;				  
	return						      	i <= n ;						      for ( int x = 0 ;						  
    for x in range ( 0 , n ) :				      	i ++ ) {						      ;								  
	print ( f2 , end = " " )			      	  cout << f2 << " " ;					      x ++ ) {							  
	next = f1 + f2					      	  int next = f1 + f2 ;					    	cout << f2 << " " ;					  
	f1 = f2						      	  f1 = f2 ;						    	int next = f1 + f2 ;					  
	f2 = next					      	  f2 = next ;						    	f1 = f2 ;						  
							      	}							    	f2 = next ;						  
							      }								      }								  
							      								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION		      LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION			    LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION			  LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION
--							      --							    --								  --
def minLexRotation ( str_ ) :				      string minLexRotation ( string str ) {			    string minLexRotation ( string str_ ) {			  error : LEXICOGRAPHICALLY_MINIMUM_STRING_ROTATION.
    n = len ( str_ )					      	int n = str . length ( ) ;				      int n = str_ . length ( ) ;				  cpp: In function ‘std::__cxx11::string f_filled(st
    arr = [ 0 ] * n					      	string arr [ n ] ;					      string arr ;						  d::__cxx11::string)’: LEXICOGRAPHICALLY_MINIMUM_ST
    concat = str_ + str_				      	string concat = str + str ;				      arr . reserve ( n ) ;					  RING_ROTATION.cpp:35:62: error: no matching functi
    for i in range ( n ) :				      	for ( int i = 0 ;					      string concat = str_ + str_ ;				  on for call to ‘std::__cxx11::basic_string<char>::
	arr [ i ] = concat [ i : n + i ]		      	i < n ;							      for ( int i = 0 ;						  push_back(std::__cxx11::basic_string<char>)’	  i
    arr.sort ( )					      	i ++ ) arr [ i ] = concat . substr ( i , n ) ;		      i < n ;							  ++ ) arr . push_back ( concat . substr ( i , n + i
    return arr [ 0 ]					      	sort ( arr , arr + n ) ;				      i ++ ) arr . push_back ( concat . substr ( i , n + i - i )   - i ) ) ;
							      	return arr [ 0 ] ;					      sort ( arr . begin ( ) , arr . end ( ) ) ;		  			 ^ In file included from /us
							      }								      return arr ;						  r/include/c++/8/string:52,		      from /
							      								    }								  usr/include/c++/8/bits/locale_classes.h:40,
							      								    								  	     from /usr/include/c++/8/bits/ios_base.h
							      								    								  :41,			from /usr/include/c++/8/ios:
							      								    								  42,		       from /usr/include/c++/8/ostre
							      								    								  am:38,		  from /usr/include/c++/8/io
							      								    								  stream:39,		      from LEXICOGRAPHICALLY
							      								    								  _MINIMUM_STRING_ROTATION.cpp:8: /usr/include/c++/8
							      								    								  /bits/basic_string.h:1349:7: note: candidate: ‘voi
							      								    								  d std::__cxx11::basic_string<_CharT, _Traits, _All
							      								    								  oc>::push_back(_CharT) [with _CharT = char; _Trait
							      								    								  s = std::char_traits<char>; _Alloc = std::allocato
							      								    								  r<char>]’	   push_back(_CharT __c)	^~~~
							      								    								  ~~~~~ /usr/include/c++/8/bits/basic_string.h:1349:
							      								    								  7: note:   no known conversion for argument 1 from
							      								    								   ‘std::__cxx11::basic_string<char>’ to ‘char’
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN EFFICIENT_SEARCH_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACEN
--							      --							    --								  --
def search ( arr , n , x ) :				      int search ( int arr [ ] , int n , int x ) {		    int search ( int * arr , int n , int x ) {			  failure : #Results: 5, 10
    i = 0						      	int i = 0 ;						      int i = 0 ;						  
    while ( i <= n - 1 ) :				      	while ( i <= n - 1 ) {					      while ( ( i <= n - 1 ) && ( arr [ i ] == x ) ) {		  
	if ( arr [ i ] == x ) :				      	  if ( arr [ i ] == x ) return i ;			    	return i ;						  
	    return i					      	  i += abs ( arr [ i ] - x ) ;				      }								  
	i += abs ( arr [ i ] - x )			      	}							      i += abs ( arr [ i ] - x ) ;				  
    return - 1						      	return - 1 ;						      return - 1 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			      HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			    HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN			  HEIGHT_N_ARY_TREE_PARENT_ARRAY_GIVEN
--							      --							    --								  --
def findHeight ( parent , n ) :				      int findHeight ( int * parent , int n ) {			    int findHeight ( int * parent , int n ) {			  script_not_found : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	p = i						      	i < n ;							      i < n ;							  
	current = 1					      	i ++ ) {						      i ++ ) {							  
	while ( parent [ p ] != - 1 ) :			      	  int p = i , current = 1 ;				    	int p = i ;						  
	    current += 1				      	  while ( parent [ p ] != - 1 ) {			    	int current = 1 ;					  
	    p = parent [ p ]				      	    current ++ ;					    	while ( ( parent [ p ] != - 1 ) && ( parent [ p ] != - 1  
	res = max ( res , current )			      	    p = parent [ p ] ;					    	  current ++ ;						  
    return res						      	  }							    	  p = parent [ p ] ;					  
							      	  res = max ( res , current ) ;				    	}							  
							      	}							    	res = max ( res , current ) ;				  
							      	return res ;						      }								  
							      }								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER   MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER   MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER	  MAXIMUM_LENGTH_PREFIX_ONE_STRING_OCCURS_SUBSEQUENCE_ANOTHER
--							      --							    --								  --
def maxPrefix ( s , t ) :				      int maxPrefix ( char s [ ] , char t [ ] ) {		    int maxPrefix ( string s , string t ) {			  error : /bin/bash: line 1: 1846473 Aborted
    count = 0						      	int count = 0 ;						      int count = 0 ;						  	   (core dumped) ./MAXIMUM_LENGTH_PREFIX_ONE
    for i in range ( 0 , len ( t ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  _STRING_OCCURS_SUBSEQUENCE_ANOTHER_cpp
	if ( count == len ( s ) ) :			      	i < strlen ( t ) ;					      ;								  
	    break					      	i ++ ) {						      i ++ ) {							  
	if ( t [ i ] == s [ count ] ) :			      	  if ( count == strlen ( s ) ) break ;			    	if ( ( count == s . length ( ) ) && ( t . length ( ) == s 
	    count = count + 1				      	  if ( t [ i ] == s [ count ] ) count ++ ;		    	if ( ( t [ i ] == s [ count ] ) && ( t [ i ] == s [ count 
    return count					      	}							      }								  
							      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN
--							      --							    --								  --
def findMaximum ( arr , low , high ) :			      int findMaximum ( int arr [ ] , int low , int high ) {	    int findMaximum ( int * arr , int low , int high ) {	  failure : #Results: 8, 10
    max = arr [ low ]					      	int max = arr [ low ] ;					      int max = arr [ low ] ;					  
    i = low						      	int i ;							      int i ;							  
    for i in range ( high + 1 ) :			      	for ( i = low + 1 ;					      for ( i = low ;						  
	if arr [ i ] > max :				      	i <= high ;						      i < high + 1 ;						  
	    max = arr [ i ]				      	i ++ ) {						      i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ;		  
    return max						      	  if ( arr [ i ] > max ) max = arr [ i ] ;		      return max ;						  
							      	  else break ;						    }								  
							      	}							    								  
							      	return max ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING	      CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING		    CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING		  CALCULATE_SUM_OF_ALL_NUMBERS_PRESENT_IN_A_STRING
--							      --							    --								  --
def findSum ( str1 ) :					      int findSum ( string str ) {				    int findSum ( string str1 ) {				  success : None
    temp = ""						      	string temp = "" ;					      string temp ;						  
    Sum = 0						      	int sum = 0 ;						      int Sum = 0 ;						  
    for ch in str1 :					      	for ( char ch : str ) {					      for ( int i = 0 ;						  
	if ( ch.isdigit ( ) ) :				      	  if ( isdigit ( ch ) ) temp += ch ;			      i < str1 . length ( ) ;					  
	    temp += ch					      	  else {						      i ++ ) {							  
	else :						      	    sum += atoi ( temp . c_str ( ) ) ;			    	char ch = str1 [ i ] ;					  
	    Sum += int ( temp )				      	    temp = "" ;						    	if ( isdigit ( ch ) ) temp += ch ;			  
	    temp = "0"					      	  }							    	else {							  
    return Sum + int ( temp )				      	}							    	  Sum += atoi ( temp . c_str ( ) ) ;			  
							      	return sum + atoi ( temp . c_str ( ) ) ;		    	  temp = "0" ;						  
							      }								    	}							  
							      								      }								  
							      								      return Sum + atoi ( temp . c_str ( ) ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MIRROR_IMAGE_POINT_2_D_PLANE			      FIND_MIRROR_IMAGE_POINT_2_D_PLANE				    FIND_MIRROR_IMAGE_POINT_2_D_PLANE				  FIND_MIRROR_IMAGE_POINT_2_D_PLANE
--							      --							    --								  --
def mirrorImage ( a , b , c , x1 , y1 ) :		      pair < double , double > mirrorImage ( double a , double b ,  inline float mirrorImage ( float a , float b , float c , floa script_not_found : None
    temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b )  	double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b *   float temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b *  
    x = temp * a + x1					      	double x = temp * a + x1 ;				      float x = temp * a + x1 ;					  
    y = temp * b + y1					      	double y = temp * b + y1 ;				      float y = temp * b + y1 ;					  
    return ( x , y )					      	return make_pair ( x , y ) ;				      return ( x ) ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO		      MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO		    MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO			  MULTIPLY_LARGE_INTEGERS_UNDER_LARGE_MODULO
--							      --							    --								  --
def moduloMultiplication ( a , b , mod ) :		      long long moduloMultiplication ( long long a , long long b ,  int moduloMultiplication ( int a , int b , int mod ) {	  success : None
    res = 0 ;						      	long long res = 0 ;					      int res = 0 ;						  
    a = a % mod ;					      	a %= mod ;						      ;								  
    while ( b ) :					      	while ( b ) {						      a = a % mod ;						  
	if ( b & 1 ) :					      	  if ( b & 1 ) res = ( res + a ) % mod ;		      while ( ( b ) ) {						  
	    res = ( res + a ) % mod ;			      	  a = ( 2 * a ) % mod ;					    	if ( ( b & 1 ) != 0 ) res = ( res + a ) % mod ;		  
	a = ( 2 * a ) % mod ;				      	  b >>= 1 ;						    	a = ( 2 * a ) % mod ;					  
	b >>= 1 ;					      	}							    	b >>= 1 ;						  
    return res ;					      	return res ;						      }								  
							      }								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1		      MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1		    MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1			  MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1
--							      --							    --								  --
def subset ( arr , n ) :				      int subset ( int arr [ ] , int n ) {			    int subset ( int * arr , int n ) {				  error : MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1
    mp = { i : 0 for i in range ( 10 ) }		      	unordered_map < int , int > mp ;			      map < int , int > mp ;					  .cpp: In function ‘int f_filled(int*, int)’: MINIM
    for i in range ( n ) :				      	for ( int i = 0 ;					      mp [ i ] = 0 ;						  UM_NUMBER_SUBSETS_DISTINCT_ELEMENTS_1.cpp:29:8: er
	mp [ arr [ i ] ] += 1				      	i < n ;							      for ( int i = 0 ;						  ror: ‘i’ was not declared in this scope    mp [ i
    res = 0						      	i ++ ) mp [ arr [ i ] ] ++ ;				      i < 10 ;							  ] = 0 ;	  ^
    for key , value in mp.items ( ) :			      	int res = 0 ;						      i ++ ) mp [ arr [ i ] ] ++ ;				  
	res = max ( res , value )			      	for ( auto x : mp ) res = max ( res , x . second ) ;	      int res = 0 ;						  
    return res						      	return res ;						      for ( map < int , int > :: iterator it = mp . begin ( ) ;	  
							      }								      it != mp . end ( ) ;					  
							      								      it ++ ) res = max ( res , it -> second ) ;		  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_DIFFERENCE_PAIR_1				      FIND_MINIMUM_DIFFERENCE_PAIR_1				    FIND_MINIMUM_DIFFERENCE_PAIR_1				  FIND_MINIMUM_DIFFERENCE_PAIR_1
--							      --							    --								  --
def findMinDiff ( arr , n ) :				      int findMinDiff ( int arr [ ] , int n ) {			    int findMinDiff ( int * arr , int n ) {			  failure : #Results: 9, 10
    arr = sorted ( arr )				      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    diff = 10 ** 20					      	int diff = INT_MAX ;					      int diff = 10 * 20 ;					  
    for i in range ( n - 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if arr [ i + 1 ] - arr [ i ] < diff :		      	i < n - 1 ;						      i < n - 1 ;						  
	    diff = arr [ i + 1 ] - arr [ i ]		      	i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [   i ++ ) {							  
    return diff						      	return diff ;						    	if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i +  
							      }								      }								  
							      								      return diff ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		      FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		    FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS		  FIND_NUMBER_PERFECT_SQUARES_TWO_GIVEN_NUMBERS
--							      --							    --								  --
def CountSquares ( a , b ) :				      int countSquares ( int a , int b ) {			    int CountSquares ( int a , int b ) {			  success : None
    cnt = 0						      	int cnt = 0 ;						      int cnt = 0 ;						  
    for i in range ( a , b + 1 ) :			      	for ( int i = a ;					      for ( int i = a ;						  
	j = 1 ;						      	i <= b ;						      i <= b ;							  
	while j * j <= i :				      	i ++ ) for ( int j = 1 ;				      i ++ ) {							  
	    if j * j == i :				      	j * j <= i ;						    	int j = 1 ;						  
		cnt = cnt + 1				      	j ++ ) if ( j * j == i ) cnt ++ ;			    	while ( j * j <= i ) {					  
	    j = j + 1					      	return cnt ;						    	  if ( j * j == i ) cnt = cnt + 1 ;			  
	i = i + 1					      }								    	  j = j + 1 ;						  
    return cnt						      								    	}							  
							      								    	j = i + 1 ;						  
							      								      }								  
							      								      return cnt ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BREAK_NUMBER_THREE_PARTS				      BREAK_NUMBER_THREE_PARTS					    BREAK_NUMBER_THREE_PARTS					  BREAK_NUMBER_THREE_PARTS
--							      --							    --								  --
def count_of_ways ( n ) :				      ll count_of_ways ( ll n ) {				    int countOfWays ( int n ) {					  script_not_found : None
    count = 0						      	ll count = 0 ;						      int count = 0 ;						  
    for i in range ( 0 , n + 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( 0 , n + 1 ) :			      	i <= n ;						      i <= n ;							  
	    for k in range ( 0 , n + 1 ) :		      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		if ( i + j + k == n ) :			      	j <= n ;						    	for ( int j = 0 ;					  
		    count = count + 1			      	j ++ ) for ( int k = 0 ;				    	j <= n ;						  
    return count					      	k <= n ;						    	j ++ ) {						  
							      	k ++ ) if ( i + j + k == n ) count ++ ;			    	  for ( int k = 0 ;					  
							      	return count ;						    	  k <= n ;						  
							      }								    	  k ++ ) {						  
							      								    	    if ( ( i + j + k ) == n ) count = count + 1 ;	  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FRIENDS_PAIRING_PROBLEM_2				      FRIENDS_PAIRING_PROBLEM_2					    FRIENDS_PAIRING_PROBLEM_2					  FRIENDS_PAIRING_PROBLEM_2
--							      --							    --								  --
def countFriendsPairings ( n ) :			      int countFriendsPairings ( int n ) {			    int countFriendsPairings ( int n ) {			  success : None
    a , b , c = 1 , 2 , 0				      	int a = 1 , b = 2 , c = 0 ;				      int a = 1 , b = 2 , c = 0 ;				  
    if ( n <= 2 ) :					      	if ( n <= 2 ) {						      if ( ( n <= 2 ) ) return n ;				  
	return n					      	  return n ;						      for ( int i = 3 ;						  
    for i in range ( 3 , n + 1 ) :			      	}							      i <= n ;							  
	c = b + ( i - 1 ) * a				      	for ( int i = 3 ;					      i ++ ) {							  
	a = b						      	i <= n ;						    	c = b + ( i - 1 ) * a ;					  
	b = c						      	i ++ ) {						    	a = b ;							  
    return c						      	  c = b + ( i - 1 ) * a ;				    	b = c ;							  
							      	  a = b ;						      }								  
							      	  b = c ;						      return c ;						  
							      	}							    }								  
							      	return c ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1	      EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1		    EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1		  EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION_1
--							      --							    --								  --
def exponentiation ( bas , exp ) :			      long exponentiation ( long base , long exp ) {		    int exponentiation ( int bas , int exp ) {			  script_not_found : None
    t = 1						      	long t = 1L ;						      int t = 1 ;						  
    while ( exp > 0 ) :					      	while ( exp > 0 ) {					      while ( ( exp > 0 ) ) {					  
	if ( exp % 2 != 0 ) :				      	  if ( exp % 2 != 0 ) t = ( t * base ) % N ;		    	if ( ( exp % 2 ) != 0 ) t = ( t * bas ) % N ;		  
	    t = ( t * bas ) % N				      	  base = ( base * base ) % N ;				    	bas = ( bas * bas ) % N ;				  
	bas = ( bas * bas ) % N				      	  exp /= 2 ;						    	exp = ( int ) ( exp / 2 ) ;				  
	exp = int ( exp / 2 )				      	}							      }								  
    return t % N					      	return t % N ;						      return t % N ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y
--							      --							    --								  --
def countSolutions ( n ) :				      int countSolutions ( int n ) {				    int countSolutions ( int n ) {				  success : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    x = 0						      	for ( int x = 0 ;					      int x = 0 ;						  
    while ( x * x < n ) :				      	x * x < n ;						      while ( ( x * x ) < n ) {					  
	y = 0						      	x ++ ) for ( int y = 0 ;				    	int y = 0 ;						  
	while ( x * x + y * y < n ) :			      	x * x + y * y < n ;					    	while ( ( x * x + y * y ) < n ) {			  
	    res = res + 1				      	y ++ ) res ++ ;						    	  res = res + 1 ;					  
	    y = y + 1					      	return res ;						    	  y = y + 1 ;						  
	x = x + 1					      }								    	}							  
    return res						      								    	x = x + 1 ;						  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			      DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			    DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM			  DIVIDE_CUBOID_CUBES_SUM_VOLUMES_MAXIMUM
--							      --							    --								  --
def maximizecube ( l , b , h ) :			      void maximizecube ( int l , int b , int h ) {		    int maximizecube ( double l , double b , double h ) {	  script_not_found : None
    side = gcd ( l , gcd ( b , h ) )			      	int side = __gcd ( l , __gcd ( b , h ) ) ;		      double side = gcd ( l , gcd ( b , h ) ) ;			  
    num = int ( l / side )				      	int num = l / side ;					      int num = ( int ) ( l / side ) ;				  
    num = int ( num * b / side )			      	num = ( num * b / side ) ;				      num = ( int ) ( num * b / side ) ;			  
    num = int ( num * h / side )			      	num = ( num * h / side ) ;				      num = ( int ) ( num * h / side ) ;			  
    print ( side , num )				      	cout << side << " " << num << endl ;			      cout << side << " " << num << endl ;			  
							      }								      return num ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_XOR_VALUE_PAIR					      MINIMUM_XOR_VALUE_PAIR					    MINIMUM_XOR_VALUE_PAIR					  MINIMUM_XOR_VALUE_PAIR
--							      --							    --								  --
def minXOR ( arr , n ) :				      int minXOR ( int arr [ ] , int n ) {			    int minXOR ( int * arr , int n ) {				  success : None
    arr.sort ( )					      	int min_xor = INT_MAX ;					      sort ( arr , arr + n ) ;					  
    min_xor = 999999					      	for ( int i = 0 ;					      int minXor = 999999 ;					  
    val = 0						      	i < n ;							      int val ;							  
    for i in range ( 0 , n - 1 ) :			      	i ++ ) for ( int j = i + 1 ;				      for ( int i = 0 ;						  
	for j in range ( i + 1 , n - 1 ) :		      	j < n ;							      i <= n - 1 ;						  
	    val = arr [ i ] ^ arr [ j ]			      	j ++ ) min_xor = min ( min_xor , arr [ i ] ^ arr [ j ] ) ;    i ++ ) {							  
	    min_xor = min ( min_xor , val )		      	return min_xor ;					    	for ( int j = i + 1 ;					  
    return min_xor					      }								    	j <= n - 1 ;						  
							      								    	j ++ ) {						  
							      								    	  val = arr [ i ] ^ arr [ j ] ;				  
							      								    	  minXor = min ( minXor , val ) ;			  
							      								    	}							  
							      								      }								  
							      								      return minXor ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		      FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		    FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1		  FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY_1
--							      --							    --								  --
def maxProduct ( arr , n ) :				      int maxProduct ( int arr [ ] , int n ) {			    int maxProduct ( int * arr , int n ) {			  success : None
    if n < 3 :						      	if ( n < 3 ) return - 1 ;				      if ( n < 3 ) return - 1 ;					  
	return - 1					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    arr.sort ( )					      	return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [    return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [  
    return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr  }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_BY_7					      DIVISIBILITY_BY_7						    DIVISIBILITY_BY_7						  DIVISIBILITY_BY_7
--							      --							    --								  --
def isDivisibleBy7 ( num ) :				      int isDivisibleBy7 ( int num ) {				    bool isDivisibleBy7 ( int num ) {				  success : None
    if num < 0 :					      	if ( num < 0 ) return isDivisibleBy7 ( - num ) ;	      if ( num < 0 ) return isDivisibleBy7 ( - num ) ;		  
	return isDivisibleBy7 ( - num )			      	if ( num == 0 || num == 7 ) return 1 ;			      if ( ( num == 0 ) || ( num == 7 ) ) return true ;		  
    if ( num == 0 or num == 7 ) :			      	if ( num < 10 ) return 0 ;				      if ( ( num < 10 ) ) return false ;			  
	return True					      	return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 1   return isDivisibleBy7 ( num / 10 - 2 * ( num - num / 10 * 1 
    if ( num < 10 ) :					      }								    }								  
	return False					      								    								  
    return isDivisibleBy7 ( num // 10 - 2 * ( num - num // 10 								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERIAN_NUMBER						      EULERIAN_NUMBER						    EULERIAN_NUMBER						  EULERIAN_NUMBER
--							      --							    --								  --
def eulerian ( n , m ) :				      int eulerian ( int n , int m ) {				    double eulerian ( int n , int m ) {				  script_not_found : None
    if ( m >= n or n == 0 ) :				      	if ( m >= n || n == 0 ) return 0 ;			      if ( ( m >= n || n == 0 ) ) return 0 ;			  
	return 0					      	if ( m == 0 ) return 1 ;				      if ( ( m == 0 ) ) return 1 ;				  
    if ( m == 0 ) :					      	return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) *   return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) 
	return 1					      }								    }								  
    return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	      RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	    RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY	  RECURSIVE_C_PROGRAM_LINEARLY_SEARCH_ELEMENT_GIVEN_ARRAY
--							      --							    --								  --
def recSearch ( arr , l , r , x ) :			      int recSearch ( int arr [ ] , int l , int r , int x ) {	    int recSearch ( int * arr , int l , int r , int x ) {	  success : None
    if r < l :						      	if ( r < l ) return - 1 ;				      if ( r < l ) return - 1 ;					  
	return - 1					      	if ( arr [ l ] == x ) return l ;			      if ( arr [ l ] == x ) return l ;				  
    if arr [ l ] == x :					      	if ( arr [ r ] == x ) return r ;			      if ( arr [ r ] == x ) return r ;				  
	return l					      	return recSearch ( arr , l + 1 , r - 1 , x ) ;		      return recSearch ( arr , l + 1 , r - 1 , x ) ;		  
    if arr [ r ] == x :					      }								    }								  
	return r					      								    								  
    return recSearch ( arr , l + 1 , r - 1 , x )	      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS COUNT_MINIMUM_NUMBER_SUBSETS_SUBSEQUENCES_CONSECUTIVE_NUMBERS
--							      --							    --								  --
def numofsubset ( arr , n ) :				      int numofsubset ( int arr [ ] , int n ) {			    int numofsubset ( int * arr , int n ) {			  failure : #Results: 0, 10
    x = sorted ( arr )					      	sort ( arr , arr + n ) ;				      int * x = arr ;						  
    count = 1						      	int count = 1 ;						      int count = 1 ;						  
    for i in range ( 0 , n - 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( x [ i ] + 1 != x [ i + 1 ] ) :		      	i < n - 1 ;						      i <= n - 1 ;						  
	    count = count + 1				      	i ++ ) {						      i ++ ) {							  
    return count					      	  if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ;	    	if ( ( x [ i ] + 1 != x [ i + 1 ] ) && ( x [ i ] + 1 != x 
							      	}							      }								  
							      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_BINARY_DECIMAL_CONVERSION_1			      PROGRAM_BINARY_DECIMAL_CONVERSION_1			    PROGRAM_BINARY_DECIMAL_CONVERSION_1				  PROGRAM_BINARY_DECIMAL_CONVERSION_1
--							      --							    --								  --
def binaryToDecimal ( n ) :				      int binaryToDecimal ( string n ) {			    int binaryToDecimal ( string n ) {				  success : None
    num = n						      	string num = n ;					      string num = n ;						  
    dec_value = 0					      	int dec_value = 0 ;					      int decValue = 0 ;					  
    base1 = 1						      	int base = 1 ;						      int base1 = 1 ;						  
    len1 = len ( num )					      	int len = num . length ( ) ;				      int len1 = num . length ( ) ;				  
    for i in range ( len1 - 1 , - 1 , - 1 ) :		      	for ( int i = len - 1 ;					      for ( int i = len1 - 1 ;					  
	if ( num [ i ] == '1' ) :			      	i >= 0 ;						      i >= 0 ;							  
	    dec_value += base1				      	i -- ) {						      i -- ) {							  
	base1 = base1 * 2				      	  if ( num [ i ] == '1' ) dec_value += base ;		    	if ( ( num [ i ] == '1' ) ) decValue += base1 ;		  
    return dec_value					      	  base = base * 2 ;					    	base1 = base1 * 2 ;					  
							      	}							      }								  
							      	return dec_value ;					      return decValue ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	      COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	    COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS	  COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS
--							      --							    --								  --
def countSubstringWithEqualEnds ( s ) :			      int countSubstringWithEqualEnds ( string s ) {		    int countSubstringWithEqualEnds ( string s ) {		  success : None
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    n = len ( s )					      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i , n ) :			      	i < n ;							      i < n ;							  
	    if ( s [ i ] == s [ j ] ) :			      	i ++ ) for ( int j = i ;				      i ++ ) {							  
		result = result + 1			      	j < n ;							    	for ( int j = i ;					  
    return result					      	j ++ ) if ( s [ i ] == s [ j ] ) result ++ ;		    	j < n ;							  
							      	return result ;						    	j ++ ) {						  
							      }								    	  if ( ( s [ i ] == s [ j ] ) ) result = result + 1 ;	  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BINARY_SEARCH_1						      BINARY_SEARCH_1						    BINARY_SEARCH_1						  BINARY_SEARCH_1
--							      --							    --								  --
def binarySearch ( arr , l , r , x ) :			      int binarySearch ( int arr [ ] , int l , int r , int x ) {    int binarySearch ( int * arr , int l , int r , int x ) {	  script_not_found : None
    while l <= r :					      	while ( l <= r ) {					      while ( l <= r ) {					  
	mid = l + ( r - l ) // 2			      	  int m = l + ( r - l ) / 2 ;				    	int mid = l + ( r - l ) / 2 ;				  
	if arr [ mid ] == x :				      	  if ( arr [ m ] == x ) return m ;			    	if ( arr [ mid ] == x ) return mid ;			  
	    return mid					      	  if ( arr [ m ] < x ) l = m + 1 ;			    	else if ( arr [ mid ] < x ) l = mid + 1 ;		  
	elif arr [ mid ] < x :				      	  else r = m - 1 ;					    	else r = mid - 1 ;					  
	    l = mid + 1					      	}							      }								  
	else :						      	return - 1 ;						      return - 1 ;						  
	    r = mid - 1					      }								    }								  
    return - 1						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_BINARY_CONVERSION			      PROGRAM_DECIMAL_BINARY_CONVERSION				    PROGRAM_DECIMAL_BINARY_CONVERSION				  PROGRAM_DECIMAL_BINARY_CONVERSION
--							      --							    --								  --
def decToBinary ( n ) :					      void decToBinary ( int n ) {				    int decToBinary ( int n ) {					  script_not_found : None
    binaryNum = [ 0 ] * n				      	int binaryNum [ 32 ] ;					      vector < int > binaryNum ( n , 0 ) ;			  
    i = 0						      	int i = 0 ;						      int i = 0 ;						  
    while ( n > 0 ) :					      	while ( n > 0 ) {					      while ( ( n > 0 ) && ( n % 2 == 0 ) ) {			  
	binaryNum [ i ] = n % 2				      	  binaryNum [ i ] = n % 2 ;				    	binaryNum [ i ] = n % 2 ;				  
	n = int ( n / 2 )				      	  n = n / 2 ;						    	n = ( int ) ( n / 2 ) ;					  
	i += 1						      	  i ++ ;						    	i ++ ;							  
    for j in range ( i - 1 , - 1 , - 1 ) :		      	}							      }								  
	print ( binaryNum [ j ] , end = "" )		      	for ( int j = i - 1 ;					      for ( int j = i - 1 ;					  
							      	j >= 0 ;						      j >= 0 ;							  
							      	j -- ) cout << binaryNum [ j ] ;			      j -- ) cout << binaryNum [ j ] << " " ;			  
							      }								      return n ;						  
-							      -								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		      HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		    HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION		  HOW_TO_AVOID_OVERFLOW_IN_MODULAR_MULTIPLICATION
--							      --							    --								  --
def mulmod ( a , b , mod ) :				      ll mulmod ( ll a , ll b , ll mod ) {			    int mulmod ( int a , int b , int mod ) {			  script_not_found : None
    res = 0						      	ll res = 0 ;						      int res = 0 ;						  
    a = a % mod						      	a = a % mod ;						      a = a % mod ;						  
    while ( b > 0 ) :					      	while ( b > 0 ) {					      while ( ( b > 0 ) ) {					  
	if ( b % 2 == 1 ) :				      	  if ( b % 2 == 1 ) res = ( res + a ) % mod ;		    	if ( ( b % 2 == 1 ) ) res = ( res + a ) % mod ;		  
	    res = ( res + a ) % mod			      	  a = ( a * 2 ) % mod ;					    	a = ( a * 2 ) % mod ;					  
	a = ( a * 2 ) % mod				      	  b /= 2 ;						    	b /= 2 ;						  
	b //= 2						      	}							      }								  
    return res % mod					      	return res % mod ;					      return res % mod ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NON_REPEATING_ELEMENT_1					      NON_REPEATING_ELEMENT_1					    NON_REPEATING_ELEMENT_1					  NON_REPEATING_ELEMENT_1
--							      --							    --								  --
def firstNonRepeating ( arr , n ) :			      int firstNonRepeating ( int arr [ ] , int n ) {		    int firstNonRepeating ( int * arr , int n ) {		  success : None
    mp = defaultdict ( lambda : 0 )			      	unordered_map < int , int > mp ;			      map < int , int > mp ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	mp [ arr [ i ] ] += 1				      	i < n ;							      i < n ;							  
    for i in range ( n ) :				      	i ++ ) mp [ arr [ i ] ] ++ ;				      i ++ ) mp [ arr [ i ] ] ++ ;				  
	if mp [ arr [ i ] ] == 1 :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    return arr [ i ]				      	i < n ;							      i < n ;							  
    return - 1						      	i ++ ) if ( mp [ arr [ i ] ] == 1 ) return arr [ i ] ;	      i ++ ) if ( mp [ arr [ i ] ] == 1 ) return arr [ i ] ;	  
							      	return - 1 ;						      return - 1 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS		      MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS			    MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS			  MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS
--							      --							    --								  --
def middleOfThree ( a , b , c ) :			      int middleOfThree ( int a , int b , int c ) {		    int middleOfThree ( int a , int b , int c ) {		  success : None
    if ( ( a < b and b < c ) or ( c < b and b < a ) ) :	      	if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ;    if ( ( ( a < b && b < c ) || ( c < b && b < a ) ) ) return  
	return b					      	else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return   if ( ( ( b < a && a < c ) || ( c < a && a < b ) ) ) return  
    if ( ( b < a and a < c ) or ( c < a and a < b ) ) :	      	else return c ;						      else return c ;						  
	return a					      }								    }								  
    else :						      								    								  
	return c					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_ MULTIPLY_TWO_NUMBERS_WITHOUT_USING_MULTIPLY_DIVISION_BITWISE_
--							      --							    --								  --
def multiply ( x , y ) :				      public : int multiply ( int x , int y ) {			    int multiply ( int x , int y ) {				  script_not_found : None
    if ( y == 0 ) :					      	if ( y == 0 ) return 0 ;				      if ( ( y == 0 ) ) return 0 ;				  
	return 0					      	if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ;	      if ( ( y > 0 ) ) return ( x + multiply ( x , y - 1 ) ) ;	  
    if ( y > 0 ) :					      	if ( y < 0 ) return - multiply ( x , - y ) ;		      if ( ( y < 0 ) ) return - multiply ( x , - y ) ;		  
	return ( x + multiply ( x , y - 1 ) )		      }								      return x * x * x * x * x * x * x * x * x * x * x * x * x *  
    if ( y < 0 ) :					      								    }								  
	return - multiply ( x , - y )			      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LOWER_CASE_UPPER_CASE_INTERESTING_FACT			      LOWER_CASE_UPPER_CASE_INTERESTING_FACT			    LOWER_CASE_UPPER_CASE_INTERESTING_FACT			  LOWER_CASE_UPPER_CASE_INTERESTING_FACT
--							      --							    --								  --
def to_upper ( string ) :				      string to_upper ( string & in ) {				    string toUpperCase ( string string ) {			  script_not_found : None
    for i in range ( len ( string ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( 'a' <= string [ i ] <= 'z' ) :		      	i < in . length ( ) ;					      i < string . length ( ) ;					  
	    string = ( string [ 0 : i ] + chr ( ord ( string  	i ++ ) if ( 'a' <= in [ i ] <= 'z' ) in [ i ] = in [ i ] -    i ++ ) {							  
    return string					      	return in ;						    	if ( ( 'a' <= string [ i ] && string [ i ] <= 'z' ) ) str 
							      }								      }								  
							      								      return string ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS	      MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS		    MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS		  MINIMUM_SUM_ABSOLUTE_DIFFERENCE_PAIRS_TWO_ARRAYS
--							      --							    --								  --
def findMinSum ( a , b , n ) :				      long long int findMinSum ( int a [ ] , int b [ ] , int n ) {  int findMinSum ( int * a , int * b , int n ) {		  script_not_found : None
    a.sort ( )						      	sort ( a , a + n ) ;					      sort ( a ) ;						  
    b.sort ( )						      	sort ( b , b + n ) ;					      sort ( b ) ;						  
    sum = 0						      	long long int sum = 0 ;					      int sum = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	sum = sum + abs ( a [ i ] - b [ i ] )		      	i < n ;							      i < n ;							  
    return sum						      	i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ) ;		      i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ) ;		  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	      DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	    DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1	  DISTRIBUTING_ITEMS_PERSON_CANNOT_TAKE_TWO_ITEMS_TYPE_1
--							      --							    --								  --
def checkCount ( arr , n , k ) :			      bool checkCount ( int arr [ ] , int n , int k ) {		    bool checkCount ( int * arr , int n , int k ) {		  success : None
    mp = defaultdict ( lambda : 0 )			      	unordered_map < int , int > hash ;			      map < int , int > mp ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	mp [ arr [ i ] ] += 1				      	i < n ;							      i < n ;							  
    for key , values in mp.items ( ) :			      	i ++ ) hash [ arr [ i ] ] ++ ;				      i ++ ) mp [ arr [ i ] ] += 1 ;				  
	if values > 2 * k :				      	for ( auto x : hash ) if ( x . second > 2 * k ) return fals   for ( map < int , int > :: iterator it = mp . begin ( ) ;	  
	    return False				      	return true ;						      it != mp . end ( ) ;					  
    return True						      }								      it ++ ) if ( it -> second > 2 * k ) return false ;	  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NTH_NON_FIBONACCI_NUMBER				      NTH_NON_FIBONACCI_NUMBER					    NTH_NON_FIBONACCI_NUMBER					  NTH_NON_FIBONACCI_NUMBER
--							      --							    --								  --
def nonFibonacci ( n ) :				      int nonFibonacci ( int n ) {				    int nonFibonacci ( int n ) {				  success : None
    prevPrev = 1					      	int prevPrev = 1 , prev = 2 , curr = 3 ;		      int prevPrev = 1 ;					  
    prev = 2						      	while ( n > 0 ) {					      int prev = 2 ;						  
    curr = 3						      	  prevPrev = prev ;					      int curr = 3 ;						  
    while n > 0 :					      	  prev = curr ;						      while ( n > 0 ) {						  
	prevPrev = prev					      	  curr = prevPrev + prev ;				    	prevPrev = prev ;					  
	prev = curr					      	  n = n - ( curr - prev - 1 ) ;				    	prev = curr ;						  
	curr = prevPrev + prev				      	}							    	curr = prevPrev + prev ;				  
	n = n - ( curr - prev - 1 )			      	n = n + ( curr - prev - 1 ) ;				    	n = n - ( curr - prev - 1 ) ;				  
    n = n + ( curr - prev - 1 )				      	return prev + n ;					      }								  
    return prev + n					      }								      n = n + ( curr - prev - 1 ) ;				  
							      								      return prev + n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_XOR_VALUE_PAIR_1				      MINIMUM_XOR_VALUE_PAIR_1					    MINIMUM_XOR_VALUE_PAIR_1					  MINIMUM_XOR_VALUE_PAIR_1
--							      --							    --								  --
def minXOR ( arr , n ) :				      int minXOR ( int arr [ ] , int n ) {			    int minXOR ( int * arr , int n ) {				  failure : #Results: 9, 10
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    minXor = int ( sys.float_info.max )			      	int minXor = INT_MAX ;					      int minXor = ( int ) INT_MAX ;				  
    val = 0						      	int val = 0 ;						      int val ;							  
    for i in range ( 0 , n - 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	val = arr [ i ] ^ arr [ i + 1 ]			      	i < n - 1 ;						      i <= n - 1 ;						  
	minXor = min ( minXor , val )			      	i ++ ) {						      i ++ ) {							  
    return minXor					      	  val = arr [ i ] ^ arr [ i + 1 ] ;			    	val = arr [ i ] ^ arr [ i + 1 ] ;			  
							      	  minXor = min ( minXor , val ) ;			    	minXor = min ( minXor , val ) ;				  
							      	}							      }								  
							      	return minXor ;						      return minXor ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	      FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	    FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1	  FIND_WHETHER_A_GIVEN_NUMBER_IS_A_POWER_OF_4_OR_NOT_1
--							      --							    --								  --
def isPowerOfFour ( n ) :				      bool isPowerOfFour ( unsigned int n ) {			    bool isPowerOfFour ( unsigned long n ) {			  success : None
    count = 0						      	int count = 0 ;						      unsigned long count = 0 ;					  
    if ( n and ( not ( n & ( n - 1 ) ) ) ) :		      	if ( n && ! ( n & ( n - 1 ) ) ) {			      if ( ( n > 0 ) && ( ! ( n & ( n - 1 ) ) ) ) {		  
	while ( n > 1 ) :				      	  while ( n > 1 ) {					    	while ( ( n > 1 ) ) {					  
	    n >>= 1					      	    n >>= 1 ;						    	  n >>= 1 ;						  
	    count += 1					      	    count += 1 ;					    	  count ++ ;						  
	if ( count % 2 == 0 ) :				      	  }							    	}							  
	    return True					      	  return ( count % 2 == 0 ) ? 1 : 0 ;			    	if ( ( count % 2 ) == 0 ) return true ;			  
	else :						      	}							    	else return false ;					  
	    return False				      	return 0 ;						      }								  
							      }								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NON_REPEATING_ELEMENT					      NON_REPEATING_ELEMENT					    NON_REPEATING_ELEMENT					  NON_REPEATING_ELEMENT
--							      --							    --								  --
def firstNonRepeating ( arr , n ) :			      int firstNonRepeating ( int arr [ ] , int n ) {		    int firstNonRepeating ( int * arr , int n ) {		  success : None
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	j = 0						      	i < n ;							      i < n ;							  
	while ( j < n ) :				      	i ++ ) {						      i ++ ) {							  
	    if ( i != j and arr [ i ] == arr [ j ] ) :	      	  int j ;						    	int j = 0 ;						  
		break					      	  for ( j = 0 ;						    	while ( ( j < n ) ) {					  
	    j += 1					      	  j < n ;						    	  if ( ( i != j ) && ( arr [ i ] == arr [ j ] ) ) break ; 
	if ( j == n ) :					      	  j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ;    	  j ++ ;						  
	    return arr [ i ]				      	  if ( j == n ) return arr [ i ] ;			    	}							  
    return - 1						      	}							    	if ( ( j == n ) ) return arr [ i ] ;			  
							      	return - 1 ;						      }								  
							      }								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC	      MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC	    MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC		  MODULAR_EXPONENTIATION_POWER_IN_MODULAR_ARITHMETIC
--							      --							    --								  --
def power ( x , y , p ) :				      int power ( int x , unsigned int y , int p ) {		    int power ( int x , int y , int p ) {			  success : None
    res = 1						      	int res = 1 ;						      int res = 1 ;						  
    x = x % p						      	x = x % p ;						      x = x % p ;						  
    while ( y > 0 ) :					      	while ( y > 0 ) {					      while ( ( y > 0 ) ) {					  
	if ( ( y & 1 ) == 1 ) :				      	  if ( y & 1 ) res = ( res * x ) % p ;			    	if ( ( ( y & 1 ) == 1 ) ) res = ( res * x ) % p ;	  
	    res = ( res * x ) % p			      	  y = y >> 1 ;						    	y = y >> 1 ;						  
	y = y >> 1					      	  x = ( x * x ) % p ;					    	x = ( x * x ) % p ;					  
	x = ( x * x ) % p				      	}							      }								  
    return res						      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K	      PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K		    PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K		  PERMUTE_TWO_ARRAYS_SUM_EVERY_PAIR_GREATER_EQUAL_K
--							      --							    --								  --
def isPossible ( a , b , n , k ) :			      bool isPossible ( int a [ ] , int b [ ] , int n , int k ) {   bool isPossible ( int * a , int * b , int n , int k ) {	  failure : #Results: 9, 10
    a.sort ( reverse = True )				      	sort ( a , a + n ) ;					      sort ( a , a + n ) ;					  
    b.sort ( )						      	sort ( b , b + n , greater < int > ( ) ) ;		      sort ( b , b + n ) ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( a [ i ] + b [ i ] < k ) :			      	i < n ;							      i < n ;							  
	    return False				      	i ++ ) if ( a [ i ] + b [ i ] < k ) return false ;	      i ++ ) if ( ( a [ i ] + b [ i ] < k ) ) return false ;	  
    return True						      	return true ;						      return true ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EQUILIBRIUM_INDEX_OF_AN_ARRAY_1				      EQUILIBRIUM_INDEX_OF_AN_ARRAY_1				    EQUILIBRIUM_INDEX_OF_AN_ARRAY_1				  EQUILIBRIUM_INDEX_OF_AN_ARRAY_1
--							      --							    --								  --
def equilibrium ( arr ) :				      int equilibrium ( int arr [ ] , int n ) {			    int equilibrium ( int * arr ) {				  error : EQUILIBRIUM_INDEX_OF_AN_ARRAY_1.cpp: In fu
    total_sum = sum ( arr )				      	int sum = 0 ;						      int totalSum = sum ( arr ) ;				  nction ‘int f_filled(int*)’: EQUILIBRIUM_INDEX_OF_
    leftsum = 0						      	int leftsum = 0 ;					      int leftsum = 0 ;						  AN_ARRAY_1.cpp:34:18: error: ‘sum’ was not declare
    for i , num in enumerate ( arr ) :			      	for ( int i = 0 ;					      for ( int i = 0 , num = arr [ 0 ] ;			  d in this scope    int totalSum = sum ( arr ) ;
	total_sum -= num				      	i < n ;							      i < num ;							  		  ^~~ EQUILIBRIUM_INDEX_OF_AN_ARRAY_
	if leftsum == total_sum :			      	++ i ) sum += arr [ i ] ;				      i ++ ) {							  1.cpp:34:18: note: suggested alternative: ‘fsub’
	    return i					      	for ( int i = 0 ;					    	totalSum -= arr [ i ] ;					    int totalSum = sum ( arr ) ;		   ^
	leftsum += num					      	i < n ;							    	if ( leftsum == totalSum ) return i ;			  ~~		       fsub EQUILIBRIUM_INDEX_OF_AN_
    return - 1						      	++ i ) {						    	leftsum += arr [ i ] ;					  ARRAY_1.cpp: In function ‘int main()’: EQUILIBRIUM
							      	  sum -= arr [ i ] ;					      }								  _INDEX_OF_AN_ARRAY_1.cpp:53:49: error: too many ar
							      	  if ( leftsum == sum ) return i ;			      return - 1 ;						  guments to function ‘int f_filled(int*)’
							      	  leftsum += arr [ i ] ;				    }								  if(f_filled(&param0[i].front(),param1[i]) == f_gol
							      	}							    								  d(&param0[i].front(),param1[i]))
							      	return - 1 ;						    								  				  ^ EQUILIBRIUM_INDE
							      }								    								  X_OF_AN_ARRAY_1.cpp:33:5: note: declared here	 int
							      								    								   f_filled ( int * arr ) {	 ^~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		      PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		    PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2		  PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_2
--							      --							    --								  --
def printDistinct ( arr , n ) :				      void printDistinct ( int arr [ ] , int n ) {		    void printDistinct ( int * arr , int n ) {			  script_not_found : None
    s = dict ( )					      	unordered_set < int > s ;				      map < int , int > s ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( arr [ i ] not in s.keys ( ) ) :		      	i < n ;							      i < n ;							  
	    s [ arr [ i ] ] = arr [ i ]			      	i ++ ) {						      i ++ ) {							  
	    print ( arr [ i ] , end = " " )		      	  if ( s . find ( arr [ i ] ) == s . end ( ) ) {	    	if ( ( arr [ i ] != 0 ) && ( arr [ i ] != 1 ) ) {	  
							      	    s . insert ( arr [ i ] ) ;				    	  s [ arr [ i ] ] = arr [ i ] ;				  
							      	    cout << arr [ i ] << " " ;				    	  cout << arr [ i ] << " " ;				  
							      	  }							    	}							  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND COUNT_EVEN_LENGTH_BINARY_SEQUENCES_WITH_SAME_SUM_OF_FIRST_AND
--							      --							    --								  --
def countSeq ( n ) :					      int countSeq ( int n ) {					    double countSeq ( int n ) {					  failure : #Results: 2, 10
    nCr = 1						      	int nCr = 1 , res = 1 ;					      double nCr = 1 ;						  
    res = 1						      	for ( int r = 1 ;					      double res = 1 ;						  
    for r in range ( 1 , n + 1 ) :			      	r <= n ;						      for ( int r = 1 ;						  
	nCr = ( nCr * ( n + 1 - r ) ) / r ;		      	r ++ ) {						      r <= n ;							  
	res += nCr * nCr ;				      	  nCr = ( nCr * ( n + 1 - r ) ) / r ;			      r ++ ) {							  
    return res ;					      	  res += nCr * nCr ;					    	nCr = ( nCr * ( n + 1 - r ) ) / r ;			  
							      	}							    	res += nCr * nCr ;					  
							      	return res ;						      }								  
							      }								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI
--							      --							    --								  --
def countNegative ( M , n , m ) :			      int countNegative ( int M [ ] [ 4 ] , int n , int m ) {	    int countNegative ( int * * M , int n , int m ) {		  script_not_found : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( m ) :				      	i < n ;							      i < n ;							  
	    if M [ i ] [ j ] < 0 :			      	i ++ ) {						      i ++ ) {							  
		count += 1				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    else :					      	  j < m ;						    	j < m ;							  
		break					      	  j ++ ) {						    	j ++ ) {						  
    return count					      	    if ( M [ i ] [ j ] < 0 ) count += 1 ;		    	  if ( M [ i ] [ j ] < 0 ) count ++ ;			  
							      	    else break ;					    	  else break ;						  
							      	  }							    	}							  
							      	}							      }								  
							      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		      PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		    PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES		  PRIMALITY_TEST_SET_5USING_LUCAS_LEHMER_SERIES
--							      --							    --								  --
def isPrime ( p ) :					      bool isPrime ( int p ) {					    bool isPrime ( int p ) {					  failure : #Results: 8, 10
    checkNumber = 2 ** p - 1				      	long long checkNumber = pow ( 2 , p ) - 1 ;		      int checkNumber = 2 * p - 1 ;				  
    nextval = 4 % checkNumber				      	long long nextval = 4 % checkNumber ;			      int nextval = 4 % checkNumber ;				  
    for i in range ( 1 , p - 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	nextval = ( nextval * nextval - 2 ) % checkNumber     	i < p - 1 ;						      i < p - 1 ;						  
    if ( nextval == 0 ) : return True			      	i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;    i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ;  
    else : return False					      	return ( nextval == 0 ) ;				      if ( ( nextval == 0 ) ) return true ;			  
							      }								      else return false ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_PERIMETER_N_BLOCKS				      MINIMUM_PERIMETER_N_BLOCKS				    MINIMUM_PERIMETER_N_BLOCKS					  MINIMUM_PERIMETER_N_BLOCKS
--							      --							    --								  --
def minPerimeter ( n ) :				      int minPerimeter ( int n ) {				    double minPerimeter ( double n ) {				  error : MINIMUM_PERIMETER_N_BLOCKS.cpp: In functio
    l = math.sqrt ( n )					      	int l = sqrt ( n ) ;					      double l = sqrt ( n ) ;					  n ‘double f_filled(double)’: MINIMUM_PERIMETER_N_B
    sq = l * l						      	int sq = l * l ;					      double sq = l * l ;					  LOCKS.cpp:36:14: error: invalid operands of types
    if ( sq == n ) :					      	if ( sq == n ) return l * 4 ;				      if ( ( sq == n ) ) return l * 4 ;				  ‘double’ and ‘double’ to binary ‘operator%’	   i
	return l * 4					      	else {							      else {							  f ( ( n % l ) != 0 ) perimeter += 2 ;
    else :						      	  long long int row = n / l ;				    	double row = n / l ;					  ~~^~~
	row = n / l					      	  long long int perimeter = 2 * ( l + row ) ;		    	double perimeter = 2 * ( l + row ) ;			  
	perimeter = 2 * ( l + row )			      	  if ( n % l != 0 ) perimeter += 2 ;			    	if ( ( n % l ) != 0 ) perimeter += 2 ;			  
	if ( n % l != 0 ) :				      	  return perimeter ;					    	return perimeter ;					  
	    perimeter += 2				      	}							      }								  
	return perimeter				      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEWMAN_CONWAY_SEQUENCE_1				      NEWMAN_CONWAY_SEQUENCE_1					    NEWMAN_CONWAY_SEQUENCE_1					  NEWMAN_CONWAY_SEQUENCE_1
--							      --							    --								  --
def sequence ( n ) :					      int sequence ( int n ) {					    int sequence ( int n ) {					  timeout : None
    f = array.array ( 'i' , [ 0 , 1 , 1 ] )		      	int f [ n + 1 ] ;					      int f [ ] = {						  
    for i in range ( 3 , n + 1 ) :			      	int i ;							    	0 , 1 , 1 }						  
	r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]	      	f [ 0 ] = 0 ;						    	;							  
	f.append ( r ) ;				      	f [ 1 ] = 1 ;						    	for ( int i = 3 ;					  
    return r						      	f [ 2 ] = 1 ;						    	i <= n ;						  
							      	for ( i = 3 ;						    	i ++ ) {						  
							      	i <= n ;						    	  int r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;	  
							      	i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]  	  f [ i ] = r ;						  
							      	return f [ n ] ;					    	}							  
							      }								    	;							  
							      								    	return n ;						  
							      								      }								  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		      NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		    NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N		  NUMBER_NON_NEGATIVE_INTEGRAL_SOLUTIONS_B_C_N
--							      --							    --								  --
def countIntegralSolutions ( n ) :			      int countIntegralSolutions ( int n ) {			    int countIntegralSolutions ( int n ) {			  success : None
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    for i in range ( n + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( n + 1 ) :			      	i <= n ;						      i < n + 1 ;						  
	    for k in range ( n + 1 ) :			      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		if i + j + k == n :			      	j <= n - i ;						    	for ( int j = 0 ;					  
		    result += 1				      	j ++ ) for ( int k = 0 ;				    	j < n + 1 ;						  
    return result					      	k <= ( n - i - j ) ;					    	j ++ ) {						  
							      	k ++ ) if ( i + j + k == n ) result ++ ;		    	  for ( int k = 0 ;					  
							      	return result ;						    	  k < n + 1 ;						  
							      }								    	  k ++ ) {						  
							      								    	    if ( i + j + k == n ) result ++ ;			  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_GAMES_PLAYED_WINNER				      MAXIMUM_GAMES_PLAYED_WINNER				    MAXIMUM_GAMES_PLAYED_WINNER					  MAXIMUM_GAMES_PLAYED_WINNER
--							      --							    --								  --
def maxGameByWinner ( N ) :				      int maxGameByWinner ( int N ) {				    int maxGameByWinner ( int N ) {				  success : None
    dp = [ 0 for i in range ( N ) ]			      	int dp [ N ] ;						      vector < int > dp ( N , 0 ) ;				  
    dp [ 0 ] = 1					      	dp [ 0 ] = 1 ;						      dp [ 0 ] = 1 ;						  
    dp [ 1 ] = 2					      	dp [ 1 ] = 2 ;						      dp [ 1 ] = 2 ;						  
    i = 1						      	int i = 2 ;						      int i = 1 ;						  
    while dp [ i ] <= N :				      	do {							      while ( dp [ i ] <= N ) {					  
	i = i + 1					      	  dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ;		    	i = i + 1 ;						  
	dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]		      	}							    	dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ;		  
    return ( i - 1 )					      	while ( dp [ i ++ ] <= N ) ;				      }								  
							      	return ( i - 2 ) ;					      return ( i - 1 ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_2
--							      --							    --								  --
def numberOfPaths ( p , q ) :				      int numberOfPaths ( int m , int n ) {			    int numberOfPaths ( int p , int q ) {			  success : None
    dp = [ 1 for i in range ( q ) ]			      	int dp [ n ] = {					      vector < int > dp ( q , 0 ) ;				  
    for i in range ( p - 1 ) :				      	  1 }							      for ( int i = 0 ;						  
	for j in range ( 1 , q ) :			      	  ;							      i < q ;							  
	    dp [ j ] += dp [ j - 1 ]			      	  dp [ 0 ] = 1 ;					      i ++ ) {							  
    return dp [ q - 1 ]					      	  for ( int i = 0 ;					    	dp [ i ] = 1 ;						  
							      	  i < m ;						      }								  
							      	  i ++ ) {						      for ( int i = 0 ;						  
							      	    for ( int j = 1 ;					      i < p - 1 ;						  
							      	    j < n ;						      i ++ ) {							  
							      	    j ++ ) {						    	for ( int j = 1 ;					  
							      	      dp [ j ] += dp [ j - 1 ] ;			    	j < q ;							  
							      	    }							    	j ++ ) {						  
							      	  }							    	  dp [ j ] += dp [ j - 1 ] ;				  
							      	  return dp [ n - 1 ] ;					    	}							  
							      	}							      }								  
							      								      return dp [ q - 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY		      MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY		    MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY			  MINIMUM_OPERATION_MAKE_ELEMENTS_EQUAL_ARRAY
--							      --							    --								  --
def minOperation ( arr , n ) :				      int minOperation ( int arr [ ] , int n ) {		    int minOperation ( int * arr , int n ) {			  timeout : None
    Hash = defaultdict ( lambda : 0 )			      	unordered_map < int , int > hash ;			      unordered_map < int , int > Hash ;			  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	Hash [ arr [ i ] ] += 1				      	i < n ;							      i != n ;							  
    max_count = 0					      	i ++ ) hash [ arr [ i ] ] ++ ;				      i ++ ) Hash [ arr [ i ] ] ++ ;				  
    for i in Hash :					      	int max_count = 0 ;					      int maxCount = 0 ;					  
	if max_count < Hash [ i ] :			      	for ( auto i : hash ) if ( max_count < i . second ) max_cou   for ( int i = 0 ;						  
	    max_count = Hash [ i ]			      	return ( n - max_count ) ;				      i < Hash . size ( ) ;					  
    return n - max_count				      }								      i ++ ) if ( maxCount < Hash [ i ] ) maxCount = Hash [ i ] ; 
							      								      return n - maxCount ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BUBBLE_SORT						      BUBBLE_SORT						    BUBBLE_SORT							  BUBBLE_SORT
--							      --							    --								  --
def bubbleSort ( arr ) :				      void bubbleSort ( int arr [ ] , int n ) {			    void bubbleSort ( int * arr ) {				  script_not_found : None
    n = len ( arr )					      	int i , j ;						      int n = sizeof ( arr ) / sizeof ( int ) ;			  
    for i in range ( n ) :				      	for ( i = 0 ;						      for ( int i = 0 ;						  
	for j in range ( 0 , n - i - 1 ) :		      	i < n - 1 ;						      i < n ;							  
	    if arr [ j ] > arr [ j + 1 ] :		      	i ++ ) for ( j = 0 ;					      i ++ ) {							  
		arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , a 	j < n - i - 1 ;						    	for ( int j = 0 ;					  
							      	j ++ ) if ( arr [ j ] > arr [ j + 1 ] ) swap ( & arr [ j ]  	j <= n - i - 1 ;					  
							      }								    	j ++ ) {						  
							      								    	  if ( arr [ j ] > arr [ j + 1 ] ) arr [ j ] = arr [ j +  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_WAYS_BREAK_STRING_BRACKET_FORM			      PRINT_WAYS_BREAK_STRING_BRACKET_FORM			    PRINT_WAYS_BREAK_STRING_BRACKET_FORM			  PRINT_WAYS_BREAK_STRING_BRACKET_FORM
--							      --							    --								  --
def findCombinations ( string , index , out ) :		      void findCombinations ( string str , int index , string out ) void findCombinations ( string string , int index , string ou script_not_found : None
    if index == len ( string ) :			      	if ( index == str . length ( ) ) cout << out << endl ;	      if ( index == string . length ( ) ) cout << out ;		  
	print ( out )					      	for ( int i = index ;					      for ( int i = index ;					  
    for i in range ( index , len ( string ) , 1 ) :	      	i < str . length ( ) ;					      i < string . length ( ) ;					  
	findCombinations ( string , i + 1 , out + "(" + strin 	i ++ ) findCombinations ( str , i + 1 , out + "(" + str . s   i += 1 ) findCombinations ( string , i + 1 , out + "(" + st 
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DIVISIBLE_PAIRS_ARRAY				      COUNT_DIVISIBLE_PAIRS_ARRAY				    COUNT_DIVISIBLE_PAIRS_ARRAY					  COUNT_DIVISIBLE_PAIRS_ARRAY
--							      --							    --								  --
def countDivisibles ( arr , n ) :			      int countDivisibles ( int arr [ ] , int n ) {		    int countDivisibles ( int * arr , int n ) {			  script_not_found : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i < n ;							  
	    if ( arr [ i ] % arr [ j ] == 0 or arr [ j ] % ar 	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
		res += 1				      	j < n ;							    	for ( int j = i + 1 ;					  
    return res						      	j ++ ) if ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [ 	j < n ;							  
							      	return res ;						    	j ++ ) {						  
							      }								    	  if ( ( arr [ i ] % arr [ j ] == 0 || arr [ j ] % arr [  
							      								    	}							  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM   DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM   DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM	  DYNAMIC_PROGRAMMING_HIGH_EFFORT_VS_LOW_EFFORT_TASKS_PROBLEM
--							      --							    --								  --
def maxTasks ( high , low , n ) :			      int maxTasks ( int high [ ] , int low [ ] , int n ) {	    int maxTasks ( int * high , int * low , int n ) {		  success : None
    if ( n <= 0 ) :					      	if ( n <= 0 ) return 0 ;				      if ( ( n <= 0 ) ) return 0 ;				  
	return 0					      	return max ( high [ n - 1 ] + maxTasks ( high , low , ( n -   return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 
    return max ( high [ n - 1 ] + maxTasks ( high , low , ( n }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY		      PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY		    PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY			  PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY
--							      --							    --								  --
def printDistinct ( arr , n ) :				      void printDistinct ( int arr [ ] , int n ) {		    int printDistinct ( int * arr , int n ) {			  script_not_found : None
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	d = 0						      	i < n ;							      i <= n ;							  
	for j in range ( 0 , i ) :			      	i ++ ) {						      i ++ ) {							  
	    if ( arr [ i ] == arr [ j ] ) :		      	  int j ;						    	int d = 0 ;						  
		d = 1					      	  for ( j = 0 ;						    	for ( int j = 0 ;					  
		break					      	  j < i ;						    	j <= i ;						  
	if ( d == 0 ) :					      	  j ++ ) if ( arr [ i ] == arr [ j ] ) break ;		    	j ++ ) {						  
	    print ( arr [ i ] )				      	  if ( i == j ) cout << arr [ i ] << " " ;		    	  if ( ( arr [ i ] == arr [ j ] ) ) {			  
							      	}							    	    d = 1 ;						  
							      }								    	    break ;						  
							      								    	  }							  
							      								    	}							  
							      								    	if ( ( d == 0 ) ) cout << arr [ i ] << endl ;		  
							      								      }								  
							      								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		      FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		    FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS		  FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS
--							      --							    --								  --
def findElements ( arr , n ) :				      void findElements ( int arr [ ] , int n ) {		    int findElements ( int * arr , int n ) {			  script_not_found : None
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	count = 0					      	i < n ;							      i < n ;							  
	for j in range ( 0 , n ) :			      	i ++ ) {						      i ++ ) {							  
	    if arr [ j ] > arr [ i ] :			      	  int count = 0 ;					    	int count = 0 ;						  
		count = count + 1			      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	if count >= 2 :					      	  j < n ;						    	j < n ;							  
	    print ( arr [ i ] , end = " " )		      	  j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ;	    	j ++ ) {						  
							      	  if ( count >= 2 ) cout << arr [ i ] << " " ;		    	  if ( arr [ j ] > arr [ i ] ) count = count + 1 ;	  
							      	}							    	}							  
							      }								    	if ( count >= 2 ) cout << arr [ i ] << " " ;		  
							      								      }								  
							      								      return n ;						  
-							      -								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION ZECKENDORFS_THEOREM_NON_NEIGHBOURING_FIBONACCI_REPRESENTATION
--							      --							    --								  --
def nearestSmallerEqFib ( n ) :				      int nearestSmallerEqFib ( int n ) {			    int nearestSmallerEqFib ( int n ) {				  success : None
    if ( n == 0 or n == 1 ) :				      	if ( n == 0 || n == 1 ) return n ;			      if ( ( n == 0 ) || ( n == 1 ) ) return n ;		  
	return n					      	int f1 = 0 , f2 = 1 , f3 = 1 ;				      int f1 = 0 , f2 = 1 , f3 = 1 ;				  
    f1 , f2 , f3 = 0 , 1 , 1				      	while ( f3 <= n ) {					      while ( ( f3 <= n ) ) {					  
    while ( f3 <= n ) :					      	  f1 = f2 ;						    	f1 = f2 ;						  
	f1 = f2 ;					      	  f2 = f3 ;						    	f2 = f3 ;						  
	f2 = f3 ;					      	  f3 = f1 + f2 ;					    	f3 = f1 + f2 ;						  
	f3 = f1 + f2 ;					      	}							      }								  
    return f2 ;						      	return f2 ;						      return f2 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_DIFFERENCE_PAIR				      FIND_MINIMUM_DIFFERENCE_PAIR				    FIND_MINIMUM_DIFFERENCE_PAIR				  FIND_MINIMUM_DIFFERENCE_PAIR
--							      --							    --								  --
def findMinDiff ( arr , n ) :				      int findMinDiff ( int arr [ ] , int n ) {			    int findMinDiff ( int * arr , int n ) {			  success : None
    diff = 10 ** 20					      	int diff = INT_MAX ;					      int diff = 10 * 20 ;					  
    for i in range ( n - 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n - 1 ;						      i < n - 1 ;						  
	    if abs ( arr [ i ] - arr [ j ] ) < diff :	      	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
		diff = abs ( arr [ i ] - arr [ j ] )	      	j < n ;							    	for ( int j = i + 1 ;					  
    return diff						      	j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = a 	j < n ;							  
							      	return diff ;						    	j ++ ) {						  
							      }								    	  if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs  
							      								    	}							  
							      								      }								  
							      								      return diff ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE
--							      --							    --								  --
def subArray ( arr , n ) :				      void subArray ( int arr [ ] , int n ) {			    int subArray ( int * arr , int n ) {			  script_not_found : None
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i , n ) :			      	i < n ;							      i <= n ;							  
	    for k in range ( i , j + 1 ) :		      	i ++ ) {						      i ++ ) {							  
		print ( arr [ k ] , end = "" )		      	  for ( int j = i ;					    	for ( int j = i ;					  
	    print ( "\n" , end = "" )			      	  j < n ;						    	j < n ;							  
							      	  j ++ ) {						    	j ++ ) {						  
							      	    for ( int k = i ;					    	  for ( int k = i ;					  
							      	    k <= j ;						    	  k <= j ;						  
							      	    k ++ ) cout << arr [ k ] << " " ;			    	  k ++ ) cout << arr [ k ] << " " ;			  
							      	    cout << endl ;					    	  cout << "\n" ;					  
							      	  }							    	}							  
							      	}							      }								  
							      }								      return n ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7	      FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7		    FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7		  FIND_POSITION_GIVEN_NUMBER_AMONG_NUMBERS_MADE_4_7
--							      --							    --								  --
def findpos ( n ) :					      int findpos ( string n ) {				    int findpos ( string n ) {					  timeout : None
    i = 0						      	int i = 0 , pos = 0 ;					      int i = 0 ;						  
    j = len ( n )					      	while ( n [ i ] != '\0' ) {				      int j = n . length ( ) ;					  
    pos = 0						      	  switch ( n [ i ] ) {					      int pos = 0 ;						  
    while ( i < j ) :					      	    case '4' : pos = pos * 2 + 1 ;			      while ( ( i < j ) && ( n [ i ] == '4' ) ) pos = pos * 2 + 1 
	if ( n [ i ] == '4' ) :				      	    break ;						      if ( ( n [ i ] == '7' ) ) pos = pos * 2 + 2 ;		  
	    pos = pos * 2 + 1				      	    case '7' : pos = pos * 2 + 2 ;			      i = i + 1 ;						  
	if ( n [ i ] == '7' ) :				      	    break ;						      return pos ;						  
	    pos = pos * 2 + 2				      	  }							    }								  
	i = i + 1					      	  i ++ ;						    								  
    return pos						      	}							    								  
							      	return pos ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			      SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			    SUM_MANHATTAN_DISTANCES_PAIRS_POINTS			  SUM_MANHATTAN_DISTANCES_PAIRS_POINTS
--							      --							    --								  --
def distancesum ( x , y , n ) :				      int distancesum ( int x [ ] , int y [ ] , int n ) {	    int distancesum ( int * x , int * y , int n ) {		  success : None
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i < n ;							  
	    sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i  	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
    return sum						      	j < n ;							    	for ( int j = i + 1 ;					  
							      	j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - 	j < n ;							  
							      	return sum ;						    	j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] 
							      }								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_FACTORS_NUMBER					      SUM_FACTORS_NUMBER					    SUM_FACTORS_NUMBER						  SUM_FACTORS_NUMBER
--							      --							    --								  --
def divSum ( n ) :					      int divSum ( int n ) {					    int divSum ( int n ) {					  success : None
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    for i in range ( 2 , ( int ) ( math.sqrt ( n ) ) + 1 ) :  	for ( int i = 2 ;					      for ( int i = 2 ;						  
	if ( n % i == 0 ) :				      	i <= sqrt ( n ) ;					      i < ( int ) ( sqrt ( n ) ) + 1 ;				  
	    if ( i == ( n / i ) ) :			      	i ++ ) {						      i ++ ) {							  
		result = result + i			      	  if ( n % i == 0 ) {					    	if ( ( n % i ) == 0 ) {					  
	    else :					      	    if ( i == ( n / i ) ) result += i ;			    	  if ( ( i == ( n / i ) ) ) result = result + i ;	  
		result = result + ( i + n // i )	      	    else result += ( i + n / i ) ;			    	  else result = result + ( i + n / i ) ;		  
    return ( result + n + 1 )				      	  }							    	}							  
							      	}							      }								  
							      	return ( result + n + 1 ) ;				      return ( result + n + 1 ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	      WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	    WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS	  WAYS_TO_WRITE_N_AS_SUM_OF_TWO_OR_MORE_POSITIVE_INTEGERS
--							      --							    --								  --
def CountWays ( n ) :					      int countWays ( int n ) {					    int CountWays ( int n ) {					  success : None
    table = [ 0 ] * ( n + 1 )				      	int table [ n + 1 ] ;					      vector < int > table ( n + 1 , 0 ) ;			  
    table [ 0 ] = 1					      	memset ( table , 0 , sizeof ( table ) ) ;		      table [ 0 ] = 1 ;						  
    for i in range ( 1 , n ) :				      	table [ 0 ] = 1 ;					      for ( int i = 1 ;						  
	for j in range ( i , n + 1 ) :			      	for ( int i = 1 ;					      i < n ;							  
	    table [ j ] += table [ j - i ]		      	i < n ;							      i ++ ) {							  
    return table [ n ]					      	i ++ ) for ( int j = i ;				    	for ( int j = i ;					  
							      	j <= n ;						    	j <= n ;						  
							      	j ++ ) table [ j ] += table [ j - i ] ;			    	j ++ ) {						  
							      	return table [ n ] ;					    	  table [ j ] += table [ j - i ] ;			  
							      }								    	}							  
							      								      }								  
							      								      return table [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		      FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		    FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY		  FIND_THE_MAXIMUM_SUBARRAY_XOR_IN_A_GIVEN_ARRAY
--							      --							    --								  --
def maxSubarrayXOR ( arr , n ) :			      int maxSubarrayXOR ( int arr [ ] , int n ) {		    int maxSubarrayXOR ( int * arr , int n ) {			  success : None
    ans = - 2147483648					      	int ans = INT_MIN ;					      int ans = - 2147483648 ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	curr_xor = 0					      	i < n ;							      i < n ;							  
	for j in range ( i , n ) :			      	i ++ ) {						      i ++ ) {							  
	    curr_xor = curr_xor ^ arr [ j ]		      	  int curr_xor = 0 ;					    	int currXor = 0 ;					  
	    ans = max ( ans , curr_xor )		      	  for ( int j = i ;					    	for ( int j = i ;					  
    return ans						      	  j < n ;						    	j < n ;							  
							      	  j ++ ) {						    	j ++ ) {						  
							      	    curr_xor = curr_xor ^ arr [ j ] ;			    	  currXor = currXor ^ arr [ j ] ;			  
							      	    ans = max ( ans , curr_xor ) ;			    	  ans = max ( ans , currXor ) ;				  
							      	  }							    	}							  
							      	}							      }								  
							      	return ans ;						      return ans ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_PRINT_IDENTITY_MATRIX_1				      PROGRAM_PRINT_IDENTITY_MATRIX_1				    PROGRAM_PRINT_IDENTITY_MATRIX_1				  PROGRAM_PRINT_IDENTITY_MATRIX_1
--							      --							    --								  --
def isIdentity ( mat , N ) :				      bool isIdentity ( int mat [ ] [ MAX ] , int N ) {		    bool isIdentity ( int * * mat , int N ) {			  script_not_found : None
    for row in range ( N ) :				      	for ( int row = 0 ;					      for ( int row = 0 ;					  
	for col in range ( N ) :			      	row < N ;						      row < N ;							  
	    if ( row == col and mat [ row ] [ col ] != 1 ) :  	row ++ ) {						      row ++ ) {						  
		return False				      	  for ( int col = 0 ;					    	for ( int col = 0 ;					  
	    elif ( row != col and mat [ row ] [ col ] != 0 )  	  col < N ;						    	col < N ;						  
		return False				      	  col ++ ) {						    	col ++ ) {						  
    return True						      	    if ( row == col && mat [ row ] [ col ] != 1 ) return fa 	  if ( ( row == col ) && mat [ row ] [ col ] != 1 ) retur 
							      	    else if ( row != col && mat [ row ] [ col ] != 0 ) retu 	  else if ( ( row != col ) && mat [ row ] [ col ] != 0 )  
							      	  }							    	}							  
							      	}							      }								  
							      	return true ;						      return true ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		      SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		    SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1		  SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY_1
--							      --							    --								  --
def insertSorted ( arr , n , key , capacity ) :		      int insertSorted ( int arr [ ] , int n , int key , int capaci int insertSorted ( int * arr , int n , int key , int capacity success : None
    if ( n >= capacity ) :				      	if ( n >= capacity ) return n ;				      if ( ( n >= capacity ) ) return n ;			  
	return n					      	int i ;							      int i = n - 1 ;						  
    i = n - 1						      	for ( i = n - 1 ;					      while ( i >= 0 && arr [ i ] > key ) {			  
    while i >= 0 and arr [ i ] > key :			      	( i >= 0 && arr [ i ] > key ) ;				    	arr [ i + 1 ] = arr [ i ] ;				  
	arr [ i + 1 ] = arr [ i ]			      	i -- ) arr [ i + 1 ] = arr [ i ] ;			    	i -- ;							  
	i -= 1						      	arr [ i + 1 ] = key ;					      }								  
    arr [ i + 1 ] = key					      	return ( n + 1 ) ;					      arr [ i + 1 ] = key ;					  
    return ( n + 1 )					      }								      return ( n + 1 ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY		      MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY		    MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY			  MINIMUM_SUM_TWO_NUMBERS_FORMED_DIGITS_ARRAY
--							      --							    --								  --
def solve ( arr , n ) :					      int solve ( int arr [ ] , int n ) {			    int solve ( int * arr , int n ) {				  success : None
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    a = 0 b = 0						      	int a = 0 , b = 0 ;					      int a = 0 , b = 0 ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( i % 2 != 0 ) :				      	i < n ;							      i < n ;							  
	    a = a * 10 + arr [ i ]			      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( i & 1 ) a = a * 10 + arr [ i ] ;			    	if ( ( i % 2 != 0 ) ) a = a * 10 + arr [ i ] ;		  
	    b = b * 10 + arr [ i ]			      	  else b = b * 10 + arr [ i ] ;				    	else b = b * 10 + arr [ i ] ;				  
    return a + b					      	}							      }								  
							      	return a + b ;						      return a + b ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_STRING_BINARY_SEQUENCE				      CONVERT_STRING_BINARY_SEQUENCE				    CONVERT_STRING_BINARY_SEQUENCE				  CONVERT_STRING_BINARY_SEQUENCE
--							      --							    --								  --
def strToBinary ( s ) :					      void strToBinary ( string s ) {				    string strToBinary ( string s ) {				  script_not_found : None
    bin_conv = [ ]					      	int n = s . length ( ) ;				      string binConv ;						  
    for c in s :					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	ascii_val = ord ( c )				      	i <= n ;						      i < s . length ( ) ;					  
	binary_val = bin ( ascii_val )			      	i ++ ) {						      i ++ ) {							  
	bin_conv.append ( binary_val [ 2 : ] )		      	  int val = int ( s [ i ] ) ;				    	char c = s [ i ] ;					  
    return ( ' '.join ( bin_conv ) )			      	  string bin = "" ;					    	char asciiVal = c ;					  
							      	  while ( val > 0 ) {					    	string binaryVal = binaryVal . substr ( 2 ) ;		  
							      	    ( val % 2 ) ? bin . push_back ( '1' ) : bin . push_back 	binConv += binaryVal . substr ( 2 ) ;			  
							      	    val /= 2 ;						      }								  
							      	  }							      return ( binConv ) ;					  
							      	  reverse ( bin . begin ( ) , bin . end ( ) ) ;		    }								  
							      	  cout << bin << " " ;					    								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
OVERLAPPING_SUM_TWO_ARRAY				      OVERLAPPING_SUM_TWO_ARRAY					    OVERLAPPING_SUM_TWO_ARRAY					  OVERLAPPING_SUM_TWO_ARRAY
--							      --							    --								  --
def findSum ( A , B , n ) :				      int findSum ( int A [ ] , int B [ ] , int n ) {		    int findSum ( int * A , int * B , int n ) {			  error : OVERLAPPING_SUM_TWO_ARRAY.cpp: In function
    Hash = defaultdict ( lambda : 0 )			      	unordered_map < int , int > hash ;			      unordered_map < int , int > Hash ;			   ‘int f_filled(int*, int*, int)’: OVERLAPPING_SUM_
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  TWO_ARRAY.cpp:39:17: error: cannot convert ‘std::p
	Hash [ A [ i ] ] += 1				      	i < n ;							      i != n ;							  air<const int, int>’ to ‘int’ in initialization
	Hash [ B [ i ] ] += 1				      	i ++ ) {						      i ++ ) {							   for ( int x : Hash ) {		   ^~~~
    Sum = 0						      	  hash [ A [ i ] ] ++ ;					    	Hash [ A [ i ] ] ++ ;					  
    for x in Hash :					      	  hash [ B [ i ] ] ++ ;					    	Hash [ B [ i ] ] ++ ;					  
	if Hash [ x ] == 1 :				      	}							      }								  
	    Sum += x					      	int sum = 0 ;						      int Sum = 0 ;						  
    return Sum						      	for ( auto x : hash ) if ( x . second == 1 ) sum += x . fir   for ( int x : Hash ) {					  
							      	return sum ;						    	if ( Hash [ x ] == 1 ) Sum += x ;			  
							      }								      }								  
							      								      return Sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			      FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			    FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM			  FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM
--							      --							    --								  --
def maxLen ( arr ) :					      int maxLen ( int arr [ ] , int n ) {			    int maxLen ( int * arr ) {					  error : FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM.cpp:
    max_len = 0						      	int max_len = 0 ;					      int maxLen = 0 ;						  In function ‘int main()’: FIND_THE_LARGEST_SUBARRA
    for i in range ( len ( arr ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  Y_WITH_0_SUM.cpp:56:49: error: too many arguments
	curr_sum = 0					      	i < n ;							      i < sizeof ( arr ) / sizeof ( int ) ;			  to function ‘int f_filled(int*)’	    if(f_fil
	for j in range ( i , len ( arr ) ) :		      	i ++ ) {						      i ++ ) {							  led(&param0[i].front(),param1[i]) == f_gold(&param
	    curr_sum += arr [ j ]			      	  int curr_sum = 0 ;					    	int currSum = 0 ;					  0[i].front(),param1[i]))
	    if curr_sum == 0 :				      	  for ( int j = i ;					    	for ( int j = i ;					  			  ^ FIND_THE_LARGEST_SUBARRA
		max_len = max ( max_len , j - i + 1 )	      	  j < n ;						    	j < sizeof ( arr ) / sizeof ( int ) ;			  Y_WITH_0_SUM.cpp:33:5: note: declared here  int f_
    return max_len					      	  j ++ ) {						    	j ++ ) {						  filled ( int * arr ) {      ^~~~~~~~
							      	    curr_sum += arr [ j ] ;				    	  currSum += arr [ j ] ;				  
							      	    if ( curr_sum == 0 ) max_len = max ( max_len , j - i +  	  if ( currSum == 0 ) maxLen = max ( maxLen , j - i + 1 ) 
							      	  }							    	}							  
							      	}							      }								  
							      	return max_len ;					      return maxLen ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	      FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	    FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE	  FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE
--							      --							    --								  --
def minRadius ( k , x , y , n ) :			      int minRadius ( int k , int x [ ] , int y [ ] , int n ) {	    double minRadius ( int k , double * x , double * y , int n )  error : FIND_MINIMUM_RADIUS_ATLEAST_K_POINT_LIE_IN
    dis = [ 0 ] * n					      	int dis [ n ] ;						      double dis [ n ] ;					  SIDE_CIRCLE.cpp: In function ‘int main()’: FIND_MI
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  NIMUM_RADIUS_ATLEAST_K_POINT_LIE_INSIDE_CIRCLE.cpp
	dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ]     	i < n ;							      i != n ;							  :44:31: error: cannot convert ‘__gnu_cxx::__alloc_
    dis.sort ( )					      	i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ;    i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ;  traits<std::allocator<int>, int>::value_type*’ {ak
    return dis [ k - 1 ]				      	sort ( dis , dis + n ) ;				      std :: sort ( dis , dis + n ) ;				  a ‘int*’} to ‘double*’	  if(f_filled(param0
							      	return dis [ k - 1 ] ;					      return dis [ k - 1 ] ;					  [i],&param1[i].front(),&param2[i].front(),param3[i
							      }								    }								  ]) == f_gold(param0[i],&param1[i].front(),&param2[
							      								    								  i].front(),param3[i]))
							      								    								      ^~~~~~~~~~~~~~~~~~ FIND_MINIMUM_RADIUS_ATLEAST
							      								    								  _K_POINT_LIE_INSIDE_CIRCLE.cpp:26:36: note:	init
							      								    								  ializing argument 2 of ‘double f_filled(int, doubl
							      								    								  e*, double*, int)’  double f_filled ( int k , doub
							      								    								  le * x , double * y , int n ) {
							      								    								  	   ~~~~~~~~~^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1		      MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1		    MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1			  MIDDLE_OF_THREE_USING_MINIMUM_COMPARISONS_1
--							      --							    --								  --
def middleOfThree ( a , b , c ) :			      int middleOfThree ( int a , int b , int c ) {		    int middleOfThree ( int a , int b , int c ) {		  success : None
    if a > b :						      	if ( a > b ) {						      if ( a > b ) {						  
	if ( b > c ) :					      	  if ( b > c ) return b ;				    	if ( ( b > c ) ) return b ;				  
	    return b					      	  else if ( a > c ) return c ;				    	else if ( ( a > c ) ) return c ;			  
	elif ( a > c ) :				      	  else return a ;					    	else return a ;						  
	    return c					      	}							      }								  
	else :						      	else {							      else {							  
	    return a					      	  if ( a > c ) return a ;				    	if ( ( a > c ) ) return a ;				  
    else :						      	  else if ( b > c ) return c ;				    	else if ( ( b > c ) ) return c ;			  
	if ( a > c ) :					      	  else return b ;					    	else return b ;						  
	    return a					      	}							      }								  
	elif ( b > c ) :				      }								    }								  
	    return c					      								    								  
	else :						      								    								  
	    return b					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS   GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS   GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS	  GENERATE_BINARY_PERMUTATIONS_1S_0S_EVERY_POINT_PERMUTATIONS
--							      --							    --								  --
def generate ( ones , zeroes , str , len1 ) :		      void generate ( int ones , int zeroes , string str , int len  int generate ( int ones , int zeroes , string str , int len1  script_not_found : None
    if ( len1 == len ( str ) ) :			      	if ( len == str . length ( ) ) {			      if ( ( len1 == str . length ( ) ) ) {			  
	print ( str , end = " " )			      	  cout << str << "  " ;					    	cout << str << " " ;					  
	return						      	  return ;						    	return 0 ;						  
    generate ( ones + 1 , zeroes , str + "1" , len1 )	      	}							      }								  
    if ( ones > zeroes ) :				      	generate ( ones + 1 , zeroes , str + "1" , len ) ;	      generate ( ones + 1 , zeroes , str + "1" , len1 ) ;	  
	generate ( ones , zeroes + 1 , str + "0" , len1 )     	if ( ones > zeroes ) generate ( ones , zeroes + 1 , str + "   if ( ( ones > zeroes ) ) generate ( ones , zeroes + 1 , str 
							      }								      return ones ;						  
							      								      return ones * ones ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FRIENDS_PAIRING_PROBLEM					      FRIENDS_PAIRING_PROBLEM					    FRIENDS_PAIRING_PROBLEM					  FRIENDS_PAIRING_PROBLEM
--							      --							    --								  --
def countFriendsPairings ( n ) :			      int countFriendsPairings ( int n ) {			    int countFriendsPairings ( int n ) {			  success : None
    dp = [ 0 for i in range ( n + 1 ) ]			      	int dp [ n + 1 ] ;					      vector < int > dp ( n + 1 , 0 ) ;				  
    for i in range ( n + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( i <= 2 ) :					      	i <= n ;						      i < n + 1 ;						  
	    dp [ i ] = i				      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( i <= 2 ) dp [ i ] = i ;				    	if ( ( i <= 2 ) ) dp [ i ] = i ;			  
	    dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2  	  else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; 	else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; 
    return dp [ n ]					      	}							      }								  
							      	return dp [ n ] ;					      return dp [ n ] ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE SEARCH_AN_ELEMENT_IN_AN_ARRAY_WHERE_DIFFERENCE_BETWEEN_ADJACE
--							      --							    --								  --
def search ( arr , n , x ) :				      int search ( int arr [ ] , int n , int x ) {		    int search ( int * arr , int n , int x ) {			  failure : number is not present! number is not pre
    i = 0						      	int i = 0 ;						      int i = 0 ;						  sent! number is not present!number is not present!
    while ( i < n ) :					      	while ( i < n ) {					      while ( ( i < n ) && ( arr [ i ] == x ) ) {		   number is not present! number is not present!numb
	if ( arr [ i ] == x ) :				      	  if ( arr [ i ] == x ) return i ;			    	if ( ( arr [ i ] == x ) ) return i ;			  er is not present! number is not present!number is
	    return i					      	  i = i + abs ( arr [ i ] - x ) ;			    	i = i + abs ( arr [ i ] - x ) ;				   not present! number is not present!number is not
	i = i + abs ( arr [ i ] - x )			      	}							      }								  present! number is not present!number is not prese
    print ( "number is not present!" )			      	cout << "number is not present!" ;			      cout << "number is not present!" << endl ;		  nt! number is not present!number is not present! n
    return - 1						      	return - 1 ;						      return - 1 ;						  umber is not present!number is not present! number
							      }								      return n * n ;						   is not present!#Results: 8, 10
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCHING_ARRAY_ADJACENT_DIFFER_K			      SEARCHING_ARRAY_ADJACENT_DIFFER_K				    SEARCHING_ARRAY_ADJACENT_DIFFER_K				  SEARCHING_ARRAY_ADJACENT_DIFFER_K
--							      --							    --								  --
def search ( arr , n , x , k ) :			      int search ( int arr [ ] , int n , int x , int k ) {	    int search ( int * arr , int n , int x , int k ) {		  error : SEARCHING_ARRAY_ADJACENT_DIFFER_K.cpp:34:1
    i = 0						      	int i = 0 ;						      int i = 0 ;						  : error: ‘cout’ does not name a type; did you mean
    while ( i < n ) :					      	while ( i < n ) {					      while ( ( i < n ) && ( arr [ i ] == x ) ) {		   ‘cosl’?  cout << "number is not present!" << endl
	if ( arr [ i ] == x ) :				      	  if ( arr [ i ] == x ) return i ;			    	return i ;						   ;  ^~~~  cosl SEARCHING_ARRAY_ADJACENT_DIFFER_K.c
	    return i					      	  i = i + max ( 1 , abs ( arr [ i ] - x ) / k ) ;	      }								  pp:35:1: error: expected unqualified-id before ‘re
	i = i + max ( 1 , int ( abs ( arr [ i ] - x ) / k ) ) 	}							      i = i + max < int > ( 1 , ( int ) ( abs ( arr [ i ] - x ) / turn’	 return - 1 ;  ^~~~~~ SEARCHING_ARRAY_ADJACE
    print ( "number is not present!" )			      	cout << "number is not present!" ;			    }								  NT_DIFFER_K.cpp:36:1: error: expected unqualified-
    return - 1						      	return - 1 ;						    cout << "number is not present!" << endl ;			  id before ‘return’  return n * n ;  ^~~~~~ SEARCHI
							      }								    return - 1 ;						  NG_ARRAY_ADJACENT_DIFFER_K.cpp:37:1: error: expect
							      								    return n * n ;						  ed declaration before ‘}’ token  }  ^ SEARCHING_AR
							      								    }								  RAY_ADJACENT_DIFFER_K.cpp: In function ‘int f_fill
							      								    								  ed(int*, int, int, int)’: SEARCHING_ARRAY_ADJACENT
							      								    								  _DIFFER_K.cpp:33:1: warning: control reaches end o
							      								    								  f non-void function [-Wreturn-type]  }  ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_DIFFERENCE_EQUAL_K				      COUNT_PAIRS_DIFFERENCE_EQUAL_K				    COUNT_PAIRS_DIFFERENCE_EQUAL_K				  COUNT_PAIRS_DIFFERENCE_EQUAL_K
--							      --							    --								  --
def countPairsWithDiffK ( arr , n , k ) :		      int countPairsWithDiffK ( int arr [ ] , int n , int k ) {	    int countPairsWithDiffK ( int * arr , int n , int k ) {	  success : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i < n ;							  
	    if arr [ i ] - arr [ j ] == k or arr [ j ] - arr  	i ++ ) {						      i ++ ) {							  
		count += 1				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
    return count					      	  j < n ;						    	j < n ;							  
							      	  j ++ ) if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr 	j ++ ) {						  
							      	}							    	  if ( arr [ i ] - arr [ j ] == k || arr [ j ] - arr [ i  
							      	return count ;						    	}							  
							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI COUNT_NEGATIVE_NUMBERS_IN_A_COLUMN_WISE_ROW_WISE_SORTED_MATRI
--							      --							    --								  --
def countNegative ( M , n , m ) :			      int countNegative ( int M [ ] [ 4 ] , int n , int m ) {	    int countNegative ( int * * M , int n , int m ) {		  script_not_found : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    i = 0						      	int i = 0 ;						      int i = 0 ;						  
    j = m - 1						      	int j = m - 1 ;						      int j = m - 1 ;						  
    while j >= 0 and i < n :				      	while ( j >= 0 && i < n ) {				      while ( j >= 0 && i < n ) {				  
	if M [ i ] [ j ] < 0 :				      	  if ( M [ i ] [ j ] < 0 ) {				    	if ( M [ i ] [ j ] < 0 ) {				  
	    count += ( j + 1 )				      	    count += j + 1 ;					    	  count += ( j + 1 ) ;					  
	    i += 1					      	    i += 1 ;						    	  i ++ ;						  
	else :						      	  }							    	}							  
	    j -= 1					      	  else j -= 1 ;						    	else {							  
    return count					      	}							    	  j -- ;						  
							      	return count ;						    	}							  
							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS	      MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS	    MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS		  MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS
--							      --							    --								  --
def minProduct ( arr , n , k ) :			      int minProduct ( int arr [ ] , int n , int k ) {		    double minProduct ( double * arr , int n , int k ) {	  error : MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSITIVE_
    heapq.heapify ( arr )				      	priority_queue < int , vector < int > , greater < int >> pq   int count = 0 ;						  INTEGERS.cpp: In function ‘double f_filled(double*
    count = 0						      	for ( int i = 0 ;					      double ans = 1 ;						  , int, int)’: MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POS
    ans = 1						      	i < n ;							      while ( ( arr ) & & count < k ) {				  ITIVE_INTEGERS.cpp:34:31: error: ISO C++ forbids c
    while ( arr ) and count < k :			      	i ++ ) pq . push ( arr [ i ] ) ;			    	double x = * arr ;					  omparison between pointer and integer [-fpermissiv
	x = heapq.heappop ( arr )			      	int count = 0 , ans = 1 ;				    	ans = ans * x ;						  e]	while ( ( arr ) & & count < k ) {
	ans = ans * x					      	while ( pq . empty ( ) == false && count < k ) {	    	count = count + 1 ;					  		       ^ MINIMUM_PRODUCT_K_INTEGERS_
	count = count + 1				      	  ans = ans * pq . top ( ) ;				      }								  ARRAY_POSITIVE_INTEGERS.cpp:34:19: error: invalid
    return ans						      	  pq . pop ( ) ;					      return ans ;						  operands of types ‘double*’ and ‘bool’ to binary ‘
							      	  count ++ ;						    }								  operator&’	while ( ( arr ) & & count < k ) {
							      	}							    								  	   ~~~~~~~~^~~~~~~~~~~~~ MINIMUM_PRODUCT_K_I
							      	return ans ;						    								  NTEGERS_ARRAY_POSITIVE_INTEGERS.cpp: In function ‘
							      }								    								  int main()’: MINIMUM_PRODUCT_K_INTEGERS_ARRAY_POSI
							      								    								  TIVE_INTEGERS.cpp:50:21: error: cannot convert ‘__
							      								    								  gnu_cxx::__alloc_traits<std::allocator<int>, int>:
							      								    								  :value_type*’ {aka ‘int*’} to ‘double*’	   i
							      								    								  f(f_filled(&param0[i].front(),param1[i],param2[i])
							      								    								   == f_gold(&param0[i].front(),param1[i],param2[i])
							      								    								  )			 ^~~~~~~~~~~~~~~~~~ MINIMUM_
							      								    								  PRODUCT_K_INTEGERS_ARRAY_POSITIVE_INTEGERS.cpp:31:
							      								    								  28: note:   initializing argument 1 of ‘double f_f
							      								    								  illed(double*, int, int)’  double f_filled ( doubl
							      								    								  e * arr , int n , int k ) {			 ~~~
							      								    								  ~~~~~~^~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		      CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		    CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION		  CHINESE_REMAINDER_THEOREM_SET_1_INTRODUCTION
--							      --							    --								  --
def findMinX ( num , rem , k ) :			      int findMinX ( int num [ ] , int rem [ ] , int k ) {	    int findMinX ( int * num , int * rem , int k ) {		  script_not_found : None
    x = 1						      	int x = 1 ;						      int x = 1 ;						  
    while ( True ) :					      	while ( true ) {					      while ( ( true ) ) {					  
	j = 0						      	  int j ;						    	int j = 0 ;						  
	while ( j < k ) :				      	  for ( j = 0 ;						    	while ( ( j < k ) ) {					  
	    if ( x % num [ j ] != rem [ j ] ) :		      	  j < k ;						    	  if ( ( x % num [ j ] != rem [ j ] ) ) break ;		  
		break					      	  j ++ ) if ( x % num [ j ] != rem [ j ] ) break ;	    	  j ++ ;						  
	    j += 1					      	  if ( j == k ) return x ;				    	}							  
	if ( j == k ) :					      	  x ++ ;						    	if ( ( j == k ) ) return x ;				  
	    return x					      	}							    	x ++ ;							  
	x += 1						      	return x ;						      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES		      AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES		    AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES		  AREA_OF_A_POLYGON_WITH_GIVEN_N_ORDERED_VERTICES
--							      --							    --								  --
def polygonArea ( X , Y , n ) :				      double polygonArea ( double X [ ] , double Y [ ] , int n ) {  int polygonArea ( double * X , double * Y , int n ) {	  script_not_found : None
    area = 0.0						      	double area = 0.0 ;					      double area = 0.0 ;					  
    j = n - 1						      	int j = n - 1 ;						      int j = n - 1 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) 	i < n ;							      i < n ;							  
	j = i						      	i ++ ) {						      i ++ ) {							  
    return int ( abs ( area / 2.0 ) )			      	  area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;   	area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;	  
							      	  j = i ;						    	j = i ;							  
							      	}							      }								  
							      	return abs ( area / 2.0 ) ;				      return ( int ) fabs ( area / 2.0 ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_CONSECUTIVE_DUPLICATES_STRING			      REMOVE_CONSECUTIVE_DUPLICATES_STRING			    REMOVE_CONSECUTIVE_DUPLICATES_STRING			  REMOVE_CONSECUTIVE_DUPLICATES_STRING
--							      --							    --								  --
def removeDuplicates ( S ) :				      void removeDuplicates ( char S [ ] ) {			    string removeDuplicates ( string S ) {			  script_not_found : None
    n = len ( S )					      	int n = strlen ( S ) ;					      int n = S . length ( ) ;					  
    if ( n < 2 ) :					      	if ( n < 2 ) return ;					      if ( ( n < 2 ) ) return S ;				  
	return						      	int j = 0 ;						      int j = 0 ;						  
    j = 0						      	for ( int i = 1 ;					      for ( int i = 0 ;						  
    for i in range ( n ) :				      	i < n ;							      i < n ;							  
	if ( S [ j ] != S [ i ] ) :			      	i ++ ) {						      i ++ ) {							  
	    j += 1					      	  if ( S [ j ] != S [ i ] ) {				    	if ( ( S [ j ] != S [ i ] ) && ( S [ j ] != S [ i ] ) ) { 
	    S [ j ] = S [ i ]				      	    j ++ ;						    	  j ++ ;						  
    j += 1						      	    S [ j ] = S [ i ] ;					    	  S [ j ] = S [ i ] ;					  
    S = S [ : j ]					      	  }							    	}							  
    return S						      	}							      }								  
							      	j ++ ;							      j ++ ;							  
							      	S [ j ] = '\0' ;					      S = S . substr ( 0 , j ) ;				  
							      }								      return S ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION		      DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION			    DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION			  DISTRIBUTING_ALL_BALLS_WITHOUT_REPETITION
--							      --							    --								  --
def distributingBalls ( k , n , string ) :		      bool distributingBalls ( int k , int n , string str ) {	    bool distributingBalls ( int k , int n , string string ) {	  script_not_found : None
    a = [ 0 ] * MAX_CHAR				      	int a [ MAX_CHAR ] = {					      vector < int > a ( MAX_CHAR , 0 ) ;			  
    for i in range ( n ) :				      	  0 }							      for ( int i = 0 ;						  
	a [ ord ( string [ i ] ) - ord ( 'a' ) ] += 1	      	  ;							      i < n ;							  
    for i in range ( MAX_CHAR ) :			      	  for ( int i = 0 ;					      i ++ ) a [ string [ i ] - 'a' ] ++ ;			  
	if ( a [ i ] > k ) :				      	  i < n ;						      for ( int i = 0 ;						  
	    return False				      	  i ++ ) {						      i < MAX_CHAR ;						  
    return True						      	    a [ str [ i ] - 'a' ] ++ ;				      i ++ ) if ( ( a [ i ] > k ) ) return false ;		  
							      	  }							      return true ;						  
							      	  for ( int i = 0 ;					    }								  
							      	  i < MAX_CHAR ;					    								  
							      	  i ++ ) if ( a [ i ] > k ) return false ;		    								  
							      	  return true ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GNOME_SORT_A_STUPID_ONE					      GNOME_SORT_A_STUPID_ONE					    GNOME_SORT_A_STUPID_ONE					  GNOME_SORT_A_STUPID_ONE
--							      --							    --								  --
def gnomeSort ( arr , n ) :				      void gnomeSort ( int arr [ ] , int n ) {			    int gnomeSort ( int * arr , int n ) {			  script_not_found : None
    index = 0						      	int index = 0 ;						      int index = 0 ;						  
    while index < n :					      	while ( index < n ) {					      while ( index < n ) {					  
	if index == 0 :					      	  if ( index == 0 ) index ++ ;				    	if ( index == 0 ) index = index + 1 ;			  
	    index = index + 1				      	  if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ;	    	if ( arr [ index ] >= arr [ index - 1 ] ) index = index + 
	if arr [ index ] >= arr [ index - 1 ] :		      	  else {						    	else {							  
	    index = index + 1				      	    swap ( arr [ index ] , arr [ index - 1 ] ) ;	    	  arr [ index ] = arr [ index - 1 ] ;			  
	else :						      	    index -- ;						    	  arr [ index - 1 ] = arr [ index ] ;			  
	    arr [ index ] , arr [ index - 1 ] = arr [ index - 	  }							    	  index = index - 1 ;					  
	    index = index - 1				      	}							    	}							  
    return arr						      	return ;						      }								  
							      }								      return index ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI PROGRAM_TO_CHECK_IF_A_GIVEN_NUMBER_IS_LUCKY_ALL_DIGITS_ARE_DI
--							      --							    --								  --
def isLucky ( n ) :					      bool isLucky ( int n ) {					    int isLucky ( int n ) {					  failure : #Results: 5, 10
    ar = [ 0 ] * 10					      	bool arr [ 10 ] ;					      int ar [ 10 ] ;						  
    while ( n > 0 ) :					      	for ( int i = 0 ;					      while ( ( n > 0 ) && ( ar [ n % 10 ] != 0 ) ) {		  
	digit = math.floor ( n % 10 )			      	i < 10 ;						    	int digit = floor ( n % 10 ) ;				  
	if ( ar [ digit ] ) :				      	i ++ ) arr [ i ] = false ;				    	if ( ( ar [ digit ] != 0 ) ) return 0 ;			  
	    return 0					      	while ( n > 0 ) {					    	ar [ digit ] = 1 ;					  
	ar [ digit ] = 1				      	  int digit = n % 10 ;					    	n = n / 10 ;						  
	n = n / 10					      	  if ( arr [ digit ] ) return false ;			      }								  
    return 1						      	  arr [ digit ] = true ;				      return 1 ;						  
							      	  n = n / 10 ;						    }								  
							      	}							    								  
							      	return true ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_INSERTION_SORT				      RECURSIVE_INSERTION_SORT					    RECURSIVE_INSERTION_SORT					  RECURSIVE_INSERTION_SORT
--							      --							    --								  --
def insertionSortRecursive ( arr , n ) :		      void insertionSortRecursive ( int arr [ ] , int n ) {	    void insertionSortRecursive ( int * arr , int n ) {		  script_not_found : None
    if n <= 1 :						      	if ( n <= 1 ) return ;					      if ( n <= 1 ) return ;					  
	return						      	insertionSortRecursive ( arr , n - 1 ) ;		      insertionSortRecursive ( arr , n - 1 ) ;			  
    insertionSortRecursive ( arr , n - 1 )		      	int last = arr [ n - 1 ] ;				      int last = arr [ n - 1 ] ;				  
    last = arr [ n - 1 ]				      	int j = n - 2 ;						      int j = n - 2 ;						  
    j = n - 2						      	while ( j >= 0 && arr [ j ] > last ) {			      while ( ( j >= 0 ) && ( arr [ j ] > last ) ) {		  
    while ( j >= 0 and arr [ j ] > last ) :		      	  arr [ j + 1 ] = arr [ j ] ;				    	arr [ j + 1 ] = arr [ j ] ;				  
	arr [ j + 1 ] = arr [ j ]			      	  j -- ;						    	j = j - 1 ;						  
	j = j - 1					      	}							      }								  
    arr [ j + 1 ] = last				      	arr [ j + 1 ] = last ;					      arr [ j + 1 ] = last ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_FIRST_MISSING_NUMBER				      FIND_THE_FIRST_MISSING_NUMBER				    FIND_THE_FIRST_MISSING_NUMBER				  FIND_THE_FIRST_MISSING_NUMBER
--							      --							    --								  --
def findFirstMissing ( array , start , end ) :		      int findFirstMissing ( int array [ ] , int start , int end )  int findFirstMissing ( int * array , int start , int end ) {  success : None
    if ( start > end ) :				      	if ( start > end ) return end + 1 ;			      if ( ( start > end ) ) return end + 1 ;			  
	return end + 1					      	if ( start != array [ start ] ) return start ;		      if ( ( start != array [ start ] ) ) return start ;	  
    if ( start != array [ start ] ) :			      	int mid = ( start + end ) / 2 ;				      int mid = ( int ) ( ( start + end ) / 2 ) ;		  
	return start					      	if ( array [ mid ] == mid ) return findFirstMissing ( array   if ( ( array [ mid ] == mid ) ) return findFirstMissing ( a 
    mid = int ( ( start + end ) / 2 )			      	return findFirstMissing ( array , start , mid ) ;	      return findFirstMissing ( array , start , mid ) ;		  
    if ( array [ mid ] == mid ) :			      }								    }								  
	return findFirstMissing ( array , mid + 1 , end )     								    								  
    return findFirstMissing ( array , start , mid )	      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			      CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			    CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT			  CHECK_IF_TWO_ARRAYS_ARE_EQUAL_OR_NOT
--							      --							    --								  --
def areEqual ( arr1 , arr2 , n , m ) :			      bool areEqual ( int arr1 [ ] , int arr2 [ ] , int n , int m ) bool areEqual ( int * arr1 , int * arr2 , int n , int m ) {	  script_not_found : None
    if ( n != m ) :					      	if ( n != m ) return false ;				      if ( ( n != m ) ) return false ;				  
	return False ;					      	sort ( arr1 , arr1 + n ) ;				      ;								  
    arr1.sort ( ) ;					      	sort ( arr2 , arr2 + m ) ;				      sort ( arr1 , arr1 + n ) ;				  
    arr2.sort ( ) ;					      	for ( int i = 0 ;					      sort ( arr2 , arr2 + n ) ;				  
    for i in range ( 0 , n - 1 ) :			      	i < n ;							      for ( int i = 0 ;						  
	if ( arr1 [ i ] != arr2 [ i ] ) :		      	i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ;	      i <= n - 1 ;						  
	    return False ;				      	return true ;						      i ++ ) if ( ( arr1 [ i ] != arr2 [ i ] ) ) return false ;	  
    return True ;					      }								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES  FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES  FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES  FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES
--							      --							    --								  --
def countSol ( coeff , start , end , rhs ) :		      int countSol ( int coeff [ ] , int start , int end , int rhs  int countSol ( int * coeff , int start , int end , int rhs )  script_not_found : None
    if ( rhs == 0 ) :					      	if ( rhs == 0 ) return 1 ;				      if ( ( rhs == 0 ) ) return 1 ;				  
	return 1					      	int result = 0 ;					      int result = 0 ;						  
    result = 0						      	for ( int i = start ;					      for ( int i = start ;					  
    for i in range ( start , end + 1 ) :		      	i <= end ;						      i <= end ;						  
	if ( coeff [ i ] <= rhs ) :			      	i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff   i ++ ) {							  
	    result += countSol ( coeff , i , end , rhs - coef 	return result ;						    	if ( ( coeff [ i ] <= rhs ) ) result += countSol ( coeff  
    return result					      }								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		      FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		    FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES		  FIND_THE_NUMBER_OCCURRING_ODD_NUMBER_OF_TIMES
--							      --							    --								  --
def getOddOccurrence ( arr , arr_size ) :		      int getOddOccurrence ( int arr [ ] , int arr_size ) {	    int getOddOccurrence ( int * arr , int arrSize ) {		  success : None
    for i in range ( 0 , arr_size ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	count = 0					      	i < arr_size ;						      i != arrSize ;						  
	for j in range ( 0 , arr_size ) :		      	i ++ ) {						      i ++ ) {							  
	    if arr [ i ] == arr [ j ] :			      	  int count = 0 ;					    	int count = 0 ;						  
		count += 1				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	if ( count % 2 != 0 ) :				      	  j < arr_size ;					    	j != arrSize ;						  
	    return arr [ i ]				      	  j ++ ) {						    	j ++ ) {						  
    return - 1						      	    if ( arr [ i ] == arr [ j ] ) count ++ ;		    	  if ( arr [ i ] == arr [ j ] ) count ++ ;		  
							      	  }							    	}							  
							      	  if ( count % 2 != 0 ) return arr [ i ] ;		    	if ( ( count % 2 ) != 0 ) return arr [ i ] ;		  
							      	}							      }								  
							      	return - 1 ;						      return - 1 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MIRROR_CHARACTERS_STRING				      MIRROR_CHARACTERS_STRING					    MIRROR_CHARACTERS_STRING					  MIRROR_CHARACTERS_STRING
--							      --							    --								  --
def compute ( st , n ) :				      string compute ( string str , int n ) {			    string compute ( string st , int n ) {			  error : /bin/bash: line 1: 1847262 Aborted
    reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba"	      	string reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ;	      string reverseAlphabet = "zyxwvutsrqponmlkjihgfedcba" ;	  	   (core dumped) ./MIRROR_CHARACTERS_STRING_
    l = len ( st )					      	int l = str . length ( ) ;				      int l = st . length ( ) ;					  cpp
    answer = ""						      	for ( int i = n ;					      string answer ;						  
    for i in range ( 0 , n ) :				      	i < l ;							      for ( int i = 0 ;						  
	answer = answer + st [ i ]			      	i ++ ) str [ i ] = reverseAlphabet [ str [ i ] - 'a' ] ;      i <= n ;							  
    for i in range ( n , l ) :				      	return str ;						      i ++ ) answer = answer + st [ i ] ;			  
	answer = ( answer + reverseAlphabet [ ord ( st [ i ]  }								      for ( int i = n ;						  
    return answer					      								      i < l ;							  
							      								      i ++ ) answer = ( answer + reverseAlphabet [ st [ i ] - 'a' 
							      								      return answer ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN			      N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN			    N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN			  N_TH_NUMBER_WHOSE_SUM_OF_DIGITS_IS_TEN
--							      --							    --								  --
def findNth ( n ) :					      int findNth ( int n ) {					    int findNth ( int n ) {					  failure : #Results: 0, 10
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for curr in itertools.count ( ) :			      	for ( int curr = 1 ;					      for ( int curr = 0 ;					  
	sum = 0						      	;							      curr < sizeof ( int ) / sizeof ( int ) ;			  
	x = curr					      	curr ++ ) {						      curr ++ ) {						  
	while ( x ) :					      	  int sum = 0 ;						    	int sum = 0 ;						  
	    sum = sum + x % 10				      	  for ( int x = curr ;					    	int x = curr ;						  
	    x = x // 10					      	  x > 0 ;						    	while ( ( x ) ) {					  
	if ( sum == 10 ) :				      	  x = x / 10 ) sum = sum + x % 10 ;			    	  sum = sum + x % 10 ;					  
	    count = count + 1				      	  if ( sum == 10 ) count ++ ;				    	  x = x / 10 ;						  
	if ( count == n ) :				      	  if ( count == n ) return curr ;			    	}							  
	    return curr					      	}							    	if ( ( sum == 10 ) ) count = count + 1 ;		  
    return - 1						      	return - 1 ;						    	if ( ( count == n ) ) return curr ;			  
							      }								      }								  
							      								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY   CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY   CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY	  CHECK_WHETHER_ARITHMETIC_PROGRESSION_CAN_FORMED_GIVEN_ARRAY
--							      --							    --								  --
def checkIsAP ( arr , n ) :				      bool checkIsAP ( int arr [ ] , int n ) {			    bool checkIsAP ( int * arr , int n ) {			  success : None
    if ( n == 1 ) : return True				      	if ( n == 1 ) return true ;				      if ( ( n == 1 ) ) return true ;				  
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    d = arr [ 1 ] - arr [ 0 ]				      	int d = arr [ 1 ] - arr [ 0 ] ;				      int d = arr [ 1 ] - arr [ 0 ] ;				  
    for i in range ( 2 , n ) :				      	for ( int i = 2 ;					      for ( int i = 2 ;						  
	if ( arr [ i ] - arr [ i - 1 ] != d ) :		      	i < n ;							      i < n ;							  
	    return False				      	i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ;   i ++ ) if ( ( arr [ i ] - arr [ i - 1 ] ) != d ) return fal 
    return True						      	return true ;						      return true ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO	      WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO	    WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO	  WAYS_REMOVE_ONE_ELEMENT_BINARY_STRING_XOR_BECOMES_ZERO
--							      --							    --								  --
def xorZero ( str ) :					      int xorZero ( string str ) {				    int xorZero ( string str ) {				  success : None
    one_count = 0					      	int one_count = 0 , zero_count = 0 ;			      int oneCount = 0 ;					  
    zero_count = 0					      	int n = str . length ( ) ;				      int zeroCount = 0 ;					  
    n = len ( str )					      	for ( int i = 0 ;					      int n = str . length ( ) ;				  
    for i in range ( 0 , n , 1 ) :			      	i < n ;							      for ( int i = 0 ;						  
	if ( str [ i ] == '1' ) :			      	i ++ ) if ( str [ i ] == '1' ) one_count ++ ;		      i < n ;							  
	    one_count += 1				      	else zero_count ++ ;					      i += 1 ) {						  
	else :						      	if ( one_count % 2 == 0 ) return zero_count ;		    	if ( ( str [ i ] == '1' ) ) oneCount ++ ;		  
	    zero_count += 1				      	return one_count ;					    	else zeroCount ++ ;					  
    if ( one_count % 2 == 0 ) :				      }								      }								  
	return zero_count				      								      if ( ( oneCount % 2 == 0 ) ) return zeroCount ;		  
    return one_count					      								      return oneCount ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X   COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X   COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X	  COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X
--							      --							    --								  --
def countPairs ( arr1 , arr2 , m , n , x ) :		      int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n  int countPairs ( int * arr1 , int * arr2 , int m , int n , in success : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( m ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( n ) :				      	i < m ;							      i < m ;							  
	    if arr1 [ i ] + arr2 [ j ] == x :		      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		count = count + 1			      	j < n ;							    	for ( int j = 0 ;					  
    return count					      	j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ;   	j < n ;							  
							      	return count ;						    	j ++ ) {						  
							      }								    	  if ( arr1 [ i ] + arr2 [ j ] == x ) count = count + 1 ; 
							      								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ONE_EXTRA_CHARACTER_STRING_1			      FIND_ONE_EXTRA_CHARACTER_STRING_1				    FIND_ONE_EXTRA_CHARACTER_STRING_1				  FIND_ONE_EXTRA_CHARACTER_STRING_1
--							      --							    --								  --
def findExtraCharcter ( strA , strB ) :			      char findExtraCharcter ( string strA , string strB ) {	    char findExtraCharcter ( string strA , string strB ) {	  success : None
    res = 0						      	int res = 0 , i ;					      int res = 0 ;						  
    for i in range ( 0 , len ( strA ) ) :		      	for ( i = 0 ;						      for ( int i = 0 ;						  
	res = res ^ ( ord ) ( strA [ i ] )		      	i < strA . length ( ) ;					      i < strA . length ( ) ;					  
    for i in range ( 0 , len ( strB ) ) :		      	i ++ ) {						      i ++ ) res = res ^ ( ( int ) strA [ i ] ) ;		  
	res = res ^ ( ord ) ( strB [ i ] )		      	  res ^= strA [ i ] ;					      for ( int i = 0 ;						  
    return ( ( chr ) ( res ) ) ;			      	}							      i < strB . length ( ) ;					  
							      	for ( i = 0 ;						      i ++ ) res = res ^ ( ( int ) strB [ i ] ) ;		  
							      	i < strB . length ( ) ;					      return ( ( char ) res ) ;					  
							      	i ++ ) {						      return strA . length ( ) ;				  
							      	  res ^= strB [ i ] ;					    }								  
							      	}							    								  
							      	return ( ( char ) ( res ) ) ;				    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SWAP_BITS_IN_A_GIVEN_NUMBER				      SWAP_BITS_IN_A_GIVEN_NUMBER				    SWAP_BITS_IN_A_GIVEN_NUMBER					  SWAP_BITS_IN_A_GIVEN_NUMBER
--							      --							    --								  --
def swapBits ( x , p1 , p2 , n ) :			      int swapBits ( unsigned int x , unsigned int p1 , unsigned in int swapBits ( int x , int p1 , int p2 , int n ) {		  error : SWAP_BITS_IN_A_GIVEN_NUMBER.cpp: In functi
    set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 )		      	unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ;	      int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ;		  on ‘int f_filled(int, int, int, int)’: SWAP_BITS_I
    set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 )		      	unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ;	      int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ;		  N_A_GIVEN_NUMBER.cpp:29:7: error: expected unquali
    xor = ( set1 ^ set2 )				      	unsigned int Xor = ( set1 ^ set2 ) ;			      int xor = ( set1 ^ set2 ) ;				  fied-id before ‘xor’ token	int xor = ( set1 ^ s
    xor = ( xor << p1 ) | ( xor << p2 )			      	Xor = ( Xor << p1 ) | ( Xor << p2 ) ;			      xor = ( xor << p1 ) | ( xor << p2 ) ;			  et2 ) ;	 ^~~ SWAP_BITS_IN_A_GIVEN_NUMBER.cpp
    result = x ^ xor					      	unsigned int result = x ^ Xor ;				      int result = x ^ xor ;					  :30:3: error: expected primary-expression before ‘
    return result					      	return result ;						      return result ;						  xor’ token	xor = ( xor << p1 ) | ( xor << p2 )
							      }								    }								  ;    ^~~ SWAP_BITS_IN_A_GIVEN_NUMBER.cpp:30:7: err
							      								    								  or: expected primary-expression before ‘=’ token
							      								    								    xor = ( xor << p1 ) | ( xor << p2 ) ;	 ^ S
							      								    								  WAP_BITS_IN_A_GIVEN_NUMBER.cpp:30:11: error: expec
							      								    								  ted primary-expression before ‘xor’ token    xor =
							      								    								   ( xor << p1 ) | ( xor << p2 ) ;	      ^~~ SW
							      								    								  AP_BITS_IN_A_GIVEN_NUMBER.cpp:30:15: error: expect
							      								    								  ed primary-expression before ‘<<’ token    xor = (
							      								    								   xor << p1 ) | ( xor << p2 ) ;		^~ S
							      								    								  WAP_BITS_IN_A_GIVEN_NUMBER.cpp:30:27: error: expec
							      								    								  ted primary-expression before ‘xor’ token    xor =
							      								    								   ( xor << p1 ) | ( xor << p2 ) ;
							      								    								  	    ^~~ SWAP_BITS_IN_A_GIVEN_NUMBER.cpp:30:3
							      								    								  1: error: expected primary-expression before ‘<<’
							      								    								  token	   xor = ( xor << p1 ) | ( xor << p2 ) ;
							      								    								  			      ^~ SWAP_BITS_IN_A_GIVE
							      								    								  N_NUMBER.cpp:31:20: error: expected primary-expres
							      								    								  sion before ‘xor’ token    int result = x ^ xor ;
							      								    								  		      ^~~ SWAP_BITS_IN_A_GIVEN_NUMBE
							      								    								  R.cpp:31:24: error: expected primary-expression be
							      								    								  fore ‘;’ token    int result = x ^ xor ;
							      								    								  		 ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS	      COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS	    COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS		  COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS
--							      --							    --								  --
def countPairs ( str1 ) :				      int countPairs ( string str ) {				    int countPairs ( string str1 ) {				  success : None
    result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
    n = len ( str1 )					      	int n = str . length ( ) ;				      int n = str1 . length ( ) ;				  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i < n ;							  
	    if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ]  	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
		result += 1 ;				      	j < n ;							    	for ( int j = i + 1 ;					  
    return result ;					      	j ++ ) if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j )  	j < n ;							  
							      	return result ;						    	j ++ ) {						  
							      }								    	  if ( ( abs ( str1 [ i ] - str1 [ j ] ) == abs ( i - j ) 
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N			      COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N			    COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N			  COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N
--							      --							    --								  --
def countOfBinaryNumberLessThanN ( N ) :		      int countOfBinaryNumberLessThanN ( int N ) {		    int countOfBinaryNumberLessThanN ( int N ) {		  error : COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N.cpp:
    q = deque ( )					      	queue < int > q ;					      priority_queue < int , int > q ;				  In function ‘int f_filled(int)’: COUNT_BINARY_DIGI
    q.append ( 1 )					      	q . push ( 1 ) ;					      q . push ( 1 ) ;						  T_NUMBERS_SMALLER_N.cpp:35:30: error: ‘int’ is not
    cnt = 0						      	int cnt = 0 ;						      int cnt = 0 ;						   a class, struct, or union type    priority_queue
    while ( q ) :					      	int t ;							      while ( ( q . size ( ) > 0 ) && ( q . top ( ) <= N ) ) {	  < int , int > q ;				  ^
	t = q.popleft ( )				      	while ( ! q . empty ( ) ) {				    	int t = q . top ( ) ;					  COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N.cpp:35:30: er
	if ( t <= N ) :					      	  t = q . front ( ) ;					    	if ( ( t <= N ) ) {					  ror: template argument 3 is invalid COUNT_BINARY_D
	    cnt = cnt + 1				      	  q . pop ( ) ;						    	  cnt = cnt + 1 ;					  IGIT_NUMBERS_SMALLER_N.cpp:36:7: error: request fo
	    q.append ( t * 10 )				      	  if ( t <= N ) {					    	  q . push ( t * 10 ) ;					  r member ‘push’ in ‘q’, which is of non-class type
	    q.append ( t * 10 + 1 )			      	    cnt ++ ;						    	  q . push ( t * 10 + 1 ) ;				   ‘int’    q . push ( 1 ) ;	    ^~~~ COUNT_BINAR
    return cnt						      	    q . push ( t * 10 ) ;				    	}							  Y_DIGIT_NUMBERS_SMALLER_N.cpp:38:17: error: reques
							      	    q . push ( t * 10 + 1 ) ;				      }								  t for member ‘size’ in ‘q’, which is of non-class
							      	  }							      return cnt ;						  type ‘int’	while ( ( q . size ( ) > 0 ) && ( q
							      	}							    }								  . top ( ) <= N ) ) {			^~~~ COUNT_B
							      	return cnt ;						    								  INARY_DIGIT_NUMBERS_SMALLER_N.cpp:38:41: error: re
							      }								    								  quest for member ‘top’ in ‘q’, which is of non-cla
							      								    								  ss type ‘int’	   while ( ( q . size ( ) > 0 ) && (
							      								    								   q . top ( ) <= N ) ) {
							      								    								  		 ^~~ COUNT_BINARY_DIGIT_NUMBERS_SMAL
							      								    								  LER_N.cpp:39:17: error: request for member ‘top’ i
							      								    								  n ‘q’, which is of non-class type ‘int’      int t
							      								    								   = q . top ( ) ;		    ^~~ COUNT_BINARY
							      								    								  _DIGIT_NUMBERS_SMALLER_N.cpp:42:11: error: request
							      								    								   for member ‘push’ in ‘q’, which is of non-class t
							      								    								  ype ‘int’	   q . push ( t * 10 ) ;
							      								    								  ^~~~ COUNT_BINARY_DIGIT_NUMBERS_SMALLER_N.cpp:43:1
							      								    								  1: error: request for member ‘push’ in ‘q’, which
							      								    								  is of non-class type ‘int’	    q . push ( t * 1
							      								    								  0 + 1 ) ;	       ^~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL	      MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL	    MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL		  MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL
--							      --							    --								  --
def minOps ( arr , n , k ) :				      int minOps ( int arr [ ] , int n , int k ) {		    int minOps ( int * arr , int n , int k ) {			  error : MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMEN
    max1 = max ( arr )					      	int max = * max_element ( arr , arr + n ) ;		      double max1 = max ( arr ) ;				  TS_EQUAL.cpp: In function ‘int f_filled(int*, int,
    res = 0						      	int res = 0 ;						      double res = 0 ;						   int)’: MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMEN
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  TS_EQUAL.cpp:30:27: error: no matching function fo
	if ( ( max1 - arr [ i ] ) % k != 0 ) :		      	i < n ;							      i <= n ;							  r call to ‘max(int*&)’    double max1 = max ( arr
	    return - 1					      	i ++ ) {						      i ++ ) {							  ) ;				 ^ In file included
	else :						      	  if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ;	    	if ( ( ( max1 - arr [ i ] ) % k != 0 ) ) return - 1 ;	  from /usr/include/c++/8/bits/char_traits.h:39,
	    res += ( max1 - arr [ i ] ) / k		      	  else res += ( max - arr [ i ] ) / k ;			    	else res += ( max1 - arr [ i ] ) / k ;			  		from /usr/include/c++/8/ios:40,
    return int ( res )					      	}							      }								  	       from /usr/include/c++/8/ostream:38,
							      	return res ;						      return ( int ) res ;					  		  from /usr/include/c++/8/iostream:3
							      }								    }								  9,		      from MINIMUM_INCREMENT_K_OPERA
							      								    								  TIONS_MAKE_ELEMENTS_EQUAL.cpp:8: /usr/include/c++/
							      								    								  8/bits/stl_algobase.h:219:5: note: candidate: ‘tem
							      								    								  plate<class _Tp> constexpr const _Tp& std::max(con
							      								    								  st _Tp&, const _Tp&)’	     max(const _Tp& __a, con
							      								    								  st _Tp& __b)	    ^~~ /usr/include/c++/8/bits/stl_
							      								    								  algobase.h:219:5: note:   template argument deduct
							      								    								  ion/substitution failed: MINIMUM_INCREMENT_K_OPERA
							      								    								  TIONS_MAKE_ELEMENTS_EQUAL.cpp:30:27: note:   candi
							      								    								  date expects 2 arguments, 1 provided	  double max
							      								    								  1 = max ( arr ) ;			       ^ In
							      								    								  file included from /usr/include/c++/8/bits/char_tr
							      								    								  aits.h:39,		      from /usr/include/c++/
							      								    								  8/ios:40,		     from /usr/include/c++/8
							      								    								  /ostream:38,			from /usr/include/c+
							      								    								  +/8/iostream:39,		    from MINIMUM_INC
							      								    								  REMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL.cpp:8: /us
							      								    								  r/include/c++/8/bits/stl_algobase.h:265:5: note: c
							      								    								  andidate: ‘template<class _Tp, class _Compare> con
							      								    								  stexpr const _Tp& std::max(const _Tp&, const _Tp&,
							      								    								   _Compare)’	   max(const _Tp& __a, const _Tp& __
							      								    								  b, _Compare __comp)	   ^~~ /usr/include/c++/8/bi
							      								    								  ts/stl_algobase.h:265:5: note:   template argument
							      								    								   deduction/substitution failed: MINIMUM_INCREMENT_
							      								    								  K_OPERATIONS_MAKE_ELEMENTS_EQUAL.cpp:30:27: note:
							      								    								    candidate expects 3 arguments, 1 provided	 dou
							      								    								  ble max1 = max ( arr ) ;
							      								    								    ^ In file included from /usr/include/c++/8/algor
							      								    								  ithm:62,		    from /usr/include/c++/8/
							      								    								  x86_64-redhat-linux/bits/stdc++.h:65,
							      								    								       from MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEM
							      								    								  ENTS_EQUAL.cpp:14: /usr/include/c++/8/bits/stl_alg
							      								    								  o.h:3462:5: note: candidate: ‘template<class _Tp>
							      								    								  constexpr _Tp std::max(std::initializer_list<_Tp>)
							      								    								  ’	 max(initializer_list<_Tp> __l)	     ^~~ /us
							      								    								  r/include/c++/8/bits/stl_algo.h:3462:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: MIN
							      								    								  IMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL.cp
							      								    								  p:30:27: note:   mismatched types ‘std::initialize
							      								    								  r_list<_Tp>’ and ‘int*’    double max1 = max ( arr
							      								    								   ) ;				  ^ In file included
							      								    								   from /usr/include/c++/8/algorithm:62,
							      								    								  	from /usr/include/c++/8/x86_64-redhat-linux/
							      								    								  bits/stdc++.h:65,		     from MINIMUM_IN
							      								    								  CREMENT_K_OPERATIONS_MAKE_ELEMENTS_EQUAL.cpp:14: /
							      								    								  usr/include/c++/8/bits/stl_algo.h:3468:5: note: ca
							      								    								  ndidate: ‘template<class _Tp, class _Compare> cons
							      								    								  texpr _Tp std::max(std::initializer_list<_Tp>, _Co
							      								    								  mpare)’      max(initializer_list<_Tp> __l, _Compa
							      								    								  re __comp)	  ^~~ /usr/include/c++/8/bits/stl_al
							      								    								  go.h:3468:5: note:   template argument deduction/s
							      								    								  ubstitution failed: MINIMUM_INCREMENT_K_OPERATIONS
							      								    								  _MAKE_ELEMENTS_EQUAL.cpp:30:27: note:	  mismatched
							      								    								   types ‘std::initializer_list<_Tp>’ and ‘int*’
							      								    								  double max1 = max ( arr ) ;
							      								    								       ^ MINIMUM_INCREMENT_K_OPERATIONS_MAKE_ELEMENT
							      								    								  S_EQUAL.cpp:35:33: error: invalid operands of type
							      								    								  s ‘double’ and ‘int’ to binary ‘operator%’	  if
							      								    								   ( ( ( max1 - arr [ i ] ) % k != 0 ) ) return - 1
							      								    								  ;		~~~~~~~~~~~~~~~~~~~~~^~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE   MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE   MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE	  MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE
--							      --							    --								  --
def findMinRooms ( slots , n , m ) :			      int findMinRooms ( string slots [ ] , int n , int m ) {	    int findMinRooms ( string * slots , int n , int m ) {	  error : MINIMUM_ROOMS_FOR_M_EVENTS_OF_N_BATCHES_WI
    counts = [ 0 ] * m					      	int counts [ m ] = {					      vector < int > counts ( m , 0 ) ;				  TH_GIVEN_SCHEDULE.cpp: In function ‘int f_filled(s
    for i in range ( n ) :				      	  0 }							      for ( int i = 0 ;						  td::__cxx11::string*, int, int)’: MINIMUM_ROOMS_FO
	for j in range ( m ) :				      	  ;							      i < n ;							  R_M_EVENTS_OF_N_BATCHES_WITH_GIVEN_SCHEDULE.cpp:39
	    if ( slots [ i ] [ j ] == '1' ) :		      	  for ( int i = 0 ;					      i ++ ) {							  :54: error: cannot convert ‘const __gnu_cxx::__nor
		counts [ j ] += 1			      	  i < n ;						    	for ( int j = 0 ;					  mal_iterator<int*, std::vector<int> >’ to ‘int’ in
    return max ( counts )				      	  i ++ ) for ( int j = 0 ;				    	j < m ;							   return    return max ( counts . begin ( ) , count
							      	  j < m ;						    	j ++ ) {						  s . end ( ) ) ;
							      	  j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ;  	  if ( ( slots [ i ] [ j ] == '1' ) ) counts [ j ] ++ ;	  		      ^
							      	  return * max_element ( counts , counts + m ) ;	    	}							  
							      	}							      }								  
							      								      return max ( counts . begin ( ) , counts . end ( ) ) ;	  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY		    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY
--							      --							    --								  --
def printRepeating ( arr , size ) :			      void printRepeating ( int arr [ ] , int size ) {		    int printRepeating ( int * arr , int size ) {		  script_not_found : None
    print ( "Repeating elements are " , end = '' )	      	int i , j ;						      cout << "Repeating elements are " << endl ;		  
    for i in range ( 0 , size ) :			      	printf ( " Repeating elements are " ) ;			      for ( int i = 0 ;						  
	for j in range ( i + 1 , size ) :		      	for ( i = 0 ;						      i < size ;						  
	    if arr [ i ] == arr [ j ] :			      	i < size ;						      i ++ ) {							  
		print ( arr [ i ] , end = ' ' )		      	i ++ ) for ( j = i + 1 ;				    	for ( int j = i + 1 ;					  
							      	j < size ;						    	j < size ;						  
							      	j ++ ) if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " 	j ++ ) {						  
							      }								    	  if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " "  
							      								    	}							  
							      								      }								  
							      								      return size ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1		      PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1		    PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1		  PRINT_DISTINCT_ELEMENTS_GIVEN_INTEGER_ARRAY_1
--							      --							    --								  --
def printDistinct ( arr , n ) :				      void printDistinct ( int arr [ ] , int n ) {		    int sumOfDigits ( string str ) {				  script_not_found : None
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      int sum = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) :     	i < n ;							      i < str . length ( ) ;					  
	    while ( i < n - 1 and ( arr [ i ] == arr [ i + 1  	i ++ ) {						      i ++ ) {							  
		i += 1					      	  while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ;  	char c = str [ i ] ;					  
	else :						      	  cout << arr [ i ] << " " ;				    	if ( c == '.' ) {					  
	    print ( arr [ i ] , end = " " )		      	}							    	  while ( ( i < str . length ( ) - 1 ) && ( c == '_' ) )  
							      }								    	    sum += c ;						  
							      								    	  }							  
							      								    	}							  
							      								    	else {							  
							      								    	  sum += c ;						  
							      								    	}							  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION    SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION    SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION	  SORT_3_INTEGERS_WITHOUT_USING_CONDITION_USING_MAX_FUNCTION
--							      --							    --								  --
def printSorted ( a , b , c ) :				      void printSorted ( int a , int b , int c ) {		    void printSorted ( int a , int b , int c ) {		  script_not_found : None
    get_max = max ( a , max ( b , c ) )			      	int get_max = max ( a , max ( b , c ) ) ;		      int getMax = max ( a , max ( b , c ) ) ;			  
    get_min = - max ( - a , max ( - b , - c ) )		      	int get_min = - max ( - a , max ( - b , - c ) ) ;	      int getMin = - max ( - a , max ( - b , - c ) ) ;		  
    get_mid = ( a + b + c ) - ( get_max + get_min )	      	int get_mid = ( a + b + c ) - ( get_max + get_min ) ;	      int getMid = ( a + b + c ) - ( getMax + getMin ) ;	  
    print ( get_min , " " , get_mid , " " , get_max )	      	cout << get_min << " " << get_mid << " " << get_max ;	      cout << getMin << " " << getMid << " " << getMax ( a , b ,  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I FIND_SQUARE_ROOT_UNDER_MODULO_P_SET_1_WHEN_P_IS_IN_FORM_OF_4I
--							      --							    --								  --
def squareRoot ( n , p ) :				      void squareRoot ( int n , int p ) {			    int squareRoot ( int n , int p ) {				  script_not_found : None
    n = n % p						      	n = n % p ;						      n = n % p ;						  
    for x in range ( 2 , p ) :				      	for ( int x = 2 ;					      for ( int x = 2 ;						  
	if ( ( x * x ) % p == n ) :			      	x < p ;							      x < p ;							  
	    print ( "Square root is " , x )		      	x ++ ) {						      x ++ ) {							  
	    return					      	  if ( ( x * x ) % p == n ) {				    	if ( ( ( x * x ) % p ) == n ) {				  
    print ( "Square root doesn't exist" )		      	    cout << "Square root is " << x ;			    	  cout << "Square root is " << x << endl ;		  
							      	    return ;						    	  return x ;						  
							      	  }							    	}							  
							      	}							      }								  
							      	cout << "Square root doesn't exist" ;			      cout << "Square root doesn't exist" << endl ;		  
							      }								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S			      REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S			    REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S			  REPLACE_CHARACTER_C1_C2_C2_C1_STRING_S
--							      --							    --								  --
def replace ( s , c1 , c2 ) :				      string replace ( string s , char c1 , char c2 ) {		    string replace ( string s , char c1 , char c2 ) {		  failure : #Results: 8, 10
    l = len ( s )					      	int l = s . length ( ) ;				      int l = s . length ( ) ;					  
    for i in range ( l ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( s [ i ] == c1 ) :				      	i < l ;							      i < l ;							  
	    s = s [ 0 : i ] + c2 + s [ i + 1 : ]	      	i ++ ) {						      i ++ ) {							  
	elif ( s [ i ] == c2 ) :			      	  if ( s [ i ] == c1 ) s [ i ] = c2 ;			    	if ( ( s [ i ] == c1 ) && ( s [ i + 1 ] == c2 ) ) s = s . 
	    s = s [ 0 : i ] + c1 + s [ i + 1 : ]	      	  else if ( s [ i ] == c2 ) s [ i ] = c1 ;		    	else if ( ( s [ i ] == c2 ) && ( s [ i + 1 ] == c1 ) ) s  
    return s						      	}							      }								  
							      	return s ;						      return s ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS		      MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS			    MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS			  MINIMUM_NUMBER_SUBSETS_DISTINCT_ELEMENTS
--							      --							    --								  --
def subset ( ar , n ) :					      int subset ( int ar [ ] , int n ) {			    int subset ( int * ar , int n ) {				  failure : #Results: 3, 10
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    ar.sort ( )						      	sort ( ar , ar + n ) ;					      sort ( ar , ar + n ) ;					  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	count = 1					      	i < n ;							      i < n ;							  
	for i in range ( n - 1 ) :			      	i ++ ) {						      i ++ ) {							  
	    if ar [ i ] == ar [ i + 1 ] :		      	  int count = 1 ;					    	int count = 1 ;						  
		count += 1				      	  for ( ;						    	for ( int j = 0 ;					  
	    else :					      	  i < n - 1 ;						    	j < n - 1 ;						  
		break					      	  i ++ ) {						    	j ++ ) {						  
	res = max ( res , count )			      	    if ( ar [ i ] == ar [ i + 1 ] ) count ++ ;		    	  if ( ar [ i ] == ar [ i + 1 ] ) count ++ ;		  
    return res						      	    else break ;					    	  else break ;						  
							      	  }							    	}							  
							      	  res = max ( res , count ) ;				    	res = max ( res , count ) ;				  
							      	}							      }								  
							      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND	      GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND	    GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND	  GIVEN_TWO_STRINGS_FIND_FIRST_STRING_SUBSEQUENCE_SECOND
--							      --							    --								  --
def isSubSequence ( string1 , string2 , m , n ) :	      bool isSubSequence ( char str1 [ ] , char str2 [ ] , int m ,  bool isSubSequence ( string string1 , string string2 , int m  success : None
    if m == 0 : return True				      	if ( m == 0 ) return true ;				      if ( m == 0 ) return true ;				  
    if n == 0 : return False				      	if ( n == 0 ) return false ;				      if ( n == 0 ) return false ;				  
    if string1 [ m - 1 ] == string2 [ n - 1 ] :		      	if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequenc   if ( string1 [ m - 1 ] == string2 [ n - 1 ] ) return isSubS 
	return isSubSequence ( string1 , string2 , m - 1 , n  	return isSubSequence ( str1 , str2 , m , n - 1 ) ;	      return isSubSequence ( string1 , string2 , m , n - 1 ) ;	  
    return isSubSequence ( string1 , string2 , m , n - 1 )    }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_THAT_APPEARS_ONCE			      FIND_THE_ELEMENT_THAT_APPEARS_ONCE			    FIND_THE_ELEMENT_THAT_APPEARS_ONCE				  FIND_THE_ELEMENT_THAT_APPEARS_ONCE
--							      --							    --								  --
def getSingle ( arr , n ) :				      int getSingle ( int arr [ ] , int n ) {			    int getSingle ( int * arr , int n ) {			  success : None
    ones = 0						      	int ones = 0 , twos = 0 ;				      int ones = 0 ;						  
    twos = 0						      	int common_bit_mask ;					      int twos = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	twos = twos | ( ones & arr [ i ] )		      	i < n ;							      i < n ;							  
	ones = ones ^ arr [ i ]				      	i ++ ) {						      i ++ ) {							  
	common_bit_mask = ~ ( ones & twos )		      	  twos = twos | ( ones & arr [ i ] ) ;			    	twos = twos | ( ones & arr [ i ] ) ;			  
	ones &= common_bit_mask				      	  ones = ones ^ arr [ i ] ;				    	ones = ones ^ arr [ i ] ;				  
	twos &= common_bit_mask				      	  common_bit_mask = ~ ( ones & twos ) ;			    	int commonBitMask = ~ ( ones & twos ) ;			  
    return ones						      	  ones &= common_bit_mask ;				    	ones &= commonBitMask ;					  
							      	  twos &= common_bit_mask ;				    	twos &= commonBitMask ;					  
							      	}							      }								  
							      	return ones ;						      return ones ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE		      ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE		    ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE		  ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE
--							      --							    --								  --
def solveQuery ( start , end , arr ) :			      int solveQuery ( int start , int end , int arr [ ] ) {	    int solveQuery ( int start , int end , int * arr ) {	  error : ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VAL
    frequency = dict ( )				      	unordered_map < int , int > frequency ;			      map < int , int > frequency ;				  UE.cpp: In function ‘int f_filled(int, int, int*)’
    for i in range ( start , end + 1 ) :		      	for ( int i = start ;					      for ( int i = start ;					  : ARRAY_RANGE_QUERIES_ELEMENTS_FREQUENCY_VALUE.cpp
	if arr [ i ] in frequency.keys ( ) :		      	i <= end ;						      i <= end ;						  :36:17: error: cannot convert ‘std::pair<const int
	    frequency [ arr [ i ] ] += 1		      	i ++ ) frequency [ arr [ i ] ] ++ ;			      i ++ ) {							  , int>’ to ‘int’ in initialization	for ( int x
	else :						      	int count = 0 ;						    	if ( frequency . count ( arr [ i ] ) ) frequency [ arr [  : frequency ) {		   ^~~~~~~~~
	    frequency [ arr [ i ] ] = 1			      	for ( auto x : frequency ) if ( x . first == x . second ) c 	else frequency [ arr [ i ] ] = 1 ;			  
    count = 0						      	return count ;						      }								  
    for x in frequency :				      }								      int count = 0 ;						  
	if x == frequency [ x ] :			      								      for ( int x : frequency ) {				  
	    count += 1					      								    	if ( x == frequency [ x ] ) count ++ ;			  
    return count					      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SINK_NODES_GRAPH					      NUMBER_SINK_NODES_GRAPH					    NUMBER_SINK_NODES_GRAPH					  NUMBER_SINK_NODES_GRAPH
--							      --							    --								  --
def countSink ( n , m , edgeFrom , edgeTo ) :		      int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo int countSink ( int n , int m , int * edgeFrom , int * edgeTo script_not_found : None
    mark = [ 0 ] * ( n + 1 )				      	int mark [ n ] ;					      vector < int > mark ( n + 1 , 0 ) ;			  
    for i in range ( m ) :				      	memset ( mark , 0 , sizeof mark ) ;			      for ( int i = 0 ;						  
	mark [ edgeFrom [ i ] ] = 1			      	for ( int i = 0 ;					      i < m ;							  
    count = 0						      	i < m ;							      i ++ ) mark [ edgeFrom [ i ] ] = 1 ;			  
    for i in range ( 1 , n + 1 ) :			      	i ++ ) mark [ edgeFrom [ i ] ] = 1 ;			      int count = 0 ;						  
	if ( not mark [ i ] ) :				      	int count = 0 ;						      for ( int i = 1 ;						  
	    count += 1					      	for ( int i = 1 ;					      i <= n ;							  
    return count					      	i <= n ;						      i ++ ) {							  
							      	i ++ ) if ( ! mark [ i ] ) count ++ ;			    	if ( ( ! mark [ i ] ) ) count ++ ;			  
							      	return count ;						      }								  
							      }								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS	      COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS		    COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS		  COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS
--							      --							    --								  --
def countWords ( stri , n ) :				      int countWords ( string str [ ] , int n ) {		    int countWords ( string stri , int n ) {			  error : COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY
    m = dict ( )					      	unordered_map < string , int > m ;			      map < string , int > m ;					  _WORDS.cpp: In function ‘int f_filled(std::__cxx11
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  ::string, int)’: COUNT_WORDS_APPEAR_EXACTLY_TWO_TI
	m [ stri [ i ] ] = m.get ( stri [ i ] , 0 ) + 1	      	i < n ;							      i < n ;							  MES_ARRAY_WORDS.cpp:33:12: error: no match for ‘op
    res = 0						      	i ++ ) m [ str [ i ] ] += 1 ;				      i ++ ) m [ stri [ i ] ] = m . count ( stri [ i ] ) + 1 ;	  erator[]’ (operand types are ‘std::map<std::__cxx1
    for i in m.values ( ) :				      	int res = 0 ;						      int res = 0 ;						  1::basic_string<char>, int>’ and ‘__gnu_cxx::__all
	if i == 2 :					      	for ( auto it = m . begin ( ) ;				      for ( int i = 0 ;						  oc_traits<std::allocator<char>, char>::value_type’
	    res += 1					      	it != m . end ( ) ;					      i < m . size ( ) ;					   {aka ‘char’})    i ++ ) m [ stri [ i ] ] = m . co
    return res						      	it ++ ) if ( ( it -> second == 2 ) ) res ++ ;		      i ++ ) if ( m [ stri [ i ] ] == 2 ) res ++ ;		  unt ( stri [ i ] ) + 1 ;	       ^ In file inc
							      	return res ;						      return res ;						  luded from /usr/include/c++/8/map:61,
							      }								    }								       from /usr/include/c++/8/x86_64-redhat-linux/b
							      								    								  its/stdc++.h:81,		    from COUNT_WORDS
							      								    								  _APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS.cpp:14: /usr
							      								    								  /include/c++/8/bits/stl_map.h:490:7: note: candida
							      								    								  te: ‘std::map<_Key, _Tp, _Compare, _Alloc>::mapped
							      								    								  _type& std::map<_Key, _Tp, _Compare, _Alloc>::oper
							      								    								  ator[](const key_type&) [with _Key = std::__cxx11:
							      								    								  :basic_string<char>; _Tp = int; _Compare = std::le
							      								    								  ss<std::__cxx11::basic_string<char> >; _Alloc = st
							      								    								  d::allocator<std::pair<const std::__cxx11::basic_s
							      								    								  tring<char>, int> >; std::map<_Key, _Tp, _Compare,
							      								    								   _Alloc>::mapped_type = int; std::map<_Key, _Tp, _
							      								    								  Compare, _Alloc>::key_type = std::__cxx11::basic_s
							      								    								  tring<char>]’	       operator[](const key_type& __
							      								    								  k)	    ^~~~~~~~ /usr/include/c++/8/bits/stl_map
							      								    								  .h:490:7: note:   no known conversion for argument
							      								    								   1 from ‘__gnu_cxx::__alloc_traits<std::allocator<
							      								    								  char>, char>::value_type’ {aka ‘char’} to ‘const k
							      								    								  ey_type&’ {aka ‘const std::__cxx11::basic_string<c
							      								    								  har>&’} /usr/include/c++/8/bits/stl_map.h:510:7: n
							      								    								  ote: candidate: ‘std::map<_Key, _Tp, _Compare, _Al
							      								    								  loc>::mapped_type& std::map<_Key, _Tp, _Compare, _
							      								    								  Alloc>::operator[](std::map<_Key, _Tp, _Compare, _
							      								    								  Alloc>::key_type&&) [with _Key = std::__cxx11::bas
							      								    								  ic_string<char>; _Tp = int; _Compare = std::less<s
							      								    								  td::__cxx11::basic_string<char> >; _Alloc = std::a
							      								    								  llocator<std::pair<const std::__cxx11::basic_strin
							      								    								  g<char>, int> >; std::map<_Key, _Tp, _Compare, _Al
							      								    								  loc>::mapped_type = int; std::map<_Key, _Tp, _Comp
							      								    								  are, _Alloc>::key_type = std::__cxx11::basic_strin
							      								    								  g<char>]’	   operator[](key_type&& __k)
							      								    								   ^~~~~~~~ /usr/include/c++/8/bits/stl_map.h:510:7:
							      								    								   note:   no known conversion for argument 1 from ‘
							      								    								  __gnu_cxx::__alloc_traits<std::allocator<char>, ch
							      								    								  ar>::value_type’ {aka ‘char’} to ‘std::map<std::__
							      								    								  cxx11::basic_string<char>, int>::key_type&&’ {aka
							      								    								  ‘std::__cxx11::basic_string<char>&&’} COUNT_WORDS_
							      								    								  APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS.cpp:33:52: er
							      								    								  ror: no matching function for call to ‘std::map<st
							      								    								  d::__cxx11::basic_string<char>, int>::count(__gnu_
							      								    								  cxx::__alloc_traits<std::allocator<char>, char>::v
							      								    								  alue_type&)’	  i ++ ) m [ stri [ i ] ] = m . coun
							      								    								  t ( stri [ i ] ) + 1 ;
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/map:61,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :81,			from COUNT_WORDS_APPEAR_EXAC
							      								    								  TLY_TWO_TIMES_ARRAY_WORDS.cpp:14: /usr/include/c++
							      								    								  /8/bits/stl_map.h:1214:7: note: candidate: ‘std::m
							      								    								  ap<_Key, _Tp, _Compare, _Alloc>::size_type std::ma
							      								    								  p<_Key, _Tp, _Compare, _Alloc>::count(const key_ty
							      								    								  pe&) const [with _Key = std::__cxx11::basic_string
							      								    								  <char>; _Tp = int; _Compare = std::less<std::__cxx
							      								    								  11::basic_string<char> >; _Alloc = std::allocator<
							      								    								  std::pair<const std::__cxx11::basic_string<char>,
							      								    								  int> >; std::map<_Key, _Tp, _Compare, _Alloc>::siz
							      								    								  e_type = long unsigned int; std::map<_Key, _Tp, _C
							      								    								  ompare, _Alloc>::key_type = std::__cxx11::basic_st
							      								    								  ring<char>]’	      count(const key_type& __x) con
							      								    								  st	    ^~~~~ /usr/include/c++/8/bits/stl_map.h:
							      								    								  1214:7: note:	  no known conversion for argument 1
							      								    								   from ‘__gnu_cxx::__alloc_traits<std::allocator<ch
							      								    								  ar>, char>::value_type’ {aka ‘char’} to ‘const key
							      								    								  _type&’ {aka ‘const std::__cxx11::basic_string<cha
							      								    								  r>&’} /usr/include/c++/8/bits/stl_map.h:1220:2: no
							      								    								  te: candidate: ‘template<class _Kt> decltype (((co
							      								    								  nst std::map<_Key, _Tp, _Compare, _Alloc>*)this)->
							      								    								  std::map<_Key, _Tp, _Compare, _Alloc>::_M_t._M_cou
							      								    								  nt_tr(__x)) std::map<_Key, _Tp, _Compare, _Alloc>:
							      								    								  :count(const _Kt&) const [with _Kt = _Kt; _Key = s
							      								    								  td::__cxx11::basic_string<char>; _Tp = int; _Compa
							      								    								  re = std::less<std::__cxx11::basic_string<char> >;
							      								    								   _Alloc = std::allocator<std::pair<const std::__cx
							      								    								  x11::basic_string<char>, int> >]’   count(const _K
							      								    								  t& __x) const -> decltype(_M_t._M_count_tr(__x))
							      								    								   ^~~~~ /usr/include/c++/8/bits/stl_map.h:1220:2: n
							      								    								  ote:	 template argument deduction/substitution fa
							      								    								  iled: /usr/include/c++/8/bits/stl_map.h: In substi
							      								    								  tution of ‘template<class _Kt> decltype (((const s
							      								    								  td::map<std::__cxx11::basic_string<char>, int>*)th
							      								    								  is)->std::map<std::__cxx11::basic_string<char>, in
							      								    								  t>::_M_t.std::_Rb_tree<std::__cxx11::basic_string<
							      								    								  char>, std::pair<const std::__cxx11::basic_string<
							      								    								  char>, int>, std::_Select1st<std::pair<const std::
							      								    								  __cxx11::basic_string<char>, int> >, std::less<std
							      								    								  ::__cxx11::basic_string<char> >, std::allocator<st
							      								    								  d::pair<const std::__cxx11::basic_string<char>, in
							      								    								  t> > >::_M_count_tr<_Kt, _Req>(__x)) std::map<std:
							      								    								  :__cxx11::basic_string<char>, int>::count<_Kt>(con
							      								    								  st _Kt&) const [with _Kt = char]’: COUNT_WORDS_APP
							      								    								  EAR_EXACTLY_TWO_TIMES_ARRAY_WORDS.cpp:33:52:	 req
							      								    								  uired from here /usr/include/c++/8/bits/stl_map.h:
							      								    								  1220:2: error: no matching function for call to ‘s
							      								    								  td::_Rb_tree<std::__cxx11::basic_string<char>, std
							      								    								  ::pair<const std::__cxx11::basic_string<char>, int
							      								    								  >, std::_Select1st<std::pair<const std::__cxx11::b
							      								    								  asic_string<char>, int> >, std::less<std::__cxx11:
							      								    								  :basic_string<char> >, std::allocator<std::pair<co
							      								    								  nst std::__cxx11::basic_string<char>, int> > >::_M
							      								    								  _count_tr(const char&) const’ In file included fro
							      								    								  m /usr/include/c++/8/map:60,			from
							      								    								   /usr/include/c++/8/x86_64-redhat-linux/bits/stdc+
							      								    								  +.h:81,		   from COUNT_WORDS_APPEAR_E
							      								    								  XACTLY_TWO_TIMES_ARRAY_WORDS.cpp:14: /usr/include/
							      								    								  c++/8/bits/stl_tree.h:1257:2: note: candidate: ‘te
							      								    								  mplate<class _Kt, class _Req> std::_Rb_tree<_Key,
							      								    								  _Val, _KeyOfValue, _Compare, _Alloc>::size_type st
							      								    								  d::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Al
							      								    								  loc>::_M_count_tr(const _Kt&) const [with _Kt = _K
							      								    								  t; _Req = _Req; _Key = std::__cxx11::basic_string<
							      								    								  char>; _Val = std::pair<const std::__cxx11::basic_
							      								    								  string<char>, int>; _KeyOfValue = std::_Select1st<
							      								    								  std::pair<const std::__cxx11::basic_string<char>,
							      								    								  int> >; _Compare = std::less<std::__cxx11::basic_s
							      								    								  tring<char> >; _Alloc = std::allocator<std::pair<c
							      								    								  onst std::__cxx11::basic_string<char>, int> >]’
							      								    								  _M_count_tr(const _Kt& __k) const   ^~~~~~~~~~~ /u
							      								    								  sr/include/c++/8/bits/stl_tree.h:1257:2: note:   t
							      								    								  emplate argument deduction/substitution failed: /u
							      								    								  sr/include/c++/8/bits/stl_tree.h:1254:9: error: no
							      								    								   type named ‘type’ in ‘struct std::__has_is_transp
							      								    								  arent<std::less<std::__cxx11::basic_string<char> >
							      								    								  , char, void>’	  typename _Req =	   ^
							      								    								  ~~~~~~~ COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY
							      								    								  _WORDS.cpp:37:17: error: no match for ‘operator[]’
							      								    								   (operand types are ‘std::map<std::__cxx11::basic_
							      								    								  string<char>, int>’ and ‘__gnu_cxx::__alloc_traits
							      								    								  <std::allocator<char>, char>::value_type’ {aka ‘ch
							      								    								  ar’})	   i ++ ) if ( m [ stri [ i ] ] == 2 ) res +
							      								    								  + ;		       ^ In file included from /usr/
							      								    								  include/c++/8/map:61,			 from /usr/i
							      								    								  nclude/c++/8/x86_64-redhat-linux/bits/stdc++.h:81,
							      								    								  		    from COUNT_WORDS_APPEAR_EXACTLY_
							      								    								  TWO_TIMES_ARRAY_WORDS.cpp:14: /usr/include/c++/8/b
							      								    								  its/stl_map.h:490:7: note: candidate: ‘std::map<_K
							      								    								  ey, _Tp, _Compare, _Alloc>::mapped_type& std::map<
							      								    								  _Key, _Tp, _Compare, _Alloc>::operator[](const key
							      								    								  _type&) [with _Key = std::__cxx11::basic_string<ch
							      								    								  ar>; _Tp = int; _Compare = std::less<std::__cxx11:
							      								    								  :basic_string<char> >; _Alloc = std::allocator<std
							      								    								  ::pair<const std::__cxx11::basic_string<char>, int
							      								    								  > >; std::map<_Key, _Tp, _Compare, _Alloc>::mapped
							      								    								  _type = int; std::map<_Key, _Tp, _Compare, _Alloc>
							      								    								  ::key_type = std::__cxx11::basic_string<char>]’
							      								    								       operator[](const key_type& __k)	      ^~~~~~
							      								    								  ~~ /usr/include/c++/8/bits/stl_map.h:490:7: note:
							      								    								    no known conversion for argument 1 from ‘__gnu_c
							      								    								  xx::__alloc_traits<std::allocator<char>, char>::va
							      								    								  lue_type’ {aka ‘char’} to ‘const key_type&’ {aka ‘
							      								    								  const std::__cxx11::basic_string<char>&’} /usr/inc
							      								    								  lude/c++/8/bits/stl_map.h:510:7: note: candidate:
							      								    								  ‘std::map<_Key, _Tp, _Compare, _Alloc>::mapped_typ
							      								    								  e& std::map<_Key, _Tp, _Compare, _Alloc>::operator
							      								    								  [](std::map<_Key, _Tp, _Compare, _Alloc>::key_type
							      								    								  &&) [with _Key = std::__cxx11::basic_string<char>;
							      								    								   _Tp = int; _Compare = std::less<std::__cxx11::bas
							      								    								  ic_string<char> >; _Alloc = std::allocator<std::pa
							      								    								  ir<const std::__cxx11::basic_string<char>, int> >;
							      								    								   std::map<_Key, _Tp, _Compare, _Alloc>::mapped_typ
							      								    								  e = int; std::map<_Key, _Tp, _Compare, _Alloc>::ke
							      								    								  y_type = std::__cxx11::basic_string<char>]’
							      								    								   operator[](key_type&& __k)	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/stl_map.h:510:7: note:   no know
							      								    								  n conversion for argument 1 from ‘__gnu_cxx::__all
							      								    								  oc_traits<std::allocator<char>, char>::value_type’
							      								    								   {aka ‘char’} to ‘std::map<std::__cxx11::basic_str
							      								    								  ing<char>, int>::key_type&&’ {aka ‘std::__cxx11::b
							      								    								  asic_string<char>&&’} COUNT_WORDS_APPEAR_EXACTLY_T
							      								    								  WO_TIMES_ARRAY_WORDS.cpp: In function ‘int main()’
							      								    								  : COUNT_WORDS_APPEAR_EXACTLY_TWO_TIMES_ARRAY_WORDS
							      								    								  .cpp:58:21: error: could not convert ‘&(& param0.s
							      								    								  td::vector<std::vector<std::__cxx11::basic_string<
							      								    								  char> > >::operator[](((std::vector<std::vector<st
							      								    								  d::__cxx11::basic_string<char> > >::size_type)i)))
							      								    								  ->std::vector<std::__cxx11::basic_string<char> >::
							      								    								  front()’ from ‘__gnu_cxx::__alloc_traits<std::allo
							      								    								  cator<std::__cxx11::basic_string<char> >, std::__c
							      								    								  xx11::basic_string<char> >::value_type*’ {aka ‘std
							      								    								  ::__cxx11::basic_string<char>*’} to ‘std::__cxx11:
							      								    								  :string’ {aka ‘std::__cxx11::basic_string<char>’}
							      								    								  	   if(f_filled(&param0[i].front(),param1[i])
							      								    								   == f_gold(&param0[i].front(),param1[i]))
							      								    								  	       ^~~~~~~~~~~~~~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CAESAR_CIPHER						      CAESAR_CIPHER						    CAESAR_CIPHER						  CAESAR_CIPHER
--							      --							    --								  --
def encrypt ( text , s ) :				      string encrypt ( string text , int s ) {			    string encrypt ( string text , int s ) {			  success : None
    result = ""						      	string result = "" ;					      string result ;						  
    for i in range ( len ( text ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	char = text [ i ]				      	i < text . length ( ) ;					      i < text . length ( ) ;					  
	if ( char.isupper ( ) ) :			      	i ++ ) {						      i ++ ) {							  
	    result += chr ( ( ord ( char ) + s - 65 ) % 26 +  	  if ( isupper ( text [ i ] ) ) result += char ( int ( text 	char c = text [ i ] ;					  
	else :						      	  else result += char ( int ( text [ i ] + s - 97 ) % 26 +  	if ( isupper ( c ) ) result += ( char ) ( ( ( c + s - 65  
	    result += chr ( ( ord ( char ) + s - 97 ) % 26 +  	}							    	else result += ( char ) ( ( ( c + s - 97 ) % 26 + 97 ) )  
    return result					      	return result ;						      }								  
							      }								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1		      FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1		    FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1		  FIND_ELEMENTS_PRESENT_FIRST_ARRAY_NOT_SECOND_1
--							      --							    --								  --
def findMissing ( a , b , n , m ) :			      void findMissing ( int a [ ] , int b [ ] , int n , int m ) {  int findMissing ( string a , string b , int n , int m ) {	  script_not_found : None
    s = dict ( )					      	unordered_set < int > s ;				      map < int , int > s ;					  
    for i in range ( m ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	s [ b [ i ] ] = 1				      	i < m ;							      i < m ;							  
    for i in range ( n ) :				      	i ++ ) s . insert ( b [ i ] ) ;				      i ++ ) s [ b [ i ] ] = 1 ;				  
	if a [ i ] not in s.keys ( ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    print ( a [ i ] , end = " " )		      	i < n ;							      i < n ;							  
							      	i ++ ) if ( s . find ( a [ i ] ) == s . end ( ) ) cout << a   i ++ ) if ( a [ i ] != b [ i ] ) cout << a [ i ] << " " ;	  
							      }								      return 0 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY		      MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY		    MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY		  MAXIMUM_DISTANCE_TWO_OCCURRENCES_ELEMENT_ARRAY
--							      --							    --								  --
def maxDistance ( arr , n ) :				      int maxDistance ( int arr [ ] , int n ) {			    int maxDistance ( int * arr , int n ) {			  failure : #Results: 5, 10
    mp = { }						      	unordered_map < int , int > mp ;			      map < int , int > mp ;					  
    maxDict = 0						      	int max_dist = 0 ;					      int maxDict = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if arr [ i ] not in mp.keys ( ) :		      	i < n ;							      i < n ;							  
	    mp [ arr [ i ] ] = i			      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ 	if ( arr [ i ] != 0 ) mp [ arr [ i ] ] = i ;		  
	    maxDict = max ( maxDict , i - mp [ arr [ i ] ] )  	  else max_dist = max ( max_dist , i - mp [ arr [ i ] ] ) ; 	else maxDict = max ( maxDict , i - mp [ arr [ i ] ] ) ;	  
    return maxDict					      	}							      }								  
							      	return max_dist ;					      return maxDict ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX	      COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX	    COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX	  COUNT_ZEROS_IN_A_ROW_WISE_AND_COLUMN_WISE_SORTED_MATRIX
--							      --							    --								  --
def countZeroes ( mat ) :				      int countZeroes ( int mat [ N ] [ N ] ) {			    int countZeroes ( int * * mat ) {				  script_not_found : None
    N = 5 ;						      	int row = N - 1 , col = 0 ;				      int N = 5 ;						  
    row = N - 1 ;					      	int count = 0 ;						      int row = N - 1 ;						  
    col = 0 ;						      	while ( col < N ) {					      int col = 0 ;						  
    count = 0 ;						      	  while ( mat [ row ] [ col ] ) if ( -- row < 0 ) return co   int count = 0 ;						  
    while ( col < N ) :					      	  count += ( row + 1 ) ;				      while ( ( col < N ) ) {					  
	while ( mat [ row ] [ col ] ) :			      	  col ++ ;						    	while ( ( mat [ row ] [ col ] ) ) {			  
	    if ( row < 0 ) :				      	}							    	  if ( ( row < 0 ) ) return count ;			  
		return count ;				      	return count ;						    	  row = row - 1 ;					  
	    row = row - 1 ;				      }								    	}							  
	count = count + ( row + 1 ) ;			      								    	count = count + ( row + 1 ) ;				  
	col = col + 1 ;					      								    	col = col + 1 ;						  
    return count ;					      								      }								  
							      								      return count ;						  
							      								      return N * N ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_NEXT_STRING				      LEXICOGRAPHICALLY_NEXT_STRING				    LEXICOGRAPHICALLY_NEXT_STRING				  LEXICOGRAPHICALLY_NEXT_STRING
--							      --							    --								  --
def nextWord ( s ) :					      string nextWord ( string s ) {				    string nextWord ( string s ) {				  error : LEXICOGRAPHICALLY_NEXT_STRING.cpp: In func
    if ( s == " " ) :					      	if ( s == "" ) return "a" ;				      if ( ( s == " " ) || ( s == " a " ) ) return "a" ;	  tion ‘std::__cxx11::string f_filled(std::__cxx11::
	return "a"					      	int i = s . length ( ) - 1 ;				      int i = s . length ( ) - 1 ;				  string)’: LEXICOGRAPHICALLY_NEXT_STRING.cpp:31:62:
    i = len ( s ) - 1					      	while ( s [ i ] == 'z' && i >= 0 ) i -- ;		      while ( ( s [ i ] == 'z' ) && i >= 0 ) i -- ;		   error: invalid conversion from ‘__gnu_cxx::__allo
    while ( s [ i ] == 'z' and i >= 0 ) :		      	if ( i == - 1 ) s = s + 'a' ;				      if ( ( i == - 1 ) ) s = s + "a" ;				  c_traits<std::allocator<char>, char>::value_type’
	i -= 1						      	else s [ i ] ++ ;					      else s = s . find ( s [ i ] , ( char ) ( s [ i ] + 1 ) , 1  {aka ‘char’} to ‘const char*’ [-fpermissive]	  el
    if ( i == - 1 ) :					      	return s ;						      return s ;						  se s = s . find ( s [ i ] , ( char ) ( s [ i ] + 1
	s = s + 'a'					      }								    }								   ) , 1 ) ;
    else :						      								    								  			 ^ In file included from /us
	s = s.replace ( s [ i ] , chr ( ord ( s [ i ] ) + 1 ) 								    								  r/include/c++/8/string:52,		      from /
    return s						      								    								  usr/include/c++/8/bits/locale_classes.h:40,
							      								    								  	     from /usr/include/c++/8/bits/ios_base.h
							      								    								  :41,			from /usr/include/c++/8/ios:
							      								    								  42,		       from /usr/include/c++/8/ostre
							      								    								  am:38,		  from /usr/include/c++/8/io
							      								    								  stream:39,		      from LEXICOGRAPHICALLY
							      								    								  _NEXT_STRING.cpp:8: /usr/include/c++/8/bits/basic_
							      								    								  string.h:2337:26: note:   initializing argument 1
							      								    								  of ‘std::__cxx11::basic_string<_CharT, _Traits, _A
							      								    								  lloc>::size_type std::__cxx11::basic_string<_CharT
							      								    								  , _Traits, _Alloc>::find(const _CharT*, std::__cxx
							      								    								  11::basic_string<_CharT, _Traits, _Alloc>::size_ty
							      								    								  pe, std::__cxx11::basic_string<_CharT, _Traits, _A
							      								    								  lloc>::size_type) const [with _CharT = char; _Trai
							      								    								  ts = std::char_traits<char>; _Alloc = std::allocat
							      								    								  or<char>; std::__cxx11::basic_string<_CharT, _Trai
							      								    								  ts, _Alloc>::size_type = long unsigned int]’
							      								    								    find(const _CharT* __s, size_type __pos, size_ty
							      								    								  pe __n) const		    ~~~~~~~~~~~~~~^~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B		      FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B		    FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B		  FIND_LAST_DIGIT_FACTORIAL_DIVIDES_FACTORIAL_B
--							      --							    --								  --
def computeLastDigit ( A , B ) :			      int computeLastDigit ( long long int A , long long int B ) {  int computeLastDigit ( int A , int B ) {			  success : None
    variable = 1					      	int variable = 1 ;					      int variable = 1 ;					  
    if ( A == B ) :					      	if ( A == B ) return 1 ;				      if ( ( A == B ) ) return 1 ;				  
	return 1					      	else if ( ( B - A ) >= 5 ) return 0 ;			      else if ( ( ( B - A ) >= 5 ) ) return 0 ;			  
    elif ( ( B - A ) >= 5 ) :				      	else {							      else {							  
	return 0					      	  for ( long long int i = A + 1 ;			    	for ( int i = A + 1 ;					  
    else :						      	  i <= B ;						    	i <= B ;						  
	for i in range ( A + 1 , B + 1 ) :		      	  i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ;	    	i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ;	  
	    variable = ( variable * ( i % 10 ) ) % 10	      	  return variable % 10 ;				    	return variable % 10 ;					  
	return variable % 10				      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS    REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS    REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS	  REPRESENT_NUMBER_SUM_MINIMUM_POSSIBLE_PSUEDOBINARY_NUMBERS
--							      --							    --								  --
def psuedoBinary ( n ) :				      void psuedoBinary ( int n ) {				    int psuedoBinary ( int n ) {				  script_not_found : None
    while ( n > 0 ) :					      	while ( n > 0 ) {					      while ( ( n > 0 ) ) {					  
	temp = n					      	  int temp = n , m = 0 , p = 1 ;			    	int temp = n ;						  
	m = 0						      	  while ( temp ) {					    	int m = 0 ;						  
	p = 1						      	    int rem = temp % 10 ;				    	int p = 1 ;						  
	while ( temp ) :				      	    temp = temp / 10 ;					    	while ( ( temp ) ) {					  
	    rem = temp % 10				      	    if ( rem != 0 ) m += p ;				    	  int rem = temp % 10 ;					  
	    temp = int ( temp / 10 )			      	    p *= 10 ;						    	  temp = ( int ) ( temp / 10 ) ;			  
	    if ( rem != 0 ) :				      	  }							    	  if ( ( rem != 0 ) ) m += p ;				  
		m += p					      	  cout << m << " " ;					    	  p *= 10 ;						  
	    p *= 10					      	  n = n - m ;						    	}							  
	print ( m , end = " " )				      	}							    	cout << m << " " ;					  
	n = n - m					      }								    	n = n - m ;						  
							      								      }								  
							      								      return n ;						  
-							      -								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_4_NOT
--							      --							    --								  --
def check ( st ) :					      bool check ( string str ) {				    bool check ( string st ) {					  success : None
    n = len ( st )					      	int n = str . length ( ) ;				      int n = st . length ( ) ;					  
    if ( n == 0 ) :					      	if ( n == 0 ) return false ;				      if ( ( n == 0 ) ) return false ;				  
	return False					      	if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 4 == 0 ) ;	      if ( ( n == 1 ) ) return ( ( st [ 0 ] - '0' ) % 4 == 0 ) ;  
    if ( n == 1 ) :					      	int last = str [ n - 1 ] - '0' ;			      int last = ( int ) ( st [ n - 1 ] ) ;			  
	return ( ( st [ 0 ] - '0' ) % 4 == 0 )		      	int second_last = str [ n - 2 ] - '0' ;			      int secondLast = ( int ) ( st [ n - 2 ] ) ;		  
    last = ( int ) ( st [ n - 1 ] )			      	return ( ( second_last * 10 + last ) % 4 == 0 ) ;	      return ( ( secondLast * 10 + last ) % 4 == 0 ) ;		  
    second_last = ( int ) ( st [ n - 2 ] )		      }								    }								  
    return ( ( second_last * 10 + last ) % 4 == 0 )	      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES		      PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES		    PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES			  PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES
--							      --							    --								  --
def fib ( n ) :						      void fib ( int n ) {					    int fib ( int n ) {						  script_not_found : None
    a = 0						      	int a = 0 , b = 1 , c ;					      int a = 0 ;						  
    b = 1						      	if ( n >= 0 ) cout << a << " " ;			      int b = 1 ;						  
    if ( n >= 0 ) :					      	if ( n >= 1 ) cout << b << " " ;			      if ( ( n >= 0 ) && ( n <= 1 ) ) cout << a << " " ;	  
	print ( a , end = ' ' )				      	for ( int i = 2 ;					      if ( ( n >= 1 ) && ( n <= 2 ) ) cout << b << " " ;	  
    if ( n >= 1 ) :					      	i <= n ;						      for ( int i = 2 ;						  
	print ( b , end = ' ' )				      	i ++ ) {						      i <= n ;							  
    for i in range ( 2 , n + 1 ) :			      	  c = a + b ;						      i ++ ) {							  
	c = a + b					      	  cout << c << " " ;					    	int c = a + b ;						  
	print ( c , end = ' ' )				      	  a = b ;						    	cout << c << " " ;					  
	a = b						      	  b = c ;						    	a = b ;							  
	b = c						      	}							    	b = c ;							  
							      }								      }								  
							      								      return a ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE SUBARRAYSUBSTRING_VS_SUBSEQUENCE_AND_PROGRAMS_TO_GENERATE_THE
--							      --							    --								  --
def printSubsequences ( arr , n ) :			      void printSubsequences ( int arr [ ] , int n ) {		    void printSubsequences ( int * arr , int n ) {		  script_not_found : None
    opsize = math.pow ( 2 , n )				      	unsigned int opsize = pow ( 2 , n ) ;			      double opsize = pow ( 2 , n ) ;				  
    for counter in range ( 1 , ( int ) ( opsize ) ) :	      	for ( int counter = 1 ;					      for ( int counter = 1 ;					  
	for j in range ( 0 , n ) :			      	counter < opsize ;					      counter < ( int ) ( opsize ) ;				  
	    if ( counter & ( 1 << j ) ) :		      	counter ++ ) {						      counter ++ ) {						  
		print ( arr [ j ] , end = " " )		      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	print ( )					      	  j < n ;						    	j <= n ;						  
							      	  j ++ ) {						    	j ++ ) {						  
							      	    if ( counter & ( 1 << j ) ) cout << arr [ j ] << " " ;  	  if ( ( counter & ( 1 << j ) ) != 0 ) cout << arr [ j ]  
							      	  }							    	}							  
							      	  cout << endl ;					    	cout << endl ;						  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FRIENDS_PAIRING_PROBLEM_1				      FRIENDS_PAIRING_PROBLEM_1					    FRIENDS_PAIRING_PROBLEM_1					  FRIENDS_PAIRING_PROBLEM_1
--							      --							    --								  --
def countFriendsPairings ( n ) :			      int countFriendsPairings ( int n ) {			    int countFriendsPairings ( int n ) {			  script_not_found : None
    dp = [ - 1 ] * 100					      	if ( dp [ n ] != - 1 ) return dp [ n ] ;		      int dp [ 100 ] ;						  
    if ( dp [ n ] != - 1 ) :				      	if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1   memset ( dp , - 1 , sizeof ( dp ) ) ;			  
	return dp [ n ]					      	else return dp [ n ] = n ;				      if ( ( dp [ n ] != - 1 ) ) return dp [ n ] ;		  
    if ( n > 2 ) :					      }								      if ( ( n > 2 ) ) {					  
	dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 								    	dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * 
	return dp [ n ]					      								    	return dp [ n ] ;					  
    else :						      								      }								  
	dp [ n ] = n					      								      else {							  
	return dp [ n ]					      								    	dp [ n ] = n ;						  
							      								    	return dp [ n ] ;					  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK			      MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK			    MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK			  MINIMUM_ROTATIONS_UNLOCK_CIRCULAR_LOCK
--							      --							    --								  --
def minRotation ( input , unlock_code ) :		      int minRotation ( int input , int unlock_code ) {		    int minRotation ( int input , int unlockCode ) {		  success : None
    rotation = 0					      	int rotation = 0 ;					      int rotation = 0 ;					  
    while ( input > 0 or unlock_code > 0 ) :		      	int input_digit , code_digit ;				      while ( ( input > 0 ) || ( unlockCode > 0 ) ) {		  
	input_digit = input % 10			      	while ( input || unlock_code ) {			    	int inputDigit = input % 10 ;				  
	code_digit = unlock_code % 10			      	  input_digit = input % 10 ;				    	int codeDigit = unlockCode % 10 ;			  
	rotation += min ( abs ( input_digit - code_digit ) ,  	  code_digit = unlock_code % 10 ;			    	rotation += min < int > ( abs ( inputDigit - codeDigit )  
	input = int ( input / 10 )			      	  rotation += min ( abs ( input_digit - code_digit ) , 10 - 	input = ( int ) ( input / 10 ) ;			  
	unlock_code = int ( unlock_code / 10 )		      	  input /= 10 ;						    	unlockCode = ( int ) ( unlockCode / 10 ) ;		  
    return rotation					      	  unlock_code /= 10 ;					      }								  
							      	}							      return rotation ;						  
							      	return rotation ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_GREATER_ELEMENT					      NEXT_GREATER_ELEMENT					    NEXT_GREATER_ELEMENT					  NEXT_GREATER_ELEMENT
--							      --							    --								  --
def printNGE ( arr ) :					      void printNGE ( int arr [ ] , int n ) {			    int printNGE ( int * arr ) {				  script_not_found : None
    for i in range ( 0 , len ( arr ) , 1 ) :		      	int next , i , j ;					      for ( int i = 0 ;						  
	next = - 1					      	for ( i = 0 ;						      i < sizeof ( arr ) / sizeof ( int ) ;			  
	for j in range ( i + 1 , len ( arr ) , 1 ) :	      	i < n ;							      i += 1 ) {						  
	    if arr [ i ] < arr [ j ] :			      	i ++ ) {						    	int next = - 1 ;					  
		next = arr [ j ]			      	  next = - 1 ;						    	for ( int j = i + 1 ;					  
		break					      	  for ( j = i + 1 ;					    	j < sizeof ( arr ) / sizeof ( int ) ;			  
	print ( str ( arr [ i ] ) + " -- " + str ( next ) )   	  j < n ;						    	j += 1 ) {						  
							      	  j ++ ) {						    	  if ( arr [ i ] < arr [ j ] ) {			  
							      	    if ( arr [ i ] < arr [ j ] ) {			    	    next = arr [ j ] ;					  
							      	      next = arr [ j ] ;				    	    break ;						  
							      	      break ;						    	  }							  
							      	    }							    	}							  
							      	  }							    	cout << arr [ i ] << " -- " << next << endl ;		  
							      	  cout << arr [ i ] << " -- " << next << endl ;		      }								  
							      	}							      return 0 ;						  
							      }								      return arr * arr * arr * arr * arr * arr * arr * arr * arr  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING	      CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING	    CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING	  CALCULATE_MAXIMUM_VALUE_USING_SIGN_TWO_NUMBERS_STRING
--							      --							    --								  --
def calcMaxValue ( str ) :				      int calcMaxValue ( string str ) {				    int calcMaxValue ( string str ) {				  success : None
    res = ord ( str [ 0 ] ) - 48			      	int res = str [ 0 ] - '0' ;				      int res = ( int ) str [ 0 ] - 48 ;			  
    for i in range ( 1 , len ( str ) ) :		      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	if ( str [ i ] == '0' or str [ i ] == '1' or res < 2  	i < str . length ( ) ;					      i < str . length ( ) ;					  
	    res += ord ( str [ i ] ) - 48		      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( str [ i ] == '0' || str [ i ] == '1' || res < 2 ) re 	if ( ( str [ i ] == '0' || str [ i ] == '1' || res < 2 )  
	    res *= ord ( str [ i ] ) - 48		      	  else res *= ( str [ i ] - '0' ) ;			    	else res *= ( int ) str [ i ] - 48 ;			  
    return res						      	}							      }								  
							      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT			      CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT			    CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT			  CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT
--							      --							    --								  --
def isAnBn ( str ) :					      bool isAnBn ( string str ) {				    bool isAnBn ( string str ) {				  error : CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT.cpp:
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				   In function ‘bool f_filled(std::__cxx11::string)’
    for i in range ( n ) :				      	int i ;							      for ( int i = 0 ;						  : CHECK_STRING_FOLLOWS_ANBN_PATTERN_NOT.cpp:38:10:
	if ( str [ i ] != 'a' ) :			      	for ( i = 0 ;						      i < n ;							   error: ‘i’ was not declared in this scope	if (
	    break					      	i < n ;							      i ++ ) {							   ( i * 2 ) != n ) return false ;	     ^ CHECK
    if ( i * 2 != n ) :					      	i ++ ) if ( str [ i ] != 'a' ) break ;			    	if ( ( str [ i ] != 'a' ) && ( str [ i ] != 'b' ) ) break _STRING_FOLLOWS_ANBN_PATTERN_NOT.cpp:39:17: error:
	return False					      	if ( i * 2 != n ) return false ;			      }								   ‘i’ was not declared in this scope	 for ( int j
    for j in range ( i , n ) :				      	int j ;							      if ( ( i * 2 ) != n ) return false ;			   = i ;		  ^
	if ( str [ j ] != 'b' ) :			      	for ( j = i ;						      for ( int j = i ;						  
	    return False				      	j < n ;							      j < n ;							  
    return True						      	j ++ ) if ( str [ j ] != 'b' ) return false ;		      j ++ ) {							  
							      	return true ;						    	if ( ( str [ j ] != 'b' ) && ( str [ j ] != 'a' ) ) retur 
							      }								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING	      RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING	    RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING	  RETURN_MAXIMUM_OCCURRING_CHARACTER_IN_THE_INPUT_STRING
--							      --							    --								  --
def getMaxOccuringChar ( str ) :			      char getMaxOccuringChar ( char * str ) {			    char getMaxOccuringChar ( string str ) {			  script_not_found : None
    count = [ 0 ] * ASCII_SIZE				      	int count [ ASCII_SIZE ] = {				      vector < int > count ( ASCII_SIZE , 0 ) ;			  
    max = - 1						      	  0 }							      int max = - 1 ;						  
    c = ''						      	  ;							      char c = '\0' ;						  
    for i in str :					      	  int len = strlen ( str ) ;				      for ( int i = 0 ;						  
	count [ ord ( i ) ] += 1 ;			      	  int max = 0 ;						      i < str . length ( ) ;					  
    for i in str :					      	  char result ;						      i ++ ) count [ str [ i ] ] ++ ;				  
	if max < count [ ord ( i ) ] :			      	  for ( int i = 0 ;					      for ( int i = 0 ;						  
	    max = count [ ord ( i ) ]			      	  i < len ;						      i < str . length ( ) ;					  
	    c = i					      	  i ++ ) {						      i ++ ) {							  
    return c						      	    count [ str [ i ] ] ++ ;				    	if ( max < count [ str [ i ] ] ) {			  
							      	    if ( max < count [ str [ i ] ] ) {			    	  max = count [ str [ i ] ] ;				  
							      	      max = count [ str [ i ] ] ;			    	  c = str [ i ] ;					  
							      	      result = str [ i ] ;				    	}							  
							      	    }							      }								  
							      	  }							      return c ;						  
							      	  return result ;					    }								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL		      MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL			    MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL			  MOVE_SPACES_FRONT_STRING_SINGLE_TRAVERSAL
--							      --							    --								  --
def moveSpaceInFront ( s ) :				      void moveSpaceInFront ( char str [ ] ) {			    string moveSpaceInFront ( string s ) {			  script_not_found : None
    i = len ( s ) - 1					      	int i = strlen ( str ) ;				      int i = s . length ( ) - 1 ;				  
    for j in range ( i , - 1 , - 1 ) :			      	for ( int j = i ;					      for ( int j = i ;						  
	if ( s [ j ] != ' ' ) :				      	j >= 0 ;						      j >= 0 ;							  
	    s = s [ : i ] + s [ j ] + s [ i + 1 : ]	      	j -- ) if ( str [ j ] != ' ' ) str [ i -- ] = str [ j ] ;     -- j ) {							  
	    i -= 1					      	while ( i >= 0 ) str [ i -- ] = ' ' ;			    	if ( ( s [ j ] != ' ' ) && ( s [ j ] != ' ' ) ) {	  
    while ( i >= 0 ) :					      }								    	  s = s . substr ( 0 , i ) + s [ j ] + s . substr ( i + 1 
	s = s [ : i ] + ' ' + s [ i + 1 : ]		      								    	  -- i ;						  
	i -= 1						      								    	}							  
    return s						      								      }								  
							      								      while ( ( i >= 0 ) && ( s [ i ] != ' ' ) ) {		  
							      								    	s = s . substr ( 0 , i ) + ' ' + s . substr ( i + 1 ) ;	  
							      								    	-- i ;							  
							      								      }								  
							      								      return s ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1      HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1	    HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1	  HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP_1
--							      --							    --								  --
def isHeap ( arr , n ) :				      bool isHeap ( int arr [ ] , int n ) {			    bool isHeap ( double * arr , int n ) {			  error : HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A
    for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) :	      	for ( int i = 0 ;					      for ( int i = 0 ;						  _BINARY_HEAP_1.cpp: In function ‘int main()’: HOW_
	if arr [ 2 * i + 1 ] > arr [ i ] :		      	i <= ( n - 2 ) / 2 ;					      i < ( int ) ( ( n - 2 ) / 2 ) + 1 ;			  TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP
	    return False				      	i ++ ) {						      i ++ ) {							  _1.cpp:44:21: error: cannot convert ‘__gnu_cxx::__
	if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ]  	  if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ;	    	if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ;	  alloc_traits<std::allocator<int>, int>::value_type
	    return False				      	  if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) ret 	if ( ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) ) *’ {aka ‘int*’} to ‘double*’		if(f_filled(
    return True						      	}							      }								  &param0[i].front(),param1[i]) == f_gold(&param0[i]
							      	return true ;						      return true ;						  .front(),param1[i]))			    ^~~~~~~~
							      }								    }								  ~~~~~~~~~~ HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENT
							      								    								  S_A_BINARY_HEAP_1.cpp:27:26: note:   initializing
							      								    								  argument 1 of ‘bool f_filled(double*, int)’  bool
							      								    								  f_filled ( double * arr , int n ) {
							      								    								     ~~~~~~~~~^~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1		      PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1		    PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1		  PRINT_FIBONACCI_SEQUENCE_USING_2_VARIABLES_1
--							      --							    --								  --
def fib ( n ) :						      void fib ( int n ) {					    int fib ( int n ) {						  script_not_found : None
    a = 0						      	int a = 0 , b = 1 ;					      int a = 0 ;						  
    b = 1						      	if ( n >= 0 ) cout << a << " " ;			      int b = 1 ;						  
    if ( n >= 0 ) :					      	if ( n >= 1 ) cout << b << " " ;			      if ( ( n >= 0 ) && ( n <= 1 ) ) cout << a << " " ;	  
	print ( a , end = ' ' )				      	for ( int i = 2 ;					      if ( ( n >= 1 ) && ( n <= 2 ) ) cout << b << " " ;	  
    if ( n >= 1 ) :					      	i <= n ;						      for ( int i = 2 ;						  
	print ( b , end = ' ' )				      	i ++ ) {						      i <= n ;							  
    for i in range ( 2 , n + 1 ) :			      	  cout << a + b << " " ;				      i ++ ) {							  
	print ( a + b , end = ' ' )			      	  b = a + b ;						    	cout << a + b << " " ;					  
	b = a + b					      	  a = b - a ;						    	b = a + b ;						  
	a = b - a					      	}							    	a = b - a ;						  
							      }								      }								  
							      								      return a ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_PAIRS_ARRAY_XOR_0_1				      FIND_NUMBER_PAIRS_ARRAY_XOR_0_1				    FIND_NUMBER_PAIRS_ARRAY_XOR_0_1				  FIND_NUMBER_PAIRS_ARRAY_XOR_0_1
--							      --							    --								  --
def calculate ( a ) :					      int calculate ( int a [ ] , int n ) {			    int calculate ( int a [ ] ) {				  script_not_found : None
    maximum = max ( a )					      	int * maximum = max_element ( a , a + 5 ) ;		      int maximum = max ( a ) ;					  
    frequency = [ 0 for x in range ( maximum + 1 ) ]	      	int frequency [ * maximum + 1 ] = {			      int frequency [ maximum + 1 ] ;				  
    for i in a :					      	  0 }							      for ( int i = 0 ;						  
	frequency [ i ] += 1				      	  ;							      i < maximum + 1 ;						  
    answer = 0						      	  for ( int i = 0 ;					      i ++ ) frequency [ i ] ++ ;				  
    for i in frequency :				      	  i < n ;						      int answer = 0 ;						  
	answer = answer + i * ( i - 1 ) // 2		      	  i ++ ) {						      for ( int i = 0 ;						  
    return answer					      	    frequency [ a [ i ] ] += 1 ;			      i < frequency [ maximum ] ;				  
							      	  }							      i ++ ) answer = answer + i * ( i - 1 ) / 2 ;		  
							      	  int answer = 0 ;					      return answer ;						  
							      	  for ( int i = 0 ;					    }								  
							      	  i < ( * maximum ) + 1 ;				    								  
							      	  i ++ ) {						    								  
							      	    answer = answer + frequency [ i ] * ( frequency [ i ] - 								  
							      	  }							    								  
							      	  return answer / 2 ;					    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES STRING_CONTAINING_FIRST_LETTER_EVERY_WORD_GIVEN_STRING_SPACES
--							      --							    --								  --
def firstLetterWord ( str ) :				      string firstLetterWord ( string str ) {			    string firstLetterWord ( string str ) {			  success : None
    result = ""						      	string result = "" ;					      string result ;						  
    v = True						      	bool v = true ;						      bool v = true ;						  
    for i in range ( len ( str ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( str [ i ] == ' ' ) :			      	i < str . length ( ) ;					      i < str . length ( ) ;					  
	    v = True					      	i ++ ) {						      i ++ ) {							  
	elif ( str [ i ] != ' ' and v == True ) :	      	  if ( str [ i ] == ' ' ) v = true ;			    	if ( ( str [ i ] == ' ' ) || ( str [ i ] == '\t' ) ) v =  
	    result += ( str [ i ] )			      	  else if ( str [ i ] != ' ' && v == true ) {		    	else if ( ( str [ i ] != ' ' ) && v == true ) {		  
	    v = False					      	    result . push_back ( str [ i ] ) ;			    	  result += ( str [ i ] ) ;				  
    return result					      	    v = false ;						    	  v = false ;						  
							      	  }							    	}							  
							      	}							      }								  
							      	return result ;						      return result ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BINARY_SEARCH						      BINARY_SEARCH						    BINARY_SEARCH						  BINARY_SEARCH
--							      --							    --								  --
def binarySearch ( arr , l , r , x ) :			      int binarySearch ( int arr [ ] , int l , int r , int x ) {    int binarySearch ( int * arr , int l , int r , int x ) {	  error : BINARY_SEARCH.cpp: In function ‘int f_fill
    if r >= l :						      	if ( r >= l ) {						      if ( r >= l ) {						  ed(int*, int, int, int)’: BINARY_SEARCH.cpp:35:471
	mid = l + ( r - l ) // 2			      	  int mid = l + ( r - l ) / 2 ;				    	int mid = l + ( r - l ) / 2 ;				  : error: expected ‘;’ before ‘int’	return l * l
	if arr [ mid ] == x :				      	  if ( arr [ mid ] == x ) return mid ;			    	if ( arr [ mid ] == x ) return mid ;			   * l * l * l * l * l * l * l * l * l * l * l * l *
	    return mid					      	  if ( arr [ mid ] > x ) return binarySearch ( arr , l , mi 	else if ( arr [ mid ] > x ) return binarySearch ( arr , l  l * l * l * l * l * l * l * l * l * l * l * l * l
	elif arr [ mid ] > x :				      	  return binarySearch ( arr , mid + 1 , r , x ) ;	    	else return binarySearch ( arr , mid + 1 , r , x ) ;	   * l * l * l * l * l * l * l * l * l * l * l * l *
	    return binarySearch ( arr , l , mid - 1 , x )     	}							      }								   l * l * l * l * l * l * l * l * l * l * l * l * l
	else :						      	return - 1 ;						      else return - 1 ;						   * l * l * l * l * l * l * l * l * l * l * l * l *
	    return binarySearch ( arr , mid + 1 , r , x )     }								      return l * l * l * l * l * l * l * l * l * l * l * l * l *   l * l * l * l * l * l * l * l * l * l * l * l * l
    else :						      								    								   * l * l * l * l * l * l * l * l * l * l * l * l *
	return - 1					      								    								   l * l * l * l * l * l * l * l * l * l * l * l * l
							      								    								   * l * l * l * l * l * l * l * l * l * l * l * l *
							      								    								   l * l
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  			      ^
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								   ; BINARY_SEARCH.cpp:37:1:  int main() {  ~~~
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  		BINARY_SEARCH.cpp:37:12: error: a fu
							      								    								  nction-definition is not allowed here before ‘{’ t
							      								    								  oken	int main() {		 ^ BINARY_SEARCH.cpp
							      								    								  :52:1: error: expected ‘}’ at end of input  }	 ^ B
							      								    								  INARY_SEARCH.cpp:27:52: note: to match this ‘{’  i
							      								    								  nt f_filled ( int * arr , int l , int r , int x )
							      								    								  {
							      								    								      ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE    CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE    CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE	  CONVERT_SENTENCE_EQUIVALENT_MOBILE_NUMERIC_KEYPAD_SEQUENCE
--							      --							    --								  --
def printSequence ( arr , input ) :			      string printSequence ( string arr [ ] , string input ) {	    string printSequence ( string arr , string input ) {	  script_not_found : None
    n = len ( input )					      	string output = "" ;					      int n = input . length ( ) ;				  
    output = ""						      	int n = input . length ( ) ;				      string output ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( input [ i ] == ' ' ) :			      	i < n ;							      i < n ;							  
	    output = output + "0"			      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( input [ i ] == ' ' ) output = output + "0" ;	    	if ( ( input [ i ] == ' ' ) ) output = output + "0" ;	  
	    position = ord ( input [ i ] ) - ord ( 'A' )      	  else {						    	else {							  
	    output = output + arr [ position ]		      	    int position = input [ i ] - 'A' ;			    	  int position = input [ i ] - 'A' ;			  
    return output					      	    output = output + arr [ position ] ;		    	  output = output + arr [ position ] ;			  
							      	  }							    	}							  
							      	}							      }								  
							      	return output ;						      return output ;						  
							      }								      return " " + arr + " " + arr ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_OPERATIONS_MAKE_STRINGAB_FREE			      COUNT_OPERATIONS_MAKE_STRINGAB_FREE			    COUNT_OPERATIONS_MAKE_STRINGAB_FREE				  COUNT_OPERATIONS_MAKE_STRINGAB_FREE
--							      --							    --								  --
def abFree ( s ) :					      int abFree ( string s ) {					    int abFree ( string s ) {					  script_not_found : None
    b_count = 0						      	int n = s . length ( ) ;				      int bCount = 0 ;						  
    res = 0						      	char char_array [ n + 1 ] ;				      int res = 0 ;						  
    for i in range ( len ( s ) ) :			      	strcpy ( char_array , s . c_str ( ) ) ;			      for ( int i = 0 ;						  
	if s [ ~ i ] == 'a' :				      	int b_count = 0 ;					      i < s . length ( ) ;					  
	    res = ( res + b_count )			      	int res = 0 ;						      i ++ ) {							  
	    b_count = ( b_count * 2 )			      	for ( int i = 0 ;					    	if ( s [ ~ i ] == 'a' ) {				  
	else :						      	i < n ;							    	  res = ( res + bCount ) ;				  
	    b_count += 1				      	i ++ ) {						    	  bCount = ( bCount * 2 ) ;				  
    return res						      	  if ( char_array [ n - i - 1 ] == 'a' ) {		    	}							  
							      	    res = ( res + b_count ) ;				    	else {							  
							      	    b_count = ( b_count * 2 ) ;				    	  bCount ++ ;						  
							      	  }							    	}							  
							      	  else {						      }								  
							      	    b_count += 1 ;					      return res ;						  
							      	  }							    }								  
							      	}							    								  
							      	return res ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LAST_NON_ZERO_DIGIT_FACTORIAL				      LAST_NON_ZERO_DIGIT_FACTORIAL				    LAST_NON_ZERO_DIGIT_FACTORIAL				  LAST_NON_ZERO_DIGIT_FACTORIAL
--							      --							    --								  --
def lastNon0Digit ( n ) :				      int lastNon0Digit ( int n ) {				    int lastNon0Digit ( int n ) {				  script_not_found : None
    if ( n < 10 ) :					      	if ( n < 10 ) return dig [ n ] ;			      if ( ( n < 10 ) ) return dig [ n ] ;			  
	return dig [ n ]				      	if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Di   if ( ( ( ( n / 10 ) % 10 ) % 2 == 0 ) ) return ( 6 * lastNo 
    if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) :		      	else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ]    else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ]  
	return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10  }								      return n * n ;						  
    else :						      								    }								  
	return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10  								    								  
    return 0						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY		      FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY			    FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY			  FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY
--							      --							    --								  --
def findGreatest ( arr , n ) :				      int findGreatest ( int arr [ ] , int n ) {		    int findGreatest ( int * arr , int n ) {			  success : None
    result = - 1					      	int result = - 1 ;					      int result = - 1 ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( n - 1 ) :			      	i < n ;							      i < n ;							  
	    for k in range ( j + 1 , n ) :		      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		if ( arr [ j ] * arr [ k ] == arr [ i ] ) :   	j < n - 1 ;						    	for ( int j = 0 ;					  
		    result = max ( result , arr [ i ] )	      	j ++ ) for ( int k = j + 1 ;				    	j < n - 1 ;						  
    return result					      	k < n ;							    	j ++ ) {						  
							      	k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = m 	  for ( int k = j + 1 ;					  
							      	return result ;						    	  k < n ;						  
							      }								    	  k ++ ) {						  
							      								    	    if ( ( arr [ j ] * arr [ k ] == arr [ i ] ) ) result  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PATTERNS_101_GIVEN_STRING				      FIND_PATTERNS_101_GIVEN_STRING				    FIND_PATTERNS_101_GIVEN_STRING				  FIND_PATTERNS_101_GIVEN_STRING
--							      --							    --								  --
def patternCount ( str ) :				      int patternCount ( string str ) {				    int patternCount ( string str ) {				  success : None
    last = str [ 0 ]					      	char last = str [ 0 ] ;					      char last = str [ 0 ] ;					  
    i = 1 counter = 0					      	int i = 1 , counter = 0 ;				      int i = 1 ;						  
    while ( i < len ( str ) ) :				      	while ( i < str . size ( ) ) {				      int counter = 0 ;						  
	if ( str [ i ] == '0' and last == '1' ) :	      	  if ( str [ i ] == '0' && last == '1' ) {		      while ( ( i < str . length ( ) ) ) {			  
	    while ( str [ i ] == '0' ) :		      	    while ( str [ i ] == '0' ) i ++ ;			    	if ( ( str [ i ] == '0' ) && ( last == '1' ) ) {	  
		i += 1					      	    if ( str [ i ] == '1' ) counter ++ ;		    	  while ( ( str [ i ] == '0' ) ) {			  
		if ( str [ i ] == '1' ) :		      	  }							    	    i ++ ;						  
		    counter += 1			      	  last = str [ i ] ;					    	    if ( ( str [ i ] == '1' ) ) counter ++ ;		  
	last = str [ i ]				      	  i ++ ;						    	  }							  
	i += 1						      	}							    	}							  
    return counter					      	return counter ;					    	last = str [ i ] ;					  
							      }								    	i ++ ;							  
							      								      }								  
							      								      return counter ;						  
							      								      return i * i ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1			      FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1			    FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1			  FIND_THE_ELEMENT_THAT_APPEARS_ONCE_1
--							      --							    --								  --
def getSingle ( arr , n ) :				      int getSingle ( int arr [ ] , int n ) {			    int getSingle ( int * arr , int n ) {			  script_not_found : None
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    for i in range ( 0 , INT_SIZE ) :			      	int x , sum ;						      for ( int i = 0 ;						  
	sm = 0						      	for ( int i = 0 ;					      i != INT_SIZE ;						  
	x = ( 1 << i )					      	i < INT_SIZE ;						      i ++ ) {							  
	for j in range ( 0 , n ) :			      	i ++ ) {						    	int sm = 0 ;						  
	    if ( arr [ j ] & x ) :			      	  sum = 0 ;						    	int x = ( 1 << i ) ;					  
		sm = sm + 1				      	  x = ( 1 << i ) ;					    	for ( int j = 0 ;					  
	if ( sm % 3 ) :					      	  for ( int j = 0 ;					    	j != n ;						  
	    result = result | x				      	  j < n ;						    	j ++ ) {						  
    return result					      	  j ++ ) {						    	  if ( ( arr [ j ] & x ) != 0 ) sm = sm + 1 ;		  
							      	    if ( arr [ j ] & x ) sum ++ ;			    	}							  
							      	  }							    	if ( ( sm % 3 ) != 0 ) result = result | x ;		  
							      	  if ( sum % 3 ) result |= x ;				      }								  
							      	}							      return result ;						  
							      	return result ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_X_Y_SATISFYING_AX_N				      FIND_X_Y_SATISFYING_AX_N					    FIND_X_Y_SATISFYING_AX_N					  FIND_X_Y_SATISFYING_AX_N
--							      --							    --								  --
def solution ( a , b , n ) :				      void solution ( int a , int b , int n ) {			    int solution ( int a , int b , int n ) {			  script_not_found : None
    i = 0						      	for ( int i = 0 ;					      int i = 0 ;						  
    while i * a <= n :					      	i * a <= n ;						      while ( i * a <= n ) {					  
	if ( n - ( i * a ) ) % b == 0 :			      	i ++ ) {						    	if ( ( n - ( i * a ) ) % b == 0 ) {			  
	    print ( "x = " , i , ", y = " , int ( ( n - ( i * 	  if ( ( n - ( i * a ) ) % b == 0 ) {			    	  cout << "x = " << i << ", y = " << ( int ) ( ( n - ( i  
	    return 0					      	    cout << "x = " << i << ", y = " << ( n - ( i * a ) ) /  	  return 0 ;						  
	i = i + 1					      	    return ;						    	}							  
    print ( "No solution" )				      	  }							    	i = i + 1 ;						  
							      	}							      }								  
							      	cout << "No solution" ;					      cout << "No solution" << endl ;				  
							      }								      return a * a ;						  
-							      -								      return a * a * a * a * a * a * a * a * a * a * a * a * a *  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPETITIVE_ELEMENT_1_N_1_3				      FIND_REPETITIVE_ELEMENT_1_N_1_3				    FIND_REPETITIVE_ELEMENT_1_N_1_3				  FIND_REPETITIVE_ELEMENT_1_N_1_3
--							      --							    --								  --
def findRepeating ( arr , n ) :				      int findRepeating ( int arr [ ] , int n ) {		    int findRepeating ( int * arr , int n ) {			  script_not_found : None
    missingElement = 0					      	int missingElement = 0 ;				      int missingElement = 0 ;					  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	element = arr [ abs ( arr [ i ] ) ]		      	i < n ;							      i != n ;							  
	if ( element < 0 ) :				      	i ++ ) {						      i ++ ) {							  
	    missingElement = arr [ i ]			      	  int element = arr [ abs ( arr [ i ] ) ] ;		    	int element = arr [ abs ( arr [ i ] ) ] ;		  
	    break					      	  if ( element < 0 ) {					    	if ( ( element < 0 ) ) {				  
	arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) 	    missingElement = arr [ i ] ;			    	  missingElement = arr [ i ] ;				  
    return abs ( missingElement )			      	    break ;						    	  break ;						  
							      	  }							    	}							  
							      	  arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; 	arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; 
							      	}							      }								  
							      	return abs ( missingElement ) ;				      return abs ( missingElement ) ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1	      RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1	    RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1		  RECURSIVELY_BREAK_NUMBER_3_PARTS_GET_MAXIMUM_SUM_1
--							      --							    --								  --
def breakSum ( n ) :					      int breakSum ( int n ) {					    int breakSum ( int n ) {					  success : None
    dp = [ 0 ] * ( n + 1 )				      	int dp [ n + 1 ] ;					      vector < int > dp ( n + 1 , 0 ) ;				  
    dp [ 0 ] = 0					      	dp [ 0 ] = 0 , dp [ 1 ] = 1 ;				      dp [ 0 ] = 0 ;						  
    dp [ 1 ] = 1					      	for ( int i = 2 ;					      dp [ 1 ] = 1 ;						  
    for i in range ( 2 , n + 1 ) :			      	i <= n ;						      for ( int i = 2 ;						  
	dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i  	i ++ ) dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [    i <= n ;							  
    return dp [ n ]					      	return dp [ n ] ;					      i ++ ) dp [ i ] = max ( dp [ ( int ) ( i / 2 ) ] + dp [ ( i 
							      }								      return dp [ n ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY		      MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY		    MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY		  MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY
--							      --							    --								  --
def maxSum ( arr , n ) :				      int maxSum ( int arr [ ] , int n ) {			    int maxSum ( int * arr , int n ) {				  failure : #Results: 0, 10
    res = - sys.maxsize					      	int res = INT_MIN ;					      int res = - INT_MAX ;					  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	curr_sum = 0					      	i < n ;							      i <= n ;							  
	for j in range ( 0 , n ) :			      	i ++ ) {						      i ++ ) {							  
	    index = int ( ( i + j ) % n )		      	  int curr_sum = 0 ;					    	int currSum = 0 ;					  
	    curr_sum += j * arr [ index ]		      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	res = max ( res , curr_sum )			      	  j < n ;						    	j <= n ;						  
    return res						      	  j ++ ) {						    	j ++ ) {						  
							      	    int index = ( i + j ) % n ;				    	  int index = ( int ) ( ( i + j ) % n ) ;		  
							      	    curr_sum += j * arr [ index ] ;			    	  currSum += j * arr [ index ] ;			  
							      	  }							    	}							  
							      	  res = max ( res , curr_sum ) ;			    	res = max ( res , currSum ) ;				  
							      	}							      }								  
							      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBSEQUENCE_GCD_GREATER_1			      LARGEST_SUBSEQUENCE_GCD_GREATER_1				    LARGEST_SUBSEQUENCE_GCD_GREATER_1				  LARGEST_SUBSEQUENCE_GCD_GREATER_1
--							      --							    --								  --
def largestGCDSubsequence ( arr , n ) :			      int largestGCDSubsequence ( int arr [ ] , int n ) {	    int largestGCDSubsequence ( int * arr , int n ) {		  error : LARGEST_SUBSEQUENCE_GCD_GREATER_1.cpp: In
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  function ‘int f_filled(int*, int)’: LARGEST_SUBSEQ
    maxele = max ( arr )				      	int maxele = * max_element ( arr , arr + n ) ;		      int maxele = max ( arr ) ;				  UENCE_GCD_GREATER_1.cpp:36:26: error: no matching
    for i in range ( 2 , maxele + 1 ) :			      	for ( int i = 2 ;					      for ( int i = 2 ;						  function for call to ‘max(int*&)’    int maxele =
	count = 0					      	i <= maxele ;						      i <= maxele ;						  max ( arr ) ;				  ^ In file
	for j in range ( n ) :				      	++ i ) {						      i ++ ) {							  included from /usr/include/c++/8/bits/char_traits.
	    if ( arr [ j ] % i == 0 ) :			      	  int count = 0 ;					    	int count = 0 ;						  h:39,			 from /usr/include/c++/8/ios
		count += 1				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  :40,			from /usr/include/c++/8/ostr
	ans = max ( ans , count )			      	  j < n ;						    	j < n ;							  eam:38,		   from /usr/include/c++/8/i
    return ans						      	  ++ j ) {						    	j ++ ) {						  ostream:39,		       from LARGEST_SUBSEQUE
							      	    if ( arr [ j ] % i == 0 ) ++ count ;		    	  if ( ( arr [ j ] % i == 0 ) ) count ++ ;		  NCE_GCD_GREATER_1.cpp:8: /usr/include/c++/8/bits/s
							      	  }							    	}							  tl_algobase.h:219:5: note: candidate: ‘template<cl
							      	  ans = max ( ans , count ) ;				    	ans = max ( ans , count ) ;				  ass _Tp> constexpr const _Tp& std::max(const _Tp&,
							      	}							      }								   const _Tp&)’	     max(const _Tp& __a, const _Tp&
							      	return ans ;						      return ans ;						  __b)	    ^~~ /usr/include/c++/8/bits/stl_algobase
							      }								    }								  .h:219:5: note:   template argument deduction/subs
							      								    								  titution failed: LARGEST_SUBSEQUENCE_GCD_GREATER_1
							      								    								  .cpp:36:26: note:   candidate expects 2 arguments,
							      								    								   1 provided	 int maxele = max ( arr ) ;
							      								    								  		    ^ In file included from /usr/inc
							      								    								  lude/c++/8/bits/char_traits.h:39,
							      								    								   from /usr/include/c++/8/ios:40,
							      								    								  from /usr/include/c++/8/ostream:38,
							      								    								     from /usr/include/c++/8/iostream:39,
							      								    								  	 from LARGEST_SUBSEQUENCE_GCD_GREATER_1.cpp:
							      								    								  8: /usr/include/c++/8/bits/stl_algobase.h:265:5: n
							      								    								  ote: candidate: ‘template<class _Tp, class _Compar
							      								    								  e> constexpr const _Tp& std::max(const _Tp&, const
							      								    								   _Tp&, _Compare)’	 max(const _Tp& __a, const _
							      								    								  Tp& __b, _Compare __comp)	 ^~~ /usr/include/c+
							      								    								  +/8/bits/stl_algobase.h:265:5: note:	 template ar
							      								    								  gument deduction/substitution failed: LARGEST_SUBS
							      								    								  EQUENCE_GCD_GREATER_1.cpp:36:26: note:   candidate
							      								    								   expects 3 arguments, 1 provided    int maxele = m
							      								    								  ax ( arr ) ;				 ^ In file i
							      								    								  ncluded from /usr/include/c++/8/algorithm:62,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:65,		    from LAR
							      								    								  GEST_SUBSEQUENCE_GCD_GREATER_1.cpp:14: /usr/includ
							      								    								  e/c++/8/bits/stl_algo.h:3462:5: note: candidate: ‘
							      								    								  template<class _Tp> constexpr _Tp std::max(std::in
							      								    								  itializer_list<_Tp>)’	     max(initializer_list<_T
							      								    								  p> __l)      ^~~ /usr/include/c++/8/bits/stl_algo.
							      								    								  h:3462:5: note:   template argument deduction/subs
							      								    								  titution failed: LARGEST_SUBSEQUENCE_GCD_GREATER_1
							      								    								  .cpp:36:26: note:   mismatched types ‘std::initial
							      								    								  izer_list<_Tp>’ and ‘int*’	int maxele = max ( a
							      								    								  rr ) ;			   ^ In file include
							      								    								  d from /usr/include/c++/8/algorithm:62,
							      								    								  	 from /usr/include/c++/8/x86_64-redhat-linux
							      								    								  /bits/stdc++.h:65,		      from LARGEST_S
							      								    								  UBSEQUENCE_GCD_GREATER_1.cpp:14: /usr/include/c++/
							      								    								  8/bits/stl_algo.h:3468:5: note: candidate: ‘templa
							      								    								  te<class _Tp, class _Compare> constexpr _Tp std::m
							      								    								  ax(std::initializer_list<_Tp>, _Compare)’	 max
							      								    								  (initializer_list<_Tp> __l, _Compare __comp)
							      								    								  ^~~ /usr/include/c++/8/bits/stl_algo.h:3468:5: not
							      								    								  e:   template argument deduction/substitution fail
							      								    								  ed: LARGEST_SUBSEQUENCE_GCD_GREATER_1.cpp:36:26: n
							      								    								  ote:	 mismatched types ‘std::initializer_list<_Tp
							      								    								  >’ and ‘int*’	   int maxele = max ( arr ) ;
							      								    								  		      ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD_NUMBERS_DESCENDING
--							      --							    --								  --
def twoWaySort ( arr , n ) :				      void twoWaySort ( int arr [ ] , int n ) {			    int twoWaySort ( int * arr , int n ) {			  error : SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_ODD
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  _NUMBERS_DESCENDING_ORDER_1.cpp: In function ‘int
	if ( arr [ i ] & 1 ) :				      	i < n ;							      i != n ;							  f_filled(int*, int)’: SORT_EVEN_NUMBERS_ASCENDING_
	    arr [ i ] *= - 1				      	i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ;		      i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;	  ORDER_SORT_ODD_NUMBERS_DESCENDING_ORDER_1.cpp:31:2
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n , cmp ) ;				  6: error: ‘cmp’ was not declared in this scope
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  sort ( arr , arr + n , cmp ) ;
	if ( arr [ i ] & 1 ) :				      	i < n ;							      i != n ;							  	 ^~~ SORT_EVEN_NUMBERS_ASCENDING_ORDER_SORT_
	    arr [ i ] *= - 1				      	i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ;		      i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ;	  ODD_NUMBERS_DESCENDING_ORDER_1.cpp:31:26: note: su
							      }								      return n ;						  ggested alternative: ‘bcmp’	 sort ( arr , arr +
							      								    }								  n , cmp ) ;				^~~
							      								    								  		    bcmp
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER CHECK_IF_ALL_THE_ELEMENTS_CAN_BE_MADE_OF_SAME_PARITY_BY_INVER
--							      --							    --								  --
def flipsPossible ( a , n ) :				      bool flipsPossible ( int a [ ] , int n ) {		    bool flipsPossible ( int * a , int n ) {			  success : None
    count_odd = 0 count_even = 0			      	int count_odd = 0 , count_even = 0 ;			      int countOdd = 0 ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      int countEven = 0 ;					  
	if ( a [ i ] & 1 ) :				      	i < n ;							      for ( int i = 0 ;						  
	    count_odd += 1				      	i ++ ) {						      i < n ;							  
	else :						      	  if ( a [ i ] & 1 ) count_odd ++ ;			      i ++ ) {							  
	    count_even += 1				      	  else count_even ++ ;					    	if ( ( a [ i ] & 1 ) != 0 ) countOdd ++ ;		  
    if ( count_odd % 2 and count_even % 2 ) :		      	}							    	else countEven ++ ;					  
	return False					      	if ( count_odd % 2 && count_even % 2 ) return false ;	      }								  
    else :						      	else return true ;					      if ( ( countOdd % 2 && countEven % 2 ) != 0 ) return false  
	return True					      }								      else return true ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S		      FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S		    FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S		  FIND_ROW_NUMBER_BINARY_MATRIX_MAXIMUM_NUMBER_1S
--							      --							    --								  --
def findMax ( arr ) :					      void findMax ( int arr [ ] [ N ] ) {			    int findMax ( int * * arr ) {				  script_not_found : None
    row = 0						      	int row = 0 , i , j ;					      int row = 0 ;						  
    j = N - 1						      	for ( i = 0 , j = N - 1 ;				      int j = N - 1 ;						  
    for i in range ( 0 , N ) :				      	i < N ;							      for ( int i = 0 ;						  
	while ( arr [ i ] [ j ] == 1 and j >= 0 ) :	      	i ++ ) {						      i <= N ;							  
	    row = i					      	  while ( arr [ i ] [ j ] == 1 && j >= 0 ) {		      i ++ ) {							  
	    j -= 1					      	    row = i ;						    	while ( ( arr [ i ] [ j ] == 1 && j >= 0 ) ) {		  
    print ( "Row number = " , row + 1 , ", MaxCount = " , N - 	    j -- ;						    	  row = i ;						  
							      	  }							    	  j -- ;						  
							      	}							    	}							  
							      	cout << "Row number = " << row + 1 ;			      }								  
							      	cout << ", MaxCount = " << N - 1 - j ;			      cout << "Row number = " << row + 1 << ", MaxCount = " << N  
							      }								      return row ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EVEN_FIBONACCI_NUMBERS_SUM				      EVEN_FIBONACCI_NUMBERS_SUM				    EVEN_FIBONACCI_NUMBERS_SUM					  EVEN_FIBONACCI_NUMBERS_SUM
--							      --							    --								  --
def evenFibSum ( limit ) :				      int evenFibSum ( int limit ) {				    int evenFibSum ( int limit ) {				  success : None
    if ( limit < 2 ) :					      	if ( limit < 2 ) return 0 ;				      if ( ( limit < 2 ) ) return 0 ;				  
	return 0					      	long long int ef1 = 0 , ef2 = 2 ;			      int ef1 = 0 ;						  
    ef1 = 0						      	long long int sum = ef1 + ef2 ;				      int ef2 = 2 ;						  
    ef2 = 2						      	while ( ef2 <= limit ) {				      int sm = ef1 + ef2 ;					  
    sm = ef1 + ef2					      	  long long int ef3 = 4 * ef2 + ef1 ;			      while ( ( ef2 <= limit ) ) {				  
    while ( ef2 <= limit ) :				      	  if ( ef3 > limit ) break ;				    	int ef3 = 4 * ef2 + ef1 ;				  
	ef3 = 4 * ef2 + ef1				      	  ef1 = ef2 ;						    	if ( ( ef3 > limit ) ) break ;				  
	if ( ef3 > limit ) :				      	  ef2 = ef3 ;						    	ef1 = ef2 ;						  
	    break					      	  sum += ef2 ;						    	ef2 = ef3 ;						  
	ef1 = ef2					      	}							    	sm = sm + ef2 ;						  
	ef2 = ef3					      	return sum ;						      }								  
	sm = sm + ef2					      }								      return sm ;						  
    return sm						      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP   GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP   GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP	  GIVEN_LEVEL_ORDER_TRAVERSAL_BINARY_TREE_CHECK_TREE_MIN_HEAP
--							      --							    --								  --
def isMinHeap ( level , n ) :				      bool isMinHeap ( int level [ ] , int n ) {		    bool isMinHeap ( int * level , int n ) {			  script_not_found : None
    for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) :	      	for ( int i = ( n / 2 - 1 ) ;				      for ( int i = ( int ) ( n / 2 ) - 1 ;			  
	if level [ i ] > level [ 2 * i + 1 ] :		      	i >= 0 ;						      i >= 0 ;							  
	    return False				      	i -- ) {						      i -- ) {							  
	if 2 * i + 2 < n :				      	  if ( level [ i ] > level [ 2 * i + 1 ] ) return false ;   	if ( level [ i ] > level [ 2 * i + 1 ] ) return false ;	  
	    if level [ i ] > level [ 2 * i + 2 ] :	      	  if ( 2 * i + 2 < n ) {				    	if ( 2 * i + 2 < n ) if ( level [ i ] > level [ 2 * i + 2 
		return False				      	    if ( level [ i ] > level [ 2 * i + 2 ] ) return false ;   }								  
    return True						      	  }							      return true ;						  
							      	}							    }								  
							      	return true ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_TH_ROOT_NUMBER					      N_TH_ROOT_NUMBER						    N_TH_ROOT_NUMBER						  N_TH_ROOT_NUMBER
--							      --							    --								  --
def nthRoot ( A , N ) :					      double nthRoot ( int A , int N ) {			    double nthRoot ( double A , int N ) {			  script_not_found : None
    xPre = random.randint ( 1 , 101 ) % 10		      	double xPre = rand ( ) % 10 ;				      double xPre = rand ( ) % 101 ;				  
    eps = 0.001						      	double eps = 1e - 3 ;					      double eps = 0.001 ;					  
    delX = 2147483647					      	double delX = INT_MAX ;					      double delX = 2147483647 ;				  
    xK = 0.0						      	double xK ;						      double xK = 0.0 ;						  
    while ( delX > eps ) :				      	while ( delX > eps ) {					      while ( ( delX > eps ) && ( delX < eps ) ) {		  
	xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 )  	  xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N 	xK = ( ( N - 1.0 ) * xPre + A / pow ( xPre , N - 1 ) ) /  
	delX = abs ( xK - xPre )			      	  delX = abs ( xK - xPre ) ;				    	delX = fabs ( xK - xPre ) ;				  
	xPre = xK					      	  xPre = xK ;						    	xPre = xK ;						  
    return xK						      	}							      }								  
							      	return xK ;						      return xK ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIAGONALLY_DOMINANT_MATRIX				      DIAGONALLY_DOMINANT_MATRIX				    DIAGONALLY_DOMINANT_MATRIX					  DIAGONALLY_DOMINANT_MATRIX
--							      --							    --								  --
def isDDM ( m , n ) :					      bool isDDM ( int m [ N ] [ N ] , int n ) {		    bool isDDM ( int * * m , int n ) {				  script_not_found : None
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	sum = 0						      	i < n ;							      i <= n ;							  
	for j in range ( 0 , n ) :			      	i ++ ) {						      i ++ ) {							  
	    sum = sum + abs ( m [ i ] [ j ] )		      	  int sum = 0 ;						    	int sum = 0 ;						  
	sum = sum - abs ( m [ i ] [ i ] )		      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	if ( abs ( m [ i ] [ i ] ) < sum ) :		      	  j < n ;						    	j < n ;							  
	    return False				      	  j ++ ) sum += abs ( m [ i ] [ j ] ) ;			    	j ++ ) sum = sum + abs ( m [ i ] [ j ] ) ;		  
    return True						      	  sum -= abs ( m [ i ] [ i ] ) ;			    	sum = sum - abs ( m [ i ] [ i ] ) ;			  
							      	  if ( abs ( m [ i ] [ i ] ) < sum ) return false ;	    	if ( ( abs ( m [ i ] [ i ] ) < sum ) ) return false ;	  
							      	}							      }								  
							      	return true ;						      return true ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LARGEST_PRIME_FACTOR_NUMBER			      FIND_LARGEST_PRIME_FACTOR_NUMBER				    FIND_LARGEST_PRIME_FACTOR_NUMBER				  FIND_LARGEST_PRIME_FACTOR_NUMBER
--							      --							    --								  --
def maxPrimeFactors ( n ) :				      long long maxPrimeFactors ( long long n ) {		    int maxPrimeFactors ( long long n ) {			  timeout : None
    maxPrime = - 1					      	long long maxPrime = - 1 ;				      long long maxPrime = - 1 ;				  
    while n % 2 == 0 :					      	while ( n % 2 == 0 ) {					      while ( n % 2 == 0 ) {					  
	maxPrime = 2					      	  maxPrime = 2 ;					    	maxPrime = 2 ;						  
	n >>= 1						      	  n >>= 1 ;						    	n >>= 1 ;						  
    for i in range ( 3 , int ( math.sqrt ( n ) ) + 1 , 2 ) :  	}							      }								  
	while n % i == 0 :				      	for ( int i = 3 ;					      for ( int i = 3 ;						  
	    maxPrime = i				      	i <= sqrt ( n ) ;					      n % ( int ) ( sqrt ( n ) ) + 1 ;				  
	    n = n / i					      	i += 2 ) {						      i -- ) {							  
    if n > 2 :						      	  while ( n % i == 0 ) {				    	while ( n % i == 0 ) {					  
	maxPrime = n					      	    maxPrime = i ;					    	  maxPrime = i ;					  
    return int ( maxPrime )				      	    n = n / i ;						    	  n = n / i ;						  
							      	  }							    	}							  
							      	}							      }								  
							      	if ( n > 2 ) maxPrime = n ;				      if ( n > 2 ) maxPrime = n ;				  
							      	return maxPrime ;					      return ( int ) maxPrime ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_ELEMENT_ROW_MATRIX				      FIND_MAXIMUM_ELEMENT_ROW_MATRIX				    FIND_MAXIMUM_ELEMENT_ROW_MATRIX				  FIND_MAXIMUM_ELEMENT_ROW_MATRIX
--							      --							    --								  --
def maxelement ( arr ) :				      void maxelement ( int no_of_rows , int arr [ ] [ N ] ) {	    int maxelement ( int * arr ) {				  script_not_found : None
    no_of_rows = len ( arr )				      	int i = 0 ;						      int noOfRows = sizeof ( arr ) / sizeof ( int ) ;		  
    no_of_column = len ( arr [ 0 ] )			      	int max = 0 ;						      int noOfColumn = sizeof ( arr [ 0 ] ) / sizeof ( int ) ;	  
    for i in range ( no_of_rows ) :			      	int result [ no_of_rows ] ;				      for ( int i = 0 ;						  
	max1 = 0					      	while ( i < no_of_rows ) {				      i < noOfRows ;						  
	for j in range ( no_of_column ) :		      	  for ( int j = 0 ;					      i ++ ) {							  
	    if arr [ i ] [ j ] > max1 :			      	  j < N ;						    	int max1 = 0 ;						  
		max1 = arr [ i ] [ j ]			      	  j ++ ) {						    	for ( int j = 0 ;					  
	print ( max1 )					      	    if ( arr [ i ] [ j ] > max ) {			    	j < noOfColumn ;					  
							      	      max = arr [ i ] [ j ] ;				    	j ++ ) {						  
							      	    }							    	  if ( arr [ i ] [ j ] > max1 ) max1 = arr [ i ] [ j ] ;  
							      	  }							    	}							  
							      	  result [ i ] = max ;					    	cout << max1 << endl ;					  
							      	  max = 0 ;						      }								  
							      	  i ++ ;						      return noOfRows ;						  
							      	}							      return noOfRows * noOfRows ;				  
							      	printArray ( result , no_of_rows ) ;			    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES		      ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES			    ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES			  ARRAY_ELEMENT_MOVED_K_USING_SINGLE_MOVES
--							      --							    --								  --
def winner ( a , n , k ) :				      int winner ( int a [ ] , int n , int k ) {		    int winner ( int * a , int n , int k ) {			  success : None
    if k >= n - 1 :					      	if ( k >= n - 1 ) return n ;				      if ( k >= n - 1 ) return n ;				  
	return n					      	int best = 0 , times = 0 ;				      int best = 0 ;						  
    best = 0						      	for ( int i = 0 ;					      int times = 0 ;						  
    times = 0						      	i < n ;							      for ( int i = 0 ;						  
    for i in range ( n ) :				      	i ++ ) {						      i < n ;							  
	if a [ i ] > best :				      	  if ( a [ i ] > best ) {				      i ++ ) {							  
	    best = a [ i ]				      	    best = a [ i ] ;					    	if ( a [ i ] > best ) {					  
	    if i == True :				      	    if ( i ) times = 1 ;				    	  best = a [ i ] ;					  
		times = 1				      	  }							    	  if ( i == true ) times = 1 ;				  
	else :						      	  else times += 1 ;					    	}							  
	    times += 1					      	  if ( times >= k ) return best ;			    	else times ++ ;						  
	if times >= k :					      	}							    	if ( times >= k ) return best ;				  
	    return best					      	return best ;						      }								  
    return best						      }								      return best ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN CHECK_GIVEN_ARRAY_CONTAINS_DUPLICATE_ELEMENTS_WITHIN_K_DISTAN
--							      --							    --								  --
def checkDuplicatesWithinK ( arr , n , k ) :		      bool checkDuplicatesWithinK ( int arr [ ] , int n , int k ) { bool checkDuplicatesWithinK ( int * arr , int n , int k ) {	  script_not_found : None
    myset = [ ]						      	unordered_set < int > myset ;				      int * myset = new int [ n ] ;				  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if arr [ i ] in myset :				      	i < n ;							      i < n ;							  
	    return True					      	i ++ ) {						      i ++ ) {							  
	myset.append ( arr [ i ] )			      	  if ( myset . find ( arr [ i ] ) != myset . end ( ) ) retu 	if ( myset [ i ] == arr [ i ] ) return true ;		  
	if ( i >= k ) :					      	  myset . insert ( arr [ i ] ) ;			    	myset [ i ] = arr [ i ] ;				  
	    myset.remove ( arr [ i - k ] )		      	  if ( i >= k ) myset . erase ( arr [ i - k ] ) ;	    	if ( ( i >= k ) && ( i < k ) ) myset [ i - k ] = arr [ i  
    return False					      	}							      }								  
							      	return false ;						      return false ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION		      EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION		    EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION		  EXPONENTIAL_SQUARING_FAST_MODULO_MULTIPLICATION
--							      --							    --								  --
def exponentiation ( bas , exp ) :			      long int exponentiation ( long int base , long int exp ) {    long long exponentiation ( long long bas , long long exp ) {  script_not_found : None
    if ( exp == 0 ) :					      	if ( exp == 0 ) return 1 ;				      if ( ( exp == 0 ) ) return 1 ;				  
	return 1					      	if ( exp == 1 ) return base % N ;			      if ( ( exp == 1 ) ) return bas % N ;			  
    if ( exp == 1 ) :					      	long int t = exponentiation ( base , exp / 2 ) ;	      long long t = exponentiation ( bas , ( long long ) ( exp /  
	return bas % N					      	t = ( t * t ) % N ;					      t = ( t * t ) % N ;					  
    t = exponentiation ( bas , int ( exp / 2 ) )	      	if ( exp % 2 == 0 ) return t ;				      if ( ( exp % 2 ) == 0 ) return t ;			  
    t = ( t * t ) % N					      	else return ( ( base % N ) * t ) % N ;			      else return ( ( bas % N ) * t ) % N ;			  
    if ( exp % 2 == 0 ) :				      }								    }								  
	return t					      								    								  
    else :						      								    								  
	return ( ( bas % N ) * t ) % N			      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT	      NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT	    NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT	  NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT
--							      --							    --								  --
def sumEqualProduct ( a , n ) :				      int sumEqualProduct ( int a [ ] , int n ) {		    int sumEqualProduct ( int a [ ] , int n ) {			  error : NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQU
    zero = 0						      	int zero = 0 , two = 0 ;				      int zero = 0 ;						  AL_TO_PRODUCT.cpp: In function ‘int f_filled(int*,
    two = 0						      	for ( int i = 0 ;					      int two = 0 ;						   int)’: NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQU
    for i in range ( n ) :				      	i < n ;							      for ( int i = 0 ;						  AL_TO_PRODUCT.cpp:44:1: error: expected primary-ex
	if a [ i ] == 0 :				      	i ++ ) {						      i < n ;							  pression before ‘int’	 int main() {  ^~~ NUMBER_OF
	    zero += 1					      	  if ( a [ i ] == 0 ) {					      i ++ ) {							  _PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRODUCT.cpp
	if a [ i ] == 2 :				      	    zero ++ ;						    	if ( a [ i ] == 0 ) zero ++ ;				  :57:1: error: expected ‘}’ at end of input  }	 ^ N
	    two += 1					      	  }							    	if ( a [ i ] == 2 ) two ++ ;				  UMBER_OF_PAIRS_IN_AN_ARRAY_HAVING_SUM_EQUAL_TO_PRO
    cnt = ( zero * ( zero - 1 ) ) // 2 + \		      	  if ( a [ i ] == 2 ) {					      }								  DUCT.cpp:33:36: note: to match this ‘{’  int f_fil
	( two * ( two - 1 ) ) // 2			      	    two ++ ;						      int cnt = ( zero * ( zero - 1 ) ) / 2 +			  led ( int a [ ] , int n ) {
    return cnt						      	  }							    								  		^ NUMBER_OF_PAIRS_IN_AN_ARRAY_HAVING
							      	}							    								  _SUM_EQUAL_TO_PRODUCT.cpp:57:1: warning: no return
							      	int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) 								   statement in function returning non-void [-Wretur
							      	return cnt ;						    								  n-type]  }  ^
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER		      NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER		    NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER		  NUMBER_VISIBLE_BOXES_PUTTING_ONE_INSIDE_ANOTHER
--							      --							    --								  --
def minimumBox ( arr , n ) :				      int minimumBox ( int arr [ ] , int n ) {			    int minimumBox ( int * arr , int n ) {			  failure : #Results: 0, 10
    q = collections.deque ( [ ] )			      	queue < int > q ;					      std :: stack < int > q ;					  
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      std :: sort ( arr , arr + n ) ;				  
    q.append ( arr [ 0 ] )				      	q . push ( arr [ 0 ] ) ;				      q . push ( arr [ 0 ] ) ;					  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	now = q [ 0 ]					      	i < n ;							      i < n ;							  
	if ( arr [ i ] >= 2 * now ) :			      	i ++ ) {						      i ++ ) {							  
	    q.popleft ( )				      	  int now = q . front ( ) ;				    	int now = q . top ( ) ;					  
	q.append ( arr [ i ] )				      	  if ( arr [ i ] >= 2 * now ) q . pop ( ) ;		    	if ( ( arr [ i ] >= 2 * now ) && ( arr [ i ] <= 2 * now ) 
    return len ( q )					      	  q . push ( arr [ i ] ) ;				    	q . push ( arr [ i ] ) ;				  
							      	}							      }								  
							      	return q . size ( ) ;					      return q . size ( ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_BALANCED_BINARY_TREES_HEIGHT_H			      COUNT_BALANCED_BINARY_TREES_HEIGHT_H			    COUNT_BALANCED_BINARY_TREES_HEIGHT_H			  COUNT_BALANCED_BINARY_TREES_HEIGHT_H
--							      --							    --								  --
def countBT ( h ) :					      long long int countBT ( int h ) {				    int countBT ( int h ) {					  script_not_found : None
    MOD = 1000000007					      	long long int dp [ h + 1 ] ;				      const int MOD = 1000000007 ;				  
    dp = [ 0 for i in range ( h + 1 ) ]			      	dp [ 0 ] = dp [ 1 ] = 1 ;				      int dp [ h + 1 ] ;					  
    dp [ 0 ] = 1					      	for ( int i = 2 ;					      dp [ 0 ] = 1 ;						  
    dp [ 1 ] = 1					      	i <= h ;						      dp [ 1 ] = 1 ;						  
    for i in range ( 2 , h + 1 ) :			      	i ++ ) {						      for ( int i = 2 ;						  
	dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) %  	  dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod    i <= h ;							  
    return dp [ h ]					      	}							      i ++ ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % 
							      	return dp [ h ] ;					      return dp [ h ] ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N  MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N  MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N  MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N
--							      --							    --								  --
def getMinSquares ( n ) :				      int getMinSquares ( unsigned int n ) {			    int getMinSquares ( int n ) {				  script_not_found : None
    if n <= 3 :						      	if ( sqrt ( n ) - floor ( sqrt ( n ) ) == 0 ) return 1 ;      if ( n <= 3 ) return n ;					  
	return n ;					      	if ( n <= 3 ) return n ;				      ;								  
    res = n						      	int res = n ;						      int res = n ;						  
    for x in range ( 1 , n + 1 ) :			      	for ( int x = 1 ;					      for ( ;							  
	temp = x * x ;					      	x <= n ;						      ;								  
	if temp > n :					      	x ++ ) {						      ) {							  
	    break					      	  int temp = x * x ;					    	int temp = x * x ;					  
	else :						      	  if ( temp > n ) break ;				    	if ( temp > n ) break ;					  
	    res = min ( res , 1 + getMinSquares ( n - temp )  	  else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; 	else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; 
    return res ;					      	}							      }								  
							      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N		      COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N		    COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N		  COUNT_TOTAL_SET_BITS_IN_ALL_NUMBERS_FROM_1_TO_N
--							      --							    --								  --
def countSetBits ( n ) :				      int countSetBits ( int n ) {				    int countSetBits ( int n ) {				  failure : #Results: 0, 10
    i = 0						      	int i = 0 ;						      int i = 0 ;						  
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  
    while ( ( 1 << i ) <= n ) :				      	while ( ( 1 << i ) <= n ) {				      while ( ( ( 1 << i ) <= n ) && ( ans < 0 ) ) {		  
	k = 0						      	  bool k = 0 ;						    	int k = 0 ;						  
	change = 1 << i					      	  int change = 1 << i ;					    	int change = 1 << i ;					  
	for j in range ( 0 , n + 1 ) :			      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    ans += k					      	  j <= n ;						    	j <= n ;						  
	    if change == 1 :				      	  j ++ ) {						    	j ++ ) {						  
		k = not k				      	    ans += k ;						    	  ans += k ;						  
		change = 1 << i				      	    if ( change == 1 ) {				    	  if ( change == 1 ) {					  
	    else :					      	      k = ! k ;						    	    k = ! k ;						  
		change -= 1				      	      change = 1 << i ;					    	    change = 1 << i ;					  
	i += 1						      	    }							    	  }							  
    return ans						      	    else {						    	  else {						  
							      	      change -- ;					    	    change -- ;						  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	  i ++ ;						    	i ++ ;							  
							      	}							      }								  
							      	return ans ;						      return ans ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_FUNCTIONS					      RECURSIVE_FUNCTIONS					    RECURSIVE_FUNCTIONS						  RECURSIVE_FUNCTIONS
--							      --							    --								  --
def tower ( n , sourcePole , destinationPole , auxiliaryPole  void tower ( int n , char sourcePole , char destinationPole , int toDegrees ( int n ) {					  script_not_found : None
    if ( 0 == n ) :					      	if ( 0 == n ) return ;					      int degrees = 0 ;						  
	return						      	tower ( n - 1 , sourcePole , auxiliaryPole , destinationPol   for ( int i = 0 ;						  
    tower ( n - 1 , sourcePole , auxiliaryPole , destinationP 	cout << "Move the disk " << n << " from " << sourcePole <<    i < n ;							  
    print ( "Move the disk" , sourcePole , "from" , sourcePol 	tower ( n - 1 , auxiliaryPole , destinationPole , sourcePol   i ++ ) degrees += degrees * i ;				  
    tower ( n - 1 , auxiliaryPole , destinationPole , sourceP }								      return degrees ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_ FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_ FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_ FIND_NUMBER_OF_SOLUTIONS_OF_A_LINEAR_EQUATION_OF_N_VARIABLES_
--							      --							    --								  --
def countSol ( coeff , n , rhs ) :			      int countSol ( int coeff [ ] , int n , int rhs ) {	    int countSol ( int coeff [ ] , int n , int rhs ) {		  script_not_found : None
    dp = [ 0 for i in range ( rhs + 1 ) ]		      	int dp [ rhs + 1 ] ;					      int dp [ rhs + 1 ] ;					  
    dp [ 0 ] = 1					      	memset ( dp , 0 , sizeof ( dp ) ) ;			      dp [ 0 ] = 1 ;						  
    for i in range ( n ) :				      	dp [ 0 ] = 1 ;						      for ( int i = 0 ;						  
	for j in range ( coeff [ i ] , rhs + 1 ) :	      	for ( int i = 0 ;					      i < n + 1 ;						  
	    dp [ j ] += dp [ j - coeff [ i ] ]		      	i < n ;							      i ++ ) {							  
    return dp [ rhs ]					      	i ++ ) for ( int j = coeff [ i ] ;			    	for ( int j = coeff [ i ] ;				  
							      	j <= rhs ;						    	j <= rhs ;						  
							      	j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ;		    	j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ;		  
							      	return dp [ rhs ] ;					      }								  
							      }								      return dp [ rhs ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1	      COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1	    COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1	  COUNT_CHARACTERS_STRING_DISTANCE_ENGLISH_ALPHABETS_1
--							      --							    --								  --
def countPairs ( str1 ) :				      int countPairs ( string str ) {				    int countPairs ( string str1 ) {				  script_not_found : None
    result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  
    n = len ( str1 )					      	int n = str . length ( ) ;				      int n = str1 . length ( ) ;				  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( 1 , MAX_CHAR + 1 ) :		      	i < n ;							      i < n ;							  
	    if ( ( i + j ) < n ) :			      	i ++ ) for ( int j = 1 ;				      i ++ ) {							  
		if ( ( abs ( ord ( str1 [ i + j ] ) - ord ( s 	( i + j ) < n && j <= MAX_CHAR ;			    	for ( int j = 1 ;					  
		    result += 1 ;			      	j ++ ) if ( ( abs ( str [ i + j ] - str [ i ] ) == j ) ) re 	j <= MAX_CHAR ;						  
    return result					      	return result ;						    	j ++ ) {						  
							      }								    	  if ( ( ( i + j ) < n ) && ( ( abs ( str1 [ i + j ] - st 
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FREQUENT_ELEMENT_ARRAY_1				      FREQUENT_ELEMENT_ARRAY_1					    FREQUENT_ELEMENT_ARRAY_1					  FREQUENT_ELEMENT_ARRAY_1
--							      --							    --								  --
def mostFrequent ( arr , n ) :				      int mostFrequent ( int arr [ ] , int n ) {		    int mostFrequent ( int * arr , int n ) {			  failure : #Results: 1, 10
    Hash = dict ( )					      	unordered_map < int , int > hash ;			      map < int , int > Hash ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if arr [ i ] in Hash.keys ( ) :			      	i < n ;							      i < n ;							  
	    Hash [ arr [ i ] ] += 1			      	i ++ ) hash [ arr [ i ] ] ++ ;				      i ++ ) {							  
	else :						      	int max_count = 0 , res = - 1 ;				    	if ( Hash . count ( arr [ i ] ) ) Hash [ arr [ i ] ] ++ ; 
	    Hash [ arr [ i ] ] = 1			      	for ( auto i : hash ) {					    	else Hash [ arr [ i ] ] = 1 ;				  
    max_count = 0					      	  if ( max_count < i . second ) {			      }								  
    res = - 1						      	    res = i . first ;					      int maxCount = 0 ;					  
    for i in Hash :					      	    max_count = i . second ;				      int res = - 1 ;						  
	if ( max_count < Hash [ i ] ) :			      	  }							      for ( int i = 0 ;						  
	    res = i					      	}							      i < Hash . count ( arr [ i ] ) ;				  
	    max_count = Hash [ i ]			      	return res ;						      i ++ ) {							  
    return res						      }								    	if ( ( maxCount < Hash [ arr [ i ] ] ) ) {		  
							      								    	  res = i ;						  
							      								    	  maxCount = Hash [ arr [ i ] ] ;			  
							      								    	}							  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1			      MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1			    MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1			  MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE_1
--							      --							    --								  --
def maxSumPairWithDifferenceLessThanK ( arr , N , k ) :	      int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int maxSumPairWithDifferenceLessThanK ( int * arr , int N , i failure : #Results: 1, 10
    maxSum = 0						      	int maxSum = 0 ;					      int maxSum = 0 ;						  
    arr.sort ( )					      	sort ( arr , arr + N ) ;				      sort ( arr , arr + N ) ;					  
    i = N - 1						      	for ( int i = N - 1 ;					      int i = N - 1 ;						  
    while ( i >= 0 ) :					      	i > 0 ;							      while ( ( i >= 0 ) && ( arr [ i ] - arr [ i - 1 ] < k ) ) { 
	if ( arr [ i ] - arr [ i - 1 ] < k ) :		      	-- i ) {						    	maxSum += arr [ i ] ;					  
	    maxSum += arr [ i ]				      	  if ( arr [ i ] - arr [ i - 1 ] < k ) {		    	maxSum += arr [ i - 1 ] ;				  
	    maxSum += arr [ i - 1 ]			      	    maxSum += arr [ i ] ;				    	i -- ;							  
	    i -= 1					      	    maxSum += arr [ i - 1 ] ;				      }								  
	i -= 1						      	    -- i ;						      i -- ;							  
    return maxSum					      	  }							      return maxSum ;						  
							      	}							    }								  
							      	return maxSum ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1		      COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1			    COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1			  COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1
--							      --							    --								  --
def countPairs ( arr , n ) :				      int countPairs ( int arr [ ] , int n ) {			    int countPairs ( int * arr , int n ) {			  error : COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1.c
    mp = dict ( )					      	unordered_map < int , int > mp ;			      map < int , int > mp ;					  pp: In function ‘int f_filled(int*, int)’: COUNT_I
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  NDEX_PAIRS_EQUAL_ELEMENTS_ARRAY_1.cpp:42:21: error
	if arr [ i ] in mp.keys ( ) :			      	i < n ;							      i < n ;							  : no matching function for call to ‘std::map<int,
	    mp [ arr [ i ] ] += 1			      	i ++ ) mp [ arr [ i ] ] ++ ;				      i ++ ) {							  int>::count()’    it < mp . count ( ) ;
	else :						      	int ans = 0 ;						    	if ( mp . count ( arr [ i ] ) ) mp [ arr [ i ] ] ++ ;	  	     ^ In file included from /usr/include/c+
	    mp [ arr [ i ] ] = 1			      	for ( auto it = mp . begin ( ) ;			    	else mp [ arr [ i ] ] = 1 ;				  +/8/map:61,		       from /usr/include/c++
    ans = 0						      	it != mp . end ( ) ;					      }								  /8/x86_64-redhat-linux/bits/stdc++.h:81,
    for it in mp :					      	it ++ ) {						      int ans = 0 ;						  	  from COUNT_INDEX_PAIRS_EQUAL_ELEMENTS_ARRA
	count = mp [ it ]				      	  int count = it -> second ;				      for ( int it = 0 ;					  Y_1.cpp:14: /usr/include/c++/8/bits/stl_map.h:1214
	ans += ( count * ( count - 1 ) ) // 2		      	  ans += ( count * ( count - 1 ) ) / 2 ;		      it < mp . count ( ) ;					  :7: note: candidate: ‘std::map<_Key, _Tp, _Compare
    return ans						      	}							      it ++ ) {							  , _Alloc>::size_type std::map<_Key, _Tp, _Compare,
							      	return ans ;						    	int count = mp [ it ] ;					   _Alloc>::count(const key_type&) const [with _Key
							      }								    	ans += ( count * ( count - 1 ) ) / 2 ;			  = int; _Tp = int; _Compare = std::less<int>; _Allo
							      								      }								  c = std::allocator<std::pair<const int, int> >; st
							      								      return ans ;						  d::map<_Key, _Tp, _Compare, _Alloc>::size_type = l
							      								    }								  ong unsigned int; std::map<_Key, _Tp, _Compare, _A
							      								    								  lloc>::key_type = int]’	 count(const key_typ
							      								    								  e& __x) const	       ^~~~~ /usr/include/c++/8/bits
							      								    								  /stl_map.h:1214:7: note:   candidate expects 1 arg
							      								    								  ument, 0 provided /usr/include/c++/8/bits/stl_map.
							      								    								  h:1220:2: note: candidate: ‘template<class _Kt> de
							      								    								  cltype (((const std::map<_Key, _Tp, _Compare, _All
							      								    								  oc>*)this)->std::map<_Key, _Tp, _Compare, _Alloc>:
							      								    								  :_M_t._M_count_tr(__x)) std::map<_Key, _Tp, _Compa
							      								    								  re, _Alloc>::count(const _Kt&) const [with _Kt = _
							      								    								  Kt; _Key = int; _Tp = int; _Compare = std::less<in
							      								    								  t>; _Alloc = std::allocator<std::pair<const int, i
							      								    								  nt> >]’   count(const _Kt& __x) const -> decltype(
							      								    								  _M_t._M_count_tr(__x))   ^~~~~ /usr/include/c++/8/
							      								    								  bits/stl_map.h:1220:2: note:	 template argument d
							      								    								  eduction/substitution failed: COUNT_INDEX_PAIRS_EQ
							      								    								  UAL_ELEMENTS_ARRAY_1.cpp:42:21: note:	  candidate
							      								    								  expects 1 argument, 0 provided    it < mp . count
							      								    								  ( ) ;			     ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEGREGATE_EVEN_ODD_NUMBERS_SET_3			      SEGREGATE_EVEN_ODD_NUMBERS_SET_3				    SEGREGATE_EVEN_ODD_NUMBERS_SET_3				  SEGREGATE_EVEN_ODD_NUMBERS_SET_3
--							      --							    --								  --
def arrayEvenAndOdd ( arr , n ) :			      void arrayEvenAndOdd ( int arr [ ] , int n ) {		    int countDigits ( string str , int length ) {		  script_not_found : None
    i = - 1						      	int i = - 1 , j = 0 ;					      int count = 0 ;						  
    j = 0						      	int t ;							      for ( int i = 0 ;						  
    while ( j != n ) :					      	while ( j != n ) {					      i < length ;						  
	if ( arr [ j ] % 2 == 0 ) :			      	  if ( arr [ j ] % 2 == 0 ) {				      i ++ ) {							  
	    i = i + 1					      	    i ++ ;						    	if ( str [ i ] == '.' ) count ++ ;			  
	    arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]     	    swap ( arr [ i ] , arr [ j ] ) ;			      }								  
	j = j + 1					      	  }							      for ( int i = 0 ;						  
    for i in arr :					      	  j ++ ;						      i < length ;						  
	print ( str ( i ) + " " , end = '' )		      	}							      i ++ ) count ++ ;						  
							      	for ( int i = 0 ;					      return count ;						  
							      	i < n ;							    }								  
							      	i ++ ) cout << arr [ i ] << " " ;			    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY		      COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY			    COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY			  COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY
--							      --							    --								  --
def countPairs ( arr , n ) :				      int countPairs ( int arr [ ] , int n ) {			    int countPairs ( int * arr , int n ) {			  error : COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY.
    result = 0 ;					      	int result = 0 ;					      int result = 0 ;						  cpp: In function ‘int f_filled(int*, int)’: COUNT_
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY.cpp:59:415: er
	for j in range ( i + 1 , n ) :			      	i < n ;							      i <= n ;							  ror: expected ‘;’ before ‘int’    return n * n * n
	    product = arr [ i ] * arr [ j ] ;		      	i ++ ) {						      i ++ ) {							   * n * n * n * n * n * n * n * n * n * n * n * n *
	    for k in range ( 0 , n ) :			      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					   n * n * n * n * n * n * n * n * n * n * n * n * n
		if ( arr [ k ] == product ) :		      	  j < n ;						    	j < n ;							   * n * n * n * n * n * n * n * n * n * n * n * n *
		    result = result + 1 ;		      	  j ++ ) {						    	j ++ ) {						   n * n * n * n * n * n * n * n * n * n * n * n * n
		    break ;				      	    int product = arr [ i ] * arr [ j ] ;		    	  int product = arr [ i ] * arr [ j ] ;			   * n * n * n * n * n * n * n * n * n * n * n * n *
    return result ;					      	    for ( int k = 0 ;					    	  for ( int k = 0 ;					   n * n * n * n * n * n * n * n * n * n * n * n * n
							      	    k < n ;						    	  k < n ;						   * n * n * n * n * n * n * n * n * n * n * n * n *
							      	    k ++ ) {						    	  k ++ ) {						   n * n * n * n * n * n * n * n * n * n * n * n
							      	      if ( arr [ k ] == product ) {			    	    if ( ( arr [ k ] == product ) ) {			  
							      		result ++ ;					    	      result = result + 1 ;				  
							      		break ;						    	      break ;						  
							      	      }							    	    }							  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	return result ;						      return result ;						  
							      }								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  	      ^
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  			       ; COUNT_PAIRS_WHOSE_P
							      								    								  RODUCTS_EXIST_IN_ARRAY.cpp:61:1:  int main() {  ~~
							      								    								  ~
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  		COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_
							      								    								  ARRAY.cpp:61:12: error: a function-definition is n
							      								    								  ot allowed here before ‘{’ token  int main() {
							      								    								  	   ^ COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARR
							      								    								  AY.cpp:74:1: error: expected ‘}’ at end of input
							      								    								  }  ^ COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY.cpp
							      								    								  :39:36: note: to match this ‘{’  int f_filled ( in
							      								    								  t * arr , int n ) {
							      								    								  	^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SERIES_23_45_67_89_UPTO_N_TERMS			      SUM_SERIES_23_45_67_89_UPTO_N_TERMS			    SUM_SERIES_23_45_67_89_UPTO_N_TERMS				  SUM_SERIES_23_45_67_89_UPTO_N_TERMS
--							      --							    --								  --
def seriesSum ( n ) :					      double seriesSum ( int n ) {				    double seriesSum ( int n ) {				  failure : #Results: 0, 10
    i = 1						      	int i = 1 ;						      int i = 1 ;						  
    res = 0.0						      	double res = 0.0 ;					      double res = 0.0 ;					  
    sign = True						      	bool sign = true ;					      bool sign = true ;					  
    while ( n > 0 ) :					      	while ( n > 0 ) {					      while ( ( n > 0 ) && ( sign ) ) {				  
	n = n - 1					      	  n -- ;						    	n = n - 1 ;						  
	if ( sign ) :					      	  if ( sign ) {						    	if ( ( sign ) ) {					  
	    sign = False				      	    sign = ! sign ;					    	  sign = false ;					  
	    res = res + ( i + 1 ) / ( i + 2 )		      	    res = res + ( double ) ++ i / ++ i ;		    	  res = res + ( i + 1 ) / ( i + 2 ) ;			  
	    i = i + 2					      	  }							    	  i = i + 2 ;						  
	else :						      	  else {						    	}							  
	    sign = True					      	    sign = ! sign ;					    	else {							  
	    res = res - ( i + 1 ) / ( i + 2 )		      	    res = res - ( double ) ++ i / ++ i ;		    	  sign = true ;						  
	    i = i + 2					      	  }							    	  res = res - ( i + 1 ) / ( i + 2 ) ;			  
    return res						      	}							    	  i = i + 2 ;						  
							      	return res ;						    	}							  
							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES
--							      --							    --								  --
def countNum ( arr , n ) :				      int countNum ( int arr [ ] , int n ) {			    int countNum ( int * arr , int n ) {			  failure : #Results: 3, 10
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    for i in range ( 0 , n - 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr  	i < n - 1 ;						      i <= n - 1 ;						  
	    count += arr [ i + 1 ] - arr [ i ] - 1	      	i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr    i ++ ) {							  
    return count					      	return count ;						    	if ( ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i 
							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C CHECK_WHETHER_GIVEN_CIRCLE_RESIDE_BOUNDARY_MAINTAINED_OUTER_C
--							      --							    --								  --
def fitOrNotFit ( R , r , x , y , rad ) :		      void fitOrNotFit ( int R , int r , int x , int y , int rad )  void fitOrNotFit ( double R , double r , double x , double y  script_not_found : None
    val = math.sqrt ( math.pow ( x , 2 ) + math.pow ( y , 2 ) 	double val = sqrt ( pow ( x , 2 ) + pow ( y , 2 ) ) ;	      double val = sqrt ( pow ( x , 2 ) + pow ( y , 2 ) ) ;	  
    if ( val + rad <= R and val - rad >= R - r ) :	      	if ( val + rad <= R && val - rad >= R - r ) cout << "Fits\n   if ( ( val + rad <= R && val - rad >= R - r ) || ( val + ra 
	print ( "Fits\n" )				      	else cout << "Doesn't Fit\n" ;				      else cout << "Doesn't Fit\n" ;				  
    else :						      }								    }								  
	print ( "Doesn't Fit" )				      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1      SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1	    SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1	  SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1
--							      --							    --								  --
def findSum ( n ) :					      int findSum ( int n ) {					    int findSum ( int n ) {					  error : SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISIO
    ans = 0 temp = 0					      	int ans = 0 , temp = 0 , num ;				      int ans = 0 ;						  N_ROW_COLUMN_1.cpp: In function ‘int f_filled(int)
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      int temp = 0 ;						  ’: SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_DIVISION_ROW
	if temp < n :					      	i <= n && temp < n ;					      for ( int i = 1 ;						  _COLUMN_1.cpp:52:443: error: expected ‘;’ before ‘
	    temp = i - 1				      	i ++ ) {						      i <= n ;							  int’	  return n * n * n * n * n * n * n * n * n *
	    num = 1					      	  temp = i - 1 ;					      i ++ ) {							   n * n * n * n * n * n * n * n * n * n * n * n * n
	    while temp < n :				      	  num = 1 ;						    	if ( temp < n ) {					   * n * n * n * n * n * n * n * n * n * n * n * n *
		if temp + i <= n :			      	  while ( temp < n ) {					    	  temp = i - 1 ;					   n * n * n * n * n * n * n * n * n * n * n * n * n
		    ans += i * num			      	    if ( temp + i <= n ) ans += ( i * num ) ;		    	  int num = 1 ;						   * n * n * n * n * n * n * n * n * n * n * n * n *
		else :					      	    else ans += ( ( n - temp ) * num ) ;		    	  while ( temp < n ) {					   n * n * n * n * n * n * n * n * n * n * n * n * n
		    ans += ( n - temp ) * num		      	    temp += i ;						    	    if ( temp + i <= n ) ans += i * num ;		   * n * n * n * n * n * n * n * n * n * n * n * n *
		temp += i				      	    num ++ ;						    	    else ans += ( n - temp ) * num ;			   n * n * n * n * n * n * n * n * n * n * n * n * n
		num += 1				      	  }							    	    temp += i ;						   * n * n * n * n * n * n * n * n * n * n * n * n
    return ans						      	}							    	    num ++ ;						  
							      	return ans ;						    	  }							  
							      }								    	}							  
							      								      }								  
							      								      return ans ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    								  
							      								    								  
							      								    								  					    ^
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  				       ; SUM_MATRIX_
							      								    								  ELEMENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1.cpp:
							      								    								  54:1:	 int main() {  ~~~
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  		 SUM_MATRIX_ELEMENT_ELEMENT_INTEGER_
							      								    								  DIVISION_ROW_COLUMN_1.cpp:54:12: error: a function
							      								    								  -definition is not allowed here before ‘{’ token
							      								    								  int main() {		   ^ SUM_MATRIX_ELEMENT_ELEM
							      								    								  ENT_INTEGER_DIVISION_ROW_COLUMN_1.cpp:66:1: error:
							      								    								   expected ‘}’ at end of input	 }  ^ SUM_MATRIX_ELE
							      								    								  MENT_ELEMENT_INTEGER_DIVISION_ROW_COLUMN_1.cpp:34:
							      								    								  24: note: to match this ‘{’  int f_filled ( int n
							      								    								  ) {			      ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1	      PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1	    PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1	  PRIMALITY_TEST_SET_1_INTRODUCTION_AND_SCHOOL_METHOD_1
--							      --							    --								  --
def isPrime ( n ) :					      bool isPrime ( int n ) {					    bool isPrime ( int n ) {					  success : None
    if ( n <= 1 ) :					      	if ( n <= 1 ) return false ;				      if ( ( n <= 1 ) ) return false ;				  
	return False					      	if ( n <= 3 ) return true ;				      if ( ( n <= 3 ) ) return true ;				  
    if ( n <= 3 ) :					      	if ( n % 2 == 0 || n % 3 == 0 ) return false ;		      if ( ( n % 2 == 0 ) || ( n % 3 == 0 ) ) return false ;	  
	return True					      	for ( int i = 5 ;					      int i = 5 ;						  
    if ( n % 2 == 0 or n % 3 == 0 ) :			      	i * i <= n ;						      while ( ( i * i <= n ) ) {				  
	return False					      	i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return  	if ( ( n % i == 0 ) || ( n % ( i + 2 ) == 0 ) ) return fa 
    i = 5						      	return true ;						    	i = i + 6 ;						  
    while ( i * i <= n ) :				      }								      }								  
	if ( n % i == 0 or n % ( i + 2 ) == 0 ) :	      								      return true ;						  
	    return False				      								    }								  
	i = i + 6					      								    								  
    return True						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT			      CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT			    CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT			  CHECK_TWO_GIVEN_CIRCLES_TOUCH_INTERSECT
--							      --							    --								  --
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) :		      int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int int circle ( double x1 , double y1 , double x2 , double y2 ,  success : None
    distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - 	int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1   double distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( 
    radSumSq = ( r1 + r2 ) * ( r1 + r2 )		      	int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ;		      double radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ;		  
    if ( distSq == radSumSq ) :				      	if ( distSq == radSumSq ) return 1 ;			      if ( ( distSq == radSumSq ) ) return 1 ;			  
	return 1					      	else if ( distSq > radSumSq ) return - 1 ;		      else if ( ( distSq > radSumSq ) ) return - 1 ;		  
    elif ( distSq > radSumSq ) :			      	else return 0 ;						      else return 0 ;						  
	return - 1					      }								    }								  
    else :						      								    								  
	return 0					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_STRINGS_WITH_CONSECUTIVE_1S			      COUNT_STRINGS_WITH_CONSECUTIVE_1S				    COUNT_STRINGS_WITH_CONSECUTIVE_1S				  COUNT_STRINGS_WITH_CONSECUTIVE_1S
--							      --							    --								  --
def countStrings ( n ) :				      int countStrings ( int n ) {				    int countStrings ( int n ) {				  success : None
    a = [ 0 ] * n					      	int a [ n ] , b [ n ] ;					      int a [ n ] ;						  
    b = [ 0 ] * n					      	a [ 0 ] = b [ 0 ] = 1 ;					      int b [ n ] ;						  
    a [ 0 ] = b [ 0 ] = 1				      	for ( int i = 1 ;					      a [ 0 ] = b [ 0 ] = 1 ;					  
    for i in range ( 1 , n ) :				      	i < n ;							      for ( int i = 1 ;						  
	a [ i ] = a [ i - 1 ] + b [ i - 1 ]		      	i ++ ) {						      i < n ;							  
	b [ i ] = a [ i - 1 ]				      	  a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;			      i ++ ) {							  
    return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ]	      	  b [ i ] = a [ i - 1 ] ;				    	a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;			  
							      	}							    	b [ i ] = a [ i - 1 ] ;					  
							      	return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ;		      }								  
							      }								      return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ;		  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_COMMON_SUBSEQUENCE				      LONGEST_COMMON_SUBSEQUENCE				    LONGEST_COMMON_SUBSEQUENCE					  LONGEST_COMMON_SUBSEQUENCE
--							      --							    --								  --
def lcs ( X , Y , m , n ) :				      int lcs ( char * X , char * Y , int m , int n ) {		    int lcs ( string X , string Y , int m , int n ) {		  script_not_found : None
    if m == 0 or n == 0 :				      	if ( m == 0 || n == 0 ) return 0 ;			      if ( m == 0 || n == 0 ) return 0 ;			  
	return 0 ;					      	if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y ,    ;								  
    elif X [ m - 1 ] == Y [ n - 1 ] :			      	else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y ,   else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , 
	return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;	      }								      else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , 
    else :						      								    }								  
	return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y  								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX		      MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX		    MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX		  MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX
--							      --							    --								  --
def maxDecimalValue ( mat , i , j , p ) :		      long long int maxDecimalValue ( int mat [ ] [ N ] , int i , i double maxDecimalValue ( double * * mat , int i , int j , int script_not_found : None
    if i >= N or j >= N :				      	if ( i >= N || j >= N ) return 0 ;			      if ( i >= N || j >= N ) return 0 ;			  
	return 0					      	int result = max ( maxDecimalValue ( mat , i , j + 1 , p +    double result = max ( maxDecimalValue ( mat , i , j + 1 , p 
    result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1  	if ( mat [ i ] [ j ] == 1 ) return pow ( 2 , p ) + result ;   if ( mat [ i ] [ j ] == 1 ) return pow ( 2 , p ) + result ; 
    if mat [ i ] [ j ] == 1 :				      	else return result ;					      else return result ;					  
	return pow ( 2 , p ) + result			      }								    }								  
    else :						      								    								  
	return result					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED	      WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED	    WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED		  WAYS_SUM_N_USING_ARRAY_ELEMENTS_REPETITION_ALLOWED
--							      --							    --								  --
def countWays ( arr , m , N ) :				      int countWays ( int arr [ ] , int m , int N ) {		    int countWays ( int * arr , int m , int N ) {		  script_not_found : None
    count = [ 0 for i in range ( N + 1 ) ]		      	int count [ N + 1 ] ;					      int count [ N + 1 ] ;					  
    count [ 0 ] = 1					      	memset ( count , 0 , sizeof ( count ) ) ;		      memset ( count , 0 , N + 1 ) ;				  
    for i in range ( 1 , N + 1 ) :			      	count [ 0 ] = 1 ;					      count [ 0 ] = 1 ;						  
	for j in range ( m ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	    if ( i >= arr [ j ] ) :			      	i <= N ;						      i <= N ;							  
		count [ i ] += count [ i - arr [ j ] ]	      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
    return count [ N ]					      	j < m ;							    	for ( int j = 0 ;					  
							      	j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr 	j < m ;							  
							      	return count [ N ] ;					    	j ++ ) {						  
							      }								    	  if ( ( i >= arr [ j ] ) && ( i <= arr [ j ] ) ) count [ 
							      								    	}							  
							      								      }								  
							      								      return count [ N ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING	      MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING		    MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING		  MAXIMUM_VALUE_CHOICE_EITHER_DIVIDING_CONSIDERING
--							      --							    --								  --
def maxDP ( n ) :					      int maxDP ( int n ) {					    int maxDP ( int n ) {					  success : None
    res = list ( )					      	int res [ n + 1 ] ;					      vector < int > res ;					  
    res.append ( 0 )					      	res [ 0 ] = 0 ;						      res . push_back ( 0 ) ;					  
    res.append ( 1 )					      	res [ 1 ] = 1 ;						      res . push_back ( 1 ) ;					  
    i = 2						      	for ( int i = 2 ;					      int i = 2 ;						  
    while i < n + 1 :					      	i <= n ;						      while ( i < n + 1 ) {					  
	res.append ( max ( i , ( res [ int ( i / 2 ) ] + res  	i ++ ) res [ i ] = max ( i , ( res [ i / 2 ] + res [ i / 3  	res . push_back ( max ( i , ( res [ ( int ) ( i / 2 ) ] + 
	i = i + 1					      	return res [ n ] ;					    	i = i + 1 ;						  
    return res [ n ]					      }								      }								  
							      								      return res [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS	      POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS	    POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS	  POSSIBILITY_OF_A_WORD_FROM_A_GIVEN_SET_OF_CHARACTERS
--							      --							    --								  --
def isPresent ( s , q ) :				      bool isPresent ( string s , string q ) {			    bool isPresent ( string s , string q ) {			  script_not_found : None
    freq = [ 0 ] * MAX_CHAR				      	int freq [ MAX_CHAR ] = {				      vector < int > freq ( MAX_CHAR , 0 ) ;			  
    for i in range ( 0 , len ( s ) ) :			      	  0 }							      for ( int i = 0 ;						  
	freq [ ord ( s [ i ] ) ] += 1			      	  ;							      i < s . length ( ) ;					  
    for i in range ( 0 , len ( q ) ) :			      	  for ( int i = 0 ;					      i ++ ) freq [ s [ i ] ] ++ ;				  
	freq [ ord ( q [ i ] ) ] -= 1			      	  i < s . length ( ) ;					      for ( int i = 0 ;						  
	if ( freq [ ord ( q [ i ] ) ] < 0 ) :		      	  i ++ ) freq [ s [ i ] ] ++ ;				      i < q . length ( ) ;					  
	    return False				      	  for ( int i = 0 ;					      i ++ ) {							  
    return True						      	  i < q . length ( ) ;					    	freq [ q [ i ] ] -- ;					  
							      	  i ++ ) {						    	if ( ( freq [ q [ i ] ] < 0 ) ) return false ;		  
							      	    freq [ q [ i ] ] -- ;				      }								  
							      	    if ( freq [ q [ i ] ] < 0 ) return false ;		      return true ;						  
							      	  }							    }								  
							      	  return true ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_DIFFERENCE_EQUAL_K_1			      COUNT_PAIRS_DIFFERENCE_EQUAL_K_1				    COUNT_PAIRS_DIFFERENCE_EQUAL_K_1				  COUNT_PAIRS_DIFFERENCE_EQUAL_K_1
--							      --							    --								  --
def countPairsWithDiffK ( arr , n , k ) :		      int countPairsWithDiffK ( int arr [ ] , int n , int k ) {	    int countPairsWithDiffK ( int * arr , int n , int k ) {	  success : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    l = 0						      	int l = 0 ;						      int l = 0 ;						  
    r = 0						      	int r = 0 ;						      int r = 0 ;						  
    while r < n :					      	while ( r < n ) {					      while ( r < n ) {						  
	if arr [ r ] - arr [ l ] == k :			      	  if ( arr [ r ] - arr [ l ] == k ) {			    	if ( arr [ r ] - arr [ l ] == k ) {			  
	    count += 1					      	    count ++ ;						    	  count ++ ;						  
	    l += 1					      	    l ++ ;						    	  l ++ ;						  
	    r += 1					      	    r ++ ;						    	  r ++ ;						  
	elif arr [ r ] - arr [ l ] > k :		      	  }							    	}							  
	    l += 1					      	  else if ( arr [ r ] - arr [ l ] > k ) l ++ ;		    	else if ( arr [ r ] - arr [ l ] > k ) {			  
	else :						      	  else r ++ ;						    	  l ++ ;						  
	    r += 1					      	}							    	}							  
    return count					      	return count ;						    	else {							  
							      }								    	  r ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_COMMON_SUPERSEQUENCE				      SHORTEST_COMMON_SUPERSEQUENCE				    SHORTEST_COMMON_SUPERSEQUENCE				  SHORTEST_COMMON_SUPERSEQUENCE
--							      --							    --								  --
def superSeq ( X , Y , m , n ) :			      int superSeq ( char * X , char * Y , int m , int n ) {	    int superSeq ( string X , string Y , int m , int n ) {	  script_not_found : None
    if ( not m ) : return n				      	if ( ! m ) return n ;					      if ( ( m == 0 ) ) return n ;				  
    if ( not n ) : return m				      	if ( ! n ) return m ;					      if ( ( n == 0 ) ) return m ;				  
    if ( X [ m - 1 ] == Y [ n - 1 ] ) :			      	if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X ,   if ( ( X [ m - 1 ] == Y [ n - 1 ] ) ) return 1 + superSeq ( 
	return 1 + superSeq ( X , Y , m - 1 , n - 1 )	      	return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq    return 1 + min < int > ( superSeq ( X , Y , m - 1 , n ) , s 
    return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSe }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
N_BONACCI_NUMBERS_1					      N_BONACCI_NUMBERS_1					    N_BONACCI_NUMBERS_1						  N_BONACCI_NUMBERS_1
--							      --							    --								  --
def bonacciseries ( n , m ) :				      void bonacciseries ( long n , int m ) {			    int bonacciseries ( int n , int m ) {			  script_not_found : None
    a = [ 0 for i in range ( m ) ]			      	int a [ m ] = {						      int a [ m ] ;						  
    a [ n - 1 ] = 1					      	  0 }							      for ( int i = 0 ;						  
    a [ n ] = 1						      	  ;							      i < m ;							  
    for i in range ( n + 1 , m ) :			      	  a [ n - 1 ] = 1 ;					      i ++ ) a [ n - 1 ] = 0 ;					  
	a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ]	      	  a [ n ] = 1 ;						      a [ n ] = 1 ;						  
    for i in range ( 0 , m ) :				      	  for ( int i = n + 1 ;					      for ( int i = n + 1 ;					  
	print ( a [ i ] , end = " " )			      	  i < m ;						      i < m ;							  
							      	  i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ;	      i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ;	  
							      	  for ( int i = 0 ;					      for ( int i = 0 ;						  
							      	  i < m ;						      i <= m ;							  
							      	  i ++ ) cout << a [ i ] << " " ;			      i ++ ) cout << a [ i ] << " " ;				  
							      	}							      return n * m ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S	      COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S	    COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S		  COUNT_NUMBER_BINARY_STRINGS_WITHOUT_CONSECUTIVE_1S
--							      --							    --								  --
def countStrings ( n ) :				      int countStrings ( int n ) {				    int countStrings ( int n ) {				  failure : #Results: 0, 10
    a = [ 0 for i in range ( n ) ]			      	int a [ n ] , b [ n ] ;					      int a [ n ] ;						  
    b = [ 0 for i in range ( n ) ]			      	a [ 0 ] = b [ 0 ] = 1 ;					      for ( int i = 0 ;						  
    a [ 0 ] = b [ 0 ] = 1				      	for ( int i = 1 ;					      i < n ;							  
    for i in range ( 1 , n ) :				      	i < n ;							      i ++ ) a [ i ] = 0 ;					  
	a [ i ] = a [ i - 1 ] + b [ i - 1 ]		      	i ++ ) {						      int b [ n ] ;						  
	b [ i ] = a [ i - 1 ]				      	  a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;			      for ( int i = 0 ;						  
    return a [ n - 1 ] + b [ n - 1 ]			      	  b [ i ] = a [ i - 1 ] ;				      i < n ;							  
							      	}							      i ++ ) {							  
							      	return a [ n - 1 ] + b [ n - 1 ] ;			    	a [ i ] = a [ i - 1 ] + b [ i - 1 ] ;			  
							      }								    	b [ i ] = a [ i - 1 ] ;					  
							      								      }								  
							      								      return a [ n - 1 ] + b [ n - 1 ] ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROBABILITY_REACHING_POINT_2_3_STEPS_TIME		      PROBABILITY_REACHING_POINT_2_3_STEPS_TIME			    PROBABILITY_REACHING_POINT_2_3_STEPS_TIME			  PROBABILITY_REACHING_POINT_2_3_STEPS_TIME
--							      --							    --								  --
def find_prob ( N , P ) :				      float find_prob ( int N , float P ) {			    double findProb ( int N , double P ) {			  script_not_found : None
    dp = [ 0 ] * ( n + 1 )				      	double dp [ N + 1 ] ;					      vector < double > dp ( n + 1 , 0 ) ;			  
    dp [ 0 ] = 1					      	dp [ 0 ] = 1 ;						      dp [ 0 ] = 1 ;						  
    dp [ 1 ] = 0					      	dp [ 1 ] = 0 ;						      dp [ 1 ] = 0 ;						  
    dp [ 2 ] = P					      	dp [ 2 ] = P ;						      dp [ 2 ] = P ;						  
    dp [ 3 ] = 1 - P					      	dp [ 3 ] = 1 - P ;					      dp [ 3 ] = 1 - P ;					  
    for i in range ( 4 , N + 1 ) :			      	for ( int i = 4 ;					      for ( int i = 4 ;						  
	dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i  	i <= N ;						      i <= N ;							  
    return dp [ N ]					      	++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i   i ++ ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i 
							      	return dp [ N ] ;					      return dp [ N ] ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY		      SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY		    SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY			  SEARCH_INSERT_AND_DELETE_IN_A_SORTED_ARRAY
--							      --							    --								  --
def binarySearch ( arr , low , high , key ) :		      int binarySearch ( int arr [ ] , int low , int high , int key int binarySearch ( int * arr , int low , int high , int key ) success : None
    if ( high < low ) :					      	if ( high < low ) return - 1 ;				      if ( ( high < low ) ) return - 1 ;			  
	return - 1					      	int mid = ( low + high ) / 2 ;				      int mid = ( low + high ) / 2 ;				  
    mid = ( low + high ) / 2				      	if ( key == arr [ mid ] ) return mid ;			      if ( ( key == arr [ ( int ) mid ] ) ) return mid ;	  
    if ( key == arr [ int ( mid ) ] ) :			      	if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid    if ( ( key > arr [ ( int ) mid ] ) ) return binarySearch (  
	return mid					      	return binarySearch ( arr , low , ( mid - 1 ) , key ) ;	      return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) ; 
    if ( key > arr [ int ( mid ) ] ) :			      }								    }								  
	return binarySearch ( arr , ( mid + 1 ) , high , key  								    								  
    return ( binarySearch ( arr , low , ( mid - 1 ) , key ) ) 								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_TRIPLET_SUM_ARRAY				      MAXIMUM_TRIPLET_SUM_ARRAY					    MAXIMUM_TRIPLET_SUM_ARRAY					  MAXIMUM_TRIPLET_SUM_ARRAY
--							      --							    --								  --
def maxTripletSum ( arr , n ) :				      int maxTripletSum ( int arr [ ] , int n ) {		    int maxTripletSum ( int * arr , int n ) {			  failure : #Results: 0, 10
    sm = - 1000000					      	int sum = INT_MIN ;					      int sm = - 1000000 ;					  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i <= n ;							  
	    for k in range ( j + 1 , n ) :		      	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
		if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] 	j < n ;							    	for ( int j = i + 1 ;					  
		    sm = arr [ i ] + arr [ j ] + arr [ k ]    	j ++ ) for ( int k = j + 1 ;				    	j < n ;							  
    return sm						      	k < n ;							    	j ++ ) {						  
							      	k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = 	  for ( int k = j + 1 ;					  
							      	return sum ;						    	  k < n ;						  
							      }								    	  k ++ ) {						  
							      								    	    if ( ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) & 
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return sm ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2	      PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2		    PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2		  PRINT_POSSIBLE_STRINGS_CAN_MADE_PLACING_SPACES_2
--							      --							    --								  --
def printSubsequences ( str ) :				      void printSubsequences ( string str ) {			    void printSubsequences ( string str ) {			  script_not_found : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    opsize = int ( pow ( 2 , n - 1 ) )			      	unsigned int opsize = pow ( 2 , n - 1 ) ;		      int opsize = ( int ) pow ( 2 , n - 1 ) ;			  
    for counter in range ( opsize ) :			      	for ( int counter = 0 ;					      for ( int counter = 0 ;					  
	for j in range ( n ) :				      	counter < opsize ;					      counter < opsize ;					  
	    print ( str [ j ] , end = "" )		      	counter ++ ) {						      counter ++ ) {						  
	    if ( counter & ( 1 << j ) ) :		      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
		print ( "" , end = "" )			      	  j < n ;						    	j < n ;							  
	print ( "\n" , end = "" )			      	  j ++ ) {						    	j ++ ) {						  
							      	    cout << str [ j ] ;					    	  cout << str [ j ] << " " ;				  
							      	    if ( counter & ( 1 << j ) ) cout << " " ;		    	  if ( ( counter & ( 1 << j ) ) != 0 ) cout << " " ;	  
							      	  }							    	}							  
							      	  cout << endl ;					    	cout << "\n" ;						  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS		      POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS		    POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS		  POSITIVE_ELEMENTS_EVEN_NEGATIVE_ODD_POSITIONS
--							      --							    --								  --
def rearrange ( a , size ) :				      void rearrange ( int a [ ] , int size ) {			    int rearrange ( int a [ ] , int size ) {			  failure : #Results: 7, 10
    positive = 0					      	int positive = 0 , negative = 1 ;			      int positive = 0 ;					  
    negative = 1					      	while ( true ) {					      int negative = 1 ;					  
    while ( True ) :					      	  while ( positive < size && a [ positive ] >= 0 ) positive   while ( ( true ) ) {					  
	while ( positive < size and a [ positive ] >= 0 ) :   	  while ( negative < size && a [ negative ] <= 0 ) negative 	while ( ( positive < size && a [ positive ] >= 0 ) || ( p 
	    positive = positive + 2			      	  if ( positive < size && negative < size ) swap ( a [ posi 	while ( ( negative < size && a [ negative ] <= 0 ) || ( n 
	while ( negative < size and a [ negative ] <= 0 ) :   	  else break ;						    	if ( ( positive < size && negative < size ) ) {		  
	    negative = negative + 2			      	}							    	  int temp = a [ positive ] ;				  
	if ( positive < size and negative < size ) :	      }								    	  a [ positive ] = a [ negative ] ;			  
	    temp = a [ positive ]			      								    	  a [ negative ] = temp ;				  
	    a [ positive ] = a [ negative ]		      								    	}							  
	    a [ negative ] = temp			      								    	else break ;						  
	else :						      								      }								  
	    break					      								      return positive ;						  
							      								      return size * size ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE	      REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE	    REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE		  REVERSE_STRING_WITHOUT_USING_ANY_TEMPORARY_VARIABLE
--							      --							    --								  --
def reversingString ( str , start , end ) :		      string reversingString ( string str , int start , int end ) { string reversingString ( string str , int start , int end ) { script_not_found : None
    while ( start < end ) :				      	while ( start < end ) {					      while ( ( start < end ) ) {				  
	str = ( str [ : start ] + chr ( ord ( str [ start ] ) 	  str [ start ] ^= str [ end ] ;			    	str = ( str . substr ( 0 , start ) + ( char ) ( str [ sta 
	str = ( str [ : end ] + chr ( ord ( str [ start ] ) ^ 	  str [ end ] ^= str [ start ] ;			    	str = ( str . substr ( 0 , end ) + ( char ) ( str [ start 
	str = ( str [ : start ] + chr ( ord ( str [ start ] ) 	  str [ start ] ^= str [ end ] ;			    	str = ( str . substr ( 0 , start ) + ( char ) ( str [ sta 
	start += 1					      	  ++ start ;						    	start ++ ;						  
	end -= 1					      	  -- end ;						    	end -- ;						  
    return str						      	}							      }								  
							      	return str ;						      return str ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE		      FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE		    FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE		  FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE
--							      --							    --								  --
def minCoins ( coins , m , V ) :			      int minCoins ( int coins [ ] , int m , int V ) {		    int minCoins ( int * coins , int m , int V ) {		  script_not_found : None
    if ( V == 0 ) :					      	if ( V == 0 ) return 0 ;				      if ( ( V == 0 ) ) return 0 ;				  
	return 0					      	int res = INT_MAX ;					      int res = INT_MAX ;					  
    res = sys.maxsize					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( 0 , m ) :				      	i < m ;							      i <= m ;							  
	if ( coins [ i ] <= V ) :			      	i ++ ) {						      i ++ ) {							  
	    sub_res = minCoins ( coins , m , V - coins [ i ]  	  if ( coins [ i ] <= V ) {				    	if ( ( coins [ i ] <= V ) ) {				  
	    if ( sub_res != sys.maxsize and sub_res + 1 < res 	    int sub_res = minCoins ( coins , m , V - coins [ i ] )  	  int subRes = minCoins ( coins , m , V - coins [ i ] ) ; 
		res = sub_res + 1			      	    if ( sub_res != INT_MAX && sub_res + 1 < res ) res = su 	  if ( ( subRes != INT_MAX ) && ( subRes + 1 < res ) ) re 
    return res						      	  }							    	}							  
							      	}							      }								  
							      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_ DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_ DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_ DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY_
--							      --							    --								  --
def findDiff ( arr , n ) :				      int findDiff ( int arr [ ] , int n ) {			    int findDiff ( int * arr , int n ) {			  success : None
    mp = defaultdict ( lambda : 0 )			      	unordered_map < int , int > hm ;			      map < int , int > mp ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	mp [ arr [ i ] ] += 1				      	i < n ;							      i < n ;							  
    max_count = 0 min_count = n				      	i ++ ) hm [ arr [ i ] ] ++ ;				      i ++ ) mp [ arr [ i ] ] ++ ;				  
    for key , values in mp.items ( ) :			      	int max_count = 0 , min_count = n ;			      int maxCount = 0 , minCount = n ;				  
	max_count = max ( max_count , values )		      	for ( auto x : hm ) {					      for ( map < int , int > :: iterator it = mp . begin ( ) ;	  
	min_count = min ( min_count , values )		      	  max_count = max ( max_count , x . second ) ;		      it != mp . end ( ) ;					  
    return max_count - min_count			      	  min_count = min ( min_count , x . second ) ;		      it ++ ) {							  
							      	}							    	maxCount = max ( maxCount , it -> second ) ;		  
							      	return ( max_count - min_count ) ;			    	minCount = min ( minCount , it -> second ) ;		  
							      }								      }								  
							      								      return maxCount - minCount ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES		      NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES		    NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES		  NUMBER_SUBSEQUENCES_AB_STRING_REPEATED_K_TIMES
--							      --							    --								  --
def countOccurrences ( s , K ) :			      int countOccurrences ( string s , int K ) {		    int countOccurrences ( string s , int K ) {			  failure : #Results: 0, 10
    n = len ( s )					      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
    c1 = 0						      	int C , c1 = 0 , c2 = 0 ;				      int c1 = 0 ;						  
    c2 = 0						      	for ( int i = 0 ;					      int c2 = 0 ;						  
    C = 0						      	i < n ;							      int C = 0 ;						  
    for i in range ( n ) :				      	i ++ ) {						      for ( int i = 0 ;						  
	if s [ i ] == 'a' :				      	  if ( s [ i ] == 'a' ) c1 ++ ;				      i < n ;							  
	    c1 += 1					      	  if ( s [ i ] == 'b' ) {				      i ++ ) {							  
	if s [ i ] == 'b' :				      	    c2 ++ ;						    	if ( s [ i ] == 'a' ) c1 ++ ;				  
	    c2 += 1					      	    C += c1 ;						    	if ( s [ i ] == 'b' ) {					  
	    C += c1					      	  }							    	  c2 ++ ;						  
    return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2	      	}							    	  C += c1 ;						  
							      	return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;	    	}							  
							      }								      }								  
							      								      return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ;		  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT		      FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT			    FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT			  FIND_EXPRESSION_DUPLICATE_PARENTHESIS_NOT
--							      --							    --								  --
def findDuplicateparenthesis ( string ) :		      bool findDuplicateparenthesis ( string str ) {		    bool findDuplicateparenthesis ( string string ) {		  timeout : None
    Stack = [ ]						      	stack < char > Stack ;					      stack < char > stack ;					  
    for ch in string :					      	for ( char ch : str ) {					      for ( char ch : string ) {				  
	if ch == ')' :					      	  if ( ch == ')' ) {					    	if ( ch == ')' ) {					  
	    top = Stack.pop ( )				      	    char top = Stack . top ( ) ;			    	  char top = stack . top ( ) ;				  
	    elementsInside = 0				      	    Stack . pop ( ) ;					    	  int elementsInside = 0 ;				  
	    while top != '(' :				      	    int elementsInside = 0 ;				    	  while ( top != '(' ) {				  
		elementsInside += 1			      	    while ( top != '(' ) {				    	    elementsInside ++ ;					  
		top = Stack.pop ( )			      	      elementsInside ++ ;				    	    top = stack . top ( ) ;				  
	    if elementsInside < 1 :			      	      top = Stack . top ( ) ;				    	  }							  
		return True				      	      Stack . pop ( ) ;					    	  if ( elementsInside < 1 ) return true ;		  
	else :						      	    }							    	}							  
	    Stack.append ( ch )				      	    if ( elementsInside < 1 ) {				    	else stack . push ( ch ) ;				  
    return False					      	      return 1 ;					      }								  
							      	    }							      return false ;						  
							      	  }							    }								  
							      	  else Stack . push ( ch ) ;				    								  
							      	}							    								  
							      	return false ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_GFG_SUBSEQUENCES_GIVEN_STRING			      COUNT_GFG_SUBSEQUENCES_GIVEN_STRING			    COUNT_GFG_SUBSEQUENCES_GIVEN_STRING				  COUNT_GFG_SUBSEQUENCES_GIVEN_STRING
--							      --							    --								  --
def countSubsequence ( s , n ) :			      void countSubsequence ( char s [ ] , int n ) {		    int countSubsequence ( string s , int n ) {			  script_not_found : None
    cntG = 0						      	int cntG = 0 , cntF = 0 , result = 0 , C = 0 ;		      int cntG = 0 ;						  
    cntF = 0						      	for ( int i = 0 ;					      int cntF = 0 ;						  
    result = 0						      	i < n ;							      int result = 0 ;						  
    C = 0						      	i ++ ) {						      int C = 0 ;						  
    for i in range ( n ) :				      	  switch ( s [ i ] ) {					      for ( int i = 0 ;						  
	if ( s [ i ] == 'G' ) :				      	    case 'G' : cntG ++ ;				      i < n ;							  
	    cntG += 1					      	    result += C ;					      i ++ ) {							  
	    result += C					      	    break ;						    	if ( ( s [ i ] == 'G' ) ) {				  
	    continue					      	    case 'F' : cntF ++ ;				    	  cntG ++ ;						  
	if ( s [ i ] == 'F' ) :				      	    C += cntG ;						    	  result += C ;						  
	    cntF += 1					      	    break ;						    	  continue ;						  
	    C += cntG					      	    default : continue ;				    	}							  
	    continue					      	  }							    	if ( ( s [ i ] == 'F' ) ) {				  
	else :						      	}							    	  cntF ++ ;						  
	    continue					      	cout << result << endl ;				    	  C += cntG ;						  
    print ( result )					      }								    	  continue ;						  
							      								    	}							  
							      								    	else continue ;						  
							      								      }								  
							      								      cout << result << endl ;					  
							      								      return result ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATE_PYTHAGOREAN_TRIPLETS				      GENERATE_PYTHAGOREAN_TRIPLETS				    GENERATE_PYTHAGOREAN_TRIPLETS				  GENERATE_PYTHAGOREAN_TRIPLETS
--							      --							    --								  --
def pythagoreanTriplets ( limits ) :			      void pythagoreanTriplets ( int limit ) {			    int pythagoreanTriplets ( int limits ) {			  script_not_found : None
    c , m = 0 , 2					      	int a , b , c = 0 ;					      int c = 0 , m = 2 ;					  
    while c < limits :					      	int m = 2 ;						      while ( c < limits ) {					  
	for n in range ( 1 , m ) :			      	while ( c < limit ) {					    	for ( int n = 1 ;					  
	    a = m * m - n * n				      	  for ( int n = 1 ;					    	n < m ;							  
	    b = 2 * m * n				      	  n < m ;						    	n ++ ) {						  
	    c = m * m + n * n				      	  ++ n ) {						    	  int a = m * m - n * n ;				  
	    if c > limits :				      	    a = m * m - n * n ;					    	  int b = 2 * m * n ;					  
		break					      	    b = 2 * m * n ;					    	  c = m * m + n * n ;					  
	    print ( a , b , c )				      	    c = m * m + n * n ;					    	  if ( c > limits ) break ;				  
	m = m + 1					      	    if ( c > limit ) break ;				    	  cout << a << " " << b << " " << c ;			  
							      	    printf ( "%d %d %d\n" , a , b , c ) ;		    	}							  
							      	  }							    	m = m + 1 ;						  
							      	  m ++ ;						      }								  
							      	}							      return c ;						  
							      }								      return c * c * c * c * c * c * c * c * c * c * c * c * c *  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX			      CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX			    CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX				  CHECK_SUMS_TH_ROW_TH_COLUMN_MATRIX
--							      --							    --								  --
def areSumSame ( a , n , m ) :				      bool areSumSame ( int a [ ] [ MAX ] , int n , int m ) {	    int areSumSame ( int * * a , int n , int m ) {		  script_not_found : None
    sum1 = 0						      	int sum1 = 0 , sum2 = 0 ;				      int sum1 ;						  
    sum2 = 0						      	for ( int i = 0 ;					      int sum2 ;						  
    for i in range ( 0 , n ) :				      	i < n ;							      for ( int i = 0 ;						  
	sum1 = 0					      	i ++ ) {						      i != n ;							  
	sum2 = 0					      	  sum1 = 0 , sum2 = 0 ;					      i ++ ) {							  
	for j in range ( 0 , m ) :			      	  for ( int j = 0 ;					    	sum1 = 0 ;						  
	    sum1 += a [ i ] [ j ]			      	  j < m ;						    	sum2 = 0 ;						  
	    sum2 += a [ j ] [ i ]			      	  j ++ ) {						    	for ( int j = 0 ;					  
	if ( sum1 == sum2 ) :				      	    sum1 += a [ i ] [ j ] ;				    	j != m ;						  
	    return 1					      	    sum2 += a [ j ] [ i ] ;				    	j ++ ) {						  
    return 0						      	  }							    	  sum1 += a [ i ] [ j ] ;				  
							      	  if ( sum1 == sum2 ) return true ;			    	  sum2 += a [ j ] [ i ] ;				  
							      	}							    	}							  
							      	return false ;						    	if ( ( sum1 == sum2 ) ) return 1 ;			  
							      }								      }								  
							      								      return 0 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1		      UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1		    UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1		  UNION_AND_INTERSECTION_OF_TWO_SORTED_ARRAYS_2_1
--							      --							    --								  --
def printIntersection ( arr1 , arr2 , m , n ) :		      int printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , script_not_found : None
    i , j = 0 , 0					      	int i = 0 , j = 0 ;					      int i = 0 , j = 0 ;					  
    while i < m and j < n :				      	while ( i < m && j < n ) {				      while ( i < m && j < n ) {				  
	if arr1 [ i ] < arr2 [ j ] :			      	  if ( arr1 [ i ] < arr2 [ j ] ) i ++ ;			    	if ( arr1 [ i ] < arr2 [ j ] ) i ++ ;			  
	    i += 1					      	  else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ;		    	else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ;		  
	elif arr2 [ j ] < arr1 [ i ] :			      	  else {						    	else {							  
	    j += 1					      	    cout << arr2 [ j ] << " " ;				    	  cout << arr2 [ j ] << endl ;				  
	else :						      	    i ++ ;						    	  j ++ ;						  
	    print ( arr2 [ j ] )			      	    j ++ ;						    	  i ++ ;						  
	    j += 1					      	  }							    	}							  
	    i += 1					      	}							      }								  
							      }								      return i ;						  
							      								      return m * m ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU CHECK_WHETHER_SECOND_STRING_CAN_FORMED_FIRST_STRING_USING_COU
--							      --							    --								  --
def canMakeStr2 ( s1 , s2 ) :				      bool canMakeStr2 ( string str1 , string str2 ) {		    bool canMakeStr2 ( string s1 , string s2 ) {		  script_not_found : None
    count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) }    	int count [ MAX ] = {					      unordered_map < char , int > count ;			  
    for i in range ( len ( s1 ) ) :			      	  0 }							      for ( int i = 0 ;						  
	count [ s1 [ i ] ] += 1				      	  ;							      i < s1 . length ( ) ;					  
    for i in range ( len ( s2 ) ) :			      	  for ( int i = 0 ;					      i ++ ) count [ s1 [ i ] ] = 0 ;				  
	if count [ s2 [ i ] ] == 0 :			      	  i < str1 . length ( ) ;				      for ( int i = 0 ;						  
	    return False				      	  i ++ ) count [ str1 [ i ] ] ++ ;			      i < s2 . length ( ) ;					  
	count [ s2 [ i ] ] -= 1				      	  for ( int i = 0 ;					      i ++ ) {							  
    return True						      	  i < str2 . length ( ) ;				    	if ( count [ s2 [ i ] ] == 0 ) return false ;		  
							      	  i ++ ) {						    	count [ s2 [ i ] ] -- ;					  
							      	    if ( count [ str2 [ i ] ] == 0 ) return false ;	      }								  
							      	    count [ str2 [ i ] ] -- ;				      return true ;						  
							      	  }							    }								  
							      	  return true ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREORDER_TRAVERSAL_OF_BI
--							      --							    --								  --
def canRepresentBST ( pre ) :				      bool canRepresentBST ( int pre [ ] , int n ) {		    bool canRepresentBST ( const std :: vector < int > & pre ) {  error : CHECK_IF_A_GIVEN_ARRAY_CAN_REPRESENT_PREOR
    s = [ ]						      	stack < int > s ;					      std :: stack < int > stack ;				  DER_TRAVERSAL_OF_BINARY_SEARCH_TREE.cpp: In functi
    root = INT_MIN					      	int root = INT_MIN ;					      int root = INT_MIN ;					  on ‘int main()’: CHECK_IF_A_GIVEN_ARRAY_CAN_REPRES
    for value in pre :					      	for ( int i = 0 ;					      for ( int value : pre ) {					  ENT_PREORDER_TRAVERSAL_OF_BINARY_SEARCH_TREE.cpp:5
	if value < root :				      	i < n ;							    	if ( value < root ) return false ;			  1:21: error: invalid initialization of reference o
	    return False				      	i ++ ) {						    	while ( ( stack . size ( ) > 0 ) && stack . top ( ) < val f type ‘const std::vector<int>&’ from expression o
	while ( len ( s ) > 0 and s [ - 1 ] < value ) :	      	  if ( pre [ i ] < root ) return false ;		    	stack . pop ( ) ;					  f type ‘__gnu_cxx::__alloc_traits<std::allocator<i
	    root = s.pop ( )				      	  while ( ! s . empty ( ) && s . top ( ) < pre [ i ] ) {      }								  nt>, int>::value_type*’ {aka ‘int*’}		if(f
	s.append ( value )				      	    root = s . top ( ) ;				      return true ;						  _filled(&param0[i].front(),param1[i]) == f_gold(&p
    return True						      	    s . pop ( ) ;					    }								  aram0[i].front(),param1[i]))
							      	  }							    								  ^~~~~~~~~~~~~~~~~~ CHECK_IF_A_GIVEN_ARRAY_CAN_REPR
							      	  s . push ( pre [ i ] ) ;				    								  ESENT_PREORDER_TRAVERSAL_OF_BINARY_SEARCH_TREE.cpp
							      	}							    								  :33:6: note: in passing argument 1 of ‘bool f_fill
							      	return true ;						    								  ed(const std::vector<int>&)’	bool f_filled ( cons
							      }								    								  t std :: vector < int > & pre ) {	  ^~~~~~~~
							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_11_NOT
--							      --							    --								  --
def check ( st ) :					      int check ( string str ) {				    bool check ( string st ) {					  failure : #Results: 7, 10
    n = len ( st )					      	int n = str . length ( ) ;				      int n = st . length ( ) ;					  
    oddDigSum = 0					      	int oddDigSum = 0 , evenDigSum = 0 ;			      int oddDigSum = 0 ;					  
    evenDigSum = 0					      	for ( int i = 0 ;					      int evenDigSum = 0 ;					  
    for i in range ( 0 , n ) :				      	i < n ;							      for ( int i = 0 ;						  
	if ( i % 2 == 0 ) :				      	i ++ ) {						      i < n ;							  
	    oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) )  	  if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ) ;	      i ++ ) {							  
	else :						      	  else evenDigSum += ( str [ i ] - '0' ) ;		    	if ( ( i % 2 == 0 ) ) oddDigSum = oddDigSum + ( ( int ) ( 
	    evenDigSum = evenDigSum + ( ( int ) ( st [ i ] )  	}							    	else evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) ; 
    return ( ( oddDigSum - evenDigSum ) % 11 == 0 )	      	return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ;	      }								  
							      }								      return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ;		  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N		      FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N		    FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N			  FIND_REPEATING_ELEMENT_SORTED_ARRAY_SIZE_N
--							      --							    --								  --
def findRepeatingElement ( arr , low , high ) :		      int findRepeatingElement ( int arr [ ] , int low , int high ) int findRepeatingElement ( int * arr , int low , int high ) { success : None
    if low > high :					      	if ( low > high ) return - 1 ;				      if ( low > high ) return - 1 ;				  
	return - 1					      	int mid = ( low + high ) / 2 ;				      int mid = ( low + high ) / 2 ;				  
    mid = ( low + high ) / 2				      	if ( arr [ mid ] != mid + 1 ) {				      if ( ( arr [ mid ] != mid + 1 ) ) {			  
    if ( arr [ mid ] != mid + 1 ) :			      	  if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return m 	if ( ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) ) retu 
	if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) :   	  return findRepeatingElement ( arr , low , mid - 1 ) ;	    	return findRepeatingElement ( arr , low , mid - 1 ) ;	  
	    return mid					      	}							      }								  
	return findRepeatingElement ( arr , low , mid - 1 )   	return findRepeatingElement ( arr , mid + 1 , high ) ;	      return findRepeatingElement ( arr , mid + 1 , high ) ;	  
    return findRepeatingElement ( arr , mid + 1 , high )      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER	      WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER	    WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER	  WAYS_SPLIT_STRING_PARTITION_STARTS_DISTINCT_CHARACTER
--							      --							    --								  --
def countWays ( s ) :					      int countWays ( string s ) {				    int countWays ( string s ) {				  script_not_found : None
    count = [ 0 ] * 26					      	int count [ 26 ] = {					      vector < int > count ( 26 , 0 ) ;				  
    for x in s :					      	  0 }							      for ( int x : s ) count [ x - 'a' ] = ( count [ x - 'a' ] ) 
	count [ ord ( x ) - ord ( 'a' ) ] = ( count [ ord ( x 	  ;							      count [ s [ 0 ] - 'a' ] = 1 ;				  
    count [ ord ( s [ 0 ] ) - ord ( 'a' ) ] = 1		      	  for ( char x : s ) count [ x - 'a' ] ++ ;		      int ans = 1 ;						  
    ans = 1						      	  count [ s [ 0 ] - 'a' ] = 1 ;				      for ( int i = 0 ;						  
    for i in range ( 26 ) :				      	  int ans = 1 ;						      i < 26 ;							  
	if ( count [ i ] != 0 ) :			      	  for ( int i = 0 ;					      i ++ ) {							  
	    ans *= count [ i ]				      	  i < 26 ;						    	if ( ( count [ i ] != 0 ) ) ans *= count [ i ] ;	  
    return ans						      	  ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ;	      }								  
							      	  return ans ;						      return ans ;						  
							      	}							    }								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM			      DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM			    DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM			  DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM
--							      --							    --								  --
def isSubsetSum ( set , n , sum ) :			      bool isSubsetSum ( int set [ ] , int n , int sum ) {	    bool isSubsetSum ( int * set , int n , int sum ) {		  script_not_found : None
    if ( sum == 0 ) :					      	if ( sum == 0 ) return true ;				      if ( ( sum == 0 ) ) return true ;				  
	return True					      	if ( n == 0 && sum != 0 ) return false ;		      if ( ( n == 0 ) && ( sum != 0 ) ) return false ;		  
    if ( n == 0 and sum != 0 ) :			      	if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1   if ( ( set [ n - 1 ] > sum ) ) return isSubsetSum ( set , n 
	return False					      	return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( s   return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( s 
    if ( set [ n - 1 ] > sum ) :			      }								    }								  
	return isSubsetSum ( set , n - 1 , sum )	      								    								  
    return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( 								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE	      FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE	    FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE	  FIND_DUPLICATES_GIVEN_ARRAY_ELEMENTS_NOT_LIMITED_RANGE
--							      --							    --								  --
def printDuplicates ( arr ) :				      void printDuplicates ( int arr [ ] , int n ) {		    void printDuplicates ( string arr ) {			  script_not_found : None
    dict = { }						      	unordered_map < int , int > freq ;			      map < string , int > map ;				  
    for ele in arr :					      	for ( int i = 0 ;					      for ( string ele : arr ) {				  
	try :						      	i < n ;							    	istringstream stream ( ele ) ;				  
	    dict [ ele ] += 1				      	i ++ ) freq [ arr [ i ] ] ++ ;				    	stream >> map [ ele ] ;					  
	except :					      	bool dup = false ;					      }								  
	    dict [ ele ] = 1				      	unordered_map < int , int > :: iterator itr ;		      for ( int i = 0 ;						  
    for item in dict :					      	for ( itr = freq . begin ( ) ;				      i < map . size ( ) ;					  
	if ( dict [ item ] > 1 ) :			      	itr != freq . end ( ) ;					      i ++ ) {							  
	    print ( item , end = " " )			      	itr ++ ) {						    	if ( ( map [ map [ i ] ] > 1 ) ) cout << map [ map [ i ]  
    print ( "\n" )					      	  if ( itr -> second > 1 ) {				      }								  
							      	    cout << itr -> first << " " ;			      cout << "\n" ;						  
							      	    dup = true ;					    }								  
							      	  }							    								  
							      	}							    								  
							      	if ( dup == false ) cout << "-1" ;			    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1 COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1 COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1 COUNT_PAIRS_TWO_SORTED_ARRAYS_WHOSE_SUM_EQUAL_GIVEN_VALUE_X_1
--							      --							    --								  --
def countPairs ( arr1 , arr2 , m , n , x ) :		      int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n  int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n  failure : #Results: 1, 10
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    us = set ( )					      	unordered_set < int > us ;				      set < int > us ;						  
    for i in range ( m ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	us.add ( arr1 [ i ] )				      	i < m ;							      i < m ;							  
    for j in range ( n ) :				      	i ++ ) us . insert ( arr1 [ i ] ) ;			      i ++ ) us . insert ( arr1 [ i ] ) ;			  
	if x - arr2 [ j ] in us :			      	for ( int j = 0 ;					      for ( int j = 0 ;						  
	    count += 1					      	j < n ;							      j < n ;							  
    return count					      	j ++ ) if ( us . find ( x - arr2 [ j ] ) != us . end ( ) )    j ++ ) if ( us . count ( arr2 [ j ] ) ) count ++ ;	  
							      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_FIBONACCI_NUMBERS					      SUM_FIBONACCI_NUMBERS					    SUM_FIBONACCI_NUMBERS					  SUM_FIBONACCI_NUMBERS
--							      --							    --								  --
def calculateSum ( n ) :				      int calculateSum ( int n ) {				    int calculateSum ( int n ) {				  success : None
    if ( n <= 0 ) :					      	if ( n <= 0 ) return 0 ;				      if ( ( n <= 0 ) ) return 0 ;				  
	return 0					      	int fibo [ n + 1 ] ;					      vector < int > fibo ( n + 1 , 0 ) ;			  
    fibo = [ 0 ] * ( n + 1 )				      	fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ;			      fibo [ 1 ] = 1 ;						  
    fibo [ 1 ] = 1					      	int sum = fibo [ 0 ] + fibo [ 1 ] ;			      int sm = fibo [ 0 ] + fibo [ 1 ] ;			  
    sm = fibo [ 0 ] + fibo [ 1 ]			      	for ( int i = 2 ;					      for ( int i = 2 ;						  
    for i in range ( 2 , n + 1 ) :			      	i <= n ;						      i <= n ;							  
	fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ]	      	i ++ ) {						      i ++ ) {							  
	sm = sm + fibo [ i ]				      	  fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;	    	fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;		  
    return sm						      	  sum += fibo [ i ] ;					    	sm = sm + fibo [ i ] ;					  
							      	}							      }								  
							      	return sum ;						      return sm ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I COUNT_DERANGEMENTS_PERMUTATION_SUCH_THAT_NO_ELEMENT_APPEARS_I
--							      --							    --								  --
def countDer ( n ) :					      int countDer ( int n ) {					    int countDer ( int n ) {					  success : None
    der = [ 0 for i in range ( n + 1 ) ]		      	int der [ n + 1 ] ;					      int der [ n + 1 ] ;					  
    der [ 0 ] = 1					      	der [ 0 ] = 1 ;						      der [ 0 ] = 1 ;						  
    der [ 1 ] = 0					      	der [ 1 ] = 0 ;						      der [ 1 ] = 0 ;						  
    der [ 2 ] = 1					      	der [ 2 ] = 1 ;						      der [ 2 ] = 1 ;						  
    for i in range ( 3 , n + 1 ) :			      	for ( int i = 3 ;					      for ( int i = 3 ;						  
	der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 	i <= n ;						      i <= n ;							  
    return der [ n ]					      	++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i -    i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i -  
							      	return der [ n ] ;					      return der [ n ] ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY			      FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY			    FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY			  FIRST_ELEMENT_OCCURRING_K_TIMES_ARRAY
--							      --							    --								  --
def firstElement ( arr , n , k ) :			      int firstElement ( int arr [ ] , int n , int k ) {	    int firstElement ( int * arr , int n , int k ) {		  failure : #Results: 7, 10
    count_map = { }					      	unordered_map < int , int > count_map ;			      unordered_map < int , int > countMap ;			  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( arr [ i ] in count_map.keys ( ) ) :	      	i < n ;							      i != n ;							  
	    count_map [ arr [ i ] ] += 1		      	i ++ ) count_map [ arr [ i ] ] ++ ;			      ) {							  
	else :						      	for ( int i = 0 ;					    	if ( ( arr [ i ] < countMap . count ( arr [ i ] ) ) ) cou 
	    count_map [ arr [ i ] ] = 1			      	i < n ;							    	else countMap [ arr [ i ] ] = 1 ;			  
	i += 1						      	i ++ ) if ( count_map [ arr [ i ] ] == k ) return arr [ i ] 	i ++ ;							  
    for i in range ( 0 , n ) :				      	return - 1 ;						      }								  
	if ( count_map [ arr [ i ] ] == k ) :		      }								      for ( int i = 0 ;						  
	    return arr [ i ]				      								      i != n ;							  
	i += 1						      								      ) {							  
    return - 1						      								    	if ( ( countMap [ arr [ i ] ] == k ) ) return arr [ i ] ; 
							      								    	i ++ ;							  
							      								      }								  
							      								      return - 1 ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1	      COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1	    COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1	  COUNT_SUBSTRINGS_WITH_SAME_FIRST_AND_LAST_CHARACTERS_1
--							      --							    --								  --
def countSubstringWithEqualEnds ( s ) :			      int countSubstringWithEqualEnds ( string s ) {		    int countSubstringWithEqualEnds ( string s ) {		  script_not_found : None
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    n = len ( s )					      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
    count = [ 0 ] * MAX_CHAR				      	int count [ MAX_CHAR ] = {				      vector < int > count ( MAX_CHAR , 0 ) ;			  
    for i in range ( n ) :				      	  0 }							      for ( int i = 0 ;						  
	count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1	      	  ;							      i < n ;							  
    for i in range ( MAX_CHAR ) :			      	  for ( int i = 0 ;					      i ++ ) count [ s [ i ] - 'a' ] ++ ;			  
	result += ( count [ i ] * ( count [ i ] + 1 ) / 2 )   	  i < n ;						      for ( int i = 0 ;						  
    return result					      	  i ++ ) count [ s [ i ] - 'a' ] ++ ;			      i < MAX_CHAR ;						  
							      	  for ( int i = 0 ;					      i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 )  
							      	  i < MAX_CHAR ;					      return result ;						  
							      	  i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2  }								  
							      	  return result ;					    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE		      CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE		    CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE		  CONVERT_ALTERNATE_CHARACTERS_STRING_UPPER_CASE
--							      --							    --								  --
def convertOpposite ( str ) :				      void convertOpposite ( string & str ) {			    void convertOpposite ( string str ) {			  script_not_found : None
    ln = len ( str )					      	int ln = str . length ( ) ;				      int ln = str . length ( ) ;				  
    for i in range ( ln ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if str [ i ] >= 'a' and str [ i ] <= 'z' :	      	i < ln ;						      i < ln ;							  
	    str [ i ] = chr ( ord ( str [ i ] ) - 32 )	      	i ++ ) {						      i ++ ) {							  
	elif str [ i ] >= 'A' and str [ i ] <= 'Z' :	      	  if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) str [ i ] = s 	if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) str [ i ] = ( 
	    str [ i ] = chr ( ord ( str [ i ] ) + 32 )	      	  else if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) str [ i  	else if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) str [ i  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP	      HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP	    HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP	  HOW_TO_CHECK_IF_A_GIVEN_ARRAY_REPRESENTS_A_BINARY_HEAP
--							      --							    --								  --
def isHeap ( arr , i , n ) :				      bool isHeap ( int arr [ ] , int i , int n ) {		    bool isHeap ( int * arr , int i , int n ) {			  success : None
    if i > int ( ( n - 2 ) / 2 ) :			      	if ( i > ( n - 2 ) / 2 ) return true ;			      if ( i > ( int ) ( ( n - 2 ) / 2 ) ) return true ;	  
	return True					      	if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2   if ( ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 
    if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr  	return false ;						      return false ;						  
	return True					      }								    }								  
    return False					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY		      FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY			    FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY			  FIND_SUM_UNIQUE_SUB_ARRAY_SUM_GIVEN_ARRAY
--							      --							    --								  --
def findSubarraySum ( arr , n ) :			      long long int findSubarraySum ( int arr [ ] , int n ) {	    int findSubarraySum ( int * arr , int n ) {			  timeout : None
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    m = dict ( )					      	unordered_map < int , int > m ;				      map < int , int > m ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	Sum = 0						      	i < n ;							      i < n ;							  
	for j in range ( i , n ) :			      	i ++ ) {						      i ++ ) {							  
	    Sum += arr [ j ]				      	  int sum = 0 ;						    	int Sum = 0 ;						  
	    m [ Sum ] = m.get ( Sum , 0 ) + 1		      	  for ( int j = i ;					    	for ( int j = i ;					  
    for x in m :					      	  j < n ;						    	j < n ;							  
	if m [ x ] == 1 :				      	  j ++ ) {						    	j ++ ) {						  
	    res += x					      	    sum += arr [ j ] ;					    	  Sum += arr [ j ] ;					  
    return res						      	    m [ sum ] ++ ;					    	  m [ Sum ] = m . count ( Sum ) + 1 ;			  
							      	  }							    	}							  
							      	}							      }								  
							      	for ( auto x : m ) if ( x . second == 1 ) res += x . first    for ( int x = 0 ;						  
							      	return res ;						      x < m . size ( ) ;					  
							      }								      x ++ ) {							  
							      								    	if ( m [ x ] == 1 ) res += x ;				  
							      								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG GENERATING_DISTINCT_SUBSEQUENCES_OF_A_GIVEN_STRING_IN_LEXICOG
--							      --							    --								  --
def generate ( st , s ) :				      void generate ( set < string > & st , string s ) {	    string generate ( set < string > & st , string s ) {	  script_not_found : None
    if len ( s ) == 0 :					      	if ( s . size ( ) == 0 ) return ;			      if ( s . length ( ) == 0 ) return "" ;			  
	return						      	if ( st . find ( s ) == st . end ( ) ) {		      if ( ! st . count ( s ) ) {				  
    if s not in st :					      	  st . insert ( s ) ;					    	st . insert ( s ) ;					  
	st.add ( s )					      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
	for i in range ( len ( s ) ) :			      	  i < s . size ( ) ;					    	i < s . length ( ) ;					  
	    t = list ( s ).copy ( )			      	  i ++ ) {						    	i ++ ) {						  
	    t.remove ( s [ i ] )			      	    string t = s ;					    	  string t = s ;					  
	    t = ''.join ( t )				      	    t . erase ( i , 1 ) ;				    	  t . erase ( s . substr ( i ) ) ;			  
	    generate ( st , t )				      	    generate ( st , t ) ;				    	  t = t . substr ( 0 , t . length ( ) - i ) ;		  
    return						      	  }							    	  generate ( st , t ) ;					  
							      	}							    	}							  
							      	return ;						      }								  
							      }								      return st ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1	    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_1
--							      --							    --								  --
def printRepeating ( arr , size ) :			      void printRepeating ( int arr [ ] , int size ) {		    void printRepeating ( int * arr , int size ) {		  script_not_found : None
    count = [ 0 ] * size				      	int * count = new int [ sizeof ( int ) * ( size - 2 ) ] ;     vector < int > count ( size , 0 ) ;			  
    print ( " Repeating elements are " , end = "" )	      	int i ;							      cout << " Repeating elements are " ;			  
    for i in range ( 0 , size ) :			      	cout << " Repeating elements are " ;			      for ( int i = 0 ;						  
	if ( count [ arr [ i ] ] == 1 ) :		      	for ( i = 0 ;						      i != size ;						  
	    print ( arr [ i ] , end = " " )		      	i < size ;						      i ++ ) {							  
	else :						      	i ++ ) {						    	if ( ( count [ arr [ i ] ] == 1 ) ) cout << arr [ i ] <<  
	    count [ arr [ i ] ] = count [ arr [ i ] ] + 1     	  if ( count [ arr [ i ] ] == 1 ) cout << arr [ i ] << " "  	else count [ arr [ i ] ] = count [ arr [ i ] ] + 1 ;	  
							      	  else count [ arr [ i ] ] ++ ;				      }								  
							      	}							    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY		      MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY		    MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY		  MAXIMUM_AREA_RECTANGLE_PICKING_FOUR_SIDES_ARRAY
--							      --							    --								  --
def findArea ( arr , n ) :				      int findArea ( int arr [ ] , int n ) {			    int findArea ( int * arr , int n ) {			  failure : #Results: 7, 10
    arr.sort ( reverse = True )				      	sort ( arr , arr + n , greater < int > ( ) ) ;		      sort ( arr , arr + n ) ;					  
    dimension = [ 0 , 0 ]				      	int dimension [ 2 ] = {					      int dimension [ ] = {					  
    i = 0						      	  0 , 0 }						    	0 , 0 }							  
    j = 0						      	  ;							    	;							  
    while ( i < n - 1 and j < 2 ) :			      	  for ( int i = 0 , j = 0 ;				    	int i = 0 ;						  
	if ( arr [ i ] == arr [ i + 1 ] ) :		      	  i < n - 1 && j < 2 ;					    	int j = 0 ;						  
	    dimension [ j ] = arr [ i ]			      	  i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ 	while ( ( i < n - 1 ) && ( j < 2 ) ) {			  
	    j += 1					      	  return ( dimension [ 0 ] * dimension [ 1 ] ) ;	    	  if ( ( arr [ i ] == arr [ i + 1 ] ) ) {		  
	    i += 1					      	}							    	    dimension [ j ] = arr [ i ] ;			  
	i += 1						      								    	    j ++ ;						  
    return ( dimension [ 0 ] * dimension [ 1 ] )	      								    	    i ++ ;						  
							      								    	  }							  
							      								    	  i ++ ;						  
							      								    	}							  
							      								    	return ( dimension [ 0 ] * dimension [ 1 ] ) ;		  
							      								      }								  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL NOBLE_INTEGERS_IN_AN_ARRAY_COUNT_OF_GREATER_ELEMENTS_IS_EQUAL
--							      --							    --								  --
def nobleInteger ( arr ) :				      int nobleInteger ( int arr [ ] , int n ) {		    int nobleInteger ( int * arr ) {				  script_not_found : None
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + sizeof ( int ) / sizeof ( int ) ) ;	  
    n = len ( arr )					      	for ( int i = 0 ;					      int n = sizeof ( int ) / sizeof ( int ) ;			  
    for i in range ( n - 1 ) :				      	i < n - 1 ;						      for ( int i = 0 ;						  
	if arr [ i ] == arr [ i + 1 ] :			      	i ++ ) {						      i < n - 1 ;						  
	    continue					      	  if ( arr [ i ] == arr [ i + 1 ] ) continue ;		      i ++ ) {							  
	if arr [ i ] == n - i - 1 :			      	  if ( arr [ i ] == n - i - 1 ) return arr [ i ] ;	    	if ( arr [ i ] == arr [ i + 1 ] ) continue ;		  
	    return arr [ i ]				      	}							    	if ( arr [ i ] == n - i - 1 ) return arr [ i ] ;	  
    if arr [ n - 1 ] == 0 :				      	if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ;	      }								  
	return arr [ n - 1 ]				      	return - 1 ;						      if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ;		  
    return - 1						      }								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAYS_DISTINCT_ELEMENTS				      SUBARRAYS_DISTINCT_ELEMENTS				    SUBARRAYS_DISTINCT_ELEMENTS					  SUBARRAYS_DISTINCT_ELEMENTS
--							      --							    --								  --
def sumoflength ( arr , n ) :				      int sumoflength ( int arr [ ] , int n ) {			    int sumoflength ( string arr , int n ) {			  error : SUBARRAYS_DISTINCT_ELEMENTS.cpp: In functi
    s = [ ]						      	unordered_set < int > s ;				      string result ;						  on ‘int main()’: SUBARRAYS_DISTINCT_ELEMENTS.cpp:5
    j = 0						      	int j = 0 , ans = 0 ;					      int j = 0 ;						  8:21: error: could not convert ‘&(& param0.std::ve
    ans = 0						      	for ( int i = 0 ;					      int ans = 0 ;						  ctor<std::vector<int> >::operator[](((std::vector<
    for i in range ( n ) :				      	i < n ;							      for ( int i = 0 ;						  std::vector<int> >::size_type)i)))->std::vector<in
	while ( j < n and ( arr [ j ] not in s ) ) :	      	i ++ ) {						      i < n ;							  t>::front()’ from ‘__gnu_cxx::__alloc_traits<std::
	    s.append ( arr [ j ] )			      	  while ( j < n && s . find ( arr [ j ] ) == s . end ( ) )    i ++ ) {							  allocator<int>, int>::value_type*’ {aka ‘int*’} to
	    j += 1					      	    s . insert ( arr [ j ] ) ;				    	while ( ( j < n ) && ( result [ j ] != ' ' ) ) {	   ‘std::__cxx11::string’ {aka ‘std::__cxx11::basic_
	ans += ( ( j - i ) * ( j - i + 1 ) ) // 2	      	    j ++ ;						    	  result += toupper ( result [ j ] ) ;			  string<char>’}	  if(f_filled(&param0[i].fro
	s.remove ( arr [ i ] )				      	  }							    	  j ++ ;						  nt(),param1[i]) == f_gold(&param0[i].front(),param
    return ans						      	  ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;		    	}							  1[i]))		      ^~~~~~~~~~~~~~~~~~
							      	  s . erase ( arr [ i ] ) ;				    	ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ;		  
							      	}							    	result . erase ( result . begin ( ) + i ) ;		  
							      	return ans ;						      }								  
							      }								      return ans ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS		      PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS			    PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS			  PUT_SPACES_WORDS_STARTING_CAPITAL_LETTERS
--							      --							    --								  --
def amendSentence ( string ) :				      void amendSentence ( string str ) {			    void amendSentence ( string string ) {			  script_not_found : None
    string = list ( string )				      	for ( int i = 0 ;					      string = string ;						  
    for i in range ( len ( string ) ) :			      	i < str . length ( ) ;					      for ( int i = 0 ;						  
	if string [ i ] >= 'A' and string [ i ] <= 'Z' :      	i ++ ) {						      i < string . length ( ) ;					  
	    string [ i ] = chr ( ord ( string [ i ] ) + 32 )  	  if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {		      i ++ ) {							  
	    if i != 0 :					      	    str [ i ] = str [ i ] + 32 ;			    	if ( string [ i ] >= 'A' && string [ i ] <= 'Z' ) {	  
		print ( "" , end = "" )			      	    if ( i != 0 ) cout << " " ;				    	  string [ i ] = ( char ) ( ( int ) string [ i ] + 32 ) ; 
	    print ( string [ i ] , end = "" )		      	    cout << str [ i ] ;					    	  if ( i != 0 ) cout << " " ;				  
	else :						      	  }							    	  cout << string [ i ] << " " ;				  
	    print ( string [ i ] , end = "" )		      	  else cout << str [ i ] ;				    	}							  
							      	}							    	else cout << string [ i ] << " " ;			  
							      }								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_1S_SORTED_BINARY_ARRAY				      COUNT_1S_SORTED_BINARY_ARRAY				    COUNT_1S_SORTED_BINARY_ARRAY				  COUNT_1S_SORTED_BINARY_ARRAY
--							      --							    --								  --
def countOnes ( arr , low , high ) :			      int countOnes ( bool arr [ ] , int low , int high ) {	    int countOnes ( int * arr , int low , int high ) {		  script_not_found : None
    if high >= low :					      	if ( high >= low ) {					      if ( high >= low ) {					  
	mid = low + ( high - low ) / 2			      	  int mid = low + ( high - low ) / 2 ;			    	int mid = low + ( high - low ) / 2 ;			  
	if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( ar 	  if ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ m 	if ( ( ( mid == high || arr [ mid + 1 ] == 0 ) && ( arr [ 
	    return mid + 1				      	  if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid +  	if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid +  
	if arr [ mid ] == 1 :				      	  return countOnes ( arr , low , ( mid - 1 ) ) ;	    	return countOnes ( arr , low , mid - 1 ) ;		  
	    return countOnes ( arr , ( mid + 1 ) , high )     	}							      }								  
	return countOnes ( arr , low , mid - 1 )	      	return 0 ;						      return 0 ;						  
    return 0						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS			      K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS			    K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS			  K_MAXIMUM_SUM_COMBINATIONS_TWO_ARRAYS
--							      --							    --								  --
def KMaxCombinations ( A , B , N , K ) :		      void KMaxCombinations ( int A [ ] , int B [ ] , int N , int K int KMaxCombinations ( int * A , int * B , int N , int K ) {  script_not_found : None
    pq = PriorityQueue ( )				      	priority_queue < int > pq ;				      priority_queue < pair < int , int >> pq ;			  
    for i in range ( 0 , N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( 0 , N ) :			      	i < N ;							      i < N ;							  
	    a = A [ i ] + B [ j ]			      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
	    pq.put ( ( - a , a ) )			      	j < N ;							    	for ( int j = 0 ;					  
    count = 0						      	j ++ ) pq . push ( A [ i ] + B [ j ] ) ;		    	j < N ;							  
    while ( count < K ) :				      	int count = 0 ;						    	j ++ ) {						  
	print ( pq.get ( ) [ 1 ] )			      	while ( count < K ) {					    	  int a = A [ i ] + B [ j ] ;				  
	count = count + 1				      	  cout << pq . top ( ) << endl ;			    	  pq . push ( make_pair ( - a , a ) ) ;			  
							      	  pq . pop ( ) ;					    	}							  
							      	  count ++ ;						      }								  
							      	}							      int count = 0 ;						  
							      }								      while ( ( count < K ) && ( pq . top ( ) . second == 1 ) ) { 
							      								    	cout << pq . top ( ) . second << endl ;			  
							      								    	count = count + 1 ;					  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_WAVE_FORM_2_1				      SORT_ARRAY_WAVE_FORM_2_1					    SORT_ARRAY_WAVE_FORM_2_1					  SORT_ARRAY_WAVE_FORM_2_1
--							      --							    --								  --
def sortInWave ( arr , n ) :				      void sortInWave ( int arr [ ] , int n ) {			    void sortInWave ( int * arr , int n ) {			  script_not_found : None
    for i in range ( 0 , n , 2 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( i > 0 and arr [ i ] < arr [ i - 1 ] ) :	      	i < n ;							      i < n ;							  
	    arr [ i ] , arr [ i - 1 ] = arr [ i - 1 ] , arr [ 	i += 2 ) {						      i += 2 ) {						  
	if ( i < n - 1 and arr [ i ] < arr [ i + 1 ] ) :      	  if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( & arr [  	if ( ( i > 0 ) && arr [ i ] < arr [ i - 1 ] ) arr [ i ] = 
	    arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ 	  if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( & ar 	if ( ( i < n - 1 ) && arr [ i ] < arr [ i + 1 ] ) arr [ i 
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EQUILIBRIUM_INDEX_OF_AN_ARRAY				      EQUILIBRIUM_INDEX_OF_AN_ARRAY				    EQUILIBRIUM_INDEX_OF_AN_ARRAY				  EQUILIBRIUM_INDEX_OF_AN_ARRAY
--							      --							    --								  --
def equilibrium ( arr ) :				      int equilibrium ( int arr [ ] , int n ) {			    int equilibrium ( string arr ) {				  error : EQUILIBRIUM_INDEX_OF_AN_ARRAY.cpp: In func
    leftsum = 0						      	int i , j ;						      int leftsum ;						  tion ‘int main()’: EQUILIBRIUM_INDEX_OF_AN_ARRAY.c
    rightsum = 0					      	int leftsum , rightsum ;				      int rightsum ;						  pp:64:21: error: could not convert ‘&(& param0.std
    n = len ( arr )					      	for ( i = 0 ;						      int n = arr . length ( ) ;				  ::vector<std::vector<int> >::operator[](((std::vec
    for i in range ( n ) :				      	i < n ;							      for ( int i = 0 ;						  tor<std::vector<int> >::size_type)i)))->std::vecto
	leftsum = 0					      	++ i ) {						      i < n ;							  r<int>::front()’ from ‘__gnu_cxx::__alloc_traits<s
	rightsum = 0					      	  leftsum = 0 ;						      i ++ ) {							  td::allocator<int>, int>::value_type*’ {aka ‘int*’
	for j in range ( i ) :				      	  for ( j = 0 ;						    	leftsum = 0 ;						  } to ‘std::__cxx11::string’ {aka ‘std::__cxx11::ba
	    leftsum += arr [ j ]			      	  j < i ;						    	rightsum = 0 ;						  sic_string<char>’}	      if(f_filled(&param0[i]
	for j in range ( i + 1 , n ) :			      	  j ++ ) leftsum += arr [ j ] ;				    	for ( int j = 0 ;					  .front(),param1[i]) == f_gold(&param0[i].front(),p
	    rightsum += arr [ j ]			      	  rightsum = 0 ;					    	j < i ;							  aram1[i]))			  ^~~~~~~~~~~~~~~~~~
	if leftsum == rightsum :			      	  for ( j = i + 1 ;					    	j ++ ) leftsum += arr [ j ] ;				  
	    return i					      	  j < n ;						    	for ( int j = i + 1 ;					  
    return - 1						      	  j ++ ) rightsum += arr [ j ] ;			    	j < n ;							  
							      	  if ( leftsum == rightsum ) return i ;			    	j ++ ) rightsum += arr [ j ] ;				  
							      	}							    	if ( leftsum == rightsum ) return i ;			  
							      	return - 1 ;						      }								  
							      }								      return - 1 ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE	      DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE	    DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_4_LONGEST_COMMON_SUBSEQUENCE
--							      --							    --								  --
def lcs ( X , Y , m , n ) :				      int lcs ( char * X , char * Y , int m , int n ) {		    int lcs ( string X , string Y , int m , int n ) {		  script_not_found : None
    if m == 0 or n == 0 :				      	if ( m == 0 || n == 0 ) return 0 ;			      if ( m == 0 || n == 0 ) return 0 ;			  
	return 0 ;					      	if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y ,    ;								  
    elif X [ m - 1 ] == Y [ n - 1 ] :			      	else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y ,   else if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , 
	return 1 + lcs ( X , Y , m - 1 , n - 1 ) ;	      }								      else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , 
    else :						      								    }								  
	return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y  								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE			      PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE			    PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE			  PRINT_N_TERMS_NEWMAN_CONWAY_SEQUENCE
--							      --							    --								  --
def sequence ( n ) :					      void sequence ( int n ) {					    int sequence ( int n ) {					  script_not_found : None
    f = [ 0 , 1 , 1 ]					      	int f [ n + 1 ] ;					      int f [ ] = {						  
    print ( f [ 1 ] , end = " " ) ,			      	f [ 0 ] = 0 ;						    	0 , 1 , 1 }						  
    print ( f [ 2 ] , end = " " ) ,			      	f [ 1 ] = 1 ;						    	;							  
    for i in range ( 3 , n + 1 ) :			      	f [ 2 ] = 1 ;						    	cout << f [ 1 ] << " " << endl ;			  
	f.append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ]  	cout << f [ 1 ] << " " << f [ 2 ] << " " ;		    	cout << f [ 2 ] << " " << endl ;			  
	print ( f [ i ] , end = " " ) ,			      	for ( int i = 3 ;					    	for ( int i = 3 ;					  
							      	i <= n ;						    	i <= n ;						  
							      	i ++ ) {						    	i ++ ) {						  
							      	  f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;	    	  f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ;	  
							      	  cout << f [ i ] << " " ;				    	  cout << f [ i ] << " " << endl ;			  
							      	}							    	}							  
							      }								    	return n ;						  
							      								      }								  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1			      SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1			    SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1			  SORT_1_N_SWAPPING_ADJACENT_ELEMENTS_1
--							      --							    --								  --
def sortedAfterSwap ( A , B , n ) :			      bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) {	    bool sortedAfterSwap ( int * A , int * B , int n ) {	  script_not_found : None
    for i in range ( 0 , n - 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if B [ i ] :					      	i < n - 1 ;						      i <= n - 1 ;						  
	    if A [ i ] != i + 1 :			      	i ++ ) {						      i ++ ) {							  
		A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] 	  if ( B [ i ] ) {					    	if ( B [ i ] ) {					  
    for i in range ( n ) :				      	    if ( A [ i ] != i + 1 ) swap ( A [ i ] , A [ i + 1 ] )  	  if ( A [ i ] != i + 1 ) A [ i ] = A [ i + 1 ] ;	  
	if A [ i ] != i + 1 :				      	  }							    	}							  
	    return False				      	}							      }								  
    return True						      	for ( int i = 0 ;					      for ( int i = 0 ;						  
							      	i < n ;							      i < n ;							  
							      	i ++ ) {						      i ++ ) {							  
							      	  if ( A [ i ] != i + 1 ) return false ;		    	if ( A [ i ] != i + 1 ) return false ;			  
							      	}							      }								  
							      	return true ;						      return true ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE K_TH_MISSING_ELEMENT_INCREASING_SEQUENCE_NOT_PRESENT_GIVEN_SE
--							      --							    --								  --
def find ( a , b , k , n1 , n2 ) :			      int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 )  int find ( int * a , int * b , int k , int n1 , int n2 ) {	  script_not_found : None
    s = set ( )						      	unordered_set < int > s ;				      set < int > s ;						  
    for i in range ( n2 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	s.add ( b [ i ] )				      	i < n2 ;						      i < n2 ;							  
    missing = 0						      	i ++ ) s . insert ( b [ i ] ) ;				      i ++ ) s . insert ( b [ i ] ) ;				  
    for i in range ( n1 ) :				      	int missing = 0 ;					      int missing = 0 ;						  
	if a [ i ] not in s :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    missing += 1				      	i < n1 ;						      i < n1 ;							  
	if missing == k :				      	i ++ ) {						      i ++ ) {							  
	    return a [ i ]				      	  if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ;   	if ( a [ i ] != s . count ( a [ i ] ) ) missing ++ ;	  
    return - 1						      	  if ( missing == k ) return a [ i ] ;			    	if ( missing == k ) return a [ i ] ;			  
							      	}							      }								  
							      	return - 1 ;						      return - 1 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION	      DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION	    DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION	  DYNAMIC_PROGRAMMING_SET_8_MATRIX_CHAIN_MULTIPLICATION
--							      --							    --								  --
def MatrixChainOrder ( p , i , j ) :			      int MatrixChainOrder ( int p [ ] , int i , int j ) {	    int MatrixChainOrder ( int * p , int i , int j ) {		  success : None
    if i == j :						      	if ( i == j ) return 0 ;				      if ( i == j ) return 0 ;					  
	return 0					      	int k ;							      int min = INT_MAX ;					  
    _min = sys.maxsize					      	int min = INT_MAX ;					      for ( int k = i ;						  
    for k in range ( i , j ) :				      	int count ;						      k < j ;							  
	count = ( MatrixChainOrder ( p , i , k ) + MatrixChai 	for ( k = i ;						      k ++ ) {							  
	if count < _min :				      	k < j ;							    	int count = ( MatrixChainOrder ( p , i , k ) + MatrixChai 
	    _min = count				      	k ++ ) {						    	if ( count < min ) min = count ;			  
    return _min						      	  count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder   }								  
							      	  if ( count < min ) min = count ;			      return min ;						  
							      	}							    }								  
							      	return min ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1	      MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1		    MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1		  MAXIMUM_CONSECUTIVE_REPEATING_CHARACTER_STRING_1
--							      --							    --								  --
def maxRepeating ( str ) :				      char maxRepeating ( string str ) {			    char maxRepeating ( string str ) {				  success : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    res = str [ 0 ]					      	char res = str [ 0 ] ;					      char res = str [ 0 ] ;					  
    cur_count = 1					      	int cur_count = 1 ;					      int curCount = 1 ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) :     	i < n ;							      i < n ;							  
	    cur_count += 1				      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count  	if ( ( i < n - 1 ) && str [ i ] == str [ i + 1 ] ) curCou 
	    if cur_count > count :			      	  else {						    	else {							  
		count = cur_count			      	    if ( cur_count > count ) {				    	  if ( curCount > count ) {				  
		res = str [ i ]				      	      count = cur_count ;				    	    count = curCount ;					  
	    cur_count = 1				      	      res = str [ i ] ;					    	    res = str [ i ] ;					  
    return res						      	    }							    	  }							  
							      	    cur_count = 1 ;					    	  curCount = 1 ;					  
							      	  }							    	}							  
							      	}							      }								  
							      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DELETE_CONSECUTIVE_WORDS_SEQUENCE_1			      DELETE_CONSECUTIVE_WORDS_SEQUENCE_1			    DELETE_CONSECUTIVE_WORDS_SEQUENCE_1				  DELETE_CONSECUTIVE_WORDS_SEQUENCE_1
--							      --							    --								  --
def removeConsecutiveSame ( v ) :			      int removeConsecutiveSame ( vector < string > v ) {	    int removeConsecutiveSame ( string v ) {			  script_not_found : None
    st = [ ]						      	stack < string > st ;					      string st ;						  
    for i in range ( len ( v ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( len ( st ) == 0 ) :			      	i < v . size ( ) ;					      i < v . length ( ) ;					  
	    st.append ( v [ i ] )			      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( st . empty ( ) ) st . push ( v [ i ] ) ;		    	if ( ( st . length ( ) == 0 ) && ( st [ i ] == ' ' ) ) st 
	    Str = st [ - 1 ]				      	  else {						    	else {							  
	    if ( Str == v [ i ] ) :			      	    string str = st . top ( ) ;				    	  char Str = st [ st . length ( ) - 1 ] ;		  
		st.pop ( )				      	    if ( str . compare ( v [ i ] ) == 0 ) st . pop ( ) ;    	  if ( ( Str == v [ i ] ) && ( Str != v [ i ] ) ) st . er 
	    else :					      	    else st . push ( v [ i ] ) ;			    	  else st += v [ i ] ;					  
		st.append ( v [ i ] )			      	  }							    	}							  
    return len ( st )					      	}							      }								  
							      	return st . size ( ) ;					      return st . length ( ) ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1	      SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1	    SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1		  SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM_1
--							      --							    --								  --
def KnapSack ( val , wt , n , W ) :			      int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) {   int KnapSack ( int * val , int * wt , int n , int W ) {	  error : /bin/bash: line 1: 1847152 Segmentation fa
    dp = [ 0 ] * ( W + 1 )				      	int dp [ W + 1 ] ;					      int dp [ W + 1 ] ;					  ult	   (core dumped) ./SPACE_OPTIMIZED_DP_SOLUTI
    for i in range ( n ) :				      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int i = 0 ;						  ON_0_1_KNAPSACK_PROBLEM_1_cpp
	for j in range ( W , wt [ i ] , - 1 ) :		      	for ( int i = 0 ;					      i < n ;							  
	    dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j -  	i < n ;							      i ++ ) {							  
    return dp [ W ]					      	i ++ ) for ( int j = W ;				    	for ( int j = W ;					  
							      	j >= wt [ i ] ;						    	wt [ i ] > 0 ;						  
							      	j -- ) dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt  	j -- ) dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - w 
							      	return dp [ W ] ;					      }								  
							      }								      return dp [ W ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE		      DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE		    DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE		  DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE
--							      --							    --								  --
def eggDrop ( n , k ) :					      int eggDrop ( int n , int k ) {				    int eggDrop ( int n , int k ) {				  script_not_found : None
    if ( k == 1 or k == 0 ) :				      	if ( k == 1 || k == 0 ) return k ;			      if ( ( k == 1 ) || ( k == 0 ) ) return k ;		  
	return k					      	if ( n == 1 ) return k ;				      if ( ( n == 1 ) ) return k ;				  
    if ( n == 1 ) :					      	int min = INT_MAX , x , res ;				      int min = INT_MAX ;					  
	return k					      	for ( x = 1 ;						      for ( int x = 1 ;						  
    min = sys.maxsize					      	x <= k ;						      x <= k ;							  
    for x in range ( 1 , k + 1 ) :			      	x ++ ) {						      x ++ ) {							  
	res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , 	  res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - 	int res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , 
	if ( res < min ) :				      	  if ( res < min ) min = res ;				    	if ( ( res < min ) ) min = res ;			  
	    min = res					      	}							      }								  
    return min + 1					      	return min + 1 ;					      return min + 1 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1		      COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1		    COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1			  COUNT_PAIRS_WHOSE_PRODUCTS_EXIST_IN_ARRAY_1
--							      --							    --								  --
def countPairs ( arr , n ) :				      int countPairs ( int arr [ ] , int n ) {			    int countPairs ( int * arr , int n ) {			  success : None
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    Hash = set ( )					      	set < int > Hash ;					      set < int > Hash ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	Hash.add ( arr [ i ] )				      	i < n ;							      i < n ;							  
    for i in range ( n ) :				      	i ++ ) Hash . insert ( arr [ i ] ) ;			      i ++ ) Hash . insert ( arr [ i ] ) ;			  
	for j in range ( i + 1 , n ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    product = arr [ i ] * arr [ j ]		      	i < n ;							      i < n ;							  
	    if product in ( Hash ) :			      	i ++ ) {						      i ++ ) for ( int j = i + 1 ;				  
		result += 1				      	  for ( int j = i + 1 ;					      j < n ;							  
    return result					      	  j < n ;						      j ++ ) {							  
							      	  j ++ ) {						    	int product = arr [ i ] * arr [ j ] ;			  
							      	    int product = arr [ i ] * arr [ j ] ;		    	if ( Hash . count ( product ) ) result ++ ;		  
							      	    if ( Hash . find ( product ) != Hash . end ( ) ) result   }								  
							      	  }							      return result ;						  
							      	}							    }								  
							      	return result ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE			      FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE			    FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE				  FIND_NTH_TERM_DRAGON_CURVE_SEQUENCE
--							      --							    --								  --
def Dragon_Curve_Sequence ( n ) :			      string Dragon_Curve_Sequence ( int n ) {			    string Dragon_Curve_Sequence ( int n ) {			  script_not_found : None
    s = "1"						      	string s = "1" ;					      string s = "1" ;						  
    for i in range ( 2 , n + 1 ) :			      	for ( int i = 2 ;					      for ( int i = 2 ;						  
	temp = "1"					      	i <= n ;						      i <= n ;							  
	prev = '1'					      	i ++ ) {						      i ++ ) {							  
	zero = '0'					      	  string temp = "1" ;					    	string temp = "1" ;					  
	one = '1'					      	  char prev = '1' , zero = '0' , one = '1' ;		    	char prev = '1' ;					  
	for j in range ( len ( s ) ) :			      	  for ( int j = 0 ;					    	char zero = '0' ;					  
	    temp += s [ j ]				      	  j < s . length ( ) ;					    	char one = '1' ;					  
	    if ( prev == '0' ) :			      	  j ++ ) {						    	for ( int j = 0 ;					  
		temp += one				      	    temp += s [ j ] ;					    	j < s . length ( ) ;					  
		prev = one				      	    if ( prev == '0' ) {				    	j ++ ) {						  
	    else :					      	      temp += one ;					    	  temp += s [ j ] ;					  
		temp += zero				      	      prev = one ;					    	  if ( ( prev == '0' ) ) {				  
		prev = zero				      	    }							    	    temp += one ;					  
	s = temp					      	    else {						    	    prev = one ;					  
    return s						      	      temp += zero ;					    	  }							  
							      	      prev = zero ;					    	  else {						  
							      	    }							    	    temp += zero ;					  
							      	  }							    	    prev = zero ;					  
							      	  s = temp ;						    	  }							  
							      	}							    	}							  
							      	return s ;						    	s = temp ;						  
							      }								      }								  
							      								      return s ;						  
							      								      return " " + to_string ( n ) + " " + to_string ( n ) ;	  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY		      FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY		    FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY			  FIND_MAXIMUM_PRODUCT_OF_A_TRIPLET_IN_ARRAY
--							      --							    --								  --
def maxProduct ( arr , n ) :				      int maxProduct ( int arr [ ] , int n ) {			    int maxProduct ( int * arr , int n ) {			  success : None
    if n < 3 :						      	if ( n < 3 ) return - 1 ;				      if ( n < 3 ) return - 1 ;					  
	return - 1					      	int max_product = INT_MIN ;				      int maxProduct = - ( INT_MAX - 1 ) ;			  
    max_product = - ( sys.maxsize - 1 )			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( 0 , n - 2 ) :			      	i < n - 2 ;						      i <= n - 2 ;						  
	for j in range ( i + 1 , n - 1 ) :		      	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
	    for k in range ( j + 1 , n ) :		      	j < n - 1 ;						      j <= n - 1 ;						  
		max_product = max ( max_product , arr [ i ] * 	j ++ ) for ( int k = j + 1 ;				      j ++ ) for ( int k = j + 1 ;				  
    return max_product					      	k < n ;							      k < n ;							  
							      	k ++ ) max_product = max ( max_product , arr [ i ] * arr [    k ++ ) maxProduct = max ( maxProduct , arr [ i ] * arr [ j  
							      	return max_product ;					      return maxProduct ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ARRANGEMENT_QUEUE_GIVEN_TIME			      FIND_ARRANGEMENT_QUEUE_GIVEN_TIME				    FIND_ARRANGEMENT_QUEUE_GIVEN_TIME				  FIND_ARRANGEMENT_QUEUE_GIVEN_TIME
--							      --							    --								  --
def solve ( n , t , p ) :				      void solve ( int n , int t , string s ) {			    int solve ( int n , int t , string p ) {			  script_not_found : None
    s = list ( p )					      	for ( int i = 0 ;					      string s = p ;						  
    for i in range ( 0 , t ) :				      	i < t ;							      for ( int i = 0 ;						  
	for j in range ( 0 , n - 1 ) :			      	i ++ ) for ( int j = 0 ;				      i <= t ;							  
	    if ( s [ j ] == 'B' and s [ j + 1 ] == 'G' ) :    	j < n - 1 ;						      i ++ ) {							  
		temp = s [ j ]				      	j ++ ) if ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) {	    	for ( int j = 0 ;					  
		s [ j ] = s [ j + 1 ]			      	  char temp = s [ j ] ;					    	j <= n - 1 ;						  
		s [ j + 1 ] = temp			      	  s [ j ] = s [ j + 1 ] ;				    	j ++ ) {						  
		j = j + 1				      	  s [ j + 1 ] = temp ;					    	  if ( ( s [ j ] == 'B' && s [ j + 1 ] == 'G' ) ) {	  
    print ( ''.join ( s ) )				      	  j ++ ;						    	    char temp = s [ j ] ;				  
							      	}							    	    s [ j ] = s [ j + 1 ] ;				  
							      	cout << s ;						    	    s [ j + 1 ] = temp ;				  
							      }								    	    j = j + 1 ;						  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      cout << s << endl ;					  
							      								      return n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS     SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS	    SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS	  SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COLUMN_NUMBERS
--							      --							    --								  --
def findSum ( n ) :					      int findSum ( int n ) {					    int findSum ( int n ) {					  error : SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW
    arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] 	int arr [ n ] [ n ] ;					      vector < vector < int >> arr ( n , vector < int > ( n , 0 ) _COLUMN_NUMBERS.cpp: In function ‘int f_filled(int
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int y = 0 ;						  )’: SUM_MATRIX_ELEMENT_ABSOLUTE_DIFFERENCE_ROW_COL
	for j in range ( n ) :				      	i < n ;							      y < n ;							  UMN_NUMBERS.cpp:39:22: error: ‘j’ was not declared
	    arr [ i ] [ j ] = abs ( i - j )		      	i ++ ) for ( int j = 0 ;				      y ++ ) for ( int i = 0 ;					   in this scope    i ++ ) arr [ i ] [ j ] = abs ( i
    sum = 0						      	j < n ;							      i < n ;							   - j ) ;			 ^
    for i in range ( n ) :				      	j ++ ) arr [ i ] [ j ] = abs ( i - j ) ;		      i ++ ) arr [ i ] [ j ] = abs ( i - j ) ;			  
	for j in range ( n ) :				      	int sum = 0 ;						      int sum = 0 ;						  
	    sum += arr [ i ] [ j ]			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    return sum						      	i < n ;							      i < n ;							  
							      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  
							      	j < n ;							      j < n ;							  
							      	j ++ ) sum += arr [ i ] [ j ] ;				      j ++ ) sum += arr [ i ] [ j ] ;				  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM			      REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM			    REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM			  REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM
--							      --							    --								  --
def rearrange ( arr , n ) :				      void rearrange ( int arr [ ] , int n ) {			    int rearrange ( int * arr , int n ) {			  script_not_found : None
    temp = n * [ None ]					      	int temp [ n ] ;					      int temp [ n * sizeof ( int ) ] ;				  
    small , large = 0 , n - 1				      	int small = 0 , large = n - 1 ;				      int small = 0 , large = n - 1 ;				  
    flag = True						      	int flag = true ;					      bool flag = true ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if flag is True :				      	i < n ;							      i < n ;							  
	    temp [ i ] = arr [ large ]			      	i ++ ) {						      i ++ ) {							  
	    large -= 1					      	  if ( flag ) temp [ i ] = arr [ large -- ] ;		    	if ( flag == true ) {					  
	else :						      	  else temp [ i ] = arr [ small ++ ] ;			    	  temp [ i ] = arr [ large ] ;				  
	    temp [ i ] = arr [ small ]			      	  flag = ! flag ;					    	  large -- ;						  
	    small += 1					      	}							    	}							  
	flag = bool ( 1 - flag )			      	for ( int i = 0 ;					    	else {							  
    for i in range ( n ) :				      	i < n ;							    	  temp [ i ] = arr [ small ] ;				  
	arr [ i ] = temp [ i ]				      	i ++ ) arr [ i ] = temp [ i ] ;				    	  small ++ ;						  
    return arr						      }								    	}							  
							      								    	flag = ( bool ) ( 1 - flag ) ;				  
							      								      }								  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) arr [ i ] = temp [ i ] ;				  
							      								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MIDDLE_ROW_COLUMN_MATRIX				      SUM_MIDDLE_ROW_COLUMN_MATRIX				    SUM_MIDDLE_ROW_COLUMN_MATRIX				  SUM_MIDDLE_ROW_COLUMN_MATRIX
--							      --							    --								  --
def middlesum ( mat , n ) :				      void middlesum ( int mat [ ] [ MAX ] , int n ) {		    int middlesum ( int * * mat , int n ) {			  script_not_found : None
    row_sum = 0						      	int row_sum = 0 , col_sum = 0 ;				      int rowSum = 0 ;						  
    col_sum = 0						      	for ( int i = 0 ;					      int colSum = 0 ;						  
    for i in range ( n ) :				      	i < n ;							      for ( int i = 0 ;						  
	row_sum += mat [ n // 2 ] [ i ]			      	i ++ ) row_sum += mat [ n / 2 ] [ i ] ;			      i < n ;							  
    print ( "Sum of middle row = " , row_sum )		      	cout << "Sum of middle row = " << row_sum << endl ;	      i ++ ) rowSum += mat [ n / 2 ] [ i ] ;			  
    for i in range ( n ) :				      	for ( int i = 0 ;					      cout << "Sum of middle row = " << rowSum << endl ;	  
	col_sum += mat [ i ] [ n // 2 ]			      	i < n ;							      for ( int i = 0 ;						  
    print ( "Sum of middle column = " , col_sum )	      	i ++ ) col_sum += mat [ i ] [ n / 2 ] ;			      i < n ;							  
							      	cout << "Sum of middle column = " << col_sum ;		      i ++ ) colSum += mat [ i ] [ n / 2 ] ;			  
							      }								      cout << "Sum of middle column = " << colSum << endl ;	  
							      								      return rowSum ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1		      MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1		    MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1		  MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY_1
--							      --							    --								  --
def maxDiff ( arr , n ) :				      int maxDiff ( int arr [ ] , int n ) {			    int maxDiff ( int * arr , int n ) {				  failure : #Results: 3, 10
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    for i in range ( n - 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) :   	i < n - 1 ;						      i < n - 1 ;						  
	    result += abs ( arr [ i ] )			      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i 	if ( ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) && (  
	    pass					      	  else i ++ ;						    	else {							  
    if ( arr [ n - 2 ] != arr [ n - 1 ] ) :		      	}							    	}							  
	result += abs ( arr [ n - 1 ] )			      	if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += abs ( arr [   }								  
    return result					      	return result ;						      if ( ( arr [ n - 2 ] != arr [ n - 1 ] ) && ( arr [ n - 1 ]  
							      }								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM		      SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM		    SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM			  SEARCHING_FOR_PATTERNS_SET_2_KMP_ALGORITHM
--							      --							    --								  --
def computeLPSArray ( pat , M , lps ) :			      void computeLPSArray ( char * pat , int M , int * lps ) {	    int computeLPSArray ( string pat , int M , int * lps ) {	  script_not_found : None
    len = 0						      	int len = 0 ;						      int len = 0 ;						  
    lps [ 0 ]						      	lps [ 0 ] = 0 ;						      lps [ 0 ] = 0 ;						  
    i = 1						      	int i = 1 ;						      int i = 1 ;						  
    while i < M :					      	while ( i < M ) {					      while ( i < M ) {						  
	if pat [ i ] == pat [ len ] :			      	  if ( pat [ i ] == pat [ len ] ) {			    	if ( pat [ i ] == pat [ len ] ) {			  
	    len += 1					      	    len ++ ;						    	  len ++ ;						  
	    lps [ i ] = len				      	    lps [ i ] = len ;					    	  lps [ i ] = len ;					  
	    i += 1					      	    i ++ ;						    	  i ++ ;						  
	else :						      	  }							    	}							  
	    if len != 0 :				      	  else {						    	else {							  
		len = lps [ len - 1 ]			      	    if ( len != 0 ) {					    	  if ( len != 0 ) len = lps [ len - 1 ] ;		  
	    else :					      	      len = lps [ len - 1 ] ;				    	  else {						  
		lps [ i ] = 0				      	    }							    	    lps [ i ] = 0 ;					  
		i += 1					      	    else {						    	    i ++ ;						  
							      	      lps [ i ] = 0 ;					    	  }							  
							      	      i ++ ;						    	}							  
							      	    }							      }								  
							      	  }							      return len ;						  
							      	}							    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1			      MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1			    MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1			  MINIMUM_COST_SORT_MATRIX_NUMBERS_0_N2_1
--							      --							    --								  --
def calculateEnergy ( mat , n ) :			      int calculateEnergy ( int mat [ SIZE ] [ SIZE ] , int n ) {   int calculateEnergy ( int * * mat , int n ) {		  script_not_found : None
    tot_energy = 0					      	int i_des , j_des , q ;					      int tot_energy = 0 ;					  
    for i in range ( n ) :				      	int tot_energy = 0 ;					      for ( int i = 0 ;						  
	for j in range ( n ) :				      	for ( int i = 0 ;					      i < n ;							  
	    q = mat [ i ] [ j ] // n			      	i < n ;							      i ++ ) {							  
	    i_des = q					      	i ++ ) {						    	for ( int j = 0 ;					  
	    j_des = mat [ i ] [ j ] - ( n * q )		      	  for ( int j = 0 ;					    	j < n ;							  
	    tot_energy += ( abs ( i_des - i ) + abs ( j_des - 	  j < n ;						    	j ++ ) {						  
    return tot_energy					      	  j ++ ) {						    	  int q = mat [ i ] [ j ] / n ;				  
							      	    q = mat [ i ] [ j ] / n ;				    	  int i_des = q ;					  
							      	    i_des = q ;						    	  int j_des = mat [ i ] [ j ] - ( n * q ) ;		  
							      	    j_des = mat [ i ] [ j ] - ( n * q ) ;		    	  tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) 
							      	    tot_energy += abs ( i_des - i ) + abs ( j_des - j ) ;   	}							  
							      	  }							      }								  
							      	}							      return tot_energy ;					  
							      	return tot_energy ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING		      SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING		    SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING		  SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING
--							      --							    --								  --
def sumAtKthLevel ( tree , k ) :			      int sumAtKthLevel ( string tree , int k ) {		    int sumAtKthLevel ( string tree , int k ) {			  success : None
    level = - 1						      	int level = - 1 ;					      int level = - 1 ;						  
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    n = len ( tree )					      	int n = tree . length ( ) ;				      int n = tree . length ( ) ;				  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( tree [ i ] == '(' ) :			      	i < n ;							      i < n ;							  
	    level += 1					      	i ++ ) {						      i ++ ) {							  
	elif ( tree [ i ] == ')' ) :			      	  if ( tree [ i ] == '(' ) level ++ ;			    	if ( ( tree [ i ] == '(' ) ) level ++ ;			  
	    level -= 1					      	  else if ( tree [ i ] == ')' ) level -- ;		    	else if ( ( tree [ i ] == ')' ) ) level -- ;		  
	else :						      	  else {						    	else {							  
	    if ( level == k ) :				      	    if ( level == k ) sum += ( tree [ i ] - '0' ) ;	    	  if ( ( level == k ) ) sum += ( tree [ i ] - '0' ) ;	  
		sum += ( ord ( tree [ i ] ) - ord ( '0' ) )   	  }							    	}							  
    return sum						      	}							      }								  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUPER_PRIME						      SUPER_PRIME						    SUPER_PRIME							  SUPER_PRIME
--							      --							    --								  --
def SieveOfEratosthenes ( n , isPrime ) :		      bool SieveOfEratosthenes ( int n , bool isPrime [ ] ) {	    void SieveOfEratosthenes ( int n , bool isPrime [ ] ) {	  script_not_found : None
    isPrime [ 0 ] = isPrime [ 1 ] = False		      	isPrime [ 0 ] = isPrime [ 1 ] = false ;			      isPrime [ 0 ] = isPrime [ 1 ] = false ;			  
    for i in range ( 2 , n + 1 ) :			      	for ( int i = 2 ;					      for ( int i = 2 ;						  
	isPrime [ i ] = True				      	i <= n ;						      i <= n ;							  
    for p in range ( 2 , n + 1 ) :			      	i ++ ) isPrime [ i ] = true ;				      i ++ ) isPrime [ i ] = true ;				  
	if ( p * p <= n and isPrime [ p ] == True ) :	      	for ( int p = 2 ;					      for ( int p = 2 ;						  
	    for i in range ( p * 2 , n + 1 , p ) :	      	p * p <= n ;						      p <= n ;							  
		isPrime [ i ] = False			      	p ++ ) {						      p ++ ) {							  
		p += 1					      	  if ( isPrime [ p ] == true ) {			    	if ( ( p * p <= n && isPrime [ p ] == true ) ) {	  
							      	    for ( int i = p * 2 ;				    	  for ( int i = p * 2 ;					  
							      	    i <= n ;						    	  i + 1 < p ;						  
							      	    i += p ) isPrime [ i ] = false ;			    	  i ++ ) {						  
							      	  }							    	    isPrime [ i ] = false ;				  
							      	}							    	    p ++ ;						  
							      }								    	  }							  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORTING_USING_TRIVIAL_HASH_FUNCTION			      SORTING_USING_TRIVIAL_HASH_FUNCTION			    SORTING_USING_TRIVIAL_HASH_FUNCTION				  SORTING_USING_TRIVIAL_HASH_FUNCTION
--							      --							    --								  --
def sortUsingHash ( a , n ) :				      void sortUsingHash ( int a [ ] , int n ) {		    int sortUsingHash ( int a [ ] , int n ) {			  script_not_found : None
    Max = max ( a )					      	int max = * std :: max_element ( a , a + n ) ;		      int Max = max ( a ) ;					  
    Hash = [ 0 ] * ( Max + 1 )				      	int hash [ max + 1 ] = {				      vector < int > Hash ( Max + 1 , 0 ) ;			  
    for i in range ( 0 , n ) :				      	  0 }							      for ( int i = 0 ;						  
	Hash [ a [ i ] ] += 1				      	  ;							      i <= n ;							  
    for i in range ( 0 , Max + 1 ) :			      	  for ( int i = 0 ;					      i ++ ) Hash [ a [ i ] ] ++ ;				  
	if Hash [ i ] != 0 :				      	  i < n ;						      for ( int i = 0 ;						  
	    for j in range ( 0 , Hash [ i ] ) :		      	  i ++ ) hash [ a [ i ] ] += 1 ;			      i <= Max ;						  
		print ( i , end = " " )			      	  for ( int i = 0 ;					      i ++ ) {							  
							      	  i <= max ;						    	if ( Hash [ i ] != 0 ) {				  
							      	  i ++ ) {						    	  for ( int j = 0 ;					  
							      	    if ( hash [ i ] ) {					    	  Hash [ i ] != 0 ;					  
							      	      for ( int j = 0 ;					    	  j ++ ) cout << i << " " ;				  
							      	      j < hash [ i ] ;					    	}							  
							      	      j ++ ) {						      }								  
							      		cout << i << " " ;				      return Max ;						  
							      	      }							    }								  
							      	    }							    								  
							      	  }							    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS	      GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS		    GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS		  GREEDY_ALGORITHM_TO_FIND_MINIMUM_NUMBER_OF_COINS
--							      --							    --								  --
def findMin ( V ) :					      void findMin ( int V ) {					    int findMin ( int V ) {					  script_not_found : None
    deno = [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 ]    	vector < int > ans ;					      int deno [ ] = {						  
    n = len ( deno )					      	for ( int i = n - 1 ;					    	1 , 2 , 5 , 10 , 20 , 50 , 100 , 500 , 1000 }		  
    ans = [ ]						      	i >= 0 ;						    	;							  
    i = n - 1						      	i -- ) {						    	int n = sizeof ( deno ) / sizeof ( int ) ;		  
    while ( i >= 0 ) :					      	  while ( V >= deno [ i ] ) {				    	int ans [ n ] ;						  
	while ( V >= deno [ i ] ) :			      	    V -= deno [ i ] ;					    	int i = n - 1 ;						  
	    V -= deno [ i ]				      	    ans . push_back ( deno [ i ] ) ;			    	while ( ( i >= 0 ) && ( V >= deno [ i ] ) ) {		  
	    ans.append ( deno [ i ] )			      	  }							    	  while ( ( V -= deno [ i ] ) ) {			  
	i -= 1						      	}							    	    V -= deno [ i ] ;					  
    for i in range ( len ( ans ) ) :			      	for ( int i = 0 ;					    	    ans [ i ] = deno [ i ] ;				  
	print ( ans [ i ] , end = " " )			      	i < ans . size ( ) ;					    	  }							  
							      	i ++ ) cout << ans [ i ] << "  " ;			    	  i -- ;						  
							      }								    	}							  
							      								    	for ( int i = 0 ;					  
							      								    	i < sizeof ( ans ) / sizeof ( int ) ;			  
							      								    	i ++ ) cout << ans [ i ] << " " ;			  
							      								    	return 0 ;						  
							      								    	return V * V * V * V * V * V * V * V * V * V * V * V * V  
							      								      }								  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1		      PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1		    PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1		  PROGRAM_CHECK_DIAGONAL_MATRIX_SCALAR_MATRIX_1
--							      --							    --								  --
def isScalarMatrix ( mat ) :				      bool isScalarMatrix ( int mat [ N ] [ N ] ) {		    bool isScalarMatrix ( int * * mat ) {			  script_not_found : None
    for i in range ( 0 , N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( 0 , N ) :			      	i < N ;							      i != N ;							  
	    if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) :  	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		return False				      	j < N ;							    	for ( int j = 0 ;					  
    for i in range ( 0 , N - 1 ) :			      	j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return 	j != N ;						  
	if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) :   	for ( int i = 0 ;					    	j ++ ) {						  
	    return False				      	i < N - 1 ;						    	  if ( ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return  
    return True						      	i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) re 	}							  
							      	return true ;						      }								  
							      }								      for ( int i = 0 ;						  
							      								      i != N - 1 ;						  
							      								      i ++ ) {							  
							      								    	if ( ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) ) ret 
							      								      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1			      LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1			    LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1			  LENGTH_LONGEST_BALANCED_SUBSEQUENCE_1
--							      --							    --								  --
def maxLength ( s , n ) :				      int maxLength ( char s [ ] , int n ) {			    int maxLength ( string s , int n ) {			  success : None
    invalidOpenBraces = 0				      	int invalidOpenBraces = 0 ;				      int invalidOpenBraces = 0 ;				  
    invalidCloseBraces = 0				      	int invalidCloseBraces = 0 ;				      int invalidCloseBraces = 0 ;				  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( s [ i ] == '(' ) :				      	i < n ;							      i < n ;							  
	    invalidOpenBraces += 1			      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( s [ i ] == '(' ) {				    	if ( ( s [ i ] == '(' ) ) invalidOpenBraces ++ ;	  
	    if ( invalidOpenBraces == 0 ) :		      	    invalidOpenBraces ++ ;				    	else {							  
		invalidCloseBraces += 1			      	  }							    	  if ( ( invalidOpenBraces == 0 ) ) invalidCloseBraces ++ 
	    else :					      	  else {						    	  else invalidOpenBraces -- ;				  
		invalidOpenBraces -= 1			      	    if ( invalidOpenBraces == 0 ) {			    	}							  
    return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) 	      invalidCloseBraces ++ ;				      }								  
							      	    }							      return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; 
							      	    else {						    }								  
							      	      invalidOpenBraces -- ;				    								  
							      	    }							    								  
							      	  }							    								  
							      	}							    								  
							      	return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; 								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PARTS_GIVEN_CIRCL
--							      --							    --								  --
def findMinimumAngle ( arr , n ) :			      int findMinimumAngle ( int arr [ ] , int n ) {		    double findMinimumAngle ( double * arr , int n ) {		  error : PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TW
    l = 0						      	int l = 0 , sum = 0 , ans = 360 ;			      int l = 0 ;						  O_PARTS_GIVEN_CIRCLE.cpp: In function ‘int main()’
    _sum = 0						      	for ( int i = 0 ;					      double _sum = 0 ;						  : PROGRAM_FIND_SMALLEST_DIFFERENCE_ANGLES_TWO_PART
    ans = 360						      	i < n ;							      double ans = 360 ;					  S_GIVEN_CIRCLE.cpp:58:21: error: cannot convert ‘_
    for i in range ( n ) :				      	i ++ ) {						      for ( int i = 0 ;						  _gnu_cxx::__alloc_traits<std::allocator<int>, int>
	_sum += arr [ i ]				      	  sum += arr [ i ] ;					      i < n ;							  ::value_type*’ {aka ‘int*’} to ‘double*’
	while _sum >= 180 :				      	  while ( sum >= 180 ) {				      i ++ ) {							  if(f_filled(&param0[i].front(),param1[i]) == f_gol
	    ans = min ( ans , 2 * abs ( 180 - _sum ) )	      	    ans = min ( ans , 2 * abs ( 180 - sum ) ) ;		    	_sum += arr [ i ] ;					  d(&param0[i].front(),param1[i]))
	    _sum -= arr [ l ]				      	    sum -= arr [ l ] ;					    	while ( _sum >= 180 ) {					      ^~~~~~~~~~~~~~~~~~ PROGRAM_FIND_SMALLEST_DIFFE
	    l += 1					      	    l ++ ;						    	  ans = min ( ans , 2 * abs ( 180 - _sum ) ) ;		  RENCE_ANGLES_TWO_PARTS_GIVEN_CIRCLE.cpp:33:28: not
	ans = min ( ans , 2 * abs ( 180 - _sum ) )	      	  }							    	  _sum -= arr [ l ] ;					  e:   initializing argument 1 of ‘double f_filled(d
    return ans						      	  ans = min ( ans , 2 * abs ( 180 - sum ) ) ;		    	  l ++ ;						  ouble*, int)’	 double f_filled ( double * arr , in
							      	}							    	}							  t n ) {		     ~~~~~~~~~^~~
							      	return ans ;						    	ans = min ( ans , 2 * abs ( 180 - _sum ) ) ;		  
							      }								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FLOOR_IN_A_SORTED_ARRAY					      FLOOR_IN_A_SORTED_ARRAY					    FLOOR_IN_A_SORTED_ARRAY					  FLOOR_IN_A_SORTED_ARRAY
--							      --							    --								  --
def floorSearch ( arr , low , high , x ) :		      int floorSearch ( int arr [ ] , int n , int x ) {		    int floorSearch ( int * arr , int low , int high , int x ) {  error : FLOOR_IN_A_SORTED_ARRAY.cpp: In function ‘
    if ( low > high ) :					      	if ( x >= arr [ n - 1 ] ) return n - 1 ;		      if ( ( low > high ) ) return - 1 ;			  int main()’: FLOOR_IN_A_SORTED_ARRAY.cpp:44:59: er
	return - 1					      	if ( x < arr [ 0 ] ) return - 1 ;			      if ( ( x >= arr [ high ] ) ) return high ;		  ror: too few arguments to function ‘int f_filled(i
    if ( x >= arr [ high ] ) :				      	for ( int i = 1 ;					      int mid = ( int ) ( ( low + high ) / 2 ) ;		  nt*, int, int, int)’		if(f_filled(&param0[
	return high					      	i < n ;							      if ( ( arr [ mid ] == x ) ) return mid ;			  i].front(),param1[i],param2[i]) == f_gold(&param0[
    mid = int ( ( low + high ) / 2 )			      	i ++ ) if ( arr [ i ] > x ) return ( i - 1 ) ;		      if ( ( mid > 0 ) && ( arr [ mid - 1 ] <= x && x < arr [ mid i].front(),param1[i],param2[i]))
    if ( arr [ mid ] == x ) :				      	return - 1 ;						      if ( ( x < arr [ mid ] ) ) return floorSearch ( arr , low , 					    ^ FLOOR_
	return mid					      }								      return floorSearch ( arr , mid + 1 , high , x ) ;		  IN_A_SORTED_ARRAY.cpp:26:5: note: declared here  i
    if ( mid > 0 and arr [ mid - 1 ] <= x and x < arr [ mid ] 								    }								  nt f_filled ( int * arr , int low , int high , int
	return mid - 1					      								    								   x ) {      ^~~~~~~~
    if ( x < arr [ mid ] ) :				      								    								  
	return floorSearch ( arr , low , mid - 1 , x )	      								    								  
    return floorSearch ( arr , mid + 1 , high , x )	      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND		      EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND		    EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND		  EVALUATE_AN_ARRAY_EXPRESSION_WITH_NUMBERS_AND
--							      --							    --								  --
def calculateSum ( arr , n ) :				      int calculateSum ( string arr [ ] , int n ) {		    int calculateSum ( string * * arr , int n ) {		  script_not_found : None
    if ( n == 0 ) :					      	if ( n == 0 ) return 0 ;				      if ( ( n == 0 ) ) return 0 ;				  
	return 0					      	string s = arr [ 0 ] ;					      string s = arr [ 0 ] ;					  
    s = arr [ 0 ]					      	int value = stoi ( s ) ;				      int value ;						  
    value = int ( s )					      	int sum = value ;					      int sum = value ;						  
    sum = value						      	for ( int i = 2 ;					      for ( int i = 2 ;						  
    for i in range ( 2 , n , 2 ) :			      	i < n ;							      i < n ;							  
	s = arr [ i ]					      	i = i + 2 ) {						      i += 2 ) {						  
	value = int ( s )				      	  s = arr [ i ] ;					    	s = arr [ i ] ;						  
	operation = arr [ i - 1 ] [ 0 ]			      	  int value = stoi ( s ) ;				    	value = atoi ( s . c_str ( ) ) ;			  
	if ( operation == '+' ) :			      	  char operation = arr [ i - 1 ] [ 0 ] ;		    	char operation = arr [ i - 1 ] [ 0 ] ;			  
	    sum += value				      	  if ( operation == '+' ) sum += value ;		    	if ( ( operation == '+' ) || ( operation == '-' ) ) sum + 
	else :						      	  else sum -= value ;					    	else sum -= value ;					  
	    sum -= value				      	}							      }								  
    return sum						      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU COMPUTE_NCR_P_SET_1_INTRODUCTION_AND_DYNAMIC_PROGRAMMING_SOLU
--							      --							    --								  --
def nCrModp ( n , r , p ) :				      int nCrModp ( int n , int r , int p ) {			    int nCrModp ( int n , int r , int p ) {			  failure : #Results: 2, 10
    C = [ 0 for i in range ( r + 1 ) ]			      	int C [ r + 1 ] ;					      int C [ r + 1 ] ;						  
    C [ 0 ] = 1						      	memset ( C , 0 , sizeof ( C ) ) ;			      C [ 0 ] = 1 ;						  
    for i in range ( 1 , n + 1 ) :			      	C [ 0 ] = 1 ;						      for ( int i = 1 ;						  
	for j in range ( min ( i , r ) , 0 , - 1 ) :	      	for ( int i = 1 ;					      i <= n ;							  
	    C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p	      	i <= n ;						      i ++ ) {							  
    return C [ r ]					      	i ++ ) {						    	for ( int j = min ( i , r ) ;				  
							      	  for ( int j = min ( i , r ) ;				    	j > 0 ;							  
							      	  j > 0 ;						    	j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ;	  
							      	  j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ;	      }								  
							      	}							      return C [ r ] ;						  
							      	return C [ r ] ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_REVERSE_STRING_REMOVING_VOWELS			      PRINT_REVERSE_STRING_REMOVING_VOWELS			    PRINT_REVERSE_STRING_REMOVING_VOWELS			  PRINT_REVERSE_STRING_REMOVING_VOWELS
--							      --							    --								  --
def replaceOriginal ( s , n ) :				      void replaceOriginal ( string s , int n ) {		    string replaceOriginal ( string s , int n ) {		  script_not_found : None
    r = [ ' ' ] * n					      	string r ( n , ' ' ) ;					      string r ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	r [ i ] = s [ n - 1 - i ]			      	i < n ;							      i < n ;							  
	if ( s [ i ] != 'a' and s [ i ] != 'e' and s [ i ] != 	i ++ ) {						      i ++ ) {							  
	    print ( r [ i ] , end = "" )		      	  r [ i ] = s [ n - 1 - i ] ;				    	r += ' ' ;						  
    print ( )						      	  if ( s [ i ] != 'a' && s [ i ] != 'e' && s [ i ] != 'i' & 	if ( ( s [ i ] != 'a' && s [ i ] != 'e' && s [ i ] != 'i' 
							      	    cout << r [ i ] ;					    	  r += s [ i ] ;					  
							      	  }							    	}							  
							      	}							      }								  
							      	cout << endl ;						      return r ;						  
							      }								      return " " + s + " " + s ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_BRACKET_NUMBER					      PRINT_BRACKET_NUMBER					    PRINT_BRACKET_NUMBER					  PRINT_BRACKET_NUMBER
--							      --							    --								  --
def printBracketNumber ( exp , n ) :			      void printBracketNumber ( string exp , int n ) {		    void printBracketNumber ( string exp , int n ) {		  script_not_found : None
    left_bnum = 1					      	int left_bnum = 1 ;					      int leftBnum = 1 ;					  
    right_bnum = list ( )				      	stack < int > right_bnum ;				      list < int > rightBnum ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if exp [ i ] == '(' :				      	i < n ;							      i < n ;							  
	    print ( left_bnum , end = " " )		      	i ++ ) {						      i ++ ) {							  
	    right_bnum.append ( left_bnum )		      	  if ( exp [ i ] == '(' ) {				    	if ( exp [ i ] == '(' ) {				  
	    left_bnum += 1				      	    cout << left_bnum << " " ;				    	  cout << leftBnum << " " ;				  
	elif exp [ i ] == ')' :				      	    right_bnum . push ( left_bnum ) ;			    	  rightBnum . push_back ( leftBnum ) ;			  
	    print ( right_bnum [ - 1 ] , end = " " )	      	    left_bnum ++ ;					    	  leftBnum ++ ;						  
	    right_bnum.pop ( )				      	  }							    	}							  
							      	  else if ( exp [ i ] == ')' ) {			    	else if ( exp [ i ] == ')' ) {				  
							      	    cout << right_bnum . top ( ) << " " ;		    	  cout << rightBnum . back ( ) << " " ;			  
							      	    right_bnum . pop ( ) ;				    	  rightBnum . pop_back ( ) ;				  
							      	  }							    	}							  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_AN_ARRAY_OF_0S_1S_AND_2S				      SORT_AN_ARRAY_OF_0S_1S_AND_2S				    SORT_AN_ARRAY_OF_0S_1S_AND_2S				  SORT_AN_ARRAY_OF_0S_1S_AND_2S
--							      --							    --								  --
def sort012 ( a , arr_size ) :				      void sort012 ( int a [ ] , int arr_size ) {		    void sort012 ( int * a , int arrSize ) {			  script_not_found : None
    lo = 0						      	int lo = 0 ;						      int lo = 0 ;						  
    hi = arr_size - 1					      	int hi = arr_size - 1 ;					      int hi = arrSize - 1 ;					  
    mid = 0						      	int mid = 0 ;						      int mid = 0 ;						  
    while mid <= hi :					      	while ( mid <= hi ) {					      while ( mid <= hi ) {					  
	if a [ mid ] == 0 :				      	  switch ( a [ mid ] ) {				    	if ( a [ mid ] == 0 ) {					  
	    a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ]	      	    case 0 : swap ( a [ lo ++ ] , a [ mid ++ ] ) ;	    	  a [ lo ] = a [ mid ] ;				  
	    lo = lo + 1					      	    break ;						    	  a [ mid ] = a [ lo ] ;				  
	    mid = mid + 1				      	    case 1 : mid ++ ;					    	  lo = lo + 1 ;						  
	elif a [ mid ] == 1 :				      	    break ;						    	  mid = mid + 1 ;					  
	    mid = mid + 1				      	    case 2 : swap ( a [ mid ] , a [ hi -- ] ) ;		    	}							  
	else :						      	    break ;						    	else if ( a [ mid ] == 1 ) {				  
	    a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ]	      	  }							    	  mid = mid + 1 ;					  
	    hi = hi - 1					      	}							    	}							  
							      }								    	else {							  
							      								    	  a [ mid ] = a [ hi ] ;				  
							      								    	  a [ hi ] = a [ mid ] ;				  
							      								    	  hi = hi - 1 ;						  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FREQUENCY_ELEMENT_UNSORTED_ARRAY			      FREQUENCY_ELEMENT_UNSORTED_ARRAY				    FREQUENCY_ELEMENT_UNSORTED_ARRAY				  FREQUENCY_ELEMENT_UNSORTED_ARRAY
--							      --							    --								  --
def countFreq ( a , n ) :				      void countFreq ( int a [ ] , int n ) {			    int countFreq ( int a [ ] , int n ) {			  script_not_found : None
    hm = { }						      	unordered_map < int , int > hm ;			      unordered_map < int , int > hm ;				  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	hm [ a [ i ] ] = hm.get ( a [ i ] , 0 ) + 1	      	i < n ;							      i != n ;							  
    st = set ( )					      	i ++ ) hm [ a [ i ] ] ++ ;				      i ++ ) hm [ a [ i ] ] = hm . count ( a [ i ] ) + 1 ;	  
    for x in hm :					      	set < pair < int , int >> st ;				      set < pair < int , int >> st ;				  
	st.add ( ( x , hm [ x ] ) )			      	for ( auto x : hm ) {					      for ( int i = 0 ;						  
    cumul = 0						      	  st . insert ( {					      i != n ;							  
    for x in sorted ( st ) :				      	    x . first , x . second }				      i ++ ) st . insert ( make_pair ( a [ i ] , hm [ a [ i ] ] ) 
	cumul += x [ 1 ]				      	    ) ;							      int cumul = 0 ;						  
	print ( x [ 0 ] , cumul )			      	  }							      for ( set < pair < int , int >> :: iterator it = st . begin 
							      	  int cumul = 0 ;					      it != st . end ( ) ;					  
							      	  for ( auto x : st ) {					      it ++ ) {							  
							      	    cumul += x . second ;				    	cumul += it -> second ;					  
							      	    cout << x . first << " " << cumul << endl ;		    	cout << it -> first << " " << cumul << endl ;		  
							      	  }							      }								  
							      	}							      return cumul ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3	    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_3
--							      --							    --								  --
def printRepeating ( arr , size ) :			      void printRepeating ( int arr [ ] , int size ) {		    void printRepeating ( int * arr , int size ) {		  script_not_found : None
    print ( " The repeating elements are" , end = " " )	      	int i ;							      cout << " The repeating elements are" << endl ;		  
    for i in range ( 0 , size ) :			      	cout << "The repeating elements are" ;			      for ( int i = 0 ;						  
	if ( arr [ abs ( arr [ i ] ) ] > 0 ) :		      	for ( i = 0 ;						      i != size ;						  
	    arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( 	i < size ;						      i ++ ) {							  
	else :						      	i ++ ) {						    	if ( ( arr [ abs ( arr [ i ] ) ] > 0 ) ) arr [ abs ( arr  
	    print ( abs ( arr [ i ] ) , end = " " )	      	  if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i  	else cout << abs ( arr [ i ] ) << " " ;			  
							      	  else cout << " " << abs ( arr [ i ] ) << " " ;	      }								  
							      	}							    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS		      FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS		    FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS		  FIND_THE_MINIMUM_DISTANCE_BETWEEN_TWO_NUMBERS
--							      --							    --								  --
def minDist ( arr , n , x , y ) :			      int minDist ( int arr [ ] , int n , int x , int y ) {	    int minDist ( int * arr , int n , int x , int y ) {		  failure : #Results: 2, 10
    min_dist = 99999999					      	int i , j ;						      int minDist = 99999999 ;					  
    for i in range ( n ) :				      	int min_dist = INT_MAX ;				      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	for ( i = 0 ;						      i < n ;							  
	    if ( x == arr [ i ] and y == arr [ j ] or y == ar 	i < n ;							      i ++ ) {							  
		min_dist = abs ( i - j )		      	i ++ ) {						    	for ( int j = i + 1 ;					  
	return min_dist					      	  for ( j = i + 1 ;					    	j < n ;							  
							      	  j < n ;						    	j ++ ) {						  
							      	  j ++ ) {						    	  if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i 
							      	    if ( ( x == arr [ i ] && y == arr [ j ] || y == arr [ i 	}							  
							      	      min_dist = abs ( i - j ) ;			    	return minDist ;					  
							      	    }							      }								  
							      	  }							      return n * n ;						  
							      	}							    }								  
							      	return min_dist ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES	      COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES		    COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES		  COUNT_ARRAYS_CONSECUTIVE_ELEMENT_DIFFERENT_VALUES
--							      --							    --								  --
def countarray ( n , k , x ) :				      int countarray ( int n , int k , int x ) {		    double countarray ( int n , int k , int x ) {		  script_not_found : None
    dp = list ( )					      	int dp [ MAXN ] = {					      vector < int > dp ;					  
    dp.append ( 0 )					      	  0 }							      dp . push_back ( 0 ) ;					  
    dp.append ( 1 )					      	  ;							      dp . push_back ( 1 ) ;					  
    i = 2						      	  dp [ 0 ] = 0 ;					      int i = 2 ;						  
    while i < n :					      	  dp [ 1 ] = 1 ;					      while ( i < n ) {						  
	dp.append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp 	  for ( int i = 2 ;					    	dp . push_back ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * d 
	i = i + 1					      	  i < n ;						    	i = i + 1 ;						  
    return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 	  i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) *    }								  
							      	  return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ]   return ( x == 1 ) ? dp [ n - 2 ] : dp [ n - 1 ] ;		  
							      	}							    }								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_INCREASING_SUBSEQUENCE_1			      LONGEST_INCREASING_SUBSEQUENCE_1				    LONGEST_INCREASING_SUBSEQUENCE_1				  LONGEST_INCREASING_SUBSEQUENCE_1
--							      --							    --								  --
def lis ( arr ) :					      int lis ( int arr [ ] , int n ) {				    int lis ( int * arr ) {					  error : LONGEST_INCREASING_SUBSEQUENCE_1.cpp: In f
    n = len ( arr )					      	int lis [ n ] ;						      int n = sizeof ( arr ) / sizeof ( int ) ;			  unction ‘int main()’: LONGEST_INCREASING_SUBSEQUEN
    lis = [ 1 ] * n					      	lis [ 0 ] = 1 ;						      int lis [ n ] ;						  CE_1.cpp:57:49: error: too many arguments to funct
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  ion ‘int f_filled(int*)’	    if(f_filled(&par
	for j in range ( 0 , i ) :			      	i < n ;							      i < n ;							  am0[i].front(),param1[i]) == f_gold(&param0[i].fro
	    if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j  	i ++ ) {						      i ++ ) {							  nt(),param1[i]))
		lis [ i ] = lis [ j ] + 1		      	  lis [ i ] = 1 ;					    	for ( int j = 0 ;					  		  ^ LONGEST_INCREASING_SUBSEQUENCE_1
    maximum = 0						      	  for ( int j = 0 ;					    	j < i ;							  .cpp:31:5: note: declared here  int f_filled ( int
    for i in range ( n ) :				      	  j < i ;						    	j ++ ) {						   * arr ) {	  ^~~~~~~~
	maximum = max ( maximum , lis [ i ] )		      	  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j  	  if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 
    return maximum					      	}							    	}							  
							      	return * max_element ( lis , lis + n ) ;		      }								  
							      }								      int maximum = 0 ;						  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) maximum = max ( maximum , lis [ i ] ) ;		  
							      								      return maximum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_TRIANGLES_POSSIBLE			      FIND_NUMBER_OF_TRIANGLES_POSSIBLE				    FIND_NUMBER_OF_TRIANGLES_POSSIBLE				  FIND_NUMBER_OF_TRIANGLES_POSSIBLE
--							      --							    --								  --
def findnumberofTriangles ( arr ) :			      int findNumberOfTriangles ( int arr [ ] , int n ) {	    int findnumberofTriangles ( int * arr ) {			  script_not_found : None
    n = len ( arr )					      	qsort ( arr , n , sizeof ( arr [ 0 ] ) , comp ) ;	      int n = sizeof ( arr ) / sizeof ( int ) ;			  
    arr.sort ( )					      	int count = 0 ;						      sort ( arr , arr + n ) ;					  
    count = 0						      	for ( int i = 0 ;					      int count = 0 ;						  
    for i in range ( 0 , n - 2 ) :			      	i < n - 2 ;						      for ( int i = 0 ;						  
	k = i + 2					      	++ i ) {						      i <= n - 2 ;						  
	for j in range ( i + 1 , n ) :			      	  int k = i + 2 ;					      i ++ ) {							  
	    while ( k < n and arr [ i ] + arr [ j ] > arr [ k 	  for ( int j = i + 1 ;					    	int k = i + 2 ;						  
		k += 1					      	  j < n ;						    	for ( int j = i + 1 ;					  
	    if ( k > j ) :				      	  ++ j ) {						    	j < n ;							  
		count += k - j - 1			      	    while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ 	j ++ ) {						  
    return count					      	    if ( k > j ) count += k - j - 1 ;			    	  while ( ( k < n ) && arr [ i ] + arr [ j ] > arr [ k ]  
							      	  }							    	  if ( ( k > j ) ) count += k - j - 1 ;			  
							      	}							    	}							  
							      	return count ;						      }								  
							      }								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
JUMP_SEARCH						      JUMP_SEARCH						    JUMP_SEARCH							  JUMP_SEARCH
--							      --							    --								  --
def jumpSearch ( arr , x , n ) :			      int jumpSearch ( int arr [ ] , int x , int n ) {		    int jumpSearch ( int * arr , double x , int n ) {		  script_not_found : None
    step = math.sqrt ( n )				      	int step = sqrt ( n ) ;					      double step = sqrt ( n ) ;				  
    prev = 0						      	int prev = 0 ;						      double prev = 0 ;						  
    while arr [ int ( min ( step , n ) - 1 ) ] < x :	      	while ( arr [ min ( step , n ) - 1 ] < x ) {		      while ( arr [ ( int ) ( min ( step , n ) - 1 ) ] < x ) {	  
	prev = step					      	  prev = step ;						    	prev = step ;						  
	step += math.sqrt ( n )				      	  step += sqrt ( n ) ;					    	step += sqrt ( n ) ;					  
	if prev >= n :					      	  if ( prev >= n ) return - 1 ;				    	if ( prev >= n ) return - 1 ;				  
	    return - 1					      	}							      }								  
    while arr [ int ( prev ) ] < x :			      	while ( arr [ prev ] < x ) {				      while ( arr [ ( int ) prev ] < x ) {			  
	prev += 1					      	  prev ++ ;						    	prev ++ ;						  
	if prev == min ( step , n ) :			      	  if ( prev == min ( step , n ) ) return - 1 ;		    	if ( prev == min ( step , n ) ) return - 1 ;		  
	    return - 1					      	}							      }								  
    if arr [ int ( prev ) ] == x :			      	if ( arr [ prev ] == x ) return prev ;			      if ( arr [ ( int ) prev ] == x ) return prev ;		  
	return prev					      	return - 1 ;						      return - 1 ;						  
    return - 1						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y COUNT_DISTINCT_NON_NEGATIVE_PAIRS_X_Y_SATISFY_INEQUALITY_XX_Y
--							      --							    --								  --
def countSolutions ( n ) :				      int countSolutions ( int n ) {				    int countSolutions ( int n ) {				  success : None
    x = 0						      	int x = 0 , yCount , res = 0 ;				      int x = 0 ;						  
    res = 0						      	for ( yCount = 0 ;					      int res = 0 ;						  
    yCount = 0						      	yCount * yCount < n ;					      int yCount = 0 ;						  
    while ( yCount * yCount < n ) :			      	yCount ++ ) ;						      while ( ( yCount * yCount < n ) ) yCount = yCount + 1 ;	  
	yCount = yCount + 1				      	while ( yCount != 0 ) {					      while ( ( yCount != 0 ) ) {				  
    while ( yCount != 0 ) :				      	  res += yCount ;					    	res = res + yCount ;					  
	res = res + yCount				      	  x ++ ;						    	x = x + 1 ;						  
	x = x + 1					      	  while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCoun 	while ( ( yCount != 0 ) && ( x * x + ( yCount - 1 ) * ( y 
	while ( yCount != 0 and ( x * x + ( yCount - 1 ) * (  	}							      }								  
	    yCount = yCount - 1				      	return res ;						      return res ;						  
    return res						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_AREA_TRIANGLE				      C_PROGRAM_FIND_AREA_TRIANGLE				    C_PROGRAM_FIND_AREA_TRIANGLE				  C_PROGRAM_FIND_AREA_TRIANGLE
--							      --							    --								  --
def findArea ( a , b , c ) :				      float findArea ( float a , float b , float c ) {		    double findArea ( double a , double b , double c ) {	  script_not_found : None
    if ( a < 0 or b < 0 or c < 0 or ( a + b <= c ) or ( a + c 	if ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || a + c <=    if ( ( a < 0 || b < 0 || c < 0 || ( a + b <= c ) || ( a + c 
	print ( 'Not a valid trianglen' )		      	  cout << "Not a valid trianglen" ;			    	cout << "Not a valid trianglen" << endl ;		  
	return						      	  exit ( 0 ) ;						    	return 0 ;						  
    s = ( a + b + c ) / 2				      	}							      }								  
    area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5   	float s = ( a + b + c ) / 2 ;				      double s = ( a + b + c ) / 2 ;				  
    print ( 'Area of a traingle is %f' % area )		      	return sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ;	      double area = ( s * ( s - a ) * ( s - b ) * ( s - c ) ) * 0 
							      }								      cout << "Area of a traingle is " << area << endl ;	  
							      								      return area ;						  
							      								      return a * a ;						  
-							      -								      return a * a * a * a * a * a * a * a * a * a * a * a * a *  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING		      FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING		    FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING		  FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING
--							      --							    --								  --
def count ( a , b , m , n ) :				      int count ( string a , string b , int m , int n ) {	    int count ( string a , string b , int m , int n ) {		  script_not_found : None
    if ( ( m == 0 and n == 0 ) or n == 0 ) :		      	if ( ( m == 0 && n == 0 ) || n == 0 ) return 1 ;	      if ( ( ( m == 0 && n == 0 ) || n == 0 ) ) return 1 ;	  
	return 1					      	if ( m == 0 ) return 0 ;				      if ( ( m == 0 ) ) return 0 ;				  
    if ( m == 0 ) :					      	if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m    if ( ( a [ m - 1 ] == b [ n - 1 ] ) ) return ( count ( a ,  
	return 0					      	else return count ( a , b , m - 1 , n ) ;		      else return count ( a , b , m - 1 , n ) ;			  
    if ( a [ m - 1 ] == b [ n - 1 ] ) :			      }								    }								  
	return ( count ( a , b , m - 1 , n - 1 ) + count ( a  								    								  
    else :						      								    								  
	return count ( a , b , m - 1 , n )		      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1		      REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1		    REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1		  REORDER_A_ARRAY_ACCORDING_TO_GIVEN_INDEXES_1
--							      --							    --								  --
def reorder ( arr , index , n ) :			      void reorder ( int arr [ ] , int index [ ] , int n ) {	    int reorder ( int * arr , int * index , int n ) {		  script_not_found : None
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	while ( index [ i ] != i ) :			      	i < n ;							      i != n ;							  
	    oldTargetI = index [ index [ i ] ]		      	i ++ ) {						      i ++ ) {							  
	    oldTargetE = arr [ index [ i ] ]		      	  while ( index [ i ] != i ) {				    	while ( ( index [ i ] != i ) ) {			  
	    arr [ index [ i ] ] = arr [ i ]		      	    int oldTargetI = index [ index [ i ] ] ;		    	  int oldTargetI = index [ index [ i ] ] ;		  
	    index [ index [ i ] ] = index [ i ]		      	    char oldTargetE = arr [ index [ i ] ] ;		    	  int oldTargetE = arr [ index [ i ] ] ;		  
	    index [ i ] = oldTargetI			      	    arr [ index [ i ] ] = arr [ i ] ;			    	  arr [ index [ i ] ] = arr [ i ] ;			  
	    arr [ i ] = oldTargetE			      	    index [ index [ i ] ] = index [ i ] ;		    	  index [ index [ i ] ] = index [ i ] ;			  
							      	    index [ i ] = oldTargetI ;				    	  index [ i ] = oldTargetI ;				  
							      	    arr [ i ] = oldTargetE ;				    	  arr [ i ] = oldTargetE ;				  
							      	  }							    	}							  
							      	}							      }								  
							      }								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION     MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION	    MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION	  MAXIMUM_SUBARRAY_SUM_ARRAY_CREATED_REPEATED_CONCATENATION
--							      --							    --								  --
def maxSubArraySumRepeated ( a , n , k ) :		      int maxSubArraySumRepeated ( int a [ ] , int n , int k ) {    int maxSubArraySumRepeated ( int * a , int n , int k ) {	  success : None
    max_so_far = - 2147483648				      	int max_so_far = INT_MIN , max_ending_here = 0 ;	      int maxSoFar = - 2147483648 ;				  
    max_ending_here = 0					      	for ( int i = 0 ;					      int maxEndingHere = 0 ;					  
    for i in range ( n * k ) :				      	i < n * k ;						      for ( int i = 0 ;						  
	max_ending_here = max_ending_here + a [ i % n ]	      	i ++ ) {						      i < n * k ;						  
	if ( max_so_far < max_ending_here ) :		      	  max_ending_here = max_ending_here + a [ i % n ] ;	      i ++ ) {							  
	    max_so_far = max_ending_here		      	  if ( max_so_far < max_ending_here ) max_so_far = max_endi 	maxEndingHere = maxEndingHere + a [ i % n ] ;		  
	if ( max_ending_here < 0 ) :			      	  if ( max_ending_here < 0 ) max_ending_here = 0 ;	    	if ( ( maxSoFar < maxEndingHere ) ) maxSoFar = maxEndingH 
	    max_ending_here = 0				      	}							    	if ( ( maxEndingHere < 0 ) ) maxEndingHere = 0 ;	  
    return max_so_far					      	return max_so_far ;					      }								  
							      }								      return maxSoFar ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KNAPSACK_PROBLEM					      KNAPSACK_PROBLEM						    KNAPSACK_PROBLEM						  KNAPSACK_PROBLEM
--							      --							    --								  --
def knapSack ( W , wt , val , n ) :			      int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {   int knapSack ( int W , int * wt , int * val , int n ) {	  script_not_found : None
    if n == 0 or W == 0 :				      	if ( n == 0 || W == 0 ) return 0 ;			      if ( n == 0 || W == 0 ) return 0 ;			  
	return 0					      	if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n    if ( ( wt [ n - 1 ] > W ) ) return knapSack ( W , wt , val  
    if ( wt [ n - 1 ] > W ) :				      	else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1   else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 
	return knapSack ( W , wt , val , n - 1 )	      }								    }								  
    else :						      								    								  
	return max ( val [ n - 1 ] + knapSack ( W - wt [ n -  								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND			      CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND			    CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND			  CALCULATE_ANGLE_HOUR_HAND_MINUTE_HAND
--							      --							    --								  --
def calcAngle ( h , m ) :				      int calcAngle ( double h , double m ) {			    double calcAngle ( int h , int m ) {			  failure : Wrong input Wrong inputWrong input Wrong
    if ( h < 0 or m < 0 or h > 12 or m > 60 ) :		      	if ( h < 0 || m < 0 || h > 12 || m > 60 ) printf ( "Wrong i   if ( ( h < 0 || m < 0 || h > 12 || m > 60 ) ) cout << "Wron  inputWrong input Wrong inputWrong input Wrong inp
	print ( 'Wrong input' )				      	if ( h == 12 ) h = 0 ;					      if ( ( h == 12 ) ) h = 0 ;				  utWrong input Wrong inputWrong input Wrong inputWr
    if ( h == 12 ) :					      	if ( m == 60 ) m = 0 ;					      if ( ( m == 60 ) ) m = 0 ;				  ong input Wrong inputWrong input Wrong inputWrong
	h = 0						      	int hour_angle = 0.5 * ( h * 60 + m ) ;			      double hourAngle = 0.5 * ( h * 60 + m ) ;			  input Wrong inputWrong input Wrong input#Results:
    if ( m == 60 ) :					      	int minute_angle = 6 * m ;				      double minuteAngle = 6 * m ;				  0, 10
	m = 0						      	int angle = abs ( hour_angle - minute_angle ) ;		      double angle = fabs ( hourAngle - minuteAngle ) ;		  
    hour_angle = 0.5 * ( h * 60 + m )			      	angle = min ( 360 - angle , angle ) ;			      angle = min ( 360 - angle , angle ) ;			  
    minute_angle = 6 * m				      	return angle ;						      return angle ;						  
    angle = abs ( hour_angle - minute_angle )		      }								    }								  
    angle = min ( 360 - angle , angle )			      								    								  
    return angle					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE			      PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE			    PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE			  PROGRAM_CENSOR_WORD_ASTERISKS_SENTENCE
--							      --							    --								  --
def censor ( text , word ) :				      string censor ( string text , string word ) {		    string censor ( string text , char word ) {			  script_not_found : None
    word_list = text.split ( )				      	vector < string > word_list ;				      string wordArray = text ;					  
    result = ''						      	boost :: split ( word_list , text , boost :: is_any_of ( "\   string result ;						  
    stars = '*' * len ( word )				      	string result = "" ;					      char stars [ word ] ;					  
    count = 0						      	string stars = "" ;					      int count = 0 ;						  
    index = 0						      	for ( int i = 0 ;					      int index = 0 ;						  
    for i in word_list :				      	i < word . size ( ) ;					      for ( int i = 0 ;						  
	if i == word :					      	i ++ ) stars += '*' ;					      i < count ;						  
	    word_list [ index ] = stars			      	int index = 0 ;						      i ++ ) {							  
	index += 1					      	for ( string i : word_list ) {				    	if ( wordArray [ index ] == word ) wordArray [ index ] =  
    result = ' '.join ( word_list )			      	  if ( i . compare ( word ) == 0 ) {			    	index ++ ;						  
    return result					      	    word_list [ index ] = stars ;			      }								  
							      	  }							      result = wordArray ;					  
							      	  index ++ ;						      return result ;						  
							      	}							    }								  
							      	for ( string i : word_list ) {				    								  
							      	  result += i + ' ' ;					    								  
							      	}							    								  
							      	return result ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MULTISTAGE_GRAPH_SHORTEST_PATH				      MULTISTAGE_GRAPH_SHORTEST_PATH				    MULTISTAGE_GRAPH_SHORTEST_PATH				  MULTISTAGE_GRAPH_SHORTEST_PATH
--							      --							    --								  --
def shortestDist ( graph ) :				      INT_MAX int shortestDist ( int graph [ N ] [ N ] ) {	    int shortestDist ( int * * graph ) {			  script_not_found : None
    global INF						      	int dist [ N ] ;					      static int INF = 0 ;					  
    dist = [ 0 ] * N					      	dist [ N - 1 ] = 0 ;					      int dist [ N ] ;						  
    dist [ N - 1 ] = 0					      	for ( int i = N - 2 ;					      memset ( dist , 0 , sizeof ( dist ) ) ;			  
    for i in range ( N - 2 , - 1 , - 1 ) :		      	i >= 0 ;						      dist [ N - 1 ] = 0 ;					  
	dist [ i ] = INF				      	i -- ) {						      for ( int i = N - 2 ;					  
	for j in range ( N ) :				      	  dist [ i ] = INF ;					      i >= 0 ;							  
	    if graph [ i ] [ j ] == INF :		      	  for ( int j = i ;					      i -- ) {							  
		continue				      	  j < N ;						    	dist [ i ] = INF ;					  
	    dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] 	  j ++ ) {						    	for ( int j = 0 ;					  
    return dist [ 0 ]					      	    if ( graph [ i ] [ j ] == INF ) continue ;		    	j < N ;							  
							      	    dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dis 	j ++ ) {						  
							      	  }							    	  if ( graph [ i ] [ j ] == INF ) continue ;		  
							      	}							    	  dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dis 
							      	return dist [ 0 ] ;					    	}							  
							      }								      }								  
							      								      return dist [ 0 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TILING_WITH_DOMINOES					      TILING_WITH_DOMINOES					    TILING_WITH_DOMINOES					  TILING_WITH_DOMINOES
--							      --							    --								  --
def countWays ( n ) :					      int countWays ( int n ) {					    int countWays ( int n ) {					  success : None
    A = [ 0 ] * ( n + 1 )				      	int A [ n + 1 ] , B [ n + 1 ] ;				      vector < int > A ( n + 1 , 0 ) ;				  
    B = [ 0 ] * ( n + 1 )				      	A [ 0 ] = 1 , A [ 1 ] = 0 , B [ 0 ] = 0 , B [ 1 ] = 1 ;	      vector < int > B ( n + 1 , 0 ) ;				  
    A [ 0 ] = 1						      	for ( int i = 2 ;					      A [ 0 ] = 1 ;						  
    A [ 1 ] = 0						      	i <= n ;						      A [ 1 ] = 0 ;						  
    B [ 0 ] = 0						      	i ++ ) {						      B [ 0 ] = 0 ;						  
    B [ 1 ] = 1						      	  A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ;		      B [ 1 ] = 1 ;						  
    for i in range ( 2 , n + 1 ) :			      	  B [ i ] = A [ i - 1 ] + B [ i - 2 ] ;			      for ( int i = 2 ;						  
	A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ]		      	}							      i <= n ;							  
	B [ i ] = A [ i - 1 ] + B [ i - 2 ]		      	return A [ n ] ;					      i ++ ) {							  
    return A [ n ]					      }								    	A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ;		  
							      								    	B [ i ] = A [ i - 1 ] + B [ i - 2 ] ;			  
							      								      }								  
							      								      return A [ n ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS			      NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS			    NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS			  NUMBER_OF_PERMUTATION_WITH_K_INVERSIONS
--							      --							    --								  --
def numberOfPermWithKInversion ( N , K ) :		      int numberOfPermWithKInversion ( int N , int K ) {	    int numberOfPermWithKInversion ( int N , int K ) {		  script_not_found : None
    if ( N == 0 ) : return 0				      	if ( N == 0 ) return 0 ;				      if ( ( N == 0 ) ) return 0 ;				  
    if ( K == 0 ) : return 1				      	if ( K == 0 ) return 1 ;				      if ( ( K == 0 ) ) return 1 ;				  
    if ( memo [ N ] [ K ] != 0 ) :			      	if ( memo [ N ] [ K ] != 0 ) return memo [ N ] [ K ] ;	      if ( ( memo [ N ] [ K ] != 0 ) ) return memo [ N ] [ K ] ;  
	return memo [ N ] [ K ]				      	int sum = 0 ;						      int sum = 0 ;						  
    sum = 0						      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( K + 1 ) :				      	i <= K ;						      i < K + 1 ;						  
	if ( i <= N - 1 ) :				      	i ++ ) {						      i ++ ) {							  
	    sum += numberOfPermWithKInversion ( N - 1 , K - i 	  if ( i <= N - 1 ) sum += numberOfPermWithKInversion ( N - 	if ( ( i <= N - 1 ) ) sum += numberOfPermWithKInversion ( 
    memo [ N ] [ K ] = sum				      	}							      }								  
    return sum						      	memo [ N ] [ K ] = sum ;				      memo [ N ] [ K ] = sum ;					  
							      	return sum ;						      return sum ;						  
							      }								      return N * N ;						  
							      								      return N * N ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS		      NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS		    NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS		  NEXT_HIGHER_NUMBER_WITH_SAME_NUMBER_OF_SET_BITS
--							      --							    --								  --
def snoob ( x ) :					      uint_t snoob ( uint_t x ) {				    int snoob ( int x ) {					  script_not_found : None
    next = 0						      	uint_t rightOne ;					      int next = 0 ;						  
    if ( x ) :						      	uint_t nextHigherOneBit ;				      if ( ( x ) ) {						  
	rightOne = x & - ( x )				      	uint_t rightOnesPattern ;				    	int rightOne = x & - ( x ) ;				  
	nextHigherOneBit = x + int ( rightOne )		      	uint_t next = 0 ;					    	int nextHigherOneBit = x + ( int ) rightOne ;		  
	rightOnesPattern = x ^ int ( nextHigherOneBit )	      	if ( x ) {						    	int rightOnesPattern = x ^ ( int ) nextHigherOneBit ;	  
	rightOnesPattern = ( int ( rightOnesPattern ) / int ( 	  rightOne = x & - ( signed ) x ;			    	rightOnesPattern = ( ( int ) rightOnesPattern ) / ( ( int 
	rightOnesPattern = int ( rightOnesPattern ) >> 2      	  nextHigherOneBit = x + rightOne ;			    	rightOnesPattern = ( ( int ) rightOnesPattern ) >> 2 ;	  
	next = nextHigherOneBit | rightOnesPattern	      	  rightOnesPattern = x ^ nextHigherOneBit ;		    	next = nextHigherOneBit | rightOnesPattern ;		  
    return next						      	  rightOnesPattern = ( rightOnesPattern ) / rightOne ;	      }								  
							      	  rightOnesPattern >>= 2 ;				      return next ;						  
							      	  next = nextHigherOneBit | rightOnesPattern ;		    }								  
							      	}							    								  
							      	return next ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FREQUENCY_ELEMENT_UNSORTED_ARRAY_1			      FREQUENCY_ELEMENT_UNSORTED_ARRAY_1			    FREQUENCY_ELEMENT_UNSORTED_ARRAY_1				  FREQUENCY_ELEMENT_UNSORTED_ARRAY_1
--							      --							    --								  --
def countFreq ( a , n ) :				      void countFreq ( int a [ ] , int n ) {			    int countFreq ( int a [ ] , int n ) {			  script_not_found : None
    hm = dict ( )					      	unordered_map < int , int > hm ;			      map < int , int > hm ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	hm [ a [ i ] ] = hm.get ( a [ i ] , 0 ) + 1	      	i < n ;							      i < n ;							  
    cumul = 0						      	i ++ ) hm [ a [ i ] ] ++ ;				      i ++ ) hm [ a [ i ] ] = hm . count ( a [ i ] ) + 1 ;	  
    for i in range ( n ) :				      	int cumul = 0 ;						      int cumul = 0 ;						  
	cumul += hm [ a [ i ] ]				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( hm [ a [ i ] ] > 0 ) :			      	i < n ;							      i < n ;							  
	    print ( a [ i ] , "->" , cumul )		      	i ++ ) {						      i ++ ) {							  
	hm [ a [ i ] ] = 0				      	  cumul += hm [ a [ i ] ] ;				    	cumul += hm [ a [ i ] ] ;				  
							      	  if ( hm [ a [ i ] ] ) {				    	if ( ( hm [ a [ i ] ] > 0 ) && ( hm [ a [ i ] ] < 0 ) ) c 
							      	    cout << a [ i ] << "->" << cumul << endl ;		    	hm [ a [ i ] ] = 0 ;					  
							      	  }							      }								  
							      	  hm [ a [ i ] ] = 0 ;					      return cumul ;						  
							      	}							    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE			      FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE			    FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE			  FIND_DIMENSIONS_RIGHT_ANGLED_TRIANGLE
--							      --							    --								  --
def findDimen ( H , A ) :				      void findDimen ( int H , int A ) {			    void findDimen ( int H , int A ) {				  script_not_found : None
    if H * H < 4 * A :					      	if ( H * H < 4 * A ) {					      if ( H * H < 4 * A ) {					  
	print ( "Not Possible" )			      	  cout << "Not Possible\n" ;				    	cout << "Not Possible" << endl ;			  
	return						      	  return ;						    	return ;						  
    apb = sqrt ( H * H + 4 * A )			      	}							      }								  
    asb = sqrt ( H * H - 4 * A )			      	double apb = sqrt ( H * H + 4 * A ) ;			      double apb = sqrt ( H * H + 4 * A ) ;			  
    print ( "P = " , "%.2f" % ( ( apb - asb ) / 2.0 ) )	      	double asb = sqrt ( H * H - 4 * A ) ;			      double asb = sqrt ( H * H - 4 * A ) ;			  
    print ( "B = " , "%.2f" % ( ( apb + asb ) / 2.0 ) )	      	cout . precision ( 2 ) ;				      cout << "P = " << "" << ( ( apb - asb ) / 2.0 ) << endl ;	  
							      	cout << "P = " << fixed << ( apb - asb ) / 2.0 << "\n" ;      cout << "B = " << "" << ( ( apb + asb ) / 2.0 ) << endl ;	  
							      	cout << "B = " << ( apb + asb ) / 2.0 ;			    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PAIRS_WITH_GIVEN_SUM_1				      COUNT_PAIRS_WITH_GIVEN_SUM_1				    COUNT_PAIRS_WITH_GIVEN_SUM_1				  COUNT_PAIRS_WITH_GIVEN_SUM_1
--							      --							    --								  --
def getPairsCount ( arr , n , sum ) :			      int getPairsCount ( int arr [ ] , int n , int sum ) {	    int getPairsCount ( int * arr , int n , int sum ) {		  script_not_found : None
    m = [ 0 ] * 1000					      	unordered_map < int , int > m ;				      vector < int > m ( 1000 , 0 ) ;				  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	m [ arr [ i ] ]					      	i < n ;							      i != n ;							  
	m [ arr [ i ] ] += 1				      	i ++ ) m [ arr [ i ] ] ++ ;				      i ++ ) {							  
    twice_count = 0					      	int twice_count = 0 ;					    	m [ arr [ i ] ] ++ ;					  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					    	m [ arr [ i ] ] ++ ;					  
	twice_count += m [ sum - arr [ i ] ]		      	i < n ;							      }								  
	if ( sum - arr [ i ] == arr [ i ] ) :		      	i ++ ) {						      int twice_count = 0 ;					  
	    twice_count -= 1				      	  twice_count += m [ sum - arr [ i ] ] ;		      for ( int i = 0 ;						  
    return int ( twice_count / 2 )			      	  if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ;	      i != n ;							  
							      	}							      i ++ ) {							  
							      	return twice_count / 2 ;				    	twice_count += m [ sum - arr [ i ] ] ;			  
							      }								    	if ( ( sum - arr [ i ] ) == arr [ i ] ) twice_count -- ;  
							      								      }								  
							      								      return ( int ) ( twice_count / 2 ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECAMANS_SEQUENCE_1					      RECAMANS_SEQUENCE_1					    RECAMANS_SEQUENCE_1						  RECAMANS_SEQUENCE_1
--							      --							    --								  --
def recaman ( n ) :					      void recaman ( int n ) {					    int recaman ( int n ) {					  script_not_found : None
    if ( n <= 0 ) :					      	if ( n <= 0 ) return ;					      if ( ( n <= 0 ) ) return n ;				  
	return						      	printf ( "%d, " , 0 ) ;					      cout << 0 << "," << endl ;				  
    print ( 0 , "," , end = '' )			      	unordered_set < int > s ;				      set < int > s ;						  
    s = set ( [ ] )					      	s . insert ( 0 ) ;					      s . insert ( 0 ) ;					  
    s.add ( 0 )						      	int prev = 0 ;						      int prev = 0 ;						  
    prev = 0						      	for ( int i = 1 ;					      for ( int i = 1 ;						  
    for i in range ( 1 , n ) :				      	i < n ;							      i < n ;							  
	curr = prev - i					      	i ++ ) {						      i ++ ) {							  
	if ( curr < 0 or curr in s ) :			      	  int curr = prev - i ;					    	int curr = prev - i ;					  
	    curr = prev + i				      	  if ( curr < 0 || s . find ( curr ) != s . end ( ) ) curr  	if ( ( curr < 0 ) || ( curr >= s . size ( ) ) ) curr = pr 
	s.add ( curr )					      	  s . insert ( curr ) ;					    	s . insert ( curr ) ;					  
	print ( curr , "," , end = '' )			      	  printf ( "%d, " , curr ) ;				    	cout << curr << "," << endl ;				  
	prev = curr					      	  prev = curr ;						    	prev = curr ;						  
							      	}							      }								  
							      }								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3		      NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3		    NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3		  NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3
--							      --							    --								  --
def divisible ( num ) :					      int divisible ( string num ) {				    int divisible ( string num ) {				  error : NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBL
    n = len ( num )					      	int n = num . length ( ) ;				      int n = num . length ( ) ;				  E_3.cpp: In function ‘int f_filled(std::__cxx11::s
    sum = 0						      	int sum = accumulate ( begin ( num ) , end ( num ) , 0 ) -    int sum = 0 ;						  tring)’: NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIB
    for i in range ( n ) :				      	if ( sum % 3 == 0 ) return 0 ;				      for ( int i = 0 ;						  LE_3.cpp:34:36: error: request for member ‘c_str’
	sum += int ( num [ i ] )			      	if ( n == 1 ) return - 1 ;				      i < n ;							  in ‘num.std::__cxx11::basic_string<char>::operator
    if ( sum % 3 == 0 ) :				      	for ( int i = 0 ;					      i ++ ) sum += atoi ( num [ i ] . c_str ( ) ) ;		  [](((std::__cxx11::basic_string<char>::size_type)i
	return 0					      	i < n ;							      if ( ( sum % 3 == 0 ) ) return 0 ;			  ))’, which is of non-class type ‘__gnu_cxx::__allo
    if ( n == 1 ) :					      	i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ;   if ( ( n == 1 ) ) return - 1 ;				  c_traits<std::allocator<char>, char>::value_type’
	return - 1					      	if ( n == 2 ) return - 1 ;				      for ( int i = 0 ;						  {aka ‘char’}	  i ++ ) sum += atoi ( num [ i ] . c
    for i in range ( n ) :				      	return 2 ;						      i < n ;							  _str ( ) ) ;					   ^
	if ( sum % 3 == int ( num [ i ] ) % 3 ) :	      }								      i ++ ) if ( ( sum % 3 == atoi ( num [ i ] . c_str ( ) ) % 3 ~~~~ NUMBER_DIGITS_REMOVED_MAKE_NUMBER_DIVISIBLE_3
	    return 1					      								      if ( ( n == 2 ) ) return - 1 ;				  .cpp:39:47: error: request for member ‘c_str’ in ‘
    if ( n == 2 ) :					      								      return 2 ;						  num.std::__cxx11::basic_string<char>::operator[]((
	return - 1					      								      return n * n ;						  (std::__cxx11::basic_string<char>::size_type)i))’,
    return 2						      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *   which is of non-class type ‘__gnu_cxx::__alloc_tr
							      								    }								  aits<std::allocator<char>, char>::value_type’ {aka
							      								    								   ‘char’}    i ++ ) if ( ( sum % 3 == atoi ( num [
							      								    								  i ] . c_str ( ) ) % 3 ) ) return 1 ;
							      								    								  				    ^~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT			      KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT			    KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT			  KTH_ADJACENT_NODE_GRAPH_VERTEX_WEIGHT
--							      --							    --								  --
def printkthnode ( adj , wt , n , k ) :			      void printkthnode ( vector < pair < int , int >> adj [ ] , in int printkthnode ( int * * adj , double * wt , int n , int k  script_not_found : None
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	adj [ i ].sort ( )				      	i < n ;							      i < n ;							  
    for i in range ( n ) :				      	i ++ ) sort ( adj [ i ] . begin ( ) , adj [ i ] . end ( ) )   i ++ ) adj [ i ] = sort ( wt , wt + n ) ;			  
	if ( len ( adj [ i ] ) >= k ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    print ( adj [ i ] [ len ( adj [ i ] ) - k ] [ 1 ] 	i < n ;							      i < n ;							  
	else :						      	i ++ ) {						      i ++ ) {							  
	    print ( "-1" , end = " " )			      	  if ( adj [ i ] . size ( ) >= k ) cout << adj [ i ] [ adj  	if ( ( adj [ i ] [ adj [ i ] - k ] ) && ( adj [ i ] [ adj 
							      	  else cout << "-1" ;					    	else cout << "-1" ;					  
							      	}							      }								  
							      }								      return 0 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_ LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_ LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_ LONGEST_SUBSEQUENCE_WHERE_EVERY_CHARACTER_APPEARS_AT_LEAST_K_
--							      --							    --								  --
def longestSubseqWithK ( str , k ) :			      void longestSubseqWithK ( string str , int k ) {		    int longestSubseqWithK ( string str , int k ) {		  script_not_found : None
    n = len ( str )					      	int n = str . size ( ) ;				      int n = str . length ( ) ;				  
    freq = [ 0 ] * MAX_CHARS				      	int freq [ MAX_CHARS ] = {				      vector < int > freq ( MAX_CHARS , 0 ) ;			  
    for i in range ( n ) :				      	  0 }							      for ( int i = 0 ;						  
	freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1	      	  ;							      i < n ;							  
    for i in range ( n ) :				      	  for ( int i = 0 ;					      i ++ ) freq [ str [ i ] - 'a' ] ++ ;			  
	if ( freq [ ord ( str [ i ] ) - ord ( 'a' ) ] >= k )  	  i < n ;						      for ( int i = 0 ;						  
	    print ( str [ i ] , end = "" )		      	  i ++ ) freq [ str [ i ] - 'a' ] ++ ;			      i < n ;							  
							      	  for ( int i = 0 ;					      i ++ ) if ( ( freq [ str [ i ] - 'a' ] ) >= k ) cout << str 
							      	  i < n ;						      return n ;						  
							      	  i ++ ) if ( freq [ str [ i ] - 'a' ] >= k ) cout << str [   return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      	}							    }								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS			      LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS			    LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS				  LONGEST_SPAN_SUM_TWO_BINARY_ARRAYS
--							      --							    --								  --
def longestCommonSum ( arr1 , arr2 , n ) :		      int longestCommonSum ( bool arr1 [ ] , bool arr2 [ ] , int n  int longestCommonSum ( int * arr1 , int * arr2 , int n ) {	  script_not_found : None
    maxLen = 0						      	int maxLen = 0 ;					      int maxLen = 0 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	sum1 = 0					      	i < n ;							      i < n ;							  
	sum2 = 0					      	i ++ ) {						      i ++ ) {							  
	for j in range ( i , n ) :			      	  int sum1 = 0 , sum2 = 0 ;				    	int sum1 = 0 ;						  
	    sum1 += arr1 [ j ]				      	  for ( int j = i ;					    	int sum2 = 0 ;						  
	    sum2 += arr2 [ j ]				      	  j < n ;						    	for ( int j = i ;					  
	    if ( sum1 == sum2 ) :			      	  j ++ ) {						    	j < n ;							  
		len = j - i + 1				      	    sum1 += arr1 [ j ] ;				    	j ++ ) {						  
		if ( len > maxLen ) :			      	    sum2 += arr2 [ j ] ;				    	  sum1 += arr1 [ j ] ;					  
		    maxLen = len			      	    if ( sum1 == sum2 ) {				    	  sum2 += arr2 [ j ] ;					  
    return maxLen					      	      int len = j - i + 1 ;				    	  if ( ( sum1 == sum2 ) && ( sum1 < sum2 ) ) {		  
							      	      if ( len > maxLen ) maxLen = len ;		    	    int len = j - i + 1 ;				  
							      	    }							    	    if ( ( len > maxLen ) ) maxLen = len ;		  
							      	  }							    	  }							  
							      	}							    	}							  
							      	return maxLen ;						      }								  
							      }								      return maxLen ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE	      COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE		    COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE		  COUNT_NUMBER_ISLANDS_EVERY_ISLAND_SEPARATED_LINE
--							      --							    --								  --
def countIslands ( mat ) :				      int countIslands ( int mat [ ] [ N ] ) {			    int countIslands ( string mat ) {				  script_not_found : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( 0 , M ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( 0 , N ) :			      	i < M ;							      i <= M ;							  
	    if ( mat [ i ] [ j ] == 'X' ) :		      	i ++ ) {						      i ++ ) {							  
		if ( ( i == 0 or mat [ i - 1 ] [ j ] == 'O' ) 	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
		    count = count + 1			      	  j < N ;						    	j <= N ;						  
    return count					      	  j ++ ) {						    	j ++ ) {						  
							      	    if ( mat [ i ] [ j ] == 'X' ) {			    	  if ( ( mat [ i ] [ j ] == 'X' ) ) {			  
							      	      if ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && ( j  	    if ( ( ( i == 0 || mat [ i - 1 ] [ j ] == 'O' ) && (  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STERN_BROCOT_SEQUENCE					      STERN_BROCOT_SEQUENCE					    STERN_BROCOT_SEQUENCE					  STERN_BROCOT_SEQUENCE
--							      --							    --								  --
def SternSequenceFunc ( BrocotSequence , n ) :		      void SternSequenceFunc ( vector < int > & BrocotSequence , in int SternSequenceFunc ( string BrocotSequence , int n ) {	  script_not_found : None
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	considered_element = BrocotSequence [ i ]	      	BrocotSequence . size ( ) < n ;				      i < n ;							  
	precedent = BrocotSequence [ i - 1 ]		      	i ++ ) {						      i ++ ) {							  
	BrocotSequence.append ( considered_element + preceden 	  int considered_element = BrocotSequence [ i ] ;	    	char considered_element = BrocotSequence [ i ] ;	  
	BrocotSequence.append ( considered_element )	      	  int precedent = BrocotSequence [ i - 1 ] ;		    	char precedent = BrocotSequence [ i - 1 ] ;		  
    for i in range ( 0 , 15 ) :				      	  BrocotSequence . push_back ( considered_element + precede 	BrocotSequence += considered_element + precedent ;	  
	print ( BrocotSequence [ i ] , end = " " )	      	  BrocotSequence . push_back ( considered_element ) ;	    	BrocotSequence += considered_element ;			  
							      	}							      }								  
							      	for ( int i = 0 ;					      for ( int i = 0 ;						  
							      	i < 15 ;						      i <= 15 ;							  
							      	++ i ) cout << BrocotSequence [ i ] << " " ;		      i ++ ) cout << BrocotSequence [ i ] << " " ;		  
							      }								      return 0 ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT	      GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT	    GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT	  GIVEN_AN_ARRAY_OF_PAIRS_FIND_ALL_SYMMETRIC_PAIRS_IN_IT
--							      --							    --								  --
def findSymPairs ( arr , row ) :			      void findSymPairs ( int arr [ ] [ 2 ] , int row ) {	    int findSymPairs ( int * * arr , int row ) {		  script_not_found : None
    hM = dict ( )					      	unordered_map < int , int > hM ;			      map < int , int > hM ;					  
    for i in range ( row ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	first = arr [ i ] [ 0 ]				      	i < row ;						      i < row ;							  
	sec = arr [ i ] [ 1 ]				      	i ++ ) {						      i ++ ) {							  
	if ( sec in hM.keys ( ) and hM [ sec ] == first ) :   	  int first = arr [ i ] [ 0 ] ;				    	int first = arr [ i ] [ 0 ] ;				  
	    print ( "(" , sec , "," , first , ")" )	      	  int sec = arr [ i ] [ 1 ] ;				    	int sec = arr [ i ] [ 1 ] ;				  
	else :						      	  if ( hM . find ( sec ) != hM . end ( ) && hM [ sec ] == f 	if ( ( sec < hM . size ( ) ) && hM [ sec ] == first ) cou 
	    hM [ first ] = sec				      	  else hM [ first ] = sec ;				    	else hM [ first ] = sec ;				  
							      	}							      }								  
							      }								      return row ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PANGRAM_CHECKING					      PANGRAM_CHECKING						    PANGRAM_CHECKING						  PANGRAM_CHECKING
--							      --							    --								  --
def checkPangram ( s ) :				      bool checkPangram ( string & str ) {			    bool checkPangram ( string s ) {				  error : PANGRAM_CHECKING.cpp: In function ‘bool f_
    List = [ ]						      	vector < bool > mark ( 26 , false ) ;			      vector < bool > List ;					  filled(std::__cxx11::string)’: PANGRAM_CHECKING.cp
    for i in range ( 26 ) :				      	int index ;						      for ( int i = 0 ;						  p:38:30: error: ‘begin’ was not declared in this s
	List.append ( False )				      	for ( int i = 0 ;					      i < 26 ;							  cope	  for ( char c : s . c_str ( ) ) {
    for c in s.lower ( ) :				      	i < str . length ( ) ;					      i ++ ) List . push_back ( false ) ;			  		       ^ PANGRAM_CHECKING.cpp:38:30:
	if not c == " " :				      	i ++ ) {						      for ( char c : s . c_str ( ) ) {				   note: suggested alternative: In file included fro
	    List [ ord ( c ) - ord ( 'a' ) ] = True	      	  if ( 'A' <= str [ i ] && str [ i ] <= 'Z' ) index = str [ 	if ( ! c == ' ' ) List [ c - 'a' ] = true ;		  m /usr/include/c++/8/x86_64-redhat-linux/bits/stdc
    for ch in List :					      	  else if ( 'a' <= str [ i ] && str [ i ] <= 'z' ) index =    }								  ++.h:95,		    from PANGRAM_CHECKING.cp
	if ch == False :				      	  mark [ index ] = true ;				      for ( bool ch : List ) {					  p:14: /usr/include/c++/8/valarray:1211:5: note:
	    return False				      	}							    	if ( ch == false ) return false ;			  ‘std::begin’	    begin(const valarray<_Tp>& __va)
    return True						      	for ( int i = 0 ;					      }								  	^~~~~ PANGRAM_CHECKING.cpp:38:30: error: ‘en
							      	i <= 25 ;						      return true ;						  d’ was not declared in this scope    for ( char c
							      	i ++ ) if ( mark [ i ] == false ) return ( false ) ;	    }								  : s . c_str ( ) ) {
							      	return ( true ) ;					    								  ^ PANGRAM_CHECKING.cpp:38:30: note: suggested alte
							      }								    								  rnative: In file included from /usr/include/c++/8/
							      								    								  x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								       from PANGRAM_CHECKING.cpp:14: /usr/include/c+
							      								    								  +/8/valarray:1231:5: note:   ‘std::end’      end(c
							      								    								  onst valarray<_Tp>& __va)	 ^~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES		      FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES		    FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES		  FIND_N_TH_ELEMENT_FROM_STERNS_DIATOMIC_SERIES
--							      --							    --								  --
def findSDSFunc ( n ) :					      int findSDSFunc ( int n ) {				    int findSDSFunc ( int n ) {					  success : None
    DP = [ 0 ] * ( n + 1 )				      	int DP [ n + 1 ] ;					      vector < int > DP ( n + 1 , 0 ) ;				  
    DP [ 0 ] = 0					      	DP [ 0 ] = 0 ;						      DP [ 0 ] = 0 ;						  
    DP [ 1 ] = 1					      	DP [ 1 ] = 1 ;						      DP [ 1 ] = 1 ;						  
    for i in range ( 2 , n + 1 ) :			      	for ( int i = 2 ;					      for ( int i = 2 ;						  
	if ( int ( i % 2 ) == 0 ) :			      	i <= n ;						      i <= n ;							  
	    DP [ i ] = DP [ int ( i / 2 ) ]		      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ;		    	if ( ( ( int ) i % 2 ) == 0 ) DP [ i ] = DP [ ( int ) ( i 
	    DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [  	  else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 	else DP [ i ] = ( DP [ ( int ) ( ( i - 1 ) / 2 ) ] + DP [ 
    return DP [ n ]					      	}							      }								  
							      	return DP [ n ] ;					      return DP [ n ] ;						  
							      }								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAJORITY_ELEMENT					      MAJORITY_ELEMENT						    MAJORITY_ELEMENT						  MAJORITY_ELEMENT
--							      --							    --								  --
def findMajority ( arr , n ) :				      void findMajority ( int arr [ ] , int n ) {		    int findMajority ( int * arr , int n ) {			  script_not_found : None
    maxCount = 0 ;					      	int maxCount = 0 ;					      int maxCount = 0 ;					  
    index = - 1						      	int index = - 1 ;					      int index = - 1 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	count = 0					      	i < n ;							      i < n ;							  
	for j in range ( n ) :				      	i ++ ) {						      i ++ ) {							  
	    if ( arr [ i ] == arr [ j ] ) :		      	  int count = 0 ;					    	int count = 0 ;						  
		count += 1				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	if ( count > maxCount ) :			      	  j < n ;						    	j < n ;							  
	    maxCount = count				      	  j ++ ) {						    	j ++ ) {						  
	    index = i					      	    if ( arr [ i ] == arr [ j ] ) count ++ ;		    	  if ( ( arr [ i ] == arr [ j ] ) ) count ++ ;		  
    if ( maxCount > n // 2 ) :				      	  }							    	}							  
	print ( arr [ index ] )				      	  if ( count > maxCount ) {				    	if ( ( count > maxCount ) ) {				  
    else :						      	    maxCount = count ;					    	  maxCount = count ;					  
	print ( "No Majority Element" )			      	    index = i ;						    	  index = i ;						  
							      	  }							    	}							  
							      	}							      }								  
							      	if ( maxCount > n / 2 ) cout << arr [ index ] << endl ;	      if ( ( maxCount > n / 2 ) ) cout << arr [ index ] << endl ; 
							      	else cout << "No Majority Element" << endl ;		      else cout << "No Majority Element" << endl ;		  
							      }								      return maxCount ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY  DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY  DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY  DIFFERENCE_BETWEEN_HIGHEST_AND_LEAST_FREQUENCIES_IN_AN_ARRAY
--							      --							    --								  --
def findDiff ( arr , n ) :				      int findDiff ( int arr [ ] , int n ) {			    int findDiff ( int * arr , int n ) {			  success : None
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    count = 0 max_count = 0 min_count = n		      	int count = 0 , max_count = 0 , min_count = n ;		      int count = 0 ;						  
    for i in range ( 0 , ( n - 1 ) ) :			      	for ( int i = 0 ;					      int maxCount = 0 ;					  
	if arr [ i ] == arr [ i + 1 ] :			      	i < ( n - 1 ) ;						      int minCount = n ;					  
	    count += 1					      	i ++ ) {						      for ( int i = 0 ;						  
	    continue					      	  if ( arr [ i ] == arr [ i + 1 ] ) {			      i <= ( n - 1 ) ;						  
	else :						      	    count += 1 ;					      i ++ ) {							  
	    max_count = max ( max_count , count )	      	    continue ;						    	if ( arr [ i ] == arr [ i + 1 ] ) {			  
	    min_count = min ( min_count , count )	      	  }							    	  count ++ ;						  
	    count = 0					      	  else {						    	  continue ;						  
    return max_count - min_count			      	    max_count = max ( max_count , count ) ;		    	}							  
							      	    min_count = min ( min_count , count ) ;		    	else {							  
							      	    count = 0 ;						    	  maxCount = max ( maxCount , count ) ;			  
							      	  }							    	  minCount = min ( minCount , count ) ;			  
							      	}							    	  count = 0 ;						  
							      	return ( max_count - min_count ) ;			    	}							  
							      }								      }								  
							      								      return maxCount - minCount ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS	      HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS	    HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS	  HOW_TO_PRINT_MAXIMUM_NUMBER_OF_A_USING_GIVEN_FOUR_KEYS
--							      --							    --								  --
def findoptimal ( N ) :					      int findoptimal ( int N ) {				    int findoptimal ( int N ) {					  success : None
    if ( N <= 6 ) :					      	if ( N <= 6 ) return N ;				      if ( ( N <= 6 ) ) return N ;				  
	return N					      	int screen [ N ] ;					      vector < int > screen ( N , 0 ) ;				  
    screen = [ 0 ] * N					      	int b ;							      for ( int n = 1 ;						  
    for n in range ( 1 , 7 ) :				      	int n ;							      n < 7 ;							  
	screen [ n - 1 ] = n				      	for ( n = 1 ;						      n ++ ) screen [ n - 1 ] = n ;				  
    for n in range ( 7 , N + 1 ) :			      	n <= 6 ;						      for ( int n = 7 ;						  
	screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 	n ++ ) screen [ n - 1 ] = n ;				      n <= N ;							  
    return screen [ N - 1 ]				      	for ( n = 7 ;						      n ++ ) screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max  
							      	n <= N ;						      return screen [ N - 1 ] ;					  
							      	n ++ ) {						    }								  
							      	  screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * 								  
							      	}							    								  
							      	return screen [ N - 1 ] ;				    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE COUNT_NUMBER_WAYS_TILE_FLOOR_SIZE_N_X_M_USING_1_X_M_SIZE_TILE
--							      --							    --								  --
def countWays ( n , m ) :				      int countWays ( int n , int m ) {				    int countWays ( int n , int m ) {				  success : None
    count = [ ]						      	int count [ n + 1 ] ;					      vector < int > count ( n + 2 , 0 ) ;			  
    for i in range ( n + 2 ) :				      	count [ 0 ] = 0 ;					      for ( int i = 0 ;						  
	count.append ( 0 )				      	for ( int i = 1 ;					      i < n + 2 ;						  
    count [ 0 ] = 0					      	i <= n ;						      i ++ ) count [ i ] = 0 ;					  
    for i in range ( 1 , n + 1 ) :			      	i ++ ) {						      count [ 0 ] = 0 ;						  
	if ( i > m ) :					      	  if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i -    for ( int i = 1 ;						  
	    count [ i ] = count [ i - 1 ] + count [ i - m ]   	  else if ( i < m ) count [ i ] = 1 ;			      i <= n ;							  
	elif ( i < m ) :				      	  else count [ i ] = 2 ;				      i ++ ) {							  
	    count [ i ] = 1				      	}							    	if ( ( i > m ) ) count [ i ] = count [ i - 1 ] + count [  
	else :						      	return count [ n ] ;					    	else if ( ( i < m ) ) count [ i ] = 1 ;			  
	    count [ i ] = 2				      }								    	else count [ i ] = 2 ;					  
    return count [ n ]					      								      }								  
							      								      return count [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY	      MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY	    MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY	  MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY
--							      --							    --								  --
def minJumps ( arr , l , h ) :				      int minJumps ( int arr [ ] , int n ) {			    double minJumps ( int * arr , int l , int h ) {		  script_not_found : None
    if ( h == l ) :					      	if ( n == 1 ) return 0 ;				      if ( ( h == l ) ) return 0 ;				  
	return 0					      	int res = INT_MAX ;					      if ( ( arr [ l ] == 0 ) ) return std :: numeric_limits < do 
    if ( arr [ l ] == 0 ) :				      	for ( int i = n - 2 ;					      double min = std :: numeric_limits < double > :: infinity ( 
	return float ( 'inf' )				      	i >= 0 ;						      for ( int i = l + 1 ;					  
    min = float ( 'inf' )				      	i -- ) {						      i <= h ;							  
    for i in range ( l + 1 , h + 1 ) :			      	  if ( i + arr [ i ] >= n - 1 ) {			      i ++ ) {							  
	if ( i < l + arr [ l ] + 1 ) :			      	    int sub_res = minJumps ( arr , i + 1 ) ;		    	if ( ( i < l + arr [ l ] + 1 ) ) {			  
	    jumps = minJumps ( arr , i , h )		      	    if ( sub_res != INT_MAX ) res = min ( res , sub_res + 1 	  double jumps = minJumps ( arr , i , h ) ;		  
	    if ( jumps != float ( 'inf' ) and jumps + 1 < min 	  }							    	  if ( ( jumps != std :: numeric_limits < double > :: inf 
		min = jumps + 1				      	}							    	}							  
    return min						      	return res ;						      }								  
							      }								      return min ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS     RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS	    RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS	  RECURSIVE_SOLUTION_COUNT_SUBSTRINGS_FIRST_LAST_CHARACTERS
--							      --							    --								  --
def countSubstrs ( str , i , j , n ) :			      int countSubstrs ( string str , int i , int j , int n ) {	    int countSubstrs ( string str , int i , int j , int n ) {	  script_not_found : None
    if ( n == 1 ) :					      	if ( n == 1 ) return 1 ;				      if ( ( n == 1 ) ) return 1 ;				  
	return 1					      	if ( n <= 0 ) return 0 ;				      if ( ( n <= 0 ) ) return 0 ;				  
    if ( n <= 0 ) :					      	int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countS   int res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + coun 
	return 0					      	if ( str [ i ] == str [ j ] ) res ++ ;			      if ( ( str [ i ] == str [ j ] ) ) res ++ ;		  
    res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countS 	return res ;						      return res ;						  
    if ( str [ i ] == str [ j ] ) :			      }								    }								  
	res += 1					      								    								  
    return res						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2	      FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2		    FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2		  FIND_ELEMENTS_ARRAY_LEAST_TWO_GREATER_ELEMENTS_2
--							      --							    --								  --
def findElements ( arr , n ) :				      void findElements ( int arr [ ] , int n ) {		    int findElements ( int * arr , int n ) {			  script_not_found : None
    first = - sys.maxsize				      	int first = INT_MIN , second = INT_MIN ;		      int first = - INT_MAX ;					  
    second = - sys.maxsize				      	for ( int i = 0 ;					      int second = - INT_MAX ;					  
    for i in range ( 0 , n ) :				      	i < n ;							      for ( int i = 0 ;						  
	if ( arr [ i ] > first ) :			      	i ++ ) {						      i != n ;							  
	    second = first				      	  if ( arr [ i ] > first ) {				      i ++ ) {							  
	    first = arr [ i ]				      	    second = first ;					    	if ( ( arr [ i ] > first ) && ( arr [ i ] < second ) ) {  
	elif ( arr [ i ] > second ) :			      	    first = arr [ i ] ;					    	  second = first ;					  
	    second = arr [ i ]				      	  }							    	  first = arr [ i ] ;					  
    for i in range ( 0 , n ) :				      	  else if ( arr [ i ] > second ) second = arr [ i ] ;	    	}							  
	if ( arr [ i ] < second ) :			      	}							    	else if ( ( arr [ i ] > second ) && ( arr [ i ] < second  
	    print ( arr [ i ] , end = " " )		      	for ( int i = 0 ;					    	  second = arr [ i ] ;					  
							      	i < n ;							    	}							  
							      	i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << " " ;   }								  
							      }								      for ( int i = 0 ;						  
							      								      i != n ;							  
							      								      i ++ ) {							  
							      								    	if ( ( arr [ i ] < second ) ) {				  
							      								    	  cout << arr [ i ] << " " ;				  
							      								    	}							  
							      								      }								  
							      								      return n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_PRIME_FACTOR_GIVEN_NUMBER				      K_TH_PRIME_FACTOR_GIVEN_NUMBER				    K_TH_PRIME_FACTOR_GIVEN_NUMBER				  K_TH_PRIME_FACTOR_GIVEN_NUMBER
--							      --							    --								  --
def kPrimeFactor ( n , k ) :				      int kPrimeFactor ( int n , int k ) {			    int kPrimeFactor ( int n , int k ) {			  success : None
    while ( n % 2 == 0 ) :				      	while ( n % 2 == 0 ) {					      while ( ( n % 2 == 0 ) ) {				  
	k = k - 1					      	  k -- ;						    	k = k - 1 ;						  
	n = n / 2					      	  n = n / 2 ;						    	n = n / 2 ;						  
	if ( k == 0 ) :					      	  if ( k == 0 ) return 2 ;				    	if ( ( k == 0 ) ) return 2 ;				  
	    return 2					      	}							      }								  
    i = 3						      	for ( int i = 3 ;					      int i = 3 ;						  
    while i <= math.sqrt ( n ) :			      	i <= sqrt ( n ) ;					      while ( i <= sqrt ( n ) ) {				  
	while ( n % i == 0 ) :				      	i = i + 2 ) {						    	while ( ( n % i == 0 ) ) {				  
	    if ( k == 1 ) :				      	  while ( n % i == 0 ) {				    	  if ( ( k == 1 ) ) return i ;				  
		return i				      	    if ( k == 1 ) return i ;				    	  k = k - 1 ;						  
	    k = k - 1					      	    k -- ;						    	  n = n / i ;						  
	    n = n / i					      	    n = n / i ;						    	}							  
	i = i + 2					      	  }							    	i = i + 2 ;						  
    if ( n > 2 and k == 1 ) :				      	}							      }								  
	return n					      	if ( n > 2 && k == 1 ) return n ;			      if ( ( n > 2 ) && ( k == 1 ) ) return n ;			  
    return - 1						      	return - 1 ;						      return - 1 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAJORITY_ELEMENT_1					      MAJORITY_ELEMENT_1					    MAJORITY_ELEMENT_1						  MAJORITY_ELEMENT_1
--							      --							    --								  --
def findMajority ( arr , size ) :			      void findMajority ( int arr [ ] , int size ) {		    int findMajority ( int * arr , int size ) {			  script_not_found : None
    m = { }						      	unordered_map < int , int > m ;				      map < int , int > m ;					  
    for i in range ( size ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if arr [ i ] in m :				      	i < size ;						      i < size ;						  
	    m [ arr [ i ] ] += 1			      	i ++ ) m [ arr [ i ] ] ++ ;				      i ++ ) {							  
	else :						      	int count = 0 ;						    	if ( m . count ( arr [ i ] ) ) m [ arr [ i ] ] ++ ;	  
	    m [ arr [ i ] ] = 1				      	for ( auto i : m ) {					    	else m [ arr [ i ] ] = 1 ;				  
    count = 0						      	  if ( i . second > size / 2 ) {			      }								  
    for key in m :					      	    count = 1 ;						      int count = 0 ;						  
	if m [ key ] > size / 2 :			      	    cout << "Majority found :- " << i . first << endl ;	      for ( int i = 0 ;						  
	    count = 1					      	    break ;						      i < m . count ( ) ;					  
	    print ( "Majority found :-" , key )		      	  }							      i ++ ) {							  
	    break					      	}							    	if ( m [ i ] > size / 2 ) {				  
    if ( count == 0 ) :					      	if ( count == 0 ) cout << "No Majority element" << endl ;   	  count = 1 ;						  
	print ( "No Majority element" )			      }								    	  cout << "Majority found :-" << m [ i ] << endl ;	  
							      								    	  break ;						  
							      								    	}							  
							      								      }								  
							      								      if ( ( count == 0 ) ) cout << "No Majority element" << endl 
							      								      return count ;						  
							      								      return size * size ;					  
							      								      return size * size * size * size * size * size * size * siz 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_DUPLICA
--							      --							    --								  --
def noAdjacentDup ( s ) :				      string noAdjacentDup ( string s ) {			    string noAdjacentDup ( string s ) {				  error : PRINT_A_CLOSEST_STRING_THAT_DOES_NOT_CONTA
    n = len ( s )					      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  IN_ADJACENT_DUPLICATES.cpp: In function ‘std::__cx
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  x11::string f_filled(std::__cxx11::string)’: PRINT
	if ( s [ i ] == s [ i - 1 ] ) :			      	i < n ;							      i < n ;							  _A_CLOSEST_STRING_THAT_DOES_NOT_CONTAIN_ADJACENT_D
	    s [ i ] = "a"				      	i ++ ) {						      i ++ ) {							  UPLICATES.cpp:37:17: error: invalid conversion fro
	    while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and 	  if ( s [ i ] == s [ i - 1 ] ) {			    	if ( ( s [ i ] == s [ i - 1 ] ) ) {			  m ‘const char*’ to ‘__gnu_cxx::__alloc_traits<std:
		s [ i ] += 1				      	    s [ i ] = 'a' ;					    	  s [ i ] = "a" ;					  :allocator<char>, char>::value_type’ {aka ‘char’}
	    i += 1					      	    while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i  	  while ( ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [  [-fpermissive]	s [ i ] = "a" ;
    return s						      	    i ++ ;						    	  i ++ ;						       ^~~
							      	  }							    	}							  
							      	}							      }								  
							      	return s ;						      return s ;						  
							      }								      return " " + s + " " + s ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_ODD_FACTORS_NUMBER				      FIND_SUM_ODD_FACTORS_NUMBER				    FIND_SUM_ODD_FACTORS_NUMBER					  FIND_SUM_ODD_FACTORS_NUMBER
--							      --							    --								  --
def sumofoddFactors ( n ) :				      int sumofoddFactors ( int n ) {				    double sumofoddFactors ( int n ) {				  success : None
    res = 1						      	int res = 1 ;						      double res = 1 ;						  
    while n % 2 == 0 :					      	while ( n % 2 == 0 ) n = n / 2 ;			      while ( n % 2 == 0 ) n = n / 2 ;				  
	n = n // 2					      	for ( int i = 3 ;					      for ( int i = 3 ;						  
    for i in range ( 3 , int ( math.sqrt ( n ) + 1 ) ) :      	i <= sqrt ( n ) ;					      i < ( int ) ( sqrt ( n ) + 1 ) ;				  
	count = 0					      	i ++ ) {						      i ++ ) {							  
	curr_sum = 1					      	  int count = 0 , curr_sum = 1 ;			    	int count = 0 ;						  
	curr_term = 1					      	  int curr_term = 1 ;					    	double currSum = 1 ;					  
	while n % i == 0 :				      	  while ( n % i == 0 ) {				    	double currTerm = 1 ;					  
	    count += 1					      	    count ++ ;						    	while ( n % i == 0 ) {					  
	    n = n // i					      	    n = n / i ;						    	  count ++ ;						  
	    curr_term *= i				      	    curr_term *= i ;					    	  n = n / i ;						  
	    curr_sum += curr_term			      	    curr_sum += curr_term ;				    	  currTerm *= i ;					  
	res *= curr_sum					      	  }							    	  currSum += currTerm ;					  
    if n >= 2 :						      	  res *= curr_sum ;					    	}							  
	res *= ( 1 + n )				      	}							    	res *= currSum ;					  
    return res						      	if ( n >= 2 ) res *= ( 1 + n ) ;			      }								  
							      	return res ;						      if ( n >= 2 ) res *= ( 1 + n ) ;				  
							      }								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMAINDER_7_LARGE_NUMBERS				      REMAINDER_7_LARGE_NUMBERS					    REMAINDER_7_LARGE_NUMBERS					  REMAINDER_7_LARGE_NUMBERS
--							      --							    --								  --
def remainderWith7 ( num ) :				      int remainderWith7 ( string num ) {			    int remainderWith7 ( string num ) {				  success : None
    series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ]		      	int series [ ] = {					      int series [ ] = {					  
    series_index = 0					      	  1 , 3 , 2 , - 1 , - 3 , - 2 }				    	1 , 3 , 2 , - 1 , - 3 , - 2 }				  
    result = 0						      	  ;							    	;							  
    for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) :      	  int series_index = 0 ;				    	int seriesIndex = 0 ;					  
	digit = ord ( num [ i ] ) - 48			      	  int result = 0 ;					    	int result = 0 ;					  
	result += digit * series [ series_index ]	      	  for ( int i = num . size ( ) - 1 ;			    	for ( int i = ( num . length ( ) - 1 ) ;		  
	series_index = ( series_index + 1 ) % 6		      	  i >= 0 ;						    	i >= 0 ;						  
	result %= 7					      	  i -- ) {						    	i -- ) {						  
    if ( result < 0 ) :					      	    int digit = num [ i ] - '0' ;			    	  int digit = ( int ) ( num [ i ] - 48 ) ;		  
	result = ( result + 7 ) % 7			      	    result += digit * series [ series_index ] ;		    	  result += digit * series [ seriesIndex ] ;		  
    return result					      	    series_index = ( series_index + 1 ) % 6 ;		    	  seriesIndex = ( seriesIndex + 1 ) % 6 ;		  
							      	    result %= 7 ;					    	  result %= 7 ;						  
							      	  }							    	}							  
							      	  if ( result < 0 ) result = ( result + 7 ) % 7 ;	    	if ( ( result < 0 ) ) result = ( result + 7 ) % 7 ;	  
							      	  return result ;					    	return result ;						  
							      	}							      }								  
-							      	-							      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1			      FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1			    FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1				  FIND_NUMBER_OF_TRIANGLES_POSSIBLE_1
--							      --							    --								  --
def CountTriangles ( A ) :				      void CountTriangles ( vector < int > A ) {		    int CountTriangles ( string A ) {				  script_not_found : None
    n = len ( A )					      	int n = A . size ( ) ;					      int n = A . length ( ) ;					  
    A.sort ( )						      	sort ( A . begin ( ) , A . end ( ) ) ;			      sort ( A . begin ( ) , A . end ( ) ) ;			  
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( n - 1 , 0 , - 1 ) :		      	for ( int i = n - 1 ;					      for ( int i = n - 1 ;					  
	l = 0						      	i >= 1 ;						      i > 0 ;							  
	r = i - 1					      	i -- ) {						      i -- ) {							  
	while ( l < r ) :				      	  int l = 0 , r = i - 1 ;				    	int l = 0 ;						  
	    if ( A [ l ] + A [ r ] > A [ i ] ) :	      	  while ( l < r ) {					    	int r = i - 1 ;						  
		count += r - l				      	    if ( A [ l ] + A [ r ] > A [ i ] ) {		    	while ( ( l < r ) ) {					  
		r -= 1					      	      count += r - l ;					    	  if ( ( A [ l ] + A [ r ] > A [ i ] ) ) {		  
	    else :					      	      r -- ;						    	    count += r - l ;					  
		l += 1					      	    }							    	    r -- ;						  
    print ( "No of possible solutions: " , count )	      	    else l ++ ;						    	  }							  
							      	  }							    	  else {						  
							      	}							    	    l ++ ;						  
							      	cout << "No of possible solutions: " << count ;		    	  }							  
							      }								    	}							  
							      								      }								  
							      								      cout << "No of possible solutions: " << count << endl ;	  
							      								      return count ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS      COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS	    COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS	  COUNT_WAYS_DIVIDE_CIRCLE_USING_N_NON_INTERSECTING_CHORDS
--							      --							    --								  --
def chordCnt ( A ) :					      int chordCnt ( int A ) {					    int chordCnt ( int A ) {					  failure : #Results: 0, 10
    n = 2 * A						      	int n = 2 * A ;						      int n = 2 * A ;						  
    dpArray = [ 0 ] * ( n + 1 )				      	int dpArray [ n + 1 ] = {				      int dpArray [ n + 1 ] ;					  
    dpArray [ 0 ] = 1					      	  0 }							      dpArray [ 0 ] = 1 ;					  
    dpArray [ 2 ] = 1					      	  ;							      dpArray [ 2 ] = 1 ;					  
    for i in range ( 4 , n + 1 , 2 ) :			      	  dpArray [ 0 ] = 1 ;					      for ( int i = 4 ;						  
	for j in range ( 0 , i - 1 , 2 ) :		      	  dpArray [ 2 ] = 1 ;					      i <= n + 1 ;						  
	    dpArray [ i ] += ( dpArray [ j ] * dpArray [ i -  	  for ( int i = 4 ;					      i += 2 ) {						  
    return int ( dpArray [ n ] )			      	  i <= n ;						    	for ( int j = 0 ;					  
							      	  i += 2 ) {						    	j < i - 1 ;						  
							      	    for ( int j = 0 ;					    	j += 2 ) dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 
							      	    j < i - 1 ;						      }								  
							      	    j += 2 ) {						      return ( int ) dpArray [ n ] ;				  
							      	      dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 -  }								  
							      	    }							    								  
							      	  }							    								  
							      	  return dpArray [ n ] ;				    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY	      INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY	    INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY	  INTEGER_POSITIVE_VALUE_POSITIVE_NEGATIVE_VALUE_ARRAY
--							      --							    --								  --
def findInteger ( arr , n ) :				      int findInteger ( int arr [ ] , int n ) {			    int findInteger ( int * arr , int n ) {			  failure : #Results: 3, 10
    hash = dict ( )					      	unordered_map < int , int > hash ;			      map < int , int > hash ;					  
    maximum = 0						      	int maximum = 0 ;					      int maximum = 0 ;						  
    for i in arr :					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( i < 0 ) :					      	i < n ;							      i < n ;							  
	    if abs ( i ) not in hash.keys ( ) :		      	i ++ ) {						      i ++ ) {							  
		hash [ abs ( i ) ] = - 1		      	  if ( arr [ i ] < 0 ) hash [ abs ( arr [ i ] ) ] -= 1 ;    	if ( ( i < 0 ) ) {					  
	    else :					      	  else hash [ arr [ i ] ] += 1 ;			    	  if ( abs ( i ) != hash . count ( abs ( i ) ) ) hash [ a 
		hash [ abs ( i ) ] -= 1			      	}							    	  else hash [ abs ( i ) ] -- ;				  
	else :						      	for ( int i = 0 ;					    	}							  
	    hash [ i ] = hash.get ( i , 0 ) + 1		      	i < n ;							    	else hash [ i ] = hash . count ( i ) + 1 ;		  
    for i in arr :					      	i ++ ) if ( hash [ arr [ i ] ] != 0 ) return arr [ i ] ;      }								  
	if i in hash.keys ( ) and hash [ i ] > 0 :	      	return - 1 ;						      for ( int i = 0 ;						  
	    return i					      }								      i < n ;							  
    return - 1						      								      i ++ ) {							  
							      								    	if ( hash . count ( i ) && hash [ i ] > 0 ) return i ;	  
							      								      }								  
							      								      return - 1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES	      COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES		    COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES		  COUNT_SUBSTRINGS_BINARY_STRING_CONTAINING_K_ONES
--							      --							    --								  --
def countOfSubstringWithKOnes ( s , K ) :		      int countOfSubstringWithKOnes ( string s , int K ) {	    int countOfSubstringWithKOnes ( string s , int K ) {	  script_not_found : None
    N = len ( s )					      	int N = s . length ( ) ;				      int N = s . length ( ) ;					  
    res = 0						      	int res = 0 ;						      int res = 0 ;						  
    countOfOne = 0					      	int countOfOne = 0 ;					      int countOfOne = 0 ;					  
    freq = [ 0 for i in range ( N + 1 ) ]		      	int freq [ N + 1 ] = {					      vector < int > freq ( N + 1 , 0 ) ;			  
    freq [ 0 ] = 1					      	  0 }							      freq [ 0 ] = 1 ;						  
    for i in range ( 0 , N , 1 ) :			      	  ;							      for ( int i = 0 ;						  
	countOfOne += ord ( s [ i ] ) - ord ( '0' )	      	  freq [ 0 ] = 1 ;					      i < N ;							  
	if ( countOfOne >= K ) :			      	  for ( int i = 0 ;					      i += 1 ) {						  
	    res += freq [ countOfOne - K ]		      	  i < N ;						    	countOfOne += s [ i ] - '0' ;				  
	freq [ countOfOne ] += 1			      	  i ++ ) {						    	if ( ( countOfOne >= K ) && ( countOfOne <= K ) ) res +=  
    return res						      	    countOfOne += ( s [ i ] - '0' ) ;			    	freq [ countOfOne ] ++ ;				  
							      	    if ( countOfOne >= K ) {				      }								  
							      	      res += freq [ countOfOne - K ] ;			      return res ;						  
							      	    }							    }								  
							      	    freq [ countOfOne ] ++ ;				    								  
							      	  }							    								  
							      	  return res ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1    DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1    DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1	  DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQUENCE_1
--							      --							    --								  --
def lis ( arr ) :					      int lis ( int arr [ ] , int n ) {				    int lis ( int * arr ) {					  error : DYNAMIC_PROGRAMMING_SET_3_LONGEST_INCREASI
    n = len ( arr )					      	int lis [ n ] ;						      int n = sizeof ( arr ) / sizeof ( int ) ;			  NG_SUBSEQUENCE_1.cpp: In function ‘int main()’: DY
    lis = [ 1 ] * n					      	lis [ 0 ] = 1 ;						      int lis [ n ] ;						  NAMIC_PROGRAMMING_SET_3_LONGEST_INCREASING_SUBSEQU
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  ENCE_1.cpp:57:49: error: too many arguments to fun
	for j in range ( 0 , i ) :			      	i < n ;							      i < n ;							  ction ‘int f_filled(int*)’	      if(f_filled(&p
	    if arr [ i ] > arr [ j ] and lis [ i ] < lis [ j  	i ++ ) {						      i ++ ) {							  aram0[i].front(),param1[i]) == f_gold(&param0[i].f
		lis [ i ] = lis [ j ] + 1		      	  lis [ i ] = 1 ;					    	for ( int j = 0 ;					  ront(),param1[i]))
    maximum = 0						      	  for ( int j = 0 ;					    	j < i ;							  		    ^ DYNAMIC_PROGRAMMING_SET_3_LONG
    for i in range ( n ) :				      	  j < i ;						    	j ++ ) {						  EST_INCREASING_SUBSEQUENCE_1.cpp:31:5: note: decla
	maximum = max ( maximum , lis [ i ] )		      	  j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j  	  if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 red here  int f_filled ( int * arr ) {      ^~~~~~
    return maximum					      	}							    	}							  ~~
							      	return * max_element ( lis , lis + n ) ;		      }								  
							      }								      int maximum = 0 ;						  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) maximum = max ( maximum , lis [ i ] ) ;		  
							      								      return maximum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT		      MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT		    MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT		  MAXIMUM_SUM_2_X_N_GRID_NO_TWO_ELEMENTS_ADJACENT
--							      --							    --								  --
def maxSum ( grid , n ) :				      int maxSum ( int grid [ 2 ] [ MAX ] , int n ) {		    int maxSum ( int * * grid , int n ) {			  script_not_found : None
    incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] )	      	int incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ;      int incl = max < int > ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0  
    excl = 0						      	int excl = 0 , excl_new ;				      int excl = 0 ;						  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	excl_new = max ( excl , incl )			      	i < n ;							      i < n ;							  
	incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i 	i ++ ) {						      i ++ ) {							  
	excl = excl_new					      	  excl_new = max ( excl , incl ) ;			    	int exclNew = max < int > ( excl , incl ) ;		  
    return max ( excl , incl )				      	  incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) 	incl = excl + max < int > ( grid [ 0 ] [ i ] , grid [ 1 ] 
							      	  excl = excl_new ;					    	excl = exclNew ;					  
							      	}							      }								  
							      	return max ( excl , incl ) ;				      return max < int > ( excl , incl ) ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH		      REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH		    REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH		  REARRANGE_POSITIVE_AND_NEGATIVE_NUMBERS_PUBLISH
--							      --							    --								  --
def rearrange ( arr , n ) :				      void GFG :: rearrange ( int arr [ ] , int n ) {		    void rearrange ( int * arr , int n ) {			  script_not_found : None
    i = - 1						      	int i = - 1 ;						      int i = - 1 ;						  
    for j in range ( n ) :				      	for ( int j = 0 ;					      for ( int j = 0 ;						  
	if ( arr [ j ] < 0 ) :				      	j < n ;							      j < n ;							  
	    i += 1					      	j ++ ) {						      j ++ ) {							  
	    arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ]     	  if ( arr [ j ] < 0 ) {				    	if ( ( arr [ j ] < 0 ) ) {				  
    pos , neg = i + 1 , 0				      	    i ++ ;						    	  i ++ ;						  
    while ( pos < n and neg < pos and arr [ neg ] < 0 ) :     	    swap ( & arr [ i ] , & arr [ j ] ) ;		    	  arr [ i ] = arr [ j ] ;				  
	arr [ neg ] , arr [ pos ] = arr [ pos ] , arr [ neg ] 	  }							    	  arr [ j ] = arr [ i ] ;				  
	pos += 1					      	}							    	}							  
	neg += 2					      	int pos = i + 1 , neg = 0 ;				      }								  
							      	while ( pos < n && neg < pos && arr [ neg ] < 0 ) {	      int pos = i + 1 , neg = 0 ;				  
							      	  swap ( & arr [ neg ] , & arr [ pos ] ) ;		      while ( ( pos < n ) && ( neg < pos ) && ( arr [ neg ] < 0 ) 
							      	  pos ++ ;						    	arr [ neg ] = arr [ pos ] ;				  
							      	  neg += 2 ;						    	pos ++ ;						  
							      	}							    	neg += 2 ;						  
							      }								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_SPECIFIC_PAIR_IN_MATRIX				      FIND_A_SPECIFIC_PAIR_IN_MATRIX				    FIND_A_SPECIFIC_PAIR_IN_MATRIX				  FIND_A_SPECIFIC_PAIR_IN_MATRIX
--							      --							    --								  --
def findMaxValue ( mat ) :				      int findMaxValue ( int mat [ ] [ N ] ) {			    int findMaxValue ( int * * mat ) {				  script_not_found : None
    maxValue = 0					      	int maxValue = INT_MIN ;				      int maxValue = 0 ;					  
    for a in range ( N - 1 ) :				      	for ( int a = 0 ;					      for ( int a = 0 ;						  
	for b in range ( N - 1 ) :			      	a < N - 1 ;						      a < N - 1 ;						  
	    for d in range ( a + 1 , N ) :		      	a ++ ) for ( int b = 0 ;				      a ++ ) {							  
		for e in range ( b + 1 , N ) :		      	b < N - 1 ;						    	for ( int b = 0 ;					  
		    if maxValue < int ( mat [ d ] [ e ] - mat 	b ++ ) for ( int d = a + 1 ;				    	b < N - 1 ;						  
			maxValue = int ( mat [ d ] [ e ] - ma 	d < N ;							    	b ++ ) {						  
    return maxValue ;					      	d ++ ) for ( int e = b + 1 ;				    	  for ( int d = a + 1 ;					  
							      	e < N ;							    	  d < N ;						  
							      	e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ]  	  d ++ ) {						  
							      	return maxValue ;					    	    for ( int e = b + 1 ;				  
							      }								    	    e < N ;						  
							      								    	    e ++ ) {						  
							      								    	      if ( maxValue < ( int ) ( mat [ d ] [ e ] - mat [ a 
							      								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return maxValue ;						  
							      								      return N * N ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PATH_SUM_TRIANGLE				      MAXIMUM_PATH_SUM_TRIANGLE					    MAXIMUM_PATH_SUM_TRIANGLE					  MAXIMUM_PATH_SUM_TRIANGLE
--							      --							    --								  --
def maxPathSum ( tri , m , n ) :			      int maxPathSum ( int tri [ ] [ N ] , int m , int n ) {	    int maxPathSum ( int * * tri , int m , int n ) {		  script_not_found : None
    for i in range ( m - 1 , - 1 , - 1 ) :		      	for ( int i = m - 1 ;					      for ( int i = m - 1 ;					  
	for j in range ( i + 1 ) :			      	i >= 0 ;						      i >= 0 ;							  
	    if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1  	i -- ) {						      i -- ) {							  
		tri [ i ] [ j ] += tri [ i + 1 ] [ j ]	      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    else :					      	  j <= i ;						    	j < i + 1 ;						  
		tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ]    	  j ++ ) {						    	j ++ ) {						  
    return tri [ 0 ] [ 0 ]				      	    if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tr 	  if ( ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] )  
							      	    else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ;	    	  else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ;	  
							      	  }							    	}							  
							      	}							      }								  
							      	return tri [ 0 ] [ 0 ] ;				      return tri [ 0 ] [ 0 ] ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING	      SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING	    SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING		  SORT_STRING_ACCORDING_ORDER_DEFINED_ANOTHER_STRING
--							      --							    --								  --
def sortByPattern ( str , pat ) :			      void sortByPattern ( string & str , string pat ) {	    string sortByPattern ( string str , string pat ) {		  script_not_found : None
    global MAX_CHAR					      	int count [ MAX_CHAR ] = {				      static int MAX_CHAR = 256 ;				  
    count = [ 0 ] * MAX_CHAR				      	  0 }							      vector < int > count ( MAX_CHAR , 0 ) ;			  
    for i in range ( 0 , len ( str ) ) :		      	  ;							      for ( int i = 0 ;						  
	count [ ord ( str [ i ] ) - 97 ] += 1		      	  for ( int i = 0 ;					      i < str . length ( ) ;					  
    index = 0						      	  i < str . length ( ) ;				      i ++ ) count [ str [ i ] - 97 ] ++ ;			  
    str = ""						      	  i ++ ) count [ str [ i ] - 'a' ] ++ ;			      int index = 0 ;						  
    for i in range ( 0 , len ( pat ) ) :		      	  int index = 0 ;					      str = "" ;						  
	j = 0						      	  for ( int i = 0 ;					      for ( int i = 0 ;						  
	while ( j < count [ ord ( pat [ i ] ) - ord ( 'a' ) ] 	  i < pat . length ( ) ;				      i < pat . length ( ) ;					  
	    str += pat [ i ]				      	  i ++ ) for ( int j = 0 ;				      i ++ ) {							  
	    j = j + 1					      	  j < count [ pat [ i ] - 'a' ] ;			    	int j = 0 ;						  
	    index += 1					      	  j ++ ) str [ index ++ ] = pat [ i ] ;			    	while ( ( j < count [ pat [ i ] - 'a' ] ) && ( j < count  
    return str						      	}							    	  str += pat [ i ] ;					  
							      								    	  j = j + 1 ;						  
							      								    	  index ++ ;						  
							      								    	}							  
							      								      }								  
							      								      return str ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY	      FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY	    FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY	  FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY
--							      --							    --								  --
def findPair ( arr , n ) :				      void findPair ( int arr [ ] , int n ) {			    int findPair ( int * arr , int n ) {			  script_not_found : None
    found = False					      	bool found = false ;					      bool found = false ;					  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i <= n ;							  
	    for k in range ( 0 , n ) :			      	i ++ ) {						      i ++ ) {							  
		if ( arr [ i ] + arr [ j ] == arr [ k ] ) :   	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
		    print ( arr [ i ] , arr [ j ] )	      	  j < n ;						    	j < n ;							  
		    found = True			      	  j ++ ) {						    	j ++ ) {						  
    if ( found == False ) :				      	    for ( int k = 0 ;					    	  for ( int k = 0 ;					  
	print ( "Not exist" )				      	    k < n ;						    	  k < n ;						  
							      	    k ++ ) {						    	  k ++ ) {						  
							      	      if ( arr [ i ] + arr [ j ] == arr [ k ] ) {	    	    if ( ( arr [ i ] + arr [ j ] == arr [ k ] ) ) {	  
							      		cout << arr [ i ] << " " << arr [ j ] << endl ;	    	      cout << arr [ i ] << " " << arr [ j ] << endl ;	  
							      		found = true ;					    	      found = true ;					  
							      	      }							    	    }							  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	if ( found == false ) cout << "Not exist" << endl ;	      if ( ( found == false ) == false ) cout << "Not exist" << e 
							      }								      return n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1		      SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1		    SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1			  SUM_ELEMENTS_K1TH_K2TH_SMALLEST_ELEMENTS_1
--							      --							    --								  --
def minheapify ( a , index ) :				      void minheapify ( int a [ ] , int index ) {		    void minHeapify ( int a [ ] , int index ) {			  script_not_found : None
    small = index					      	int small = index ;					      int small = index ;					  
    l = 2 * index + 1					      	int l = 2 * index + 1 ;					      int l = 2 * index + 1 ;					  
    r = 2 * index + 2					      	int r = 2 * index + 2 ;					      int r = 2 * index + 2 ;					  
    if ( l < n and a [ l ] < a [ small ] ) :		      	if ( l < n && a [ l ] < a [ small ] ) small = l ;	      if ( ( l < n ) && ( a [ l ] < a [ small ] ) ) small = l ;	  
	small = l					      	if ( r < n && a [ r ] < a [ small ] ) small = r ;	      if ( ( r < n ) && ( a [ r ] < a [ small ] ) ) small = r ;	  
    if ( r < n and a [ r ] < a [ small ] ) :		      	if ( small != index ) {					      if ( ( small != index ) ) {				  
	small = r					      	  swap ( a [ small ] , a [ index ] ) ;			    	( a [ small ] ) = a [ index ] ;				  
    if ( small != index ) :				      	  minheapify ( a , small ) ;				    	minHeapify ( a , small ) ;				  
	( a [ small ] , a [ index ] ) = ( a [ index ] , a [ s 	}							      }								  
	minheapify ( a , small )			      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N		      PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N		    PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N		  PRINT_POSSIBLE_SUMS_CONSECUTIVE_NUMBERS_SUM_N
--							      --							    --								  --
def findConsecutive ( N ) :				      void findConsecutive ( int N ) {				    int findConsecutive ( int N ) {				  script_not_found : None
    start = 1						      	int start = 1 , end = ( N + 1 ) / 2 ;			      int start = 1 ;						  
    end = ( N + 1 ) // 2				      	while ( start < end ) {					      int end = ( N + 1 ) / 2 ;					  
    while ( start < end ) :				      	  int sum = 0 ;						      while ( ( start < end ) ) {				  
	Sum = 0						      	  for ( int i = start ;					    	int Sum = 0 ;						  
	for i in range ( start , end + 1 ) :		      	  i <= end ;						    	for ( int i = start ;					  
	    Sum = Sum + i				      	  i ++ ) {						    	i <= end ;						  
	    if ( Sum == N ) :				      	    sum = sum + i ;					    	i ++ ) {						  
		for j in range ( start , i + 1 ) :	      	    if ( sum == N ) {					    	  Sum = Sum + i ;					  
		    print ( j , end = " " )		      	      for ( int j = start ;				    	  if ( ( Sum == N ) ) {					  
		print ( )				      	      j <= i ;						    	    for ( int j = start ;				  
		break					      	      j ++ ) printf ( "%d " , j ) ;			    	    j <= i ;						  
	    if ( Sum > N ) :				      	      printf ( "\n" ) ;					    	    j ++ ) cout << j << " " ;				  
		break					      	      break ;						    	    cout << endl ;					  
	Sum = 0						      	    }							    	    break ;						  
	start += 1					      	    if ( sum > N ) break ;				    	  }							  
							      	  }							    	  if ( ( Sum > N ) ) break ;				  
							      	  sum = 0 ;						    	}							  
							      	  start ++ ;						    	Sum = 0 ;						  
							      	}							    	start ++ ;						  
							      }								      }								  
							      								      return start ;						  
-							      -								      return N * N * N * N * N * N * N * N * N * N * N * N * N *  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL		      CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL		    CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL			  CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL
--							      --							    --								  --
def substringConversions ( s , k , b ) :		      int substringConversions ( string str , int k , int b ) {	    int substringConversions ( string s , int k , double b ) {	  script_not_found : None
    l = len ( s )					      	for ( int i = 0 ;					      int l = s . length ( ) ;					  
    for i in range ( l ) :				      	i + k <= str . size ( ) ;				      for ( int i = 0 ;						  
	if ( ( i + k ) < l + 1 ) :			      	i ++ ) {						      i < l ;							  
	    sub = s [ i : i + k ]			      	  string sub = str . substr ( i , k ) ;			      i ++ ) {							  
	    sum , counter = 0 , 0			      	  int sum = 0 , counter = 0 ;				    	if ( ( ( i + k ) < l + 1 ) ) {				  
	    for i in range ( len ( sub ) - 1 , - 1 , - 1 ) :  	  for ( int i = sub . size ( ) - 1 ;			    	  string sub = s . substr ( i , k - i ) ;		  
		sum = sum + ( ( ord ( sub [ i ] ) - ord ( '0' 	  i >= 0 ;						    	  int sum = 0 , counter = 0 ;				  
		counter += 1				      	  i -- ) {						    	  for ( int i = sub . length ( ) - 1 ;			  
	    print ( sum , end = " " )			      	    sum = sum + ( ( sub . at ( i ) - '0' ) * pow ( b , coun 	  i >= 0 ;						  
							      	    counter ++ ;					    	  i -- ) {						  
							      	  }							    	    sum = sum + ( ( sub [ i ] - '0' ) * pow ( b , counter 
							      	  cout << sum << " " ;					    	    counter ++ ;					  
							      	}							    	  }							  
							      }								    	  cout << sum << " " ;					  
							      								    	}							  
							      								      }								  
							      								      return l ;						  
							      								      return l * l * l * l * l * l * l * l * l * l * l * l * l *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS	      NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS	    NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS	  NUMBER_OF_TRIANGLES_IN_DIRECTED_AND_UNDIRECTED_GRAPHS
--							      --							    --								  --
def countTriangle ( g , isDirected ) :			      int countTriangle ( int graph [ V ] [ V ] , bool isDirected ) double countTriangle ( vector < vector < int >> g , bool isDi script_not_found : None
    nodes = len ( g )					      	int count_Triangle = 0 ;				      int nodes = g . size ( ) ;				  
    count_Triangle = 0					      	for ( int i = 0 ;					      int countTriangle = 0 ;					  
    for i in range ( nodes ) :				      	i < V ;							      for ( int i = 0 ;						  
	for j in range ( nodes ) :			      	i ++ ) {						      i < nodes ;						  
	    for k in range ( nodes ) :			      	  for ( int j = 0 ;					      i ++ ) {							  
		if ( i != j and i != k and j != k and g [ i ] 	  j < V ;						    	for ( int j = 0 ;					  
		    count_Triangle += 1			      	  j ++ ) {						    	j < nodes ;						  
    return count_Triangle / 3 if isDirected else count_Triang 	    for ( int k = 0 ;					    	j ++ ) {						  
							      	    k < V ;						    	  for ( int k = 0 ;					  
							      	    k ++ ) {						    	  k < nodes ;						  
							      	      if ( graph [ i ] [ j ] && graph [ j ] [ k ] && graph  	  k ++ ) {						  
							      	    }							    	    if ( ( i != j && i != k && j != k && g [ i ] [ j ] && 
							      	  }							    	  }							  
							      	}							    	}							  
							      	isDirected ? count_Triangle /= 3 : count_Triangle /= 6 ;      }								  
							      	return count_Triangle ;					      return isDirected ? countTriangle / 3 : countTriangle / 6 ; 
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF WRITE_AN_EFFICIENT_METHOD_TO_CHECK_IF_A_NUMBER_IS_MULTIPLE_OF
--							      --							    --								  --
def isMultipleOf3 ( n ) :				      int isMultipleOf3 ( int n ) {				    bool isMultipleOf3 ( int n ) {				  success : None
    odd_count = 0					      	int odd_count = 0 ;					      int odd_count = 0 ;					  
    even_count = 0					      	int even_count = 0 ;					      int even_count = 0 ;					  
    if ( n < 0 ) :					      	if ( n < 0 ) n = - n ;					      if ( ( n < 0 ) ) n = - n ;				  
	n = - n						      	if ( n == 0 ) return 1 ;				      if ( ( n == 0 ) ) return 1 ;				  
    if ( n == 0 ) :					      	if ( n == 1 ) return 0 ;				      if ( ( n == 1 ) ) return 0 ;				  
	return 1					      	while ( n ) {						      while ( ( n ) ) {						  
    if ( n == 1 ) :					      	  if ( n & 1 ) odd_count ++ ;				    	if ( ( n & 1 ) != 0 ) odd_count ++ ;			  
	return 0					      	  if ( n & 2 ) even_count ++ ;				    	if ( ( n & 2 ) != 0 ) even_count ++ ;			  
    while ( n ) :					      	  n = n >> 2 ;						    	n = n >> 2 ;						  
	if ( n & 1 ) :					      	}							      }								  
	    odd_count += 1				      	return isMultipleOf3 ( abs ( odd_count - even_count ) ) ;     return isMultipleOf3 ( abs ( odd_count - even_count ) ) ;	  
	if ( n & 2 ) :					      }								    }								  
	    even_count += 1				      								    								  
	n = n >> 2					      								    								  
    return isMultipleOf3 ( abs ( odd_count - even_count ) )   								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME		      COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME			    COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME			  COUNT_NUMBER_WAYS_REACH_GIVEN_SCORE_GAME
--							      --							    --								  --
def count ( n ) :					      int count ( int n ) {					    int count ( int n ) {					  success : None
    table = [ 0 for i in range ( n + 1 ) ]		      	int table [ n + 1 ] , i ;				      int table [ n + 1 ] ;					  
    table [ 0 ] = 1					      	for ( int j = 0 ;					      for ( int i = 0 ;						  
    for i in range ( 3 , n + 1 ) :			      	j < n + 1 ;						      i < n + 1 ;						  
	table [ i ] += table [ i - 3 ]			      	j ++ ) table [ j ] = 0 ;				      i ++ ) table [ i ] = 0 ;					  
    for i in range ( 5 , n + 1 ) :			      	table [ 0 ] = 1 ;					      table [ 0 ] = 1 ;						  
	table [ i ] += table [ i - 5 ]			      	for ( i = 3 ;						      for ( int i = 3 ;						  
    for i in range ( 10 , n + 1 ) :			      	i <= n ;						      i <= n ;							  
	table [ i ] += table [ i - 10 ]			      	i ++ ) table [ i ] += table [ i - 3 ] ;			      i ++ ) table [ i ] += table [ i - 3 ] ;			  
    return table [ n ]					      	for ( i = 5 ;						      for ( int i = 5 ;						  
							      	i <= n ;						      i <= n ;							  
							      	i ++ ) table [ i ] += table [ i - 5 ] ;			      i ++ ) table [ i ] += table [ i - 5 ] ;			  
							      	for ( i = 10 ;						      for ( int i = 10 ;					  
							      	i <= n ;						      i <= n ;							  
							      	i ++ ) table [ i ] += table [ i - 10 ] ;		      i ++ ) table [ i ] += table [ i - 10 ] ;			  
							      	return table [ n ] ;					      return table [ n ] ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE	      FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE	    FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE	  FIND_MINIMUM_NUMBER_DIVIDED_MAKE_NUMBER_PERFECT_SQUARE
--							      --							    --								  --
def findMinNumber ( n ) :				      int findMinNumber ( int n ) {				    int findMinNumber ( int n ) {				  success : None
    count = 0						      	int count = 0 , ans = 1 ;				      int count = 0 ;						  
    ans = 1						      	while ( n % 2 == 0 ) {					      int ans = 1 ;						  
    while n % 2 == 0 :					      	  count ++ ;						      while ( n % 2 == 0 ) {					  
	count += 1					      	  n /= 2 ;						    	count ++ ;						  
	n //= 2						      	}							    	n /= 2 ;						  
    if count % 2 is not 0 :				      	if ( count % 2 ) ans *= 2 ;				      }								  
	ans *= 2					      	for ( int i = 3 ;					      if ( count % 2 != 0 ) ans *= 2 ;				  
    for i in range ( 3 , ( int ) ( math.sqrt ( n ) ) + 1 , 2  	i <= sqrt ( n ) ;					      for ( int i = 3 ;						  
	count = 0					      	i += 2 ) {						      i < ( int ) ( sqrt ( n ) ) + 1 ;				  
	while n % i == 0 :				      	  count = 0 ;						      i += 2 ) {						  
	    count += 1					      	  while ( n % i == 0 ) {				    	count = 0 ;						  
	    n //= i					      	    count ++ ;						    	while ( n % i == 0 ) {					  
	if count % 2 is not 0 :				      	    n /= i ;						    	  count ++ ;						  
	    ans *= i					      	  }							    	  n /= i ;						  
    if n > 2 :						      	  if ( count % 2 ) ans *= i ;				    	}							  
	ans *= n					      	}							    	if ( count % 2 != 0 ) ans *= i ;			  
    return ans						      	if ( n > 2 ) ans *= n ;					      }								  
							      	return ans ;						      if ( n > 2 ) ans *= n ;					  
							      }								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE			      CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE			    CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE			  CHECK_IF_ARRAY_ELEMENTS_ARE_CONSECUTIVE
--							      --							    --								  --
def areConsecutive ( arr , n ) :			      bool areConsecutive ( int arr [ ] , int n ) {		    bool areConsecutive ( int * arr , int n ) {			  script_not_found : None
    if ( n < 1 ) :					      	if ( n < 1 ) return false ;				      if ( ( n < 1 ) ) return false ;				  
	return False					      	int min = getMin ( arr , n ) ;				      int Min = min < int > ( arr ) ;				  
    Min = min ( arr )					      	int max = getMax ( arr , n ) ;				      int Max = max < int > ( arr ) ;				  
    Max = max ( arr )					      	if ( max - min + 1 == n ) {				      if ( ( Max - Min + 1 == n ) ) {				  
    if ( Max - Min + 1 == n ) :				      	  bool * visited = ( bool * ) calloc ( n , sizeof ( bool )  	vector < bool > visited ( n , false ) ;			  
	visited = [ False for i in range ( n ) ]	      	  int i ;						    	for ( int i = 0 ;					  
	for i in range ( n ) :				      	  for ( i = 0 ;						    	i < n ;							  
	    if ( visited [ arr [ i ] - Min ] != False ) :     	  i < n ;						    	i ++ ) {						  
		return False				      	  i ++ ) {						    	  if ( ( visited [ arr [ i ] - Min ] != false ) ) return  
	    visited [ arr [ i ] - Min ] = True		      	    if ( visited [ arr [ i ] - min ] != false ) return fals 	  visited [ arr [ i ] - Min ] = true ;			  
	return True					      	    visited [ arr [ i ] - min ] = true ;		    	}							  
    return False					      	  }							    	return true ;						  
							      	  return true ;						      }								  
							      	}							      return false ;						  
							      	return false ;						      return arr * arr * arr * arr * arr * arr * arr * arr * arr  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HARDY_RAMANUJAN_THEOREM					      HARDY_RAMANUJAN_THEOREM					    HARDY_RAMANUJAN_THEOREM					  HARDY_RAMANUJAN_THEOREM
--							      --							    --								  --
def exactPrimeFactorCount ( n ) :			      int exactPrimeFactorCount ( int n ) {			    int exactPrimeFactorCount ( int n ) {			  success : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    if ( n % 2 == 0 ) :					      	if ( n % 2 == 0 ) {					      if ( ( n % 2 == 0 ) ) {					  
	count = count + 1				      	  count ++ ;						    	count = count + 1 ;					  
	while ( n % 2 == 0 ) :				      	  while ( n % 2 == 0 ) n = n / 2 ;			    	while ( ( n % 2 == 0 ) ) n = ( int ) ( n / 2 ) ;	  
	    n = int ( n / 2 )				      	}							      }								  
    i = 3						      	for ( int i = 3 ;					      int i = 3 ;						  
    while ( i <= int ( math.sqrt ( n ) ) ) :		      	i <= sqrt ( n ) ;					      while ( ( i <= ( int ) sqrt ( n ) ) ) {			  
	if ( n % i == 0 ) :				      	i = i + 2 ) {						    	if ( ( n % i == 0 ) ) {					  
	    count = count + 1				      	  if ( n % i == 0 ) {					    	  count = count + 1 ;					  
	    while ( n % i == 0 ) :			      	    count ++ ;						    	  while ( ( n % i == 0 ) ) n = ( int ) ( n / i ) ;	  
		n = int ( n / i )			      	    while ( n % i == 0 ) n = n / i ;			    	}							  
	i = i + 2					      	  }							    	i = i + 2 ;						  
    if ( n > 2 ) :					      	}							      }								  
	count = count + 1				      	if ( n > 2 ) count ++ ;					      if ( ( n > 2 ) ) count = count + 1 ;			  
    return count					      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES	      COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES	    COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES	  COUNT_POSSIBLE_PATHS_SOURCE_DESTINATION_EXACTLY_K_EDGES
--							      --							    --								  --
def countwalks ( graph , u , v , k ) :			      int countwalks ( int graph [ ] [ V ] , int u , int v , int k  int countwalks ( int * * graph , int u , int v , int k ) {	  script_not_found : None
    if ( k == 0 and u == v ) :				      	if ( k == 0 && u == v ) return 1 ;			      if ( ( k == 0 ) && ( u == v ) ) return 1 ;		  
	return 1					      	if ( k == 1 && graph [ u ] [ v ] ) return 1 ;		      if ( ( k == 1 ) && ( graph [ u ] [ v ] ) ) return 1 ;	  
    if ( k == 1 and graph [ u ] [ v ] ) :		      	if ( k <= 0 ) return 0 ;				      if ( ( k <= 0 ) ) return 0 ;				  
	return 1					      	int count = 0 ;						      int count = 0 ;						  
    if ( k <= 0 ) :					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	return 0					      	i < V ;							      i <= V ;							  
    count = 0						      	i ++ ) if ( graph [ u ] [ i ] == 1 ) count += countwalks (    i ++ ) {							  
    for i in range ( 0 , V ) :				      	return count ;						    	if ( ( graph [ u ] [ i ] == 1 ) ) count += countwalks ( g 
	if ( graph [ u ] [ i ] == 1 ) :			      }								      }								  
	    count += countwalks ( graph , i , v , k - 1 )     								      return count ;						  
    return count					      								      return u * u ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FITTING_SHELVES_PROBLEM					      FITTING_SHELVES_PROBLEM					    FITTING_SHELVES_PROBLEM					  FITTING_SHELVES_PROBLEM
--							      --							    --								  --
def minSpacePreferLarge ( w , m , n ) :			      void minSpacePreferLarge ( int wall , int m , int n ) {	    int minSpacePreferLarge ( int w , int m , int n ) {		  script_not_found : None
    num_m = 0						      	int num_m = 0 , num_n = 0 , min_empty = wall ;		      int numM = 0 ;						  
    num_n = 0						      	int p = 0 , q = 0 , rem ;				      int numN = 0 ;						  
    rem = w						      	while ( wall >= n ) {					      int rem = w ;						  
    p = 0						      	  p = wall / m ;					      int p = 0 ;						  
    q = 0						      	  rem = wall % m ;					      int q = 0 ;						  
    r = 0						      	  if ( rem <= min_empty ) {				      int r = 0 ;						  
    while ( w >= n ) :					      	    num_m = p ;						      while ( ( w >= n ) && ( w <= m ) ) {			  
	p = w / m					      	    num_n = q ;						    	p = w / m ;						  
	r = w % m					      	    min_empty = rem ;					    	r = w % m ;						  
	if ( r <= rem ) :				      	  }							    	if ( ( r <= rem ) ) {					  
	    num_m = p					      	  q += 1 ;						    	  numM = p ;						  
	    num_n = q					      	  wall = wall - n ;					    	  numN = q ;						  
	    rem = r					      	}							    	  rem = r ;						  
	q += 1						      	cout << num_m << " " << num_n << " " << min_empty << endl ; 	}							  
	w -= n						      }								    	q ++ ;							  
    print ( str ( int ( num_m ) ) + " " + str ( num_n ) + " " 								    	w -= n ;						  
							      								      }								  
							      								      cout << to_string ( ( int ) numM ) << " " << to_string ( nu 
							      								      return numM * numN ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM		      DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM		    DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM		  DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM
--							      --							    --								  --
def knapSack ( W , wt , val , n ) :			      int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {   int knapSack ( int W , int * wt , int * val , int n ) {	  success : None
    if n == 0 or W == 0 :				      	if ( n == 0 || W == 0 ) return 0 ;			      if ( n == 0 || W == 0 ) return 0 ;			  
	return 0					      	if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n    if ( ( wt [ n - 1 ] > W ) ) return knapSack ( W , wt , val  
    if ( wt [ n - 1 ] > W ) :				      	else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1   else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 
	return knapSack ( W , wt , val , n - 1 )	      }								    }								  
    else :						      								    								  
	return max ( val [ n - 1 ] + knapSack ( W - wt [ n -  								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_1_N_SWAPPING_ADJACENT_ELEMENTS			      SORT_1_N_SWAPPING_ADJACENT_ELEMENTS			    SORT_1_N_SWAPPING_ADJACENT_ELEMENTS				  SORT_1_N_SWAPPING_ADJACENT_ELEMENTS
--							      --							    --								  --
def sortedAfterSwap ( A , B , n ) :			      bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) {	    bool sortedAfterSwap ( string A , string B , int n ) {	  script_not_found : None
    for i in range ( 0 , n - 1 ) :			      	int i , j ;						      for ( int i = 0 ;						  
	if ( B [ i ] == 1 ) :				      	for ( i = 0 ;						      i <= n - 1 ;						  
	    j = i					      	i < n - 1 ;						      i ++ ) {							  
	    while ( B [ j ] == 1 ) :			      	i ++ ) {						    	if ( ( B [ i ] == 1 ) ) {				  
		j = j + 1				      	  if ( B [ i ] ) {					    	  int j = i ;						  
	    A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A  	    j = i ;						    	  while ( ( B [ j ] == 1 ) ) j = j + 1 ;		  
	    i = j					      	    while ( B [ j ] ) j ++ ;				    	  A = A . substr ( 0 , i ) + A . substr ( i , j + 1 ) + A 
    for i in range ( 0 , n ) :				      	    sort ( A + i , A + 1 + j ) ;			    	  i = j ;						  
	if ( A [ i ] != i + 1 ) :			      	    i = j ;						    	}							  
	    return False				      	  }							      }								  
    return True						      	}							      for ( int i = 0 ;						  
							      	for ( i = 0 ;						      i <= n ;							  
							      	i < n ;							      i ++ ) if ( ( A [ i ] != i + 1 ) ) return false ;		  
							      	i ++ ) {						      return true ;						  
							      	  if ( A [ i ] != i + 1 ) return false ;		      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      	}							    }								  
							      	return true ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT FIND_THREE_ELEMENT_FROM_DIFFERENT_THREE_ARRAYS_SUCH_THAT_THAT
--							      --							    --								  --
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) :	      bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int bool findTriplet ( int * a1 , int * a2 , int * a3 , int n1 ,  failure : #Results: 2, 10
    s = set ( )						      	unordered_set < int > s ;				      set < int > s ;						  
    for i in range ( n1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	s.add ( a1 [ i ] )				      	i < n1 ;						      i < n1 ;							  
    for i in range ( n2 ) :				      	i ++ ) s . insert ( a1 [ i ] ) ;			      i ++ ) s . insert ( a1 [ i ] ) ;				  
	for j in range ( n3 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    if sum - a2 [ i ] - a3 [ j ] in s :		      	i < n2 ;						      i < n2 ;							  
		return True				      	i ++ ) {						      i ++ ) for ( int j = 0 ;					  
    return False					      	  for ( int j = 0 ;					      j < n3 ;							  
							      	  j < n3 ;						      j ++ ) if ( s . count ( a2 [ i ] - a3 [ j ] ) ) return true 
							      	  j ++ ) {						      return false ;						  
							      	    if ( s . find ( sum - a2 [ i ] - a3 [ j ] ) != s . end  }								  
							      	  }							    								  
							      	}							    								  
							      	return false ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STOOGE_SORT						      STOOGE_SORT						    STOOGE_SORT							  STOOGE_SORT
--							      --							    --								  --
def stoogesort ( arr , l , h ) :			      void stoogesort ( int arr [ ] , int l , int h ) {		    void stoogesort ( int * arr , int l , int h ) {		  success : None
    if l >= h :						      	if ( l >= h ) return ;					      if ( l >= h ) return ;					  
	return						      	if ( arr [ l ] > arr [ h ] ) swap ( arr [ l ] , arr [ h ] )   if ( arr [ l ] > arr [ h ] ) {				  
    if arr [ l ] > arr [ h ] :				      	if ( h - l + 1 > 2 ) {					    	int t = arr [ l ] ;					  
	t = arr [ l ]					      	  int t = ( h - l + 1 ) / 3 ;				    	arr [ l ] = arr [ h ] ;					  
	arr [ l ] = arr [ h ]				      	  stoogesort ( arr , l , h - t ) ;			    	arr [ h ] = t ;						  
	arr [ h ] = t					      	  stoogesort ( arr , l + t , h ) ;			      }								  
    if h - l + 1 > 2 :					      	  stoogesort ( arr , l , h - t ) ;			      if ( h - l + 1 > 2 ) {					  
	t = ( int ) ( ( h - l + 1 ) / 3 )		      	}							    	int t = ( int ) ( ( h - l + 1 ) / 3 ) ;			  
	stoogesort ( arr , l , ( h - t ) )		      }								    	stoogesort ( arr , l , ( h - t ) ) ;			  
	stoogesort ( arr , l + t , ( h ) )		      								    	stoogesort ( arr , l + t , ( h ) ) ;			  
	stoogesort ( arr , l , ( h - t ) )		      								    	stoogesort ( arr , l , ( h - t ) ) ;			  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SIZE_SUBARRAY_MAXIMUM_SUM				      SIZE_SUBARRAY_MAXIMUM_SUM					    SIZE_SUBARRAY_MAXIMUM_SUM					  SIZE_SUBARRAY_MAXIMUM_SUM
--							      --							    --								  --
def maxSubArraySum ( a , size ) :			      int maxSubArraySum ( int a [ ] , int size ) {		    int maxSubArraySum ( int * a , int size ) {			  success : None
    max_so_far = - maxsize - 1				      	int max_so_far = INT_MIN , max_ending_here = 0 , start = 0    int maxSoFar = - INT_MAX - 1 ;				  
    max_ending_here = 0					      	for ( int i = 0 ;					      int maxEndingHere = 0 ;					  
    start = 0						      	i < size ;						      int start = 0 ;						  
    end = 0						      	i ++ ) {						      int end = 0 ;						  
    s = 0						      	  max_ending_here += a [ i ] ;				      int s = 0 ;						  
    for i in range ( 0 , size ) :			      	  if ( max_so_far < max_ending_here ) {			      for ( int i = 0 ;						  
	max_ending_here += a [ i ]			      	    max_so_far = max_ending_here ;			      i != size ;						  
	if max_so_far < max_ending_here :		      	    start = s ;						      i ++ ) {							  
	    max_so_far = max_ending_here		      	    end = i ;						    	maxEndingHere += a [ i ] ;				  
	    start = s					      	  }							    	if ( maxSoFar < maxEndingHere ) {			  
	    end = i					      	  if ( max_ending_here < 0 ) {				    	  maxSoFar = maxEndingHere ;				  
	if max_ending_here < 0 :			      	    max_ending_here = 0 ;				    	  start = s ;						  
	    max_ending_here = 0				      	    s = i + 1 ;						    	  end = i ;						  
	    s = i + 1					      	  }							    	}							  
    return ( end - start + 1 )				      	}							    	if ( maxEndingHere < 0 ) {				  
							      	return ( end - start + 1 ) ;				    	  maxEndingHere = 0 ;					  
							      }								    	  s = i + 1 ;						  
							      								    	}							  
							      								      }								  
							      								      return ( end - start + 1 ) ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY		      MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY			    MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY			  MAXIMUM_CONSECUTIVE_NUMBERS_PRESENT_ARRAY
--							      --							    --								  --
def findLongestConseqSubseq ( arr , n ) :		      int findLongestConseqSubseq ( int arr [ ] , int n ) {	    int findLongestConseqSubseq ( int * arr , int n ) {		  success : None
    S = set ( )						      	unordered_set < int > S ;				      set < int > S ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	S.add ( arr [ i ] )				      	i < n ;							      i < n ;							  
    ans = 0						      	i ++ ) S . insert ( arr [ i ] ) ;			      i ++ ) S . insert ( arr [ i ] ) ;				  
    for i in range ( n ) :				      	int ans = 0 ;						      int ans = 0 ;						  
	if S.__contains__ ( arr [ i ] ) :		      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    j = arr [ i ]				      	i < n ;							      i < n ;							  
	    while ( S.__contains__ ( j ) ) :		      	i ++ ) {						      i ++ ) {							  
		j += 1					      	  if ( S . find ( arr [ i ] - 1 ) == S . end ( ) ) {	    	if ( S . count ( arr [ i ] ) ) {			  
	    ans = max ( ans , j - arr [ i ] )		      	    int j = arr [ i ] ;					    	  int j = arr [ i ] ;					  
    return ans						      	    while ( S . find ( j ) != S . end ( ) ) j ++ ;	    	  while ( ( S . count ( j ) ) ) j ++ ;			  
							      	    ans = max ( ans , j - arr [ i ] ) ;			    	  ans = max ( ans , j - arr [ i ] ) ;			  
							      	  }							    	}							  
							      	}							      }								  
							      	return ans ;						      return ans ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY LONGEST_ALTERNATING_POSITIVE_NEGATIVE_SUBARRAY_STARTING_EVERY
--							      --							    --								  --
def longestAlternating ( arr , n ) :			      void longestAlternating ( int arr [ ] , int n ) {		    int longestAlternating ( int * arr , int n ) {		  script_not_found : None
    count = [ None ] * n				      	int count [ n ] ;					      vector < int > count ( n , 0 ) ;				  
    count [ n - 1 ] = 1					      	count [ n - 1 ] = 1 ;					      count [ n - 1 ] = 1 ;					  
    i = n - 2						      	for ( int i = n - 2 ;					      int i = n - 2 ;						  
    while i >= 0 :					      	i >= 0 ;						      while ( i >= 0 ) {					  
	if ( arr [ i ] * arr [ i + 1 ] < 0 ) :		      	i -- ) {						    	if ( ( arr [ i ] * arr [ i + 1 ] < 0 ) ) count [ i ] = co 
	    count [ i ] = count [ i + 1 ] + 1		      	  if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count  	else count [ i ] = 1 ;					  
	else :						      	  else count [ i ] = 1 ;				    	i = i - 1 ;						  
	    count [ i ] = 1				      	}							      }								  
	i = i - 1					      	for ( int i = 0 ;					      i = 0 ;							  
    i = 0						      	i < n ;							      while ( i < n ) {						  
    while i < n :					      	i ++ ) cout << count [ i ] << " " ;			    	cout << count [ i ] << " " ;				  
	print ( count [ i ] , end = " " )		      }								    	i = i + 1 ;						  
	i = i + 1					      								      }								  
							      								      return n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
-							      -								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS_WINDOW_ARRAY_UNIQU
--							      --							    --								  --
def returnMaxSum ( A , B , n ) :			      int returnMaxSum ( int A [ ] , int B [ ] , int n ) {	    int returnMaxSum ( int * A , int * B , int n ) {		  error : MAXIMUM_POSSIBLE_SUM_WINDOW_ARRAY_ELEMENTS
    mp = set ( )					      	unordered_set < int > mp ;				      set < int > mp ;						  _WINDOW_ARRAY_UNIQUE.cpp: In function ‘int f_fille
    result = 0						      	int result = 0 ;					      int result = 0 ;						  d(int*, int*, int)’: MAXIMUM_POSSIBLE_SUM_WINDOW_A
    curr_sum = curr_begin = 0				      	int curr_sum = 0 , curr_begin = 0 ;			      int currSum = currBegin = 0 ;				  RRAY_ELEMENTS_WINDOW_ARRAY_UNIQUE.cpp:39:17: error
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  : ‘currBegin’ was not declared in this scope	  in
	while A [ i ] in mp :				      	i < n ;							      i < n ;							  t currSum = currBegin = 0 ;		       ^~~~~
	    mp.remove ( A [ curr_begin ] )		      	++ i ) {						      i ++ ) {							  ~~~~
	    curr_sum -= B [ curr_begin ]		      	  while ( mp . find ( A [ i ] ) != mp . end ( ) ) {	    	while ( mp . count ( A [ i ] ) ) {			  
	    curr_begin += 1				      	    mp . erase ( A [ curr_begin ] ) ;			    	  mp . erase ( A [ currBegin ] ) ;			  
	mp.add ( A [ i ] )				      	    curr_sum -= B [ curr_begin ] ;			    	  currSum -= B [ currBegin ] ;				  
	curr_sum += B [ i ]				      	    curr_begin ++ ;					    	  currBegin ++ ;					  
	result = max ( result , curr_sum )		      	  }							    	}							  
    return result					      	  mp . insert ( A [ i ] ) ;				    	mp . insert ( A [ i ] ) ;				  
							      	  curr_sum += B [ i ] ;					    	currSum += B [ i ] ;					  
							      	  result = max ( result , curr_sum ) ;			    	result = max ( result , currSum ) ;			  
							      	}							      }								  
							      	return result ;						      return result ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_ COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_ COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_ COUNT_OF_N_DIGIT_NUMBERS_WHOSE_SUM_OF_DIGITS_EQUALS_TO_GIVEN_
--							      --							    --								  --
def findCount ( n , sum ) :				      void findCount ( int n , int sum ) {			    int findCount ( int n , int sum ) {				  script_not_found : None
    start = math.pow ( 10 , n - 1 )			      	int start = pow ( 10 , n - 1 ) ;			      int start = pow < int > ( 10 , n - 1 ) ;			  
    end = math.pow ( 10 , n ) - 1			      	int end = pow ( 10 , n ) - 1 ;				      int end = pow < int > ( 10 , n ) - 1 ;			  
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    i = start						      	int i = start ;						      int i = start ;						  
    while ( i <= end ) :				      	while ( i <= end ) {					      while ( ( i <= end ) && ( i >= end ) ) {			  
	cur = 0						      	  int cur = 0 ;						    	int cur = 0 ;						  
	temp = i					      	  int temp = i ;					    	int temp = i ;						  
	while ( temp != 0 ) :				      	  while ( temp != 0 ) {					    	while ( ( temp != 0 ) ) {				  
	    cur += temp % 10				      	    cur += temp % 10 ;					    	  cur += temp % 10 ;					  
	    temp = temp // 10				      	    temp = temp / 10 ;					    	  temp = temp / 10 ;					  
	if ( cur == sum ) :				      	  }							    	}							  
	    count = count + 1				      	  if ( cur == sum ) {					    	if ( ( cur == sum ) ) {					  
	    i += 9					      	    count ++ ;						    	  count = count + 1 ;					  
	else :						      	    i += 9 ;						    	  i += 9 ;						  
	    i = i + 1					      	  }							    	}							  
    print ( count )					      	  else i ++ ;						    	else {							  
							      	}							    	  i = i + 1 ;						  
							      	cout << count ;						    	}							  
							      }								      }								  
							      								      cout << count << endl ;					  
							      								      return count ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1	      PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1	    PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1	  PAIR_WITH_GIVEN_PRODUCT_SET_1_FIND_IF_ANY_PAIR_EXISTS_1
--							      --							    --								  --
def isProduct ( arr , n , x ) :				      bool isProduct ( int arr [ ] , int n , int x ) {		    bool isProduct ( int * arr , int n , int x ) {		  failure : #Results: 9, 10
    if n < 2 :						      	if ( n < 2 ) return false ;				      if ( n < 2 ) return false ;				  
	return False					      	unordered_set < int > s ;				      set < int > s ;						  
    s = set ( )						      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( 0 , n ) :				      	i < n ;							      i <= n ;							  
	if arr [ i ] == 0 :				      	i ++ ) {						      i ++ ) {							  
	    if x == 0 :					      	  if ( arr [ i ] == 0 ) {				    	if ( arr [ i ] == 0 ) {					  
		return True				      	    if ( x == 0 ) return true ;				    	  if ( x == 0 ) return true ;				  
	    else :					      	    else continue ;					    	  else continue ;					  
		continue				      	  }							    	}							  
	if x % arr [ i ] == 0 :				      	  if ( x % arr [ i ] == 0 ) {				    	if ( x % arr [ i ] == 0 ) {				  
	    if x // arr [ i ] in s :			      	    if ( s . find ( x / arr [ i ] ) != s . end ( ) ) return 	  if ( x / arr [ i ] == s . count ( arr [ i ] ) ) return  
		return True				      	    s . insert ( arr [ i ] ) ;				    	  s . insert ( arr [ i ] ) ;				  
	    s.add ( arr [ i ] )				      	  }							    	}							  
    return False					      	}							      }								  
							      	return false ;						      return false ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1	      CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1		    CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1		  CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER_1
--							      --							    --								  --
def checkCorrectOrNot ( s ) :				      bool checkCorrectOrNot ( string s ) {			    bool checkCorrectOrNot ( string s ) {			  script_not_found : None
    global MAX_CHAR					      	int count [ MAX_CHAR ] = {				      static int MAX_CHAR = 256 ;				  
    count = [ 0 ] * MAX_CHAR				      	  0 }							      vector < int > count ( MAX_CHAR , 0 ) ;			  
    n = len ( s )					      	  ;							      int n = s . length ( ) ;					  
    if n == 1 :						      	  int n = s . length ( ) ;				      if ( n == 1 ) return true ;				  
	return true					      	  if ( n == 1 ) return true ;				      int i = 0 , j = n - 1 ;					  
    i = 0 j = n - 1					      	  for ( int i = 0 , j = n - 1 ;				      while ( i < j ) {						  
    while i < j :					      	  i < j ;						    	count [ s [ i ] - 'a' ] ++ ;				  
	count [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1	      	  i ++ , j -- ) {					    	count [ s [ j ] - 'a' ] -- ;				  
	count [ ord ( s [ j ] ) - ord ( 'a' ) ] -= 1	      	    count [ s [ i ] - 'a' ] ++ ;			    	i ++ ;							  
	i += 1 j -= 1					      	    count [ s [ j ] - 'a' ] -- ;			    	j -- ;							  
    for i in range ( MAX_CHAR ) :			      	  }							      }								  
	if count [ i ] != 0 :				      	  for ( int i = 0 ;					      for ( int i = 0 ;						  
	    return False				      	  i < MAX_CHAR ;					      i < MAX_CHAR ;						  
    return True						      	  i ++ ) if ( count [ i ] != 0 ) return false ;		      i ++ ) {							  
							      	  return true ;						    	if ( count [ i ] != 0 ) return false ;			  
							      	}							      }								  
							      								      return true ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BRESENHAMS_LINE_GENERATION_ALGORITHM			      BRESENHAMS_LINE_GENERATION_ALGORITHM			    BRESENHAMS_LINE_GENERATION_ALGORITHM			  BRESENHAMS_LINE_GENERATION_ALGORITHM
--							      --							    --								  --
def bresenham ( x1 , y1 , x2 , y2 ) :			      void bresenham ( int x1 , int y1 , int x2 , int y2 ) {	    double bresenham ( double x1 , double y1 , double x2 , double script_not_found : None
    m_new = 2 * ( y2 - y1 )				      	int m_new = 2 * ( y2 - y1 ) ;				      double m_new = 2 * ( y2 - y1 ) ;				  
    slope_error_new = m_new - ( x2 - x1 )		      	int slope_error_new = m_new - ( x2 - x1 ) ;		      double slope_error_new = m_new - ( x2 - x1 ) ;		  
    y = y1						      	for ( int x = x1 , y = y1 ;				      double y = y1 ;						  
    for x in range ( x1 , x2 + 1 ) :			      	x <= x2 ;						      for ( double x = x1 ;					  
	print ( "(" , x , "," , y , ")\n" )		      	x ++ ) {						      x <= x2 ;							  
	slope_error_new = slope_error_new + m_new	      	  cout << "(" << x << "," << y << ")\n" ;		      x ++ ) {							  
	if ( slope_error_new >= 0 ) :			      	  slope_error_new += m_new ;				    	cout << "(" << x << "," << y << ")\n" ;			  
	    y = y + 1					      	  if ( slope_error_new >= 0 ) {				    	slope_error_new = slope_error_new + m_new ;		  
	    slope_error_new = slope_error_new - 2 * ( x2 - x1 	    y ++ ;						    	if ( ( slope_error_new >= 0 ) && ( slope_error_new <= 0 ) 
							      	    slope_error_new -= 2 * ( x2 - x1 ) ;		    	  y = y + 1 ;						  
							      	  }							    	  slope_error_new = slope_error_new - 2 * ( x2 - x1 ) ;	  
							      	}							    	}							  
							      }								      }								  
							      								      return y ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION			      PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION			    PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION			  PROGRAM_DECIMAL_HEXADECIMAL_CONVERSION
--							      --							    --								  --
def decToHexa ( n ) :					      void decToHexa ( int n ) {				    int decToHexa ( int n ) {					  script_not_found : None
    hexaDeciNum = [ '0' ] * 100				      	char hexaDeciNum [ 100 ] ;				      char hexaDeciNum [ 100 ] ;				  
    i = 0						      	int i = 0 ;						      hexaDeciNum [ 0 ] = '0' ;					  
    while ( n != 0 ) :					      	while ( n != 0 ) {					      int i = 0 ;						  
	temp = 0					      	  int temp = 0 ;					      while ( ( n != 0 ) ) {					  
	temp = n % 16					      	  temp = n % 16 ;					    	int temp ;						  
	if ( temp < 10 ) :				      	  if ( temp < 10 ) {					    	temp = n % 16 ;						  
	    hexaDeciNum [ i ] = chr ( temp + 48 )	      	    hexaDeciNum [ i ] = temp + 48 ;			    	if ( ( temp < 10 ) ) {					  
	    i = i + 1					      	    i ++ ;						    	  hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ;		  
	else :						      	  }							    	  i = i + 1 ;						  
	    hexaDeciNum [ i ] = chr ( temp + 55 )	      	  else {						    	}							  
	    i = i + 1					      	    hexaDeciNum [ i ] = temp + 55 ;			    	else {							  
	n = int ( n / 16 )				      	    i ++ ;						    	  hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ;		  
    j = i - 1						      	  }							    	  i = i + 1 ;						  
    while ( j >= 0 ) :					      	  n = n / 16 ;						    	}							  
	print ( ( hexaDeciNum [ j ] ) , end = "" )	      	}							    	n = ( int ) ( n / 16 ) ;				  
	j = j - 1					      	for ( int j = i - 1 ;					      }								  
							      	j >= 0 ;						      int j = i - 1 ;						  
							      	j -- ) cout << hexaDeciNum [ j ] ;			      while ( ( j >= 0 ) ) {					  
							      }								    	cout << ( hexaDeciNum [ j ] ) << " " ;			  
							      								    	j = j - 1 ;						  
							      								      }								  
							      								      return j ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_DIVISIBLE_PAIRS_SUBSET				      LARGEST_DIVISIBLE_PAIRS_SUBSET				    LARGEST_DIVISIBLE_PAIRS_SUBSET				  LARGEST_DIVISIBLE_PAIRS_SUBSET
--							      --							    --								  --
def largestSubset ( a , n ) :				      int largestSubset ( int a [ ] , int n ) {			    int largestSubset ( int a [ ] , int n ) {			  script_not_found : None
    a.sort ( )						      	sort ( a , a + n ) ;					      sort ( a , a + n ) ;					  
    dp = [ 0 for i in range ( n ) ]			      	int dp [ n ] ;						      vector < int > dp ( n , 0 ) ;				  
    dp [ n - 1 ] = 1					      	dp [ n - 1 ] = 1 ;					      dp [ n - 1 ] = 1 ;					  
    for i in range ( n - 2 , - 1 , - 1 ) :		      	for ( int i = n - 2 ;					      for ( int i = n - 2 ;					  
	mxm = 0						      	i >= 0 ;						      i >= 0 ;							  
	for j in range ( i + 1 , n ) :			      	i -- ) {						      -- i ) {							  
	    if a [ j ] % a [ i ] == 0 :			      	  int mxm = 0 ;						    	int mxm = 0 ;						  
		mxm = max ( mxm , dp [ j ] )		      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
	dp [ i ] = 1 + mxm				      	  j < n ;						    	j < n ;							  
    return max ( dp )					      	  j ++ ) if ( a [ j ] % a [ i ] == 0 ) mxm = max ( mxm , dp 	++ j ) {						  
							      	  dp [ i ] = 1 + mxm ;					    	  if ( a [ j ] % a [ i ] == 0 ) mxm = max ( mxm , dp [ j  
							      	}							    	}							  
							      	return * max_element ( dp , dp + n ) ;			    	dp [ i ] = 1 + mxm ;					  
							      }								      }								  
							      								      return max ( dp . size ( ) , n ) ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD REARRANGE_ARRAY_SUCH_THAT_EVEN_POSITIONED_ARE_GREATER_THAN_OD
--							      --							    --								  --
def assign ( a , n ) :					      void assign ( int a [ ] , int n ) {			    int test5 ( int a [ ] , int n ) {				  script_not_found : None
    a.sort ( )						      	sort ( a , a + n ) ;					      sort ( a , a + n ) ;					  
    ans = [ 0 ] * n					      	int ans [ n ] ;						      int ans [ n ] ;						  
    p = 0						      	int p = 0 , q = n - 1 ;					      int p = 0 ;						  
    q = n - 1						      	for ( int i = 0 ;					      int q = n - 1 ;						  
    for i in range ( n ) :				      	i < n ;							      for ( int i = 0 ;						  
	if ( i + 1 ) % 2 == 0 :				      	i ++ ) {						      i < n ;							  
	    ans [ i ] = a [ q ]				      	  if ( ( i + 1 ) % 2 == 0 ) ans [ i ] = a [ q -- ] ;	      i ++ ) {							  
	    q = q - 1					      	  else ans [ i ] = a [ p ++ ] ;				    	if ( ( i + 1 ) % 2 == 0 ) {				  
	else :						      	}							    	  ans [ i ] = a [ q ] ;					  
	    ans [ i ] = a [ p ]				      	for ( int i = 0 ;					    	  q = q - 1 ;						  
	    p = p + 1					      	i < n ;							    	}							  
    for i in range ( n ) :				      	i ++ ) cout << ans [ i ] << " " ;			    	else {							  
	print ( ans [ i ] , end = " " )			      }								    	  ans [ i ] = a [ p ] ;					  
							      								    	  p = p + 1 ;						  
							      								    	}							  
							      								      }								  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) cout << ans [ i ] << " " ;				  
							      								      return 0 ;						  
							      								      return a * a ;						  
-							      -								      return a * a * a * a * a * a * a * a * a * a * a * a * a *  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T PARTITION_INTO_TWO_SUBARRAYS_OF_LENGTHS_K_AND_N_K_SUCH_THAT_T
--							      --							    --								  --
def maxDifference ( arr , N , k ) :			      int maxDifference ( int arr [ ] , int N , int k ) {	    int maxDifference ( int * arr , int N , int k ) {		  failure : #Results: 6, 10
    S = 0						      	int M , S = 0 , S1 = 0 , max_difference = 0 ;		      int S = 0 ;						  
    S1 = 0						      	for ( int i = 0 ;					      int S1 = 0 ;						  
    max_difference = 0					      	i < N ;							      int maxDifference = 0 ;					  
    for i in range ( N ) :				      	i ++ ) S += arr [ i ] ;					      for ( int i = 0 ;						  
	S += arr [ i ]					      	sort ( arr , arr + N , greater < int > ( ) ) ;		      i < N ;							  
    arr.sort ( reverse = True )				      	M = max ( k , N - k ) ;					      i ++ ) S += arr [ i ] ;					  
    M = max ( k , N - k )				      	for ( int i = 0 ;					      sort ( arr , arr + N ) ;					  
    for i in range ( M ) :				      	i < M ;							      int M = max ( k , N - k ) ;				  
	S1 += arr [ i ]					      	i ++ ) S1 += arr [ i ] ;				      for ( int i = 0 ;						  
    max_difference = S1 - ( S - S1 )			      	max_difference = S1 - ( S - S1 ) ;			      i < M ;							  
    return max_difference				      	return max_difference ;					      i ++ ) S1 += arr [ i ] ;					  
							      }								      maxDifference = S1 - ( S - S1 ) ;				  
							      								      return maxDifference ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHIFT_MATRIX_ELEMENTS_K					      SHIFT_MATRIX_ELEMENTS_K					    SHIFT_MATRIX_ELEMENTS_K					  SHIFT_MATRIX_ELEMENTS_K
--							      --							    --								  --
def shiftMatrixByK ( mat , k ) :			      void shiftMatrixByK ( int mat [ N ] [ N ] , int k ) {	    int shiftMatrixByK ( int * * mat , int k ) {		  script_not_found : None
    if ( k > N ) :					      	if ( k > N ) {						      if ( ( k > N ) ) {					  
	print ( "shifting is"" not possible" )		      	  cout << "shifting is not possible" << endl ;		    	cout << "shifting is" << " not possible" << endl ;	  
	return						      	  return ;						    	return 0 ;						  
    j = 0						      	}							      }								  
    while ( j < N ) :					      	int j = 0 ;						      int j = 0 ;						  
	for i in range ( k , N ) :			      	while ( j < N ) {					      while ( ( j < N ) ) {					  
	    print ( "{} ".format ( mat [ j ] [ i ] ) , end =  	  for ( int i = k ;					    	for ( int i = k ;					  
	for i in range ( 0 , k ) :			      	  i < N ;						    	i < N ;							  
	    print ( "{} ".format ( mat [ j ] [ i ] ) , end =  	  i ++ ) cout << mat [ j ] [ i ] << " " ;		    	i ++ ) cout << "{} " ;					  
	print ( "" )					      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
	j = j + 1					      	  i < k ;						    	i < k ;							  
							      	  i ++ ) cout << mat [ j ] [ i ] << " " ;		    	i ++ ) cout << "{} " ;					  
							      	  cout << endl ;					    	cout << endl ;						  
							      	  j ++ ;						    	j = j + 1 ;						  
							      	}							      }								  
							      }								      return j ;						  
							      								      return k * k ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2		      FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2		    FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2			  FIND_ALL_DIVISORS_OF_A_NATURAL_NUMBER_SET_2
--							      --							    --								  --
def printDivisors ( n ) :				      void printDivisors ( int n ) {				    int printDivisors ( int n ) {				  script_not_found : None
    list = [ ]						      	vector < int > v ;					      vector < int > vec ;					  
    for i in range ( 1 , int ( math.sqrt ( n ) + 1 ) ) :      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	if ( n % i == 0 ) :				      	i <= sqrt ( n ) ;					      i < ( int ) sqrt ( n ) + 1 ;				  
	    if ( n / i == i ) :				      	i ++ ) {						      i ++ ) {							  
		print ( i , end = " " )			      	  if ( n % i == 0 ) {					    	if ( ( n % i ) == 0 ) {					  
	    else :					      	    if ( n / i == i ) printf ( "%d " , i ) ;		    	  if ( ( n / i ) == i ) cout << i << " " ;		  
		print ( i , end = " " )			      	    else {						    	  else {						  
		list.append ( int ( n / i ) )		      	      printf ( "%d " , i ) ;				    	    cout << i << " " ;					  
    for i in list [ : : - 1 ] :				      	      v . push_back ( n / i ) ;				    	    vec . push_back ( ( int ) n / i ) ;			  
	print ( i , end = " " )				      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	for ( int i = v . size ( ) - 1 ;			      for ( int i = vec . size ( ) - 1 ;			  
							      	i >= 0 ;						      i >= 0 ;							  
							      	i -- ) printf ( "%d " , v [ i ] ) ;			      i -- ) cout << vec [ i ] << " " ;				  
							      }								      return 0 ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1	      COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1		    COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1		  COUNT_INVERSIONS_OF_SIZE_THREE_IN_A_GIVE_ARRAY_1
--							      --							    --								  --
def getInvCount ( arr , n ) :				      int getInvCount ( int arr [ ] , int n ) {			    int getInvCount ( int * arr , int n ) {			  success : None
    invcount = 0					      	int invcount = 0 ;					      int invcount = 0 ;					  
    for i in range ( 1 , n - 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	small = 0					      	i < n - 1 ;						      i < n - 1 ;						  
	for j in range ( i + 1 , n ) :			      	i ++ ) {						      i ++ ) {							  
	    if ( arr [ i ] > arr [ j ] ) :		      	  int small = 0 ;					    	int small = 0 ;						  
		small += 1				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
	great = 0					      	  j < n ;						    	j < n ;							  
	for j in range ( i - 1 , - 1 , - 1 ) :		      	  j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ;	    	j ++ ) if ( ( arr [ i ] > arr [ j ] ) ) small ++ ;	  
	    if ( arr [ i ] < arr [ j ] ) :		      	  int great = 0 ;					    	int great = 0 ;						  
		great += 1				      	  for ( int j = i - 1 ;					    	for ( int j = i - 1 ;					  
	invcount += great * small			      	  j >= 0 ;						    	j >= 0 ;						  
    return invcount					      	  j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ;	    	j -- ) if ( ( arr [ i ] < arr [ j ] ) ) great ++ ;	  
							      	  invcount += great * small ;				    	invcount += great * small ;				  
							      	}							      }								  
							      	return invcount ;					      return invcount ;						  
							      }								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS		      MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS		    MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS		  MAXIMIZE_ARRAY_SUN_AFTER_K_NEGATION_OPERATIONS
--							      --							    --								  --
def maximumSum ( arr , n , k ) :			      int maximumSum ( int arr [ ] , int n , int k ) {		    int maximumSum ( int * arr , int n , int k ) {		  script_not_found : None
    for i in range ( 1 , k + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	min = + 2147483647				      	i <= k ;						      i <= k ;							  
	index = - 1					      	i ++ ) {						      i ++ ) {							  
	for j in range ( n ) :				      	  int min = INT_MAX ;					    	int min = + 2147483647 ;				  
	    if ( arr [ j ] < min ) :			      	  int index = - 1 ;					    	int index = - 1 ;					  
		min = arr [ j ]				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
		index = j				      	  j < n ;						    	j < n ;							  
	if ( min == 0 ) :				      	  j ++ ) {						    	j ++ ) {						  
	    break					      	    if ( arr [ j ] < min ) {				    	  if ( ( arr [ j ] < min ) ) {				  
	arr [ index ] = - arr [ index ]			      	      min = arr [ j ] ;					    	    min = arr [ j ] ;					  
    sum = 0						      	      index = j ;					    	    index = j ;						  
    for i in range ( n ) :				      	    }							    	  }							  
	sum += arr [ i ]				      	  }							    	}							  
    return sum						      	  if ( min == 0 ) break ;				    	if ( ( min == 0 ) ) break ;				  
							      	  arr [ index ] = - arr [ index ] ;			    	arr [ index ] = - arr [ index ] ;			  
							      	}							      }								  
							      	int sum = 0 ;						      int sum = 0 ;						  
							      	for ( int i = 0 ;					      for ( int i = 0 ;						  
							      	i < n ;							      i < n ;							  
							      	i ++ ) sum += arr [ i ] ;				      i ++ ) sum += arr [ i ] ;					  
							      	return sum ;						      return sum ;						  
							      }								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1		      FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1		    FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1			  FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH_1
--							      --							    --								  --
def findMaxAverage ( arr , n , k ) :			      int findMaxAverage ( int arr [ ] , int n , int k ) {	    int findMaxAverage ( int * arr , int n , int k ) {		  failure : #Results: 9, 10
    if ( k > n ) :					      	if ( k > n ) return - 1 ;				      if ( ( k > n ) ) return - 1 ;				  
	return - 1					      	int sum = arr [ 0 ] ;					      int sum = arr [ 0 ] ;					  
    sum = arr [ 0 ]					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
    for i in range ( 1 , k ) :				      	i < k ;							      i < k ;							  
	sum += arr [ i ]				      	i ++ ) sum += arr [ i ] ;				      i ++ ) sum += arr [ i ] ;					  
    max_sum = sum					      	int max_sum = sum , max_end = k - 1 ;			      int maxSum = sum ;					  
    max_end = k - 1					      	for ( int i = k ;					      int maxEnd = k - 1 ;					  
    for i in range ( k , n ) :				      	i < n ;							      for ( int i = k ;						  
	sum = sum + arr [ i ] - arr [ i - k ]		      	i ++ ) {						      i < n ;							  
	if ( sum > max_sum ) :				      	  int sum = sum + arr [ i ] - arr [ i - k ] ;		      i ++ ) {							  
	    max_sum = sum				      	  if ( sum > max_sum ) {				    	sum = sum + arr [ i ] - arr [ i - k ] ;			  
	    max_end = i					      	    max_sum = sum ;					    	if ( ( sum > maxSum ) ) {				  
    return max_end - k + 1				      	    max_end = i ;					    	  maxSum = sum ;					  
							      	  }							    	  maxEnd = i ;						  
							      	}							    	}							  
							      	return max_end - k + 1 ;				      }								  
							      }								      return maxEnd - k + 1 ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE			      MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE			    MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE			  MAXIMUM_PRODUCT_INCREASING_SUBSEQUENCE
--							      --							    --								  --
def lis ( arr , n ) :					      ll lis ( ll arr [ ] , ll n ) {				    int lis ( int * arr , int n ) {				  script_not_found : None
    mpis = [ 0 ] * ( n )				      	ll mpis [ n ] ;						      int * mpis = new int [ n ] ;				  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	mpis [ i ] = arr [ i ]				      	i < n ;							      i < n ;							  
    for i in range ( 1 , n ) :				      	i ++ ) mpis [ i ] = arr [ i ] ;				      i ++ ) mpis [ i ] = arr [ i ] ;				  
	for j in range ( i ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	    if ( arr [ i ] > arr [ j ] and mpis [ i ] < ( mpi 	i < n ;							      i < n ;							  
		mpis [ i ] = mpis [ j ] * arr [ i ]	      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
    return max ( mpis )					      	j < i ;							    	for ( int j = 0 ;					  
							      	j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [  	j < i ;							  
							      	return * max_element ( mpis , mpis + n ) ;		    	j ++ ) {						  
							      }								    	  if ( ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j 
							      								    	}							  
							      								      }								  
							      								      return max ( mpis , n ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS		      FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS		    FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS			  FIND_FIRST_REPEATING_ELEMENT_ARRAY_INTEGERS
--							      --							    --								  --
def printFirstRepeating ( arr , n ) :			      void printFirstRepeating ( int arr [ ] , int n ) {	    int printFirstRepeating ( int * arr , int n ) {		  script_not_found : None
    Min = - 1						      	int min = - 1 ;						      int Min = - 1 ;						  
    myset = dict ( )					      	set < int > myset ;					      map < int , int > myset ;					  
    for i in range ( n - 1 , - 1 , - 1 ) :		      	for ( int i = n - 1 ;					      for ( int i = n - 1 ;					  
	if arr [ i ] in myset.keys ( ) :		      	i >= 0 ;						      i >= 0 ;							  
	    Min = i					      	i -- ) {						      i -- ) {							  
	else :						      	  if ( myset . find ( arr [ i ] ) != myset . end ( ) ) min  	if ( myset . count ( arr [ i ] ) ) Min = i ;		  
	    myset [ arr [ i ] ] = 1			      	  else myset . insert ( arr [ i ] ) ;			    	else myset [ arr [ i ] ] = 1 ;				  
    if ( Min != - 1 ) :					      	}							      }								  
	print ( "The first repeating element is" , arr [ Min  	if ( min != - 1 ) cout << "The first repeating element is "   if ( ( Min != - 1 ) ) cout << "The first repeating element  
    else :						      	else cout << "There are no repeating elements" ;	      else cout << "There are no repeating elements" << endl ;	  
	print ( "There are no repeating elements" )	      }								      return Min ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER	      SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER	    SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER	  SUM_OF_ALL_SUBSTRINGS_OF_A_STRING_REPRESENTING_A_NUMBER
--							      --							    --								  --
def sumOfSubstrings ( num ) :				      int sumOfSubstrings ( string num ) {			    int sumOfSubstrings ( string num ) {			  script_not_found : None
    n = len ( num )					      	int n = num . length ( ) ;				      int n = num . length ( ) ;				  
    sumofdigit = [ ]					      	int sumofdigit [ n ] ;					      vector < int > sumofdigit ;				  
    sumofdigit.append ( int ( num [ 0 ] ) )		      	sumofdigit [ 0 ] = toDigit ( num [ 0 ] ) ;		      sumofdigit . push_back ( atoi ( num [ 0 ] . c_str ( ) ) ) ; 
    res = sumofdigit [ 0 ]				      	int res = sumofdigit [ 0 ] ;				      int res = sumofdigit [ 0 ] ;				  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	numi = int ( num [ i ] )			      	i < n ;							      i < n ;							  
	sumofdigit.append ( ( i + 1 ) * numi + 10 * sumofdigi 	i ++ ) {						      i ++ ) {							  
	res += sumofdigit [ i ]				      	  int numi = toDigit ( num [ i ] ) ;			    	int numi = atoi ( num [ i ] . c_str ( ) ) ;		  
    return res						      	  sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i 	sumofdigit . push_back ( ( i + 1 ) * numi + 10 * sumofdig 
							      	  res += sumofdigit [ i ] ;				    	res += sumofdigit [ i ] ;				  
							      	}							      }								  
							      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1			      FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1			    FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1			  FIND_THE_LARGEST_SUBARRAY_WITH_0_SUM_1
--							      --							    --								  --
def maxLen ( arr ) :					      int maxLen ( int arr [ ] , int n ) {			    int maxLen ( int * arr ) {					  script_not_found : None
    hash_map = { }					      	unordered_map < int , int > presum ;			      unordered_map < int , int > hashMap ;			  
    max_len = 0						      	int sum = 0 ;						      int maxLen = 0 ;						  
    curr_sum = 0					      	int max_len = 0 ;					      int currSum = 0 ;						  
    for i in range ( len ( arr ) ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	curr_sum += arr [ i ]				      	i < n ;							      i < sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;		  
	if arr [ i ] is 0 and max_len is 0 :		      	i ++ ) {						      i ++ ) {							  
	    max_len = 1					      	  sum += arr [ i ] ;					    	currSum += arr [ i ] ;					  
	if curr_sum is 0 :				      	  if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ;	    	if ( arr [ i ] == 0 && maxLen == 0 ) maxLen = 1 ;	  
	    max_len = i + 1				      	  if ( sum == 0 ) max_len = i + 1 ;			    	if ( currSum == 0 ) maxLen = i + 1 ;			  
	if curr_sum in hash_map :			      	  if ( presum . find ( sum ) != presum . end ( ) ) {	    	if ( hashMap . count ( currSum ) ) maxLen = max < int > ( 
	    max_len = max ( max_len , i - hash_map [ curr_sum 	    max_len = max ( max_len , i - presum [ sum ] ) ;	    	else hashMap [ currSum ] = i ;				  
	else :						      	  }							      }								  
	    hash_map [ curr_sum ] = i			      	  else {						      return maxLen ;						  
    return max_len					      	    presum [ sum ] = i ;				    }								  
							      	  }							    								  
							      	}							    								  
							      	return max_len ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT		      REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT		    REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT		  REMOVE_ARRAY_END_ELEMENT_MAXIMIZE_SUM_PRODUCT
--							      --							    --								  --
def solve ( dp , a , low , high , turn ) :		      int solve ( int dp [ ] [ MAX ] , int a [ ] , int low , int hi double solve ( double * * dp , double * a , int low , int hig script_not_found : None
    if ( low == high ) :				      	if ( low == high ) return a [ low ] * turn ;		      if ( ( low == high ) ) return a [ low ] * turn ;		  
	return a [ low ] * turn				      	if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ]    if ( ( dp [ low ] [ high ] != 0 ) ) return dp [ low ] [ hig 
    if ( dp [ low ] [ high ] != 0 ) :			      	dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp ,   dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , 
	return dp [ low ] [ high ]			      	return dp [ low ] [ high ] ;				      return dp [ low ] [ high ] ;				  
    dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp }								    }								  
    return dp [ low ] [ high ]				      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER	      COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER	    COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER	  COUNT_NATURAL_NUMBERS_WHOSE_PERMUTATION_GREATER_NUMBER
--							      --							    --								  --
def countNumber ( n ) :					      int countNumber ( int n ) {				    int countNumber ( int n ) {					  error : /bin/bash: line 1: 1848030 Segmentation fa
    result = 0						      	int result = 0 ;					      int result = 0 ;						  ult	   (core dumped) ./COUNT_NATURAL_NUMBERS_WHO
    for i in range ( 1 , 10 ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  SE_PERMUTATION_GREATER_NUMBER_cpp
	s = [ ]						      	i <= 9 ;						      i < 10 ;							  
	if ( i <= n ) :					      	i ++ ) {						      i ++ ) {							  
	    s.append ( i )				      	  stack < int > s ;					    	stack < int > s ;					  
	    result += 1					      	  if ( i <= n ) {					    	if ( ( i <= n ) && ( s . top ( ) == i ) ) {		  
	while len ( s ) != 0 :				      	    s . push ( i ) ;					    	  s . push ( i ) ;					  
	    tp = s [ - 1 ]				      	    result ++ ;						    	  result ++ ;						  
	    s.pop ( )					      	  }							    	}							  
	    for j in range ( tp % 10 , 10 ) :		      	  while ( ! s . empty ( ) ) {				    	while ( s . top ( ) != 0 ) {				  
		x = tp * 10 + j				      	    int tp = s . top ( ) ;				    	  int tp = s . top ( ) ;				  
		if ( x <= n ) :				      	    s . pop ( ) ;					    	  s . pop ( ) ;						  
		    s.append ( x )			      	    for ( int j = tp % 10 ;				    	  for ( int j = tp % 10 ;				  
		    result += 1				      	    j <= 9 ;						    	  j < 10 ;						  
    return result					      	    j ++ ) {						    	  j ++ ) {						  
							      	      int x = tp * 10 + j ;				    	    int x = tp * 10 + j ;				  
							      	      if ( x <= n ) {					    	    if ( ( x <= n ) && ( s . top ( ) == x ) ) {		  
							      		s . push ( x ) ;				    	      s . push ( x ) ;					  
							      		result ++ ;					    	      result ++ ;					  
							      	      }							    	    }							  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	return result ;						      return result ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RECAMANS_SEQUENCE					      RECAMANS_SEQUENCE						    RECAMANS_SEQUENCE						  RECAMANS_SEQUENCE
--							      --							    --								  --
def recaman ( n ) :					      int recaman ( int n ) {					    int recaman ( int n ) {					  script_not_found : None
    arr = [ 0 ] * n					      	int arr [ n ] ;						      int arr [ n ] ;						  
    arr [ 0 ] = 0					      	arr [ 0 ] = 0 ;						      memset ( arr , 0 , sizeof ( arr ) ) ;			  
    print ( arr [ 0 ] , end = ", " )			      	printf ( "%d, " , arr [ 0 ] ) ;				      arr [ 0 ] = 0 ;						  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      cout << arr [ 0 ] << ", " ;				  
	curr = arr [ i - 1 ] - i			      	i < n ;							      for ( int i = 1 ;						  
	for j in range ( 0 , i ) :			      	i ++ ) {						      i < n ;							  
	    if ( ( arr [ j ] == curr ) or curr < 0 ) :	      	  int curr = arr [ i - 1 ] - i ;			      i ++ ) {							  
		curr = arr [ i - 1 ] + i		      	  int j ;						    	int curr = arr [ i - 1 ] - i ;				  
		break					      	  for ( j = 0 ;						    	for ( int j = 0 ;					  
	arr [ i ] = curr				      	  j < i ;						    	j < i ;							  
	print ( arr [ i ] , end = ", " )		      	  j ++ ) {						    	j ++ ) {						  
							      	    if ( ( arr [ j ] == curr ) || curr < 0 ) {		    	  if ( ( ( arr [ j ] == curr ) || curr < 0 ) ) {	  
							      	      curr = arr [ i - 1 ] + i ;			    	    curr = arr [ i - 1 ] + i ;				  
							      	      break ;						    	    break ;						  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	  arr [ i ] = curr ;					    	arr [ i ] = curr ;					  
							      	  printf ( "%d, " , arr [ i ] ) ;			    	cout << arr [ i ] << ", " ;				  
							      	}							      }								  
							      }								      return n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K     GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K	    GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K	  GIVEN_N_X_N_SQUARE_MATRIX_FIND_SUM_SUB_SQUARES_SIZE_K_X_K
--							      --							    --								  --
def printSumSimple ( mat , k ) :			      void printSumSimple ( int mat [ ] [ n ] , int k ) {	    int sumSimple ( int * * mat , int n ) {			  script_not_found : None
    if ( k > n ) :					      	if ( k > n ) return ;					      if ( ( k > n ) ) return 0 ;				  
	return						      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( n - k + 1 ) :			      	i < n - k + 1 ;						      i < n - k + 1 ;						  
	for j in range ( n - k + 1 ) :			      	i ++ ) {						      i ++ ) {							  
	    sum = 0					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    for p in range ( i , k + i ) :		      	  j < n - k + 1 ;					    	j < n - k + 1 ;						  
		for q in range ( j , k + j ) :		      	  j ++ ) {						    	j ++ ) {						  
		    sum += mat [ p ] [ q ]		      	    int sum = 0 ;					    	  int sum = 0 ;						  
	    print ( sum , end = " " )			      	    for ( int p = i ;					    	  for ( int p = i ;					  
	print ( )					      	    p < k + i ;						    	  p <= k + i ;						  
							      	    p ++ ) for ( int q = j ;				    	  p ++ ) {						  
							      	    q < k + j ;						    	    for ( int q = j ;					  
							      	    q ++ ) sum += mat [ p ] [ q ] ;			    	    q <= k + j ;					  
							      	    cout << sum << "  " ;				    	    q ++ ) sum += mat [ p ] [ q ] ;			  
							      	  }							    	  }							  
							      	  cout << endl ;					    	  cout << sum << " " ;					  
							      	}							    	}							  
							      }								    	cout << endl ;						  
							      								      }								  
							      								      return n ;						  
							      								      return n * n ;						  
-							      -								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER		      C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER			    C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER			  C_PROGRAM_FIND_SECOND_FREQUENT_CHARACTER
--							      --							    --								  --
def getSecondMostFreq ( str ) :				      char getSecondMostFreq ( string str ) {			    char getSecondMostFreq ( string str ) {			  script_not_found : None
    NO_OF_CHARS = 256					      	int count [ NO_OF_CHARS ] = {				      const int NO_OF_CHARS = 256 ;				  
    count = [ 0 ] * NO_OF_CHARS				      	  0 }							      vector < int > count ( NO_OF_CHARS , 0 ) ;		  
    for i in range ( len ( str ) ) :			      	  , i ;							      for ( int i = 0 ;						  
	count [ ord ( str [ i ] ) ] += 1		      	  for ( i = 0 ;						      i < str . length ( ) ;					  
    first , second = 0 , 0				      	  str [ i ] ;						      i ++ ) count [ str [ i ] ] ++ ;				  
    for i in range ( NO_OF_CHARS ) :			      	  i ++ ) ( count [ str [ i ] ] ) ++ ;			      int first = 0 , second = 0 ;				  
	if count [ i ] > count [ first ] :		      	  int first = 0 , second = 0 ;				      for ( int i = 0 ;						  
	    second = first				      	  for ( i = 0 ;						      i < NO_OF_CHARS ;						  
	    first = i					      	  i < NO_OF_CHARS ;					      i ++ ) {							  
	elif ( count [ i ] > count [ second ] and count [ i ] 	  i ++ ) {						    	if ( count [ i ] > count [ first ] ) {			  
	    second = i					      	    if ( count [ i ] > count [ first ] ) {		    	  second = first ;					  
    return chr ( second )				      	      second = first ;					    	  first = i ;						  
							      	      first = i ;					    	}							  
							      	    }							    	else if ( ( count [ i ] > count [ second ] && count [ i ] 
							      	    else if ( count [ i ] > count [ second ] && count [ i ]   }								  
							      	  }							      return ( char ) second ;					  
							      	  return second ;					    }								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES      PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES	    PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES	  PRINT_STRING_SPECIFIED_CHARACTER_OCCURRED_GIVEN_NO_TIMES
--							      --							    --								  --
def printString ( str , ch , count ) :			      void printString ( string str , char ch , int count ) {	    void printString ( string str , char ch , int count ) {	  script_not_found : None
    occ , i = 0 , 0					      	int occ = 0 , i ;					      int occ = 0 , i = 0 ;					  
    if ( count == 0 ) :					      	if ( count == 0 ) {					      if ( ( count == 0 ) ) cout << str << endl ;		  
	print ( str )					      	  cout << str ;						      for ( i = 0 ;						  
    for i in range ( len ( str ) ) :			      	  return ;						      i < str . length ( ) ;					  
	if ( str [ i ] == ch ) :			      	}							      i ++ ) {							  
	    occ += 1					      	for ( i = 0 ;						    	if ( ( str [ i ] == ch ) ) occ ++ ;			  
	if ( occ == count ) :				      	i < str . length ( ) ;					    	if ( ( occ == count ) ) break ;				  
	    break					      	i ++ ) {						      }								  
    if ( i < len ( str ) - 1 ) :			      	  if ( str [ i ] == ch ) occ ++ ;			      if ( ( i < str . length ( ) - 1 ) ) cout << str . substr (  
	print ( str [ i + 1 : len ( str ) - i + 2 ] )	      	  if ( occ == count ) break ;				      else cout << "Empty string" << endl ;			  
    else :						      	}							    }								  
	print ( "Empty string" )			      	if ( i < str . length ( ) - 1 ) cout << str . substr ( i +  								  
							      	else cout << "Empty string" ;				    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS	      SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS	    SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS		  SMALLEST_DIFFERENCE_PAIR_VALUES_TWO_UNSORTED_ARRAYS
--							      --							    --								  --
def findSmallestDifference ( A , B , m , n ) :		      int findSmallestDifference ( int A [ ] , int B [ ] , int m ,  int findSmallestDifference ( int * A , int * B , int m , int  success : None
    A.sort ( )						      	sort ( A , A + m ) ;					      sort ( A , A + m ) ;					  
    B.sort ( )						      	sort ( B , B + n ) ;					      sort ( B , B + m ) ;					  
    a = 0						      	int a = 0 , b = 0 ;					      int a = 0 ;						  
    b = 0						      	int result = INT_MAX ;					      int b = 0 ;						  
    result = sys.maxsize				      	while ( a < m && b < n ) {				      int result = INT_MAX ;					  
    while ( a < m and b < n ) :				      	  if ( abs ( A [ a ] - B [ b ] ) < result ) result = abs (    while ( ( a < m ) && ( b < n ) ) {			  
	if ( abs ( A [ a ] - B [ b ] ) < result ) :	      	  if ( A [ a ] < B [ b ] ) a ++ ;			    	if ( ( abs ( A [ a ] - B [ b ] ) < result ) ) result = ab 
	    result = abs ( A [ a ] - B [ b ] )		      	  else b ++ ;						    	if ( ( A [ a ] < B [ b ] ) ) a ++ ;			  
	if ( A [ a ] < B [ b ] ) :			      	}							    	else b ++ ;						  
	    a += 1					      	return result ;						      }								  
	else :						      }								      return result ;						  
	    b += 1					      								    }								  
    return result					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES    CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES    CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES	  CHECK_STRING_CAN_OBTAINED_ROTATING_ANOTHER_STRING_2_PLACES
--							      --							    --								  --
def isRotated ( str1 , str2 ) :				      bool isRotated ( string str1 , string str2 ) {		    bool isRotated ( string str1 , string str2 ) {		  success : None
    if ( len ( str1 ) != len ( str2 ) ) :		      	if ( str1 . length ( ) != str2 . length ( ) ) return false    if ( ( str1 . length ( ) != str2 . length ( ) ) ) return fa 
	return False					      	string clock_rot = "" ;					      string clockRot ;						  
    clock_rot = ""					      	string anticlock_rot = "" ;				      string anticlockRot ;					  
    anticlock_rot = ""					      	int len = str2 . length ( ) ;				      int l = str2 . length ( ) ;				  
    l = len ( str2 )					      	anticlock_rot = anticlock_rot + str2 . substr ( len - 2 , 2   anticlockRot = ( anticlockRot + str2 . substr ( l - 2 ) + s 
    anticlock_rot = ( anticlock_rot + str2 [ l - 2 : ] + str2 	clock_rot = clock_rot + str2 . substr ( 2 ) + str2 . substr   clockRot = clockRot + str2 . substr ( 2 ) + str2 . substr ( 
    clock_rot = clock_rot + str2 [ 2 : ] + str2 [ 0 : 2 ]     	return ( str1 . compare ( clock_rot ) == 0 || str1 . compar   return ( str1 == clockRot || str1 == anticlockRot ) ;	  
    return ( str1 == clock_rot or str1 == anticlock_rot )     }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT			      FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT			    FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT				  FIND_POSSIBLE_ROTATE_PAGE_ANGLE_NOT
--							      --							    --								  --
def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) :	      void possibleOrNot ( long long a1 , long long a2 , long long  int findFirstOfDigits ( string s , int start , int end ) {	  script_not_found : None
    dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) )      	long long dis1 = pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 )    int i = 0 ;						  
    dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) )      	long long dis2 = pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 )    for ( ;							  
    if ( dis1 != dis2 ) :				      	if ( dis1 != dis2 ) cout << "No" ;			      i < end ;							  
	print ( "No" )					      	else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2    i ++ ) {							  
    elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 	else cout << "Yes" ;					    	if ( s [ i ] == '-' ) {					  
	print ( "No" )					      }								    	  break ;						  
    else :						      								    	}							  
	print ( "Yes" )					      								      }								  
							      								      if ( i == end ) {						  
							      								    	return - 1 ;						  
							      								      }								  
							      								      else {							  
							      								    	return i ;						  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS	      MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS		    MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS		  MAXIMUM_SUM_SUBSEQUENCE_LEAST_K_DISTANT_ELEMENTS
--							      --							    --								  --
def maxSum ( arr , N , k ) :				      int maxSum ( int arr [ ] , int N , int k ) {		    int maxSum ( int * arr , int N , int k ) {			  success : None
    MS = [ 0 for i in range ( N ) ]			      	int MS [ N ] ;						      int MS [ N ] ;						  
    MS [ N - 1 ] = arr [ N - 1 ]			      	MS [ N - 1 ] = arr [ N - 1 ] ;				      memset ( MS , 0 , sizeof ( MS ) ) ;			  
    for i in range ( N - 2 , - 1 , - 1 ) :		      	for ( int i = N - 2 ;					      MS [ N - 1 ] = arr [ N - 1 ] ;				  
	if ( i + k + 1 >= N ) :				      	i >= 0 ;						      for ( int i = N - 2 ;					  
	    MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] )	      	i -- ) {						      i >= 0 ;							  
	else :						      	  if ( i + k + 1 >= N ) MS [ i ] = max ( arr [ i ] , MS [ i   -- i ) {							  
	    MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , M 	  else MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ 	if ( ( i + k + 1 >= N ) ) MS [ i ] = max ( arr [ i ] , MS 
    return MS [ 0 ]					      	}							    	else MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ 
							      	return MS [ 0 ] ;					      }								  
							      }								      return MS [ 0 ] ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR LONGEST_ALTERNATING_SUB_ARRAY_STARTING_EVERY_INDEX_BINARY_ARR
--							      --							    --								  --
def alternateSubarray ( arr , n ) :			      void alternateSubarray ( bool arr [ ] , int n ) {		    int alternateSubarray ( bool * arr , int n ) {		  script_not_found : None
    len = [ ]						      	int len [ n ] ;						      vector < int > len ;					  
    for i in range ( n + 1 ) :				      	len [ n - 1 ] = 1 ;					      for ( int i = 0 ;						  
	len.append ( 0 )				      	for ( int i = n - 2 ;					      i < n + 1 ;						  
    len [ n - 1 ] = 1					      	i >= 0 ;						      i ++ ) len . push_back ( 0 ) ;				  
    for i in range ( n - 2 , - 1 , - 1 ) :		      	-- i ) {						      len [ n - 1 ] = 1 ;					  
	if ( arr [ i ] ^ arr [ i + 1 ] == True ) :	      	  if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i   for ( int i = n - 2 ;					  
	    len [ i ] = len [ i + 1 ] + 1		      	  else len [ i ] = 1 ;					      i >= 0 ;							  
	else :						      	}							      i -- ) {							  
	    len [ i ] = 1				      	for ( int i = 0 ;					    	if ( ( arr [ i ] ^ arr [ i + 1 ] == true ) == true ) len  
    for i in range ( n ) :				      	i < n ;							    	else len [ i ] = 1 ;					  
	print ( len [ i ] , "" , end = "" )		      	++ i ) cout << len [ i ] << " " ;			      }								  
							      }								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) cout << len [ i ] << " " << endl ;			  
							      								      return n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED		      MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED		    MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED		  MOVE_VE_ELEMENTS_END_ORDER_EXTRA_SPACE_ALLOWED
--							      --							    --								  --
def segregateElements ( arr , n ) :			      void segregateElements ( int arr [ ] , int n ) {		    int segregateElements ( int * arr , int n ) {		  script_not_found : None
    temp = [ 0 for k in range ( n ) ]			      	int temp [ n ] ;					      int temp [ n ] ;						  
    j = 0						      	int j = 0 ;						      for ( int k = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      k < n ;							  
	if ( arr [ i ] >= 0 ) :				      	i < n ;							      k ++ ) {							  
	    temp [ j ] = arr [ i ]			      	i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ;    	if ( ( arr [ k ] >= 0 ) && ( arr [ k ] <= n ) ) {	  
	    j += 1					      	if ( j == n || j == 0 ) return ;			    	  temp [ j ] = arr [ i ] ;				  
    if ( j == n or j == 0 ) :				      	for ( int i = 0 ;					    	  j ++ ;						  
	return						      	i < n ;							    	}							  
    for i in range ( n ) :				      	i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ;	      }								  
	if ( arr [ i ] < 0 ) :				      	memcpy ( arr , temp , sizeof ( temp ) ) ;		      if ( ( j == n || j == 0 ) ) return 0 ;			  
	    temp [ j ] = arr [ i ]			      }								      for ( int i = 0 ;						  
	    j += 1					      								      i < n ;							  
    for k in range ( n ) :				      								      i ++ ) {							  
	arr [ k ] = temp [ k ]				      								    	if ( ( arr [ i ] < 0 ) && ( arr [ i ] <= n ) ) {	  
							      								    	  temp [ j ] = arr [ i ] ;				  
							      								    	  j ++ ;						  
							      								    	}							  
							      								      }								  
							      								      for ( int k = 0 ;						  
							      								      k < n ;							  
							      								      k ++ ) arr [ k ] = temp [ k ] ;				  
							      								      return n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP			      PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP			    PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP				  PRINT_TRIPLETS_SORTED_ARRAY_FORM_AP
--							      --							    --								  --
def printAllAPTriplets ( arr , n ) :			      void printAllAPTriplets ( int arr [ ] , int n ) {		    string printAllAPTriplets ( int * arr , int n ) {		  script_not_found : None
    s = [ ]						      	unordered_set < int > s ;				      string result ;						  
    for i in range ( 0 , n - 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n - 1 ;						      i <= n - 1 ;						  
	    diff = arr [ j ] - arr [ i ]		      	i ++ ) {						      i ++ ) {							  
	    if ( ( arr [ i ] - diff ) in arr ) :	      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
		print ( "{} {} {}".format ( ( arr [ i ] - dif 	  j < n ;						    	j < n ;							  
    s.append ( arr [ i ] )				      	  j ++ ) {						    	j ++ ) {						  
							      	    int diff = arr [ j ] - arr [ i ] ;			    	  int diff = arr [ j ] - arr [ i ] ;			  
							      	    if ( s . find ( arr [ i ] - diff ) != s . end ( ) ) cou 	  if ( ( ( arr [ i ] - diff ) < 0 ) ) result += "{} {} {} 
							      	  }							    	}							  
							      	  s . insert ( arr [ i ] ) ;				      }								  
							      	}							      result += arr [ i ] ;					  
							      }								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1	      FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1	    FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1	  FIND_PAIRS_IN_ARRAY_WHOSE_SUMS_ALREADY_EXIST_IN_ARRAY_1
--							      --							    --								  --
def findPair ( arr , n ) :				      void findPair ( int arr [ ] , int n ) {			    int findPair ( int * arr , int n ) {			  script_not_found : None
    s = { i : 1 for i in arr }				      	unordered_set < int > s ;				      map < int , int > s = {					  
    found = False					      	for ( int i = 0 ;					    	i , 1 }							  
    for i in range ( n ) :				      	i < n ;							    	;							  
	for j in range ( i + 1 , n ) :			      	i ++ ) s . insert ( arr [ i ] ) ;			    	bool found = false ;					  
	    if arr [ i ] + arr [ j ] in s.keys ( ) :	      	bool found = false ;					    	for ( int i = 0 ;					  
		print ( arr [ i ] , arr [ j ] )		      	for ( int i = 0 ;					    	i < n ;							  
		found = True				      	i < n ;							    	i ++ ) {						  
    if found == False :					      	i ++ ) {						    	  for ( int j = i + 1 ;					  
	print ( "Not exist" )				      	  for ( int j = i + 1 ;					    	  j < n ;						  
							      	  j < n ;						    	  j ++ ) {						  
							      	  j ++ ) {						    	    if ( s . count ( arr [ i ] + arr [ j ] ) ) {	  
							      	    if ( s . find ( arr [ i ] + arr [ j ] ) != s . end ( )  	      cout << arr [ i ] << " " << arr [ j ] << endl ;	  
							      	      cout << arr [ i ] << " " << arr [ j ] << endl ;	    	      found = true ;					  
							      	      found = true ;					    	    }							  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							    	if ( found == false ) cout << "Not exist" << endl ;	  
							      	if ( found == false ) cout << "Not exist" << endl ;	    	return 0 ;						  
							      }								    	return arr * arr ;					  
							      								    	return arr * arr ;					  
-							      -								    	return arr * arr * arr * arr * arr * arr * arr * arr * ar -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A MINIMUM_NUMBER_POINTS_REMOVED_GET_REMAINING_POINTS_ONE_SIDE_A
--							      --							    --								  --
def findmin ( p , n ) :					      int findmin ( Point p [ ] , int n ) {			    int findmin ( int * p , int n ) {				  script_not_found : None
    a , b , c , d = 0 , 0 , 0 , 0			      	int a = 0 , b = 0 , c = 0 , d = 0 ;			      int a = 0 , b = 0 , c = 0 , d = 0 ;			  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( p [ i ] [ 0 ] <= 0 ) :			      	i < n ;							      i < n ;							  
	    a += 1					      	i ++ ) {						      i ++ ) {							  
	elif ( p [ i ] [ 0 ] >= 0 ) :			      	  if ( p [ i ] . x <= 0 ) a ++ ;			    	if ( ( p [ i ] [ 0 ] <= 0 ) && ( p [ i ] [ 0 ] >= 0 ) ) a 
	    b += 1					      	  else if ( p [ i ] . x >= 0 ) b ++ ;			    	else if ( ( p [ i ] [ 0 ] >= 0 ) && ( p [ i ] [ 1 ] <= 0  
	if ( p [ i ] [ 1 ] >= 0 ) :			      	  if ( p [ i ] . y >= 0 ) c ++ ;			    	if ( ( p [ i ] [ 1 ] >= 0 ) && ( p [ i ] [ 2 ] <= 0 ) ) c 
	    c += 1					      	  else if ( p [ i ] . y <= 0 ) d ++ ;			    	else if ( ( p [ i ] [ 1 ] <= 0 ) && ( p [ i ] [ 2 ] >= 0  
	elif ( p [ i ] [ 1 ] <= 0 ) :			      	}							      }								  
	    d += 1					      	return min ( {						      return min ( & a , & b , & c , & d ) ;			  
    return min ( [ a , b , c , d ] )			      	  a , b , c , d }					    }								  
							      	  ) ;							    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE	      GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE	    GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE	  GROUP_OCCURRENCES_CHARACTERS_ACCORDING_FIRST_APPEARANCE
--							      --							    --								  --
def printGrouped ( string ) :				      void printGrouped ( string str ) {			    void printGrouped ( string string ) {			  script_not_found : None
    n = len ( string )					      	int n = str . length ( ) ;				      int n = string . length ( ) ;				  
    count = [ 0 ] * MAX_CHAR				      	int count [ MAX_CHAR ] = {				      vector < int > count ( MAX_CHAR , 0 ) ;			  
    for i in range ( n ) :				      	  0 }							      for ( int i = 0 ;						  
	count [ ord ( string [ i ] ) - ord ( "a" ) ] += 1     	  ;							      i < n ;							  
    for i in range ( n ) :				      	  for ( int i = 0 ;					      i ++ ) count [ string [ i ] - "a" ] ++ ;			  
	while count [ ord ( string [ i ] ) - ord ( "a" ) ] :  	  i < n ;						      for ( int i = 0 ;						  
	    print ( string [ i ] , end = "" )		      	  i ++ ) count [ str [ i ] - 'a' ] ++ ;			      i < n ;							  
	    count [ ord ( string [ i ] ) - ord ( "a" ) ] -= 1 	  for ( int i = 0 ;					      i ++ ) {							  
	count [ ord ( string [ i ] ) - ord ( "a" ) ] = 0      	  i < n ;						    	while ( count [ string [ i ] - "a" ] ) {		  
							      	  i ++ ) {						    	  cout << string [ i ] << " " ;				  
							      	    while ( count [ str [ i ] - 'a' ] -- ) cout << str [ i  	  count [ string [ i ] - "a" ] -- ;			  
							      	    count [ str [ i ] - 'a' ] = 0 ;			    	}							  
							      	  }							    	count [ string [ i ] - "a" ] = 0 ;			  
							      	}							      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_DECIMAL_FRACTION_BINARY_NUMBER			      CONVERT_DECIMAL_FRACTION_BINARY_NUMBER			    CONVERT_DECIMAL_FRACTION_BINARY_NUMBER			  CONVERT_DECIMAL_FRACTION_BINARY_NUMBER
--							      --							    --								  --
def decimalToBinary ( num , k_prec ) :			      string decimalToBinary ( double num , int k_prec ) {	    string decimalToBinary ( string num , int k_prec ) {	  error : CONVERT_DECIMAL_FRACTION_BINARY_NUMBER.cpp
    binary = ""						      	string binary = "" ;					      string binary ;						  : In function ‘std::__cxx11::string f_filled(std::
    Integral = int ( num )				      	int Integral = num ;					      long Integral = atol ( num . c_str ( ) ) ;		  __cxx11::string, int)’: CONVERT_DECIMAL_FRACTION_B
    fractional = num - Integral				      	double fractional = num - Integral ;			      long fractional = num - Integral ;			  INARY_NUMBER.cpp:43:25: error: no match for ‘opera
    while ( Integral ) :				      	while ( Integral ) {					      while ( ( Integral ) ) {					  tor-’ (operand types are ‘std::__cxx11::string’ {a
	rem = Integral % 2				      	  int rem = Integral % 2 ;				    	long rem = Integral % 2 ;				  ka ‘std::__cxx11::basic_string<char>’} and ‘long i
	binary += str ( rem )				      	  binary . push_back ( rem + '0' ) ;			    	binary += to_string ( rem ) ;				  nt’)	  long fractional = num - Integral ;
	Integral //= 2					      	  Integral /= 2 ;					    	Integral /= 2 ;						  		~~~~^~~~~~~~~~ In file included from
    binary = binary [ : : - 1 ]				      	}							      }								   /usr/include/c++/8/bits/stl_algobase.h:67,
    binary += '.'					      	reverse ( binary . begin ( ) , binary . end ( ) ) ;	      binary = binary . substr ( 0 , binary . length ( ) - 1 ) ;  	     from /usr/include/c++/8/bits/char_trait
    while ( k_prec ) :					      	binary . push_back ( '.' ) ;				      binary += '.' ;						  s.h:39,		   from /usr/include/c++/8/i
	fractional *= 2					      	while ( k_prec -- ) {					      while ( ( k_prec ) ) {					  os:40,		  from /usr/include/c++/8/os
	fract_bit = int ( fractional )			      	  fractional *= 2 ;					    	fractional *= 2 ;					  tream:38,		     from /usr/include/c++/8
	if ( fract_bit == 1 ) :				      	  int fract_bit = fractional ;				    	int fract_bit = atoi ( fractional . c_str ( ) ) ;	  /iostream:39,			 from CONVERT_DECIMA
	    fractional -= fract_bit			      	  if ( fract_bit == 1 ) {				    	if ( ( fract_bit == 1 ) ) {				  L_FRACTION_BINARY_NUMBER.cpp:8: /usr/include/c++/8
	    binary += '1'				      	    fractional -= fract_bit ;				    	  fractional -= fract_bit ;				  /bits/stl_iterator.h:392:5: note: candidate: ‘temp
	else :						      	    binary . push_back ( 1 + '0' ) ;			    	  binary += "1" ;					  late<class _IteratorL, class _IteratorR> decltype
	    binary += '0'				      	  }							    	}							  ((__y.base() - __x.base())) std::operator-(const s
	k_prec -= 1					      	  else binary . push_back ( 0 + '0' ) ;			    	else {							  td::reverse_iterator<_Iterator>&, const std::rever
    return binary					      	}							    	  binary += "0" ;					  se_iterator<_IteratorR>&)’	  operator-(const re
							      	return binary ;						    	}							  verse_iterator<_IteratorL>& __x,	^~~~~~~~ /us
							      }								    	k_prec -- ;						  r/include/c++/8/bits/stl_iterator.h:392:5: note:
							      								      }								   template argument deduction/substitution failed:
							      								      return binary ;						  CONVERT_DECIMAL_FRACTION_BINARY_NUMBER.cpp:43:27:
							      								    }								  note:	  ‘std::__cxx11::string’ {aka ‘std::__cxx11:
							      								    								  :basic_string<char>’} is not derived from ‘const s
							      								    								  td::reverse_iterator<_Iterator>’    long fractiona
							      								    								  l = num - Integral ;				  ^~
							      								    								  ~~~~~~ In file included from /usr/include/c++/8/bi
							      								    								  ts/stl_algobase.h:67,			 from /usr/i
							      								    								  nclude/c++/8/bits/char_traits.h:39,
							      								    								     from /usr/include/c++/8/ios:40,
							      								    								    from /usr/include/c++/8/ostream:38,
							      								    								       from /usr/include/c++/8/iostream:39,
							      								    								  	   from CONVERT_DECIMAL_FRACTION_BINARY_NUMB
							      								    								  ER.cpp:8: /usr/include/c++/8/bits/stl_iterator.h:1
							      								    								  188:5: note: candidate: ‘template<class _IteratorL
							      								    								  , class _IteratorR> decltype ((__x.base() - __y.ba
							      								    								  se())) std::operator-(const std::move_iterator<_It
							      								    								  eratorL>&, const std::move_iterator<_IteratorR>&)’
							      								    								  	operator-(const move_iterator<_IteratorL>& _
							      								    								  _x,	   ^~~~~~~~ /usr/include/c++/8/bits/stl_iter
							      								    								  ator.h:1188:5: note:	 template argument deduction
							      								    								  /substitution failed: CONVERT_DECIMAL_FRACTION_BIN
							      								    								  ARY_NUMBER.cpp:43:27: note:	‘std::__cxx11::strin
							      								    								  g’ {aka ‘std::__cxx11::basic_string<char>’} is not
							      								    								   derived from ‘const std::move_iterator<_IteratorL
							      								    								  >’	long fractional = num - Integral ;
							      								    								  		    ^~~~~~~~ In file included from /
							      								    								  usr/include/c++/8/vector:65,			from
							      								    								   CONVERT_DECIMAL_FRACTION_BINARY_NUMBER.cpp:11: /u
							      								    								  sr/include/c++/8/bits/stl_bvector.h:210:3: note: c
							      								    								  andidate: ‘std::ptrdiff_t std::operator-(const std
							      								    								  ::_Bit_iterator_base&, const std::_Bit_iterator_ba
							      								    								  se&)’	   operator-(const _Bit_iterator_base& __x,
							      								    								  const _Bit_iterator_base& __y)    ^~~~~~~~ /usr/in
							      								    								  clude/c++/8/bits/stl_bvector.h:210:3: note:	no k
							      								    								  nown conversion for argument 1 from ‘std::__cxx11:
							      								    								  :string’ {aka ‘std::__cxx11::basic_string<char>’}
							      								    								  to ‘const std::_Bit_iterator_base&’ In file includ
							      								    								  ed from /usr/include/c++/8/ccomplex:39,
							      								    								  	 from /usr/include/c++/8/x86_64-redhat-linux
							      								    								  /bits/stdc++.h:52,		      from CONVERT_D
							      								    								  ECIMAL_FRACTION_BINARY_NUMBER.cpp:14: /usr/include
							      								    								  /c++/8/complex:356:5: note: candidate: ‘template<c
							      								    								  lass _Tp> std::complex<_Tp> std::operator-(const s
							      								    								  td::complex<_Tp>&, const std::complex<_Tp>&)’
							      								    								   operator-(const complex<_Tp>& __x, const complex<
							      								    								  _Tp>& __y)	  ^~~~~~~~ /usr/include/c++/8/comple
							      								    								  x:356:5: note:   template argument deduction/subst
							      								    								  itution failed: CONVERT_DECIMAL_FRACTION_BINARY_NU
							      								    								  MBER.cpp:43:27: note:	  ‘std::__cxx11::string’ {ak
							      								    								  a ‘std::__cxx11::basic_string<char>’} is not deriv
							      								    								  ed from ‘const std::complex<_Tp>’    long fraction
							      								    								  al = num - Integral ;				   ^
							      								    								  ~~~~~~~ In file included from /usr/include/c++/8/c
							      								    								  complex:39,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:52,
							      								    								  	  from CONVERT_DECIMAL_FRACTION_BINARY_NUMBE
							      								    								  R.cpp:14: /usr/include/c++/8/complex:365:5: note:
							      								    								  candidate: ‘template<class _Tp> std::complex<_Tp>
							      								    								  std::operator-(const std::complex<_Tp>&, const _Tp
							      								    								  &)’	   operator-(const complex<_Tp>& __x, const
							      								    								  _Tp& __y)	 ^~~~~~~~ /usr/include/c++/8/complex
							      								    								  :365:5: note:	  template argument deduction/substi
							      								    								  tution failed: CONVERT_DECIMAL_FRACTION_BINARY_NUM
							      								    								  BER.cpp:43:27: note:	 ‘std::__cxx11::string’ {aka
							      								    								   ‘std::__cxx11::basic_string<char>’} is not derive
							      								    								  d from ‘const std::complex<_Tp>’    long fractiona
							      								    								  l = num - Integral ;				  ^~
							      								    								  ~~~~~~ In file included from /usr/include/c++/8/cc
							      								    								  omplex:39,		      from /usr/include/c++/
							      								    								  8/x86_64-redhat-linux/bits/stdc++.h:52,
							      								    								  	 from CONVERT_DECIMAL_FRACTION_BINARY_NUMBER
							      								    								  .cpp:14: /usr/include/c++/8/complex:374:5: note: c
							      								    								  andidate: ‘template<class _Tp> std::complex<_Tp> s
							      								    								  td::operator-(const _Tp&, const std::complex<_Tp>&
							      								    								  )’	  operator-(const _Tp& __x, const complex<_T
							      								    								  p>& __y)	^~~~~~~~ /usr/include/c++/8/complex:
							      								    								  374:5: note:	 template argument deduction/substit
							      								    								  ution failed: CONVERT_DECIMAL_FRACTION_BINARY_NUMB
							      								    								  ER.cpp:43:27: note:	mismatched types ‘const std:
							      								    								  :complex<_Tp>’ and ‘long int’	   long fractional =
							      								    								   num - Integral ;			       ^~~~~
							      								    								  ~~~ In file included from /usr/include/c++/8/ccomp
							      								    								  lex:39,		   from /usr/include/c++/8/x
							      								    								  86_64-redhat-linux/bits/stdc++.h:52,
							      								    								      from CONVERT_DECIMAL_FRACTION_BINARY_NUMBER.cp
							      								    								  p:14: /usr/include/c++/8/complex:451:5: note: cand
							      								    								  idate: ‘template<class _Tp> std::complex<_Tp> std:
							      								    								  :operator-(const std::complex<_Tp>&)’	     operato
							      								    								  r-(const complex<_Tp>& __x)	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/complex:451:5: note:   template argumen
							      								    								  t deduction/substitution failed: CONVERT_DECIMAL_F
							      								    								  RACTION_BINARY_NUMBER.cpp:43:27: note:   ‘std::__c
							      								    								  xx11::string’ {aka ‘std::__cxx11::basic_string<cha
							      								    								  r>’} is not derived from ‘const std::complex<_Tp>’
							      								    								      long fractional = num - Integral ;
							      								    								  		  ^~~~~~~~ In file included from /us
							      								    								  r/include/c++/8/deque:64,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :68,			from CONVERT_DECIMAL_FRACTIO
							      								    								  N_BINARY_NUMBER.cpp:14: /usr/include/c++/8/bits/st
							      								    								  l_deque.h:352:5: note: candidate: ‘template<class
							      								    								  _Tp, class _Ref, class _Ptr> typename std::_Deque_
							      								    								  iterator<_Tp, _Ref, _Ptr>::difference_type std::op
							      								    								  erator-(const std::_Deque_iterator<_Tp, _Ref, _Ptr
							      								    								  >&, const std::_Deque_iterator<_Tp, _Ref, _Ptr>&)’
							      								    								  	operator-(const _Deque_iterator<_Tp, _Ref, _
							      								    								  Ptr>& __x,	  ^~~~~~~~ /usr/include/c++/8/bits/s
							      								    								  tl_deque.h:352:5: note:   template argument deduct
							      								    								  ion/substitution failed: CONVERT_DECIMAL_FRACTION_
							      								    								  BINARY_NUMBER.cpp:43:27: note:   ‘std::__cxx11::st
							      								    								  ring’ {aka ‘std::__cxx11::basic_string<char>’} is
							      								    								  not derived from ‘const std::_Deque_iterator<_Tp,
							      								    								  _Ref, _Ptr>’	  long fractional = num - Integral ;
							      								    								  			      ^~~~~~~~ In file inclu
							      								    								  ded from /usr/include/c++/8/deque:64,
							      								    								       from /usr/include/c++/8/x86_64-redhat-linux/b
							      								    								  its/stdc++.h:68,		    from CONVERT_DEC
							      								    								  IMAL_FRACTION_BINARY_NUMBER.cpp:14: /usr/include/c
							      								    								  ++/8/bits/stl_deque.h:364:5: note: candidate: ‘tem
							      								    								  plate<class _Tp, class _RefL, class _PtrL, class _
							      								    								  RefR, class _PtrR> typename std::_Deque_iterator<_
							      								    								  Tp, _Ref, _Ptr>::difference_type std::operator-(co
							      								    								  nst std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const
							      								    								  std::_Deque_iterator<_Tp, _RefR, _PtrR>&)’	  op
							      								    								  erator-(const _Deque_iterator<_Tp, _RefL, _PtrL>&
							      								    								  __x,	    ^~~~~~~~ /usr/include/c++/8/bits/stl_deq
							      								    								  ue.h:364:5: note:   template argument deduction/su
							      								    								  bstitution failed: CONVERT_DECIMAL_FRACTION_BINARY
							      								    								  _NUMBER.cpp:43:27: note:   ‘std::__cxx11::string’
							      								    								  {aka ‘std::__cxx11::basic_string<char>’} is not de
							      								    								  rived from ‘const std::_Deque_iterator<_Tp, _Ref,
							      								    								  _Ptr>’    long fractional = num - Integral ;
							      								    								  			^~~~~~~~ In file included fr
							      								    								  om /usr/include/c++/8/valarray:592,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:95,		  from CONVERT_DECIM
							      								    								  AL_FRACTION_BINARY_NUMBER.cpp:14: /usr/include/c++
							      								    								  /8/bits/valarray_after.h:403:5: note: candidate: ‘
							      								    								  template<class _Dom1, class _Dom2> std::_Expr<std:
							      								    								  :_BinClos<std::__minus, std::_Expr, std::_Expr, _D
							      								    								  om1, _Dom2>, typename std::__fun<std::__minus, typ
							      								    								  ename _Dom1::value_type>::result_type> std::operat
							      								    								  or-(const std::_Expr<_Dom1, typename _Dom1::value_
							      								    								  type>&, const std::_Expr<_Dom2, typename _Dom2::va
							      								    								  lue_type>&)’	    _DEFINE_EXPR_BINARY_OPERATOR(-,
							      								    								  __minus)	^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/in
							      								    								  clude/c++/8/bits/valarray_after.h:403:5: note:   t
							      								    								  emplate argument deduction/substitution failed: CO
							      								    								  NVERT_DECIMAL_FRACTION_BINARY_NUMBER.cpp:43:27: no
							      								    								  te:	‘std::__cxx11::string’ {aka ‘std::__cxx11::b
							      								    								  asic_string<char>’} is not derived from ‘const std
							      								    								  ::_Expr<_Dom1, typename _Dom1::value_type>’	 lon
							      								    								  g fractional = num - Integral ;
							      								    								  	   ^~~~~~~~ In file included from /usr/inclu
							      								    								  de/c++/8/valarray:592,		  from /usr/
							      								    								  include/c++/8/x86_64-redhat-linux/bits/stdc++.h:95
							      								    								  ,		     from CONVERT_DECIMAL_FRACTION_B
							      								    								  INARY_NUMBER.cpp:14: /usr/include/c++/8/bits/valar
							      								    								  ray_after.h:403:5: note: candidate: ‘template<clas
							      								    								  s _Dom> std::_Expr<std::_BinClos<std::__minus, std
							      								    								  ::_Expr, std::_Constant, _Dom, typename _Dom::valu
							      								    								  e_type>, typename std::__fun<std::__minus, typenam
							      								    								  e _Dom1::value_type>::result_type> std::operator-(
							      								    								  const std::_Expr<_Dom1, typename _Dom1::value_type
							      								    								  >&, const typename _Dom::value_type&)’      _DEFIN
							      								    								  E_EXPR_BINARY_OPERATOR(-, __minus)	  ^~~~~~~~~~
							      								    								  ~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/bits/valarra
							      								    								  y_after.h:403:5: note:   template argument deducti
							      								    								  on/substitution failed: CONVERT_DECIMAL_FRACTION_B
							      								    								  INARY_NUMBER.cpp:43:27: note:	  ‘std::__cxx11::str
							      								    								  ing’ {aka ‘std::__cxx11::basic_string<char>’} is n
							      								    								  ot derived from ‘const std::_Expr<_Dom1, typename
							      								    								  _Dom1::value_type>’	 long fractional = num - Int
							      								    								  egral ;			     ^~~~~~~~ In fil
							      								    								  e included from /usr/include/c++/8/valarray:592,
							      								    								  		  from /usr/include/c++/8/x86_64-red
							      								    								  hat-linux/bits/stdc++.h:95,		       from
							      								    								  CONVERT_DECIMAL_FRACTION_BINARY_NUMBER.cpp:14: /us
							      								    								  r/include/c++/8/bits/valarray_after.h:403:5: note:
							      								    								   candidate: ‘template<class _Dom> std::_Expr<std::
							      								    								  _BinClos<std::__minus, std::_Constant, std::_Expr,
							      								    								   typename _Dom::value_type, _Dom>, typename std::_
							      								    								  _fun<std::__minus, typename _Dom1::value_type>::re
							      								    								  sult_type> std::operator-(const typename _Dom::val
							      								    								  ue_type&, const std::_Expr<_Dom1, typename _Dom1::
							      								    								  value_type>&)’      _DEFINE_EXPR_BINARY_OPERATOR(-
							      								    								  , __minus)	  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/
							      								    								  include/c++/8/bits/valarray_after.h:403:5: note:
							      								    								   template argument deduction/substitution failed:
							      								    								  CONVERT_DECIMAL_FRACTION_BINARY_NUMBER.cpp:43:27:
							      								    								  note:	  mismatched types ‘const std::_Expr<_Dom1,
							      								    								  typename _Dom1::value_type>’ and ‘long int’	 lon
							      								    								  g fractional = num - Integral ;
							      								    								  	   ^~~~~~~~ In file included from /usr/inclu
							      								    								  de/c++/8/valarray:592,		  from /usr/
							      								    								  include/c++/8/x86_64-redhat-linux/bits/stdc++.h:95
							      								    								  ,		     from CONVERT_DECIMAL_FRACTION_B
							      								    								  INARY_NUMBER.cpp:14: /usr/include/c++/8/bits/valar
							      								    								  ray_after.h:403:5: note: candidate: ‘template<clas
							      								    								  s _Dom> std::_Expr<std::_BinClos<std::__minus, std
							      								    								  ::_Expr, std::_ValArray, _Dom, typename _Dom::valu
							      								    								  e_type>, typename std::__fun<std::__minus, typenam
							      								    								  e _Dom1::value_type>::result_type> std::operator-(
							      								    								  const std::_Expr<_Dom1, typename _Dom1::value_type
							      								    								  >&, const std::valarray<typename _Dom::value_type>
							      								    								  &)’	   _DEFINE_EXPR_BINARY_OPERATOR(-, __minus)
							      								    								       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++
							      								    								  /8/bits/valarray_after.h:403:5: note:	  template a
							      								    								  rgument deduction/substitution failed: CONVERT_DEC
							      								    								  IMAL_FRACTION_BINARY_NUMBER.cpp:43:27: note:	 ‘st
							      								    								  d::__cxx11::string’ {aka ‘std::__cxx11::basic_stri
							      								    								  ng<char>’} is not derived from ‘const std::_Expr<_
							      								    								  Dom1, typename _Dom1::value_type>’	long fractio
							      								    								  nal = num - Integral ;
							      								    								  ^~~~~~~~ In file included from /usr/include/c++/8/
							      								    								  valarray:592,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  	    from CONVERT_DECIMAL_FRACTION_BINARY_NUM
							      								    								  BER.cpp:14: /usr/include/c++/8/bits/valarray_after
							      								    								  .h:403:5: note: candidate: ‘template<class _Dom> s
							      								    								  td::_Expr<std::_BinClos<std::__minus, std::_ValArr
							      								    								  ay, std::_Expr, typename _Dom::value_type, _Dom>,
							      								    								  typename std::__fun<std::__minus, typename _Dom1::
							      								    								  value_type>::result_type> std::operator-(const std
							      								    								  ::valarray<typename _Dom::value_type>&, const std:
							      								    								  :_Expr<_Dom1, typename _Dom1::value_type>&)’
							      								    								  _DEFINE_EXPR_BINARY_OPERATOR(-, __minus)	^~~~
							      								    								  ~~~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/bits/v
							      								    								  alarray_after.h:403:5: note:	 template argument d
							      								    								  eduction/substitution failed: CONVERT_DECIMAL_FRAC
							      								    								  TION_BINARY_NUMBER.cpp:43:27: note:	mismatched t
							      								    								  ypes ‘const std::_Expr<_Dom1, typename _Dom1::valu
							      								    								  e_type>’ and ‘long int’    long fractional = num -
							      								    								   Integral ;				 ^~~~~~~~ In
							      								    								   file included from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:95,		      from C
							      								    								  ONVERT_DECIMAL_FRACTION_BINARY_NUMBER.cpp:14: /usr
							      								    								  /include/c++/8/valarray:1173:1: note: candidate: ‘
							      								    								  template<class _Tp> std::_Expr<std::_BinClos<std::
							      								    								  __minus, std::_ValArray, std::_ValArray, _Tp, _Tp>
							      								    								  , typename std::__fun<std::__minus, _Tp>::result_t
							      								    								  ype> std::operator-(const std::valarray<_Tp>&, con
							      								    								  st std::valarray<_Tp>&)’  _DEFINE_BINARY_OPERATOR(
							      								    								  -, __minus)  ^~~~~~~~~~~~~~~~~~~~~~~ /usr/include/
							      								    								  c++/8/valarray:1173:1: note:	 template argument d
							      								    								  eduction/substitution failed: CONVERT_DECIMAL_FRAC
							      								    								  TION_BINARY_NUMBER.cpp:43:27: note:	‘std::__cxx1
							      								    								  1::string’ {aka ‘std::__cxx11::basic_string<char>’
							      								    								  } is not derived from ‘const std::valarray<_Tp>’
							      								    								    long fractional = num - Integral ;
							      								    								  		^~~~~~~~ In file included from /usr/
							      								    								  include/c++/8/x86_64-redhat-linux/bits/stdc++.h:95
							      								    								  ,		     from CONVERT_DECIMAL_FRACTION_B
							      								    								  INARY_NUMBER.cpp:14: /usr/include/c++/8/valarray:1
							      								    								  173:1: note: candidate: ‘template<class _Tp> std::
							      								    								  _Expr<std::_BinClos<std::__minus, std::_ValArray,
							      								    								  std::_Constant, _Tp, _Tp>, typename std::__fun<std
							      								    								  ::__minus, _Tp>::result_type> std::operator-(const
							      								    								   std::valarray<_Tp>&, const _Tp&)’  _DEFINE_BINARY
							      								    								  _OPERATOR(-, __minus)	 ^~~~~~~~~~~~~~~~~~~~~~~ /us
							      								    								  r/include/c++/8/valarray:1173:1: note:   template
							      								    								  argument deduction/substitution failed: CONVERT_DE
							      								    								  CIMAL_FRACTION_BINARY_NUMBER.cpp:43:27: note:	  ‘s
							      								    								  td::__cxx11::string’ {aka ‘std::__cxx11::basic_str
							      								    								  ing<char>’} is not derived from ‘const std::valarr
							      								    								  ay<_Tp>’    long fractional = num - Integral ;
							      								    								  			  ^~~~~~~~ In file included
							      								    								  from /usr/include/c++/8/x86_64-redhat-linux/bits/s
							      								    								  tdc++.h:95,		       from CONVERT_DECIMAL_
							      								    								  FRACTION_BINARY_NUMBER.cpp:14: /usr/include/c++/8/
							      								    								  valarray:1173:1: note: candidate: ‘template<class
							      								    								  _Tp> std::_Expr<std::_BinClos<std::__minus, std::_
							      								    								  Constant, std::_ValArray, _Tp, _Tp>, typename std:
							      								    								  :__fun<std::__minus, _Tp>::result_type> std::opera
							      								    								  tor-(const _Tp&, const std::valarray<_Tp>&)’	_DEF
							      								    								  INE_BINARY_OPERATOR(-, __minus)  ^~~~~~~~~~~~~~~~~
							      								    								  ~~~~~~ /usr/include/c++/8/valarray:1173:1: note:
							      								    								   template argument deduction/substitution failed:
							      								    								  CONVERT_DECIMAL_FRACTION_BINARY_NUMBER.cpp:43:27:
							      								    								  note:	  mismatched types ‘const std::valarray<_Tp>
							      								    								  ’ and ‘long int’    long fractional = num - Integr
							      								    								  al ;				  ^~~~~~~~ In file i
							      								    								  ncluded from /usr/include/c++/8/bits/stl_algobase.
							      								    								  h:67,			 from /usr/include/c++/8/bit
							      								    								  s/char_traits.h:39,		       from /usr/inc
							      								    								  lude/c++/8/ios:40,		      from /usr/incl
							      								    								  ude/c++/8/ostream:38,			 from /usr/i
							      								    								  nclude/c++/8/iostream:39,		     from CO
							      								    								  NVERT_DECIMAL_FRACTION_BINARY_NUMBER.cpp:8: /usr/i
							      								    								  nclude/c++/8/bits/stl_iterator.h:954:5: note: cand
							      								    								  idate: ‘template<class _IteratorL, class _Iterator
							      								    								  R, class _Container> decltype ((__lhs.base() - __r
							      								    								  hs.base())) __gnu_cxx::operator-(const __gnu_cxx::
							      								    								  __normal_iterator<_IteratorL, _Container>&, const
							      								    								  __gnu_cxx::__normal_iterator<_IteratorR, _Containe
							      								    								  r>&)’	     operator-(const __normal_iterator<_Iter
							      								    								  atorL, _Container>& __lhs,	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/stl_iterator.h:954:5: note:   templ
							      								    								  ate argument deduction/substitution failed: CONVER
							      								    								  T_DECIMAL_FRACTION_BINARY_NUMBER.cpp:43:27: note:
							      								    								    ‘std::__cxx11::string’ {aka ‘std::__cxx11::basic
							      								    								  _string<char>’} is not derived from ‘const __gnu_c
							      								    								  xx::__normal_iterator<_IteratorL, _Container>’
							      								    								  long fractional = num - Integral ;
							      								    								  	      ^~~~~~~~ In file included from /usr/in
							      								    								  clude/c++/8/bits/stl_algobase.h:67,
							      								    								     from /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  		   from /usr/include/c++/8/ios:40,
							      								    								  		  from /usr/include/c++/8/ostream:38
							      								    								  ,		     from /usr/include/c++/8/iostrea
							      								    								  m:39,			 from CONVERT_DECIMAL_FRACTI
							      								    								  ON_BINARY_NUMBER.cpp:8: /usr/include/c++/8/bits/st
							      								    								  l_iterator.h:966:5: note: candidate: ‘template<cla
							      								    								  ss _Iterator, class _Container> typename __gnu_cxx
							      								    								  ::__normal_iterator<_Iterator, _Container>::differ
							      								    								  ence_type __gnu_cxx::operator-(const __gnu_cxx::__
							      								    								  normal_iterator<_Iterator, _Container>&, const __g
							      								    								  nu_cxx::__normal_iterator<_Iterator, _Container>&)
							      								    								  ’	 operator-(const __normal_iterator<_Iterator
							      								    								  , _Container>& __lhs,	     ^~~~~~~~ /usr/include/c
							      								    								  ++/8/bits/stl_iterator.h:966:5: note:	  template a
							      								    								  rgument deduction/substitution failed: CONVERT_DEC
							      								    								  IMAL_FRACTION_BINARY_NUMBER.cpp:43:27: note:	 ‘st
							      								    								  d::__cxx11::string’ {aka ‘std::__cxx11::basic_stri
							      								    								  ng<char>’} is not derived from ‘const __gnu_cxx::_
							      								    								  _normal_iterator<_Iterator, _Container>’    long f
							      								    								  ractional = num - Integral ;
							      								    								  	^~~~~~~~ CONVERT_DECIMAL_FRACTION_BINARY_NUM
							      								    								  BER.cpp:53:41: error: request for member ‘c_str’ i
							      								    								  n ‘fractional’, which is of non-class type ‘long i
							      								    								  nt’	   int fract_bit = atoi ( fractional . c_str
							      								    								   ( ) ) ;
							      								    								  ^~~~~ CONVERT_DECIMAL_FRACTION_BINARY_NUMBER.cpp:
							      								    								  In function ‘int main()’: CONVERT_DECIMAL_FRACTION
							      								    								  _BINARY_NUMBER.cpp:73:40: error: could not convert
							      								    								   ‘param0.std::vector<double>::operator[](((std::ve
							      								    								  ctor<double>::size_type)i))’ from ‘__gnu_cxx::__al
							      								    								  loc_traits<std::allocator<double>, double>::value_
							      								    								  type’ {aka ‘double’} to ‘std::__cxx11::string’ {ak
							      								    								  a ‘std::__cxx11::basic_string<char>’}		 if(
							      								    								  f_filled(param0[i],param1[i]) == f_gold(param0[i],
							      								    								  param1[i]))
							      								    								    ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING		      LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING		    LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING		  LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_STRING
--							      --							    --								  --
def lexicographicSubConcat ( s ) :			      string lexicographicSubConcat ( string s ) {		    string lexicographicSubConcat ( string s ) {		  error : LEXICOGRAPHICAL_CONCATENATION_SUBSTRINGS_S
    n = len ( s )					      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  TRING.cpp: In function ‘std::__cxx11::string f_fil
    sub_count = ( n * ( n + 1 ) ) // 2			      	int sub_count = n * ( n + 1 ) / 2 ;			      int subCount = ( n * ( n + 1 ) ) / 2 ;			  led(std::__cxx11::string)’: LEXICOGRAPHICAL_CONCAT
    arr = [ 0 ] * sub_count				      	string arr [ sub_count ] ;				      vector < char > arr ( subCount , 0 ) ;			  ENATION_SUBSTRINGS_STRING.cpp:46:50: error: cannot
    index = 0						      	int index = 0 ;						      int index = 0 ;						   convert ‘std::__cxx11::basic_string<char>’ to ‘__
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  gnu_cxx::__alloc_traits<std::allocator<char>, char
	for j in range ( 1 , n - i + 1 ) :		      	i < n ;							      i < n ;							  >::value_type’ {aka ‘char’} in assignment	   a
	    arr [ index ] = s [ i : i + j ]		      	i ++ ) for ( int len = 1 ;				      i ++ ) {							  rr [ index ] = s . substr ( i , j - i + 1 ) ;
	    index += 1					      	len <= n - i ;						    	for ( int j = 1 ;					  						^
    arr.sort ( )					      	len ++ ) arr [ index ++ ] = s . substr ( i , len ) ;	    	j < n - i + 1 ;						  
    res = ""						      	sort ( arr , arr + sub_count ) ;			    	j ++ ) {						  
    for i in range ( sub_count ) :			      	string res = "" ;					    	  arr [ index ] = s . substr ( i , j - i + 1 ) ;	  
	res += arr [ i ]				      	for ( int i = 0 ;					    	  index ++ ;						  
    return res						      	i < sub_count ;						    	}							  
							      	i ++ ) res += arr [ i ] ;				      }								  
							      	return res ;						      sort ( arr . begin ( ) , arr . end ( ) ) ;		  
							      }								      string res ;						  
							      								      for ( int i = 0 ;						  
							      								      i < subCount ;						  
							      								      i ++ ) res += arr [ i ] ;					  
							      								      return res ;						  
							      								      return " " + s + " " + s ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM			      MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM			    MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM			  MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM
--							      --							    --								  --
def maximumSumSubarray ( arr , n ) :			      int maximumSumSubarray ( int arr [ ] , int n ) {		    double maximumSumSubarray ( double * arr , int n ) {	  error : MAXIMUM_SUBARRAY_SUM_USING_PREFIX_SUM.cpp:
    min_prefix_sum = 0					      	int min_prefix_sum = 0 ;				      double minPrefixSum = 0 ;					   In function ‘int main()’: MAXIMUM_SUBARRAY_SUM_US
    res = - math.inf					      	int res = numeric_limits < int > :: min ( ) ;		      double res = - std :: numeric_limits < double > :: infinity ING_PREFIX_SUM.cpp:58:21: error: cannot convert ‘_
    prefix_sum = [ ]					      	int prefix_sum [ n ] ;					      double prefixSum [ n ] ;					  _gnu_cxx::__alloc_traits<std::allocator<int>, int>
    prefix_sum.append ( arr [ 0 ] )			      	prefix_sum [ 0 ] = arr [ 0 ] ;				      prefixSum [ 0 ] = arr [ 0 ] ;				  ::value_type*’ {aka ‘int*’} to ‘double*’
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  if(f_filled(&param0[i].front(),param1[i]) == f_gol
	prefix_sum.append ( prefix_sum [ i - 1 ] + arr [ i ]  	i < n ;							      i < n ;							  d(&param0[i].front(),param1[i]))
    for i in range ( n ) :				      	i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ]    i ++ ) prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ;      ^~~~~~~~~~~~~~~~~~ MAXIMUM_SUBARRAY_SUM_USING_
	res = max ( res , prefix_sum [ i ] - min_prefix_sum ) 	for ( int i = 0 ;					      for ( int i = 0 ;						  PREFIX_SUM.cpp:34:28: note:	initializing argumen
	min_prefix_sum = min ( min_prefix_sum , prefix_sum [  	i < n ;							      i < n ;							  t 1 of ‘double f_filled(double*, int)’  double f_f
    return res						      	i ++ ) {						      i ++ ) {							  illed ( double * arr , int n ) {
							      	  res = max ( res , prefix_sum [ i ] - min_prefix_sum ) ;   	res = std :: max ( res , prefixSum [ i ] - minPrefixSum )   ~~~~~~~~~^~~
							      	  min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ]  	minPrefixSum = std :: min ( minPrefixSum , prefixSum [ i  
							      	}							      }								  
							      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS	      LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS	    LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS	  LARGEST_SUBSET_WHOSE_ALL_ELEMENTS_ARE_FIBONACCI_NUMBERS
--							      --							    --								  --
def findFibSubset ( arr , n ) :				      void findFibSubset ( int arr [ ] , int n ) {		    int findFibSubset ( int * arr , int n ) {			  script_not_found : None
    m = max ( arr )					      	int max = * std :: max_element ( arr , arr + n ) ;	      int m = max < int > ( arr ) ;				  
    a = 0						      	int a = 0 , b = 1 ;					      int a = 0 ;						  
    b = 1						      	unordered_set < int > hash ;				      int b = 1 ;						  
    hash = [ ]						      	hash . insert ( a ) ;					      int hash [ m ] ;						  
    hash.append ( a )					      	hash . insert ( b ) ;					      hash [ a ] = b ;						  
    hash.append ( b )					      	while ( b < max ) {					      while ( ( b < m ) && ( a < b ) ) {			  
    while ( b < m ) :					      	  int c = a + b ;					    	int c = a + b ;						  
	c = a + b					      	  a = b ;						    	a = b ;							  
	a = b						      	  b = c ;						    	b = c ;							  
	b = c						      	  hash . insert ( b ) ;					    	hash [ b ] = c ;					  
	hash.append ( b )				      	}							      }								  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if arr [ i ] in hash :				      	i < n ;							      i < n ;							  
	    print ( arr [ i ] , end = " " )		      	i ++ ) if ( hash . find ( arr [ i ] ) != hash . end ( ) ) p   i ++ ) {							  
							      }								    	if ( hash [ i ] == hash [ i ] ) cout << arr [ i ] << " "  
							      								      }								  
							      								      return a ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN FIND_THE_MAXIMUM_OF_MINIMUMS_FOR_EVERY_WINDOW_SIZE_IN_A_GIVEN
--							      --							    --								  --
def printMaxOfMin ( arr , n ) :				      void printMaxOfMin ( int arr [ ] , int n ) {		    int printMaxOfMin ( int * arr , int n ) {			  script_not_found : None
    for k in range ( 1 , n + 1 ) :			      	for ( int k = 1 ;					      for ( int k = 1 ;						  
	maxOfMin = INT_MIN				      	k <= n ;						      k <= n ;							  
	for i in range ( n - k + 1 ) :			      	k ++ ) {						      k ++ ) {							  
	    min = arr [ i ]				      	  int maxOfMin = INT_MIN ;				    	int maxOfMin = INT_MIN ;				  
	    for j in range ( k ) :			      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
		if ( arr [ i + j ] < min ) :		      	  i <= n - k ;						    	i < n - k + 1 ;						  
		    min = arr [ i + j ]			      	  i ++ ) {						    	i ++ ) {						  
	    if ( min > maxOfMin ) :			      	    int min = arr [ i ] ;				    	  int min = arr [ i ] ;					  
		maxOfMin = min				      	    for ( int j = 1 ;					    	  for ( int j = 0 ;					  
	print ( maxOfMin , end = " " )			      	    j < k ;						    	  j < k ;						  
							      	    j ++ ) {						    	  j ++ ) {						  
							      	      if ( arr [ i + j ] < min ) min = arr [ i + j ] ;	    	    if ( ( arr [ i + j ] < min ) ) min = arr [ i + j ] ;  
							      	    }							    	  }							  
							      	    if ( min > maxOfMin ) maxOfMin = min ;		    	  if ( ( min > maxOfMin ) ) maxOfMin = min ;		  
							      	  }							    	}							  
							      	  cout << maxOfMin << " " ;				    	cout << maxOfMin << " " ;				  
							      	}							      }								  
							      }								      return n ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE		      NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE		    NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE		  NUMBER_DECIMAL_NUMBERS_LENGTH_K_STRICT_MONOTONE
--							      --							    --								  --
def getNumStrictMonotone ( ln ) :			      int getNumStrictMonotone ( int len ) {			    int getNumStrictMonotone ( int ln ) {			  script_not_found : None
    DP = [ [ 0 ] * DP_s for _ in range ( ln ) ]		      	int DP [ len ] [ DP_s ] ;				      vector < vector < int >> DP ( ln , vector < int > ( DP_s ,  
    for i in range ( DP_s ) :				      	memset ( DP , 0 , sizeof ( DP ) ) ;			      for ( int i = 0 ;						  
	DP [ 0 ] [ i ] = i + 1				      	for ( int i = 0 ;					      i < DP_s ;						  
    for i in range ( 1 , ln ) :				      	i < DP_s ;						      i ++ ) DP [ 0 ] [ i ] = i + 1 ;				  
	for j in range ( 1 , DP_s ) :			      	++ i ) DP [ 0 ] [ i ] = i + 1 ;				      for ( int i = 1 ;						  
	    DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i  	for ( int i = 1 ;					      i < ln ;							  
    return DP [ ln - 1 ] [ DP_s - 1 ]			      	i < len ;						      i ++ ) for ( int j = 1 ;					  
							      	++ i ) for ( int j = 1 ;				      j < DP_s ;						  
							      	j < DP_s ;						      j ++ ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ 
							      	++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [   return DP [ ln - 1 ] [ DP_s - 1 ] ;			  
							      	return DP [ len - 1 ] [ DP_s - 1 ] ;			    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRIME_FACTORS_BIG_NUMBER				      PRIME_FACTORS_BIG_NUMBER					    PRIME_FACTORS_BIG_NUMBER					  PRIME_FACTORS_BIG_NUMBER
--							      --							    --								  --
def factorize ( n ) :					      void factorize ( long long n ) {				    int factorize ( long n ) {					  script_not_found : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    while ( ( n % 2 > 0 ) == False ) :			      	while ( ! ( n % 2 ) ) {					      while ( ( ( n % 2 > 0 ) == false ) && ( n % 2 == 0 ) ) {	  
	n >>= 1						      	  n >>= 1 ;						    	n >>= 1 ;						  
	count += 1					      	  count ++ ;						    	count ++ ;						  
    if ( count > 0 ) :					      	}							      }								  
	print ( 2 , count )				      	if ( count ) cout << 2 << "  " << count << endl ;	      if ( ( count > 0 ) ) cout << 2 << count << endl ;		  
    for i in range ( 3 , int ( math.sqrt ( n ) ) + 1 ) :      	for ( long long i = 3 ;					      for ( int i = 3 ;						  
	count = 0					      	i <= sqrt ( n ) ;					      i < ( int ) sqrt ( n ) + 1 ;				  
	while ( n % i == 0 ) :				      	i += 2 ) {						      i ++ ) {							  
	    count += 1					      	  count = 0 ;						    	count = 0 ;						  
	    n = int ( n / i )				      	  while ( n % i == 0 ) {				    	while ( ( n % i == 0 ) ) {				  
	if ( count > 0 ) :				      	    count ++ ;						    	  count ++ ;						  
	    print ( i , count )				      	    n = n / i ;						    	  n = ( long ) n / i ;					  
	i += 2						      	  }							    	}							  
    if ( n > 2 ) :					      	  if ( count ) cout << i << "  " << count << endl ;	    	if ( ( count > 0 ) ) cout << i << count << endl ;	  
	print ( n , 1 )					      	}							    	i += 2 ;						  
							      	if ( n > 2 ) cout << n << "  " << 1 << endl ;		      }								  
							      }								      if ( ( n > 2 ) ) cout << n << 1 << endl ;			  
							      								      return count ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1			      SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1			    SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1			  SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS_1
--							      --							    --								  --
def diagonalsquare ( mat , row , column ) :		      void diagonalsquare ( int mat [ ] [ MAX ] , int row , int col int getNum ( int * * nums , int row , int column ) {	  script_not_found : None
    print ( "Diagonal one : " , end = "" )		      	cout << " \nDiagonal one : " ;				      int count = 0 ;						  
    for i in range ( 0 , row ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	print ( mat [ i ] [ i ] * mat [ i ] [ i ] , end = ""  	i < row ;						      i <= row ;						  
    print ( "\n\nDiagonal two : " , end = "" )		      	i ++ ) {						      i ++ ) {							  
    for i in range ( 0 , row ) :			      	  cout << mat [ i ] [ i ] * mat [ i ] [ i ] << " " ;	    	count ++ ;						  
	print ( mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - 	}							      }								  
							      	cout << " \n\nDiagonal two : " ;			      for ( int i = 0 ;						  
							      	for ( int i = 0 ;					      i < count ;						  
							      	i < row ;						      i ++ ) {							  
							      	i ++ ) {						    	nums [ i ] = nums [ row - i - 1 ] + nums [ row - i - 1 ]  
							      	  cout << mat [ i ] [ row - i - 1 ] * mat [ i ] [ row - i -   }								  
							      	}							      for ( int i = 0 ;						  
							      }								      i < count ;						  
							      								      i ++ ) {							  
							      								    	nums [ i ] = nums [ row - i - 1 ] + nums [ row - i - 1 ]  
							      								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION		      MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION		    MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION		  MINIMUM_STEPS_MINIMIZE_N_PER_GIVEN_CONDITION
--							      --							    --								  --
def getMinSteps ( n ) :					      int getMinSteps ( int n ) {				    int getMinSteps ( int n ) {					  failure : #Results: 0, 10
    table = [ 0 ] * ( n + 1 )				      	int table [ n + 1 ] ;					      vector < int > table ( n + 1 , 0 ) ;			  
    for i in range ( n + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	table [ i ] = n - i				      	i <= n ;						      i < n + 1 ;						  
    for i in range ( n , 0 , - 1 ) :			      	i ++ ) table [ i ] = n - i ;				      i ++ ) table [ i ] = n - i ;				  
	if ( not ( i % 2 ) ) :				      	for ( int i = n ;					      for ( int i = n ;						  
	    table [ i // 2 ] = min ( table [ i ] + 1 , table  	i >= 1 ;						      i > 0 ;							  
	if ( not ( i % 3 ) ) :				      	i -- ) {						      i -- ) {							  
	    table [ i // 3 ] = min ( table [ i ] + 1 , table  	  if ( ! ( i % 2 ) ) table [ i / 2 ] = min ( table [ i ] +  	if ( ( ! ( i % 2 ) ) ) table [ i / 2 ] = min ( table [ i  
    return table [ 1 ]					      	  if ( ! ( i % 3 ) ) table [ i / 3 ] = min ( table [ i ] +  	if ( ( ! ( i % 3 ) ) ) table [ i / 3 ] = min ( table [ i  
							      	}							      }								  
							      	return table [ 1 ] ;					      return table [ n + 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS	      LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS	    LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS	  LEXICOGRAPHICALLY_SMALLEST_ARRAY_K_CONSECUTIVE_SWAPS
--							      --							    --								  --
def minimizeWithKSwaps ( arr , n , k ) :		      void minimizeWithKSwaps ( int arr [ ] , int n , int k ) {	    int findFirstIndexOfLastSlash ( string str , int index ) {	  script_not_found : None
    for i in range ( n - 1 ) :				      	for ( int i = 0 ;					      int lastSlash = 0 ;					  
	pos = i						      	i < n - 1 && k > 0 ;					      int lastSlash = str . find_last_of ( " / " ) ;		  
	for j in range ( i + 1 , n ) :			      	++ i ) {						      if ( lastSlash != string :: npos ) {			  
	    if ( j - i > k ) :				      	  int pos = i ;						    	lastSlash = lastSlash + 1 ;				  
		break					      	  for ( int j = i + 1 ;					      }								  
	    if ( arr [ j ] < arr [ pos ] ) :		      	  j < n ;						      for ( int i = 0 ;						  
		pos = j					      	  ++ j ) {						      i < str . length ( ) - 1 ;				  
	for j in range ( pos , i , - 1 ) :		      	    if ( j - i > k ) break ;				      i ++ ) {							  
	    arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ 	    if ( arr [ j ] < arr [ pos ] ) pos = j ;		    	if ( ( lastSlash - i ) > lastSlash ) break ;		  
	k -= pos - i					      	  }							    	if ( ( str [ j ] < lastSlash ) ) {			  
							      	  for ( int j = pos ;					    	  lastSlash = j ;					  
							      	  j > i ;						    	}							  
							      	  -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ;		      }								  
							      	  k -= pos - i ;					      for ( int j = pos ;					  
							      	}							      j > i ;							  
							      }								      j -- ) {							  
							      								    	if ( str [ j ] == lastSlash ) {				  
							      								    	  lastSlash = j ;					  
							      								    	}							  
							      								      }								  
							      								      return lastSlash ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI SMALLEST_LENGTH_STRING_WITH_REPEATED_REPLACEMENT_OF_TWO_DISTI
--							      --							    --								  --
def stringReduction ( str ) :				      int stringReduction ( string str ) {			    int stringReduction ( string str ) {			  script_not_found : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    count = [ 0 ] * 3					      	int count [ 3 ] = {					      vector < int > count ( 3 , 0 ) ;				  
    for i in range ( n ) :				      	  0 }							      for ( int i = 0 ;						  
	count [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1	      	  ;							      i < n ;							  
    if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ]  	  for ( int i = 0 ;					      i ++ ) count [ str [ i ] - 'a' ] ++ ;			  
	return n					      	  i < n ;						      if ( ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ]  
    if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( cou 	  ++ i ) count [ str [ i ] - 'a' ] ++ ;			      if ( ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( coun 
	return 2					      	  if ( count [ 0 ] == n || count [ 1 ] == n || count [ 2 ]    return 1 ;						  
    return 1						      	  if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( coun   return n * n ;						  
							      	  return 1 ;						    }								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT FIND_THE_MINIMUM_COST_TO_REACH_A_DESTINATION_WHERE_EVERY_STAT
--							      --							    --								  --
def minCost ( cost ) :					      INT_MAX int minCost ( int cost [ ] [ N ] ) {		    int minCost ( int cost [ N ] [ N ] ) {			  script_not_found : None
    dist = [ 0 for i in range ( N ) ]			      	int dist [ N ] ;					      vector < int > dist ( N , 0 ) ;				  
    for i in range ( N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	dist [ i ] = INF				      	i < N ;							      i < N ;							  
    dist [ 0 ] = 0					      	i ++ ) dist [ i ] = INF ;				      i ++ ) dist [ i ] = INT_MAX ;				  
    for i in range ( N ) :				      	dist [ 0 ] = 0 ;					      dist [ 0 ] = 0 ;						  
	for j in range ( i + 1 , N ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) 	i < N ;							      i < N ;							  
		dist [ j ] = dist [ i ] + cost [ i ] [ j ]    	i ++ ) for ( int j = i + 1 ;				      i ++ ) for ( int j = i + 1 ;				  
    return dist [ N - 1 ]				      	j < N ;							      j < N ;							  
							      	j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) di   j ++ ) if ( ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] )  
							      	return dist [ N - 1 ] ;					      return dist [ N - 1 ] ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1		      FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1			    FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1			  FORM_MINIMUM_NUMBER_FROM_GIVEN_SEQUENCE_1
--							      --							    --								  --
def getMinNumberForPattern ( seq ) :			      string getMinNumberForPattern ( string seq ) {		    string getMinNumberForPattern ( string seq ) {		  failure : #Results: 0, 10
    n = len ( seq )					      	int n = seq . length ( ) ;				      int n = seq . length ( ) ;				  
    if ( n >= 9 ) :					      	if ( n >= 9 ) return "-1" ;				      if ( ( n >= 9 ) ) return "-1" ;				  
	return "-1"					      	string result ( n + 1 , ' ' ) ;				      char * result = new char [ n + 1 ] ;			  
    result = [ None ] * ( n + 1 )			      	int count = 1 ;						      int count = 1 ;						  
    count = 1						      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( n + 1 ) :				      	i <= n ;						      i < n + 1 ;						  
	if ( i == n or seq [ i ] == 'I' ) :		      	i ++ ) {						      i ++ ) {							  
	    for j in range ( i - 1 , - 2 , - 1 ) :	      	  if ( i == n || seq [ i ] == 'I' ) {			    	if ( ( i == n || seq [ i ] == 'I' ) ) {			  
		result [ j + 1 ] = int ( '0' + str ( count )  	    for ( int j = i - 1 ;				    	  for ( int j = i - 1 ;					  
		count += 1				      	    j >= - 1 ;						    	  j >= 0 ;						  
		if ( j >= 0 and seq [ j ] == 'I' ) :	      	    j -- ) {						    	  j -- ) {						  
		    break				      	      result [ j + 1 ] = '0' + count ++ ;		    	    result [ j + 1 ] = ( char ) ( '0' + count ) ;	  
    return result					      	      if ( j >= 0 && seq [ j ] == 'I' ) break ;		    	    count ++ ;						  
							      	    }							    	    if ( ( j >= 0 ) && seq [ j ] == 'I' ) break ;	  
							      	  }							    	  }							  
							      	}							    	}							  
							      	return result ;						      }								  
							      }								      return seq ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S	      FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S		    FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S		  FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S
--							      --							    --								  --
def MaxDotProduct ( A , B , m , n ) :			      long long int MaxDotProduct ( int A [ ] , int B [ ] , int m , double MaxDotProduct ( double * A , double * B , int m , int  error : FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERT
    dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n  	long long int dp [ n + 1 ] [ m + 1 ] ;			      vector < vector < double >> dp ( m + 1 , vector < double >  ION_0S.cpp: In function ‘int main()’: FIND_MAXIMUM
    for i in range ( 1 , n + 1 , 1 ) :			      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int j = 0 ;						  _DOT_PRODUCT_TWO_ARRAYS_INSERTION_0S.cpp:49:21: er
	for j in range ( i , m + 1 , 1 ) :		      	for ( int i = 1 ;					      j < n + 1 ;						  ror: cannot convert ‘__gnu_cxx::__alloc_traits<std
	    dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + 	i <= n ;						      j += 1 ) {						  ::allocator<int>, int>::value_type*’ {aka ‘int*’}
    return dp [ n ] [ m ]				      	i ++ ) for ( int j = i ;				    	for ( int i = 1 ;					  to ‘double*’		if(f_filled(&param0[i].front
							      	j <= m ;						    	i < n ;							  (),&param1[i].front(),param2[i],param3[i]) == f_go
							      	j ++ ) dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + (  	i += 1 ) dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ]  ld(&param0[i].front(),&param1[i].front(),param2[i]
							      	return dp [ n ] [ m ] ;					      }								  ,param3[i]))			    ^~~~~~~~~~~~~~~~
							      }								      return dp [ n ] [ m ] ;					  ~~ FIND_MAXIMUM_DOT_PRODUCT_TWO_ARRAYS_INSERTION_0
							      								    }								  S.cpp:28:28: note:   initializing argument 1 of ‘d
							      								    								  ouble f_filled(double*, double*, int, int)’  doubl
							      								    								  e f_filled ( double * A , double * B , int m , int
							      								    								   n ) {		    ~~~~~~~~~^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE
--							      --							    --								  --
def solve ( i , par , a , n , k , current_ans ) :	      void solve ( int i , int par , int a [ ] , int n , int k , in int solve ( int i , int par , int * a , int n , int k , int c script_not_found : None
    if ( par > k ) :					      	if ( par > k ) return ;					      if ( ( par > k ) ) return 0 ;				  
	return 0					      	if ( par == k && i == n - 1 ) {				      static int ans = 0 ;					  
    global ans						      	  ans = min ( ans , current_ans ) ;			      if ( ( par == k ) && ( i == n - 1 ) ) {			  
    if ( par == k and i == n - 1 ) :			      	  return ;						    	ans = min ( ans , currentAns ) ;			  
	ans = min ( ans , current_ans )			      	}							    	return 0 ;						  
	return 0					      	for ( int j = i + 1 ;					      }								  
    for j in range ( i + 1 , n ) :			      	j < n ;							      for ( int j = i + 1 ;					  
	solve ( j , par + 1 , a , n , k , current_ans + ( a [ 	j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a    j < n ;							  
							      }								      j ++ ) solve ( j , par + 1 , a , n , k , currentAns + ( a [ 
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUBARRAY_WITH_GIVEN_SUM				      FIND_SUBARRAY_WITH_GIVEN_SUM				    FIND_SUBARRAY_WITH_GIVEN_SUM				  FIND_SUBARRAY_WITH_GIVEN_SUM
--							      --							    --								  --
def subArraySum ( arr , n , sum ) :			      int subArraySum ( int arr [ ] , int n , int sum ) {	    int subArraySum ( int * arr , int n , int sum ) {		  success : None
    for i in range ( n ) :				      	int curr_sum , i , j ;					      for ( int i = 0 ;						  
	curr_sum = arr [ i ]				      	for ( i = 0 ;						      i < n ;							  
	j = i + 1					      	i < n ;							      i ++ ) {							  
	while j <= n :					      	i ++ ) {						    	int currSum = arr [ i ] ;				  
	    if curr_sum == sum :			      	  curr_sum = arr [ i ] ;				    	int j = i + 1 ;						  
		print ( "Sum found between" )		      	  for ( j = i + 1 ;					    	while ( j <= n ) {					  
		print ( "indexes %d and %d" % ( i , j - 1 ) ) 	  j <= n ;						    	  if ( currSum == sum ) {				  
		return 1				      	  j ++ ) {						    	    cout << "Sum found between" << endl ;		  
	    if curr_sum > sum or j == n :		      	    if ( curr_sum == sum ) {				    	    cout << "indexes " << i << " and " << j - 1 << endl ; 
		break					      	      cout << "Sum found between indexes " << i << " and "  	    return 1 ;						  
	    curr_sum = curr_sum + arr [ j ]		      	      return 1 ;					    	  }							  
	    j += 1					      	    }							    	  if ( currSum > sum || j == n ) break ;		  
    print ( "No subarray found" )			      	    if ( curr_sum > sum || j == n ) break ;		    	  currSum = currSum + arr [ j ] ;			  
    return 0						      	    curr_sum = curr_sum + arr [ j ] ;			    	  j ++ ;						  
							      	  }							    	}							  
							      	}							      }								  
							      	cout << "No subarray found" ;				      cout << "No subarray found" << endl ;			  
							      	return 0 ;						      return 0 ;						  
							      }								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS		      COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS			    COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS			  COUNT_WAYS_BUILD_STREET_GIVEN_CONSTRAINTS
--							      --							    --								  --
def countWays ( n ) :					      long countWays ( int n ) {				    int countWays ( int n ) {					  failure : #Results: 2, 10
    dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ]	      	long dp [ 2 ] [ n + 1 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( n +  
    dp [ 0 ] [ 1 ] = 1					      	dp [ 0 ] [ 1 ] = 1 ;					      dp [ 0 ] [ 1 ] = 1 ;					  
    dp [ 1 ] [ 1 ] = 2					      	dp [ 1 ] [ 1 ] = 2 ;					      dp [ 1 ] [ 1 ] = 2 ;					  
    for i in range ( 2 , n + 1 ) :			      	for ( int i = 2 ;					      for ( int i = 2 ;						  
	dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i -  	i <= n ;						      i <= n ;							  
	dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ]  	i ++ ) {						      i ++ ) {							  
    return dp [ 0 ] [ n ] + dp [ 1 ] [ n ]		      	  dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ]  	dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ]  
							      	  dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i -  	dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i  
							      	}							      }								  
							      	return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;		      return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_PATH_TRIANGLE				      MINIMUM_SUM_PATH_TRIANGLE					    MINIMUM_SUM_PATH_TRIANGLE					  MINIMUM_SUM_PATH_TRIANGLE
--							      --							    --								  --
def minSumPath ( A ) :					      int minSumPath ( vector < vector < int >> & A ) {		    int minSumPath ( int * A ) {				  script_not_found : None
    memo = [ None ] * len ( A )				      	int memo [ A . size ( ) ] ;				      int memo [ A . size ( ) ] ;				  
    n = len ( A ) - 1					      	int n = A . size ( ) - 1 ;				      int n = A . size ( ) - 1 ;				  
    for i in range ( len ( A [ n ] ) ) :		      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	memo [ i ] = A [ n ] [ i ]			      	i < A [ n ] . size ( ) ;				      i < A [ n ] . size ( ) ;					  
    for i in range ( len ( A ) - 2 , - 1 , - 1 ) :	      	i ++ ) memo [ i ] = A [ n ] [ i ] ;			      i ++ ) memo [ i ] = A [ n ] [ i ] ;			  
	for j in range ( len ( A [ i ] ) ) :		      	for ( int i = A . size ( ) - 2 ;			      for ( int i = A . size ( ) - 2 ;				  
	    memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , m 	i >= 0 ;						      i >= 0 ;							  
    return memo [ 0 ]					      	i -- ) for ( int j = 0 ;				      i -- ) {							  
							      	j < A [ i ] . size ( ) ;				    	for ( int j = 0 ;					  
							      	j ++ ) memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo 	j < A [ i ] . size ( ) ;				  
							      	return memo [ 0 ] ;					    	j ++ ) memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , me 
							      }								      }								  
							      								      return memo [ 0 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY		      PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY		    PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY		  PAIRS_OF_POSITIVE_NEGATIVE_VALUES_IN_AN_ARRAY
--							      --							    --								  --
def printPairs ( arr , n ) :				      void printPairs ( int arr [ ] , int n ) {			    int printPairs ( int * arr , int n ) {			  script_not_found : None
    v = [ ]						      	vector < int > v ;					      vector < int > v ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i < n ;							  
	    if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) :   	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
		v.append ( abs ( arr [ i ] ) )		      	j < n ;							    	for ( int j = i + 1 ;					  
    if ( len ( v ) == 0 ) :				      	j ++ ) if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . pu 	j < n ;							  
	return ;					      	if ( v . size ( ) == 0 ) return ;			    	j ++ ) {						  
    v.sort ( )						      	sort ( v . begin ( ) , v . end ( ) ) ;			    	  if ( ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) ) v . p 
    for i in range ( len ( v ) ) :			      	for ( int i = 0 ;					    	}							  
	print ( - v [ i ] , "" , v [ i ] , end = " " )	      	i < v . size ( ) ;					      }								  
							      	i ++ ) cout << - v [ i ] << " " << v [ i ] ;		      if ( ( v . size ( ) == 0 ) ) return 0 ;			  
							      }								      sort ( v . begin ( ) , v . end ( ) ) ;			  
							      								      for ( int i = 0 ;						  
							      								      i < v . size ( ) ;					  
							      								      i ++ ) cout << - v [ i ] << " " << v [ i ] << " " ;	  
							      								      return v . size ( ) ;					  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS		      COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS		    COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS		  COUNT_NUMBERS_CAN_CONSTRUCTED_USING_TWO_NUMBERS
--							      --							    --								  --
def countNums ( n , x , y ) :				      int countNums ( int n , int x , int y ) {			    int countNums ( int n , int x , int y ) {			  failure : #Results: 8, 10
    arr = [ False for i in range ( n + 2 ) ]		      	vector < bool > arr ( n + 1 , false ) ;			      vector < bool > arr ( n + 2 , false ) ;			  
    if ( x <= n ) :					      	if ( x <= n ) arr [ x ] = true ;			      for ( int i = 0 ;						  
	arr [ x ] = True				      	if ( y <= n ) arr [ y ] = true ;			      i < arr . size ( ) ;					  
    if ( y <= n ) :					      	int result = 0 ;					      i ++ ) arr [ i ] = false ;				  
	arr [ y ] = True				      	for ( int i = min ( x , y ) ;				      if ( ( x <= n ) && ( y <= n ) ) arr [ x ] = true ;	  
    result = 0						      	i <= n ;						      if ( ( y <= n ) && ( x >= n ) ) arr [ y ] = true ;	  
    for i in range ( min ( x , y ) , n + 1 ) :		      	i ++ ) {						      int result = 0 ;						  
	if ( arr [ i ] ) :				      	  if ( arr [ i ] ) {					      for ( int i = min < int > ( x , y ) ;			  
	    if ( i + x <= n ) :				      	    if ( i + x <= n ) arr [ i + x ] = true ;		      i <= n ;							  
		arr [ i + x ] = True			      	    if ( i + y <= n ) arr [ i + y ] = true ;		      i ++ ) {							  
	    if ( i + y <= n ) :				      	    result ++ ;						    	if ( ( arr [ i ] ) ) {					  
		arr [ i + y ] = True			      	  }							    	  if ( ( i + x <= n ) ) arr [ i + x ] = true ;		  
	    result = result + 1				      	}							    	  if ( ( i + y <= n ) ) arr [ i + y ] = true ;		  
    return result					      	return result ;						    	  result = result + 1 ;					  
							      }								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PASCAL_TRIANGLE						      PASCAL_TRIANGLE						    PASCAL_TRIANGLE						  PASCAL_TRIANGLE
--							      --							    --								  --
def printPascal ( n : int ) :				      void printPascal ( int n ) {				    int printPascal ( int n ) {					  script_not_found : None
    arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] 	int arr [ n ] [ n ] ;					      vector < vector < int >> arr ( n , vector < int > ( n , 0 ) 
    for line in range ( 0 , n ) :			      	for ( int line = 0 ;					      for ( int y = 0 ;						  
	for i in range ( 0 , line + 1 ) :		      	line < n ;						      y < n ;							  
	    if ( i is 0 or i is line ) :		      	line ++ ) {						      y ++ ) {							  
		arr [ line ] [ i ] = 1			      	  for ( int i = 0 ;					    	for ( int line = 0 ;					  
		print ( arr [ line ] [ i ] , end = "" )	      	  i <= line ;						    	line <= n ;						  
	    else :					      	  i ++ ) {						    	line ++ ) {						  
		arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 	    if ( line == i || i == 0 ) arr [ line ] [ i ] = 1 ;	    	  if ( ( i == 0 || i == line ) ) {			  
		print ( arr [ line ] [ i ] , end = "" )	      	    else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] +  	    arr [ line ] [ i ] = 1 ;				  
	print ( "\n" , end = "" )			      	    cout << arr [ line ] [ i ] << " " ;			    	    cout << arr [ line ] [ i ] << " " ;			  
							      	  }							    	  }							  
							      	  cout << "\n" ;					    	  else {						  
							      	}							    	    arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + a 
							      }								    	    cout << arr [ line ] [ i ] << " " ;			  
							      								    	  }							  
							      								    	}							  
							      								    	cout << "\n" << endl ;					  
							      								      }								  
							      								      return n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_N_DIGITS_NON_DECREASING_INTEGERS			      NUMBER_N_DIGITS_NON_DECREASING_INTEGERS			    NUMBER_N_DIGITS_NON_DECREASING_INTEGERS			  NUMBER_N_DIGITS_NON_DECREASING_INTEGERS
--							      --							    --								  --
def nonDecNums ( n ) :					      int nonDecNums ( int n ) {				    int nonDecNums ( int n ) {					  success : None
    a = np.zeros ( ( n + 1 , 10 ) )			      	int a [ n + 1 ] [ 10 ] ;				      vector < vector < int >> a ( n + 1 , vector < int > ( 10 ,  
    for i in range ( 10 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	a [ 0 ] [ i ] = 1				      	i <= 9 ;						      i < 10 ;							  
    for i in range ( 1 , n + 1 ) :			      	i ++ ) a [ 0 ] [ i ] = 1 ;				      i ++ ) a [ 0 ] [ i ] = 1 ;				  
	a [ i ] [ 9 ] = 1				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
    for i in range ( 1 , n + 1 ) :			      	i <= n ;						      i <= n ;							  
	for j in range ( 8 , - 1 , - 1 ) :		      	i ++ ) a [ i ] [ 9 ] = 1 ;				      i ++ ) a [ i ] [ 9 ] = 1 ;				  
	    a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 	for ( int i = 1 ;					      for ( int i = 1 ;						  
    return int ( a [ n ] [ 0 ] )			      	i <= n ;						      i <= n ;							  
							      	i ++ ) for ( int j = 8 ;				      i ++ ) {							  
							      	j >= 0 ;						    	for ( int j = 8 ;					  
							      	j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1  	j >= 0 ;						  
							      	return a [ n ] [ 0 ] ;					    	j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j +  
							      }								      }								  
							      								      return ( int ) a [ n ] [ 0 ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER			      DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER			    DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER			  DIVISIBILITY_BY_12_FOR_A_LARGE_NUMBER
--							      --							    --								  --
def isDvisibleBy12 ( num ) :				      bool isDvisibleBy12 ( string num ) {			    bool isDvisibleBy12 ( string num ) {			  failure : #Results: 8, 10
    if ( len ( num ) >= 3 ) :				      	if ( num . length ( ) >= 3 ) {				      if ( ( num . length ( ) >= 3 ) ) {			  
	d1 = int ( num [ len ( num ) - 1 ] )		      	  int d1 = ( int ) num [ num . length ( ) - 1 ] ;	    	int d1 = atoi ( num . substr ( num . length ( ) - 1 ) . c 
	if ( d1 % 2 != 0 ) :				      	  if ( d1 % 2 != 0 ) return ( 0 ) ;			    	if ( ( d1 % 2 ) != 0 ) return false ;			  
	    return False				      	  int d2 = ( int ) num [ num . length ( ) - 2 ] ;	    	int d2 = atoi ( num . substr ( num . length ( ) - 2 ) . c 
	d2 = int ( num [ len ( num ) - 2 ] )		      	  int sum = 0 ;						    	int sum = 0 ;						  
	sum = 0						      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
	for i in range ( 0 , len ( num ) ) :		      	  i < num . length ( ) ;				    	i != num . length ( ) ;					  
	    sum += int ( num [ i ] )			      	  i ++ ) sum += num [ i ] ;				    	i ++ ) sum += atoi ( num . substr ( i ) . c_str ( ) ) ;	  
	return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) 	  return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ;    	return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ;	  
    else :						      	}							      }								  
	number = int ( num )				      	else {							      else {							  
	return ( number % 12 == 0 )			      	  int number = stoi ( num ) ;				    	int number = atoi ( num . c_str ( ) ) ;			  
							      	  return ( number % 12 == 0 ) ;				    	return ( number % 12 == 0 ) ;				  
							      	}							      }								  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
A_PRODUCT_ARRAY_PUZZLE_1				      A_PRODUCT_ARRAY_PUZZLE_1					    A_PRODUCT_ARRAY_PUZZLE_1					  A_PRODUCT_ARRAY_PUZZLE_1
--							      --							    --								  --
def productArray ( arr , n ) :				      void productArray ( int arr [ ] , int n ) {		    int productArray ( int * arr , int n ) {			  script_not_found : None
    if n == 1 :						      	if ( n == 1 ) {						      if ( n == 1 ) {						  
	print ( 0 )					      	  cout << 0 ;						    	cout << 0 << endl ;					  
	return						      	  return ;						    	return 0 ;						  
    i , temp = 1 , 1					      	}							      }								  
    prod = [ 1 for i in range ( n ) ]			      	int i , temp = 1 ;					      int i , temp = 1 ;					  
    for i in range ( n ) :				      	int * prod = new int [ ( sizeof ( int ) * n ) ] ;	      int prod [ n ] ;						  
	prod [ i ] = temp				      	memset ( prod , 1 , n ) ;				      for ( i = 0 ;						  
	temp *= arr [ i ]				      	for ( i = 0 ;						      i < n ;							  
    temp = 1						      	i < n ;							      i ++ ) {							  
    for i in range ( n - 1 , - 1 , - 1 ) :		      	i ++ ) {						    	prod [ i ] = temp ;					  
	prod [ i ] *= temp				      	  prod [ i ] = temp ;					    	temp *= arr [ i ] ;					  
	temp *= arr [ i ]				      	  temp *= arr [ i ] ;					      }								  
    for i in range ( n ) :				      	}							      temp = 1 ;						  
	print ( prod [ i ] , end = " " )		      	temp = 1 ;						      for ( i = n - 1 ;						  
    return						      	for ( i = n - 1 ;					      i >= 0 ;							  
							      	i >= 0 ;						      i -- ) {							  
							      	i -- ) {						    	prod [ i ] *= temp ;					  
							      	  prod [ i ] *= temp ;					    	temp *= arr [ i ] ;					  
							      	  temp *= arr [ i ] ;					      }								  
							      	}							      for ( i = 0 ;						  
							      	for ( i = 0 ;						      i < n ;							  
							      	i < n ;							      i ++ ) cout << prod [ i ] << " " ;			  
							      	i ++ ) cout << prod [ i ] << " " ;			      return n ;						  
							      	return ;						      return n * n ;						  
							      }								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX		      COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX		    COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX		  COMMON_ELEMENTS_IN_ALL_ROWS_OF_A_GIVEN_MATRIX
--							      --							    --								  --
def printCommonElements ( mat ) :			      void printCommonElements ( int mat [ M ] [ N ] ) {	    int main ( int N , char * * argv ) {			  script_not_found : None
    mp = dict ( )					      	unordered_map < int , int > mp ;			      map < int , int > mp ;					  
    for j in range ( N ) :				      	for ( int j = 0 ;					      for ( int j = 0 ;						  
	mp [ mat [ 0 ] [ j ] ] = 1			      	j < N ;							      j < N ;							  
    for i in range ( 1 , M ) :				      	j ++ ) mp [ mat [ 0 ] [ j ] ] = 1 ;			      j ++ ) mp [ mat [ 0 ] [ j ] ] = 1 ;			  
	for j in range ( N ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	    if ( mat [ i ] [ j ] in mp.keys ( ) and mp [ mat  	i < M ;							      i < M ;							  
		mp [ mat [ i ] [ j ] ] = i + 1		      	i ++ ) {						      i ++ ) for ( int j = 0 ;					  
		if i == M - 1 :				      	  for ( int j = 0 ;					      j < N ;							  
		    print ( mat [ i ] [ j ] , end = " " )     	  j < N ;						      j ++ ) if ( ( mat [ i ] [ j ] < mp . size ( ) ) && mp [ mat 
							      	  j ++ ) {						    	mp [ mat [ i ] [ j ] ] = i + 1 ;			  
							      	    if ( mp [ mat [ i ] [ j ] ] == i ) {		    	if ( i == M - 1 ) cout << mat [ i ] [ j ] << " " ;	  
							      	      mp [ mat [ i ] [ j ] ] = i + 1 ;			      }								  
							      	      if ( i == M - 1 ) cout << mat [ i ] [ j ] << " " ;      return 0 ;						  
							      	    }							      return N * N ;						  
							      	  }							      return N * N * N * N * N * N * N * N * N * N * N * N * N *  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE		      FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE			    FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE			  FIND_A_TRIPLET_THAT_SUM_TO_A_GIVEN_VALUE
--							      --							    --								  --
def find3Numbers ( A , arr_size , sum ) :		      bool find3Numbers ( int A [ ] , int arr_size , int sum ) {    bool find3Numbers ( int * A , int arrSize , int sum ) {	  success : None
    for i in range ( 0 , arr_size - 2 ) :		      	int l , r ;						      for ( int i = 0 ;						  
	for j in range ( i + 1 , arr_size - 1 ) :	      	for ( int i = 0 ;					      i <= arrSize - 2 ;					  
	    for k in range ( j + 1 , arr_size ) :	      	i < arr_size - 2 ;					      i ++ ) {							  
		if A [ i ] + A [ j ] + A [ k ] == sum :	      	i ++ ) {						    	for ( int j = i + 1 ;					  
		    print ( "Triplet is" , A [ i ] , ", " , A 	  for ( int j = i + 1 ;					    	j <= arrSize - 1 ;					  
		    return True				      	  j < arr_size - 1 ;					    	j ++ ) {						  
    return False					      	  j ++ ) {						    	  for ( int k = j + 1 ;					  
							      	    for ( int k = j + 1 ;				    	  k <= arrSize ;					  
							      	    k < arr_size ;					    	  k ++ ) {						  
							      	    k ++ ) {						    	    if ( A [ i ] + A [ j ] + A [ k ] == sum ) {		  
							      	      if ( A [ i ] + A [ j ] + A [ k ] == sum ) {	    	      cout << "Triplet is" << A [ i ] << ", " << A [ j ]  
							      		cout << "Triplet is " << A [ i ] << ", " << A [ j ] 	      return true ;					  
							      		return true ;					    	    }							  
							      	      }							    	  }							  
							      	    }							    	}							  
							      	  }							      }								  
							      	}							      return false ;						  
							      	return false ;						      return A [ arrSize - 1 ] * A [ arrSize - 1 ] ;		  
							      }								      return A [ arrSize - 1 ] * A [ arrSize - 1 ] ;		  
							      								      return A [ arrSize - 1 ] * A [ arrSize - 1 ] ;		  
							      								      return A [ arrSize - 1 ] * A [ arrSize - 1 ] ;		  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_ PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_ PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_ PROGRAM_SWAP_UPPER_DIAGONAL_ELEMENTS_LOWER_DIAGONAL_ELEMENTS_
--							      --							    --								  --
def swapUpperToLower ( arr ) :				      void swapUpperToLower ( int arr [ n ] [ n ] ) {		    int sumOfDigits ( string str ) {				  script_not_found : None
    n = 4 ;						      	for ( int i = 0 ;					      int sum = 0 ;						  
    for i in range ( 0 , n ) :				      	i < n ;							      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i ++ ) {						      i < str . length ( ) ;					  
	    temp = arr [ i ] [ j ] ;			      	  for ( int j = i + 1 ;					      i ++ ) {							  
	    arr [ i ] [ j ] = arr [ j ] [ i ] ;		      	  j < n ;						    	int digit = 0 ;						  
	    arr [ j ] [ i ] = temp ;			      	  j ++ ) {						    	for ( int j = i + 1 ;					  
    for i in range ( 0 , n ) :				      	    int temp = arr [ i ] [ j ] ;			    	j < str . length ( ) ;					  
	for j in range ( 0 , n ) :			      	    arr [ i ] [ j ] = arr [ j ] [ i ] ;			    	j ++ ) {						  
	    print ( arr [ i ] [ j ] , end = " " ) ;	      	    arr [ j ] [ i ] = temp ;				    	  digit = str [ i ] - '0' ;				  
	print ( " " ) ;					      	  }							    	  if ( digit >= 10 ) digit = 10 - digit ;		  
							      	}							    	  if ( digit == 0 ) sum ++ ;				  
							      	for ( int i = 0 ;					    	  else sum += digit ;					  
							      	i < n ;							    	}							  
							      	i ++ ) {						      }								  
							      	  for ( int j = 0 ;					      for ( int i = 0 ;						  
							      	  j < n ;						      i < str . length ( ) ;					  
							      	  j ++ ) cout << arr [ i ] [ j ] << " " ;		      i ++ ) {							  
							      	  cout << endl ;					    	sum += str [ i ] - '0' ;				  
							      	}							      }								  
							      }								      return sum ;						  
							      								      return str . length ( ) ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_ MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_ MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_ MINIMUM_NUMBER_OF_SQUARES_WHOSE_SUM_EQUALS_TO_GIVEN_NUMBER_N_
--							      --							    --								  --
def getMinSquares ( n ) :				      int getMinSquares ( int n ) {				    int getMinSquares ( int n ) {				  timeout : None
    dp = [ 0 , 1 , 2 , 3 ]				      	int * dp = new int [ n + 1 ] ;				      vector < int > dp = {					  
    for i in range ( 4 , n + 1 ) :			      	dp [ 0 ] = 0 ;						    	0 , 1 , 2 , 3 }						  
	dp.append ( i )					      	dp [ 1 ] = 1 ;						    	;							  
	for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1  	dp [ 2 ] = 2 ;						    	for ( int i = 4 ;					  
	    temp = x * x ;				      	dp [ 3 ] = 3 ;						    	i <= n ;						  
	    if temp > i :				      	for ( int i = 4 ;					    	i ++ ) {						  
		break					      	i <= n ;						    	  dp . push_back ( i ) ;				  
	    else :					      	i ++ ) {						    	  for ( int x = 1 ;					  
		dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp 	  dp [ i ] = i ;					    	  x <= ( int ) ceil ( sqrt ( i ) ) + 1 ;		  
    return dp [ n ]					      	  for ( int x = 1 ;					    	  ) {							  
							      	  x <= ceil ( sqrt ( i ) ) ;				    	    int temp = x * x ;					  
							      	  x ++ ) {						    	    ;							  
							      	    int temp = x * x ;					    	    if ( temp > i ) break ;				  
							      	    if ( temp > i ) break ;				    	    else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ]  
							      	    else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] )  	  }							  
							      	  }							    	}							  
							      	}							    	return dp [ n ] ;					  
							      	int res = dp [ n ] ;					      }								  
							      	delete [ ] dp ;						    								  
							      	return res ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVIDE_LARGE_NUMBER_REPRESENTED_STRING			      DIVIDE_LARGE_NUMBER_REPRESENTED_STRING			    DIVIDE_LARGE_NUMBER_REPRESENTED_STRING			  DIVIDE_LARGE_NUMBER_REPRESENTED_STRING
--							      --							    --								  --
def longDivision ( number , divisor ) :			      string longDivision ( string number , int divisor ) {	    string longDivision ( string number , int divisor ) {	  error : /bin/bash: line 1: 1848323 Aborted
    ans = ""						      	string ans ;						      string ans ;						  	   (core dumped) ./DIVIDE_LARGE_NUMBER_REPRE
    idx = 0						      	int idx = 0 ;						      int idx = 0 ;						  SENTED_STRING_cpp
    temp = ord ( number [ idx ] ) - ord ( '0' )		      	int temp = number [ idx ] - '0' ;			      int temp = number [ idx ] - '0' ;				  
    while ( temp < divisor ) :				      	while ( temp < divisor ) temp = temp * 10 + ( number [ ++ i   while ( ( temp < divisor ) && ( temp > 0 ) ) {		  
	temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord 	while ( number . size ( ) > idx ) {			    	temp = ( temp * 10 + number [ idx + 1 ] - '0' ) ;	  
	idx += 1					      	  ans += ( temp / divisor ) + '0' ;			    	idx += 1 ;						  
    idx += 1						      	  temp = ( temp % divisor ) * 10 + number [ ++ idx ] - '0'    }								  
    while ( ( len ( number ) ) > idx ) :		      	}							      idx += 1 ;						  
	ans += chr ( math.floor ( temp // divisor ) + ord ( ' 	if ( ans . length ( ) == 0 ) return "0" ;		      while ( ( ( number . length ( ) ) > idx ) && ( temp > 0 ) ) 
	temp = ( ( temp % divisor ) * 10 + ord ( number [ idx 	return ans ;						    	ans += ( char ) floor ( temp / divisor ) + '0' ;	  
	idx += 1					      }								    	temp = ( ( temp % divisor ) * 10 + number [ idx ] - '0' ) 
    ans += chr ( math.floor ( temp // divisor ) + ord ( '0' ) 								    	idx += 1 ;						  
    if ( len ( ans ) == 0 ) :				      								      }								  
	return "0"					      								      ans += ( char ) floor ( temp / divisor ) + '0' ;		  
    return ans						      								      if ( ( ans . length ( ) == 0 ) ) return "0" ;		  
							      								      return ans ;						  
							      								      return " " + number + " " + number ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C		      LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C		    LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C			  LEXICOGRAPHICALLY_PREVIOUS_PERMUTATION_IN_C
--							      --							    --								  --
def prevPermutation ( str ) :				      bool prevPermutation ( string & str ) {			    bool prevPermutation ( string str ) {			  script_not_found : None
    n = len ( str ) - 1					      	int n = str . length ( ) - 1 ;				      int n = str . length ( ) - 1 ;				  
    i = n						      	int i = n ;						      int i = n ;						  
    while ( i > 0 and str [ i - 1 ] <= str [ i ] ) :	      	while ( i > 0 && str [ i - 1 ] <= str [ i ] ) i -- ;	      while ( ( i > 0 ) && str [ i - 1 ] <= str [ i ] ) i -- ;	  
	i -= 1						      	if ( i <= 0 ) return false ;				      if ( ( i <= 0 ) ) return false ;				  
    if ( i <= 0 ) :					      	int j = i - 1 ;						      int j = i - 1 ;						  
	return False					      	while ( j + 1 <= n && str [ j + 1 ] <= str [ i - 1 ] ) j ++   while ( ( j + 1 <= n ) && str [ j + 1 ] <= str [ i - 1 ] )  
    j = i - 1						      	swap ( str [ i - 1 ] , str [ j ] ) ;			      str = str . substr ( 0 , i - 1 ) ;			  
    while ( j + 1 <= n and str [ j + 1 ] <= str [ i - 1 ] ) : 	reverse ( str . begin ( ) + i , str . end ( ) ) ;	      char temp = str [ i - 1 ] ;				  
	j += 1						      	return true ;						      str [ i - 1 ] = str [ j ] ;				  
    str = list ( str )					      }								      str [ j ] = temp ;					  
    temp = str [ i - 1 ]				      								      str = str . substr ( 0 , str . length ( ) - 1 ) ;		  
    str [ i - 1 ] = str [ j ]				      								      return true ;						  
    str [ j ] = temp					      								      return n * n ;						  
    str = ''.join ( str )				      								      return n * n ;						  
    str [ : : - 1 ]					      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
    return True , str					      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_SUBSEQUENCES				      COUNT_DISTINCT_SUBSEQUENCES				    COUNT_DISTINCT_SUBSEQUENCES					  COUNT_DISTINCT_SUBSEQUENCES
--							      --							    --								  --
def countSub ( ss ) :					      int countSub ( string str ) {				    int countSub ( string ss ) {				  script_not_found : None
    last = [ - 1 for i in range ( MAX_CHAR + 1 ) ]	      	vector < int > last ( MAX_CHAR , - 1 ) ;		      vector < int > last ( MAX_CHAR + 1 , - 1 ) ;		  
    n = len ( ss )					      	int n = str . length ( ) ;				      for ( int i = 0 ;						  
    dp = [ - 2 for i in range ( n + 1 ) ]		      	int dp [ n + 1 ] ;					      i < MAX_CHAR + 1 ;					  
    dp [ 0 ] = 1					      	dp [ 0 ] = 1 ;						      i ++ ) last [ i ] = i ;					  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      int n = ss . length ( ) ;					  
	dp [ i ] = 2 * dp [ i - 1 ]			      	i <= n ;						      vector < int > dp ( n + 1 , - 2 ) ;			  
	if last [ ord ( ss [ i - 1 ] ) ] != - 1 :	      	i ++ ) {						      dp [ 0 ] = 1 ;						  
	    dp [ i ] = dp [ i ] - dp [ last [ ord ( ss [ i -  	  dp [ i ] = 2 * dp [ i - 1 ] ;				      for ( int i = 1 ;						  
	last [ ord ( ss [ i - 1 ] ) ] = i - 1		      	  if ( last [ str [ i - 1 ] ] != - 1 ) dp [ i ] = dp [ i ]    i <= n ;							  
    return dp [ n ]					      	  last [ str [ i - 1 ] ] = ( i - 1 ) ;			      i ++ ) {							  
							      	}							    	dp [ i ] = 2 * dp [ i - 1 ] ;				  
							      	return dp [ n ] ;					    	if ( last [ ss [ ss [ i - 1 ] ] ] != - 1 ) dp [ i ] = dp  
							      }								    	last [ ss [ ss [ i - 1 ] ] ] = i - 1 ;			  
							      								      }								  
							      								      return dp [ n ] ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX	      MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX	    MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX	  MINIMUM_OPERATIONS_REQUIRED_SET_ELEMENTS_BINARY_MATRIX
--							      --							    --								  --
def minOperation ( arr ) :				      int minOperation ( bool arr [ N ] [ M ] ) {		    int minOperation ( int * * arr ) {				  script_not_found : None
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  
    for i in range ( N - 1 , - 1 , - 1 ) :		      	for ( int i = N - 1 ;					      for ( int i = N - 1 ;					  
	for j in range ( M - 1 , - 1 , - 1 ) :		      	i >= 0 ;						      i >= 0 ;							  
	    if ( arr [ i ] [ j ] == 0 ) :		      	i -- ) {						      i -- ) {							  
		ans += 1				      	  for ( int j = M - 1 ;					    	for ( int j = M - 1 ;					  
		for k in range ( i + 1 ) :		      	  j >= 0 ;						    	j >= 0 ;						  
		    for h in range ( j + 1 ) :		      	  j -- ) {						    	j -- ) {						  
			if ( arr [ k ] [ h ] == 1 ) :	      	    if ( arr [ i ] [ j ] == 0 ) {			    	  if ( ( arr [ i ] [ j ] == 0 ) ) {			  
			    arr [ k ] [ h ] = 0		      	      ans ++ ;						    	    ans ++ ;						  
			else :				      	      for ( int k = 0 ;					    	    for ( int k = 0 ;					  
			    arr [ k ] [ h ] = 1		      	      k <= i ;						    	    k < i + 1 ;						  
    return ans						      	      k ++ ) {						    	    k ++ ) {						  
							      		for ( int h = 0 ;				    	      for ( int h = 0 ;					  
							      		h <= j ;					    	      h < j + 1 ;					  
							      		h ++ ) {					    	      h ++ ) {						  
							      		  if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0 ; 		if ( ( arr [ k ] [ h ] == 1 ) ) arr [ k ] [ h ] = 
							      		  else arr [ k ] [ h ] = 1 ;			    		else arr [ k ] [ h ] = 1 ;			  
							      		}						    	      }							  
							      	      }							    	    }							  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	return ans ;						      return ans ;						  
							      }								      return arr [ N ] * arr [ M ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_DISTANCE_TWO_POINTS_EARTH			      PROGRAM_DISTANCE_TWO_POINTS_EARTH				    PROGRAM_DISTANCE_TWO_POINTS_EARTH				  PROGRAM_DISTANCE_TWO_POINTS_EARTH
--							      --							    --								  --
def distance ( lat1 , lat2 , lon1 , lon2 ) :		      long double distance ( long double lat1 , long double long1 , double distance ( double lat1 , double lat2 , double lon1 , d script_not_found : None
    lon1 = radians ( lon1 )				      	lat1 = toRadians ( lat1 ) ;				      lon1 = radians ( lon1 ) ;					  
    lon2 = radians ( lon2 )				      	long1 = toRadians ( long1 ) ;				      lon2 = radians ( lon2 ) ;					  
    lat1 = radians ( lat1 )				      	lat2 = toRadians ( lat2 ) ;				      lat1 = radians ( lat1 ) ;					  
    lat2 = radians ( lat2 )				      	long2 = toRadians ( long2 ) ;				      lat2 = radians ( lat2 ) ;					  
    dlon = lon2 - lon1					      	long double dlong = long2 - long1 ;			      double dlon = lon2 - lon1 ;				  
    dlat = lat2 - lat1					      	long double dlat = lat2 - lat1 ;			      double dlat = lat2 - lat1 ;				  
    a = sin ( dlat / 2 ) ** 2 + cos ( lat1 ) * cos ( lat2 ) * 	long double ans = pow ( sin ( dlat / 2 ) , 2 ) + cos ( lat1   double a = sin ( dlat / 2 ) * sin ( dlat / 2 ) + cos ( lat1 
    c = 2 * asin ( sqrt ( a ) )				      	ans = 2 * asin ( sqrt ( ans ) ) ;			      double c = 2 * asin ( sqrt ( a ) ) ;			  
    r = 6371						      	long double R = 6371 ;					      double r = 6371 ;						  
    return ( c * r )					      	ans = ans * R ;						      return ( c * r ) ;					  
							      	return ans ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER		      CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER		    CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER		  CHECK_HALF_STRING_CHARACTER_FREQUENCY_CHARACTER
--							      --							    --								  --
def checkCorrectOrNot ( s ) :				      bool checkCorrectOrNot ( string s ) {			    bool checkCorrectOrNot ( string s ) {			  script_not_found : None
    global MAX_CHAR					      	int count1 [ MAX_CHAR ] = {				      static int MAX_CHAR = 256 ;				  
    count1 = [ 0 ] * MAX_CHAR				      	  0 }							      vector < int > count1 ( MAX_CHAR , 0 ) ;			  
    count2 = [ 0 ] * MAX_CHAR				      	  ;							      vector < int > count2 ( MAX_CHAR , 0 ) ;			  
    n = len ( s )					      	  int count2 [ MAX_CHAR ] = {				      int n = s . length ( ) ;					  
    if n == 1 :						      	    0 }							      if ( n == 1 ) return true ;				  
	return true					      	    ;							      int i = 0 , j = n - 1 ;					  
    i = 0 j = n - 1					      	    int n = s . length ( ) ;				      while ( ( i < j ) ) {					  
    while ( i < j ) :					      	    if ( n == 1 ) return true ;				    	count1 [ s [ i ] - 'a' ] ++ ;				  
	count1 [ ord ( s [ i ] ) - ord ( 'a' ) ] += 1	      	    for ( int i = 0 , j = n - 1 ;			    	count2 [ s [ j ] - 'a' ] ++ ;				  
	count2 [ ord ( s [ j ] ) - ord ( 'a' ) ] += 1	      	    i < j ;						    	i ++ ;							  
	i += 1 j -= 1					      	    i ++ , j -- ) {					    	j -- ;							  
    for i in range ( MAX_CHAR ) :			      	      count1 [ s [ i ] - 'a' ] ++ ;			      }								  
	if count1 [ i ] != count2 [ i ] :		      	      count2 [ s [ j ] - 'a' ] ++ ;			      for ( int i = 0 ;						  
	    return False				      	    }							      i < MAX_CHAR ;						  
    return True						      	    for ( int i = 0 ;					      i ++ ) {							  
							      	    i < MAX_CHAR ;					    	if ( count1 [ i ] != count2 [ i ] ) return false ;	  
							      	    i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false   }								  
							      	    return true ;					      return true ;						  
							      	  }							    }								  
-							      	  -							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_EVEN_FACTORS_NUMBER				      FIND_SUM_EVEN_FACTORS_NUMBER				    FIND_SUM_EVEN_FACTORS_NUMBER				  FIND_SUM_EVEN_FACTORS_NUMBER
--							      --							    --								  --
def sumofFactors ( n ) :				      int sumofFactors ( int n ) {				    double sumofFactors ( int n ) {				  success : None
    if ( n % 2 != 0 ) :					      	if ( n % 2 != 0 ) return 0 ;				      if ( ( n % 2 ) != 0 ) return 0 ;				  
	return 0					      	int res = 1 ;						      double res = 1 ;						  
    res = 1						      	for ( int i = 2 ;					      for ( int i = 2 ;						  
    for i in range ( 2 , ( int ) ( math.sqrt ( n ) ) + 1 ) :  	i <= sqrt ( n ) ;					      i <= ( int ) ( sqrt ( n ) ) ;				  
	count = 0					      	i ++ ) {						      i ++ ) {							  
	curr_sum = 1					      	  int count = 0 , curr_sum = 1 , curr_term = 1 ;	    	int count = 0 ;						  
	curr_term = 1					      	  while ( n % i == 0 ) {				    	double currSum = 1 ;					  
	while ( n % i == 0 ) :				      	    count ++ ;						    	double currTerm = 1 ;					  
	    count = count + 1				      	    n = n / i ;						    	while ( ( n % i ) == 0 ) {				  
	    n = n // i					      	    if ( i == 2 && count == 1 ) curr_sum = 0 ;		    	  count = count + 1 ;					  
	    if ( i == 2 and count == 1 ) :		      	    curr_term *= i ;					    	  n = n / i ;						  
		curr_sum = 0				      	    curr_sum += curr_term ;				    	  if ( ( i == 2 && count == 1 ) ) currSum = 0 ;		  
	    curr_term = curr_term * i			      	  }							    	  currTerm = currTerm * i ;				  
	    curr_sum = curr_sum + curr_term		      	  res *= curr_sum ;					    	  currSum = currSum + currTerm ;			  
	res = res * curr_sum				      	}							    	}							  
    if ( n >= 2 ) :					      	if ( n >= 2 ) res *= ( 1 + n ) ;			    	res = res * currSum ;					  
	res = res * ( 1 + n )				      	return res ;						      }								  
    return res						      }								      if ( ( n >= 2 ) ) res = res * ( 1 + n ) ;			  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_CHECK_ISBN					      PROGRAM_CHECK_ISBN					    PROGRAM_CHECK_ISBN						  PROGRAM_CHECK_ISBN
--							      --							    --								  --
def isValidISBN ( isbn ) :				      bool isValidISBN ( string & isbn ) {			    bool isValidISBN ( string isbn ) {				  error : PROGRAM_CHECK_ISBN.cpp: In function ‘bool
    if len ( isbn ) != 10 :				      	int n = isbn . length ( ) ;				      if ( isbn . length ( ) != 10 ) return false ;		  f_filled(std::__cxx11::string)’: PROGRAM_CHECK_ISB
	return False					      	if ( n != 10 ) return false ;				      int _sum = 0 ;						  N.cpp:40:33: error: invalid conversion from ‘__gnu
    _sum = 0						      	int sum = 0 ;						      for ( int i = 0 ;						  _cxx::__alloc_traits<std::allocator<char>, char>::
    for i in range ( 9 ) :				      	for ( int i = 0 ;					      i < 9 ;							  value_type’ {aka ‘char’} to ‘const char*’ [-fpermi
	if 0 <= int ( isbn [ i ] ) <= 9 :		      	i < 9 ;							      i ++ ) {							  ssive]      if ( 0 <= atoi ( isbn [ i ] ) && i <=
	    _sum += int ( isbn [ i ] ) * ( 10 - i )	      	i ++ ) {						    	if ( 0 <= atoi ( isbn [ i ] ) && i <= 9 ) _sum += atoi (  9 ) _sum += atoi ( isbn [ i ] ) * ( 10 - i ) ;
	else :						      	  int digit = isbn [ i ] - '0' ;			    	else return false ;					  				^ In file included f
	    return False				      	  if ( 0 > digit || 9 < digit ) return false ;		      }								  rom /usr/include/c++/8/cstdlib:75,
    if ( isbn [ 9 ] != 'X' and 0 <= int ( isbn [ 9 ] ) <= 9 ) 	  sum += ( digit * ( 10 - i ) ) ;			      if ( ( isbn [ 9 ] != 'X' && 0 <= atoi ( isbn [ 9 ] ) && isb   from /usr/include/c++/8/ext/string_conversions.h
	return False					      	}							      _sum += isbn [ 9 ] == 'X' ? 10 : atoi ( isbn [ 9 ] ) ;	  :41,			from /usr/include/c++/8/bits
    _sum += 10 if isbn [ 9 ] == 'X' else int ( isbn [ 9 ] )   	char last = isbn [ 9 ] ;				      return ( _sum % 11 == 0 ) ;				  /basic_string.h:6400,			 from /usr/i
    return ( _sum % 11 == 0 )				      	if ( last != 'X' && ( last < '0' || last > '9' ) ) return f }								  nclude/c++/8/string:52,		   from /usr
							      	sum += ( ( last == 'X' ) ? 10 : ( last - '0' ) ) ;	    								  /include/c++/8/bits/locale_classes.h:40,
							      	return ( sum % 11 == 0 ) ;				    								  	  from /usr/include/c++/8/bits/ios_base.h:41
							      }								    								  ,		     from /usr/include/c++/8/ios:42,
							      								    								  		    from /usr/include/c++/8/ostream:
							      								    								  38,		       from /usr/include/c++/8/iostr
							      								    								  eam:39,		   from PROGRAM_CHECK_ISBN.c
							      								    								  pp:8: /usr/include/stdlib.h:104:30: note:   initia
							      								    								  lizing argument 1 of ‘int atoi(const char*)’	exte
							      								    								  rn int atoi (const char *__nptr)
							      								    								   ~~~~~~~~~~~~^~~~~~ PROGRAM_CHECK_ISBN.cpp:40:73:
							      								    								  error: invalid conversion from ‘__gnu_cxx::__alloc
							      								    								  _traits<std::allocator<char>, char>::value_type’ {
							      								    								  aka ‘char’} to ‘const char*’ [-fpermissive]	   i
							      								    								  f ( 0 <= atoi ( isbn [ i ] ) && i <= 9 ) _sum += a
							      								    								  toi ( isbn [ i ] ) * ( 10 - i ) ;
							      								    								  
							      								    								  	 ^ In file included from /usr/include/c++/8/
							      								    								  cstdlib:75,		       from /usr/include/c++
							      								    								  /8/ext/string_conversions.h:41,		   f
							      								    								  rom /usr/include/c++/8/bits/basic_string.h:6400,
							      								    								  		  from /usr/include/c++/8/string:52,
							      								    								  		    from /usr/include/c++/8/bits/loc
							      								    								  ale_classes.h:40,		     from /usr/inclu
							      								    								  de/c++/8/bits/ios_base.h:41,			from
							      								    								   /usr/include/c++/8/ios:42,		       from
							      								    								  /usr/include/c++/8/ostream:38,		  fr
							      								    								  om /usr/include/c++/8/iostream:39,
							      								    								    from PROGRAM_CHECK_ISBN.cpp:8: /usr/include/stdl
							      								    								  ib.h:104:30: note:   initializing argument 1 of ‘i
							      								    								  nt atoi(const char*)’	 extern int atoi (const char
							      								    								   *__nptr)		      ~~~~~~~~~~~~^~~~~~ PRO
							      								    								  GRAM_CHECK_ISBN.cpp:43:54: error: invalid conversi
							      								    								  on from ‘__gnu_cxx::__alloc_traits<std::allocator<
							      								    								  char>, char>::value_type’ {aka ‘char’} to ‘const c
							      								    								  har*’ [-fpermissive]	  if ( ( isbn [ 9 ] != 'X' &
							      								    								  & 0 <= atoi ( isbn [ 9 ] ) && isbn [ 9 ] ) ) retur
							      								    								  n false ;
							      								    								  		^ In file included from /usr/include
							      								    								  /c++/8/cstdlib:75,		      from /usr/incl
							      								    								  ude/c++/8/ext/string_conversions.h:41,
							      								    								  	from /usr/include/c++/8/bits/basic_string.h:
							      								    								  6400,			 from /usr/include/c++/8/str
							      								    								  ing:52,		   from /usr/include/c++/8/b
							      								    								  its/locale_classes.h:40,		    from /us
							      								    								  r/include/c++/8/bits/ios_base.h:41,
							      								    								     from /usr/include/c++/8/ios:42,
							      								    								    from /usr/include/c++/8/ostream:38,
							      								    								       from /usr/include/c++/8/iostream:39,
							      								    								  	   from PROGRAM_CHECK_ISBN.cpp:8: /usr/inclu
							      								    								  de/stdlib.h:104:30: note:   initializing argument
							      								    								  1 of ‘int atoi(const char*)’	extern int atoi (con
							      								    								  st char *__nptr)		     ~~~~~~~~~~~~^~~
							      								    								  ~~~ PROGRAM_CHECK_ISBN.cpp:44:54: error: invalid c
							      								    								  onversion from ‘__gnu_cxx::__alloc_traits<std::all
							      								    								  ocator<char>, char>::value_type’ {aka ‘char’} to ‘
							      								    								  const char*’ [-fpermissive]	 _sum += isbn [ 9 ]
							      								    								  == 'X' ? 10 : atoi ( isbn [ 9 ] ) ;
							      								    								  					  ^ In file
							      								    								  included from /usr/include/c++/8/cstdlib:75,
							      								    								  	      from /usr/include/c++/8/ext/string_con
							      								    								  versions.h:41,		  from /usr/include/
							      								    								  c++/8/bits/basic_string.h:6400,		   f
							      								    								  rom /usr/include/c++/8/string:52,
							      								    								   from /usr/include/c++/8/bits/locale_classes.h:40,
							      								    								  		    from /usr/include/c++/8/bits/ios
							      								    								  _base.h:41,		       from /usr/include/c++
							      								    								  /8/ios:42,		      from /usr/include/c++/
							      								    								  8/ostream:38,			 from /usr/include/c
							      								    								  ++/8/iostream:39,		     from PROGRAM_CH
							      								    								  ECK_ISBN.cpp:8: /usr/include/stdlib.h:104:30: note
							      								    								  :   initializing argument 1 of ‘int atoi(const cha
							      								    								  r*)’	extern int atoi (const char *__nptr)
							      								    								  	     ~~~~~~~~~~~~^~~~~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DICE_THROW_PROBLEM					      DICE_THROW_PROBLEM					    DICE_THROW_PROBLEM						  DICE_THROW_PROBLEM
--							      --							    --								  --
def findWays ( m , n , x ) :				      int findWays ( int m , int n , int x ) {			    int findWays ( int m , int n , int x ) {			  failure : #Results: 6, 10
    table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ]    	int table [ n + 1 ] [ x + 1 ] ;				      vector < vector < int >> table ( n + 1 , vector < int > ( x 
    for j in range ( 1 , min ( m + 1 , x + 1 ) ) :	      	memset ( table , 0 , sizeof ( table ) ) ;		      for ( int i = 0 ;						  
	table [ 1 ] [ j ] = 1				      	for ( int j = 1 ;					      i < n + 1 ;						  
    for i in range ( 2 , n + 1 ) :			      	j <= m && j <= x ;					      i ++ ) {							  
	for j in range ( 1 , x + 1 ) :			      	j ++ ) table [ 1 ] [ j ] = 1 ;				    	for ( int j = 1 ;					  
	    for k in range ( 1 , min ( m + 1 , j ) ) :	      	for ( int i = 2 ;					    	j < min ( m + 1 , x + 1 ) ;				  
		table [ i ] [ j ] += table [ i - 1 ] [ j - k  	i <= n ;						    	j ++ ) {						  
    return table [ - 1 ] [ - 1 ]			      	i ++ ) for ( int j = 1 ;				    	  table [ 1 ] [ j ] = 1 ;				  
							      	j <= x ;						    	}							  
							      	j ++ ) for ( int k = 1 ;				      }								  
							      	k <= m && k < j ;					      for ( int i = 2 ;						  
							      	k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;	      i <= n ;							  
							      	return table [ n ] [ x ] ;				      i ++ ) {							  
							      }								    	for ( int j = 1 ;					  
							      								    	j <= x ;						  
							      								    	j ++ ) {						  
							      								    	  for ( int k = 1 ;					  
							      								    	  k < min ( m + 1 , j ) ;				  
							      								    	  k ++ ) {						  
							      								    	    table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;	  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return table [ table . size ( ) - 1 ] [ table . size ( ) -  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
TEMPLE_OFFERINGS					      TEMPLE_OFFERINGS						    TEMPLE_OFFERINGS						  TEMPLE_OFFERINGS
--							      --							    --								  --
def offeringNumber ( n , templeHeight ) :		      int offeringNumber ( int n , int templeHeight [ ] ) {	    int offeringNumber ( int n , int * templeHeight ) {		  success : None
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	left = 0					      	i < n ;							      i < n ;							  
	right = 0					      	++ i ) {						      i ++ ) {							  
	for j in range ( i - 1 , - 1 , - 1 ) :		      	  int left = 0 , right = 0 ;				    	int left = 0 ;						  
	    if ( templeHeight [ j ] < templeHeight [ j + 1 ]  	  for ( int j = i - 1 ;					    	int right = 0 ;						  
		left += 1				      	  j >= 0 ;						    	for ( int j = i - 1 ;					  
	    else :					      	  -- j ) {						    	j >= 0 ;						  
		break					      	    if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ l 	j -- ) {						  
	for j in range ( i + 1 , n ) :			      	    else break ;					    	  if ( ( templeHeight [ j ] < templeHeight [ j + 1 ] ) )  
	    if ( templeHeight [ j ] < templeHeight [ j - 1 ]  	  }							    	  else break ;						  
		right += 1				      	  for ( int j = i + 1 ;					    	}							  
	    else :					      	  j < n ;						    	for ( int j = i + 1 ;					  
		break					      	  ++ j ) {						    	j < n ;							  
	sum += max ( right , left ) + 1			      	    if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ r 	j ++ ) {						  
    return sum						      	    else break ;					    	  if ( ( templeHeight [ j ] < templeHeight [ j - 1 ] ) )  
							      	  }							    	  else break ;						  
							      	  sum += max ( right , left ) + 1 ;			    	}							  
							      	}							    	sum += max < int > ( right , left ) + 1 ;		  
							      	return sum ;						      }								  
							      }								      return sum ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM   REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM   REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM	  REMOVE_MINIMUM_NUMBER_CHARACTERS_TWO_STRINGS_BECOME_ANAGRAM
--							      --							    --								  --
def remAnagram ( str1 , str2 ) :			      int remAnagram ( string str1 , string str2 ) {		    int remAnagram ( string str1 , string str2 ) {		  script_not_found : None
    count1 = [ 0 ] * CHARS				      	int count1 [ CHARS ] = {				      vector < int > count1 ( CHARS ) ;				  
    count2 = [ 0 ] * CHARS				      	  0 }							      vector < int > count2 ( CHARS ) ;				  
    i = 0						      	  , count2 [ CHARS ] = {				      int i = 0 ;						  
    while i < len ( str1 ) :				      	    0 }							      while ( i < str1 . length ( ) ) {				  
	count1 [ ord ( str1 [ i ] ) - ord ( 'a' ) ] += 1      	    ;							    	count1 [ str1 [ i ] - 'a' ] ++ ;			  
	i += 1						      	    for ( int i = 0 ;					    	i ++ ;							  
    i = 0						      	    str1 [ i ] != '\0' ;				      }								  
    while i < len ( str2 ) :				      	    i ++ ) count1 [ str1 [ i ] - 'a' ] ++ ;		      i = 0 ;							  
	count2 [ ord ( str2 [ i ] ) - ord ( 'a' ) ] += 1      	    for ( int i = 0 ;					      while ( i < str2 . length ( ) ) {				  
	i += 1						      	    str2 [ i ] != '\0' ;				    	count2 [ str2 [ i ] - 'a' ] ++ ;			  
    result = 0						      	    i ++ ) count2 [ str2 [ i ] - 'a' ] ++ ;		    	i ++ ;							  
    for i in range ( 26 ) :				      	    int result = 0 ;					      }								  
	result += abs ( count1 [ i ] - count2 [ i ] )	      	    for ( int i = 0 ;					      int result = 0 ;						  
    return result					      	    i < 26 ;						      for ( int i = 0 ;						  
							      	    i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ;    i < 26 ;							  
							      	    return result ;					      i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ;	  
							      	  }							      return result ;						  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								      return str1 . length ( ) ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE     REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE	    REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE	  REARRANGE_ARRAY_MAXIMUM_MINIMUM_FORM_SET_2_O1_EXTRA_SPACE
--							      --							    --								  --
def rearrange ( arr , n ) :				      void rearrange ( int arr [ ] , int n ) {			    int rearrange ( int * arr , int n ) {			  failure : #Results: 2, 10
    max_idx = n - 1					      	int max_idx = n - 1 , min_idx = 0 ;			      int maxIdx = n - 1 ;					  
    min_idx = 0						      	int max_elem = arr [ n - 1 ] + 1 ;			      int minIdx = 0 ;						  
    max_elem = arr [ n - 1 ] + 1			      	for ( int i = 0 ;					      int maxElem = arr [ n - 1 ] + 1 ;				  
    for i in range ( 0 , n ) :				      	i < n ;							      for ( int i = 0 ;						  
	if i % 2 == 0 :					      	i ++ ) {						      i <= n ;							  
	    arr [ i ] += ( arr [ max_idx ] % max_elem ) * max 	  if ( i % 2 == 0 ) {					      i ++ ) {							  
	    max_idx -= 1				      	    arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem  	if ( i % 2 == 0 ) {					  
	else :						      	    max_idx -- ;					    	  arr [ i ] += ( arr [ maxIdx ] % maxElem ) * maxElem ;	  
	    arr [ i ] += ( arr [ min_idx ] % max_elem ) * max 	  }							    	  maxIdx -- ;						  
	    min_idx += 1				      	  else {						    	}							  
    for i in range ( 0 , n ) :				      	    arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem  	else {							  
	arr [ i ] = arr [ i ] / max_elem		      	    min_idx ++ ;					    	  arr [ i ] += ( arr [ minIdx ] % maxElem ) * maxElem ;	  
							      	  }							    	  minIdx ++ ;						  
							      	}							    	}							  
							      	for ( int i = 0 ;					      }								  
							      	i < n ;							      for ( int i = 0 ;						  
							      	i ++ ) arr [ i ] = arr [ i ] / max_elem ;		      i <= n ;							  
							      }								      i ++ ) arr [ i ] = arr [ i ] / maxElem ;			  
							      								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1	      COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1	    COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1	  COUNT_POSSIBLE_PATHS_TOP_LEFT_BOTTOM_RIGHT_NXM_MATRIX_1
--							      --							    --								  --
def numberOfPaths ( m , n ) :				      int numberOfPaths ( int m , int n ) {			    int numberOfPaths ( int m , int n ) {			  success : None
    count = [ [ 0 for x in range ( m ) ] for y in range ( n ) 	int count [ m ] [ n ] ;					      vector < vector < int >> count ( m , vector < int > ( n , 0 
    for i in range ( m ) :				      	for ( int i = 0 ;					      for ( int y = 0 ;						  
	count [ i ] [ 0 ] = 1 ;				      	i < m ;							      y < n ;							  
    for j in range ( n ) :				      	i ++ ) count [ i ] [ 0 ] = 1 ;				      y ++ ) {							  
	count [ 0 ] [ j ] = 1 ;				      	for ( int j = 0 ;					    	for ( int i = 0 ;					  
    for i in range ( 1 , m ) :				      	j < n ;							    	i < m ;							  
	for j in range ( n ) :				      	j ++ ) count [ 0 ] [ j ] = 1 ;				    	i ++ ) count [ i ] [ 0 ] = 1 ;				  
	    count [ i ] [ j ] = count [ i - 1 ] [ j ] + count 	for ( int i = 1 ;					    	;							  
    return count [ m - 1 ] [ n - 1 ]			      	i < m ;							    	for ( int j = 0 ;					  
							      	i ++ ) {						    	j < n ;							  
							      	  for ( int j = 1 ;					    	j ++ ) count [ 0 ] [ j ] = 1 ;				  
							      	  j < n ;						      }								  
							      	  j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count    for ( int i = 1 ;						  
							      	}							      i < m ;							  
							      	return count [ m - 1 ] [ n - 1 ] ;			      i ++ ) {							  
							      }								    	for ( int j = 0 ;					  
							      								    	j < n ;							  
							      								    	j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count  
							      								      }								  
							      								      return count [ m - 1 ] [ n - 1 ] ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STEINS_ALGORITHM_FOR_FINDING_GCD			      STEINS_ALGORITHM_FOR_FINDING_GCD				    STEINS_ALGORITHM_FOR_FINDING_GCD				  STEINS_ALGORITHM_FOR_FINDING_GCD
--							      --							    --								  --
def gcd ( a , b ) :					      int gcd ( int a , int b ) {				    int gcd ( int a , int b ) {					  script_not_found : None
    if ( a == 0 ) :					      	if ( a == 0 ) return b ;				      if ( ( a == 0 ) ) return b ;				  
	return b					      	if ( b == 0 ) return a ;				      if ( ( b == 0 ) ) return a ;				  
    if ( b == 0 ) :					      	int k ;							      int k = 0 ;						  
	return a					      	for ( k = 0 ;						      while ( ( ( a | b ) & 1 ) == 0 ) {			  
    k = 0						      	( ( a | b ) && 1 ) == 0 ;				    	a = a >> 1 ;						  
    while ( ( ( a | b ) & 1 ) == 0 ) :			      	++ k ) {						    	b = b >> 1 ;						  
	a = a >> 1					      	  a >>= 1 ;						    	k = k + 1 ;						  
	b = b >> 1					      	  b >>= 1 ;						      }								  
	k = k + 1					      	}							      while ( ( ( a & 1 ) == 0 ) ) a = a >> 1 ;			  
    while ( ( a & 1 ) == 0 ) :				      	while ( ( a > 1 ) == 0 ) a >>= 1 ;			      while ( ( b != 0 ) ) {					  
	a = a >> 1					      	do {							    	while ( ( ( b & 1 ) == 0 ) ) b = b >> 1 ;		  
    while ( b != 0 ) :					      	  while ( ( b > 1 ) == 0 ) b >>= 1 ;			    	if ( ( a > b ) ) {					  
	while ( ( b & 1 ) == 0 ) :			      	  if ( a > b ) swap ( a , b ) ;				    	  int temp = a ;					  
	    b = b >> 1					      	  b = ( b - a ) ;					    	  a = b ;						  
	if ( a > b ) :					      	}							    	  b = temp ;						  
	    temp = a					      	while ( b != 0 ) ;					    	}							  
	    a = b					      	return a << k ;						    	b = ( b - a ) ;						  
	    b = temp					      }								      }								  
	b = ( b - a )					      								      return ( a << k ) ;					  
    return ( a << k )					      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN DYNAMIC_PROGRAMMING_SET_28_MINIMUM_INSERTIONS_TO_FORM_A_PALIN
--							      --							    --								  --
def findMinInsertions ( str , l , h ) :			      int findMinInsertions ( char str [ ] , int l , int h ) {	    int findMinInsertions ( string str , int l , int h ) {	  success : None
    if ( l > h ) :					      	if ( l > h ) return INT_MAX ;				      if ( ( l > h ) ) return INT_MAX ;				  
	return sys.maxsize				      	if ( l == h ) return 0 ;				      if ( ( l == h ) ) return 0 ;				  
    if ( l == h ) :					      	if ( l == h - 1 ) return ( str [ l ] == str [ h ] ) ? 0 : 1   if ( ( l == h - 1 ) ) return ( str [ l ] == str [ h ] ) ? 0 
	return 0					      	return ( str [ l ] == str [ h ] ) ? findMinInsertions ( str   if ( ( str [ l ] == str [ h ] ) ) return findMinInsertions  
    if ( l == h - 1 ) :					      }								      else return ( min ( findMinInsertions ( str , l , h - 1 ) , 
	return 0 if ( str [ l ] == str [ h ] ) else 1	      								      return l * l ;						  
    if ( str [ l ] == str [ h ] ) :			      								      return l * l * l * l * l * l * l * l * l * l * l * l * l *  
	return findMinInsertions ( str , l + 1 , h - 1 )      								    }								  
    else :						      								    								  
	return ( min ( findMinInsertions ( str , l , h - 1 )  								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1	      MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1		    MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1		  MINIMUM_LENGTH_SUBARRAY_SUM_GREATER_GIVEN_VALUE_1
--							      --							    --								  --
def smallestSubWithSum ( arr , n , x ) :		      int smallestSubWithSum ( int arr [ ] , int n , int x ) {	    int smallestSubWithSum ( int * arr , int n , int x ) {	  failure : #Results: 8, 10
    curr_sum = 0					      	int curr_sum = 0 , min_len = n + 1 ;			      int currSum = 0 ;						  
    min_len = n + 1					      	int start = 0 , end = 0 ;				      int minLen = n + 1 ;					  
    start = 0						      	while ( end < n ) {					      int start = 0 ;						  
    end = 0						      	  while ( curr_sum <= x && end < n ) {			      int end = 0 ;						  
    while ( end < n ) :					      	    if ( curr_sum <= 0 && x > 0 ) {			      while ( ( end < n ) && ( currSum <= x && end < n ) ) {	  
	while ( curr_sum <= x and end < n ) :		      	      start = end ;					    	if ( ( currSum <= 0 && x > 0 ) ) {			  
	    if ( curr_sum <= 0 and x > 0 ) :		      	      curr_sum = 0 ;					    	  start = end ;						  
		start = end				      	    }							    	  currSum = 0 ;						  
		curr_sum = 0				      	    curr_sum += arr [ end ++ ] ;			    	}							  
	    curr_sum += arr [ end ]			      	  }							    	currSum += arr [ end ] ;				  
	    end += 1					      	  while ( curr_sum > x && start < n ) {			    	end ++ ;						  
	while ( curr_sum > x and start < n ) :		      	    if ( end - start < min_len ) min_len = end - start ;      }								  
	    if ( end - start < min_len ) :		      	    curr_sum -= arr [ start ++ ] ;			      while ( ( currSum > x && start < n ) ) {			  
		min_len = end - start			      	  }							    	if ( ( end - start < minLen ) ) minLen = end - start ;	  
	    curr_sum -= arr [ start ]			      	}							    	currSum -= arr [ start ] ;				  
	    start += 1					      	return min_len ;					    	start ++ ;						  
    return min_len					      }								      }								  
							      								      return minLen ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_ALMOST_SORTED_ARRAY				      SEARCH_ALMOST_SORTED_ARRAY				    SEARCH_ALMOST_SORTED_ARRAY					  SEARCH_ALMOST_SORTED_ARRAY
--							      --							    --								  --
def binarySearch ( arr , l , r , x ) :			      int binarySearch ( int arr [ ] , int l , int r , int x ) {    int binarySearch ( int * arr , int l , int r , int x ) {	  success : None
    if ( r >= l ) :					      	if ( r >= l ) {						      if ( ( r >= l ) && ( r <= r ) ) {				  
	mid = int ( l + ( r - l ) / 2 )			      	  int mid = l + ( r - l ) / 2 ;				    	int mid = ( int ) ( l + ( r - l ) / 2 ) ;		  
	if ( arr [ mid ] == x ) : return mid		      	  if ( arr [ mid ] == x ) return mid ;			    	if ( ( arr [ mid ] == x ) ) return mid ;		  
	if ( mid > l and arr [ mid - 1 ] == x ) :	      	  if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) 	if ( ( mid > l ) && ( arr [ mid - 1 ] == x ) ) return ( m 
	    return ( mid - 1 )				      	  if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) 	if ( ( mid < r ) && ( arr [ mid + 1 ] == x ) ) return ( m 
	if ( mid < r and arr [ mid + 1 ] == x ) :	      	  if ( arr [ mid ] > x ) return binarySearch ( arr , l , mi 	if ( ( arr [ mid ] > x ) ) return binarySearch ( arr , l  
	    return ( mid + 1 )				      	  return binarySearch ( arr , mid + 2 , r , x ) ;	    	return binarySearch ( arr , mid + 2 , r , x ) ;		  
	if ( arr [ mid ] > x ) :			      	}							      }								  
	    return binarySearch ( arr , l , mid - 2 , x )     	return - 1 ;						      return - 1 ;						  
	return binarySearch ( arr , mid + 2 , r , x )	      }								      return l * l ;						  
    return - 1						      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING    SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING    SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING	  SPLIT_NUMERIC_ALPHABETIC_AND_SPECIAL_SYMBOLS_FROM_A_STRING
--							      --							    --								  --
def splitString ( str ) :				      void splitString ( string str ) {				    string splitString ( string str ) {				  script_not_found : None
    alpha = ""						      	string alpha , num , special ;				      string alpha ;						  
    num = ""						      	for ( int i = 0 ;					      string num ;						  
    special = ""					      	i < str . length ( ) ;					      string special ;						  
    for i in range ( len ( str ) ) :			      	i ++ ) {						      for ( int i = 0 ;						  
	if ( str [ i ].isdigit ( ) ) :			      	  if ( isdigit ( str [ i ] ) ) num . push_back ( str [ i ]    i < str . length ( ) ;					  
	    num = num + str [ i ]			      	  else if ( ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) || ( s   i ++ ) {							  
	elif ( ( str [ i ] >= 'A' and str [ i ] <= 'Z' ) or ( 	  else special . push_back ( str [ i ] ) ;		    	if ( isdigit ( str [ i ] ) ) num = num + str [ i ] ;	  
	    alpha += str [ i ]				      	}							    	else if ( ( ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) || ( 
	else :						      	cout << alpha << endl ;					    	else special += str [ i ] ;				  
	    special += str [ i ]			      	cout << num << endl ;					      }								  
    print ( alpha )					      	cout << special << endl ;				      cout << alpha << endl ;					  
    print ( num )					      }								      cout << num << endl ;					  
    print ( special )					      								      cout << special << endl ;					  
-							      -								      return alpha + num + num + num + num + num + num + num + nu -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M	      DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M	    DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M		  DIFFERENT_WAYS_SUM_N_USING_NUMBERS_GREATER_EQUAL_M
--							      --							    --								  --
def numberofways ( n , m ) :				      int numberofways ( int n , int m ) {			    int numberofWays ( int n , int m ) {			  failure : #Results: 8, 10
    dp = np.zeros ( ( n + 2 , n + 2 ) )			      	int dp [ n + 2 ] [ n + 2 ] ;				      vector < vector < int >> dp ( n + 2 , vector < int > ( n +  
    dp [ 0 ] [ n + 1 ] = 1				      	memset ( dp , 0 , sizeof ( dp ) ) ;			      dp [ 0 ] [ n + 1 ] = 1 ;					  
    for k in range ( n , m - 1 , - 1 ) :		      	dp [ 0 ] [ n + 1 ] = 1 ;				      for ( int k = n ;						  
	for i in range ( n + 1 ) :			      	for ( int k = n ;					      k >= m ;							  
	    dp [ i ] [ k ] = dp [ i ] [ k + 1 ]		      	k >= m ;						      -- k ) {							  
	    if ( i - k >= 0 ) :				      	k -- ) {						    	for ( int i = 0 ;					  
		dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i -  	  for ( int i = 0 ;					    	i < n + 1 ;						  
    return dp [ n ] [ m ]				      	  i <= n ;						    	++ i ) {						  
							      	  i ++ ) {						    	  dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ;			  
							      	    dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ;		    	  if ( ( i - k >= 0 ) ) dp [ i ] [ k ] = ( dp [ i ] [ k ] 
							      	    if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + d 	}							  
							      	  }							      }								  
							      	}							      return dp [ n ] [ m ] ;					  
							      	return dp [ n ] [ m ] ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_INSERTIONS_SORT_ARRAY				      MINIMUM_INSERTIONS_SORT_ARRAY				    MINIMUM_INSERTIONS_SORT_ARRAY				  MINIMUM_INSERTIONS_SORT_ARRAY
--							      --							    --								  --
def minInsertionStepToSortArray ( arr , N ) :		      int minInsertionStepToSortArray ( int arr [ ] , int N ) {	    int minInsertionStepToSortArray ( int * arr , int N ) {	  error : MINIMUM_INSERTIONS_SORT_ARRAY.cpp: In func
    lis = [ 0 ] * N					      	int lis [ N ] ;						      int lis [ N ] ;						  tion ‘int f_filled(int*, int)’: MINIMUM_INSERTIONS
    for i in range ( N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  _SORT_ARRAY.cpp:51:1: error: expected primary-expr
	lis [ i ] = 1					      	i < N ;							      i < N ;							  ession before ‘int’  int main() {  ^~~ MINIMUM_INS
    for i in range ( 1 , N ) :				      	i ++ ) lis [ i ] = 1 ;					      i ++ ) lis [ i ] = 1 ;					  ERTIONS_SORT_ARRAY.cpp:49:617: error: expected ‘;’
	for j in range ( i ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						   before ‘int’	   return N * N * N * N * N * N * N
	    if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ 	i < N ;							      i < N ;							  * N * N * N * N * N * N * N * N * N * N * N * N *
		lis [ i ] = lis [ j ] + 1		      	i ++ ) for ( int j = 0 ;				      i ++ ) for ( int j = 0 ;					  N * N * N * N * N * N * N * N * N * N * N * N * N
    max = 0						      	j < i ;							      j < i ;							  * N * N * N * N * N * N * N * N * N * N * N * N *
    for i in range ( N ) :				      	j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ]   j ++ ) if ( ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j N * N * N * N * N * N * N * N * N * N * N * N * N
	if ( max < lis [ i ] ) :			      	int max = 0 ;						      int max = 0 ;						  * N * N * N * N * N * N * N * N * N * N * N * N *
	    max = lis [ i ]				      	for ( int i = 0 ;					      for ( int i = 0 ;						  N * N * N * N * N * N * N * N * N * N * N * N * N
    return ( N - max )					      	i < N ;							      i < N ;							  * N * N * N * N * N * N * N * N * N * N * N * N *
							      	i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;		      i ++ ) if ( ( max < lis [ i ] ) ) max = lis [ i ] ;	  N * N * N * N * N * N * N * N * N * N * N * N * N
							      	return ( N - max ) ;					      return ( N - max ) ;					  * N * N * N * N * N * N * N * N * N * N * N * N *
							      }								      return N * N * N * N * N * N * N * N * N * N * N * N * N *  N * N * N * N * N * N * N * N * N * N * N * N * N
							      								    								  * N * N * N * N * N * N * N * N * N * N * N * N *
							      								    								  N * N * N * N * N * N * N * N *
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  						   ^
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  		    ; MINIMUM_INSERTIONS_SORT_ARRAY.
							      								    								  cpp:51:1:  int main() {  ~~~
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  
							      								    								  					     MINIMUM
							      								    								  _INSERTIONS_SORT_ARRAY.cpp:51:12: error: a functio
							      								    								  n-definition is not allowed here before ‘{’ token
							      								    								   int main() {		    ^ MINIMUM_INSERTIONS_SOR
							      								    								  T_ARRAY.cpp:64:1: error: expected ‘}’ at end of in
							      								    								  put  }  ^ MINIMUM_INSERTIONS_SORT_ARRAY.cpp:34:36:
							      								    								   note: to match this ‘{’  int f_filled ( int * arr
							      								    								   , int N ) {					   ^
							      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1		      COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1		    COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1		  COUNT_POSSIBLE_DECODINGS_GIVEN_DIGIT_SEQUENCE_1
--							      --							    --								  --
def countDecodingDP ( digits , n ) :			      int countDecodingDP ( char * digits , int n ) {		    int countDecodingDP ( string digits , int n ) {		  script_not_found : None
    count = [ 0 ] * ( n + 1 )				      	int count [ n + 1 ] ;					      vector < int > count ( n + 1 , 0 ) ;			  
    count [ 0 ] = 1					      	count [ 0 ] = 1 ;					      count [ 0 ] = 1 ;						  
    count [ 1 ] = 1					      	count [ 1 ] = 1 ;					      count [ 1 ] = 1 ;						  
    for i in range ( 2 , n + 1 ) :			      	if ( digits [ 0 ] == '0' ) return 0 ;			      for ( int i = 2 ;						  
	count [ i ] = 0					      	for ( int i = 2 ;					      i <= n ;							  
	if ( digits [ i - 1 ] > '0' ) :			      	i <= n ;						      i ++ ) {							  
	    count [ i ] = count [ i - 1 ]		      	i ++ ) {						    	count [ i ] = 0 ;					  
	if ( digits [ i - 2 ] == '1' or ( digits [ i - 2 ] == 	  count [ i ] = 0 ;					    	if ( ( digits [ i - 1 ] > '0' ) ) count [ i ] = count [ i 
	    count [ i ] += count [ i - 2 ]		      	  if ( digits [ i - 1 ] > '0' ) count [ i ] = count [ i - 1 	if ( ( digits [ i - 2 ] == '1' ) || ( digits [ i - 2 ] == 
    return count [ n ]					      	  if ( digits [ i - 2 ] == '1' || ( digits [ i - 2 ] == '2'   }								  
							      	}							      return count [ n ] ;					  
							      	return count [ n ] ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1		      FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1		    FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1			  FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_1
--							      --							    --								  --
def findTriplets ( arr , n ) :				      void findTriplets ( int arr [ ] , int n ) {		    int findTriplets ( int * arr , int n ) {			  script_not_found : None
    found = False					      	bool found = false ;					      bool found = false ;					  
    for i in range ( n - 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	s = set ( )					      	i < n - 1 ;						      i < n - 1 ;						  
	for j in range ( i + 1 , n ) :			      	i ++ ) {						      i ++ ) {							  
	    x = - ( arr [ i ] + arr [ j ] )		      	  unordered_set < int > s ;				    	set < int > s ;						  
	    if x in s :					      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
		print ( x , arr [ i ] , arr [ j ] )	      	  j < n ;						    	j < n ;							  
		found = True				      	  j ++ ) {						    	j ++ ) {						  
	    else :					      	    int x = - ( arr [ i ] + arr [ j ] ) ;		    	  int x = - ( arr [ i ] + arr [ j ] ) ;			  
		s.add ( arr [ j ] )			      	    if ( s . find ( x ) != s . end ( ) ) {		    	  if ( s . count ( x ) ) {				  
    if found == False :					      	      printf ( "%d %d %d\n" , x , arr [ i ] , arr [ j ] ) ; 	    cout << x << " " << arr [ i ] << " " << arr [ j ] <<  
	print ( "No Triplet Found" )			      	      found = true ;					    	    found = true ;					  
							      	    }							    	  }							  
							      	    else s . insert ( arr [ j ] ) ;			    	  else s . insert ( arr [ j ] ) ;			  
							      	  }							    	}							  
							      	}							      }								  
							      	if ( found == false ) cout << " No Triplet Found" << endl ;   if ( found == false ) cout << "No Triplet Found" << endl ;  
							      }								      return 0 ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1		      FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1		    FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1			  FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1
--							      --							    --								  --
def countRotations ( arr , low , high ) :		      int countRotations ( int arr [ ] , int low , int high ) {	    int countRotations ( int * arr , int low , int high ) {	  error : FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1
    if ( high < low ) :					      	if ( high < low ) return 0 ;				      if ( ( high < low ) ) return 0 ;				  .cpp: In function ‘int f_filled(int*, int, int)’:
	return 0					      	if ( high == low ) return low ;				      if ( ( high == low ) ) return low ;			  FIND_ROTATION_COUNT_ROTATED_SORTED_ARRAY_1.cpp:32:
    if ( high == low ) :				      	int mid = low + ( high - low ) / 2 ;			      double mid = low + ( high - low ) / 2 ;			  40: error: invalid types ‘int*[double]’ for array
	return low					      	if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return (   mid = ( int ) mid ;					  subscript    if ( ( mid < high ) && arr [ mid + 1
    mid = low + ( high - low ) / 2			      	if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mi   if ( ( mid < high ) && arr [ mid + 1 ] < arr [ mid ] ) retu ] < arr [ mid ] ) return ( mid + 1 ) ;
    mid = int ( mid )					      	if ( arr [ high ] > arr [ mid ] ) return countRotations ( a   if ( ( mid > low ) && arr [ mid ] < arr [ mid - 1 ] ) retur 			       ^ FIND_ROTATION_COUNT
    if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) :     	return countRotations ( arr , mid + 1 , high ) ;	      if ( ( arr [ high ] > arr [ mid ] ) ) return countRotations _ROTATED_SORTED_ARRAY_1.cpp:32:54: error: invalid
	return ( mid + 1 )				      }								      return countRotations ( arr , mid + 1 , high ) ;		  types ‘int*[double]’ for array subscript    if ( (
    if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) :      								    }								   mid < high ) && arr [ mid + 1 ] < arr [ mid ] ) r
	return mid					      								    								  eturn ( mid + 1 ) ;
    if ( arr [ high ] > arr [ mid ] ) :			      								    								  			  ^ FIND_ROTATION_COUNT_ROTA
	return countRotations ( arr , low , mid - 1 )	      								    								  TED_SORTED_ARRAY_1.cpp:33:35: error: invalid types
    return countRotations ( arr , mid + 1 , high )	      								    								   ‘int*[double]’ for array subscript	 if ( ( mid
							      								    								  > low ) && arr [ mid ] < arr [ mid - 1 ] ) return
							      								    								  mid ;					   ^ FIND_RO
							      								    								  TATION_COUNT_ROTATED_SORTED_ARRAY_1.cpp:33:53: err
							      								    								  or: invalid types ‘int*[double]’ for array subscri
							      								    								  pt	if ( ( mid > low ) && arr [ mid ] < arr [ mi
							      								    								  d - 1 ] ) return mid ;
							      								    								  			    ^ FIND_ROTATION_COUNT_RO
							      								    								  TATED_SORTED_ARRAY_1.cpp:34:35: error: invalid typ
							      								    								  es ‘int*[double]’ for array subscript	   if ( ( ar
							      								    								  r [ high ] > arr [ mid ] ) ) return f_filled ( arr
							      								    								   , low , mid - 1 ) ;
							      								    								  	^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1		      CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1		    CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1		  CONVERT_SUBSTRINGS_LENGTH_K_BASE_B_DECIMAL_1
--							      --							    --								  --
def substringConversions ( str1 , k , b ) :		      int substringConversions ( string str , int k , int b ) {	    int substringConversions ( string str1 , int k , int b ) {	  script_not_found : None
    for i in range ( 0 , len ( str1 ) - k + 1 ) :	      	int i = 0 , sum = 0 , counter = k - 1 ;			      for ( int i = 0 ;						  
	sub = str1 [ i : k + i ]			      	for ( i ;						      i <= str1 . length ( ) - k + 1 ;				  
	Sum = 0						      	i < k ;							      i ++ ) {							  
	counter = 0					      	i ++ ) {						    	string sub = str1 . substr ( i , k + i - i ) ;		  
	for i in range ( len ( sub ) - 1 , - 1 , - 1 ) :      	  sum = sum + ( ( str . at ( i ) - '0' ) * pow ( b , counte 	int Sum = 0 ;						  
	    Sum = ( Sum + ( ( ord ( sub [ i ] ) - ord ( '0' ) 	  counter -- ;						    	int counter = 0 ;					  
	    counter += 1				      	}							    	for ( int i = sub . length ( ) - 1 ;			  
	print ( Sum , end = " " )			      	cout << sum << " " ;					    	i >= 0 ;						  
							      	int prev = sum ;					    	i -- ) {						  
							      	sum = 0 , counter = 0 ;					    	  Sum = ( Sum + ( ( sub [ i ] - '0' ) * pow ( b , counter 
							      	for ( i ;						    	  counter ++ ;						  
							      	i < str . size ( ) ;					    	}							  
							      	i ++ ) {						    	cout << Sum << " " ;					  
							      	  sum = prev - ( ( str . at ( i - k ) - '0' ) * pow ( b , k   }								  
							      	  sum = sum * b ;					      return k ;						  
							      	  sum = sum + ( str . at ( i ) - '0' ) ;		      return k * k ;						  
							      	  cout << sum << " " ;					      return k * k ;						  
							      	  prev = sum ;						      return k * k * k * k * k * k * k * k * k * k * k * k * k *  
							      	  counter ++ ;						    								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1   REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1   REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1	  REPLACE_OCCURRENCES_STRING_AB_C_WITHOUT_USING_EXTRA_SPACE_1
--							      --							    --								  --
def translate ( st ) :					      void translate ( char * str ) {				    void translate ( string st ) {				  script_not_found : None
    l = len ( st )					      	int len = strlen ( str ) ;				      int l = st . length ( ) ;					  
    if ( l < 2 ) :					      	if ( len < 2 ) return ;					      if ( ( l < 2 ) ) return ;					  
	return						      	int i = 0 ;						      int i = 0 ;						  
    i = 0						      	int j = 0 ;						      int j = 0 ;						  
    j = 0						      	while ( j < len - 1 ) {					      while ( ( j < l - 1 ) ) {					  
    while ( j < l - 1 ) :				      	  if ( str [ j ] == 'A' && str [ j + 1 ] == 'B' ) {	    	if ( ( st [ j ] == 'A' && st [ j + 1 ] == 'B' ) ) {	  
	if ( st [ j ] == 'A' and st [ j + 1 ] == 'B' ) :      	    j = j + 2 ;						    	  j += 2 ;						  
	    j += 2					      	    str [ i ++ ] = 'C' ;				    	  st [ i ] = 'C' ;					  
	    st [ i ] = 'C'				      	    continue ;						    	  i ++ ;						  
	    i += 1					      	  }							    	  continue ;						  
	    continue					      	  str [ i ++ ] = str [ j ++ ] ;				    	}							  
	st [ i ] = st [ j ]				      	}							    	st [ i ] = st [ j ] ;					  
	i += 1						      	if ( j == len - 1 ) str [ i ++ ] = str [ j ] ;		    	i ++ ;							  
	j += 1						      	str [ i ] = ' ' ;					    	j ++ ;							  
    if ( j == l - 1 ) :					      }								      }								  
	st [ i ] = st [ j ]				      								      if ( ( j == l - 1 ) ) {					  
	i += 1						      								    	st [ i ] = st [ j ] ;					  
    st [ i ] = ' '					      								    	i ++ ;							  
    st [ l - 1 ] = ' '					      								      }								  
							      								      st [ i ] = ' ' ;						  
							      								      st [ l - 1 ] = ' ' ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1		      SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1		    SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1		  SUM_NODES_K_TH_LEVEL_TREE_REPRESENTED_STRING_1
--							      --							    --								  --
def sumAtKthLevel ( tree , k , i , level ) :		      int sumAtKthLevel ( string tree , int k , int & i , int level int sumAtKthLevel ( string tree , int k , vector < int > :: i script_not_found : None
    if ( tree [ i [ 0 ] ] == '(' ) :			      	if ( tree [ i ++ ] == '(' ) {				      if ( ( * i ) == '(' ) {					  
	i [ 0 ] += 1					      	  if ( tree [ i ] == ')' ) return 0 ;			    	i [ 0 ] ++ ;						  
	if ( tree [ i [ 0 ] ] == ')' ) :		      	  int sum = 0 ;						    	if ( ( * i ) == ')' ) return 0 ;			  
	    return 0					      	  if ( level == k ) sum = tree [ i ] - '0' ;		    	int sum = 0 ;						  
	sum = 0						      	  int leftsum = sumAtKthLevel ( tree , k , ++ i , level + 1 	if ( ( level == k ) ) sum = atoi ( ( * i ) [ 0 ] . c_str  
	if ( level == k ) :				      	  int rightsum = sumAtKthLevel ( tree , k , ++ i , level +  	i [ 0 ] ++ ;						  
	    sum = int ( tree [ i [ 0 ] ] )		      	  ++ i ;						    	int leftsum = sumAtKthLevel ( tree , k , i , level + 1 )  
	i [ 0 ] += 1					      	  return sum + leftsum + rightsum ;			    	i [ 0 ] ++ ;						  
	leftsum = sumAtKthLevel ( tree , k , i , level + 1 )  	}							    	int rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) 
	i [ 0 ] += 1					      }								    	i [ 0 ] ++ ;						  
	rightsum = sumAtKthLevel ( tree , k , i , level + 1 ) 								    	return sum + leftsum + rightsum ;			  
	i [ 0 ] += 1					      								      }								  
	return sum + leftsum + rightsum			      								      return 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 *  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1	      FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1		    FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1		  FIND_MINIMUM_NUMBER_OF_COINS_THAT_MAKE_A_CHANGE_1
--							      --							    --								  --
def minCoins ( coins , m , V ) :			      int minCoins ( int coins [ ] , int m , int V ) {		    int minCoins ( int * coins , int m , int V ) {		  success : None
    table = [ 0 for i in range ( V + 1 ) ]		      	int table [ V + 1 ] ;					      int table [ V + 1 ] ;					  
    table [ 0 ] = 0					      	table [ 0 ] = 0 ;					      memset ( table , 0 , V + 1 ) ;				  
    for i in range ( 1 , V + 1 ) :			      	for ( int i = 1 ;					      table [ 0 ] = 0 ;						  
	table [ i ] = sys.maxsize			      	i <= V ;						      for ( int i = 1 ;						  
    for i in range ( 1 , V + 1 ) :			      	i ++ ) table [ i ] = INT_MAX ;				      i <= V ;							  
	for j in range ( m ) :				      	for ( int i = 1 ;					      i ++ ) table [ i ] = INT_MAX ;				  
	    if ( coins [ j ] <= i ) :			      	i <= V ;						      for ( int i = 1 ;						  
		sub_res = table [ i - coins [ j ] ]	      	i ++ ) {						      i <= V ;							  
		if ( sub_res != sys.maxsize and sub_res + 1 < 	  for ( int j = 0 ;					      i ++ ) {							  
		    table [ i ] = sub_res + 1		      	  j < m ;						    	for ( int j = 0 ;					  
    return table [ V ]					      	  j ++ ) if ( coins [ j ] <= i ) {			    	j < m ;							  
							      	    int sub_res = table [ i - coins [ j ] ] ;		    	j ++ ) {						  
							      	    if ( sub_res != INT_MAX && sub_res + 1 < table [ i ] )  	  if ( ( coins [ j ] <= i ) ) {				  
							      	  }							    	    int subRes = table [ i - coins [ j ] ] ;		  
							      	}							    	    if ( ( subRes != INT_MAX ) && ( subRes + 1 < table [  
							      	return table [ V ] ;					    	  }							  
							      }								    	}							  
							      								      }								  
							      								      return table [ V ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY	      FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY	    FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY		  FIND_MINIMUM_ELEMENT_IN_A_SORTED_AND_ROTATED_ARRAY
--							      --							    --								  --
def findMin ( arr , low , high ) :			      int findMin ( int arr [ ] , int low , int high ) {	    int findMin ( int * arr , int low , int high ) {		  success : None
    if high < low :					      	if ( high < low ) return arr [ 0 ] ;			      if ( high < low ) return arr [ 0 ] ;			  
	return arr [ 0 ]				      	if ( high == low ) return arr [ low ] ;			      if ( high == low ) return arr [ low ] ;			  
    if high == low :					      	int mid = low + ( high - low ) / 2 ;			      int mid = ( int ) ( ( low + high ) / 2 ) ;		  
	return arr [ low ]				      	if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return a   if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return a 
    mid = int ( ( low + high ) / 2 )			      	if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return ar   if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return ar 
    if mid < high and arr [ mid + 1 ] < arr [ mid ] :	      	if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , lo   if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , lo 
	return arr [ mid + 1 ]				      	return findMin ( arr , mid + 1 , high ) ;		      return findMin ( arr , mid + 1 , high ) ;			  
    if mid > low and arr [ mid ] < arr [ mid - 1 ] :	      }								    }								  
	return arr [ mid ]				      								    								  
    if arr [ high ] > arr [ mid ] :			      								    								  
	return findMin ( arr , low , mid - 1 )		      								    								  
    return findMin ( arr , mid + 1 , high )		      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS		      FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS		    FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS			  FIND_RELATIVE_COMPLEMENT_TWO_SORTED_ARRAYS
--							      --							    --								  --
def relativeComplement ( arr1 , arr2 , n , m ) :	      void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n int relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n  script_not_found : None
    i = 0						      	int i = 0 , j = 0 ;					      int i = 0 ;						  
    j = 0						      	while ( i < n && j < m ) {				      int j = 0 ;						  
    while ( i < n and j < m ) :				      	  if ( arr1 [ i ] < arr2 [ j ] ) {			      while ( ( i < n ) && ( j < m ) ) {			  
	if ( arr1 [ i ] < arr2 [ j ] ) :		      	    cout << arr1 [ i ] << " " ;				    	if ( ( arr1 [ i ] < arr2 [ j ] ) ) {			  
	    print ( arr1 [ i ] , "" , end = "" )	      	    i ++ ;						    	  cout << arr1 [ i ] << " " << " " ;			  
	    i += 1					      	  }							    	  i ++ ;						  
	elif ( arr1 [ i ] > arr2 [ j ] ) :		      	  else if ( arr1 [ i ] > arr2 [ j ] ) {			    	}							  
	    j += 1					      	    j ++ ;						    	else if ( ( arr1 [ i ] > arr2 [ j ] ) ) {		  
	elif ( arr1 [ i ] == arr2 [ j ] ) :		      	  }							    	  j ++ ;						  
	    i += 1					      	  else if ( arr1 [ i ] == arr2 [ j ] ) {		    	}							  
	    j += 1					      	    i ++ ;						    	else if ( ( arr1 [ i ] == arr2 [ j ] ) ) {		  
    while ( i < n ) :					      	    j ++ ;						    	  i ++ ;						  
	print ( arr1 [ i ] , "" , end = "" )		      	  }							    	  j ++ ;						  
							      	}							    	}							  
							      	while ( i < n ) cout << arr1 [ i ] << " " ;		      }								  
							      }								      while ( ( i < n ) ) {					  
							      								    	cout << arr1 [ i ] << " " << " " ;			  
							      								      }								  
							      								      return i ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUBARRAY_WITH_GIVEN_SUM_1				      FIND_SUBARRAY_WITH_GIVEN_SUM_1				    FIND_SUBARRAY_WITH_GIVEN_SUM_1				  FIND_SUBARRAY_WITH_GIVEN_SUM_1
--							      --							    --								  --
def subArraySum ( arr , n , sum ) :			      int subArraySum ( int arr [ ] , int n , int sum ) {	    int subArraySum ( int * arr , int n , int sum ) {		  success : None
    curr_sum = arr [ 0 ]				      	int curr_sum = arr [ 0 ] , start = 0 , i ;		      int currSum = arr [ 0 ] ;					  
    start = 0						      	for ( i = 1 ;						      int start = 0 ;						  
    i = 1						      	i <= n ;						      int i = 1 ;						  
    while i <= n :					      	i ++ ) {						      while ( i <= n ) {					  
	while curr_sum > sum and start < i - 1 :	      	  while ( curr_sum > sum && start < i - 1 ) {		    	while ( currSum > sum && start < i - 1 ) {		  
	    curr_sum = curr_sum - arr [ start ]		      	    curr_sum = curr_sum - arr [ start ] ;		    	  currSum = currSum - arr [ start ] ;			  
	    start += 1					      	    start ++ ;						    	  start ++ ;						  
	if curr_sum == sum :				      	  }							    	}							  
	    print ( "Sum found between indexes" )	      	  if ( curr_sum == sum ) {				    	if ( currSum == sum ) {					  
	    print ( "%d and %d" % ( start , i - 1 ) )	      	    cout << "Sum found between indexes " << start << " and  	  cout << "Sum found between indexes" << endl ;		  
	    return 1					      	    return 1 ;						    	  cout << start << " and " << i - 1 << endl ;		  
	if i < n :					      	  }							    	  return 1 ;						  
	    curr_sum = curr_sum + arr [ i ]		      	  if ( i < n ) curr_sum = curr_sum + arr [ i ] ;	    	}							  
	i += 1						      	}							    	if ( i < n ) currSum = currSum + arr [ i ] ;		  
    print ( "No subarray found" )			      	cout << "No subarray found" ;				    	i ++ ;							  
    return 0						      	return 0 ;						      }								  
							      }								      cout << "No subarray found" << endl ;			  
							      								      return 0 ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3	  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_3
--							      --							    --								  --
def findLength ( st , n ) :				      int findLength ( string str , int n ) {			    int findLength ( string st , int n ) {			  script_not_found : None
    total = [ 0 ] * ( n + 1 )				      	int ans = 0 ;						      vector < int > total ( n + 1 , 0 ) ;			  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 0 ;					      for ( int i = 1 ;						  
	total [ i ] = ( total [ i - 1 ] + int ( st [ i - 1 ]  	i <= n - 2 ;						      i <= n ;							  
    ans = 0						      	i ++ ) {						      i ++ ) total [ i ] = ( total [ i - 1 ] + atoi ( st [ i - 1  
    l = 2						      	  int l = i , r = i + 1 ;				      int ans = 0 ;						  
    while ( l <= n ) :					      	  int lsum = 0 , rsum = 0 ;				      int l = 2 ;						  
	for i in range ( n - l + 1 ) :			      	  while ( r < n && l >= 0 ) {				      while ( ( l <= n ) && ( l < n ) ) {			  
	    j = i + l - 1				      	    lsum += str [ l ] - '0' ;				    	for ( int i = 0 ;					  
	    if ( total [ i + int ( l / 2 ) ] - total [ i ] == 	    rsum += str [ r ] - '0' ;				    	i < n - l + 1 ;						  
		ans = max ( ans , l )			      	    if ( lsum == rsum ) ans = max ( ans , r - l + 1 ) ;	    	i ++ ) {						  
	l = l + 2					      	    l -- ;						    	  int j = i + l - 1 ;					  
    return ans						      	    r ++ ;						    	  if ( ( total [ i + ( int ) l / 2 ] - total [ i ] == tot 
							      	  }							    	}							  
							      	}							    	l = l + 2 ;						  
							      	return ans ;						      }								  
							      }								      return ans ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT		      CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT		    CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT		  CHECK_WHETHER_POINT_EXISTS_CIRCLE_SECTOR_NOT
--							      --							    --								  --
def checkPoint ( radius , x , y , percent , startAngle ) :    void checkPoint ( int radius , int x , int y , float percent  void checkPoint ( double radius , double x , double y , doubl script_not_found : None
    endAngle = 360 / percent + startAngle		      	float endAngle = 360 / percent + startAngle ;		      double endAngle = 360 / percent + startAngle ;		  
    polarradius = math.sqrt ( x * x + y * y )		      	float polarradius = sqrt ( x * x + y * y ) ;		      double polarradius = sqrt ( x * x + y * y ) ;		  
    Angle = math.atan ( y / x )				      	float Angle = atan ( y / x ) ;				      double Angle = atan ( y / x ) ;				  
    if ( Angle >= startAngle and Angle <= endAngle and polarr 	if ( Angle >= startAngle && Angle <= endAngle && polarradiu   if ( ( Angle >= startAngle && Angle <= endAngle && polarrad 
	print ( "Point (" , x , "," , y , ") " "exist in the  	else printf ( "Point (%d, %d) does not exist in the circle    else cout << "Point (" << x << "," << y << ") " << "does no 
    else :						      }								    }								  
	print ( "Point (" , x , "," , y , ") " "does not exis 								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX		      RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX		    RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX		  RETURN_PREVIOUS_ELEMENT_IN_AN_EXPANDING_MATRIX
--							      --							    --								  --
def findLeft ( str ) :					      string findLeft ( string str ) {				    string findLeft ( string str ) {				  script_not_found : None
    n = len ( str ) - 1					      	int n = str . length ( ) ;				      int n = str . length ( ) - 1 ;				  
    while ( n > 0 ) :					      	while ( n -- ) {					      while ( ( n > 0 ) && ( str [ n ] == 'd' ) ) {		  
	if ( str [ n ] == 'd' ) :			      	  if ( str [ n ] == 'd' ) {				    	if ( ( str [ n ] == 'c' ) ) {				  
	    str = str [ 0 : n ] + 'c' + str [ n + 1 : ]	      	    str [ n ] = 'c' ;					    	  str = str . substr ( 0 , n ) + 'c' + str . substr ( n + 
	    break					      	    break ;						    	  break ;						  
	if ( str [ n ] == 'b' ) :			      	  }							    	}							  
	    str = str [ 0 : n ] + 'a' + str [ n + 1 : ]	      	  if ( str [ n ] == 'b' ) {				    	if ( ( str [ n ] == 'b' ) ) {				  
	    break					      	    str [ n ] = 'a' ;					    	  str = str . substr ( 0 , n ) + 'a' + str . substr ( n + 
	if ( str [ n ] == 'a' ) :			      	    break ;						    	  break ;						  
	    str = str [ 0 : n ] + 'b' + str [ n + 1 : ]	      	  }							    	}							  
	elif ( str [ n ] == 'c' ) :			      	  if ( str [ n ] == 'a' ) str [ n ] = 'b' ;		    	if ( ( str [ n ] == 'a' ) ) {				  
	    str = str [ 0 : n ] + 'd' + str [ n + 1 : ]	      	  else if ( str [ n ] == 'c' ) str [ n ] = 'd' ;	    	  str = str . substr ( 0 , n ) + 'b' + str . substr ( n + 
	n -= 1						      	}							    	}							  
    return str						      	return str ;						    	else if ( ( str [ n ] == 'c' ) ) {			  
							      }								    	  str = str . substr ( 0 , n ) + 'd' + str . substr ( n + 
							      								    	}							  
							      								    	n -- ;							  
							      								      }								  
							      								      return str ;						  
							      								      return " " + str + " " + str ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS			      SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS			    SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS			  SMALLEST_SUBARRAY_K_DISTINCT_NUMBERS
--							      --							    --								  --
def minRange ( arr , n , k ) :				      void minRange ( int arr [ ] , int n , int k ) {		    int minRange ( string arr , int n , int k ) {		  script_not_found : None
    l = 0						      	int l = 0 , r = n ;					      int l = 0 ;						  
    r = n						      	for ( int i = 0 ;					      int r = n ;						  
    for i in range ( n ) :				      	i < n ;							      for ( int i = 0 ;						  
	s = [ ]						      	i ++ ) {						      i < n ;							  
	for j in range ( i , n ) :			      	  unordered_set < int > s ;				      i ++ ) {							  
	    s.append ( arr [ j ] )			      	  int j ;						    	string s ;						  
	    if ( len ( s ) == k ) :			      	  for ( j = i ;						    	for ( int j = i ;					  
		if ( ( j - i ) < ( r - l ) ) :		      	  j < n ;						    	j < n ;							  
		    r = j				      	  j ++ ) {						    	j ++ ) {						  
		    l = i				      	    s . insert ( arr [ j ] ) ;				    	  s += arr [ j ] ;					  
		break					      	    if ( s . size ( ) == k ) {				    	  if ( ( s . length ( ) == k ) ) {			  
	if ( j == n ) :					      	      if ( ( j - i ) < ( r - l ) ) {			    	    if ( ( ( j - i ) < ( r - l ) ) ) {			  
	    break					      		r = j ;						    	      r = j ;						  
    if ( l == 0 and r == n ) :				      		l = i ;						    	      l = i ;						  
	print ( "Invalid k" )				      	      }							    	    }							  
    else :						      	      break ;						    	    break ;						  
	print ( l , r )					      	    }							    	  }							  
							      	  }							    	}							  
							      	  if ( j == n ) break ;					    	if ( ( j == n ) ) break ;				  
							      	}							      }								  
							      	if ( l == 0 && r == n ) cout << "Invalid k" ;		      if ( ( l == 0 ) && ( r == n ) ) cout << "Invalid k" << endl 
							      	else cout << l << " " << r ;				      else cout << l << " " << r ;				  
							      }								      return l ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1	      MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1	    MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1	  MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_1
--							      --							    --								  --
def minJumps ( arr , n ) :				      int minJumps ( int arr [ ] , int n ) {			    float minJumps ( float * arr , int n ) {			  error : MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_
    jumps = [ 0 for i in range ( n ) ]			      	int * jumps = new int [ n ] ;				      int * jumps = new int [ n ] ;				  GIVEN_ARRAY_1.cpp: In function ‘float f_filled(flo
    if ( n == 0 ) or ( arr [ 0 ] == 0 ) :		      	int i , j ;						      for ( int i = 0 ;						  at*, int)’: MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_O
	return float ( 'inf' )				      	if ( n == 0 || arr [ 0 ] == 0 ) return INT_MAX ;	      i < n ;							  F_A_GIVEN_ARRAY_1.cpp:48:65: warning: overflow in
    jumps [ 0 ] = 0					      	jumps [ 0 ] = 0 ;					      i ++ ) {							  conversion from ‘float’ to ‘int’ changes value fro
    for i in range ( 1 , n ) :				      	for ( i = 1 ;						    	if ( ( n == 0 ) || ( arr [ 0 ] == 0 ) ) return std :: num m ‘+Inff’ to ‘2147483647’ [-Woverflow]	jump
	jumps [ i ] = float ( 'inf' )			      	i < n ;							    	jumps [ 0 ] = 0 ;					  s [ i ] = std :: numeric_limits < float > :: infin
	for j in range ( i ) :				      	i ++ ) {						    	for ( int i = 1 ;					  ity ( ) ;			 ~~~~~~~~~~~~~~~~~~~
	    if ( i <= j + arr [ j ] ) and ( jumps [ j ] != fl 	  jumps [ i ] = INT_MAX ;				    	i < n ;							  ~~~~~~~~~~~~~~~~~~~~~~~~~^~~ MINIMUM_NUMBER_OF_JUM
		jumps [ i ] = min ( jumps [ i ] , jumps [ j ] 	  for ( j = 0 ;						    	i ++ ) {						  PS_TO_REACH_END_OF_A_GIVEN_ARRAY_1.cpp: In functio
		break					      	  j < i ;						    	  jumps [ i ] = std :: numeric_limits < float > :: infini n ‘int main()’: MINIMUM_NUMBER_OF_JUMPS_TO_REACH_E
    return jumps [ n - 1 ]				      	  j ++ ) {						    	  for ( int j = 0 ;					  ND_OF_A_GIVEN_ARRAY_1.cpp:69:21: error: cannot con
							      	    if ( i <= j + arr [ j ] && jumps [ j ] != INT_MAX ) {   	  j < i ;						  vert ‘__gnu_cxx::__alloc_traits<std::allocator<int
							      	      jumps [ i ] = min ( jumps [ i ] , jumps [ j ] + 1 ) ; 	  j ++ ) {						  >, int>::value_type*’ {aka ‘int*’} to ‘float*’
							      	      break ;						    	    if ( ( i <= j + arr [ j ] ) && ( jumps [ j ] != std : 	if(f_filled(&param0[i].front(),param1[i]) ==
							      	    }							    	      jumps [ i ] = std :: min ( jumps [ i ] , jumps [ j   f_gold(&param0[i].front(),param1[i]))
							      	  }							    	      break ;						  	    ^~~~~~~~~~~~~~~~~~ MINIMUM_NUMBER_OF_JUM
							      	}							    	    }							  PS_TO_REACH_END_OF_A_GIVEN_ARRAY_1.cpp:38:26: note
							      	return jumps [ n - 1 ] ;				    	  }							  :   initializing argument 1 of ‘float f_filled(flo
							      }								    	}							  at*, int)’  float f_filled ( float * arr , int n )
							      								      }								   {		       ~~~~~~~~^~~
							      								      return jumps [ n - 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE			      FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE			    FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE				  FIND_TWO_SIDES_RIGHT_ANGLE_TRIANGLE
--							      --							    --								  --
def printOtherSides ( n ) :				      void printOtherSides ( int n ) {				    int printOtherSides ( int n ) {				  script_not_found : None
    if ( n & 1 ) :					      	if ( n & 1 ) {						      if ( ( n & 1 ) != 0 ) {					  
	if ( n == 1 ) :					      	  if ( n == 1 ) cout << - 1 << endl ;			    	if ( ( n == 1 ) ) cout << - 1 ;				  
	    print ( - 1 )				      	  else {						    	else {							  
	else :						      	    int b = ( n * n - 1 ) / 2 ;				    	  int b = ( n * n - 1 ) / 2 ;				  
	    b = ( n * n - 1 ) // 2			      	    int c = ( n * n + 1 ) / 2 ;				    	  int c = ( n * n + 1 ) / 2 ;				  
	    c = ( n * n + 1 ) // 2			      	    cout << "b = " << b << ", c = " << c << endl ;	    	  cout << "b =" << b << ", c =" << c << endl ;		  
	    print ( "b =" , b , ", c =" , c )		      	  }							    	}							  
    else :						      	}							      }								  
	if ( n == 2 ) :					      	else {							      else {							  
	    print ( - 1 )				      	  if ( n == 2 ) cout << - 1 << endl ;			    	if ( ( n == 2 ) ) cout << - 1 ;				  
	else :						      	  else {						    	else {							  
	    b = n * n // 4 - 1				      	    int b = n * n / 4 - 1 ;				    	  int b = n * n / 4 - 1 ;				  
	    c = n * n // 4 + 1				      	    int c = n * n / 4 + 1 ;				    	  int c = n * n / 4 + 1 ;				  
	    print ( "b =" , b", c =" , c )		      	    cout << "b = " << b << ", c = " << c << endl ;	    	  cout << "b =" << b << ", c =" << c << endl ;		  
							      	  }							    	}							  
							      	}							      }								  
							      }								      return n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES ELEMENTS_TO_BE_ADDED_SO_THAT_ALL_ELEMENTS_OF_A_RANGE_ARE_PRES
--							      --							    --								  --
def countNum ( arr , n ) :				      int countNum ( int arr [ ] , int n ) {			    int countNum ( int * arr , int n ) {			  script_not_found : None
    s = dict ( )					      	unordered_set < int > s ;				      map < int , int > s ;					  
    count , maxm , minm = 0 , - 10 ** 9 , 10 ** 9	      	int count = 0 , maxm = INT_MIN , minm = INT_MAX ;	      int count = 0 , maxm = - 10 * 9 , minm = 10 * 9 ;		  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	s [ arr [ i ] ] = 1				      	i < n ;							      i < n ;							  
	if ( arr [ i ] < minm ) :			      	i ++ ) {						      i ++ ) {							  
	    minm = arr [ i ]				      	  s . insert ( arr [ i ] ) ;				    	s [ arr [ i ] ] = 1 ;					  
	if ( arr [ i ] > maxm ) :			      	  if ( arr [ i ] < minm ) minm = arr [ i ] ;		    	if ( ( arr [ i ] < minm ) ) minm = arr [ i ] ;		  
	    maxm = arr [ i ]				      	  if ( arr [ i ] > maxm ) maxm = arr [ i ] ;		    	if ( ( arr [ i ] > maxm ) ) maxm = arr [ i ] ;		  
    for i in range ( minm , maxm + 1 ) :		      	}							      }								  
	if i not in s.keys ( ) :			      	for ( int i = minm ;					      for ( int i = minm ;					  
	    count += 1					      	i <= maxm ;						      i <= maxm ;						  
    return count					      	i ++ ) if ( s . find ( arr [ i ] ) == s . end ( ) ) count +   i ++ ) {							  
							      	return count ;						    	if ( ! s . count ( arr [ i ] ) ) count ++ ;		  
							      }								      }								  
							      								      return count ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
STEINS_ALGORITHM_FOR_FINDING_GCD_1			      STEINS_ALGORITHM_FOR_FINDING_GCD_1			    STEINS_ALGORITHM_FOR_FINDING_GCD_1				  STEINS_ALGORITHM_FOR_FINDING_GCD_1
--							      --							    --								  --
def gcd ( a , b ) :					      int gcd ( int a , int b ) {				    int gcd ( int a , int b ) {					  success : None
    if ( a == b ) :					      	if ( a == b ) return a ;				      if ( ( a == b ) ) return a ;				  
	return a					      	if ( a == 0 ) return b ;				      if ( ( a == 0 ) ) return b ;				  
    if ( a == 0 ) :					      	if ( b == 0 ) return a ;				      if ( ( b == 0 ) ) return a ;				  
	return b					      	if ( ~ a & 1 ) {					      if ( ( ( ~ a & 1 ) == 1 ) ) {				  
    if ( b == 0 ) :					      	  if ( b & 1 ) return gcd ( a >> 1 , b ) ;		    	if ( ( ( b & 1 ) == 1 ) ) return gcd ( a >> 1 , b ) ;	  
	return a					      	  else return gcd ( a >> 1 , b >> 1 ) << 1 ;		    	else return ( gcd ( a >> 1 , b >> 1 ) << 1 ) ;		  
    if ( ( ~ a & 1 ) == 1 ) :				      	}							      }								  
	if ( ( b & 1 ) == 1 ) :				      	if ( ~ b & 1 ) return gcd ( a , b >> 1 ) ;		      if ( ( ( ~ b & 1 ) == 1 ) ) return gcd ( a , b >> 1 ) ;	  
	    return gcd ( a >> 1 , b )			      	if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ;	      if ( ( a > b ) ) return gcd ( ( a - b ) >> 1 , b ) ;	  
	else :						      	return gcd ( ( b - a ) >> 1 , a ) ;			      return gcd ( ( b - a ) >> 1 , a ) ;			  
	    return ( gcd ( a >> 1 , b >> 1 ) << 1 )	      }								    }								  
    if ( ( ~ b & 1 ) == 1 ) :				      								    								  
	return gcd ( a , b >> 1 )			      								    								  
    if ( a > b ) :					      								    								  
	return gcd ( ( a - b ) >> 1 , b )		      								    								  
    return gcd ( ( b - a ) >> 1 , a )			      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1		      MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1		    MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1		  MAXIMUM_SUM_IARRI_AMONG_ROTATIONS_GIVEN_ARRAY_1
--							      --							    --								  --
def maxSum ( arr , n ) :				      int maxSum ( int arr [ ] , int n ) {			    int maxSum ( int * arr , int n ) {				  success : None
    cum_sum = 0						      	int cum_sum = 0 ;					      int cumSum = 0 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	cum_sum += arr [ i ]				      	i < n ;							      i < n ;							  
    curr_val = 0					      	i ++ ) cum_sum += arr [ i ] ;				      i ++ ) cumSum += arr [ i ] ;				  
    for i in range ( 0 , n ) :				      	int curr_val = 0 ;					      int currVal = 0 ;						  
	curr_val += i * arr [ i ]			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    res = curr_val					      	i < n ;							      i < n ;							  
    for i in range ( 1 , n ) :				      	i ++ ) curr_val += i * arr [ i ] ;			      i ++ ) currVal += i * arr [ i ] ;				  
	next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + 	int res = curr_val ;					      int res = currVal ;					  
	curr_val = next_val				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	res = max ( res , next_val )			      	i < n ;							      i < n ;							  
    return res						      	i ++ ) {						      i ++ ) {							  
							      	  int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + a 	int nextVal = ( currVal - ( cumSum - arr [ i - 1 ] ) + ar 
							      	  curr_val = next_val ;					    	currVal = nextVal ;					  
							      	  res = max ( res , next_val ) ;			    	res = max ( res , nextVal ) ;				  
							      	}							      }								  
							      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_PREFIX_ALSO_SUFFIX_1				      LONGEST_PREFIX_ALSO_SUFFIX_1				    LONGEST_PREFIX_ALSO_SUFFIX_1				  LONGEST_PREFIX_ALSO_SUFFIX_1
--							      --							    --								  --
def longestPrefixSuffix ( s ) :				      int longestPrefixSuffix ( string s ) {			    int longestPrefixSuffix ( string s ) {			  error : LONGEST_PREFIX_ALSO_SUFFIX_1.cpp: In funct
    n = len ( s )					      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  ion ‘int f_filled(std::__cxx11::string)’: LONGEST_
    lps = [ 0 ] * n					      	int lps [ n ] ;						      vector < int > lps ( n , 0 ) ;				  PREFIX_ALSO_SUFFIX_1.cpp:53:3: error: ‘else’ witho
    l = 0						      	lps [ 0 ] = 0 ;						      int l = 0 ;						  ut a previous ‘if’	else {	  ^~~~
    i = 1						      	int len = 0 ;						      int i = 1 ;						  
    while ( i < n ) :					      	int i = 1 ;						      while ( ( i < n ) && ( s [ i ] == s [ l ] ) ) {		  
	if ( s [ i ] == s [ l ] ) :			      	while ( i < n ) {					    	l = l + 1 ;						  
	    l = l + 1					      	  if ( s [ i ] == s [ len ] ) {				    	lps [ i ] = l ;						  
	    lps [ i ] = l				      	    len ++ ;						    	i = i + 1 ;						  
	    i = i + 1					      	    lps [ i ] = len ;					      }								  
	else :						      	    i ++ ;						      else {							  
	    if ( l != 0 ) :				      	  }							    	if ( ( l != 0 ) ) l = lps [ l - 1 ] ;			  
		l = lps [ l - 1 ]			      	  else {						    	else {							  
	    else :					      	    if ( len != 0 ) {					    	  lps [ i ] = 0 ;					  
		lps [ i ] = 0				      	      len = lps [ len - 1 ] ;				    	  i = i + 1 ;						  
		i = i + 1				      	    }							    	}							  
    res = lps [ n - 1 ]					      	    else {						      }								  
    if ( res > n / 2 ) :				      	      lps [ i ] = 0 ;					      int res = lps [ n - 1 ] ;					  
	return n // 2					      	      i ++ ;						      if ( ( res > n / 2 ) ) return n / 2 ;			  
    else :						      	    }							      else return res ;						  
	return res					      	  }							      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      	}							    }								  
							      	int res = lps [ n - 1 ] ;				    								  
							      	return ( res > n / 2 ) ? n / 2 : res ;			    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT MINIMUM_TIME_WRITE_CHARACTERS_USING_INSERT_DELETE_COPY_OPERAT
--							      --							    --								  --
def minTimeForWritingChars ( N , insrt , remov , cpy ) :      int minTimeForWritingChars ( int N , int insert , int remove  int minTimeForWritingChars ( int N , int insrt , int remov ,  success : None
    if N == 0 :						      	if ( N == 0 ) return 0 ;				      if ( N == 0 ) return 0 ;					  
	return 0					      	if ( N == 1 ) return insert ;				      if ( N == 1 ) return insrt ;				  
    if N == 1 :						      	int dp [ N + 1 ] ;					      vector < int > dp ( N + 1 , 0 ) ;				  
	return insrt					      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int i = 1 ;						  
    dp = [ 0 ] * ( N + 1 )				      	for ( int i = 1 ;					      i <= N ;							  
    for i in range ( 1 , N + 1 ) :			      	i <= N ;						      i ++ ) {							  
	if i % 2 == 0 :					      	i ++ ) {						    	if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insrt , 
	    dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ i // 	  if ( i % 2 == 0 ) dp [ i ] = min ( dp [ i - 1 ] + insert  	else dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ ( i + 1 
	else :						      	  else dp [ i ] = min ( dp [ i - 1 ] + insert , dp [ ( i +    }								  
	    dp [ i ] = min ( dp [ i - 1 ] + insrt , dp [ ( i  	}							      return dp [ N ] ;						  
    return dp [ N ]					      	return dp [ N ] ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES	      CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES		    CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES		  CONVERT_STRICTLY_INCREASING_ARRAY_MINIMUM_CHANGES
--							      --							    --								  --
def minRemove ( arr , n ) :				      int minRemove ( int arr [ ] , int n ) {			    int minRemove ( int * arr , int n ) {			  success : None
    LIS = [ 0 for i in range ( n ) ]			      	int LIS [ n ] , len = 0 ;				      int LIS [ n ] ;						  
    len = 0						      	for ( int i = 0 ;					      int len = 0 ;						  
    for i in range ( n ) :				      	i < n ;							      for ( int i = 0 ;						  
	LIS [ i ] = 1					      	i ++ ) LIS [ i ] = 1 ;					      i < n ;							  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      i ++ ) LIS [ i ] = 1 ;					  
	for j in range ( i ) :				      	i < n ;							      for ( int i = 1 ;						  
	    if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr 	i ++ ) {						      i < n ;							  
		LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) 	  for ( int j = 0 ;					      i ++ ) {							  
	len = max ( len , LIS [ i ] )			      	  j < i ;						    	for ( int j = 0 ;					  
    return ( n - len )					      	  j ++ ) {						    	j < i ;							  
							      	    if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ]  	j ++ ) {						  
							      	      LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) ;	    	  if ( ( arr [ i ] > arr [ j ] ) && ( i - j ) <= ( arr [  
							      	    }							    	}							  
							      	  }							    	len = max ( len , LIS [ i ] ) ;				  
							      	  len = max ( len , LIS [ i ] ) ;			      }								  
							      	}							      return ( n - len ) ;					  
							      	return n - len ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S			      LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S			    LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S			  LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S
--							      --							    --								  --
def lenOfLongSubarr ( arr , n ) :			      int lenOfLongSubarr ( int arr [ ] , int n ) {		    int lenOfLongSubarr ( int * arr , int n ) {			  error : LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S.cpp
    um = { i : 0 for i in range ( 10 ) }		      	unordered_map < int , int > um ;			      unordered_map < int , int > um ;				  : In function ‘int f_filled(int*, int)’: LONGEST_S
    sum = 0						      	int sum = 0 , maxLen = 0 ;				      um [ i ] = 0 ;						  UBARRAY_COUNT_1S_ONE_COUNT_0S.cpp:35:8: error: ‘i’
    maxLen = 0						      	for ( int i = 0 ;					      for ( int i = 0 ;						   was not declared in this scope    um [ i ] = 0 ;
    for i in range ( n ) :				      	i < n ;							      i < 10 ;							  	  ^ LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S.c
	if arr [ i ] == 0 :				      	i ++ ) {						      i ++ ) {							  pp:39:27: error: ‘sum’ was not declared in this sc
	    sum += - 1					      	  sum += arr [ i ] == 0 ? - 1 : 1 ;			    	if ( arr [ i ] == 0 ) sum += - 1 ;			  ope	   if ( arr [ i ] == 0 ) sum += - 1 ;
	else :						      	  if ( sum == 1 ) maxLen = i + 1 ;			    	else sum += 1 ;						  		       ^~~ LONGEST_SUBARRAY_COUNT_1S
	    sum += 1					      	  else if ( um . find ( sum ) == um . end ( ) ) um [ sum ]  	if ( ( sum == 1 ) ) maxLen = i + 1 ;			  _ONE_COUNT_0S.cpp:39:27: note: suggested alternati
	if ( sum == 1 ) :				      	  if ( um . find ( sum - 1 ) != um . end ( ) ) {	    	else if ( ( sum != 0 ) ) um [ sum ] = i ;		  ve: ‘um’	if ( arr [ i ] == 0 ) sum += - 1 ;
	    maxLen = i + 1				      	    if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um  	if ( ( ( sum - 1 ) < um . count ( i ) ) ) if ( ( maxLen < 			    ^~~
	elif ( sum not in um ) :			      	  }							      }								  	 um LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S.c
	    um [ sum ] = i				      	}							      return maxLen ;						  pp:40:10: error: ‘sum’ was not declared in this sc
	if ( ( sum - 1 ) in um ) :			      	return maxLen ;						    }								  ope	   else sum += 1 ;	     ^~~ LONGEST_SUB
	    if ( maxLen < ( i - um [ sum - 1 ] ) ) :	      }								    								  ARRAY_COUNT_1S_ONE_COUNT_0S.cpp:40:10: note: sugge
		maxLen = i - um [ sum - 1 ]		      								    								  sted alternative: ‘um’      else sum += 1 ;
    return maxLen					      								    								      ^~~	    um LONGEST_SUBARRAY_COUNT_1S_ONE
							      								    								  _COUNT_0S.cpp:41:12: error: ‘sum’ was not declared
							      								    								   in this scope      if ( ( sum == 1 ) ) maxLen = i
							      								    								   + 1 ;	     ^~~ LONGEST_SUBARRAY_COUNT_1S_O
							      								    								  NE_COUNT_0S.cpp:41:12: note: suggested alternative
							      								    								  : ‘um’      if ( ( sum == 1 ) ) maxLen = i + 1 ;
							      								    								  	     ^~~	     um LONGEST_SUBARRAY_COU
							      								    								  NT_1S_ONE_COUNT_0S.cpp:41:25: error: ‘maxLen’ was
							      								    								  not declared in this scope	  if ( ( sum == 1 )
							      								    								  ) maxLen = i + 1 ;			      ^~~~~~
							      								    								   LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S.cpp:41:25:
							      								    								   note: suggested alternative: ‘mblen’	     if ( (
							      								    								  sum == 1 ) ) maxLen = i + 1 ;
							      								    								       ^~~~~~			       mblen LONGEST
							      								    								  _SUBARRAY_COUNT_1S_ONE_COUNT_0S.cpp:43:14: error:
							      								    								  ‘sum’ was not declared in this scope	    if ( ( (
							      								    								   sum - 1 ) < um . count ( i ) ) ) if ( ( maxLen <
							      								    								  ( i - um [ sum - 1 ] ) ) ) maxLen = i - um [ sum -
							      								    								   1 ] ;	       ^~~ LONGEST_SUBARRAY_COUNT_1S
							      								    								  _ONE_COUNT_0S.cpp:43:14: note: suggested alternati
							      								    								  ve: ‘um’	if ( ( ( sum - 1 ) < um . count ( i
							      								    								  ) ) ) if ( ( maxLen < ( i - um [ sum - 1 ] ) ) ) m
							      								    								  axLen = i - um [ sum - 1 ] ;		     ^~~
							      								    								  	     um LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_
							      								    								  0S.cpp:43:54: error: ‘maxLen’ was not declared in
							      								    								  this scope	  if ( ( ( sum - 1 ) < um . count (
							      								    								  i ) ) ) if ( ( maxLen < ( i - um [ sum - 1 ] ) ) )
							      								    								   maxLen = i - um [ sum - 1 ] ;
							      								    								  				     ^~~~~~ LONGEST_
							      								    								  SUBARRAY_COUNT_1S_ONE_COUNT_0S.cpp:43:54: note: su
							      								    								  ggested alternative: ‘mblen’	    if ( ( ( sum - 1
							      								    								   ) < um . count ( i ) ) ) if ( ( maxLen < ( i - um
							      								    								   [ sum - 1 ] ) ) ) maxLen = i - um [ sum - 1 ] ;
							      								    								  
							      								    								     ^~~~~~
							      								    								  		mblen LONGEST_SUBARRAY_COUNT_1S_ONE_
							      								    								  COUNT_0S.cpp:45:10: error: ‘maxLen’ was not declar
							      								    								  ed in this scope    return maxLen ;		^~~~
							      								    								  ~~ LONGEST_SUBARRAY_COUNT_1S_ONE_COUNT_0S.cpp:45:1
							      								    								  0: note: suggested alternative: ‘mblen’    return
							      								    								  maxLen ;	     ^~~~~~	      mblen
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ENTRINGER_NUMBER_1					      ENTRINGER_NUMBER_1					    ENTRINGER_NUMBER_1						  ENTRINGER_NUMBER_1
--							      --							    --								  --
def zigzag ( n , k ) :					      int zigzag ( int n , int k ) {				    int zigzag ( int n , int k ) {				  script_not_found : None
    dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n  	int dp [ n + 1 ] [ k + 1 ] ;				      vector < vector < int >> dp ( k + 1 , vector < int > ( n +  
    dp [ 0 ] [ 0 ] = 1					      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int y = 0 ;						  
    for i in range ( 1 , n + 1 ) :			      	dp [ 0 ] [ 0 ] = 1 ;					      y < n + 1 ;						  
	dp [ i ] [ 0 ] = 0				      	for ( int i = 1 ;					      y ++ ) dp [ 0 ] [ 0 ] = 1 ;				  
    for i in range ( 1 , n + 1 ) :			      	i <= n ;						      for ( int i = 1 ;						  
	for j in range ( 1 , k + 1 ) :			      	i ++ ) dp [ i ] [ 0 ] = 0 ;				      i <= n ;							  
	    dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i -  	for ( int i = 1 ;					      i ++ ) dp [ i ] [ 0 ] = 0 ;				  
    return dp [ n ] [ k ]				      	i <= n ;						      for ( int i = 1 ;						  
							      	i ++ ) {						      i <= n ;							  
							      	  for ( int j = 1 ;					      i ++ ) for ( int j = 1 ;					  
							      	  j <= i ;						      j <= k ;							  
							      	  j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ]   j ++ ) dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] 
							      	  return dp [ n ] [ k ] ;				      return dp [ n ] [ k ] ;					  
							      	}							    }								  
							      	int main ( ) {						    								  
							      	  int n = 4 , k = 3 ;					    								  
							      	  cout << zigzag ( n , k ) << endl ;			    								  
							      	  return 0 ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_MAXIMUM_GCD_ARRAY_1				      FIND_PAIR_MAXIMUM_GCD_ARRAY_1				    FIND_PAIR_MAXIMUM_GCD_ARRAY_1				  FIND_PAIR_MAXIMUM_GCD_ARRAY_1
--							      --							    --								  --
def findMaxGCD ( arr , n ) :				      int findMaxGCD ( int arr [ ] , int n ) {			    int findMaxGCD ( int * arr , int n ) {			  failure : #Results: 4, 10
    high = 0						      	int high = 0 ;						      int high = 0 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	high = max ( high , arr [ i ] )			      	i < n ;							      i <= n ;							  
    count = [ 0 ] * ( high + 1 )			      	i ++ ) high = max ( high , arr [ i ] ) ;		      i ++ ) high = max < int > ( high , arr [ i ] ) ;		  
    for i in range ( 0 , n ) :				      	int count [ high + 1 ] = {				      vector < int > count ( high + 1 , 0 ) ;			  
	count [ arr [ i ] ] += 1			      	  0 }							      for ( int i = 0 ;						  
    counter = 0						      	  ;							      i <= n ;							  
    for i in range ( high , 0 , - 1 ) :			      	  for ( int i = 0 ;					      i ++ ) count [ arr [ i ] ] ++ ;				  
	j = i						      	  i < n ;						      int counter = 0 ;						  
	while ( j <= high ) :				      	  i ++ ) count [ arr [ i ] ] ++ ;			      for ( int i = high ;					  
	    if ( count [ j ] > 0 ) :			      	  int counter = 0 ;					      i > 0 ;							  
		counter += count [ j ]			      	  for ( int i = high ;					      i -- ) {							  
	    j += i					      	  i >= 1 ;						    	int j = i ;						  
	    if ( counter == 2 ) :			      	  i -- ) {						    	while ( ( j <= high ) ) {				  
		return i				      	    int j = i ;						    	  if ( ( count [ j ] > 0 ) ) counter += count [ j ] ;	  
	counter = 0					      	    counter = 0 ;					    	  j += i ;						  
							      	    while ( j <= high ) {				    	  if ( ( counter == 2 ) ) return i ;			  
							      	      if ( count [ j ] >= 2 ) return j ;		    	}							  
							      	      else if ( count [ j ] == 1 ) counter ++ ;		    	counter = 0 ;						  
							      	      j += i ;						      }								  
							      	      if ( counter == 2 ) return i ;			      return 0 ;						  
							      	    }							    }								  
							      	  }							    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1			      FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1			    FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1			  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1
--							      --							    --								  --
def isRectangle ( m ) :					      bool isRectangle ( const vector < vector < int >> & m ) {	    bool isRectangle ( vector < vector < int >> m ) {		  failure : #Results: 9, 10
    rows = len ( m )					      	int rows = m . size ( ) ;				      int rows = m . size ( ) ;					  
    if ( rows == 0 ) :					      	if ( rows == 0 ) return false ;				      if ( ( rows == 0 ) ) return false ;			  
	return False					      	int columns = m [ 0 ] . size ( ) ;			      int columns = m [ 0 ] . size ( ) ;			  
    columns = len ( m [ 0 ] )				      	for ( int y1 = 0 ;					      for ( int y1 = 0 ;					  
    for y1 in range ( rows ) :				      	y1 < rows ;						      y1 < rows ;						  
	for x1 in range ( columns ) :			      	y1 ++ ) for ( int x1 = 0 ;				      y1 ++ ) for ( int x1 = 0 ;				  
	    if ( m [ y1 ] [ x1 ] == 1 ) :		      	x1 < columns ;						      x1 < columns ;						  
		for y2 in range ( y1 + 1 , rows ) :	      	x1 ++ ) if ( m [ y1 ] [ x1 ] == 1 ) for ( int y2 = y1 + 1 ;   x1 ++ ) if ( ( m [ y1 ] [ x1 ] == 1 ) ) for ( int y2 = y1 + 
		    for x2 in range ( x1 + 1 , columns ) :    	y2 < rows ;						      y2 < rows ;						  
			if ( m [ y1 ] [ x2 ] == 1 and m [ y2  	y2 ++ ) for ( int x2 = x1 + 1 ;				      y2 ++ ) for ( int x2 = x1 + 1 ;				  
			    return True			      	x2 < columns ;						      x2 < columns ;						  
    return False					      	x2 ++ ) if ( m [ y1 ] [ x2 ] == 1 && m [ y2 ] [ x1 ] == 1 &   x2 ++ ) if ( ( m [ y1 ] [ x2 ] == 1 ) && ( m [ y2 ] [ x1 ]  
							      	return false ;						      return false ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K		      MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K		    MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K		  MINIMUM_POSSIBLE_VALUE_AI_AJ_K_GIVEN_ARRAY_K
--							      --							    --								  --
def pairs ( arr , n , k ) :				      void pairs ( int arr [ ] , int n , int k ) {		    int pairsOf ( int * arr , int n , int k ) {			  script_not_found : None
    smallest = 999999999999				      	int smallest = INT_MAX ;				      int smallest = 999999999999 ;				  
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n ;							      i < n ;							  
	    if abs ( arr [ i ] + arr [ j ] - k ) < smallest : 	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
		smallest = abs ( arr [ i ] + arr [ j ] - k )  	j < n ;							    	for ( int j = i + 1 ;					  
		count = 1				      	j ++ ) {						    	j < n ;							  
	    elif abs ( arr [ i ] + arr [ j ] - k ) == smalles 	  if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) {	    	j ++ ) {						  
		count += 1				      	    smallest = abs ( arr [ i ] + arr [ j ] - k ) ;	    	  if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) {	  
    print ( "Minimal Value = " , smallest )		      	    count = 1 ;						    	    smallest = abs ( arr [ i ] + arr [ j ] - k ) ;	  
    print ( "Total Pairs = " , count )			      	  }							    	    count = 1 ;						  
							      	  else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) 	  }							  
							      	}							    	  else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest 
							      	cout << "Minimal Value = " << smallest << "\n" ;	    	}							  
							      	cout << "Total Pairs = " << count << "\n" ;		      }								  
							      }								      cout << "Minimal Value = " << smallest << endl ;		  
							      								      cout << "Total Pairs = " << count << endl ;		  
							      								      return count ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS		      MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS		    MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS			  MINIMUM_INDEX_SUM_COMMON_ELEMENTS_TWO_LISTS
--							      --							    --								  --
def find ( list1 , list2 ) :				      void find ( vector < string > list1 , vector < string > list2 string find ( string list1 , string list2 ) {		  script_not_found : None
    res = [ ]						      	vector < string > res ;					      string res ;						  
    max_possible_sum = len ( list1 ) + len ( list2 ) - 2      	int max_possible_sum = list1 . size ( ) + list2 . size ( )    int maxPossibleSum = list1 . length ( ) + list2 . length (  
    for sum in range ( max_possible_sum + 1 ) :		      	for ( int sum = 0 ;					      for ( int sum = 0 ;					  
	for i in range ( sum + 1 ) :			      	sum <= max_possible_sum ;				      sum < maxPossibleSum + 1 ;				  
	    if ( i < len ( list1 ) and ( sum - i ) < len ( li 	sum ++ ) {						      sum ++ ) {						  
		res.append ( list1 [ i ] )		      	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
	if ( len ( res ) > 0 ) :			      	  i <= sum ;						    	i < sum + 1 ;						  
	    break					      	  i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . 	i ++ ) {						  
    for i in range ( len ( res ) ) :			      	  if ( res . size ( ) > 0 ) break ;			    	  if ( ( i < list1 . length ( ) ) && ( sum - i ) < list2  
	print ( res [ i ] , end = " " )			      	}							    	}							  
							      	for ( int i = 0 ;					    	if ( ( res . length ( ) > 0 ) ) break ;			  
							      	i < res . size ( ) ;					      }								  
							      	i ++ ) cout << res [ i ] << " " ;			      for ( int i = 0 ;						  
							      }								      i < res . length ( ) ;					  
							      								      i ++ ) cout << res [ i ] << " " ;				  
							      								      return res ;						  
							      								      return " " + list1 + " " + list2 ;			  
							      								      return " " + list1 ;					  
							      								      return " " + list1 ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
INTERPOLATION_SEARCH					      INTERPOLATION_SEARCH					    INTERPOLATION_SEARCH					  INTERPOLATION_SEARCH
--							      --							    --								  --
def interpolationSearch ( arr , n , x ) :		      int interpolationSearch ( int arr [ ] , int n , int x ) {	    int interpolationSearch ( double * arr , int n , double x ) { script_not_found : None
    lo = 0						      	int lo = 0 , hi = ( n - 1 ) ;				      int lo = 0 ;						  
    hi = ( n - 1 )					      	while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {    int hi = ( n - 1 ) ;					  
    while lo <= hi and x >= arr [ lo ] and x <= arr [ hi ] :  	  if ( lo == hi ) {					      while ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) {  
	if lo == hi :					      	    if ( arr [ lo ] == x ) return lo ;			    	if ( lo == hi ) {					  
	    if arr [ lo ] == x :			      	    return - 1 ;					    	  if ( arr [ lo ] == x ) return lo ;			  
		return lo ;				      	  }							    	  return - 1 ;						  
	    return - 1 ;				      	  int pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ]  	}							  
	pos = lo + int ( ( ( float ( hi - lo ) / ( arr [ hi ] 	  if ( arr [ pos ] == x ) return pos ;			    	return - 1 ;						  
	if arr [ pos ] == x :				      	  if ( arr [ pos ] < x ) lo = pos + 1 ;			      }								  
	    return pos					      	  else hi = pos - 1 ;					      int pos = lo + ( int ) ( ( ( ( double ) ( hi - lo ) / ( arr 
	if arr [ pos ] < x :				      	}							      if ( arr [ pos ] == x ) return pos ;			  
	    lo = pos + 1 ;				      	return - 1 ;						      if ( arr [ pos ] < x ) lo = pos + 1 ;			  
	else :						      }								      else hi = pos - 1 ;					  
	    hi = pos - 1 ;				      								    }								  
    return - 1						      								    return - 1 ;						  
							      								    return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DELANNOY_NUMBER_1					      DELANNOY_NUMBER_1						    DELANNOY_NUMBER_1						  DELANNOY_NUMBER_1
--							      --							    --								  --
def dealnnoy ( n , m ) :				      int dealnnoy ( int n , int m ) {				    int dealnnoy ( int n , int m ) {				  error : /bin/bash: line 1: 1847824 Segmentation fa
    dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m  	int dp [ m + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( m +  ult	   (core dumped) ./DELANNOY_NUMBER_1_cpp
    for i in range ( m ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	dp [ 0 ] [ i ] = 1				      	i <= m ;						      i < m ;							  
    for i in range ( 1 , m + 1 ) :			      	i ++ ) dp [ i ] [ 0 ] = 1 ;				      i ++ ) dp [ 0 ] [ i ] = 1 ;				  
	dp [ i ] [ 0 ] = 1				      	for ( int i = 0 ;					      for ( int i = 1 ;						  
    for i in range ( 1 , m + 1 ) :			      	i <= m ;						      i <= m ;							  
	for j in range ( 1 , n + 1 ) :			      	i ++ ) dp [ 0 ] [ i ] = 1 ;				      i ++ ) dp [ i ] [ 0 ] = 1 ;				  
	    dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1  	for ( int i = 1 ;					      for ( int i = 1 ;						  
    return dp [ m ] [ n ]				      	i <= m ;						      i <= m ;							  
							      	i ++ ) for ( int j = 1 ;				      i ++ ) for ( int j = 1 ;					  
							      	j <= n ;						      j <= n ;							  
							      	j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [   j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ 
							      	return dp [ m ] [ n ] ;					      return dp [ m ] [ n ] ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_BINOMIAL_COEFFICIENTS				      SUM_BINOMIAL_COEFFICIENTS					    SUM_BINOMIAL_COEFFICIENTS					  SUM_BINOMIAL_COEFFICIENTS
--							      --							    --								  --
def binomialCoeffSum ( n ) :				      int binomialCoeffSum ( int n ) {				    int binomialCoeffSum ( int n ) {				  success : None
    C = [ [ 0 ] * ( n + 2 ) for i in range ( 0 , n + 2 ) ]    	int C [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> C ( n + 2 , vector < int > ( n + 2 
    for i in range ( 0 , n + 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( 0 , min ( i , n ) + 1 ) :	      	i <= n ;						      i <= n ;							  
	    if ( j == 0 or j == i ) :			      	i ++ ) {						      i ++ ) {							  
		C [ i ] [ j ] = 1			      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    else :					      	  j <= min ( i , n ) ;					    	j <= min ( i , n ) ;					  
		C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i 	  j ++ ) {						    	j ++ ) {						  
    sum = 0						      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  if ( ( j == 0 || j == i ) ) C [ i ] [ j ] = 1 ;	  
    for i in range ( 0 , n + 1 ) :			      	    else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	  else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  
	sum += C [ n ] [ i ]				      	  }							    	}							  
    return sum						      	}							      }								  
							      	int sum = 0 ;						      int sum = 0 ;						  
							      	for ( int i = 0 ;					      for ( int i = 0 ;						  
							      	i <= n ;						      i <= n ;							  
							      	i ++ ) sum += C [ n ] [ i ] ;				      i ++ ) sum += C [ n ] [ i ] ;				  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMALLER_TH
--							      --							    --								  --
def findElement ( arr , n ) :				      int findElement ( int arr [ ] , int n ) {			    int findElement ( float * arr , int n ) {			  error : FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEM
    leftMax = [ None ] * n				      	int leftMax [ n ] ;					      float * leftMax = new float [ n ] ;			  ENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_G
    leftMax [ 0 ] = float ( '-inf' )			      	leftMax [ 0 ] = INT_MIN ;				      memset ( leftMax , 0 , n * sizeof ( float ) ) ;		  REATER_THAN_IT.cpp: In function ‘int main()’: FIND
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      leftMax [ 0 ] = ( float ) - 1 ;				  _THE_ELEMENT_BEFORE_WHICH_ALL_THE_ELEMENTS_ARE_SMA
	leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i - 1 	i < n ;							      for ( int i = 1 ;						  LLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE_GREATER_THAN_
    rightMin = float ( 'inf' )				      	i ++ ) leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i -    i < n ;							  IT.cpp:57:21: error: cannot convert ‘__gnu_cxx::__
    for i in range ( n - 1 , - 1 , - 1 ) :		      	int rightMin = INT_MAX ;				      i ++ ) leftMax [ i ] = max ( leftMax [ i - 1 ] , arr [ i -  alloc_traits<std::allocator<int>, int>::value_type
	if leftMax [ i ] < arr [ i ] and rightMin > arr [ i ] 	for ( int i = n - 1 ;					      float rightMin = ( float ) - 1 ;				  *’ {aka ‘int*’} to ‘float*’	       if(f_filled(&
	    return i					      	i >= 0 ;						      for ( int i = n - 1 ;					  param0[i].front(),param1[i]) == f_gold(&param0[i].
	rightMin = min ( rightMin , arr [ i ] )		      	i -- ) {						      i >= 0 ;							  front(),param1[i]))			   ^~~~~~~~~
    return - 1						      	  if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] )    i -- ) {							  ~~~~~~~~~ FIND_THE_ELEMENT_BEFORE_WHICH_ALL_THE_EL
							      	  rightMin = min ( rightMin , arr [ i ] ) ;		    	if ( leftMax [ i ] < arr [ i ] && rightMin > arr [ i ] )  EMENTS_ARE_SMALLER_THAN_IT_AND_AFTER_WHICH_ALL_ARE
							      	}							    	rightMin = min ( rightMin , arr [ i ] ) ;		  _GREATER_THAN_IT.cpp:33:24: note:   initializing a
							      	return - 1 ;						      }								  rgument 1 of ‘int f_filled(float*, int)’  int f_fi
							      }								      return - 1 ;						  lled ( float * arr , int n ) {		 ~~~
							      								    }								  ~~~~~^~~
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS COUNT_GROUPINGS_NUMBER_SUM_DIGITS_EVERY_SUB_GROUP_LESS_EQUALS
--							      --							    --								  --
def countGroups ( position , previous_sum , length , num ) :  int countGroups ( int position , int previous_sum , int lengt int countGroups ( int position , int previousSum , int length script_not_found : None
    if ( position == length ) :				      	if ( position == length ) return 1 ;			      if ( ( position == length ) ) return 1 ;			  
	return 1					      	if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [    if ( ( dp [ position ] [ previousSum ] != - 1 ) ) return dp 
    if ( dp [ position ] [ previous_sum ] != - 1 ) :	      	dp [ position ] [ previous_sum ] = 0 ;			      dp [ position ] [ previousSum ] = 0 ;			  
	return dp [ position ] [ previous_sum ]		      	int res = 0 ;						      int res = 0 ;						  
    dp [ position ] [ previous_sum ] = 0		      	int sum = 0 ;						      int sum = 0 ;						  
    res = 0						      	for ( int i = position ;				      for ( int i = position ;					  
    sum = 0						      	i < length ;						      i < length ;						  
    for i in range ( position , length ) :		      	i ++ ) {						      i ++ ) {							  
	sum += ( ord ( num [ i ] ) - ord ( '0' ) )	      	  sum += ( num [ i ] - '0' ) ;				    	sum += ( num [ i ] - '0' ) ;				  
	if ( sum >= previous_sum ) :			      	  if ( sum >= previous_sum ) res += countGroups ( i + 1 , s 	if ( ( sum >= previousSum ) ) res += countGroups ( i + 1  
	    res += countGroups ( i + 1 , sum , length , num ) 	}							      }								  
    dp [ position ] [ previous_sum ] = res		      	dp [ position ] [ previous_sum ] = res ;		      dp [ position ] [ previousSum ] = res ;			  
    return res						      	return res ;						      return res ;						  
							      }								      return position * position * position * position * position 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_ MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_ MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_ MINIMUM_NUMBER_OF_MANIPULATIONS_REQUIRED_TO_MAKE_TWO_STRINGS_
--							      --							    --								  --
def countManipulations ( s1 , s2 ) :			      int countManipulations ( string s1 , string s2 ) {	    int countManipulations ( string s1 , string s2 ) {		  script_not_found : None
    count = 0						      	int count = 0 ;						      int count = 0 ;						  
    char_count = [ 0 ] * 26				      	int char_count [ 26 ] ;					      vector < int > charCount ( 26 , 0 ) ;			  
    for i in range ( 26 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	char_count [ i ] = 0				      	i < 26 ;						      i < 26 ;							  
    for i in range ( len ( s1 ) ) :			      	i ++ ) {						      i ++ ) charCount [ i ] = 0 ;				  
	char_count [ ord ( s1 [ i ] ) - ord ( 'a' ) ] += 1    	  char_count [ i ] = 0 ;				      for ( int i = 0 ;						  
    for i in range ( len ( s2 ) ) :			      	}							      i < s1 . length ( ) ;					  
	char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] -= 1    	for ( int i = 0 ;					      i ++ ) charCount [ s1 [ i ] - 'a' ] ++ ;			  
	if ( char_count [ ord ( s2 [ i ] ) - ord ( 'a' ) ] <  	i < s1 . length ( ) ;					      for ( int i = 0 ;						  
	    count += 1					      	i ++ ) char_count [ s1 [ i ] - 'a' ] ++ ;		      i < s2 . length ( ) ;					  
    return count					      	for ( int i = 0 ;					      i ++ ) {							  
							      	i < s2 . length ( ) ;					    	charCount [ s2 [ i ] - 'a' ] -- ;			  
							      	i ++ ) {						    	if ( ( charCount [ s2 [ i ] - 'a' ] < 0 ) ) count ++ ;	  
							      	  char_count [ s2 [ i ] - 'a' ] -- ;			      }								  
							      	  if ( char_count [ s2 [ i ] - 'a' ] < 0 ) count ++ ;	      return count ;						  
							      	}							    }								  
							      	return count ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF		  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF
--							      --							    --								  --
def findLength ( str ) :				      int findLength ( char * str ) {				    int findLength ( string str ) {				  script_not_found : None
    n = len ( str )					      	int n = strlen ( str ) ;				      int n = str . length ( ) ;				  
    maxlen = 0						      	int maxlen = 0 ;					      int len = 0 ;						  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n , 2 ) :		      	i < n ;							      i < n ;							  
	    length = j - i + 1				      	i ++ ) {						      i ++ ) {							  
	    leftsum = 0					      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
	    rightsum = 0				      	  j < n ;						    	j < n ;							  
	    for k in range ( 0 , int ( length / 2 ) ) :	      	  j += 2 ) {						    	j += 2 ) {						  
		leftsum += ( int ( str [ i + k ] ) - int ( '0 	    int length = j - i + 1 ;				    	  int length = j - i + 1 ;				  
		rightsum += ( int ( str [ i + k + int ( lengt 	    int leftsum = 0 , rightsum = 0 ;			    	  int leftsum = 0 ;					  
	    if ( leftsum == rightsum and maxlen < length ) :  	    for ( int k = 0 ;					    	  int rightsum = 0 ;					  
		maxlen = length				      	    k < length / 2 ;					    	  for ( int k = 0 ;					  
    return maxlen					      	    k ++ ) {						    	  ( int ) ( length / 2 ) > 0 ;				  
							      	      leftsum += ( str [ i + k ] - '0' ) ;		    	  k ++ ) {						  
							      	      rightsum += ( str [ i + k + length / 2 ] - '0' ) ;    	    leftsum += ( ( int ) str [ i + k ] - ( int ) '0' ) ;  
							      	    }							    	    rightsum += ( ( int ) str [ i + k + ( int ) length /  
							      	    if ( leftsum == rightsum && maxlen < length ) maxlen =  	  }							  
							      	  }							    	  if ( ( leftsum == rightsum && len < length ) ) len = le 
							      	}							    	}							  
							      	return maxlen ;						      }								  
							      }								      return len ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE	      CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE	    CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE	  CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE
--							      --							    --								  --
def isChangeable ( notes , n ) :			      int isChangeable ( int notes [ ] , int n ) {		    int isChangeable ( int * notes , int n ) {			  error : CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON
    fiveCount = 0					      	int fiveCount = 0 ;					      int fiveCount = 0 ;					  _IN_THE_QUEUE.cpp: In function ‘int f_filled(int*,
    tenCount = 0					      	int tenCount = 0 ;					      int tenCount = 0 ;					   int)’: CHECK_IF_X_CAN_GIVE_CHANGE_TO_EVERY_PERSON
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  _IN_THE_QUEUE.cpp:61:3: error: ‘else’ without a pr
	if ( notes [ i ] == 5 ) :			      	i < n ;							      i < n ;							  evious ‘if’	 else {	   ^~~~ CHECK_IF_X_CAN_GIVE_
	    fiveCount += 1				      	i ++ ) {						      i ++ ) {							  CHANGE_TO_EVERY_PERSON_IN_THE_QUEUE.cpp:69:1: warn
	elif ( notes [ i ] == 10 ) :			      	  if ( notes [ i ] == 5 ) fiveCount ++ ;		    	if ( ( notes [ i ] == 5 ) ) fiveCount ++ ;		  ing: control reaches end of non-void function [-Wr
	    if ( fiveCount > 0 ) :			      	  else if ( notes [ i ] == 10 ) {			    	else if ( ( notes [ i ] == 10 ) ) {			  eturn-type]  }  ^
		fiveCount -= 1				      	    if ( fiveCount > 0 ) {				    	  if ( ( fiveCount > 0 ) ) {				  
		tenCount += 1				      	      fiveCount -- ;					    	    fiveCount -- ;					  
	    else :					      	      tenCount ++ ;					    	    tenCount ++ ;					  
		return 0				      	    }							    	  }							  
	else :						      	    else return 0 ;					    	  else return 0 ;					  
	    if ( fiveCount > 0 and tenCount > 0 ) :	      	  }							    	}							  
		fiveCount -= 1				      	  else {						    	else return 0 ;						  
		tenCount -= 1				      	    if ( fiveCount > 0 && tenCount > 0 ) {		      }								  
	    elif ( fiveCount >= 3 ) :			      	      fiveCount -- ;					      else {							  
		fiveCount -= 3				      	      tenCount -- ;					    	if ( ( fiveCount > 0 ) && ( tenCount > 0 ) ) {		  
	    else :					      	    }							    	  fiveCount -- ;					  
		return 0				      	    else if ( fiveCount >= 3 ) {			    	  tenCount -- ;						  
    return 1						      	      fiveCount -= 3 ;					    	}							  
							      	    }							    	else if ( ( fiveCount >= 3 ) ) fiveCount -= 3 ;		  
							      	    else return 0 ;					    	else return 0 ;						  
							      	  }							      }								  
							      	}							    }								  
							      	return 1 ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONVERTING_DECIMAL_NUMBER_LYING_BETWEEN_1_TO_3999_TO_ROMAN_NU CONVERTING_DECIMAL_NUMBER_LYING_BETWEEN_1_TO_3999_TO_ROMAN_NU CONVERTING_DECIMAL_NUMBER_LYING_BETWEEN_1_TO_3999_TO_ROMAN_NU CONVERTING_DECIMAL_NUMBER_LYING_BETWEEN_1_TO_3999_TO_ROMAN_NU
--							      --							    --								  --
def printRoman ( number ) :				      int printRoman ( int number ) {				    int getNum ( int n ) {					  script_not_found : None
    num = [ 1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 5 	int num [ ] = {						      int sum = 0 ;						  
    sym = [ "I" , "IV" , "V" , "IX" , "X" , "XL" , "L" , "XC" 	  1 , 4 , 5 , 9 , 10 , 40 , 50 , 90 , 100 , 400 , 500 , 900   for ( int i = 0 ;						  
    i = 12						      	  ;							      i < n ;							  
    while number :					      	  string sym [ ] = {					      i ++ ) sum += i ;						  
	div = number // num [ i ]			      	    "I" , "IV" , "V" , "IX" , "X" , "XL" , "L" , "XC" , "C"   string sym = " " + to_string ( n ) ;			  
	number %= num [ i ]				      	    ;							      for ( int i = 0 ;						  
	while div :					      	    int i = 12 ;					      i < n ;							  
	    print ( sym [ i ] , end = "" )		      	    while ( number > 0 ) {				      i ++ ) sum += i ;						  
	    div -= 1					      	      int div = number / num [ i ] ;			      string div = " " + to_string ( n ) ;			  
	i -= 1						      	      number = number % num [ i ] ;			      for ( int i = 0 ;						  
							      	      while ( div -- ) {				      i < n ;							  
							      		cout << sym [ i ] ;				      i ++ ) sum += i ;						  
							      	      }							      return sum ;						  
							      	      i -- ;						      return n * n ;						  
							      	    }							      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      	  }							    }								  
-							      	  -							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUBARRAY_LEAST_AVERAGE				      FIND_SUBARRAY_LEAST_AVERAGE				    FIND_SUBARRAY_LEAST_AVERAGE					  FIND_SUBARRAY_LEAST_AVERAGE
--							      --							    --								  --
def findMinAvgSubarray ( arr , n , k ) :		      void findMinAvgSubarray ( int arr [ ] , int n , int k ) {	    int findMinAvgSubarray ( int * arr , int n , int k ) {	  script_not_found : None
    if ( n < k ) : return 0				      	if ( n < k ) return ;					      if ( ( n < k ) ) return 0 ;				  
    res_index = 0					      	int res_index = 0 ;					      int resIndex = 0 ;					  
    curr_sum = 0					      	int curr_sum = 0 ;					      int currSum = 0 ;						  
    for i in range ( k ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	curr_sum += arr [ i ]				      	i < k ;							      i < k ;							  
    min_sum = curr_sum					      	i ++ ) curr_sum += arr [ i ] ;				      i ++ ) currSum += arr [ i ] ;				  
    for i in range ( k , n ) :				      	int min_sum = curr_sum ;				      int minSum = currSum ;					  
	curr_sum += arr [ i ] - arr [ i - k ]		      	for ( int i = k ;					      for ( int i = k ;						  
	if ( curr_sum < min_sum ) :			      	i < n ;							      i < n ;							  
	    min_sum = curr_sum				      	i ++ ) {						      i ++ ) {							  
	    res_index = ( i - k + 1 )			      	  curr_sum += arr [ i ] - arr [ i - k ] ;		    	currSum += arr [ i ] - arr [ i - k ] ;			  
    print ( "Subarray between [" , res_index , ", " , ( res_i 	  if ( curr_sum < min_sum ) {				    	if ( ( currSum < minSum ) ) {				  
							      	    min_sum = curr_sum ;				    	  minSum = currSum ;					  
							      	    res_index = ( i - k + 1 ) ;				    	  resIndex = ( i - k + 1 ) ;				  
							      	  }							    	}							  
							      	}							      }								  
							      	cout << "Subarray between [" << res_index << ", " << res_in   cout << "Subarray between [" << resIndex << ", " << ( resIn 
							      }								      return resIndex ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY		      SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY		    SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY		  SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_ARRAY
--							      --							    --								  --
def search ( arr , l , h , key ) :			      int search ( int arr [ ] , int l , int h , int key ) {	    int search ( int * arr , int l , int h , int key ) {	  error : SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTED_
    if l > h :						      	if ( l > h ) return - 1 ;				      if ( l > h ) return - 1 ;					  ARRAY.cpp: In function ‘int f_filled(int*, int, in
	return - 1					      	int mid = ( l + h ) / 2 ;				      int mid = ( l + h ) / 2 ;					  t, int)’: SEARCH_AN_ELEMENT_IN_A_SORTED_AND_PIVOTE
    mid = ( l + h ) // 2				      	if ( arr [ mid ] == key ) return mid ;			      if ( arr [ mid ] == key ) return mid ;			  D_ARRAY.cpp:37:67: error: ‘a’ was not declared in
    if arr [ mid ] == key :				      	if ( arr [ l ] <= arr [ mid ] ) {			      if ( arr [ l ] <= arr [ mid ] ) {				  this scope	if ( key >= arr [ mid ] && key <= ar
	return mid					      	  if ( key >= arr [ l ] && key <= arr [ mid ] ) return sear 	if ( key >= arr [ l ] && key <= arr [ mid ] ) return sear r [ h ] ) return f_filled ( a , mid + 1 , h , key
    if arr [ l ] <= arr [ mid ] :			      	  return search ( arr , mid + 1 , h , key ) ;		    	return search ( arr , mid + 1 , h , key ) ;		  ) ;
	if key >= arr [ l ] and key <= arr [ mid ] :	      	}							      }								  		       ^
	    return search ( arr , l , mid - 1 , key )	      	if ( key >= arr [ mid ] && key <= arr [ h ] ) return search   if ( key >= arr [ mid ] && key <= arr [ h ] ) return search 
	return search ( arr , mid + 1 , h , key )	      	return search ( arr , l , mid - 1 , key ) ;		      return search ( arr , l , mid - 1 , key ) ;		  
    if key >= arr [ mid ] and key <= arr [ h ] :	      }								      return l * l ;						  
	return search ( a , mid + 1 , h , key )		      								    }								  
    return search ( arr , l , mid - 1 , key )		      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SORTED_ROWS_MATRIX				      COUNT_SORTED_ROWS_MATRIX					    COUNT_SORTED_ROWS_MATRIX					  COUNT_SORTED_ROWS_MATRIX
--							      --							    --								  --
def sortedCount ( mat , r , c ) :			      int sortedCount ( int mat [ ] [ MAX ] , int r , int c ) {	    int sortedCount ( int * * mat , int r , int c ) {		  script_not_found : None
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    for i in range ( r ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	j = 0						      	i < r ;							      i < r ;							  
	for j in range ( c - 1 ) :			      	i ++ ) {						      i ++ ) {							  
	    if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] :	      	  int j ;						    	int j ;							  
		break					      	  for ( j = 0 ;						    	for ( j = 0 ;						  
	if j == c - 2 :					      	  j < c - 1 ;						    	j < c - 1 ;						  
	    result += 1					      	  j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) brea 	j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) brea 
    for i in range ( 0 , r ) :				      	  if ( j == c - 1 ) result ++ ;				    	if ( j == c - 2 ) result ++ ;				  
	j = 0						      	}							      }								  
	for j in range ( c - 1 , 0 , - 1 ) :		      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] :	      	i < r ;							      i <= r ;							  
		break					      	i ++ ) {						      i ++ ) {							  
	if c > 1 and j == 1 :				      	  int j ;						    	int j ;							  
	    result += 1					      	  for ( j = c - 1 ;					    	for ( j = c - 1 ;					  
    return result					      	  j > 0 ;						    	j > 0 ;							  
							      	  j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) brea 	j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) brea 
							      	  if ( c > 1 && j == 0 ) result ++ ;			    	if ( c > 1 && j == 1 ) result ++ ;			  
							      	}							      }								  
							      	return result ;						      return result ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS		      MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS		    MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS		  MAXIMUM_SUM_INCREASING_ORDER_ELEMENTS_N_ARRAYS
--							      --							    --								  --
def maximumSum ( a , n ) :				      int maximumSum ( int a [ ] [ M ] , int n ) {		    int maximumSum ( int * a , int n ) {			  script_not_found : None
    global M						      	for ( int i = 0 ;					      int M = 0 ;						  
    for i in range ( 0 , n ) :				      	i < n ;							      for ( int i = 0 ;						  
	a [ i ].sort ( )				      	i ++ ) sort ( a [ i ] , a [ i ] + M ) ;			      i <= n ;							  
    sum = a [ n - 1 ] [ M - 1 ]				      	int sum = a [ n - 1 ] [ M - 1 ] ;			      i ++ ) a [ i ] = sort ( a + i , a + n ) ;			  
    prev = a [ n - 1 ] [ M - 1 ]			      	int prev = a [ n - 1 ] [ M - 1 ] ;			      int sum = a [ n - 1 ] [ M - 1 ] ;				  
    for i in range ( n - 2 , - 1 , - 1 ) :		      	int i , j ;						      int prev = a [ n - 1 ] [ M - 1 ] ;			  
	for j in range ( M - 1 , - 1 , - 1 ) :		      	for ( i = n - 2 ;					      for ( int i = n - 2 ;					  
	    if ( a [ i ] [ j ] < prev ) :		      	i >= 0 ;						      i >= 0 ;							  
		prev = a [ i ] [ j ]			      	i -- ) {						      i -- ) {							  
		sum += prev				      	  for ( j = M - 1 ;					    	for ( int j = M - 1 ;					  
		break					      	  j >= 0 ;						    	j >= 0 ;						  
	if ( j == - 1 ) :				      	  j -- ) {						    	j -- ) {						  
	    return 0					      	    if ( a [ i ] [ j ] < prev ) {			    	  if ( ( a [ i ] [ j ] < prev ) ) {			  
    return sum						      	      prev = a [ i ] [ j ] ;				    	    prev = a [ i ] [ j ] ;				  
							      	      sum += prev ;					    	    sum += prev ;					  
							      	      break ;						    	    break ;						  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	  if ( j == - 1 ) return 0 ;				    	if ( ( j == - 1 ) ) return 0 ;				  
							      	}							      }								  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY		      MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY		    MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY		  MAXIMUM_POSSIBLE_DIFFERENCE_TWO_SUBSETS_ARRAY
--							      --							    --								  --
def maxDiff ( arr , n ) :				      int maxDiff ( int arr [ ] , int n ) {			    int maxDiff ( int * arr , int n ) {				  success : None
    SubsetSum_1 = 0					      	int SubsetSum_1 = 0 , SubsetSum_2 = 0 ;			      int SubsetSum_1 = 0 ;					  
    SubsetSum_2 = 0					      	for ( int i = 0 ;					      int SubsetSum_2 = 0 ;					  
    for i in range ( 0 , n ) :				      	i <= n - 1 ;						      for ( int i = 0 ;						  
	isSingleOccurance = True			      	i ++ ) {						      i < n ;							  
	for j in range ( i + 1 , n ) :			      	  bool isSingleOccurance = true ;			      i ++ ) {							  
	    if ( arr [ i ] == arr [ j ] ) :		      	  for ( int j = i + 1 ;					    	bool isSingleOccurance = true ;				  
		isSingleOccurance = False		      	  j <= n - 1 ;						    	for ( int j = i + 1 ;					  
		arr [ i ] = arr [ j ] = 0		      	  j ++ ) {						    	j < n ;							  
		break					      	    if ( arr [ i ] == arr [ j ] ) {			    	j ++ ) {						  
	if ( isSingleOccurance == True ) :		      	      isSingleOccurance = false ;			    	  if ( ( arr [ i ] == arr [ j ] ) ) {			  
	    if ( arr [ i ] > 0 ) :			      	      arr [ i ] = arr [ j ] = 0 ;			    	    isSingleOccurance = false ;				  
		SubsetSum_1 += arr [ i ]		      	      break ;						    	    arr [ i ] = arr [ j ] = 0 ;				  
	    else :					      	    }							    	    break ;						  
		SubsetSum_2 += arr [ i ]		      	  }							    	  }							  
    return abs ( SubsetSum_1 - SubsetSum_2 )		      	  if ( isSingleOccurance ) {				    	}							  
							      	    if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ;	    	if ( ( isSingleOccurance == true ) == true ) {		  
							      	    else SubsetSum_2 += arr [ i ] ;			    	  if ( ( arr [ i ] > 0 ) ) SubsetSum_1 += arr [ i ] ;	  
							      	  }							    	  else SubsetSum_2 += arr [ i ] ;			  
							      	}							    	}							  
							      	return abs ( SubsetSum_1 - SubsetSum_2 ) ;		      }								  
							      }								      return abs ( SubsetSum_1 - SubsetSum_2 ) ;		  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_DERANGEMENT_SEQUENCE				      SMALLEST_DERANGEMENT_SEQUENCE				    SMALLEST_DERANGEMENT_SEQUENCE				  SMALLEST_DERANGEMENT_SEQUENCE
--							      --							    --								  --
def generate_derangement ( N ) :			      void generate_derangement ( int N ) {			    int generateDerangement ( int N ) {				  script_not_found : None
    S = [ 0 ] * ( N + 1 )				      	int S [ N + 1 ] ;					      vector < int > S ( N + 1 , 0 ) ;				  
    for i in range ( 1 , N + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	S [ i ] = i					      	i <= N ;						      i <= N ;							  
    D = [ 0 ] * ( N + 1 )				      	i ++ ) S [ i ] = i ;					      i ++ ) S [ i ] = i ;					  
    for i in range ( 1 , N + 1 , 2 ) :			      	int D [ N + 1 ] ;					      vector < int > D ( N + 1 , 0 ) ;				  
	if i == N :					      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	    D [ N ] = S [ N - 1 ]			      	i <= N ;						      i <= N ;							  
	    D [ N - 1 ] = S [ N ]			      	i += 2 ) {						      i += 2 ) {						  
	else :						      	  if ( i == N && i % N != 0 ) {				    	if ( i == N ) {						  
	    D [ i ] = i + 1				      	    int temp = D [ N ] D [ N ] = D [ N - 1 ] ;		    	  D [ N ] = S [ N - 1 ] ;				  
	    D [ i + 1 ] = i				      	    D [ N - 1 ] = temp ;				    	  D [ N - 1 ] = S [ N ] ;				  
    for i in range ( 1 , N + 1 ) :			      	  }							    	}							  
	print ( D [ i ] , end = " " )			      	  else {						    	else {							  
    print ( )						      	    D [ i ] = i + 1 ;					    	  D [ i ] = i + 1 ;					  
							      	    D [ i + 1 ] = i ;					    	  D [ i + 1 ] = i ;					  
							      	  }							    	}							  
							      	}							      }								  
							      	for ( int i = 1 ;					      for ( int i = 1 ;						  
							      	i <= N ;						      i <= N ;							  
							      	i ++ ) printf ( "%d " , D [ i ] ) ;			      i ++ ) cout << D [ i ] << " " ;				  
							      	printf ( "\n" ) ;					      cout << endl ;						  
							      }								      return N ;						  
							      								      return N * N ;						  
-							      -								      return N * N * N * N * N * N * N * N * N * N * N * N * N *  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE MAXIMUM_LENGTH_SUBSEQUENCE_DIFFERENCE_ADJACENT_ELEMENTS_EITHE
--							      --							    --								  --
def maxLenSub ( arr , n ) :				      int maxLenSub ( int arr [ ] , int n ) {			    int maxLenSub ( int * arr , int n ) {			  success : None
    mls = [ ]						      	int mls [ n ] , max = 0 ;				      int mls [ n ] ;						  
    max = 0						      	for ( int i = 0 ;					      int max = 0 ;						  
    for i in range ( n ) :				      	i < n ;							      for ( int i = 0 ;						  
	mls.append ( 1 )				      	i ++ ) mls [ i ] = 1 ;					      i < n ;							  
    for i in range ( n ) :				      	for ( int i = 1 ;					      i ++ ) mls [ i ] = 1 ;					  
	for j in range ( i ) :				      	i < n ;							      for ( int i = 0 ;						  
	    if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ 	i ++ ) for ( int j = 0 ;				      i < n ;							  
		mls [ i ] = mls [ j ] + 1		      	j < i ;							      i ++ ) for ( int j = 0 ;					  
    for i in range ( n ) :				      	j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ]   j < i ;							  
	if ( max < mls [ i ] ) :			      	for ( int i = 0 ;					      j ++ ) if ( ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i 
	    max = mls [ i ]				      	i < n ;							      for ( int i = 0 ;						  
    return max						      	i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ;		      i < n ;							  
							      	return max ;						      i ++ ) if ( ( max < mls [ i ] ) ) max = mls [ i ] ;	  
							      }								      return max ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S DELETE_ARRAY_ELEMENTS_WHICH_ARE_SMALLER_THAN_NEXT_OR_BECOME_S
--							      --							    --								  --
def deleteElements ( arr , n , k ) :			      void deleteElements ( int arr [ ] , int n , int k ) {	    int countDigits ( string str , int length ) {		  script_not_found : None
    st = [ ]						      	stack < int > s ;					      string :: size_type pos = 0 ;				  
    st.append ( arr [ 0 ] )				      	s . push ( arr [ 0 ] ) ;				      for ( int i = 0 ;						  
    top = 0						      	int count = 0 ;						      i < length ;						  
    count = 0						      	for ( int i = 1 ;					      i ++ ) {							  
    for i in range ( 1 , n ) :				      	i < n ;							    	char c = str [ pos ] ;					  
	while ( len ( st ) != 0 and count < k and st [ top ]  	i ++ ) {						    	if ( c == '.' ) {					  
	    st.pop ( )					      	  while ( ! s . empty ( ) && s . top ( ) < arr [ i ] && cou 	  pos ++ ;						  
	    count += 1					      	    s . pop ( ) ;					    	}							  
	    top -= 1					      	    count ++ ;						    	else if ( c == '-' ) {					  
	st.append ( arr [ i ] )				      	  }							    	  pos ++ ;						  
	top += 1					      	  s . push ( arr [ i ] ) ;				    	}							  
    for i in range ( 0 , len ( st ) ) :			      	}							    	else if ( c == '+' ) {					  
	print ( st [ i ] , "" , end = "" )		      	int m = s . size ( ) ;					    	  pos ++ ;						  
							      	vector < int > v ( m ) ;				    	}							  
							      	while ( ! s . empty ( ) ) {				    	else if ( c == '*' ) {					  
							      	  v [ -- m ] = s . top ( ) ;				    	  pos ++ ;						  
							      	  s . pop ( ) ;						    	}							  
							      	}							    	else if ( c == '/' ) {					  
							      	for ( auto x : v ) cout << x << " " ;			    	  pos ++ ;						  
							      	cout << endl ;						    	}							  
							      }								    	else if ( c == '?' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '*' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '+' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '-' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '*' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '/' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '?' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '*' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '+' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '-' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '*' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '/' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '?' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '*' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '?' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '*' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '+' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '-' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '+' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '*' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '/' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '?' ) {					  
							      								    	  pos ++ ;						  
							      								    	}							  
							      								    	else if ( c == '*' ) {					  
-							      -								    	  -							  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8	      GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8	    GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8	  GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8
--							      --							    --								  --
def isSubSeqDivisible ( st ) :				      bool isSubSeqDivisible ( string str ) {			    bool isSubSeqDivisible ( string st ) {			  script_not_found : None
    l = len ( st )					      	for ( int i = 0 ;					      int l = st . length ( ) ;					  
    arr = [ 0 ] * l					      	i < l ;							      int arr [ l ] ;						  
    for i in range ( 0 , l ) :				      	i ++ ) {						      for ( int i = 0 ;						  
	for j in range ( i , l ) :			      	  for ( int j = i ;					      i <= l ;							  
	    for k in range ( j , l ) :			      	  j < l ;						      i ++ ) {							  
		if ( arr [ i ] % 8 == 0 ) :		      	  j ++ ) {						    	for ( int j = i ;					  
		    return True				      	    for ( int k = j ;					    	j < l ;							  
		elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 ==  	    k < l ;						    	j ++ ) {						  
		    return True				      	    k ++ ) {						    	  for ( int k = j ;					  
		elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + a 	      if ( arr [ i ] % 8 == 0 ) return true ;		    	  k < l ;						  
		    return True				      	      else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 &&  	  k ++ ) {						  
    return False					      	      else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [  	    if ( ( arr [ i ] % 8 == 0 ) ) return true ;		  
							      	    }							    	    else if ( ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 ) 
							      	  }							    	    else if ( ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr  
							      	}							    	  }							  
							      	return false ;						    	}							  
							      }								      }								  
							      								    }								  
							      								    return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_ LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_ LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_ LEXICOGRAPHICALLY_LARGEST_SUBSEQUENCE_EVERY_CHARACTER_OCCURS_
--							      --							    --								  --
def subsequence ( s , t , n , k ) :			      void subsequence ( char s [ ] , char t [ ] , int n , int k )  int subsequence ( string s , string t , int n , int k ) {	  script_not_found : None
    last = 0						      	int last = 0 , cnt = 0 , new_last = 0 , size = 0 ;	      int last = 0 ;						  
    cnt = 0						      	for ( char ch = 'z' ;					      int cnt ;							  
    new_last = 0					      	ch >= 'a' ;						      int newLast = 0 ;						  
    size = 0						      	ch -- ) {						      int size = 0 ;						  
    string = 'zyxwvutsrqponmlkjihgfedcba'		      	  cnt = 0 ;						      string string = "zyxwvutsrqponmlkjihgfedcba" ;		  
    for ch in string :					      	  for ( int i = last ;					      for ( char ch : string ) {				  
	cnt = 0						      	  i < n ;						    	cnt = 0 ;						  
	for i in range ( last , n ) :			      	  i ++ ) {						    	for ( int i = last ;					  
	    if s [ i ] == ch :				      	    if ( s [ i ] == ch ) cnt ++ ;			    	i < n ;							  
		cnt += 1				      	  }							    	i ++ ) if ( s [ i ] == ch ) cnt ++ ;			  
	if cnt >= k :					      	  if ( cnt >= k ) {					    	if ( cnt >= k ) for ( int i = last ;			  
	    for i in range ( last , n ) :		      	    for ( int i = last ;				    	i < n ;							  
		if s [ i ] == ch :			      	    i < n ;						    	i ++ ) if ( s [ i ] == ch ) {				  
		    t [ size ] = ch			      	    i ++ ) {						    	  t [ size ] = ch ;					  
		    new_last = i			      	      if ( s [ i ] == ch ) {				    	  newLast = i ;						  
		    size += 1				      		t [ size ++ ] = ch ;				    	  size ++ ;						  
	    last = new_last				      		new_last = i ;					    	}							  
							      	      }							      }								  
							      	    }							      last = newLast ;						  
							      	    last = new_last ;					      return size ;						  
							      	  }							    }								  
							      	}							    								  
							      	t [ size ] = '\0' ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MEDIAN_OF_TWO_SORTED_ARRAYS				      MEDIAN_OF_TWO_SORTED_ARRAYS				    MEDIAN_OF_TWO_SORTED_ARRAYS					  MEDIAN_OF_TWO_SORTED_ARRAYS
--							      --							    --								  --
def getMedian ( ar1 , ar2 , n ) :			      int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) {	    double getMedian ( double * ar1 , double * ar2 , int n ) {	  error : MEDIAN_OF_TWO_SORTED_ARRAYS.cpp: In functi
    i = 0						      	int i = 0 ;						      int i = 0 ;						  on ‘int main()’: MEDIAN_OF_TWO_SORTED_ARRAYS.cpp:8
    j = 0						      	int j = 0 ;						      int j = 0 ;						  9:21: error: cannot convert ‘__gnu_cxx::__alloc_tr
    m1 = - 1						      	int count ;						      double m1 = - 1 ;						  aits<std::allocator<int>, int>::value_type*’ {aka
    m2 = - 1						      	int m1 = - 1 , m2 = - 1 ;				      double m2 = - 1 ;						  ‘int*’} to ‘double*’		if(f_filled(&param0[
    count = 0						      	for ( count = 0 ;					      int count = 0 ;						  i].front(),&param1[i].front(),param2[i]) == f_gold
    while count < n + 1 :				      	count <= n ;						      while ( count < n + 1 ) {					  (&param0[i].front(),&param1[i].front(),param2[i]))
	count += 1					      	count ++ ) {						    	count ++ ;						  			^~~~~~~~~~~~~~~~~~ MEDIAN_OF
	if i == n :					      	  if ( i == n ) {					    	if ( i == n ) {						  _TWO_SORTED_ARRAYS.cpp:49:28: note:	initializing
	    m1 = m2					      	    m1 = m2 ;						    	  m1 = m2 ;						   argument 1 of ‘double f_filled(double*, double*,
	    m2 = ar2 [ 0 ]				      	    m2 = ar2 [ 0 ] ;					    	  m2 = ar2 [ 0 ] ;					  int)’	 double f_filled ( double * ar1 , double * a
	    break					      	    break ;						    	  break ;						  r2 , int n ) {		    ~~~~~~~~~^~~
	elif j == n :					      	  }							    	}							  
	    m1 = m2					      	  else if ( j == n ) {					    	else if ( j == n ) {					  
	    m2 = ar1 [ 0 ]				      	    m1 = m2 ;						    	  m1 = m2 ;						  
	    break					      	    m2 = ar1 [ 0 ] ;					    	  m2 = ar1 [ 0 ] ;					  
	if ar1 [ i ] < ar2 [ j ] :			      	    break ;						    	  break ;						  
	    m1 = m2					      	  }							    	}							  
	    m2 = ar1 [ i ]				      	  if ( ar1 [ i ] < ar2 [ j ] ) {			    	if ( ar1 [ i ] < ar2 [ j ] ) {				  
	    i += 1					      	    m1 = m2 ;						    	  m1 = m2 ;						  
	else :						      	    m2 = ar1 [ i ] ;					    	  m2 = ar1 [ i ] ;					  
	    m1 = m2					      	    i ++ ;						    	  i ++ ;						  
	    m2 = ar2 [ j ]				      	  }							    	}							  
	    j += 1					      	  else {						    	else {							  
    return ( m1 + m2 ) / 2				      	    m1 = m2 ;						    	  m1 = m2 ;						  
							      	    m2 = ar2 [ j ] ;					    	  m2 = ar2 [ j ] ;					  
							      	    j ++ ;						    	  j ++ ;						  
							      	  }							    	}							  
							      	}							      }								  
							      	return ( m1 + m2 ) / 2 ;				      return ( m1 + m2 ) / 2 ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES	      REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES		    REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES		  REARRANGE_BINARY_STRING_ALTERNATE_X_Y_OCCURRENCES
--							      --							    --								  --
def arrangeString ( str1 , x , y ) :			      void arrangeString ( string str , int x , int y ) {	    int findFirstLetter ( string str1 , int start , int end ) {	  script_not_found : None
    count_0 = 0						      	int count_0 = 0 ;					      int i , j ;						  
    count_1 = 0						      	int count_1 = 0 ;					      int count = 0 ;						  
    n = len ( str1 )					      	int len = str . length ( ) ;				      for ( i = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      i < end ;							  
	if str1 [ i ] == '0' :				      	i < len ;						      i ++ ) {							  
	    count_0 += 1				      	i ++ ) {						    	if ( str1 [ i ] == '0' ) count ++ ;			  
	else :						      	  if ( str [ i ] == '0' ) count_0 ++ ;			    	else count ++ ;						  
	    count_1 += 1				      	  else count_1 ++ ;					      }								  
    while count_0 > 0 or count_1 > 0 :			      	}							      while ( count > 0 || count > 1 ) {			  
	for i in range ( 0 , x ) :			      	while ( count_0 > 0 || count_1 > 0 ) {			    	for ( i = 0 ;						  
	    if count_0 > 0 :				      	  for ( int j = 0 ;					    	i <= start ;						  
		print ( "0" , end = "" )		      	  j < x && count_0 > 0 ;				    	i ++ ) {						  
		count_0 -= 1				      	  j ++ ) {						    	  if ( count > 0 ) {					  
	for j in range ( 0 , y ) :			      	    if ( count_0 > 0 ) {				    	    cout << "0" << endl ;				  
	    if count_1 > 0 :				      	      cout << "0" ;					    	    count -- ;						  
		print ( "1" , end = "" )		      	      count_0 -- ;					    	  }							  
		count_1 -= 1				      	    }							    	}							  
							      	  }							    	for ( j = 0 ;						  
							      	  for ( int j = 0 ;					    	j < end ;						  
							      	  j < y && count_1 > 0 ;				    	j ++ ) {						  
							      	  j ++ ) {						    	  if ( count > 0 ) {					  
							      	    if ( count_1 > 0 ) {				    	    cout << "1" << endl ;				  
							      	      cout << "1" ;					    	    count -- ;						  
							      	      count_1 -- ;					    	  }							  
							      	    }							    	}							  
							      	  }							      }								  
							      	}							      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_LINE_PASSING_2_POINTS			      PROGRAM_FIND_LINE_PASSING_2_POINTS			    PROGRAM_FIND_LINE_PASSING_2_POINTS				  PROGRAM_FIND_LINE_PASSING_2_POINTS
--							      --							    --								  --
def lineFromPoints ( P , Q ) :				      pair < double , double > void lineFromPoints ( pdd P , pdd Q  void lineFromPoints ( double * P , double * Q ) {		  script_not_found : None
    a = Q [ 1 ] - P [ 1 ]				      	double a = Q . second - P . second ;			      double a = Q [ 1 ] - P [ 1 ] ;				  
    b = P [ 0 ] - Q [ 0 ]				      	double b = P . first - Q . first ;			      double b = P [ 0 ] - Q [ 0 ] ;				  
    c = a * ( P [ 0 ] ) + b * ( P [ 1 ] )		      	double c = a * ( P . first ) + b * ( P . second ) ;	      double c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) ;		  
    if ( b < 0 ) :					      	if ( b < 0 ) {						      if ( ( b < 0 ) ) cout << "The line passing through points P 
	print ( "The line passing through points P and Q is:" 	  cout << "The line passing through points P and Q is: " <<   else cout << "The line passing through points P and Q is: " 
    else :						      	}							    }								  
	print ( "The line passing through points P and Q is:  	else {							    								  
							      	  cout << "The line passing through points P and Q is: " << 								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS		      COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS		    COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS		  COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS
--							      --							    --								  --
def countSubarrays ( arr , n ) :			      int countSubarrays ( int arr [ ] , int n ) {		    int countSubarrays ( int * arr , int n ) {			  error : COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELE
    difference = 0					      	int difference = 0 ;					      int difference = 0 ;					  MENTS.cpp: In function ‘int f_filled(int*, int)’:
    ans = 0						      	int ans = 0 ;						      int ans = 0 ;						  COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS.cp
    hash_positive = [ 0 ] * ( n + 1 )			      	int hash_positive [ n + 1 ] , hash_negative [ n + 1 ] ;	      vector < int > hashPositive ( n + 1 , 0 ) ;		  p:53:72: error: no match for ‘operator[]’ (operand
    hash_negative = [ 0 ] * ( n + 1 )			      	fill_n ( hash_positive , n + 1 , 0 ) ;			      vector < int > hashNegative ( n + 1 , 0 ) ;		   types are ‘std::vector<int>’ and ‘std::vector<int
    hash_positive [ 0 ] = 1				      	fill_n ( hash_negative , n + 1 , 0 ) ;			      hashPositive [ 0 ] = 1 ;					  >’)	     ans += hashNegative [ hashPositive [ ha
    for i in range ( n ) :				      	hash_positive [ 0 ] = 1 ;				      for ( int i = 0 ;						  shPositive [ hashPositive [ hashPositive ] ] ] ;
	if ( arr [ i ] & 1 == 1 ) :			      	for ( int i = 0 ;					      i < n ;							  
	    difference = difference + 1			      	i < n ;							      i ++ ) {							  		       ^ In file included from /usr/
	else :						      	i ++ ) {						    	if ( ( arr [ i ] & 1 ) == 1 ) difference = difference + 1 include/c++/8/vector:64,		    from COU
	    difference = difference - 1			      	  if ( arr [ i ] & 1 == 1 ) difference ++ ;		    	else difference = difference - 1 ;			  NT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS.cpp:1
	if ( difference < 0 ) :				      	  else difference -- ;					    	if ( ( difference < 0 ) ) {				  1: /usr/include/c++/8/bits/stl_vector.h:930:7: not
	    ans += hash_negative [ - difference ]	      	  if ( difference < 0 ) {				    	  ans += hashNegative [ hashPositive [ hashPositive [ has e: candidate: ‘std::vector<_Tp, _Alloc>::reference
	    hash_negative [ - difference ] = hash_negative [  	    ans += hash_negative [ - difference ] ;		    	  hashNegative [ hashPositive [ hashPositive ] ] = hashNe  std::vector<_Tp, _Alloc>::operator[](std::vector<
	else :						      	    hash_negative [ - difference ] ++ ;			    	}							  _Tp, _Alloc>::size_type) [with _Tp = int; _Alloc =
	    ans += hash_positive [ difference ]		      	  }							    	else {							   std::allocator<int>; std::vector<_Tp, _Alloc>::re
	    hash_positive [ difference ] = hash_positive [ di 	  else {						    	  ans += hashPositive [ difference ] ;			  ference = int&; std::vector<_Tp, _Alloc>::size_typ
    return ans						      	    ans += hash_positive [ difference ] ;		    	  hashPositive [ hashPositive [ hashPositive [ hashPositi e = long unsigned int]’	 operator[](size_typ
							      	    hash_positive [ difference ] ++ ;			    	}							  e __n) _GLIBCXX_NOEXCEPT	  ^~~~~~~~ /usr/incl
							      	  }							      }								  ude/c++/8/bits/stl_vector.h:930:7: note:   no know
							      	}							      return ans ;						  n conversion for argument 1 from ‘std::vector<int>
							      	return ans ;						    }								  ’ to ‘std::vector<int>::size_type’ {aka ‘long unsi
							      }								    								  gned int’} /usr/include/c++/8/bits/stl_vector.h:94
							      								    								  8:7: note: candidate: ‘std::vector<_Tp, _Alloc>::c
							      								    								  onst_reference std::vector<_Tp, _Alloc>::operator[
							      								    								  ](std::vector<_Tp, _Alloc>::size_type) const [with
							      								    								   _Tp = int; _Alloc = std::allocator<int>; std::vec
							      								    								  tor<_Tp, _Alloc>::const_reference = const int&; st
							      								    								  d::vector<_Tp, _Alloc>::size_type = long unsigned
							      								    								  int]’	       operator[](size_type __n) const _GLIB
							      								    								  CXX_NOEXCEPT	      ^~~~~~~~ /usr/include/c++/8/bi
							      								    								  ts/stl_vector.h:948:7: note:	 no known conversion
							      								    								   for argument 1 from ‘std::vector<int>’ to ‘std::v
							      								    								  ector<int>::size_type’ {aka ‘long unsigned int’} C
							      								    								  OUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS.cpp
							      								    								  :53:92: error: expected ‘]’ before ‘;’ token
							      								    								    ans += hashNegative [ hashPositive [ hashPositiv
							      								    								  e [ hashPositive [ hashPositive ] ] ] ;
							      								    								  
							      								    								  				  ^~
							      								    								  
							      								    								  			     ] COUNT_SUBARRAYS_WITH_
							      								    								  SAME_EVEN_AND_ODD_ELEMENTS.cpp:54:35: error: no ma
							      								    								  tch for ‘operator[]’ (operand types are ‘std::vect
							      								    								  or<int>’ and ‘std::vector<int>’)	  hashNegati
							      								    								  ve [ hashPositive [ hashPositive ] ] = hashNegativ
							      								    								  e [ hashPositive [ hashPositive ] ] + 1 ;
							      								    								  			     ^ In file included from
							      								    								   /usr/include/c++/8/vector:64,		  fr
							      								    								  om COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS
							      								    								  .cpp:11: /usr/include/c++/8/bits/stl_vector.h:930:
							      								    								  7: note: candidate: ‘std::vector<_Tp, _Alloc>::ref
							      								    								  erence std::vector<_Tp, _Alloc>::operator[](std::v
							      								    								  ector<_Tp, _Alloc>::size_type) [with _Tp = int; _A
							      								    								  lloc = std::allocator<int>; std::vector<_Tp, _Allo
							      								    								  c>::reference = int&; std::vector<_Tp, _Alloc>::si
							      								    								  ze_type = long unsigned int]’	       operator[](si
							      								    								  ze_type __n) _GLIBCXX_NOEXCEPT	^~~~~~~~ /us
							      								    								  r/include/c++/8/bits/stl_vector.h:930:7: note:   n
							      								    								  o known conversion for argument 1 from ‘std::vecto
							      								    								  r<int>’ to ‘std::vector<int>::size_type’ {aka ‘lon
							      								    								  g unsigned int’} /usr/include/c++/8/bits/stl_vecto
							      								    								  r.h:948:7: note: candidate: ‘std::vector<_Tp, _All
							      								    								  oc>::const_reference std::vector<_Tp, _Alloc>::ope
							      								    								  rator[](std::vector<_Tp, _Alloc>::size_type) const
							      								    								   [with _Tp = int; _Alloc = std::allocator<int>; st
							      								    								  d::vector<_Tp, _Alloc>::const_reference = const in
							      								    								  t&; std::vector<_Tp, _Alloc>::size_type = long uns
							      								    								  igned int]’	     operator[](size_type __n) const
							      								    								   _GLIBCXX_NOEXCEPT	    ^~~~~~~~ /usr/include/c+
							      								    								  +/8/bits/stl_vector.h:948:7: note:   no known conv
							      								    								  ersion for argument 1 from ‘std::vector<int>’ to ‘
							      								    								  std::vector<int>::size_type’ {aka ‘long unsigned i
							      								    								  nt’} COUNT_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMEN
							      								    								  TS.cpp:54:84: error: no match for ‘operator[]’ (op
							      								    								  erand types are ‘std::vector<int>’ and ‘std::vecto
							      								    								  r<int>’)	  hashNegative [ hashPositive [ hash
							      								    								  Positive ] ] = hashNegative [ hashPositive [ hashP
							      								    								  ositive ] ] + 1 ;
							      								    								  
							      								    								    ^ In file included from /usr/include/c++/8/vecto
							      								    								  r:64,			 from COUNT_SUBARRAYS_WITH_S
							      								    								  AME_EVEN_AND_ODD_ELEMENTS.cpp:11: /usr/include/c++
							      								    								  /8/bits/stl_vector.h:930:7: note: candidate: ‘std:
							      								    								  :vector<_Tp, _Alloc>::reference std::vector<_Tp, _
							      								    								  Alloc>::operator[](std::vector<_Tp, _Alloc>::size_
							      								    								  type) [with _Tp = int; _Alloc = std::allocator<int
							      								    								  >; std::vector<_Tp, _Alloc>::reference = int&; std
							      								    								  ::vector<_Tp, _Alloc>::size_type = long unsigned i
							      								    								  nt]’	      operator[](size_type __n) _GLIBCXX_NOE
							      								    								  XCEPT	       ^~~~~~~~ /usr/include/c++/8/bits/stl_
							      								    								  vector.h:930:7: note:	  no known conversion for ar
							      								    								  gument 1 from ‘std::vector<int>’ to ‘std::vector<i
							      								    								  nt>::size_type’ {aka ‘long unsigned int’} /usr/inc
							      								    								  lude/c++/8/bits/stl_vector.h:948:7: note: candidat
							      								    								  e: ‘std::vector<_Tp, _Alloc>::const_reference std:
							      								    								  :vector<_Tp, _Alloc>::operator[](std::vector<_Tp,
							      								    								  _Alloc>::size_type) const [with _Tp = int; _Alloc
							      								    								  = std::allocator<int>; std::vector<_Tp, _Alloc>::c
							      								    								  onst_reference = const int&; std::vector<_Tp, _All
							      								    								  oc>::size_type = long unsigned int]’	      operat
							      								    								  or[](size_type __n) const _GLIBCXX_NOEXCEPT
							      								    								   ^~~~~~~~ /usr/include/c++/8/bits/stl_vector.h:948
							      								    								  :7: note:   no known conversion for argument 1 fro
							      								    								  m ‘std::vector<int>’ to ‘std::vector<int>::size_ty
							      								    								  pe’ {aka ‘long unsigned int’} COUNT_SUBARRAYS_WITH
							      								    								  _SAME_EVEN_AND_ODD_ELEMENTS.cpp:58:50: error: no m
							      								    								  atch for ‘operator[]’ (operand types are ‘std::vec
							      								    								  tor<int>’ and ‘std::vector<int>’)	   hashPosit
							      								    								  ive [ hashPositive [ hashPositive [ hashPositive ]
							      								    								   ] ] = hashPositive [ hashPositive [ hashPositive
							      								    								  ] ] + 1 ;
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/vector:64,			 from COUNT_SUBARRAY
							      								    								  S_WITH_SAME_EVEN_AND_ODD_ELEMENTS.cpp:11: /usr/inc
							      								    								  lude/c++/8/bits/stl_vector.h:930:7: note: candidat
							      								    								  e: ‘std::vector<_Tp, _Alloc>::reference std::vecto
							      								    								  r<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc
							      								    								  >::size_type) [with _Tp = int; _Alloc = std::alloc
							      								    								  ator<int>; std::vector<_Tp, _Alloc>::reference = i
							      								    								  nt&; std::vector<_Tp, _Alloc>::size_type = long un
							      								    								  signed int]’	      operator[](size_type __n) _GLI
							      								    								  BCXX_NOEXCEPT	       ^~~~~~~~ /usr/include/c++/8/b
							      								    								  its/stl_vector.h:930:7: note:	  no known conversio
							      								    								  n for argument 1 from ‘std::vector<int>’ to ‘std::
							      								    								  vector<int>::size_type’ {aka ‘long unsigned int’}
							      								    								  /usr/include/c++/8/bits/stl_vector.h:948:7: note:
							      								    								  candidate: ‘std::vector<_Tp, _Alloc>::const_refere
							      								    								  nce std::vector<_Tp, _Alloc>::operator[](std::vect
							      								    								  or<_Tp, _Alloc>::size_type) const [with _Tp = int;
							      								    								   _Alloc = std::allocator<int>; std::vector<_Tp, _A
							      								    								  lloc>::const_reference = const int&; std::vector<_
							      								    								  Tp, _Alloc>::size_type = long unsigned int]’
							      								    								    operator[](size_type __n) const _GLIBCXX_NOEXCEP
							      								    								  T	   ^~~~~~~~ /usr/include/c++/8/bits/stl_vect
							      								    								  or.h:948:7: note:   no known conversion for argume
							      								    								  nt 1 from ‘std::vector<int>’ to ‘std::vector<int>:
							      								    								  :size_type’ {aka ‘long unsigned int’} COUNT_SUBARR
							      								    								  AYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS.cpp:58:101: er
							      								    								  ror: no match for ‘operator[]’ (operand types are
							      								    								  ‘std::vector<int>’ and ‘std::vector<int>’)
							      								    								  hashPositive [ hashPositive [ hashPositive [ hashP
							      								    								  ositive ] ] ] = hashPositive [ hashPositive [ hash
							      								    								  Positive ] ] + 1 ;
							      								    								  
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/vector:64,		   from COUN
							      								    								  T_SUBARRAYS_WITH_SAME_EVEN_AND_ODD_ELEMENTS.cpp:11
							      								    								  : /usr/include/c++/8/bits/stl_vector.h:930:7: note
							      								    								  : candidate: ‘std::vector<_Tp, _Alloc>::reference
							      								    								  std::vector<_Tp, _Alloc>::operator[](std::vector<_
							      								    								  Tp, _Alloc>::size_type) [with _Tp = int; _Alloc =
							      								    								  std::allocator<int>; std::vector<_Tp, _Alloc>::ref
							      								    								  erence = int&; std::vector<_Tp, _Alloc>::size_type
							      								    								   = long unsigned int]’	operator[](size_type
							      								    								   __n) _GLIBCXX_NOEXCEPT	 ^~~~~~~~ /usr/inclu
							      								    								  de/c++/8/bits/stl_vector.h:930:7: note:   no known
							      								    								   conversion for argument 1 from ‘std::vector<int>’
							      								    								   to ‘std::vector<int>::size_type’ {aka ‘long unsig
							      								    								  ned int’} /usr/include/c++/8/bits/stl_vector.h:948
							      								    								  :7: note: candidate: ‘std::vector<_Tp, _Alloc>::co
							      								    								  nst_reference std::vector<_Tp, _Alloc>::operator[]
							      								    								  (std::vector<_Tp, _Alloc>::size_type) const [with
							      								    								  _Tp = int; _Alloc = std::allocator<int>; std::vect
							      								    								  or<_Tp, _Alloc>::const_reference = const int&; std
							      								    								  ::vector<_Tp, _Alloc>::size_type = long unsigned i
							      								    								  nt]’	      operator[](size_type __n) const _GLIBC
							      								    								  XX_NOEXCEPT	     ^~~~~~~~ /usr/include/c++/8/bit
							      								    								  s/stl_vector.h:948:7: note:	no known conversion
							      								    								  for argument 1 from ‘std::vector<int>’ to ‘std::ve
							      								    								  ctor<int>::size_type’ {aka ‘long unsigned int’}
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH		      FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH			    FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH			  FIND_MAXIMUM_AVERAGE_SUBARRAY_OF_K_LENGTH
--							      --							    --								  --
def findMaxAverage ( arr , n , k ) :			      int findMaxAverage ( int arr [ ] , int n , int k ) {	    int findMaxAverage ( int * arr , int n , int k ) {		  success : None
    if k > n :						      	if ( k > n ) return - 1 ;				      if ( k > n ) return - 1 ;					  
	return - 1					      	int * csum = new int [ n ] ;				      vector < int > csum ( n , 0 ) ;				  
    csum = [ 0 ] * n					      	csum [ 0 ] = arr [ 0 ] ;				      csum [ 0 ] = arr [ 0 ] ;					  
    csum [ 0 ] = arr [ 0 ]				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
    for i in range ( 1 , n ) :				      	i < n ;							      i < n ;							  
	csum [ i ] = csum [ i - 1 ] + arr [ i ]		      	i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ;	      i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ;		  
    max_sum = csum [ k - 1 ]				      	int max_sum = csum [ k - 1 ] , max_end = k - 1 ;	      int maxSum = csum [ k - 1 ] ;				  
    max_end = k - 1					      	for ( int i = k ;					      int maxEnd = k - 1 ;					  
    for i in range ( k , n ) :				      	i < n ;							      for ( int i = k ;						  
	curr_sum = csum [ i ] - csum [ i - k ]		      	i ++ ) {						      i < n ;							  
	if curr_sum > max_sum :				      	  int curr_sum = csum [ i ] - csum [ i - k ] ;		      i ++ ) {							  
	    max_sum = curr_sum				      	  if ( curr_sum > max_sum ) {				    	int currSum = csum [ i ] - csum [ i - k ] ;		  
	    max_end = i					      	    max_sum = curr_sum ;				    	if ( currSum > maxSum ) {				  
    return max_end - k + 1				      	    max_end = i ;					    	  maxSum = currSum ;					  
							      	  }							    	  maxEnd = i ;						  
							      	}							    	}							  
							      	delete [ ] csum ;					      }								  
							      	return max_end - k + 1 ;				      return maxEnd - k + 1 ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K	      COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K		    COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K		  COUNT_DISTINCT_ELEMENTS_IN_EVERY_WINDOW_OF_SIZE_K
--							      --							    --								  --
def countDistinct ( arr , k , n ) :			      void countDistinct ( int arr [ ] , int k , int n ) {	    int countDistinct ( int * arr , int k , int n ) {		  script_not_found : None
    mp = defaultdict ( lambda : 0 )			      	map < int , int > hm ;					      map < int , int > mp ;					  
    dist_count = 0					      	int dist_count = 0 ;					      int distCount = 0 ;					  
    for i in range ( k ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if mp [ arr [ i ] ] == 0 :			      	i < k ;							      i < k ;							  
	    dist_count += 1				      	i ++ ) {						      i ++ ) {							  
	mp [ arr [ i ] ] += 1				      	  if ( hm [ arr [ i ] ] == 0 ) {			    	if ( mp [ arr [ i ] ] == 0 ) distCount ++ ;		  
    print ( dist_count )				      	    dist_count ++ ;					    	mp [ arr [ i ] ] ++ ;					  
    for i in range ( k , n ) :				      	  }							      }								  
	if mp [ arr [ i - k ] ] == 1 :			      	  hm [ arr [ i ] ] += 1 ;				      cout << distCount << endl ;				  
	    dist_count -= 1				      	}							      for ( int i = k ;						  
	mp [ arr [ i - k ] ] -= 1			      	cout << dist_count << endl ;				      i < n ;							  
	if mp [ arr [ i ] ] == 0 :			      	for ( int i = k ;					      i ++ ) {							  
	    dist_count += 1				      	i < n ;							    	if ( mp [ arr [ i - k ] ] == 1 ) distCount -- ;		  
	mp [ arr [ i ] ] += 1				      	i ++ ) {						    	mp [ arr [ i - k ] ] -- ;				  
	print ( dist_count )				      	  if ( hm [ arr [ i - k ] ] == 1 ) {			    	if ( mp [ arr [ i ] ] == 0 ) distCount ++ ;		  
							      	    dist_count -- ;					    	mp [ arr [ i ] ] ++ ;					  
							      	  }							    	cout << distCount << endl ;				  
							      	  hm [ arr [ i - k ] ] -= 1 ;				      }								  
							      	  if ( hm [ arr [ i ] ] == 0 ) {			      return distCount ;					  
							      	    dist_count ++ ;					      return k * k ;						  
							      	  }							    }								  
							      	  hm [ arr [ i ] ] += 1 ;				    								  
							      	  cout << dist_count << endl ;				    								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2	  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_2
--							      --							    --								  --
def findLength ( string , n ) :				      int findLength ( string str , int n ) {			    int findLength ( string string , int n ) {			  script_not_found : None
    Sum = [ 0 ] * ( n + 1 )				      	int sum [ n + 1 ] ;					      vector < int > Sum ( n + 1 , 0 ) ;			  
    for i in range ( 1 , n + 1 ) :			      	sum [ 0 ] = 0 ;						      for ( int i = 1 ;						  
	Sum [ i ] = ( Sum [ i - 1 ] + int ( string [ i - 1 ]  	for ( int i = 1 ;					      i <= n ;							  
    ans = 0						      	i <= n ;						      i ++ ) Sum [ i ] = ( Sum [ i - 1 ] + atoi ( string [ i - 1  
    for length in range ( 2 , n + 1 , 2 ) :		      	i ++ ) sum [ i ] = ( sum [ i - 1 ] + str [ i - 1 ] - '0' )    int ans = 0 ;						  
	for i in range ( 0 , n - length + 1 ) :		      	int ans = 0 ;						      for ( int length = 2 ;					  
	    j = i + length - 1				      	for ( int len = 2 ;					      length <= n ;						  
	    if ( Sum [ i + length // 2 ] - Sum [ i ] == Sum [ 	len <= n ;						      length += 2 ) {						  
		ans = max ( ans , length )		      	len += 2 ) {						    	for ( int i = 0 ;					  
    return ans						      	  for ( int i = 0 ;					    	i <= n - length + 1 ;					  
							      	  i <= n - len ;					    	i ++ ) {						  
							      	  i ++ ) {						    	  int j = i + length - 1 ;				  
							      	    int j = i + len - 1 ;				    	  if ( ( Sum [ i + length / 2 ] - Sum [ i ] == Sum [ i +  
							      	    if ( sum [ i + len / 2 ] - sum [ i ] == sum [ i + len ] 	}							  
							      	  }							      }								  
							      	}							      return ans ;						  
							      	return ans ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_TWO_NUMBERS_B_FIND_X_X_B				      GIVEN_TWO_NUMBERS_B_FIND_X_X_B				    GIVEN_TWO_NUMBERS_B_FIND_X_X_B				  GIVEN_TWO_NUMBERS_B_FIND_X_X_B
--							      --							    --								  --
def modularEquation ( a , b ) :				      void modularEquation ( int a , int b ) {			    int modularEquation ( int a , int b ) {			  script_not_found : None
    if ( a < b ) :					      	if ( a < b ) {						      if ( ( a < b ) ) {					  
	print ( "No solution possible " )		      	  cout << "No solution possible " << endl ;		    	cout << "No solution possible " << endl ;		  
	return						      	  return ;						    	return 0 ;						  
    if ( a == b ) :					      	}							      }								  
	print ( "Infinite Solution possible " )		      	if ( a == b ) {						      if ( ( a == b ) ) {					  
	return						      	  cout << "Infinite Solution possible " << endl ;	    	cout << "Infinite Solution possible " << endl ;		  
    count = 0						      	  return ;						    	return 0 ;						  
    n = a - b						      	}							      }								  
    y = ( int ) ( math.sqrt ( a - b ) )			      	int count = 0 ;						      int count = 0 ;						  
    for i in range ( 1 , y + 1 ) :			      	int n = a - b ;						      int n = a - b ;						  
	if ( n % i == 0 ) :				      	int y = sqrt ( a - b ) ;				      int y = ( int ) ( sqrt ( a - b ) ) ;			  
	    if ( n / i > b ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
		count = count + 1			      	i <= y ;						      i <= y ;							  
	    if ( i > b ) :				      	++ i ) {						      i ++ ) {							  
		count = count + 1			      	  if ( n % i == 0 ) {					    	if ( ( n % i == 0 ) ) {					  
    if ( y * y == n and y > b ) :			      	    if ( n / i > b ) count ++ ;				    	  if ( ( n / i > b ) ) count = count + 1 ;		  
	count = count - 1				      	    if ( i > b ) count ++ ;				    	  if ( ( i > b ) ) count = count + 1 ;			  
    print ( count )					      	  }							    	}							  
							      	}							      }								  
							      	if ( y * y == n && y > b ) count -- ;			      if ( ( y * y == n ) && ( y > b ) ) count = count - 1 ;	  
							      	cout << count << endl ;					      cout << count << endl ;					  
							      }								      return count ;						  
							      								      return a * a ;						  
							      								      return a * a * a * a * a * a * a * a * a * a * a * a * a *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_VALID_SEQUENCE_DIVISIBLE_M_1			      CHECK_VALID_SEQUENCE_DIVISIBLE_M_1			    CHECK_VALID_SEQUENCE_DIVISIBLE_M_1				  CHECK_VALID_SEQUENCE_DIVISIBLE_M_1
--							      --							    --								  --
def isPossible ( n , index , modulo , M , arr , dp ) :	      int isPossible ( int n , int index , int modulo , int M , int int isPossible ( int n , int index , int modulo , int M , int script_not_found : None
    modulo = ( ( modulo % M ) + M ) % M			      	modulo = ( ( modulo % M ) + M ) % M ;			      modulo = ( ( modulo % M ) + M ) % M ;			  
    if ( index == n ) :					      	if ( index == n ) {					      if ( ( index == n ) ) {					  
	if ( modulo == 0 ) :				      	  if ( modulo == 0 ) return 1 ;				    	if ( ( modulo == 0 ) ) return 1 ;			  
	    return 1					      	  return 0 ;						    	return 0 ;						  
	return 0					      	}							      }								  
    if ( dp [ index ] [ modulo ] != - 1 ) :		      	if ( dp [ index ] [ modulo ] != - 1 ) return dp [ index ] [   if ( ( dp [ index ] [ modulo ] != - 1 ) ) return dp [ index 
	return dp [ index ] [ modulo ]			      	int placeAdd = isPossible ( n , index + 1 , modulo + arr [    bool placeAdd = isPossible ( n , index + 1 , modulo + arr [ 
    placeAdd = isPossible ( n , index + 1 , modulo + arr [ in 	int placeMinus = isPossible ( n , index + 1 , modulo - arr    bool placeMinus = isPossible ( n , index + 1 , modulo - arr 
    placeMinus = isPossible ( n , index + 1 , modulo - arr [  	bool res = ( placeAdd || placeMinus ) ;			      bool res = ( placeAdd || placeMinus ) ;			  
    res = bool ( placeAdd or placeMinus )		      	dp [ index ] [ modulo ] = res ;				      dp [ index ] [ modulo ] = res ;				  
    dp [ index ] [ modulo ] = res			      	return res ;						      return res ;						  
    return res						      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA			      FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA			    FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA			  FINDING_VERTEX_FOCUS_DIRECTRIX_PARABOLA
--							      --							    --								  --
def parabola ( a , b , c ) :				      void parabola ( float a , float b , float c ) {		    int parabola ( int a , int b , int c ) {			  script_not_found : None
    print ( "Vertex: (" , ( - b / ( 2 * a ) ) , ", " , ( ( (  	cout << "Vertex: (" << ( - b / ( 2 * a ) ) << ", " << ( ( (   cout << "Vertex: (" << ( - b / ( 2 * a ) ) << ", " << ( ( ( 
    print ( "Focus: (" , ( - b / ( 2 * a ) ) , ", " , ( ( ( 4 	cout << "Focus: (" << ( - b / ( 2 * a ) ) << ", " << ( ( (    cout << "Focus: (" << ( - b / ( 2 * a ) ) << ", " << ( ( (  
    print ( "Directrix: y=" , c - ( ( b * b ) + 1 ) * 4 * a , 	cout << "Directrix: y=" << c - ( ( b * b ) + 1 ) * 4 * a <<   cout << "Directrix: y=" << c - ( ( b * b ) + 1 ) * 4 * a ;  
							      }								      return a * a * a * a * a * a * a * a * a * a * a * a * a *  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE			      MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE			    MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE			  MAXIMUM_BINOMIAL_COEFFICIENT_TERM_VALUE
--							      --							    --								  --
def maxcoefficientvalue ( n ) :				      int maxcoefficientvalue ( int n ) {			    int maxcoefficientvalue ( int n ) {				  success : None
    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 	int C [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> C ( n + 1 , vector < int > ( n + 1 
    for i in range ( n + 1 ) :				      	for ( int i = 0 ;					      for ( int y = 0 ;						  
	for j in range ( min ( i , n ) + 1 ) :		      	i <= n ;						      y < n + 1 ;						  
	    if ( j == 0 or j == i ) :			      	i ++ ) {						      y ++ ) {							  
		C [ i ] [ j ] = 1			      	  for ( int j = 0 ;					    	for ( int i = 0 ;					  
	    else :					      	  j <= min ( i , n ) ;					    	i < n + 1 ;						  
		C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ 	  j ++ ) {						    	i ++ ) {						  
    maxvalue = 0					      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  for ( int j = 0 ;					  
    for i in range ( n + 1 ) :				      	    else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	  j < min ( i , n ) + 1 ;				  
	maxvalue = max ( maxvalue , C [ n ] [ i ] )	      	  }							    	  j ++ ) {						  
    return maxvalue					      	}							    	    if ( ( j == 0 || j == i ) ) C [ i ] [ j ] = 1 ;	  
							      	int maxvalue = 0 ;					    	    else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i  
							      	for ( int i = 0 ;					    	  }							  
							      	i <= n ;						    	}							  
							      	i ++ ) maxvalue = max ( maxvalue , C [ n ] [ i ] ) ;	      }								  
							      	return maxvalue ;					      int maxvalue = 0 ;					  
							      }								      for ( int i = 0 ;						  
							      								      i < n + 1 ;						  
							      								      i ++ ) maxvalue = max ( maxvalue , C [ n ] [ i ] ) ;	  
							      								      return maxvalue ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CEILING_IN_A_SORTED_ARRAY_1				      CEILING_IN_A_SORTED_ARRAY_1				    CEILING_IN_A_SORTED_ARRAY_1					  CEILING_IN_A_SORTED_ARRAY_1
--							      --							    --								  --
def ceilSearch ( arr , low , high , x ) :		      int ceilSearch ( int arr [ ] , int low , int high , int x ) { int ceilSearch ( int * arr , int low , int high , int x ) {	  success : None
    if x <= arr [ low ] :				      	int mid ;						      if ( x <= arr [ low ] ) return low ;			  
	return low					      	if ( x <= arr [ low ] ) return low ;			      if ( x > arr [ high ] ) return - 1 ;			  
    if x > arr [ high ] :				      	if ( x > arr [ high ] ) return - 1 ;			      int mid = ( low + high ) / 2 ;				  
	return - 1					      	mid = ( low + high ) / 2 ;				      if ( arr [ mid ] == x ) return mid ;			  
    mid = ( low + high ) / 2				      	if ( arr [ mid ] == x ) return mid ;			      else if ( arr [ mid ] < x ) {				  
    if arr [ mid ] == x :				      	else if ( arr [ mid ] < x ) {				    	if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid 
	return mid					      	  if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid 	else return ceilSearch ( arr , mid + 1 , high , x ) ;	  
    elif arr [ mid ] < x :				      	  else return ceilSearch ( arr , mid + 1 , high , x ) ;	      }								  
	if mid + 1 <= high and x <= arr [ mid + 1 ] :	      	}							      else {							  
	    return mid + 1				      	else {							    	if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; 
	else :						      	  if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; 	else return ceilSearch ( arr , low , mid - 1 , x ) ;	  
	    return ceilSearch ( arr , mid + 1 , high , x )    	  else return ceilSearch ( arr , low , mid - 1 , x ) ;	      }								  
    else :						      	}							    }								  
	if mid - 1 >= low and x > arr [ mid - 1 ] :	      }								    								  
	    return mid					      								    								  
	else :						      								    								  
	    return ceilSearch ( arr , low , mid - 1 , x )     								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS		      FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS			    FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS			  FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS
--							      --							    --								  --
def evenSum ( n ) :					      int evenSum ( int n ) {					    int evenSum ( int n ) {					  error : FIND_SUM_EVEN_INDEX_BINOMIAL_COEFFICIENTS.
    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 	int C [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> C ( n + 1 , vector < int > ( n + 1 cpp: In function ‘int f_filled(int)’: FIND_SUM_EVE
    for i in range ( 0 , n + 1 ) :			      	int i , j ;						      for ( int y = 0 ;						  N_INDEX_BINOMIAL_COEFFICIENTS.cpp:45:12: error: ‘j
	for j in range ( 0 , min ( i , n + 1 ) ) :	      	for ( i = 0 ;						      y <= n ;							  ’ was not declared in this scope	  if ( j ==
	    if j == 0 or j == i :			      	i <= n ;						      y ++ ) {							  0 || j == i ) C [ i ] [ j ] = 1 ;		^
		C [ i ] [ j ] = 1			      	i ++ ) {						    	for ( int i = 0 ;					  
	    else :					      	  for ( j = 0 ;						    	i <= min < int > ( i , n + 1 ) ;			  
		C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i 	  j <= min ( i , n ) ;					    	i ++ ) {						  
    sum = 0 ;						      	  j ++ ) {						    	  if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		  
    for i in range ( 0 , n + 1 ) :			      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  
	if n % 2 == 0 :					      	    else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	}							  
	    sum = sum + C [ n ] [ i ]			      	  }							      }								  
    return sum						      	}							      int sum = 0 ;						  
							      	int sum = 0 ;						      for ( int i = 0 ;						  
							      	for ( int i = 0 ;					      i <= n ;							  
							      	i <= n ;						      i ++ ) {							  
							      	i += 2 ) sum += C [ n ] [ i ] ;				    	if ( n % 2 == 0 ) sum = sum + C [ n ] [ i ] ;		  
							      	return sum ;						      }								  
							      }								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
UNIQUE_CELLS_BINARY_MATRIX				      UNIQUE_CELLS_BINARY_MATRIX				    UNIQUE_CELLS_BINARY_MATRIX					  UNIQUE_CELLS_BINARY_MATRIX
--							      --							    --								  --
def countUnique ( mat , n , m ) :			      int countUnique ( int mat [ ] [ MAX ] , int n , int m ) {	    int countUnique ( int * * mat , int n , int m ) {		  script_not_found : None
    rowsum = [ 0 ] * n					      	int rowsum [ n ] , colsum [ m ] ;			      vector < int > rowsum ( n , 0 ) ;				  
    colsum = [ 0 ] * m					      	memset ( colsum , 0 , sizeof ( colsum ) ) ;		      vector < int > colsum ( m , 0 ) ;				  
    for i in range ( n ) :				      	memset ( rowsum , 0 , sizeof ( rowsum ) ) ;		      for ( int i = 0 ;						  
	for j in range ( m ) :				      	for ( int i = 0 ;					      i < n ;							  
	    if ( mat [ i ] [ j ] != 0 ) :		      	i < n ;							      i ++ ) {							  
		rowsum [ i ] += 1			      	i ++ ) for ( int j = 0 ;				    	for ( int j = 0 ;					  
		colsum [ j ] += 1			      	j < m ;							    	j < m ;							  
    uniquecount = 0					      	j ++ ) if ( mat [ i ] [ j ] ) {				    	j ++ ) {						  
    for i in range ( n ) :				      	  rowsum [ i ] ++ ;					    	  if ( ( mat [ i ] [ j ] != 0 ) ) {			  
	for j in range ( m ) :				      	  colsum [ j ] ++ ;					    	    rowsum [ i ] ++ ;					  
	    if ( mat [ i ] [ j ] != 0 and rowsum [ i ] == 1 a 	}							    	    colsum [ j ] ++ ;					  
		uniquecount += 1			      	int uniquecount = 0 ;					    	  }							  
    return uniquecount					      	for ( int i = 0 ;					    	}							  
							      	i < n ;							      }								  
							      	i ++ ) for ( int j = 0 ;				      int uniquecount = 0 ;					  
							      	j < m ;							      for ( int i = 0 ;						  
							      	j ++ ) if ( mat [ i ] [ j ] && rowsum [ i ] == 1 && colsum    i < n ;							  
							      	return uniquecount ;					      i ++ ) {							  
							      }								    	for ( int j = 0 ;					  
							      								    	j < m ;							  
							      								    	j ++ ) {						  
							      								    	  if ( ( mat [ i ] [ j ] != 0 ) && ( rowsum [ i ] == 1 )  
							      								    	}							  
							      								      }								  
							      								      return uniquecount ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COMMON_CHARACTERS_N_STRINGS				      COMMON_CHARACTERS_N_STRINGS				    COMMON_CHARACTERS_N_STRINGS					  COMMON_CHARACTERS_N_STRINGS
--							      --							    --								  --
def commonCharacters ( strings , n ) :			      void commonCharacters ( string str [ ] , int n ) {	    void commonCharacters ( string strings , int n ) {		  script_not_found : None
    prim = [ True ] * MAX_CHAR				      	bool prim [ MAX_CHAR ] ;				      vector < bool > prim ( MAX_CHAR , true ) ;		  
    for i in range ( n ) :				      	memset ( prim , true , sizeof ( prim ) ) ;		      for ( int i = 0 ;						  
	sec = [ False ] * MAX_CHAR			      	for ( int i = 0 ;					      i < n ;							  
	for j in range ( len ( strings [ i ] ) ) :	      	i < n ;							      i ++ ) {							  
	    if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( ' 	i ++ ) {						    	vector < bool > sec ( MAX_CHAR , false ) ;		  
		sec [ ord ( strings [ i ] [ j ] ) - ord ( 'a' 	  bool sec [ MAX_CHAR ] = {				    	for ( int j = 0 ;					  
	for i in range ( MAX_CHAR ) :			      	    false }						    	j < strings [ i ] . length ( ) ;			  
	    prim [ i ] = sec [ i ]			      	    ;							    	j ++ ) {						  
    for i in range ( 26 ) :				      	    for ( int j = 0 ;					    	  if ( ( prim [ strings [ i ] [ j ] - 'a' ] ) ) sec [ str 
	if ( prim [ i ] ) :				      	    str [ i ] [ j ] ;					    	}							  
	    print ( "%c " % ( i + ord ( 'a' ) ) , end = "" )  	    j ++ ) {						    	for ( int i = 0 ;					  
							      	      if ( prim [ str [ i ] [ j ] - 'a' ] ) sec [ str [ i ] 	i < MAX_CHAR ;						  
							      	    }							    	i ++ ) prim [ i ] = sec [ i ] ;				  
							      	    memcpy ( prim , sec , MAX_CHAR ) ;			      }								  
							      	  }							      for ( int i = 0 ;						  
							      	  for ( int i = 0 ;					      i < 26 ;							  
							      	  i < 26 ;						      i ++ ) {							  
							      	  i ++ ) if ( prim [ i ] ) printf ( "%c " , i + 'a' ) ;	    	if ( ( prim [ i ] ) ) cout << ( i + 'a' ) << " " ;	  
							      	}							      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2			      PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2			    PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2				  PROGRAM_FOR_NTH_FIBONACCI_NUMBER_2
--							      --							    --								  --
def fib ( n ) :						      int fib ( int n ) {					    int fib ( int n ) {						  script_not_found : None
    if ( n == 0 ) :					      	if ( n == 0 ) return 0 ;				      if ( ( n == 0 ) ) return 0 ;				  
	return 0					      	if ( n == 1 || n == 2 ) return ( f [ n ] = 1 ) ;	      if ( ( n == 1 ) || ( n == 2 ) ) {				  
    if ( n == 1 or n == 2 ) :				      	if ( f [ n ] ) return f [ n ] ;				    	f [ n ] = 1 ;						  
	f [ n ] = 1					      	int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 ;		    	return ( f [ n ] ) ;					  
	return ( f [ n ] )				      	f [ n ] = ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1   }								  
    if ( f [ n ] ) :					      	return f [ n ] ;					      if ( ( f [ n ] ) ) return f [ n ] ;			  
	return f [ n ]					      }								      if ( ( n & 1 ) != 0 ) {					  
    if ( n & 1 ) :					      								    	int k = ( n + 1 ) / 2 ;					  
	k = ( n + 1 ) // 2				      								    	if ( ( ( n & 1 ) != 0 ) ) f [ n ] = ( fib ( k ) * fib ( k 
    else :						      								    	else f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib (  
	k = n // 2					      								      }								  
    if ( ( n & 1 ) ) :					      								      return n ;						  
	f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * f 								    }								  
    else :						      								    								  
	f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k 								    								  
    return f [ n ]					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F COUNT_OF_SUB_STRINGS_THAT_DO_NOT_CONTAIN_ALL_THE_CHARACTERS_F
--							      --							    --								  --
def CountSubString ( Str , n ) :			      int CountSubstring ( char str [ ] , int n ) {		    int CountSubString ( string Str , int n ) {			  success : None
    ans = ( n * ( n + 1 ) ) // 2			      	int ans = ( n * ( n + 1 ) ) / 2 ;			      int ans = ( n * ( n + 1 ) ) / 2 ;				  
    a_index = 0						      	int a_index = 0 ;					      int aIndex = 0 ;						  
    b_index = 0						      	int b_index = 0 ;					      int bIndex = 0 ;						  
    c_index = 0						      	int c_index = 0 ;					      int cIndex = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( Str [ i ] == 'a' ) :			      	i < n ;							      i < n ;							  
	    a_index = i + 1				      	i ++ ) {						      i ++ ) {							  
	    ans -= min ( b_index , c_index )		      	  if ( str [ i ] == 'a' ) {				    	if ( ( Str [ i ] == 'a' ) ) {				  
	elif ( Str [ i ] == 'b' ) :			      	    a_index = i + 1 ;					    	  aIndex = i + 1 ;					  
	    b_index = i + 1				      	    ans -= min ( b_index , c_index ) ;			    	  ans -= min < int > ( bIndex , cIndex ) ;		  
	    ans -= min ( a_index , c_index )		      	  }							    	}							  
	else :						      	  else if ( str [ i ] == 'b' ) {			    	else if ( ( Str [ i ] == 'b' ) ) {			  
	    c_index = i + 1				      	    b_index = i + 1 ;					    	  bIndex = i + 1 ;					  
	    ans -= min ( a_index , b_index )		      	    ans -= min ( a_index , c_index ) ;			    	  ans -= min < int > ( aIndex , cIndex ) ;		  
    return ans						      	  }							    	}							  
							      	  else {						    	else {							  
							      	    c_index = i + 1 ;					    	  cIndex = i + 1 ;					  
							      	    ans -= min ( a_index , b_index ) ;			    	  ans -= min < int > ( aIndex , bIndex ) ;		  
							      	  }							    	}							  
							      	}							      }								  
							      	return ans ;						      return ans ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST GIVEN_SORTED_ARRAY_NUMBER_X_FIND_PAIR_ARRAY_WHOSE_SUM_CLOSEST
--							      --							    --								  --
def printClosest ( arr , n , x ) :			      void printClosest ( int arr [ ] , int n , int x ) {	    int printClosest ( int * arr , int n , int x ) {		  script_not_found : None
    res_l , res_r = 0 , 0				      	int res_l , res_r ;					      int res_l = 0 , res_r = 0 ;				  
    l , r , diff = 0 , n - 1 , MAX_VAL			      	int l = 0 , r = n - 1 , diff = INT_MAX ;		      int l = 0 , r = n - 1 , diff = MAX_VAL ;			  
    while r > l :					      	while ( r > l ) {					      while ( r > l ) {						  
	if abs ( arr [ l ] + arr [ r ] - x ) < diff :	      	  if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) {	    	if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) {	  
	    res_l = l					      	    res_l = l ;						    	  res_l = l ;						  
	    res_r = r					      	    res_r = r ;						    	  res_r = r ;						  
	    diff = abs ( arr [ l ] + arr [ r ] - x )	      	    diff = abs ( arr [ l ] + arr [ r ] - x ) ;		    	  diff = abs ( arr [ l ] + arr [ r ] - x ) ;		  
	if arr [ l ] + arr [ r ] > x :			      	  }							    	}							  
	    r -= 1					      	  if ( arr [ l ] + arr [ r ] > x ) r -- ;		    	if ( arr [ l ] + arr [ r ] > x ) r -- ;			  
	else :						      	  else l ++ ;						    	else l ++ ;						  
	    l += 1					      	}							      }								  
    print ( 'The closest pair is {} and {}'.format ( arr [ re 	cout << " The closest pair is " << arr [ res_l ] << " and "   cout << "The closest pair is " << arr [ res_l ] << " and "  
							      }								      return res_l ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1		      THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1		    THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1		  THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS_1
--							      --							    --								  --
def thirdLargest ( arr , arr_size ) :			      void thirdLargest ( int arr [ ] , int arr_size ) {	    int thirdLargest ( int * arr , int arrSize ) {		  script_not_found : None
    if ( arr_size < 3 ) :				      	if ( arr_size < 3 ) {					      if ( ( arrSize < 3 ) ) {					  
	print ( " Invalid Input " )			      	  printf ( " Invalid Input " ) ;			    	cout << " Invalid Input " << endl ;			  
	return						      	  return ;						    	return 0 ;						  
    first = arr [ 0 ]					      	}							      }								  
    second = - sys.maxsize				      	int first = arr [ 0 ] , second = INT_MIN , third = INT_MIN    int first = arr [ 0 ] ;					  
    third = - sys.maxsize				      	for ( int i = 1 ;					      int second = - INT_MAX ;					  
    for i in range ( 1 , arr_size ) :			      	i < arr_size ;						      int third = - INT_MAX ;					  
	if ( arr [ i ] > first ) :			      	i ++ ) {						      for ( int i = 1 ;						  
	    third = second				      	  if ( arr [ i ] > first ) {				      i < arrSize ;						  
	    second = first				      	    third = second ;					      i ++ ) {							  
	    first = arr [ i ]				      	    second = first ;					    	if ( ( arr [ i ] > first ) ) {				  
	elif ( arr [ i ] > second ) :			      	    first = arr [ i ] ;					    	  third = second ;					  
	    third = second				      	  }							    	  second = first ;					  
	    second = arr [ i ]				      	  else if ( arr [ i ] > second ) {			    	  first = arr [ i ] ;					  
	elif ( arr [ i ] > third ) :			      	    third = second ;					    	}							  
	    third = arr [ i ]				      	    second = arr [ i ] ;				    	else if ( ( arr [ i ] > second ) ) {			  
    print ( "The third Largest" , "element is" , third )      	  }							    	  third = second ;					  
							      	  else if ( arr [ i ] > third ) third = arr [ i ] ;	    	  second = arr [ i ] ;					  
							      	}							    	}							  
							      	printf ( "The third Largest element is %d\n" , third ) ;    	else if ( ( arr [ i ] > third ) ) {			  
							      }								    	  third = arr [ i ] ;					  
							      								    	}							  
							      								      }								  
							      								      cout << "The third Largest" << "element is" << third << end 
							      								      return 0 ;						  
							      								      return arrSize * arrSize ;				  
							      								      return arrSize * arrSize ;				  
							      								      return arrSize * arrSize * arrSize * arrSize * arrSize * ar 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE			      MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE			    MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE			  MAXIMUM_SUM_PAIRS_SPECIFIC_DIFFERENCE
--							      --							    --								  --
def maxSumPairWithDifferenceLessThanK ( arr , N , K ) :	      int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int maxSumPairWithDifferenceLessThanK ( int * arr , int N , i success : None
    arr.sort ( )					      	sort ( arr , arr + N ) ;				      sort ( arr , arr + N ) ;					  
    dp = [ 0 ] * N					      	int dp [ N ] ;						      vector < int > dp ( N , 0 ) ;				  
    dp [ 0 ] = 0					      	dp [ 0 ] = 0 ;						      dp [ 0 ] = 0 ;						  
    for i in range ( 1 , N ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	dp [ i ] = dp [ i - 1 ]				      	i < N ;							      i < N ;							  
	if ( arr [ i ] - arr [ i - 1 ] < K ) :		      	i ++ ) {						      i ++ ) {							  
	    if ( i >= 2 ) :				      	  dp [ i ] = dp [ i - 1 ] ;				    	dp [ i ] = dp [ i - 1 ] ;				  
		dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + ar 	  if ( arr [ i ] - arr [ i - 1 ] < K ) {		    	if ( ( arr [ i ] - arr [ i - 1 ] < K ) ) {		  
	    else :					      	    if ( i >= 2 ) dp [ i ] = max ( dp [ i ] , dp [ i - 2 ]  	  if ( ( i >= 2 ) ) dp [ i ] = max ( dp [ i ] , dp [ i -  
		dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ 	    else dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i -  	  else dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i -  
    return dp [ N - 1 ]					      	  }							    	}							  
							      	}							      }								  
							      	return dp [ N - 1 ] ;					      return dp [ N - 1 ] ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS LONGEST_SUBSEQUENCE_SUCH_THAT_DIFFERENCE_BETWEEN_ADJACENTS_IS
--							      --							    --								  --
def longestSubseqWithDiffOne ( arr , n ) :		      int longestSubseqWithDiffOne ( int arr [ ] , int n ) {	    int longestSubseqWithDiffOne ( int * arr , int n ) {	  failure : #Results: 4, 10
    dp = [ 1 for i in range ( n ) ]			      	int dp [ n ] ;						      vector < int > dp ( n , 0 ) ;				  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i ) :				      	i < n ;							      i < n ;							  
	    if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i  	i ++ ) dp [ i ] = 1 ;					      i ++ ) {							  
		dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 )    	for ( int i = 1 ;					    	for ( int j = 0 ;					  
    result = 1						      	i < n ;							    	j < i ;							  
    for i in range ( n ) :				      	i ++ ) {						    	j ++ ) {						  
	if ( result < dp [ i ] ) :			      	  for ( int j = 0 ;					    	  if ( ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == 
	    result = dp [ i ]				      	  j < i ;						    	}							  
    return result					      	  j ++ ) {						      }								  
							      	    if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == a   int result = 1 ;						  
							      	  }							      for ( int i = 0 ;						  
							      	}							      i < n ;							  
							      	int result = 1 ;					      i ++ ) {							  
							      	for ( int i = 0 ;					    	if ( ( result < dp [ i ] ) ) result = dp [ i ] ;	  
							      	i < n ;							      }								  
							      	i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ;	      return result ;						  
							      	return result ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR
--							      --							    --								  --
def bitonicGenerator ( arr , n ) :			      void bitonicGenerator ( int arr [ ] , int n ) {		    int bitonicGenerator ( int * arr , int n ) {		  script_not_found : None
    i = 1						      	int i = 1 ;						      int i = 1 ;						  
    j = n - 1						      	int j = n - 1 ;						      int j = n - 1 ;						  
    if ( j % 2 != 0 ) :					      	if ( j % 2 != 0 ) j -- ;				      if ( ( j % 2 ) != 0 ) j = j - 1 ;				  
	j = j - 1					      	while ( i < j ) {					      while ( ( i < j ) ) {					  
    while ( i < j ) :					      	  swap ( arr [ i ] , arr [ j ] ) ;			    	arr [ j ] = arr [ i ] ;					  
	arr [ j ] , arr [ i ] = arr [ i ] , arr [ j ]	      	  i += 2 ;						    	arr [ i ] = arr [ j ] ;					  
	i = i + 2					      	  j -= 2 ;						    	i = i + 2 ;						  
	j = j - 2					      	}							    	j = j - 2 ;						  
    arr_f = [ ]						      	sort ( arr , arr + ( n + 1 ) / 2 ) ;			      }								  
    arr_s = [ ]						      	sort ( arr + ( n + 1 ) / 2 , arr + n , greater < int > ( )    int * arrF = new int [ n ] ;				  
    for i in range ( int ( ( n + 1 ) / 2 ) ) :		      }								      int * arrS = new int [ n ] ;				  
	arr_f.append ( arr [ i ] )			      								      for ( int i = 0 ;						  
    i = int ( ( n + 1 ) / 2 )				      								      i < ( int ) ( ( n + 1 ) / 2 ) ;				  
    while ( i < n ) :					      								      i ++ ) arrF [ i ] = arr [ i ] ;				  
	arr_s.append ( arr [ i ] )			      								      i = ( int ) ( ( n + 1 ) / 2 ) ;				  
	i = i + 1					      								      while ( ( i < n ) ) {					  
    arr_f.sort ( )					      								    	arrS [ i ] = arr [ i ] ;				  
    arr_s.sort ( reverse = True )			      								    	i = i + 1 ;						  
    for i in arr_s :					      								      }								  
	arr_f.append ( i )				      								      sort ( arrF , arrF + n ) ;				  
    return arr_f					      								      sort ( arrS , arrS + n ) ;				  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) arrF [ i ] = arrS [ i ] ;				  
							      								      return i ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING  MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING  MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING  MINIMAL_MOVES_FORM_STRING_ADDING_CHARACTERS_APPENDING_STRING
--							      --							    --								  --
def minimalSteps ( s , n ) :				      int minimalSteps ( string s , int n ) {			    int minimalSteps ( string s , int n ) {			  script_not_found : None
    dp = [ INT_MAX for i in range ( n ) ]		      	int dp [ n ] ;						      vector < int > dp ( n , INT_MAX ) ;			  
    s1 = ""						      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    s2 = ""						      	i < n ;							      i < n ;							  
    dp [ 0 ] = 1					      	i ++ ) dp [ i ] = INT_MAX ;				      i ++ ) {							  
    s1 += s [ 0 ]					      	string s1 = "" , s2 = "" ;				    	dp [ i ] = 0 ;						  
    for i in range ( 1 , n ) :				      	dp [ 0 ] = 1 ;						      }								  
	s1 += s [ i ]					      	s1 += s [ 0 ] ;						      string s1 ;						  
	s2 = s [ i + 1 : i + 1 + i + 1 ]		      	for ( int i = 1 ;					      string s2 ;						  
	dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 )	      	i < n ;							      dp [ 0 ] = 1 ;						  
	if ( s1 == s2 ) :				      	i ++ ) {						      s1 += s [ 0 ] ;						  
	    dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i *  	  s1 += s [ i ] ;					      for ( int i = 1 ;						  
    return dp [ n - 1 ]					      	  s2 = s . substr ( i + 1 , i + 1 ) ;			      i < n ;							  
							      	  dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ;	      i ++ ) {							  
							      	  if ( s1 == s2 ) dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , d 	s1 += s [ i ] ;						  
							      	}							    	s2 = s . substr ( i + 1 , 1 - i + 1 ) ;			  
							      	return dp [ n - 1 ] ;					    	dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ;	  
							      }								    	if ( ( s1 == s2 ) && ( dp [ i * 2 + 1 ] == dp [ i ] ) ) d 
							      								      }								  
							      								      return dp [ n - 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE		      COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE		    COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE		  COORDINATES_RECTANGLE_GIVEN_POINTS_LIE_INSIDE
--							      --							    --								  --
def printRect ( X , Y , n ) :				      void printRect ( int X [ ] , int Y [ ] , int n ) {	    void printRect ( int X , int Y , int n ) {			  script_not_found : None
    Xmax = max ( X )					      	int Xmax = * max_element ( X , X + n ) ;		      int Xmax = max ( X ) ;					  
    Xmin = min ( X )					      	int Xmin = * min_element ( X , X + n ) ;		      int Xmin = min ( X ) ;					  
    Ymax = max ( Y )					      	int Ymax = * max_element ( Y , Y + n ) ;		      int Ymax = max ( Y ) ;					  
    Ymin = min ( Y )					      	int Ymin = * min_element ( Y , Y + n ) ;		      int Ymin = min ( Y ) ;					  
    print ( "{" , Xmin , ", " , Ymin , "}" , sep = "" )	      	cout << "{" << Xmin << ", " << Ymin << "}" << endl ;	      cout << "{" << Xmin << ", " << Ymin << "}" << endl ;	  
    print ( "{" , Xmin , ", " , Ymax , "}" , sep = "" )	      	cout << "{" << Xmin << ", " << Ymax << "}" << endl ;	      cout << "{" << Xmin << ", " << Ymax << "}" << endl ;	  
    print ( "{" , Xmax , ", " , Ymax , "}" , sep = "" )	      	cout << "{" << Xmax << ", " << Ymax << "}" << endl ;	      cout << "{" << Xmax << ", " << Ymax << "}" << endl ;	  
    print ( "{" , Xmax , ", " , Ymin , "}" , sep = "" )	      	cout << "{" << Xmax << ", " << Ymin << "}" << endl ;	      cout << "{" << Xmax << ", " << Ymin ;			  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD    FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD    FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD	  FIND_FOUR_ELEMENTS_A_B_C_AND_D_IN_AN_ARRAY_SUCH_THAT_AB_CD
--							      --							    --								  --
def findPairs ( arr , n ) :				      bool findPairs ( int arr [ ] , int n ) {			    bool findPairs ( int * arr , int n ) {			  script_not_found : None
Hash = { }						      	map < int , pair < int , int >> Hash ;			      unordered_map < int , int > Hash ;			  
for i in range ( n - 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for j in range ( i + 1 , n ) :			      	i < n ;							      i < n - 1 ;						  
    sum = arr [ i ] + arr [ j ]				      	++ i ) {						      i ++ ) {							  
    if sum in Hash.keys ( ) :				      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  
	prev = Hash.get ( sum )				      	  j < n ;						    	j < n ;							  
	print ( str ( prev ) + " and (%d, %d)" % ( arr [ i ]  	  ++ j ) {						    	j ++ ) {						  
	return True					      	    int sum = arr [ i ] + arr [ j ] ;			    	  int sum = arr [ i ] + arr [ j ] ;			  
    else :						      	    if ( Hash . find ( sum ) == Hash . end ( ) ) Hash [ sum 	  if ( Hash . count ( sum ) ) {				  
	Hash [ sum ] = ( arr [ i ] , arr [ j ] )	      	    else {						    	    int prev = Hash . find ( sum ) ;			  
							      	      pair < int , int > pp = Hash [ sum ] ;		    	    cout << prev << " and (" << arr [ i ] << ", " << arr  
							      	      cout << "(" << arr [ pp . first ] << ", " << arr [ pp 	    return true ;					  
							      	      return true ;					    	  }							  
							      	    }							    	  else {						  
							      	  }							    	    Hash [ sum ] = ( arr [ i ] ) ;			  
							      	}							    	  }							  
							      	cout << "No pairs found" ;				    	}							  
							      	return false ;						      }								  
							      }								      return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1   SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1   SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1	  SEQUENCES_GIVEN_LENGTH_EVERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1
--							      --							    --								  --
def getTotalNumberOfSequences ( m , n ) :		      int getTotalNumberOfSequences ( int m , int n ) {		    int getTotalNumberOfSequences ( int m , int n ) {		  error : /bin/bash: line 1: 1847867 Segmentation fa
    T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 	int T [ m + 1 ] [ n + 1 ] ;				      vector < vector < int >> T ( n + 1 , vector < int > ( m + 1 ult	   (core dumped) ./SEQUENCES_GIVEN_LENGTH_EV
    for i in range ( m + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  ERY_ELEMENT_EQUAL_TWICE_PREVIOUS_1_cpp
	for j in range ( n + 1 ) :			      	i < m + 1 ;						      i < m + 1 ;						  
	    if i == 0 or j == 0 :			      	i ++ ) {						      i ++ ) {							  
		T [ i ] [ j ] = 0			      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    elif i < j :				      	  j < n + 1 ;						    	j < n + 1 ;						  
		T [ i ] [ j ] = 0			      	  j ++ ) {						    	j ++ ) {						  
	    elif j == 1 :				      	    if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ;		    	  if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ;		  
		T [ i ] [ j ] = i			      	    else if ( i < j ) T [ i ] [ j ] = 0 ;		    	  else if ( i < j ) T [ i ] [ j ] = 0 ;			  
	    else :					      	    else if ( j == 1 ) T [ i ] [ j ] = i ;		    	  else if ( j == 1 ) T [ i ] [ j ] = i ;		  
		T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i //  	    else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [  	  else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [  
    return T [ m ] [ n ]				      	  }							    	}							  
							      	}							      }								  
							      	return T [ m ] [ n ] ;					      return T [ m ] [ n ] ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PETERSON_GRAPH						      PETERSON_GRAPH						    PETERSON_GRAPH						  PETERSON_GRAPH
--							      --							    --								  --
def findthepath ( S , v ) :				      bool findthepath ( char * S , int v ) {			    bool findthepath ( string S , int v ) {			  script_not_found : None
    result [ 0 ] = v					      	result [ 0 ] = v + '0' ;				      string result ;						  
    for i in range ( 1 , len ( S ) ) :			      	for ( int i = 1 ;					      result [ 0 ] = v ;					  
	if ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) ] or a 	S [ i ] ;						      for ( int i = 1 ;						  
	    v = ord ( S [ i ] ) - ord ( 'A' )		      	i ++ ) {						      i < S . length ( ) ;					  
	elif ( adj [ v ] [ ord ( S [ i ] ) - ord ( 'A' ) + 5  	  if ( adj [ v ] [ S [ i ] - 'A' ] || adj [ S [ i ] - 'A' ]   i ++ ) {							  
	    v = ord ( S [ i ] ) - ord ( 'A' ) + 5	      	    v = S [ i ] - 'A' ;					    	if ( ( adj [ v ] [ S [ i ] - 'A' ] || adj [ S [ i ] - 'A' 
	else :						      	  }							    	else if ( ( adj [ v ] [ S [ i ] - 'A' + 5 ] || adj [ S [  
	    return False				      	  else if ( adj [ v ] [ S [ i ] - 'A' + 5 ] || adj [ S [ i  	else return false ;					  
	result.append ( v )				      	    v = S [ i ] - 'A' + 5 ;				    	result += v ;						  
    return True						      	  }							      }								  
							      	  else return false ;					      return true ;						  
							      	  result [ i ] = v + '0' ;				      return v * v * v * v * v * v * v * v * v * v * v * v * v *  
							      	}							    }								  
							      	return true ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED		      LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED		    LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED			  LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED
--							      --							    --								  --
def longestNull ( S ) :					      int longestNull ( string str ) {				    int longestNull ( string S ) {				  error : LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED
    arr = [ ]						      	vector < pair < char , int >> arr ;			      vector < pair < char , int >> arr ;			  .cpp: In function ‘int f_filled(std::__cxx11::stri
    arr.append ( [ '@' , - 1 ] )			      	arr . push_back ( {					      arr . push_back ( make_pair ( '@' , - 1 ) ) ;		  ng)’: LENGTH_LONGEST_SUB_STRING_CAN_MAKE_REMOVED.c
    maxlen = 0						      	  '@' , - 1 }						      int len = 0 ;						  pp:48:65: error: no match for ‘operator[]’ (operan
    for i in range ( len ( S ) ) :			      	  ) ;							      for ( int i = 0 ;						  d types are ‘__gnu_cxx::__alloc_traits<std::alloca
	arr.append ( [ S [ i ] , i ] )			      	  int maxlen = 0 ;					      i < S . length ( ) ;					  tor<std::pair<char, int> >, std::pair<char, int> >
	while ( len ( arr ) >= 3 and arr [ len ( arr ) - 3 ]  	  for ( int i = 0 ;					      i ++ ) {							  ::value_type’ {aka ‘std::pair<char, int>’} and ‘in
	    arr.pop ( )					      	  i < str . length ( ) ;				    	arr . push_back ( make_pair ( S [ i ] , i ) ) ;		  t’)	   while ( ( arr . size ( ) >= 3 && arr [ ar
	    arr.pop ( )					      	  ++ i ) {						    	while ( ( arr . size ( ) >= 3 && arr [ arr . size ( ) - 3 r . size ( ) - 3 ] [ 0 ] == '1' && arr [ arr . siz
	    arr.pop ( )					      	    arr . push_back ( {					    	  arr . pop_back ( ) ;					  e ( ) - 2 ] [ 0 ] == '0' && arr [ arr . size ( ) -
	tmp = arr [ - 1 ]				      	      str [ i ] , i }					    	  arr . pop_front ( ) ;					   1 ] [ 0 ] == '0' ) ) {
	maxlen = max ( maxlen , i - tmp [ 1 ] )		      	      ) ;						    	  arr . push_back ( make_pair ( '@' , i ) ) ;		  					 ^ LENGTH_LO
    return maxlen					      	      while ( arr . size ( ) >= 3 && arr [ arr . size ( ) - 	}							  NGEST_SUB_STRING_CAN_MAKE_REMOVED.cpp:48:108: erro
							      		arr . pop_back ( ) ;				    	pair < char , int > tmp = arr . back ( ) ;		  r: no match for ‘operator[]’ (operand types are ‘_
							      		arr . pop_back ( ) ;				    	len = max ( len , i - tmp . second ) ;			  _gnu_cxx::__alloc_traits<std::allocator<std::pair<
							      		arr . pop_back ( ) ;				      }								  char, int> >, std::pair<char, int> >::value_type’
							      	      }							      return len ;						  {aka ‘std::pair<char, int>’} and ‘int’)      while
							      	      int tmp = arr . back ( ) . second ;		    }								   ( ( arr . size ( ) >= 3 && arr [ arr . size ( ) -
							      	      maxlen = max ( maxlen , i - tmp ) ;		    								   3 ] [ 0 ] == '1' && arr [ arr . size ( ) - 2 ] [
							      	    }							    								  0 ] == '0' && arr [ arr . size ( ) - 1 ] [ 0 ] ==
							      	    return maxlen ;					    								  '0' ) ) {
							      	  }							    								  
							      								    								  		    ^ LENGTH_LONGEST_SUB_STRING_CAN_
							      								    								  MAKE_REMOVED.cpp:48:151: error: no match for ‘oper
							      								    								  ator[]’ (operand types are ‘__gnu_cxx::__alloc_tra
							      								    								  its<std::allocator<std::pair<char, int> >, std::pa
							      								    								  ir<char, int> >::value_type’ {aka ‘std::pair<char,
							      								    								   int>’} and ‘int’)	  while ( ( arr . size ( ) >
							      								    								  = 3 && arr [ arr . size ( ) - 3 ] [ 0 ] == '1' &&
							      								    								  arr [ arr . size ( ) - 2 ] [ 0 ] == '0' && arr [ a
							      								    								  rr . size ( ) - 1 ] [ 0 ] == '0' ) ) {
							      								    								  
							      								    								  
							      								    								  					  ^ LENGTH_L
							      								    								  ONGEST_SUB_STRING_CAN_MAKE_REMOVED.cpp:50:13: erro
							      								    								  r: ‘class std::vector<std::pair<char, int> >’ has
							      								    								  no member named ‘pop_front’; did you mean ‘front’?
							      								    								  	  arr . pop_front ( ) ;		     ^~~~~~~
							      								    								  ~~		  front
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE DYNAMIC_PROGRAMMING_SET_14_MAXIMUM_SUM_INCREASING_SUBSEQUENCE
--							      --							    --								  --
def maxSumIS ( arr , n ) :				      int maxSumIS ( int arr [ ] , int n ) {			    int maxSumIS ( int * arr , int n ) {			  success : None
    max = 0						      	int i , j , max = 0 ;					      int max = 0 ;						  
    msis = [ 0 for x in range ( n ) ]			      	int msis [ n ] ;					      int msis [ n ] ;						  
    for i in range ( n ) :				      	for ( i = 0 ;						      for ( int i = 0 ;						  
	msis [ i ] = arr [ i ]				      	i < n ;							      i < n ;							  
    for i in range ( 1 , n ) :				      	i ++ ) msis [ i ] = arr [ i ] ;				      i ++ ) msis [ i ] = arr [ i ] ;				  
	for j in range ( i ) :				      	for ( i = 1 ;						      for ( int i = 1 ;						  
	    if ( arr [ i ] > arr [ j ] and msis [ i ] < msis  	i < n ;							      i < n ;							  
		msis [ i ] = msis [ j ] + arr [ i ]	      	i ++ ) for ( j = 0 ;					      i ++ ) for ( int j = 0 ;					  
    for i in range ( n ) :				      	j < i ;							      j < i ;							  
	if max < msis [ i ] :				      	j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j    j ++ ) if ( ( arr [ i ] > arr [ j ] && msis [ i ] < msis [  
	    max = msis [ i ]				      	for ( i = 0 ;						      for ( int i = 0 ;						  
    return max						      	i < n ;							      i < n ;							  
							      	i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ;	      i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ;		  
							      	return max ;						      return max ;						  
							      }								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ROTATIONS_DIVISIBLE_4				      COUNT_ROTATIONS_DIVISIBLE_4				    COUNT_ROTATIONS_DIVISIBLE_4					  COUNT_ROTATIONS_DIVISIBLE_4
--							      --							    --								  --
def countRotations ( n ) :				      int countRotations ( string n ) {				    int countRotations ( string n ) {				  failure : #Results: 3, 10
    l = len ( n )					      	int len = n . length ( ) ;				      int l = n . length ( ) ;					  
    if ( l == 1 ) :					      	if ( len == 1 ) {					      if ( ( l == 1 ) ) {					  
	oneDigit = ( int ) ( n [ 0 ] )			      	  int oneDigit = n . at ( 0 ) - '0' ;			    	int oneDigit = ( int ) ( n [ 0 ] ) ;			  
	if ( oneDigit % 4 == 0 ) :			      	  if ( oneDigit % 4 == 0 ) return 1 ;			    	if ( ( oneDigit % 4 == 0 ) ) return 1 ;			  
	    return 1					      	  return 0 ;						    	return 0 ;						  
	return 0					      	}							      }								  
    count = 0						      	int twoDigit , count = 0 ;				      int count = 0 ;						  
    for i in range ( 0 , l - 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i 	i < ( len - 1 ) ;					      i <= l - 1 ;						  
	if ( twoDigit % 4 == 0 ) :			      	i ++ ) {						      i ++ ) {							  
	    count = count + 1				      	  twoDigit = ( n . at ( i ) - '0' ) * 10 + ( n . at ( i + 1 	int twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i 
    twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 	  if ( twoDigit % 4 == 0 ) count ++ ;			    	if ( ( twoDigit % 4 == 0 ) ) count = count + 1 ;	  
    if ( twoDigit % 4 == 0 ) :				      	}							      }								  
	count = count + 1				      	twoDigit = ( n . at ( len - 1 ) - '0' ) * 10 + ( n . at ( 0   int twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 
    return count					      	if ( twoDigit % 4 == 0 ) count ++ ;			      if ( ( twoDigit % 4 == 0 ) ) count = count + 1 ;		  
							      	return count ;						      return count ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY		      COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY		    COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY			  COUNT_MINIMUM_STEPS_GET_GIVEN_DESIRED_ARRAY
--							      --							    --								  --
def countMinOperations ( target , n ) :			      int countMinOperations ( unsigned int target [ ] , int n ) {  int countMinOperations ( int * target , int n ) {		  script_not_found : None
    result = 0						      	int result = 0 ;					      int result = 0 ;						  
    while ( True ) :					      	while ( 1 ) {						      while ( ( true ) ) {					  
	zero_count = 0					      	  int zero_count = 0 ;					    	int zeroCount = 0 ;					  
	i = 0						      	  int i ;						    	int i = 0 ;						  
	while ( i < n ) :				      	  for ( i = 0 ;						    	while ( ( i < n ) && ( ( target [ i ] & 1 ) > 0 ) ) {	  
	    if ( ( target [ i ] & 1 ) > 0 ) :		      	  i < n ;						    	  break ;						  
		break					      	  i ++ ) {						    	}							  
	    elif ( target [ i ] == 0 ) :		      	    if ( target [ i ] & 1 ) break ;			    	else if ( ( target [ i ] == 0 ) ) {			  
		zero_count += 1				      	    else if ( target [ i ] == 0 ) zero_count ++ ;	    	  zeroCount ++ ;					  
	    i += 1					      	  }							    	}							  
	if ( zero_count == n ) :			      	  if ( zero_count == n ) return result ;		    	i ++ ;							  
	    return result				      	  if ( i == n ) {					      }								  
	if ( i == n ) :					      	    for ( int j = 0 ;					      if ( ( zeroCount == n ) ) {				  
	    for j in range ( n ) :			      	    j < n ;						    	return result ;						  
		target [ j ] = target [ j ] // 2	      	    j ++ ) target [ j ] = target [ j ] / 2 ;		      }								  
	    result += 1					      	    result ++ ;						      if ( ( i == n ) ) {					  
	for j in range ( i , n ) :			      	  }							    	for ( int j = 0 ;					  
	    if ( target [ j ] & 1 ) :			      	  for ( int j = i ;					    	j < n ;							  
		target [ j ] -= 1			      	  j < n ;						    	j ++ ) {						  
		result += 1				      	  j ++ ) {						    	  target [ j ] = target [ j ] / 2 ;			  
							      	    if ( target [ j ] & 1 ) {				    	}							  
							      	      target [ j ] -- ;					    	result ++ ;						  
							      	      result ++ ;					      }								  
							      	    }							      for ( int j = i ;						  
							      	  }							      j < n ;							  
							      	}							      j ++ ) {							  
							      }								    	if ( ( target [ j ] & 1 ) ) {				  
							      								    	  target [ j ] -- ;					  
							      								    	  result ++ ;						  
							      								    	}							  
							      								      }								  
							      								    }								  
							      								    return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS	      CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS	    CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS		  CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS
--							      --							    --								  --
def check ( s ) :					      bool check ( string s ) {					    bool check ( string s ) {					  error : CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT
    if ( len ( s ) >= 10 ) :				      	if ( s . size ( ) >= 10 ) return true ;			      if ( ( s . length ( ) >= 10 ) ) return true ;		  _STRINGS.cpp:59:1: error: expected unqualified-id
	return True					      	for ( int i = 1 ;					      for ( int i = 1 ;						  before ‘return’  return false ;  ^~~~~~ CHECK_GIVE
    for i in range ( 1 , len ( s ) ) :			      	i < s . size ( ) ;					      i < s . length ( ) ;					  N_STRING_CAN_SPLIT_FOUR_DISTINCT_STRINGS.cpp:60:1:
	for j in range ( i + 1 , len ( s ) ) :		      	i ++ ) {						      i ++ ) {							   error: expected declaration before ‘}’ token	 }
	    for k in range ( j + 1 , len ( s ) ) :	      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  ^ CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINCT_STRIN
		s1 = s [ 0 : i ]			      	  j < s . size ( ) ;					    	j < s . length ( ) ;					  GS.cpp: In function ‘bool f_filled(std::__cxx11::s
		s2 = s [ i : j - i ]			      	  j ++ ) {						    	j ++ ) {						  tring)’: CHECK_GIVEN_STRING_CAN_SPLIT_FOUR_DISTINC
		s3 = s [ j : k - j ]			      	    for ( int k = j + 1 ;				    	  for ( int k = j + 1 ;					  T_STRINGS.cpp:58:1: warning: control reaches end o
		s4 = s [ k : len ( s ) - k ]		      	    k < s . size ( ) ;					    	  k < s . length ( ) ;					  f non-void function [-Wreturn-type]  }  ^
		if ( s1 != s2 and s1 != s3 and s1 != s4 and s 	    k ++ ) {						    	  k ++ ) {						  
		    return True				      	      string s1 = s . substr ( 0 , i ) ;		    	    string s1 = s . substr ( 0 , i ) ;			  
    return False					      	      string s2 = s . substr ( i , j - i ) ;		    	    string s2 = s . substr ( i , j - i ) ;		  
							      	      string s3 = s . substr ( j , k - j ) ;		    	    string s3 = s . substr ( j , k - j ) ;		  
							      	      string s4 = s . substr ( k , s . size ( ) - k ) ;	    	    string s4 = s . substr ( k , s . length ( ) - k ) ;	  
							      	      if ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 &&  	    if ( ( s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 & 
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	return false ;						    }								  
							      }								    return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_ELEMENT_TWO_SORTED_ARRAYS				      K_TH_ELEMENT_TWO_SORTED_ARRAYS				    K_TH_ELEMENT_TWO_SORTED_ARRAYS				  K_TH_ELEMENT_TWO_SORTED_ARRAYS
--							      --							    --								  --
def kth ( arr1 , arr2 , m , n , k ) :			      int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k int kth ( int * arr1 , int * arr2 , int m , int n , int k ) { success : None
    sorted1 = [ 0 ] * ( m + n )				      	int sorted1 [ m + n ] ;					      int sorted1 [ m + n ] ;					  
    i = 0						      	int i = 0 , j = 0 , d = 0 ;				      int i = 0 ;						  
    j = 0						      	while ( i < m && j < n ) {				      int j = 0 ;						  
    d = 0						      	  if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [    int d = 0 ;						  
    while ( i < m and j < n ) :				      	  else sorted1 [ d ++ ] = arr2 [ j ++ ] ;		      while ( ( i < m ) && ( j < n ) ) {			  
	if ( arr1 [ i ] < arr2 [ j ] ) :		      	}							    	if ( ( arr1 [ i ] < arr2 [ j ] ) ) {			  
	    sorted1 [ d ] = arr1 [ i ]			      	while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ;	    	  sorted1 [ d ] = arr1 [ i ] ;				  
	    i += 1					      	while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ;	    	  i ++ ;						  
	else :						      	return sorted1 [ k - 1 ] ;				    	}							  
	    sorted1 [ d ] = arr2 [ j ]			      }								    	else {							  
	    j += 1					      								    	  sorted1 [ d ] = arr2 [ j ] ;				  
	d += 1						      								    	  j ++ ;						  
    while ( i < m ) :					      								    	}							  
	sorted1 [ d ] = arr1 [ i ]			      								    	d ++ ;							  
	d += 1						      								      }								  
	i += 1						      								      while ( ( i < m ) ) {					  
    while ( j < n ) :					      								    	sorted1 [ d ] = arr1 [ i ] ;				  
	sorted1 [ d ] = arr2 [ j ]			      								    	d ++ ;							  
	d += 1						      								    	i ++ ;							  
	j += 1						      								      }								  
    return sorted1 [ k - 1 ]				      								      while ( ( j < n ) ) {					  
							      								    	sorted1 [ d ] = arr2 [ j ] ;				  
							      								    	d ++ ;							  
							      								    	j ++ ;							  
							      								      }								  
							      								      return sorted1 [ k - 1 ] ;				  
							      								      return m * m ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS		      LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS			    LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS			  LONGEST_SUBARRAY_NOT_K_DISTINCT_ELEMENTS
--							      --							    --								  --
def longest ( a , n , k ) :				      void longest ( int a [ ] , int n , int k ) {		    int longestDistance ( int a [ ] , int n , int k ) {		  script_not_found : None
    freq = [ 0 ] * n					      	unordered_map < int , int > freq ;			      vector < int > freq ( n , 0 ) ;				  
    start = 0						      	int start = 0 , end = 0 , now = 0 , l = 0 ;		      int start = 0 ;						  
    end = 0						      	for ( int i = 0 ;					      int end = 0 ;						  
    now = 0						      	i < n ;							      int now = 0 ;						  
    l = 0						      	i ++ ) {						      int l = 0 ;						  
    for i in range ( n ) :				      	  freq [ a [ i ] ] ++ ;					      for ( int i = 0 ;						  
	freq [ a [ i ] ] += 1				      	  if ( freq [ a [ i ] ] == 1 ) now ++ ;			      i < n ;							  
	if ( freq [ a [ i ] ] == 1 ) :			      	  while ( now > k ) {					      i ++ ) {							  
	    now += 1					      	    freq [ a [ l ] ] -- ;				    	freq [ a [ i ] ] ++ ;					  
	while ( now > k ) :				      	    if ( freq [ a [ l ] ] == 0 ) now -- ;		    	if ( ( freq [ a [ i ] ] == 1 ) ) now ++ ;		  
	    freq [ a [ l ] ] -= 1			      	    l ++ ;						    	while ( ( now > k ) ) {					  
	    if ( freq [ a [ l ] ] == 0 ) :		      	  }							    	  freq [ a [ l ] ] -- ;					  
		now -= 1				      	  if ( i - l + 1 >= end - start + 1 ) end = i , start = l ; 	  if ( ( freq [ a [ l ] ] == 0 ) ) now -- ;		  
	    l += 1					      	}							    	  l ++ ;						  
	if ( i - l + 1 >= end - start + 1 ) :		      	for ( int i = start ;					    	}							  
	    end = i					      	i <= end ;						    	if ( ( i - l + 1 >= end - start + 1 ) ) {		  
	    start = l					      	i ++ ) cout << a [ i ] << " " ;				    	  end = i ;						  
    for i in range ( start , end + 1 ) :		      }								    	  start = l ;						  
	print ( a [ i ] , end = " " )			      								    	}							  
							      								      }								  
							      								      for ( int i = start ;					  
							      								      i <= end ;						  
							      								      i ++ ) cout << a [ i ] << " " ;				  
							      								      return end - start ;					  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PRODUCT_SUBSET_ARRAY				      MAXIMUM_PRODUCT_SUBSET_ARRAY				    MAXIMUM_PRODUCT_SUBSET_ARRAY				  MAXIMUM_PRODUCT_SUBSET_ARRAY
--							      --							    --								  --
def maxProductSubset ( a , n ) :			      int maxProductSubset ( int a [ ] , int n ) {		    int maxProductSubset ( int * a , int n ) {			  error : MAXIMUM_PRODUCT_SUBSET_ARRAY.cpp: In funct
    if n == 1 :						      	if ( n == 1 ) return a [ 0 ] ;				      if ( n == 1 ) return a [ 0 ] ;				  ion ‘int f_filled(int*, int)’: MAXIMUM_PRODUCT_SUB
	return a [ 0 ]					      	int max_neg = INT_MIN ;					      double maxNeg = - 999999999999 ;				  SET_ARRAY.cpp:58:39: error: no matching function f
    max_neg = - 999999999999				      	int count_neg = 0 , count_zero = 0 ;			      int countNeg = 0 ;					  or call to ‘max(double&, int&)’	 maxNeg = ma
    count_neg = 0					      	int prod = 1 ;						      int countZero = 0 ;					  x ( maxNeg , a [ i ] ) ;
    count_zero = 0					      	for ( int i = 0 ;					      double prod = 1 ;						  		^ In file included from /usr/include
    prod = 1						      	i < n ;							      for ( int i = 0 ;						  /c++/8/bits/char_traits.h:39,			 fro
    for i in range ( n ) :				      	i ++ ) {						      i < n ;							  m /usr/include/c++/8/ios:40,			from
	if a [ i ] == 0 :				      	  if ( a [ i ] == 0 ) {					      i ++ ) {							   /usr/include/c++/8/ostream:38,		   f
	    count_zero += 1				      	    count_zero ++ ;					    	if ( a [ i ] == 0 ) {					  rom /usr/include/c++/8/iostream:39,
	    continue					      	    continue ;						    	  countZero ++ ;					     from MAXIMUM_PRODUCT_SUBSET_ARRAY.cpp:8: /usr/i
	if a [ i ] < 0 :				      	  }							    	  continue ;						  nclude/c++/8/bits/stl_algobase.h:219:5: note: cand
	    count_neg += 1				      	  if ( a [ i ] < 0 ) {					    	}							  idate: ‘template<class _Tp> constexpr const _Tp& s
	    max_neg = max ( max_neg , a [ i ] )		      	    count_neg ++ ;					    	if ( a [ i ] < 0 ) {					  td::max(const _Tp&, const _Tp&)’	max(const _T
	prod = prod * a [ i ]				      	    max_neg = max ( max_neg , a [ i ] ) ;		    	  countNeg ++ ;						  p& __a, const _Tp& __b)      ^~~ /usr/include/c++/
    if count_zero == n :				      	  }							    	  maxNeg = max ( maxNeg , a [ i ] ) ;			  8/bits/stl_algobase.h:219:5: note:   template argu
	return 0					      	  prod = prod * a [ i ] ;				    	}							  ment deduction/substitution failed: MAXIMUM_PRODUC
    if count_neg & 1 :					      	}							    	prod = prod * a [ i ] ;					  T_SUBSET_ARRAY.cpp:58:39: note:   deduced conflict
	if ( count_neg == 1 and count_zero > 0 and count_zero 	if ( count_zero == n ) return 0 ;			      }								  ing types for parameter ‘const _Tp’ (‘double’ and
	    return 0					      	if ( count_neg & 1 ) {					      if ( countZero == n ) return 0 ;				  ‘int’)	maxNeg = max ( maxNeg , a [ i ] ) ;
	prod = int ( prod / max_neg )			      	  if ( count_neg == 1 && count_zero > 0 && count_zero + cou   if ( countNeg & 1 ) {					  					 ^ In file i
    return prod						      	  prod = prod / max_neg ;				    	if ( ( countNeg == 1 ) && ( countZero > 0 ) && ( countZer ncluded from /usr/include/c++/8/bits/char_traits.h
							      	}							    	prod = ( int ) ( prod / maxNeg ) ;			  :39,			from /usr/include/c++/8/ios:
							      	return prod ;						      }								  40,		       from /usr/include/c++/8/ostre
							      }								      return prod ;						  am:38,		  from /usr/include/c++/8/io
							      								    }								  stream:39,		      from MAXIMUM_PRODUCT_S
							      								    								  UBSET_ARRAY.cpp:8: /usr/include/c++/8/bits/stl_alg
							      								    								  obase.h:265:5: note: candidate: ‘template<class _T
							      								    								  p, class _Compare> constexpr const _Tp& std::max(c
							      								    								  onst _Tp&, const _Tp&, _Compare)’	 max(const _
							      								    								  Tp& __a, const _Tp& __b, _Compare __comp)	 ^~~
							      								    								   /usr/include/c++/8/bits/stl_algobase.h:265:5: not
							      								    								  e:   template argument deduction/substitution fail
							      								    								  ed: MAXIMUM_PRODUCT_SUBSET_ARRAY.cpp:58:39: note:
							      								    								    deduced conflicting types for parameter ‘const _
							      								    								  Tp’ (‘double’ and ‘int’)	  maxNeg = max ( max
							      								    								  Neg , a [ i ] ) ;
							      								    								  	 ^ In file included from /usr/include/c++/8/
							      								    								  algorithm:62,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:65,
							      								    								  	    from MAXIMUM_PRODUCT_SUBSET_ARRAY.cpp:14
							      								    								  : /usr/include/c++/8/bits/stl_algo.h:3462:5: note:
							      								    								   candidate: ‘template<class _Tp> constexpr _Tp std
							      								    								  ::max(std::initializer_list<_Tp>)’	  max(initia
							      								    								  lizer_list<_Tp> __l)	    ^~~ /usr/include/c++/8/b
							      								    								  its/stl_algo.h:3462:5: note:	 template argument d
							      								    								  eduction/substitution failed: MAXIMUM_PRODUCT_SUBS
							      								    								  ET_ARRAY.cpp:58:39: note:   mismatched types ‘std:
							      								    								  :initializer_list<_Tp>’ and ‘double’	      maxNeg
							      								    								   = max ( maxNeg , a [ i ] ) ;
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/algorithm:62,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :65,			from MAXIMUM_PRODUCT_SUBSET_
							      								    								  ARRAY.cpp:14: /usr/include/c++/8/bits/stl_algo.h:3
							      								    								  468:5: note: candidate: ‘template<class _Tp, class
							      								    								   _Compare> constexpr _Tp std::max(std::initializer
							      								    								  _list<_Tp>, _Compare)’      max(initializer_list<_
							      								    								  Tp> __l, _Compare __comp)	 ^~~ /usr/include/c+
							      								    								  +/8/bits/stl_algo.h:3468:5: note:   template argum
							      								    								  ent deduction/substitution failed: MAXIMUM_PRODUCT
							      								    								  _SUBSET_ARRAY.cpp:58:39: note:   mismatched types
							      								    								  ‘std::initializer_list<_Tp>’ and ‘double’	   m
							      								    								  axNeg = max ( maxNeg , a [ i ] ) ;
							      								    								  			  ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_MAXIMUM_SHORTEST_DISTANCE				      PRINT_MAXIMUM_SHORTEST_DISTANCE				    PRINT_MAXIMUM_SHORTEST_DISTANCE				  PRINT_MAXIMUM_SHORTEST_DISTANCE
--							      --							    --								  --
def find_maximum ( a , n , k ) :			      int find_maximum ( int a [ ] , int n , int k ) {		    int findMaximum ( int * a , int n , int k ) {		  failure : #Results: 0, 10
    b = dict ( )					      	unordered_map < int , int > b ;				      map < int , int > b ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	x = a [ i ]					      	i < n ;							      i < n ;							  
	d = min ( 1 + i , n - i )			      	i ++ ) {						      i ++ ) {							  
	if x not in b.keys ( ) :			      	  int x = a [ i ] ;					    	int x = a [ i ] ;					  
	    b [ x ] = d					      	  int d = min ( 1 + i , n - i ) ;			    	int d = min < int > ( 1 + i , n - i ) ;			  
	else :						      	  if ( b . find ( x ) == b . end ( ) ) b [ x ] = d ;	    	if ( ! b . count ( x ) ) b [ x ] = d ;			  
	    b [ x ] = min ( d , b [ x ] )		      	  else b [ x ] = min ( d , b [ x ] ) ;			    	else b [ x ] = min < int > ( d , b [ x ] ) ;		  
    ans = 10 ** 9					      	}							      }								  
    for i in range ( n ) :				      	int ans = INT_MAX ;					      int ans = 10 * 9 ;					  
	x = a [ i ]					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( x != ( k - x ) and ( k - x ) in b.keys ( ) ) :   	i < n ;							      i < n ;							  
	    ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) 	i ++ ) {						      i ++ ) {							  
    return ans						      	  int x = a [ i ] ;					    	int x = a [ i ] ;					  
							      	  if ( x != k - x && b . find ( k - x ) != b . end ( ) ) an 	if ( ( x != ( k - x ) ) && ( k - x ) < b . count ( x ) )  
							      	}							      }								  
							      	return ans ;						      return ans ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A PRINT_ARRAY_STRINGS_SORTED_ORDER_WITHOUT_COPYING_ONE_STRING_A
--							      --							    --								  --
def printInSortedOrder ( arr , n ) :			      void printInSortedOrder ( string arr [ ] , int n ) {	    int getNum ( int * nums , int num ) {			  script_not_found : None
    index = [ 0 ] * n					      	int index [ n ] ;					      int sum = 0 ;						  
    for i in range ( n ) :				      	int i , j , min ;					      for ( int i = 0 ;						  
	index [ i ] = i					      	for ( i = 0 ;						      i < num ;							  
    for i in range ( n - 1 ) :				      	i < n ;							      i ++ ) sum += nums [ i ] ;				  
	min = i						      	i ++ ) index [ i ] = i ;				      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	for ( i = 0 ;						      i < num - 1 ;						  
	    if ( arr [ index [ min ] ] > arr [ index [ j ] ]  	i < n - 1 ;						      i ++ ) {							  
		min = j					      	i ++ ) {						    	int min = i ;						  
	if ( min != i ) :				      	  min = i ;						    	for ( int j = i + 1 ;					  
	    index [ min ] , index [ i ] = index [ i ] , index 	  for ( j = i + 1 ;					    	j < num ;						  
    for i in range ( n ) :				      	  j < n ;						    	j ++ ) {						  
	print ( arr [ index [ i ] ] , end = " " )	      	  j ++ ) {						    	  if ( ( nums [ sum ] > nums [ index [ min ] ] ) && ( num 
							      	    if ( arr [ index [ min ] ] . compare ( arr [ index [ j  	}							  
							      	  }							    	if ( ( min != i ) ) sum += nums [ min ] ;		  
							      	  if ( min != i ) {					      }								  
							      	    int temp = index [ min ] ;				      for ( int i = 0 ;						  
							      	    index [ min ] = index [ i ] ;			      i < num ;							  
							      	    index [ i ] = temp ;				      i ++ ) sum += nums [ index [ i ] ] ;			  
							      	  }							      return sum ;						  
							      	}							      return num * num * num * num * num * num * num * num * num  
							      	for ( i = 0 ;						    }								  
							      	i < n ;							    								  
							      	i ++ ) cout << arr [ index [ i ] ] << " " ;		    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA COUNT_NUMBER_OF_STRINGS_MADE_OF_R_G_AND_B_USING_GIVEN_COMBINA
--							      --							    --								  --
def possibleStrings ( n , r , b , g ) :			      int possibleStrings ( int n , int r , int b , int g ) {	    double possibleStrings ( int n , int r , int b , int g ) {	  script_not_found : None
    fact = [ 0 for i in range ( n + 1 ) ]		      	int fact [ n + 1 ] ;					      vector < int > fact ( n + 1 , 0 ) ;			  
    fact [ 0 ] = 1					      	fact [ 0 ] = 1 ;					      fact [ 0 ] = 1 ;						  
    for i in range ( 1 , n + 1 , 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	fact [ i ] = fact [ i - 1 ] * i			      	i <= n ;						      i <= n ;							  
    left = n - ( r + g + b )				      	i ++ ) fact [ i ] = fact [ i - 1 ] * i ;		      i += 1 ) fact [ i ] = fact [ i - 1 ] * i ;		  
    sum = 0						      	int left = n - ( r + g + b ) ;				      int left = n - ( r + g + b ) ;				  
    for i in range ( 0 , left + 1 , 1 ) :		      	int sum = 0 ;						      double sum = 0 ;						  
	for j in range ( 0 , left - i + 1 , 1 ) :	      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    k = left - ( i + j )			      	i <= left ;						      i <= left + 1 ;						  
	    sum = ( sum + fact [ n ] / ( fact [ i + r ] * fac 	i ++ ) {						      i += 1 ) {						  
    return sum						      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
							      	  j <= left - i ;					    	j <= left - i + 1 ;					  
							      	  j ++ ) {						    	j += 1 ) {						  
							      	    int k = left - ( i + j ) ;				    	  int k = left - ( i + j ) ;				  
							      	    sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j +  	  sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j  
							      	  }							    	}							  
							      	}							      }								  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_SQUARES_BINOMIAL_COEFFICIENTS			      SUM_SQUARES_BINOMIAL_COEFFICIENTS				    SUM_SQUARES_BINOMIAL_COEFFICIENTS				  SUM_SQUARES_BINOMIAL_COEFFICIENTS
--							      --							    --								  --
def sumofsquare ( n ) :					      int sumofsquare ( int n ) {				    int sumofsquare ( int n ) {					  error : /bin/bash: line 1: 1847978 Segmentation fa
    C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 	int C [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> C ( n + 1 , vector < int > ( n + 1 ult	   (core dumped) ./SUM_SQUARES_BINOMIAL_COEF
    for i in range ( 0 , n + 1 ) :			      	int i , j ;						      for ( int j = 0 ;						  FICIENTS_cpp
	for j in range ( 0 , min ( i , n ) + 1 ) :	      	for ( i = 0 ;						      j < n + 1 ;						  
	    if ( j == 0 or j == i ) :			      	i <= n ;						      j ++ ) {							  
		C [ i ] [ j ] = 1			      	i ++ ) {						    	for ( int i = 0 ;					  
	    else :					      	  for ( j = 0 ;						    	i <= n ;						  
		C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ 	  j <= min ( i , n ) ;					    	i ++ ) {						  
    sum = 0						      	  j ++ ) {						    	  for ( int j = 0 ;					  
    for i in range ( 0 , n + 1 ) :			      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  j <= min ( i , n ) + 1 ;				  
	sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] )	      	    else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	  j ++ ) {						  
    return sum						      	  }							    	    if ( ( j == 0 || j == i ) ) C [ i ] [ j ] = 1 ;	  
							      	}							    	    else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i  
							      	int sum = 0 ;						    	  }							  
							      	for ( int i = 0 ;					    	}							  
							      	i <= n ;						      }								  
							      	i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ;	      int sum = 0 ;						  
							      	return sum ;						      for ( int i = 0 ;						  
							      }								      i <= n ;							  
							      								      i ++ ) sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) ;	  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH	      SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH	    SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH	  SHORTEST_PATH_EXACTLY_K_EDGES_DIRECTED_WEIGHTED_GRAPH
--							      --							    --								  --
def shortestPath ( graph , u , v , k ) :		      INT_MAX int shortestPath ( int graph [ ] [ V ] , int u , int  int shortestPath ( int * * graph , int u , int v , int k ) {  script_not_found : None
    V = 4						      	if ( k == 0 && u == v ) return 0 ;			      int V = 4 ;						  
    INF = 999999999999					      	if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u    int INF = 999999999999 ;					  
    if k == 0 and u == v :				      	if ( k <= 0 ) return INF ;				      if ( k == 0 && u == v ) return 0 ;			  
	return 0					      	int res = INF ;						      if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u  
    if k == 1 and graph [ u ] [ v ] != INF :		      	for ( int i = 0 ;					      if ( k <= 0 ) return INF ;				  
	return graph [ u ] [ v ]			      	i < V ;							      int res = INF ;						  
    if k <= 0 :						      	i ++ ) {						      for ( int i = 0 ;						  
	return INF					      	  if ( graph [ u ] [ i ] != INF && u != i && v != i ) {	      i < V ;							  
    res = INF						      	    int rec_res = shortestPath ( graph , i , v , k - 1 ) ;    i ++ ) {							  
    for i in range ( V ) :				      	    if ( rec_res != INF ) res = min ( res , graph [ u ] [ i 	if ( graph [ u ] [ i ] != INF && u != i && v != i ) {	  
	if graph [ u ] [ i ] != INF and u != i and v != i :   	  }							    	  int recRes = shortestPath ( graph , i , v , k - 1 ) ;	  
	    rec_res = shortestPath ( graph , i , v , k - 1 )  	}							    	  if ( recRes != INF ) res = min < int > ( res , graph [  
	    if rec_res != INF :				      	return res ;						    	}							  
		res = min ( res , graph [ u ] [ i ] + rec_res }								      }								  
    return res						      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS	      MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS	    MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS		  MINIMIZE_THE_MAXIMUM_DIFFERENCE_BETWEEN_THE_HEIGHTS
--							      --							    --								  --
def getMinDiff ( arr , n , k ) :			      int getMinDiff ( int arr [ ] , int n , int k ) {		    int getMinDiff ( int * arr , int n , int k ) {		  success : None
    if ( n == 1 ) :					      	if ( n == 1 ) return 0 ;				      if ( ( n == 1 ) ) return 0 ;				  
	return 0					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    arr.sort ( )					      	int ans = arr [ n - 1 ] - arr [ 0 ] ;			      int ans = arr [ n - 1 ] - arr [ 0 ] ;			  
    ans = arr [ n - 1 ] - arr [ 0 ]			      	int small = arr [ 0 ] + k ;				      int small = arr [ 0 ] + k ;				  
    small = arr [ 0 ] + k				      	int big = arr [ n - 1 ] - k ;				      int big = arr [ n - 1 ] - k ;				  
    big = arr [ n - 1 ] - k				      	if ( small > big ) swap ( small , big ) ;		      if ( ( small > big ) ) small = big ;			  
    if ( small > big ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	small , big = big , small			      	i < n - 1 ;						      i < n - 1 ;						  
    for i in range ( 1 , n - 1 ) :			      	i ++ ) {						      i ++ ) {							  
	subtract = arr [ i ] - k			      	  int subtract = arr [ i ] - k ;			    	int subtract = arr [ i ] - k ;				  
	add = arr [ i ] + k				      	  int add = arr [ i ] + k ;				    	int add = arr [ i ] + k ;				  
	if ( subtract >= small or add <= big ) :	      	  if ( subtract >= small || add <= big ) continue ;	    	if ( ( subtract >= small ) || ( add <= big ) ) continue ; 
	    continue					      	  if ( big - subtract <= add - small ) small = subtract ;   	if ( ( big - subtract <= add - small ) ) small = subtract 
	if ( big - subtract <= add - small ) :		      	  else big = add ;					    	else big = add ;					  
	    small = subtract				      	}							      }								  
	else :						      	return min ( ans , big - small ) ;			      return min ( ans , big - small ) ;			  
	    big = add					      }								    }								  
    return min ( ans , big - small )			      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX		      MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX		    MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX		  MAXIMUM_DIFFERENCE_SUM_ELEMENTS_TWO_ROWS_MATRIX
--							      --							    --								  --
def maxRowDiff ( mat , m , n ) :			      int maxRowDiff ( int mat [ ] [ MAX ] , int m , int n ) {	    int maxRowDiff ( int * * mat , int m , int n ) {		  script_not_found : None
    rowSum = [ 0 ] * m					      	int rowSum [ m ] ;					      int rowSum [ m ] ;					  
    for i in range ( 0 , m ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	sum = 0						      	i < m ;							      i < m ;							  
	for j in range ( 0 , n ) :			      	i ++ ) {						      i ++ ) {							  
	    sum += mat [ i ] [ j ]			      	  int sum = 0 ;						    	int sum = 0 ;						  
	rowSum [ i ] = sum				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    max_diff = rowSum [ 1 ] - rowSum [ 0 ]		      	  j < n ;						    	j < n ;							  
    min_element = rowSum [ 0 ]				      	  j ++ ) sum += mat [ i ] [ j ] ;			    	j ++ ) sum += mat [ i ] [ j ] ;				  
    for i in range ( 1 , m ) :				      	  rowSum [ i ] = sum ;					    	rowSum [ i ] = sum ;					  
	if ( rowSum [ i ] - min_element > max_diff ) :	      	}							      }								  
	    max_diff = rowSum [ i ] - min_element	      	int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ;		      int maxDiff = rowSum [ 1 ] - rowSum [ 0 ] ;		  
	if ( rowSum [ i ] < min_element ) :		      	int min_element = rowSum [ 0 ] ;			      int minElement = rowSum [ 0 ] ;				  
	    min_element = rowSum [ i ]			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
    return max_diff					      	i < m ;							      i < m ;							  
							      	i ++ ) {						      i ++ ) {							  
							      	  if ( rowSum [ i ] - min_element > max_diff ) max_diff = r 	if ( ( rowSum [ i ] - minElement > maxDiff ) && ( rowSum  
							      	  if ( rowSum [ i ] < min_element ) min_element = rowSum [    }								  
							      	}							      return maxDiff ;						  
							      	return max_diff ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_WAYS_JUMP_REACH_END			      COUNT_NUMBER_WAYS_JUMP_REACH_END				    COUNT_NUMBER_WAYS_JUMP_REACH_END				  COUNT_NUMBER_WAYS_JUMP_REACH_END
--							      --							    --								  --
def countWaysToJump ( arr , n ) :			      void countWaysToJump ( int arr [ ] , int n ) {		    int countWaysToJump ( int * arr , int n ) {			  script_not_found : None
    count_jump = [ 0 for i in range ( n ) ]		      	int count_jump [ n ] ;					      vector < int > countJump ( n , 0 ) ;			  
    for i in range ( n - 2 , - 1 , - 1 ) :		      	memset ( count_jump , 0 , sizeof ( count_jump ) ) ;	      for ( int i = 0 ;						  
	if ( arr [ i ] >= n - i - 1 ) :			      	for ( int i = n - 2 ;					      i < n ;							  
	    count_jump [ i ] += 1			      	i >= 0 ;						      i ++ ) {							  
	j = i + 1					      	i -- ) {						    	if ( ( arr [ i ] >= n - i - 1 ) ) countJump [ i ] ++ ;	  
	while ( j < n - 1 and j <= arr [ i ] + i ) :	      	  if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ;	    	int j = i + 1 ;						  
	    if ( count_jump [ j ] != - 1 ) :		      	  for ( int j = i + 1 ;					    	while ( ( j < n - 1 ) && ( j <= arr [ i ] + i ) ) {	  
		count_jump [ i ] += count_jump [ j ]	      	  j < n - 1 && j <= arr [ i ] + i ;			    	  if ( ( countJump [ j ] != - 1 ) ) countJump [ i ] += co 
	    j += 1					      	  j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += 	  j ++ ;						  
	if ( count_jump [ i ] == 0 ) :			      	  if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ;	    	}							  
	    count_jump [ i ] = - 1			      	}							    	if ( ( countJump [ i ] == 0 ) ) countJump [ i ] = - 1 ;	  
    for i in range ( n ) :				      	for ( int i = 0 ;					      }								  
	print ( count_jump [ i ] , end = " " )		      	i < n ;							      for ( int i = 0 ;						  
							      	i ++ ) cout << count_jump [ i ] << " " ;		      i < n ;							  
							      }								      i ++ ) cout << countJump [ i ] << " " ;			  
							      								      return n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S		      LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S		    LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S		  LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S
--							      --							    --								  --
def findSubArray ( arr , n ) :				      int findSubArray ( int arr [ ] , int n ) {		    int findSubArray ( int * arr , int n ) {			  error : LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_A
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  ND_1S.cpp: In function ‘int f_filled(int*, int)’:
    maxsize = - 1					      	int maxsize = - 1 , startindex ;			      int maxsize = - 1 ;					  LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S.cp
    for i in range ( 0 , n - 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  p:52:9: error: ‘startindex’ was not declared in th
	sum = - 1 if ( arr [ i ] == 0 ) else 1		      	i < n - 1 ;						      i <= n - 1 ;						  is scope	    startindex = i ;	      ^~~~~~
	for j in range ( i + 1 , n ) :			      	i ++ ) {						      i ++ ) {							  ~~~~ LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_
	    sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else su 	  sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;			    	sum = ( arr [ i ] == 0 ) ? - 1 : 1 ;			  1S.cpp:52:9: note: suggested alternative: ‘rindex’
	    if ( sum == 0 and maxsize < j - i + 1 ) :	      	  for ( int j = i + 1 ;					    	for ( int j = i + 1 ;					  	    startindex = i ;	      ^~~~~~~~~~
		maxsize = j - i + 1			      	  j < n ;						    	j < n ;							  	rindex LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF
		startindex = i				      	  j ++ ) {						    	j ++ ) {						  _0S_AND_1S.cpp:57:16: error: ‘startindex’ was not
    if ( maxsize == - 1 ) :				      	    ( arr [ j ] == 0 ) ? ( sum += - 1 ) : ( sum += 1 ) ;    	  sum = ( arr [ j ] == 0 ) ? ( - 1 ) : sum + 1 ;	  declared in this scope    else cout << startindex
	print ( "No such subarray" )			      	    if ( sum == 0 && maxsize < j - i + 1 ) {		    	  if ( ( sum == 0 ) && ( maxsize < j - i + 1 ) ) {	  << " to" << startindex + maxsize - 1 ;
    else :						      	      maxsize = j - i + 1 ;				    	    maxsize = j - i + 1 ;				       ^~~~~~~~~~ LARGEST_SUBARRAY_WITH_EQUAL_NUMBER
	print ( startindex , "to" , startindex + maxsize - 1  	      startindex = i ;					    	    startindex = i ;					  _OF_0S_AND_1S.cpp:57:16: note: suggested alternati
    return maxsize					      	    }							    	  }							  ve: ‘rindex’	  else cout << startindex << " to" <
							      	  }							    	}							  < startindex + maxsize - 1 ;		       ^~~~~
							      	}							      }								  ~~~~~			rindex
							      	if ( maxsize == - 1 ) cout << "No such subarray" ;	      if ( ( maxsize == - 1 ) ) cout << "No such subarray" << end 
							      	else cout << startindex << " to " << startindex + maxsize -   else cout << startindex << " to" << startindex + maxsize -  
							      	return maxsize ;					      return maxsize ;						  
							      }								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D		      FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D			    FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D			  FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D
--							      --							    --								  --
def findLargestd ( S , n ) :				      int findLargestd ( int S [ ] , int n ) {			    int findLargestd ( string S , int n ) {			  error : FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D.
    found = False					      	bool found = false ;					      bool found = false ;					  cpp:73:1: error: expected unqualified-id before ‘i
    S.sort ( )						      	sort ( S , S + n ) ;					      sort ( S . begin ( ) , S . end ( ) ) ;			  f’  if ( ( found == false ) ) return - 1 ;  ^~ FIN
    for i in range ( n - 1 , - 1 , - 1 ) :		      	for ( int i = n - 1 ;					      for ( int i = n - 1 ;					  D_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D.cpp:74:1: e
	for j in range ( 0 , n ) :			      	i >= 0 ;						      i >= 0 ;							  rror: expected unqualified-id before ‘return’	 ret
	    if ( i == j ) :				      	i -- ) {						      i -- ) {							  urn n * n ;  ^~~~~~ FIND_LARGEST_D_IN_ARRAY_SUCH_T
		continue				      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  HAT_A_B_C_D.cpp:75:1: error: expected unqualified-
	    for k in range ( j + 1 , n ) :		      	  j < n ;						    	j <= n ;						  id before ‘return’  return n * n * n * n * n * n *
		if ( i == k ) :				      	  j ++ ) {						    	j ++ ) {						   n * n * n * n * n * n * n * n * n * n * n * n * n
		    continue				      	    if ( i == j ) continue ;				    	  if ( ( i == j ) ) continue ;				   * n * n * n * n * n * n * n * n * n * n * n * n *
		for l in range ( k + 1 , n ) :		      	    for ( int k = j + 1 ;				    	  for ( int k = j + 1 ;					   n * n * n * n * n * n * n * n * n * n * n * n * n
		    if ( i == l ) :			      	    k < n ;						    	  k < n ;						   * n * n * n * n * n * n * n * n * n * n * n * n *
			continue			      	    k ++ ) {						    	  k ++ ) {						   n * n * n * n * n * n * n * n * n * n * n * n * n
		    if ( S [ i ] == S [ j ] + S [ k ] + S [ l 	      if ( i == k ) continue ;				    	    if ( ( i == k ) ) continue ;			   * n * n * n * n * n * n * n * n * n * n * n * n *
			found = True			      	      for ( int l = k + 1 ;				    	    for ( int l = k + 1 ;				   n * n * n * n * n * n * n * n * n * n * n * n * n
			return S [ i ]			      	      l < n ;						    	    l < n ;						   * n * n * n * n * n * n * n * n * n * n * n * n *
    if ( found == False ) :				      	      l ++ ) {						    	    l ++ ) {						   n * n * n * n * n * n * n * n * n * n * n * n * n
	return - 1					      		if ( i == l ) continue ;			    	      if ( ( i == l ) ) continue ;			   * n * n * n * n * n * n * n * n * n * n * n * n *
							      		if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) {	    	      if ( ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) ) {  n * n * n * n * n * n * n * n * n * n * n * n * n
							      		  found = true ;				    		found = true ;					   * n * n * n * n * n * n * n * n * n * n * n * n *
							      		  return S [ i ] ;				    		return S [ i ] ;				   n * n * n ;	^~~~~~ FIND_LARGEST_D_IN_ARRAY_SUCH_
							      		}						    	      }							  THAT_A_B_C_D.cpp:76:1: error: expected declaration
							      	      }							    	    }							   before ‘}’ token  }	^ FIND_LARGEST_D_IN_ARRAY_SU
							      	    }							    	  }							  CH_THAT_A_B_C_D.cpp: In function ‘int f_gold(int*,
							      	  }							    	}							   int)’: FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D.
							      	}							      }								  cpp:43:1: warning: control reaches end of non-void
							      	if ( found == false ) return INT_MIN ;			    }								   function [-Wreturn-type]  }	^ FIND_LARGEST_D_IN_
							      }								    if ( ( found == false ) ) return - 1 ;			  ARRAY_SUCH_THAT_A_B_C_D.cpp: In function ‘int f_fi
							      								    return n * n ;						  lled(std::__cxx11::string, int)’: FIND_LARGEST_D_I
							      								    return n * n * n * n * n * n * n * n * n * n * n * n * n * n  N_ARRAY_SUCH_THAT_A_B_C_D.cpp:72:1: warning: contr
							      								    }								  ol reaches end of non-void function [-Wreturn-type
							      								    								  ]  }	^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_REPEATING_SUBSEQUENCE				      LONGEST_REPEATING_SUBSEQUENCE				    LONGEST_REPEATING_SUBSEQUENCE				  LONGEST_REPEATING_SUBSEQUENCE
--							      --							    --								  --
def findLongestRepeatingSubSeq ( str ) :		      int findLongestRepeatingSubSeq ( string str ) {		    int findLongestRepeatingSubSeq ( string str ) {		  success : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    dp = [ [ 0 ] * ( n + 1 ) ] * ( n + 1 )		      	int dp [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( n +  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 0 ;					      for ( int i = 1 ;						  
	for j in range ( 1 , n + 1 ) :			      	i <= n ;						      i <= n ;							  
	    if ( str [ i - 1 ] == str [ j - 1 ] and i != j )  	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]   	j <= n ;						    	for ( int j = 1 ;					  
	    else :					      	j ++ ) dp [ i ] [ j ] = 0 ;				    	j <= n ;						  
		dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , d 	for ( int i = 1 ;					    	j ++ ) {						  
    return dp [ n ] [ n ]				      	i <= n ;						    	  if ( ( str [ i - 1 ] == str [ j - 1 ] && i != j ) || (  
							      	i ++ ) {						    	  else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i 
							      	  for ( int j = 1 ;					    	}							  
							      	  j <= n ;						      }								  
							      	  j ++ ) {						      return dp [ n ] [ n ] ;					  
							      	    if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i  }								  
							      	    else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i 								  
							      	  }							    								  
							      	}							    								  
							      	return dp [ n ] [ n ] ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY		      MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY			    MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY			  MINIMUM_NUMBER_SWAPS_REQUIRED_SORT_ARRAY
--							      --							    --								  --
def minSwaps ( arr ) :					      int minSwaps ( int arr [ ] , int n ) {			    int minSwaps ( int * arr ) {				  script_not_found : None
    n = len ( arr )					      	pair < int , int > arrPos [ n ] ;			      int n = sizeof ( arr ) / sizeof ( int ) ;			  
    arrpos = [ * enumerate ( arr ) ]			      	for ( int i = 0 ;					      vector < vector < int >> arrpos ( n , vector < int > ( arr  
    arrpos.sort ( key = lambda it : it [ 1 ] )		      	i < n ;							      sort ( arrpos . begin ( ) , arrpos . end ( ) , [ ] ( const  
    vis = { k : False for k in range ( n ) }		      	i ++ ) {						    	return it [ 1 ] < it [ 0 ] ;				  
    ans = 0						      	  arrPos [ i ] . first = arr [ i ] ;			      }								  
    for i in range ( n ) :				      	  arrPos [ i ] . second = i ;				      ) ;							  
	if vis [ i ] or arrpos [ i ] [ 0 ] == i :	      	}							      map < int , bool > vis ;					  
	    continue					      	sort ( arrPos , arrPos + n ) ;				      vis [ k ] = false ;					  
	cycle_size = 0					      	vector < bool > vis ( n , false ) ;			      int ans = 0 ;						  
	j = i						      	int ans = 0 ;						      for ( int i = 0 ;						  
	while not vis [ j ] :				      	for ( int i = 0 ;					      i < n ;							  
	    vis [ j ] = True				      	i < n ;							      i ++ ) {							  
	    j = arrpos [ j ] [ 0 ]			      	i ++ ) {						    	if ( vis [ i ] || arrpos [ i ] [ 0 ] == i ) continue ;	  
	    cycle_size += 1				      	  if ( vis [ i ] || arrPos [ i ] . second == i ) continue ; 	int cycleSize = 0 ;					  
	if cycle_size > 0 :				      	  int cycle_size = 0 ;					    	int j = i ;						  
	    ans += ( cycle_size - 1 )			      	  int j = i ;						    	while ( ! vis [ j ] ) {					  
    return ans						      	  while ( ! vis [ j ] ) {				    	  vis [ j ] = true ;					  
							      	    vis [ j ] = 1 ;					    	  j = arrpos [ j ] [ 0 ] ;				  
							      	    j = arrPos [ j ] . second ;				    	  cycleSize ++ ;					  
							      	    cycle_size ++ ;					    	}							  
							      	  }							    	if ( cycleSize > 0 ) ans += ( cycleSize - 1 ) ;		  
							      	  if ( cycle_size > 0 ) {				      }								  
							      	    ans += ( cycle_size - 1 ) ;				      return ans ;						  
							      	  }							    }								  
							      	}							    								  
							      	return ans ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C			      MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C			    MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C				  MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C
--							      --							    --								  --
def maximumSegments ( n , a , b , c ) :			      int maximumSegments ( int n , int a , int b , int c ) {	    int maximumSegments ( int n , int a , int b , int c ) {	  error : MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C.cpp: I
    dp = [ - 1 ] * ( n + 10 )				      	int dp [ n + 1 ] ;					      vector < int > dp ( n + 10 , - 1 ) ;			  n function ‘int f_filled(int, int, int, int)’: MAX
    dp [ 0 ] = 0					      	memset ( dp , - 1 , sizeof ( dp ) ) ;			      dp [ 0 ] = 0 ;						  IMUM_NUMBER_SEGMENTS_LENGTHS_B_C.cpp:45:1: warning
    for i in range ( 0 , n ) :				      	dp [ 0 ] = 0 ;						      for ( int i = 0 ;						  : no return statement in function returning non-vo
	if ( dp [ i ] != - 1 ) :			      	for ( int i = 0 ;					      i <= n ;							  id [-Wreturn-type]  }	 ^ MAXIMUM_NUMBER_SEGMENTS_L
	    if ( i + a <= n ) :				      	i < n ;							      i ++ ) {							  ENGTHS_B_C.cpp: At global scope: MAXIMUM_NUMBER_SE
		dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i +  	i ++ ) {						    	if ( ( dp [ i ] != - 1 ) ) {				  GMENTS_LENGTHS_B_C.cpp:46:1: error: expected unqua
	    if ( i + b <= n ) :				      	  if ( dp [ i ] != - 1 ) {				    	  if ( ( i + a <= n ) ) dp [ i + a ] = max ( dp [ i ] + 1 lified-id before ‘return’  return dp [ n ] ;	^~~~
		dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i +  	    if ( i + a <= n ) dp [ i + a ] = max ( dp [ i ] + 1 , d 	  if ( ( i + b <= n ) ) dp [ i + b ] = max ( dp [ i ] + 1 ~~ MAXIMUM_NUMBER_SEGMENTS_LENGTHS_B_C.cpp:47:1: e
	    if ( i + c <= n ) :				      	    if ( i + b <= n ) dp [ i + b ] = max ( dp [ i ] + 1 , d 	  if ( ( i + c <= n ) ) dp [ i + c ] = max ( dp [ i ] + 1 rror: expected declaration before ‘}’ token  }  ^
		dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i +  	    if ( i + c <= n ) dp [ i + c ] = max ( dp [ i ] + 1 , d 	}							  
    return dp [ n ]					      	  }							      }								  
							      	}							    }								  
							      	return dp [ n ] ;					    return dp [ n ] ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_COMMON_SUBSTRING				      LONGEST_COMMON_SUBSTRING					    LONGEST_COMMON_SUBSTRING					  LONGEST_COMMON_SUBSTRING
--							      --							    --								  --
def LCSubStr ( X , Y , m , n ) :			      int LCSubStr ( char * X , char * Y , int m , int n ) {	    int LCSubStr ( string X , string Y , int m , int n ) {	  script_not_found : None
    LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range  	int LCSuff [ m + 1 ] [ n + 1 ] ;			      vector < vector < int >> LCSuff ( n + 1 , vector < int > (  
    result = 0						      	int result = 0 ;					      for ( int l = 0 ;						  
    for i in range ( m + 1 ) :				      	for ( int i = 0 ;					      l < m + 1 ;						  
	for j in range ( n + 1 ) :			      	i <= m ;						      l ++ ) {							  
	    if ( i == 0 or j == 0 ) :			      	i ++ ) {						    	for ( int i = 0 ;					  
		LCSuff [ i ] [ j ] = 0			      	  for ( int j = 0 ;					    	i < n + 1 ;						  
	    elif ( X [ i - 1 ] == Y [ j - 1 ] ) :	      	  j <= n ;						    	i ++ ) {						  
		LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 	  j ++ ) {						    	  if ( ( i == 0 || j == 0 ) && ( X [ i - 1 ] == Y [ j - 1 
		result = max ( result , LCSuff [ i ] [ j ] )  	    if ( i == 0 || j == 0 ) LCSuff [ i ] [ j ] = 0 ;	    	  else if ( ( X [ i - 1 ] == Y [ j - 1 ] ) && ( X [ i - 1 
	    else :					      	    else if ( X [ i - 1 ] == Y [ j - 1 ] ) {		    	    LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; 
		LCSuff [ i ] [ j ] = 0			      	      LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; 	    result = max ( result , LCSuff [ i ] [ j ] ) ;	  
    return result					      	      result = max ( result , LCSuff [ i ] [ j ] ) ;	    	  }							  
							      	    }							    	  else LCSuff [ i ] [ j ] = 0 ;				  
							      	    else LCSuff [ i ] [ j ] = 0 ;			    	}							  
							      	  }							      }								  
							      	}							    }								  
							      	return result ;						    return result ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2		      FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2		    FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2			  FIND_TRIPLETS_ARRAY_WHOSE_SUM_EQUAL_ZERO_2
--							      --							    --								  --
def findTriplets ( arr , n ) :				      void findTriplets ( int arr [ ] , int n ) {		    int findTriplets ( int * arr , int n ) {			  script_not_found : None
    found = False					      	bool found = false ;					      bool found = false ;					  
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
    for i in range ( 0 , n - 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	l = i + 1					      	i < n - 1 ;						      i <= n - 1 ;						  
	r = n - 1					      	i ++ ) {						      i ++ ) {							  
	x = arr [ i ]					      	  int l = i + 1 ;					    	int l = i + 1 ;						  
	while ( l < r ) :				      	  int r = n - 1 ;					    	int r = n - 1 ;						  
	    if ( x + arr [ l ] + arr [ r ] == 0 ) :	      	  int x = arr [ i ] ;					    	int x = arr [ i ] ;					  
		print ( x , arr [ l ] , arr [ r ] )	      	  while ( l < r ) {					    	while ( ( l < r ) ) {					  
		l += 1					      	    if ( x + arr [ l ] + arr [ r ] == 0 ) {		    	  if ( ( x + arr [ l ] + arr [ r ] == 0 ) ) {		  
		r -= 1					      	      printf ( "%d %d %d\n" , x , arr [ l ] , arr [ r ] ) ; 	    cout << x << " " << arr [ l ] << " " << arr [ r ] <<  
		found = True				      	      l ++ ;						    	    l ++ ;						  
	    elif ( x + arr [ l ] + arr [ r ] < 0 ) :	      	      r -- ;						    	    r -- ;						  
		l += 1					      	      found = true ;					    	    found = true ;					  
	    else :					      	    }							    	  }							  
		r -= 1					      	    else if ( x + arr [ l ] + arr [ r ] < 0 ) l ++ ;	    	  else if ( ( x + arr [ l ] + arr [ r ] < 0 ) ) l ++ ;	  
    if ( found == False ) :				      	    else r -- ;						    	  else r -- ;						  
	print ( " No Triplet Found" )			      	  }							    	}							  
							      	}							      }								  
							      	if ( found == false ) cout << " No Triplet Found" << endl ;   if ( ( found == false ) == false ) cout << " No Triplet Fou 
							      }								      return n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2	      LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2	    LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2		  LONGEST_SUBSEQUENCE_DIFFERENCE_ADJACENTS_ONE_SET_2
--							      --							    --								  --
def longLenSub ( arr , n ) :				      int longLenSub ( int arr [ ] , int n ) {			    int longLenSub ( int * arr , int n ) {			  failure : #Results: 6, 10
    um = defaultdict ( lambda : 0 )			      	unordered_map < int , int > um ;			      unordered_map < int , int > um ;				  
    longLen = 0						      	int longLen = 0 ;					      int longLen = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	len1 = 0					      	i < n ;							      i < n ;							  
	if ( arr [ i - 1 ] in um and len1 < um [ arr [ i ] -  	i ++ ) {						      i ++ ) {							  
	    len1 = um [ arr [ i ] - 1 ]			      	  int len = 0 ;						    	int len1 = 0 ;						  
	if ( arr [ i ] + 1 in um and len1 < um [ arr [ i ] +  	  if ( um . find ( arr [ i ] - 1 ) != um . end ( ) && len < 	if ( ( arr [ i ] - 1 ) < um . count ( arr [ i ] - 1 ) &&  
	    len1 = um [ arr [ i ] + 1 ]			      	  if ( um . find ( arr [ i ] + 1 ) != um . end ( ) && len < 	if ( ( arr [ i ] + 1 ) < um . count ( arr [ i ] + 1 ) &&  
	um [ arr [ i ] ] = len1 + 1			      	  um [ arr [ i ] ] = len + 1 ;				    	um [ arr [ i ] ] = len1 + 1 ;				  
	if longLen < um [ arr [ i ] ] :			      	  if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i  	if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i  
	    longLen = um [ arr [ i ] ]			      	}							      }								  
    return longLen					      	return longLen ;					      return longLen ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SERIES_LARGEST_GCD_SUM_EQUALS_N				      SERIES_LARGEST_GCD_SUM_EQUALS_N				    SERIES_LARGEST_GCD_SUM_EQUALS_N				  SERIES_LARGEST_GCD_SUM_EQUALS_N
--							      --							    --								  --
def print_sequence ( n , k ) :				      void print_sequence ( int n , int k ) {			    int printSequence ( int n , int k ) {			  script_not_found : None
    b = int ( n / ( k * ( k + 1 ) / 2 ) )		      	int b = n / ( k * ( k + 1 ) / 2 ) ;			      int b = ( int ) ( n / ( k * ( k + 1 ) / 2 ) ) ;		  
    if b == 0 :						      	if ( b == 0 ) {						      if ( b == 0 ) cout << "-1" ;				  
	print ( "-1" )					      	  cout << - 1 << endl ;					      else {							  
    else :						      	}							    	int r = 1 ;						  
	r = 1						      	else {							    	int x = 1 ;						  
	x = 1						      	  int r = 1 ;						    	while ( x * x <= n ) {					  
	while x ** 2 <= n :				      	  for ( int x = 1 ;					    	  if ( n % x != 0 ) continue ;				  
	    if n % x != 0 :				      	  x * x <= n ;						    	  else if ( x <= b && x > r ) r = x ;			  
		continue				      	  x ++ ) {						    	  else if ( n / x <= b && n / x > r ) r = n / x ;	  
	    elif x <= b and x > r :			      	    if ( n % x != 0 ) continue ;			    	  x = x + 1 ;						  
		r = x					      	    if ( x <= b && x > r ) r = x ;			    	}							  
	    elif n / x <= b and n / x > r :		      	    if ( n / x <= b && n / x > r ) r = n / x ;		    	int i = 1 ;						  
		r = n / x				      	  }							    	while ( i < k ) {					  
	    x = x + 1					      	  for ( int i = 1 ;					    	  cout << r * i << " " ;				  
	i = 1						      	  i < k ;						    	  i = i + 1 ;						  
	while i < k :					      	  i ++ ) cout << r * i << " " ;				    	}							  
	    print ( r * i , end = " " )			      	  int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ;		    	int lastTerm = n - ( r * ( k * ( k - 1 ) / 2 ) ) ;	  
	    i = i + 1					      	  cout << res << endl ;					    	cout << lastTerm ;					  
	last_term = n - ( r * ( k * ( k - 1 ) / 2 ) )	      	}							      }								  
	print ( last_term )				      }								      return 0 ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU REARRANGE_A_STRING_IN_SORTED_ORDER_FOLLOWED_BY_THE_INTEGER_SU
--							      --							    --								  --
def arrangeString ( string ) :				      string arrangeString ( string str ) {			    string arrangeString ( string string ) {			  script_not_found : None
    char_count = [ 0 ] * MAX_CHAR			      	int char_count [ MAX_CHAR ] = {				      vector < int > charCount ( MAX_CHAR , 0 ) ;		  
    s = 0						      	  0 }							      int s = 0 ;						  
    for i in range ( len ( string ) ) :			      	  ;							      for ( int i = 0 ;						  
	if string [ i ] >= "A" and string [ i ] <= "Z" :      	  int sum = 0 ;						      i < string . length ( ) ;					  
	    char_count [ ord ( string [ i ] ) - ord ( "A" ) ] 	  for ( int i = 0 ;					      i ++ ) {							  
	else :						      	  i < str . length ( ) ;				    	if ( string [ i ] >= 'A' && string [ i ] <= 'Z' ) charCou 
	    s += ord ( string [ i ] ) - ord ( "0" )	      	  i ++ ) {						    	else s += string [ i ] - '0' ;				  
    res = ""						      	    if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) char_count    }								  
    for i in range ( MAX_CHAR ) :			      	    else sum = sum + ( str [ i ] - '0' ) ;		      string res ;						  
	ch = chr ( ord ( "A" ) + i )			      	  }							      for ( int i = 0 ;						  
	while char_count [ i ] :			      	  string res = "" ;					      i < MAX_CHAR ;						  
	    res += ch					      	  for ( int i = 0 ;					      i ++ ) {							  
	    char_count [ i ] -= 1			      	  i < MAX_CHAR ;					    	char ch = ( char ) ( 'A' + i ) ;			  
    if s > 0 :						      	  i ++ ) {						    	while ( charCount [ i ] ) {				  
	res += str ( s )				      	    char ch = ( char ) ( 'A' + i ) ;			    	  res += ch ;						  
    return res						      	    while ( char_count [ i ] -- ) res = res + ch ;	    	  charCount [ i ] -- ;					  
							      	  }							    	}							  
							      	  if ( sum > 0 ) res = res + to_string ( sum ) ;	      }								  
							      	  return res ;						      if ( s > 0 ) res += to_string ( s ) ;			  
							      	}							      return res ;						  
							      								      return " " + string + " " + string ;			  
							      								      return " " + string ;					  
							      								      return " " + string ;					  
							      								      return " " + string ;					  
							      								      return " " + string + " " + string + " " + string ;	  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
KNAPSACK_PROBLEM_1					      KNAPSACK_PROBLEM_1					    KNAPSACK_PROBLEM_1						  KNAPSACK_PROBLEM_1
--							      --							    --								  --
def knapSack ( W , wt , val , n ) :			      int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {   int knapSack ( int W , int * wt , int * val , int n ) {	  script_not_found : None
    K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 	int i , w ;						      vector < vector < int >> K ( W + 1 , vector < int > ( n + 1 
    for i in range ( n + 1 ) :				      	int K [ n + 1 ] [ W + 1 ] ;				      for ( int i = 0 ;						  
	for w in range ( W + 1 ) :			      	for ( i = 0 ;						      i < n + 1 ;						  
	    if i == 0 or w == 0 :			      	i <= n ;						      i ++ ) {							  
		K [ i ] [ w ] = 0			      	i ++ ) {						    	for ( int w = 0 ;					  
	    elif wt [ i - 1 ] <= w :			      	  for ( w = 0 ;						    	w < W + 1 ;						  
		K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 	  w <= W ;						    	w ++ ) {						  
	    else :					      	  w ++ ) {						    	  if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;		  
		K [ i ] [ w ] = K [ i - 1 ] [ w ]	      	    if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;		    	  else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 
    return K [ n ] [ W ]				      	    else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 	  else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		  
							      	    else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		    	}							  
							      	  }							      }								  
							      	}							      return K [ n ] [ W ] ;					  
							      	return K [ n ] [ W ] ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COCKTAIL_SORT						      COCKTAIL_SORT						    COCKTAIL_SORT						  COCKTAIL_SORT
--							      --							    --								  --
def cocktailSort ( a ) :				      void CocktailSort ( int a [ ] , int n ) {			    void cocktailSort ( vector < int > a ) {			  script_not_found : None
    n = len ( a )					      	bool swapped = true ;					      int n = a . size ( ) ;					  
    swapped = True					      	int start = 0 ;						      bool swapped = true ;					  
    start = 0						      	int end = n - 1 ;					      int start = 0 ;						  
    end = n - 1						      	while ( swapped ) {					      int end = n - 1 ;						  
    while ( swapped == True ) :				      	  swapped = false ;					      while ( ( swapped == true ) ) {				  
	swapped = False					      	  for ( int i = start ;					    	swapped = false ;					  
	for i in range ( start , end ) :		      	  i < end ;						    	for ( int i = start ;					  
	    if ( a [ i ] > a [ i + 1 ] ) :		      	  ++ i ) {						    	i < end ;						  
		a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] 	    if ( a [ i ] > a [ i + 1 ] ) {			    	i ++ ) {						  
		swapped = True				      	      swap ( a [ i ] , a [ i + 1 ] ) ;			    	  if ( ( a [ i ] > a [ i + 1 ] ) ) {			  
	if ( swapped == False ) :			      	      swapped = true ;					    	    a [ i ] = a [ i + 1 ] ;				  
	    break					      	    }							    	    a [ i + 1 ] = a [ i ] ;				  
	swapped = False					      	  }							    	    swapped = true ;					  
	end = end - 1					      	  if ( ! swapped ) break ;				    	  }							  
	for i in range ( end - 1 , start - 1 , - 1 ) :	      	  swapped = false ;					    	}							  
	    if ( a [ i ] > a [ i + 1 ] ) :		      	  -- end ;						    	if ( ( swapped == false ) ) break ;			  
		a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] 	  for ( int i = end - 1 ;				    	swapped = false ;					  
		swapped = True				      	  i >= start ;						    	end = end - 1 ;						  
	start = start + 1				      	  -- i ) {						    	for ( int i = end - 1 ;					  
							      	    if ( a [ i ] > a [ i + 1 ] ) {			    	i >= start ;						  
							      	      swap ( a [ i ] , a [ i + 1 ] ) ;			    	i -- ) {						  
							      	      swapped = true ;					    	  if ( ( a [ i ] > a [ i + 1 ] ) ) {			  
							      	    }							    	    a [ i ] = a [ i + 1 ] ;				  
							      	  }							    	    a [ i + 1 ] = a [ i ] ;				  
							      	  ++ start ;						    	    swapped = true ;					  
							      	}							    	  }							  
							      }								    	}							  
							      								    	start = start + 1 ;					  
							      								      }								  
							      								    }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1      COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1	    COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1	  COUNT_NUMBER_OF_WAYS_TO_PARTITION_A_SET_INTO_K_SUBSETS_1
--							      --							    --								  --
def countP ( n , k ) :					      int countP ( int n , int k ) {				    int countP ( int n , int k ) {				  script_not_found : None
    dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n  	int dp [ n + 1 ] [ k + 1 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( k +  
    for i in range ( n + 1 ) :				      	for ( int i = 0 ;					      for ( int j = 0 ;						  
	dp [ i ] [ 0 ] = 0				      	i <= n ;						      j < n + 1 ;						  
    for i in range ( k + 1 ) :				      	i ++ ) dp [ i ] [ 0 ] = 0 ;				      j ++ ) dp [ i ] [ 0 ] = 0 ;				  
	dp [ 0 ] [ k ] = 0				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( 1 , n + 1 ) :			      	i <= k ;						      i < k + 1 ;						  
	for j in range ( 1 , k + 1 ) :			      	i ++ ) dp [ 0 ] [ k ] = 0 ;				      i ++ ) dp [ 0 ] [ k ] = 0 ;				  
	    if ( j == 1 or i == j ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
		dp [ i ] [ j ] = 1			      	i <= n ;						      i <= n ;							  
	    else :					      	i ++ ) for ( int j = 1 ;				      i ++ ) {							  
		dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + d 	j <= i ;						    	for ( int j = 1 ;					  
    return dp [ n ] [ k ]				      	j ++ ) if ( j == 1 || i == j ) dp [ i ] [ j ] = 1 ;	    	j <= k ;						  
							      	else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] 	j ++ ) {						  
							      	return dp [ n ] [ k ] ;					    	  if ( ( j == 1 || i == j ) && dp [ i ] [ j ] == 1 ) dp [ 
							      }								    	  else dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i 
							      								    	}							  
							      								      }								  
							      								      return dp [ n ] [ k ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE			      LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE			    LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE			  LONGEST_INCREASING_ODD_EVEN_SUBSEQUENCE
--							      --							    --								  --
def longOddEvenIncSeq ( arr , n ) :			      int longOddEvenIncSeq ( int arr [ ] , int n ) {		    int longOddEvenIncSeq ( int * arr , int n ) {		  success : None
    lioes = list ( )					      	int lioes [ n ] ;					      int lioes [ n ] ;						  
    maxLen = 0						      	int maxLen = 0 ;					      int maxLen = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	lioes.append ( 1 )				      	i < n ;							      i < n ;							  
    i = 1						      	i ++ ) lioes [ i ] = 1 ;				      i ++ ) lioes [ i ] = 1 ;					  
    for i in range ( n ) :				      	for ( int i = 1 ;					      int i = 1 ;						  
	for j in range ( i ) :				      	i < n ;							      for ( int i = 0 ;						  
	    if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr  	i ++ ) for ( int j = 0 ;				      i < n ;							  
		lioes [ i ] = lioes [ j ] + 1		      	j < i ;							      i ++ ) {							  
    for i in range ( n ) :				      	j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j  	for ( int j = 0 ;					  
	if maxLen < lioes [ i ] :			      	for ( int i = 0 ;					    	j < i ;							  
	    maxLen = lioes [ i ]			      	i < n ;							    	j ++ ) {						  
    return maxLen					      	i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ;   	  if ( ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] 
							      	return maxLen ;						    	}							  
							      }								      }								  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) {							  
							      								    	if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ;	  
							      								      }								  
							      								      return maxLen ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE		      FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE		    FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE		  FIND_A_ROTATION_WITH_MAXIMUM_HAMMING_DISTANCE
--							      --							    --								  --
def maxHamming ( arr , n ) :				      int maxHamming ( int arr [ ] , int n ) {			    int maxHamming ( int * arr , int n ) {			  failure : #Results: 7, 10
    brr = [ 0 ] * ( 2 * n + 1 )				      	int brr [ 2 * n + 1 ] ;					      int * brr = new int [ 2 * n + 1 ] ;			  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	brr [ i ] = arr [ i ]				      	i < n ;							      i < n ;							  
    for i in range ( n ) :				      	i ++ ) brr [ i ] = arr [ i ] ;				      i ++ ) brr [ i ] = arr [ i ] ;				  
	brr [ n + i ] = arr [ i ]			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    maxHam = 0						      	i < n ;							      i < n ;							  
    for i in range ( 1 , n ) :				      	i ++ ) brr [ n + i ] = arr [ i ] ;			      i ++ ) brr [ n + i ] = arr [ i ] ;			  
	currHam = 0					      	int maxHam = 0 ;					      int maxHam = 0 ;						  
	k = 0						      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	for j in range ( i , i + n ) :			      	i < n ;							      i < n ;							  
	    if brr [ j ] != arr [ k ] :			      	i ++ ) {						      i ++ ) {							  
		currHam += 1				      	  int currHam = 0 ;					    	int currHam = 0 ;					  
		k = k + 1				      	  for ( int j = i , k = 0 ;				    	int k = 0 ;						  
	if currHam == n :				      	  j < ( i + n ) ;					    	for ( int j = i ;					  
	    return n					      	  j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ;  	j < i + n ;						  
	maxHam = max ( maxHam , currHam )		      	  if ( currHam == n ) return n ;			    	j ++ ) {						  
    return maxHam					      	  maxHam = max ( maxHam , currHam ) ;			    	  if ( brr [ j ] != arr [ k ] ) {			  
							      	}							    	    currHam ++ ;					  
							      	return maxHam ;						    	    k = k + 1 ;						  
							      }								    	  }							  
							      								    	}							  
							      								    	if ( currHam == n ) return n ;				  
							      								    	maxHam = max ( maxHam , currHam ) ;			  
							      								      }								  
							      								      return maxHam ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS			      SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS			    SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS				  SQUARES_OF_MATRIX_DIAGONAL_ELEMENTS
--							      --							    --								  --
def diagonalsquare ( mat , row , column ) :		      void diagonalsquare ( int mat [ ] [ MAX ] , int row , int col int getNum ( int * * nums , int num ) {			  script_not_found : None
    print ( "Diagonal one : " , end = "" )		      	cout << "Diagonal one : " ;				      int result = 0 ;						  
    for i in range ( 0 , row ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( 0 , column ) :			      	i < row ;						      i < num ;							  
	    if ( i == j ) :				      	i ++ ) {						      i ++ ) {							  
		print ( "{} ".format ( mat [ i ] [ j ] * mat  	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    print ( " \n\nDiagonal two : " , end = "" )		      	  j < column ;						    	j < num ;						  
    for i in range ( 0 , row ) :			      	  j ++ ) if ( i == j ) cout << mat [ i ] [ j ] * mat [ i ]  	j ++ ) {						  
	for j in range ( 0 , column ) :			      	}							    	  if ( ( i == j ) ) {					  
	    if ( i + j == column - 1 ) :		      	cout << " \n\nDiagonal two : " ;			    	    result += nums [ i ] [ j ] * nums [ i ] [ j ] ;	  
		print ( "{} ".format ( mat [ i ] [ j ] * mat  	for ( int i = 0 ;					    	  }							  
							      	i < row ;						    	}							  
							      	i ++ ) {						      }								  
							      	  for ( int j = 0 ;					      result += nums [ num - 1 ] ;				  
							      	  j < column ;						      for ( int i = 0 ;						  
							      	  j ++ ) if ( i + j == column - 1 ) cout << mat [ i ] [ j ]   i < num ;							  
							      	}							      i ++ ) {							  
							      }								    	for ( int j = 0 ;					  
							      								    	j < num ;						  
							      								    	j ++ ) {						  
							      								    	  if ( ( i + j == num - 1 ) ) {				  
							      								    	    result += nums [ i ] [ j ] * nums [ i ] [ j ] ;	  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX		      REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX		    REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX		  REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX
--							      --							    --								  --
def minRemovalsDP ( arr , n ) :				      int minRemovalsDP ( int arr [ ] , int n ) {		    int minRemovalsDP ( int * arr , int n ) {			  error : REMOVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_M
    longest_start = - 1					      	int longest_start = - 1 , longest_end = 0 ;		      int longest_start = - 1 ;					  AX.cpp: In function ‘int f_filled(int*, int)’: REM
    longest_end = 0					      	for ( int start = 0 ;					      int longest_end = 0 ;					  OVE_MINIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX.cpp:55:8
    for start in range ( n ) :				      	start < n ;						      for ( int start = 0 ;					  1: error: expected ‘)’ before ‘{’ token	 if
	min = sys.maxsize				      	start ++ ) {						      start < n ;						  ( ( end - start > longest_end - longest_start || l
	max = - sys.maxsize				      	  int min = INT_MAX , max = INT_MIN ;			      start ++ ) {						  ongest_start == - 1 ) {	    ~
	for end in range ( start , n ) :		      	  for ( int end = start ;				    	int min = INT_MAX ;					  
	    val = arr [ end ]				      	  end < n ;						    	int max = - INT_MAX ;					       ^~
	    if ( val < min ) :				      	  end ++ ) {						    	for ( int end = start ;					  					 ) REMOVE_MI
		min = val				      	    int val = arr [ end ] ;				    	end < n ;						  NIMUM_ELEMENTS_EITHER_SIDE_2MIN_MAX.cpp:59:5: erro
	    if ( val > max ) :				      	    if ( val < min ) min = val ;			    	end ++ ) {						  r: expected primary-expression before ‘}’ token
		max = val				      	    if ( val > max ) max = val ;			    	  int val = arr [ end ] ;				     }	    ^
	    if ( 2 * min <= max ) :			      	    if ( 2 * min <= max ) break ;			    	  if ( ( val < min ) ) min = val ;			  
		break					      	    if ( end - start > longest_end - longest_start || longe 	  if ( ( val > max ) ) max = val ;			  
	    if ( end - start > longest_end - longest_start or 	      longest_start = start ;				    	  if ( ( 2 * min <= max ) ) break ;			  
		longest_start = start			      	      longest_end = end ;				    	  if ( ( end - start > longest_end - longest_start || lon 
		longest_end = end			      	    }							    	    longest_start = start ;				  
    if ( longest_start == - 1 ) :			      	  }							    	    longest_end = end ;					  
	return n					      	}							    	  }							  
    return ( n - ( longest_end - longest_start + 1 ) )	      	if ( longest_start == - 1 ) return n ;			    	}							  
							      	return ( n - ( longest_end - longest_start + 1 ) ) ;	      }								  
							      }								      if ( ( longest_start == - 1 ) ) return n ;		  
							      								      return ( n - ( longest_end - longest_start + 1 ) ) ;	  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_COMMON_SUPERSEQUENCE_1				      SHORTEST_COMMON_SUPERSEQUENCE_1				    SHORTEST_COMMON_SUPERSEQUENCE_1				  SHORTEST_COMMON_SUPERSEQUENCE_1
--							      --							    --								  --
def superSeq ( X , Y , m , n ) :			      int superSeq ( char * X , char * Y , int m , int n ) {	    int superSeq ( string X , string Y , int m , int n ) {	  script_not_found : None
    dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ]	      	int dp [ m + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( m + 2 , vector < int > ( n +  
    for i in range ( m + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( n + 1 ) :			      	i <= m ;						      i < m + 1 ;						  
	    if ( not i ) : dp [ i ] [ j ] = j		      	i ++ ) {						      i ++ ) {							  
	    elif ( not j ) : dp [ i ] [ j ] = i		      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    elif ( X [ i - 1 ] == Y [ j - 1 ] ) :	      	  j <= n ;						    	j < n + 1 ;						  
		dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]   	  j ++ ) {						    	j ++ ) {						  
	    else : dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [  	    if ( ! i ) dp [ i ] [ j ] = j ;			    	  if ( ( ! i ) && ( ! j ) ) {				  
    return dp [ m ] [ n ]				      	    else if ( ! j ) dp [ i ] [ j ] = i ;		    	    dp [ i ] [ j ] = j ;				  
							      	    else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 	  }							  
							      	    else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp 	  else if ( ( ! j ) && ( X [ i - 1 ] == Y [ j - 1 ] ) ) { 
							      	  }							    	    dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;	  
							      	}							    	  }							  
							      	return dp [ m ] [ n ] ;					    	  else {						  
							      }								    	    dp [ i ] [ j ] = 1 + min < int > ( dp [ i - 1 ] [ j ] 
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								    }								  
							      								    return dp [ m ] [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE_1
--							      --							    --								  --
def maxSumWO3Consec ( n ) :				      int maxSumWO3Consec ( int n ) {				    int maxSumWO3Consec ( int n ) {				  script_not_found : None
    if ( sum [ n ] != - 1 ) :				      	if ( sum [ n ] != - 1 ) return sum [ n ] ;		      if ( ( sum [ n ] != - 1 ) ) return sum [ n ] ;		  
	return sum [ n ]				      	if ( n == 0 ) return sum [ n ] = 0 ;			      if ( ( n == 0 ) ) {					  
    if ( n == 0 ) :					      	if ( n == 1 ) return sum [ n ] = arr [ 0 ] ;		    	sum [ n ] = 0 ;						  
	sum [ n ] = 0					      	if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ;    	return sum [ n ] ;					  
	return sum [ n ]				      	return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) ,    }								  
    if ( n == 1 ) :					      }								      if ( ( n == 1 ) ) {					  
	sum [ n ] = arr [ 0 ]				      								    	sum [ n ] = arr [ 0 ] ;					  
	return sum [ n ]				      								    	return sum [ n ] ;					  
    if ( n == 2 ) :					      								      }								  
	sum [ n ] = arr [ 1 ] + arr [ 0 ]		      								      if ( ( n == 2 ) ) {					  
	return sum [ n ]				      								    	sum [ n ] = arr [ 1 ] + arr [ 0 ] ;			  
    sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSu 								    	return sum [ n ] ;					  
    return sum [ n ]					      								      }								  
							      								      sum [ n ] = max < int > ( max < int > ( maxSumWO3Consec ( n 
							      								      return sum [ n ] ;					  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N			      NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N			    NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N			  NUMBER_SUBSEQUENCES_STRING_DIVISIBLE_N
--							      --							    --								  --
def countDivisibleSubseq ( str , n ) :			      int countDivisibleSubseq ( string str , int n ) {		    int countDivisibleSubseq ( string str , int n ) {		  failure : #Results: 5, 10
    l = len ( str )					      	int len = str . length ( ) ;				      int l = str . length ( ) ;				  
    dp = [ [ 0 for x in range ( l ) ] for y in range ( n ) ]  	int dp [ len ] [ n ] ;					      vector < vector < int >> dp ( l , vector < int > ( n , 0 )  
    dp [ 0 ] [ ( ord ( str [ 0 ] ) - ord ( '0' ) ) % n ] += 1 	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int y = 0 ;						  
    for i in range ( 1 , l ) :				      	dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++ ;		      y < n ;							  
	dp [ i ] [ ( ord ( str [ i ] ) - ord ( '0' ) ) % n ]  	for ( int i = 1 ;					      y ++ ) dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++ ;		  
	for j in range ( n ) :				      	i < len ;						      for ( int i = 1 ;						  
	    dp [ i ] [ j ] += dp [ i - 1 ] [ j ]	      	i ++ ) {						      i < l ;							  
	    dp [ i ] [ ( j * 10 + ( ord ( str [ i ] ) - ord ( 	  dp [ i ] [ ( str [ i ] - '0' ) % n ] ++ ;		      i ++ ) {							  
    return dp [ l - 1 ] [ 0 ]				      	  for ( int j = 0 ;					    	dp [ i ] [ ( str [ i ] - '0' ) % n ] ++ ;		  
							      	  j < n ;						    	for ( int j = 0 ;					  
							      	  j ++ ) {						    	j < n ;							  
							      	    dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ;		    	j ++ ) {						  
							      	    dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp 	  dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ;		  
							      	  }							    	  dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp 
							      	}							    	}							  
							      	return dp [ len - 1 ] [ 0 ] ;				      }								  
							      }								      return dp [ l - 1 ] [ 0 ] ;				  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_K_MODULUS_ARRAY_ELEMENT				      FINDING_K_MODULUS_ARRAY_ELEMENT				    FINDING_K_MODULUS_ARRAY_ELEMENT				  FINDING_K_MODULUS_ARRAY_ELEMENT
--							      --							    --								  --
def printEqualModNumbers ( arr , n ) :			      void printEqualModNumbers ( int arr [ ] , int n ) {	    int sumOfDigits ( string str , int length ) {		  script_not_found : None
    arr.sort ( )					      	sort ( arr , arr + n ) ;				      string :: size_type pos = 0 ;				  
    d = arr [ n - 1 ] - arr [ 0 ]			      	int d = arr [ n - 1 ] - arr [ 0 ] ;			      for ( int i = 0 ;						  
    v = [ ]						      	vector < int > v ;					      i < length ;						  
    i = 1						      	for ( int i = 1 ;					      i ++ ) {							  
    while ( i * i <= d ) :				      	i * i <= d ;						    	pos = str . find ( '.' ) ;				  
	if ( d % i == 0 ) :				      	i ++ ) {						    	if ( pos != string :: npos ) {				  
	    v.append ( i )				      	  if ( d % i == 0 ) {					    	  pos = pos + 1 ;					  
	    if ( i != d / i ) :				      	    v . push_back ( i ) ;				    	}							  
		v.append ( d / i )			      	    if ( i != d / i ) v . push_back ( d / i ) ;		      }								  
	i += 1						      	  }							      for ( int i = 0 ;						  
    for i in range ( len ( v ) ) :			      	}							      i < length ;						  
	temp = arr [ 0 ] % v [ i ]			      	for ( int i = 0 ;					      i ++ ) {							  
	j = 1						      	i < v . size ( ) ;					    	pos = pos + 1 ;						  
	while ( j < n ) :				      	i ++ ) {						      }								  
	    if ( arr [ j ] % v [ i ] != temp ) :	      	  int temp = arr [ 0 ] % v [ i ] ;			      int sum = 0 ;						  
		break					      	  int j ;						      for ( int j = 0 ;						  
	    j += 1					      	  for ( j = 1 ;						      j < length ;						  
	if ( j == n ) :					      	  j < n ;						      j ++ ) {							  
	    print ( v [ i ] , end = " " )		      	  j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ;	    	if ( str [ pos ] == '.' ) {				  
							      	  if ( j == n ) cout << v [ i ] << " " ;		    	  sum += str [ pos ] ;					  
							      	}							    	  if ( ( pos != 0 ) && ( pos != length - 1 ) ) {	  
							      }								    	    sum += str [ pos + 1 ] ;				  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK	      CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK		    CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK		  CHECK_QUEUE_CAN_SORTED_ANOTHER_QUEUE_USING_STACK
--							      --							    --								  --
def checkSorted ( n , q ) :				      bool checkSorted ( int n , queue < int > & q ) {		    bool checkSorted ( int n , queue < int > q ) {		  script_not_found : None
    st = [ ]						      	stack < int > st ;					      stack < int > st ;					  
    expected = 1					      	int expected = 1 ;					      int expected = 1 ;					  
    fnt = None						      	int fnt ;						      int fnt ;							  
    while ( not q.empty ( ) ) :				      	while ( ! q . empty ( ) ) {				      while ( ( ! q . empty ( ) ) && ( fnt = q . top ( ) ) != exp 
	fnt = q.queue [ 0 ]				      	  fnt = q . front ( ) ;					    	fnt = q . top ( ) ;					  
	q.get ( )					      	  q . pop ( ) ;						    	q . pop ( ) ;						  
	if ( fnt == expected ) :			      	  if ( fnt == expected ) expected ++ ;			    	if ( ( fnt == expected ) ) {				  
	    expected += 1				      	  else {						    	  expected ++ ;						  
	else :						      	    if ( st . empty ( ) ) {				    	}							  
	    if ( len ( st ) == 0 ) :			      	      st . push ( fnt ) ;				    	else {							  
		st.append ( fnt )			      	    }							    	  if ( ( st . size ( ) == 0 ) ) st . push ( fnt ) ;	  
	    elif ( len ( st ) != 0 and st [ - 1 ] < fnt ) :   	    else if ( ! st . empty ( ) && st . top ( ) < fnt ) {    	  else if ( ( st . size ( ) != 0 ) && st . top ( ) < fnt  
		return False				      	      return false ;					    	  else st . push ( fnt ) ;				  
	    else :					      	    }							    	}							  
		st.append ( fnt )			      	    else st . push ( fnt ) ;				    	while ( ( st . size ( ) != 0 ) && st . top ( ) == expecte 
	while ( len ( st ) != 0 and st [ - 1 ] == expected )  	  }							    	  st . pop ( ) ;					  
	    st.pop ( )					      	  while ( ! st . empty ( ) && st . top ( ) == expected ) {  	  expected ++ ;						  
	    expected += 1				      	    st . pop ( ) ;					    	}							  
    if ( expected - 1 == n and len ( st ) == 0 ) :	      	    expected ++ ;					      }								  
	return True					      	  }							      if ( ( expected - 1 == n && st . size ( ) == 0 ) ) return t 
    return False					      	}							      return false ;						  
							      	if ( expected - 1 == n && st . empty ( ) ) return true ;    }								  
							      	return false ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_AREA_RECTANGLES_POSSIBLE_ARRAY			      SUM_AREA_RECTANGLES_POSSIBLE_ARRAY			    SUM_AREA_RECTANGLES_POSSIBLE_ARRAY				  SUM_AREA_RECTANGLES_POSSIBLE_ARRAY
--							      --							    --								  --
def MaxTotalRectangleArea ( a , n ) :			      int MaxTotalRectangleArea ( int a [ ] , int n ) {		    double MaxTotalRectangleArea ( double * a , int n ) {	  error : SUM_AREA_RECTANGLES_POSSIBLE_ARRAY.cpp: In
    a.sort ( reverse = True )				      	sort ( a , a + n , greater < int > ( ) ) ;		      sort ( a , a + n ) ;					   function ‘int main()’: SUM_AREA_RECTANGLES_POSSIB
    sum = 0						      	int sum = 0 ;						      double sum = 0 ;						  LE_ARRAY.cpp:68:21: error: cannot convert ‘__gnu_c
    flag = False					      	bool flag = false ;					      bool flag = false ;					  xx::__alloc_traits<std::allocator<int>, int>::valu
    len = 0						      	int len ;						      double len = 0 ;						  e_type*’ {aka ‘int*’} to ‘double*’	      if(f_f
    i = 0						      	for ( int i = 0 ;					      int i = 0 ;						  illed(&param0[i].front(),param1[i]) == f_gold(&par
    while ( i < n - 1 ) :				      	i < n ;							      while ( ( i < n - 1 ) ) {					  am0[i].front(),param1[i]))			  ^~
	if ( i != 0 ) :					      	i ++ ) {						    	if ( ( i != 0 ) ) i = i + 1 ;				  ~~~~~~~~~~~~~~~~ SUM_AREA_RECTANGLES_POSSIBLE_ARRA
	    i = i + 1					      	  if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 	if ( ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ]  Y.cpp:39:28: note:   initializing argument 1 of ‘d
	if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1  	    flag = true ;					    	  flag = true ;						  ouble f_filled(double*, int)’	 double f_filled ( d
	    flag = True					      	    len = a [ i + 1 ] ;					    	  len = a [ i + 1 ] ;					  ouble * a , int n ) {			   ~~~~~~~~~
	    len = a [ i + 1 ]				      	    i ++ ;						    	  i = i + 1 ;						  ^
	    i = i + 1					      	  }							    	}							  
	elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i +  	  else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 	else if ( ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 
	    sum = sum + a [ i + 1 ] * len		      	    sum = sum + a [ i + 1 ] * len ;			    	  sum = sum + a [ i + 1 ] * len ;			  
	    flag = False				      	    flag = false ;					    	  flag = false ;					  
	    i = i + 1					      	    i ++ ;						    	  i = i + 1 ;						  
    return sum						      	  }							    	}							  
							      	}							      }								  
							      	return sum ;						      return sum ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_KTH_CHARACTER_OF_DECRYPTED_STRING			      FIND_KTH_CHARACTER_OF_DECRYPTED_STRING			    FIND_KTH_CHARACTER_OF_DECRYPTED_STRING			  FIND_KTH_CHARACTER_OF_DECRYPTED_STRING
--							      --							    --								  --
def encodedChar ( str , k ) :				      char encodedChar ( string str , int k ) {			    char encodedChar ( string str , int k ) {			  script_not_found : None
    expand = ""						      	string expand = "" ;					      string expand ;						  
    freq = 0						      	string temp ;						      int freq ;						  
    i = 0						      	int freq = 0 ;						      int i = 0 ;						  
    while ( i < len ( str ) ) :				      	for ( int i = 0 ;					      while ( ( i < str . length ( ) ) ) {			  
	temp = ""					      	str [ i ] != '\0' ;					    	string temp ;						  
	freq = 0					      	) {							    	freq = 0 ;						  
	while ( i < len ( str ) and ord ( str [ i ] ) >= ord  	  temp = "" ;						    	while ( ( i < str . length ( ) ) && ( str [ i ] >= 'a' )  
	    temp += str [ i ]				      	  freq = 0 ;						    	  temp += str [ i ] ;					  
	    i += 1					      	  while ( str [ i ] >= 'a' && str [ i ] <= 'z' ) {	    	  i ++ ;						  
	while ( i < len ( str ) and ord ( str [ i ] ) >= ord  	    temp . push_back ( str [ i ] ) ;			    	}							  
	    freq = freq * 10 + ord ( str [ i ] ) - ord ( '0'  	    i ++ ;						    	while ( ( i < str . length ( ) ) && ( str [ i ] >= '1' )  
	    i += 1					      	  }							    	  freq = freq * 10 + str [ i ] - '0' ;			  
	for j in range ( 1 , freq + 1 , 1 ) :		      	  while ( str [ i ] >= '1' && str [ i ] <= '9' ) {	    	  i ++ ;						  
	    expand += temp				      	    freq = freq * 10 + str [ i ] - '0' ;		    	}							  
    if ( freq == 0 ) :					      	    i ++ ;						    	for ( int j = 1 ;					  
	expand += temp					      	  }							    	j <= freq ;						  
    return expand [ k - 1 ]				      	  for ( int j = 1 ;					    	j += 1 ) expand += temp ;				  
							      	  j <= freq ;						      }								  
							      	  j ++ ) expand . append ( temp ) ;			      if ( ( freq == 0 ) ) expand += temp ;			  
							      	}							      return expand [ k - 1 ] ;					  
							      	if ( freq == 0 ) expand . append ( temp ) ;		      return k * k ;						  
							      	return expand [ k - 1 ] ;				      return k * k ;						  
							      }								      return k * k * k * k * k * k * k * k * k * k * k * k * k *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GRAPHS_CYCLE_ODD_LENGTH				      CHECK_GRAPHS_CYCLE_ODD_LENGTH				    CHECK_GRAPHS_CYCLE_ODD_LENGTH				  CHECK_GRAPHS_CYCLE_ODD_LENGTH
--							      --							    --								  --
def containsOdd ( G , src ) :				      bool containsOdd ( int G [ ] [ V ] , int src ) {		    bool containsOdd ( int * * G , int src ) {			  script_not_found : None
    global V						      	int colorArr [ V ] ;					      int V = 0 ;						  
    colorArr = [ - 1 ] * V				      	for ( int i = 0 ;					      int colorArr [ V ] ;					  
    colorArr [ src ] = 1				      	i < V ;							      memset ( colorArr , - 1 , sizeof ( colorArr ) ) ;		  
    q = queue.Queue ( )					      	++ i ) colorArr [ i ] = - 1 ;				      colorArr [ src ] = 1 ;					  
    q.put ( src )					      	colorArr [ src ] = 1 ;					      queue < int > q ;						  
    while ( not q.empty ( ) ) :				      	queue < int > q ;					      q . push ( src ) ;					  
	u = q.get ( )					      	q . push ( src ) ;					      while ( ( ! q . empty ( ) ) ) {				  
	if ( G [ u ] [ u ] == 1 ) :			      	while ( ! q . empty ( ) ) {				    	int u = q . front ( ) ;					  
	    return True					      	  int u = q . front ( ) ;				    	if ( ( G [ u ] [ u ] == 1 ) ) return true ;		  
	for v in range ( V ) :				      	  q . pop ( ) ;						    	for ( int v = 0 ;					  
	    if ( G [ u ] [ v ] and colorArr [ v ] == - 1 ) :  	  if ( G [ u ] [ u ] == 1 ) return true ;		    	v < V ;							  
		colorArr [ v ] = 1 - colorArr [ u ]	      	  for ( int v = 0 ;					    	v ++ ) {						  
		q.put ( v )				      	  v < V ;						    	  if ( ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) ) {	  
	    elif ( G [ u ] [ v ] and colorArr [ v ] == colorA 	  ++ v ) {						    	    colorArr [ v ] = 1 - colorArr [ u ] ;		  
		return True				      	    if ( G [ u ] [ v ] && colorArr [ v ] == - 1 ) {	    	    q . pop ( ) ;					  
    return False					      	      colorArr [ v ] = 1 - colorArr [ u ] ;		    	  }							  
							      	      q . push ( v ) ;					    	  else if ( ( G [ u ] [ v ] && colorArr [ v ] == colorArr 
							      	    }							    	}							  
							      	    else if ( G [ u ] [ v ] && colorArr [ v ] == colorArr [   }								  
							      	  }							      return false ;						  
							      	}							    }								  
							      	return false ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS	      CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS	    CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS	  CENTER_ELEMENT_OF_MATRIX_EQUALS_SUMS_OF_HALF_DIAGONALS
--							      --							    --								  --
def HalfDiagonalSums ( mat , n ) :			      bool HalfDiagonalSums ( int mat [ ] [ MAX ] , int n ) {	    bool HalfDiagonalSums ( int * * mat , int n ) {		  script_not_found : None
    diag1_left = 0					      	int diag1_left = 0 , diag1_right = 0 ;			      int diag1_left = 0 ;					  
    diag1_right = 0					      	int diag2_left = 0 , diag2_right = 0 ;			      int diag1_right = 0 ;					  
    diag2_left = 0					      	for ( int i = 0 , j = n - 1 ;				      int diag2_left = 0 ;					  
    diag2_right = 0					      	i < n ;							      int diag2_right = 0 ;					  
    i = 0						      	i ++ , j -- ) {						      int i = 0 ;						  
    j = n - 1						      	  if ( i < n / 2 ) {					      int j = n - 1 ;						  
    while i < n :					      	    diag1_left += mat [ i ] [ i ] ;			      while ( i < n ) {						  
	if ( i < n // 2 ) :				      	    diag2_left += mat [ j ] [ i ] ;			    	if ( ( i < n / 2 ) ) {					  
	    diag1_left += mat [ i ] [ i ]		      	  }							    	  diag1_left += mat [ i ] [ i ] ;			  
	    diag2_left += mat [ j ] [ i ]		      	  else if ( i > n / 2 ) {				    	  diag2_left += mat [ j ] [ i ] ;			  
	elif ( i > n // 2 ) :				      	    diag1_right += mat [ i ] [ i ] ;			    	}							  
	    diag1_right += mat [ i ] [ i ]		      	    diag2_right += mat [ j ] [ i ] ;			    	else if ( ( i > n / 2 ) ) {				  
	    diag2_right += mat [ j ] [ i ]		      	  }							    	  diag1_right += mat [ i ] [ i ] ;			  
	i += 1						      	}							    	  diag2_right += mat [ j ] [ i ] ;			  
	j -= 1						      	return ( diag1_left == diag2_right && diag2_right == diag2_ 	}							  
    return ( diag1_left == diag2_right and diag2_right == dia }								    	i ++ ;							  
							      								    	j -- ;							  
							      								      }								  
							      								      return ( diag1_left == diag2_right && diag1_right == diag2_ 
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1	      DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1		    DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1		  DYNAMIC_PROGRAMMING_SET_10_0_1_KNAPSACK_PROBLEM_1
--							      --							    --								  --
def knapSack ( W , wt , val , n ) :			      int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {   int knapSack ( int W , int * wt , int * val , int n ) {	  script_not_found : None
    K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 	int i , w ;						      vector < vector < int >> K ( W + 1 , vector < int > ( n + 1 
    for i in range ( n + 1 ) :				      	int K [ n + 1 ] [ W + 1 ] ;				      for ( int i = 0 ;						  
	for w in range ( W + 1 ) :			      	for ( i = 0 ;						      i < n + 1 ;						  
	    if i == 0 or w == 0 :			      	i <= n ;						      i ++ ) {							  
		K [ i ] [ w ] = 0			      	i ++ ) {						    	for ( int w = 0 ;					  
	    elif wt [ i - 1 ] <= w :			      	  for ( w = 0 ;						    	w < W + 1 ;						  
		K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 	  w <= W ;						    	w ++ ) {						  
	    else :					      	  w ++ ) {						    	  if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;		  
		K [ i ] [ w ] = K [ i - 1 ] [ w ]	      	    if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;		    	  else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 
    return K [ n ] [ W ]				      	    else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 	  else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		  
							      	    else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		    	}							  
							      	  }							      }								  
							      	}							      return K [ n ] [ W ] ;					  
							      	return K [ n ] [ W ] ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME		      CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME		    CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME		  CONSTRUCT_LEXICOGRAPHICALLY_SMALLEST_PALINDROME
--							      --							    --								  --
def constructPalin ( string , l ) :			      string constructPalin ( string str , int len ) {		    string constructPalin ( string string , int l ) {		  script_not_found : None
    string = list ( string )				      	int i = 0 , j = len - 1 ;				      string = string ;						  
    i = - 1						      	for ( ;							      int i = - 1 ;						  
    j = l						      	i < j ;							      int j = l ;						  
    while i < j :					      	i ++ , j -- ) {						      while ( i < j ) {						  
	i += 1						      	  if ( str [ i ] == str [ j ] && str [ i ] != '*' ) continu 	i ++ ;							  
	j -= 1						      	  else if ( str [ i ] == str [ j ] && str [ i ] == '*' ) {  	j -- ;							  
	if ( string [ i ] == string [ j ] and string [ i ] != 	    str [ i ] = 'a' ;					    	if ( ( string [ i ] == string [ j ] && string [ i ] != '* 
	    continue					      	    str [ j ] = 'a' ;					    	else if ( ( string [ i ] == string [ j ] && string [ i ]  
	elif ( string [ i ] == string [ j ] and string [ i ]  	    continue ;						    	  string [ i ] = 'a' ;					  
	    string [ i ] = 'a'				      	  }							    	  string [ j ] = 'a' ;					  
	    string [ j ] = 'a'				      	  else if ( str [ i ] == '*' ) {			    	  continue ;						  
	    continue					      	    str [ i ] = str [ j ] ;				    	}							  
	elif string [ i ] == '*' :			      	    continue ;						    	else if ( string [ i ] == '*' ) {			  
	    string [ i ] = string [ j ]			      	  }							    	  string [ i ] = string [ j ] ;				  
	    continue					      	  else if ( str [ j ] == '*' ) {			    	  continue ;						  
	elif string [ j ] == '*' :			      	    str [ j ] = str [ i ] ;				    	}							  
	    string [ j ] = string [ i ]			      	    continue ;						    	else if ( string [ j ] == '*' ) {			  
	    continue					      	  }							    	  string [ j ] = string [ i ] ;				  
	print ( "Not Possible" )			      	  cout << "Not Possible" ;				    	  continue ;						  
	return ""					      	  return "" ;						    	}							  
    return ''.join ( string )				      	}							    	cout << "Not Possible" << endl ;			  
							      	return str ;						    	return "" ;						  
							      }								      }								  
							      								    }								  
							      								    return string ;						  
							      								    return " " + string + " " + string ;			  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string + " " + string ;			  
							      								    return " " + string + " " + string ;			  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string ;					  
							      								    return " " + string + " " + string ;			  
							      								    return " " + string + " " + string + " " + string ;		  
							      								    return " " + string + " " + string + " " + string + " " + str 
							      								    return " " + string ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_DIVISIBILITY_LARGE_NUMBER_999			      CHECK_DIVISIBILITY_LARGE_NUMBER_999			    CHECK_DIVISIBILITY_LARGE_NUMBER_999				  CHECK_DIVISIBILITY_LARGE_NUMBER_999
--							      --							    --								  --
def isDivisible999 ( num ) :				      bool isDivisible999 ( string num ) {			    bool isDivisible999 ( string num ) {			  failure : #Results: 8, 10
    n = len ( num ) ;					      	int n = num . length ( ) ;				      int n = num . length ( ) ;				  
    if ( n == 0 or num [ 0 ] == '0' ) :			      	if ( n == 0 && num [ 0 ] == '0' ) return true ;		      ;								  
	return true					      	if ( n % 3 == 1 ) num = "00" + num ;			      if ( ( n == 0 ) || ( num [ 0 ] == '0' ) ) return true ;	  
    if ( ( n % 3 ) == 1 ) :				      	if ( n % 3 == 2 ) num = "0" + num ;			      if ( ( ( n % 3 ) == 1 ) ) num = "00" + num ;		  
	num = "00" + num				      	int gSum = 0 ;						      if ( ( ( n % 3 ) == 2 ) ) num = "0" + num ;		  
    if ( ( n % 3 ) == 2 ) :				      	for ( int i = 0 ;					      int gSum = 0 ;						  
	num = "0" + num					      	i < n ;							      for ( int i = 0 ;						  
    gSum = 0						      	i ++ ) {						      i < n ;							  
    for i in range ( 0 , n , 3 ) :			      	  int group = 0 ;					      i += 3 ) {						  
	group = 0					      	  group += ( num [ i ++ ] - '0' ) * 100 ;		    	int group = 0 ;						  
	group += ( ord ( num [ i ] ) - 48 ) * 100	      	  group += ( num [ i ++ ] - '0' ) * 10 ;		    	group += ( ( int ) num [ i ] - 48 ) * 100 ;		  
	group += ( ord ( num [ i + 1 ] ) - 48 ) * 10	      	  group += num [ i ] - '0' ;				    	group += ( ( int ) num [ i + 1 ] - 48 ) * 10 ;		  
	group += ( ord ( num [ i + 2 ] ) - 48 )		      	  gSum += group ;					    	group += ( ( int ) num [ i + 2 ] - 48 ) ;		  
	gSum += group					      	}							    	gSum += group ;						  
    if ( gSum > 1000 ) :				      	if ( gSum > 1000 ) {					      }								  
	num = str ( gSum )				      	  num = to_string ( gSum ) ;				      if ( ( gSum > 1000 ) ) {					  
	n = len ( num )					      	  n = num . length ( ) ;				    	num = to_string ( gSum ) ;				  
	gSum = isDivisible999 ( num )			      	  gSum = isDivisible999 ( num ) ;			    	n = num . length ( ) ;					  
    return ( gSum == 999 )				      	}							    	gSum = isDivisible999 ( num ) ;				  
							      	return ( gSum == 999 ) ;				      }								  
							      }								      return ( gSum == 999 ) ;					  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_MAXIMUM_GCD_ARRAY				      FIND_PAIR_MAXIMUM_GCD_ARRAY				    FIND_PAIR_MAXIMUM_GCD_ARRAY					  FIND_PAIR_MAXIMUM_GCD_ARRAY
--							      --							    --								  --
def findMaxGCD ( arr , n ) :				      int findMaxGCD ( int arr [ ] , int n ) {			    int findMaxGCD ( int * arr , int n ) {			  error : FIND_PAIR_MAXIMUM_GCD_ARRAY.cpp: In functi
    high = 0						      	int high = 0 ;						      int high = 0 ;						  on ‘int f_filled(int*, int)’: FIND_PAIR_MAXIMUM_GC
    i = 0						      	for ( int i = 0 ;					      int i = 0 ;						  D_ARRAY.cpp:64:1: warning: no return statement in
    while i < n :					      	i < n ;							      while ( i < n ) {						  function returning non-void [-Wreturn-type]  }  ^
	high = max ( high , arr [ i ] )			      	i ++ ) high = max ( high , arr [ i ] ) ;		    	high = max < int > ( high , arr [ i ] ) ;		  FIND_PAIR_MAXIMUM_GCD_ARRAY.cpp: At global scope:
	i = i + 1					      	int divisors [ high + 1 ] = {				    	i = i + 1 ;						  FIND_PAIR_MAXIMUM_GCD_ARRAY.cpp:65:1: error: ‘i’ d
    divisors = [ 0 ] * ( high + 1 )			      	  0 }							      }								  oes not name a type  i = high ;  ^ FIND_PAIR_MAXIM
    i = 0						      	  ;							      vector < int > divisors ( high + 1 , 0 ) ;		  UM_GCD_ARRAY.cpp:66:1: error: expected unqualified
    while i < n :					      	  for ( int i = 0 ;					      i = 0 ;							  -id before ‘while’  while ( i >= 1 ) {  ^~~~~ FIND
	j = 1						      	  i < n ;						      while ( i < n ) {						  _PAIR_MAXIMUM_GCD_ARRAY.cpp:70:1: error: expected
	while j <= math.sqrt ( arr [ i ] ) :		      	  i ++ ) {						    	int j = 1 ;						  unqualified-id before ‘return’  return 1 ;  ^~~~~~
	    if ( arr [ i ] % j == 0 ) :			      	    for ( int j = 1 ;					    	while ( j <= sqrt ( arr [ i ] ) ) {			   FIND_PAIR_MAXIMUM_GCD_ARRAY.cpp:71:1: error: expe
		divisors [ j ] = divisors [ j ] + 1	      	    j <= sqrt ( arr [ i ] ) ;				    	  if ( ( arr [ i ] % j == 0 ) ) {			  cted declaration before ‘}’ token  }	^ FIND_PAIR_
		if ( j != arr [ i ] / j ) :		      	    j ++ ) {						    	    divisors [ j ] = divisors [ j ] + 1 ;		  MAXIMUM_GCD_ARRAY.cpp: In function ‘int f_gold(int
		    divisors [ arr [ i ] / j ] = divisors [ a 	      if ( arr [ i ] % j == 0 ) {			    	    if ( ( j != arr [ i ] / j ) ) {			  *, int)’: FIND_PAIR_MAXIMUM_GCD_ARRAY.cpp:38:3: wa
			+ 1				      		divisors [ j ] ++ ;				    	      divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / rning: control reaches end of non-void function [-
	    j = j + 1					      		if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j  	      + 1 ;						  Wreturn-type]	   }	^
	i = i + 1					      	      }							    	    }							  
    i = high						      	    }							    	  }							  
    while i >= 1 :					      	  }							    	}							  
	if ( divisors [ i ] > 1 ) :			      	  for ( int i = high ;					    	j = j + 1 ;						  
	    return i					      	  i >= 1 ;						      }								  
	i = i - 1					      	  i -- ) if ( divisors [ i ] > 1 ) return i ;		      i = i + 1 ;						  
    return 1						      	}							    }								  
							      								    i = high ;							  
							      								    while ( i >= 1 ) {						  
							      								      if ( ( divisors [ i ] > 1 ) ) return i ;			  
							      								      i = i - 1 ;						  
							      								    }								  
							      								    return 1 ;							  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE    MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE    MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE	  MAXIMUM_SUBSEQUENCE_SUM_SUCH_THAT_NO_THREE_ARE_CONSECUTIVE
--							      --							    --								  --
def maxSumWO3Consec ( arr , n ) :			      int maxSumWO3Consec ( int arr [ ] , int n ) {		    int maxSumWO3Consec ( int * arr , int n ) {			  success : None
    sum = [ 0 for k in range ( n ) ]			      	int sum [ n ] ;						      int sum [ n ] ;						  
    if n >= 1 :						      	if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ;			      for ( int k = 0 ;						  
	sum [ 0 ] = arr [ 0 ]				      	if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ;	      k < n ;							  
    if n >= 2 :						      	if ( n > 2 ) sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ]    k ++ ) sum [ k ] = 0 ;					  
	sum [ 1 ] = arr [ 0 ] + arr [ 1 ]		      	for ( int i = 3 ;					      if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ;			  
    if n > 2 :						      	i < n ;							      if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ;		  
	sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 	i ++ ) sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2    if ( n > 2 ) sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ]  
    for i in range ( 3 , n ) :				      	return sum [ n - 1 ] ;					      for ( int i = 3 ;						  
	sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] }								      i < n ;							  
    return sum [ n - 1 ]				      								      i ++ ) sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2  
							      								      return sum [ n - 1 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1		      CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1		    CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1		  CHECK_REVERSING_SUB_ARRAY_MAKE_ARRAY_SORTED_1
--							      --							    --								  --
def checkReverse ( arr , n ) :				      bool checkReverse ( int arr [ ] , int n ) {		    bool checkReverse ( int * arr , int n ) {			  failure : #Results: 9, 10
    if ( n == 1 ) :					      	if ( n == 1 ) return true ;				      if ( ( n == 1 ) ) return true ;				  
	return True					      	int i ;							      int i = 1 ;						  
    i = 1						      	for ( i = 1 ;						      for ( i = 1 ;						  
    for i in range ( 1 , n ) :				      	i < n && arr [ i - 1 ] < arr [ i ] ;			      i < n ;							  
	if arr [ i - 1 ] < arr [ i ] :			      	i ++ ) ;						      i ++ ) if ( arr [ i - 1 ] < arr [ i ] ) if ( ( i == n ) ) r 
	    if ( i == n ) :				      	if ( i == n ) return true ;				      int j = i ;						  
		return True				      	int j = i ;						      while ( ( arr [ j ] < arr [ j - 1 ] ) ) if ( ( i > 1 ) && ( 
    j = i						      	while ( arr [ j ] < arr [ j - 1 ] ) {			      if ( ( j == n ) ) return true ;				  
    while ( arr [ j ] < arr [ j - 1 ] ) :		      	  if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ;    int k = j ;						  
	if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) :	      	  j ++ ;						      if ( ( arr [ k ] < arr [ i - 1 ] ) ) return false ;	  
	    return False				      	}							      while ( ( k > 1 ) && ( k < n ) ) if ( ( arr [ k ] < arr [ k 
	j += 1						      	if ( j == n ) return true ;				      k ++ ;							  
    if ( j == n ) :					      	int k = j ;						      return true ;						  
	return True					      	if ( arr [ k ] < arr [ i - 1 ] ) return false ;		      return n * n ;						  
    k = j						      	while ( k > 1 && k < n ) {				      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
    if ( arr [ k ] < arr [ i - 1 ] ) :			      	  if ( arr [ k ] < arr [ k - 1 ] ) return false ;	    }								  
	return False					      	  k ++ ;						    								  
    while ( k > 1 and k < n ) :				      	}							    								  
	if ( arr [ k ] < arr [ k - 1 ] ) :		      	return true ;						    								  
	    return False				      }								    								  
	k += 1						      								    								  
    return True						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B	      DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B	    DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B	  DISCRETE_LOGARITHM_FIND_INTEGER_K_AK_CONGRUENT_MODULO_B
--							      --							    --								  --
def discreteLogarithm ( a , b , m ) :			      int discreteLogarithm ( int a , int b , int m ) {		    int discreteLogarithm ( int a , int b , int m ) {		  failure : #Results: 7, 10
    n = int ( math.sqrt ( m ) + 1 )			      	int n = ( int ) sqrt ( m ) + 1 ;			      int n = ( int ) ( sqrt ( m ) + 1 ) ;			  
    an = 1						      	int an = 1 ;						      int an = 1 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	an = ( an * a ) % m				      	i < n ;							      i < n ;							  
    value = [ 0 ] * m					      	++ i ) an = ( an * a ) % m ;				      i ++ ) an = ( an * a ) % m ;				  
    cur = an						      	unordered_map < int , int > value ;			      int value [ m ] ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 , cur = an ;				      int cur = an ;						  
	if ( value [ cur ] == 0 ) :			      	i <= n ;						      for ( int i = 1 ;						  
	    value [ cur ] = i				      	++ i ) {						      i <= n ;							  
	cur = ( cur * an ) % m				      	  if ( ! value [ cur ] ) value [ cur ] = i ;		      i ++ ) {							  
    cur = b						      	  cur = ( cur * an ) % m ;				    	if ( ( value [ cur ] == 0 ) ) value [ cur ] = i ;	  
    for i in range ( n + 1 ) :				      	}							    	cur = ( cur * an ) % m ;				  
	if ( value [ cur ] > 0 ) :			      	for ( int i = 0 , cur = b ;				      }								  
	    ans = value [ cur ] * n - i			      	i <= n ;						      cur = b ;							  
	    if ( ans < m ) :				      	++ i ) {						      for ( int i = 0 ;						  
		return ans				      	  if ( value [ cur ] ) {				      i < n + 1 ;						  
	cur = ( cur * a ) % m				      	    int ans = value [ cur ] * n - i ;			      i ++ ) {							  
    return - 1						      	    if ( ans < m ) return ans ;				    	if ( ( value [ cur ] > 0 ) ) {				  
							      	  }							    	  int ans = value [ cur ] * n - i ;			  
							      	  cur = ( cur * a ) % m ;				    	  if ( ( ans < m ) ) return ans ;			  
							      	}							    	}							  
							      	return - 1 ;						    	cur = ( cur * a ) % m ;					  
							      }								      }								  
							      								      return - 1 ;						  
							      								      return a * a ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2	      MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2	    MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2	  MINIMUM_NUMBER_OF_JUMPS_TO_REACH_END_OF_A_GIVEN_ARRAY_2
--							      --							    --								  --
def minJumps ( arr , n ) :				      int minJumps ( int arr [ ] , int n ) {			    int minJumps ( int * arr , int n ) {			  failure : #Results: 7, 10
    jumps = [ 0 for i in range ( n ) ]			      	int * jumps = new int [ n ] ;				      int * jumps = new int [ n ] ;				  
    for i in range ( n - 2 , - 1 , - 1 ) :		      	int min ;						      for ( int i = 0 ;						  
	if ( arr [ i ] == 0 ) :				      	jumps [ n - 1 ] = 0 ;					      i < n ;							  
	    jumps [ i ] = float ( 'inf' )		      	for ( int i = n - 2 ;					      i ++ ) {							  
	elif ( arr [ i ] >= n - i - 1 ) :		      	i >= 0 ;						    	if ( ( arr [ i ] == 0 ) ) jumps [ i ] = INT_MAX ;	  
	    jumps [ i ] = 1				      	i -- ) {						    	else if ( ( arr [ i ] >= n - i - 1 ) ) jumps [ i ] = 1 ;  
	else :						      	  if ( arr [ i ] == 0 ) jumps [ i ] = INT_MAX ;		    	else {							  
	    min = float ( 'inf' )			      	  else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ;	    	  int min = INT_MAX ;					  
	    for j in range ( i + 1 , n ) :		      	  else {						    	  for ( int j = i + 1 ;					  
		if ( j <= arr [ i ] + i ) :		      	    min = INT_MAX ;					    	  j < n ;						  
		    if ( min > jumps [ j ] ) :		      	    for ( int j = i + 1 ;				    	  j ++ ) {						  
			min = jumps [ j ]		      	    j < n && j <= arr [ i ] + i ;			    	    if ( ( j <= arr [ i ] + i ) ) if ( ( min > jumps [ j  
	    if ( min != float ( 'inf' ) ) :		      	    j ++ ) {						    	  }							  
		jumps [ i ] = min + 1			      	      if ( min > jumps [ j ] ) min = jumps [ j ] ;	    	  if ( ( min != INT_MAX ) ) jumps [ i ] = min + 1 ;	  
	    else :					      	    }							    	  else jumps [ i ] = min ;				  
		jumps [ i ] = min			      	    if ( min != INT_MAX ) jumps [ i ] = min + 1 ;	    	}							  
    return jumps [ 0 ]					      	    else jumps [ i ] = min ;				      }								  
							      	  }							      return jumps [ 0 ] ;					  
							      	}							    }								  
							      	return jumps [ 0 ] ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LEIBNIZ_HARMONIC_TRIANGLE				      LEIBNIZ_HARMONIC_TRIANGLE					    LEIBNIZ_HARMONIC_TRIANGLE					  LEIBNIZ_HARMONIC_TRIANGLE
--							      --							    --								  --
def LeibnizHarmonicTriangle ( n ) :			      void LeibnizHarmonicTriangle ( int n ) {			    int LeibnizHarmonicTriangle ( int n ) {			  script_not_found : None
    C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 	int C [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> C ( n + 1 , vector < int > ( n + 1 
    for i in range ( 0 , n + 1 ) :			      	for ( int i = 0 ;					      for ( int y = 0 ;						  
	for j in range ( 0 , min ( i , n ) + 1 ) :	      	i <= n ;						      y <= n ;							  
	    if ( j == 0 or j == i ) :			      	i ++ ) {						      y ++ ) {							  
		C [ i ] [ j ] = 1			      	  for ( int j = 0 ;					    	for ( int i = 0 ;					  
	    else :					      	  j <= min ( i , n ) ;					    	i <= n ;						  
		C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ 	  j ++ ) {						    	i ++ ) {						  
    for i in range ( 1 , n + 1 ) :			      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  for ( int j = 0 ;					  
	for j in range ( 1 , i + 1 ) :			      	    else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1  	  j <= min ( i , n ) ;					  
	    print ( "1/" , end = "" )			      	  }							    	  j ++ ) {						  
	    print ( i * C [ i - 1 ] [ j - 1 ] , end = " " )   	}							    	    if ( ( j == 0 || j == i ) ) C [ i ] [ j ] = 1 ;	  
	print ( )					      	for ( int i = 1 ;					    	    else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i  
							      	i <= n ;						    	  }							  
							      	i ++ ) {						    	}							  
							      	  for ( int j = 1 ;					      }								  
							      	  j <= i ;						      for ( int i = 1 ;						  
							      	  j ++ ) cout << "1/" << i * C [ i - 1 ] [ j - 1 ] << " " ;   i <= n ;							  
							      	  cout << endl ;					      i ++ ) {							  
							      	}							    	for ( int j = 1 ;					  
							      }								    	j <= i ;						  
							      								    	j ++ ) {						  
							      								    	  cout << "1/" ;					  
							      								    	  cout << i * C [ i - 1 ] [ j - 1 ] << " " ;		  
							      								    	}							  
							      								    	cout << endl ;						  
							      								      }								  
							      								      return n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K		      COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K		    COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K			  COUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K
--							      --							    --								  --
def numOfIncSubseqOfSizeK ( arr , n , k ) :		      int numOfIncSubseqOfSizeK ( int arr [ ] , int n , int k ) {   int numOfIncSubseqOfSizeK ( int * arr , int n , int k ) {	  error : free(): invalid pointer /bin/bash: line 1:
    dp = [ [ 0 for i in range ( n ) ] for i in range ( k ) ]  	int dp [ k ] [ n ] , sum = 0 ;				      vector < vector < int >> dp ( n , vector < int > ( k , 0 )   1848669 Aborted		   (core dumped) ./C
    for i in range ( n ) :				      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int i = 0 ;						  OUNT_NUMBER_INCREASING_SUBSEQUENCES_SIZE_K_cpp
	dp [ 0 ] [ i ] = 1				      	for ( int i = 0 ;					      i < n ;							  
    for l in range ( 1 , k ) :				      	i < n ;							      i ++ ) dp [ 0 ] [ i ] = 1 ;				  
	for i in range ( l , n ) :			      	i ++ ) dp [ 0 ] [ i ] = 1 ;				      for ( int l = 1 ;						  
	    dp [ l ] [ i ] = 0				      	for ( int l = 1 ;					      l < k ;							  
	    for j in range ( l - 1 , i ) :		      	l < k ;							      l ++ ) for ( int i = l ;					  
		if ( arr [ j ] < arr [ i ] ) :		      	l ++ ) {						      i < n ;							  
		    dp [ l ] [ i ] += dp [ l - 1 ] [ j ]      	  for ( int i = l ;					      i ++ ) {							  
    Sum = 0						      	  i < n ;						    	dp [ l ] [ i ] = 0 ;					  
    for i in range ( k - 1 , n ) :			      	  i ++ ) {						    	for ( int j = l - 1 ;					  
	Sum += dp [ k - 1 ] [ i ]			      	    dp [ l ] [ i ] = 0 ;				    	j < i ;							  
    return Sum						      	    for ( int j = l - 1 ;				    	j ++ ) if ( ( arr [ j ] < arr [ i ] ) ) dp [ l ] [ i ] += 
							      	    j < i ;						      }								  
							      	    j ++ ) {						      int Sum = 0 ;						  
							      	      if ( arr [ j ] < arr [ i ] ) dp [ l ] [ i ] += dp [ l   for ( int i = k - 1 ;					  
							      	    }							      i < n ;							  
							      	  }							      i ++ ) Sum += dp [ k - 1 ] [ i ] ;			  
							      	}							      return Sum ;						  
							      	for ( int i = k - 1 ;					      return n * n ;						  
							      	i < n ;							      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      	i ++ ) sum += dp [ k - 1 ] [ i ] ;			    }								  
							      	return sum ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_ GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_ GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_ GIVEN_TWO_SORTED_ARRAYS_NUMBER_X_FIND_PAIR_WHOSE_SUM_CLOSEST_
--							      --							    --								  --
def printClosest ( ar1 , ar2 , m , n , x ) :		      void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n int printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n  script_not_found : None
    diff = sys.maxsize					      	int diff = INT_MAX ;					      int diff = INT_MAX ;					  
    l = 0						      	int res_l , res_r ;					      int l = 0 ;						  
    r = n - 1						      	int l = 0 , r = n - 1 ;					      int r = n - 1 ;						  
    while ( l < m and r >= 0 ) :			      	while ( l < m && r >= 0 ) {				      while ( ( l < m ) && ( r >= 0 ) ) {			  
	if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff :	      	  if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) {	    	if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) {	  
	    res_l = l					      	    res_l = l ;						    	  int res_l = l ;					  
	    res_r = r					      	    res_r = r ;						    	  int res_r = r ;					  
	    diff = abs ( ar1 [ l ] + ar2 [ r ] - x )	      	    diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) ;		    	  diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) ;		  
	if ar1 [ l ] + ar2 [ r ] > x :			      	  }							    	}							  
	    r = r - 1					      	  if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ;		    	if ( ar1 [ l ] + ar2 [ r ] > x ) r = r - 1 ;		  
	else :						      	  else l ++ ;						    	else l = l + 1 ;					  
	    l = l + 1					      	}							      }								  
    print ( "The closest pair is [" , ar1 [ res_l ] , "," , a 	cout << "The closest pair is [" << ar1 [ res_l ] << ", " <<   cout << "The closest pair is [" << ar1 [ res_l ] << "," <<  
							      }								      return 0 ;						  
							      								      return ar1 [ m ] * ar1 ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PLACED_DECREASING_OR
--							      --							    --								  --
def bitonicGenerator ( arr , n ) :			      void bitonicGenerator ( int arr [ ] , int n ) {		    int bitonicGenerator ( int * arr , int n ) {		  error : munmap_chunk(): invalid pointer /bin/bash:
    evenArr = [ ]					      	vector < int > evenArr ;				      int evenArr [ n ] ;					   line 1: 1849202 Aborted		   (core dum
    oddArr = [ ]					      	vector < int > oddArr ;					      int oddArr [ n ] ;					  ped) ./SORT_EVEN_PLACED_ELEMENTS_INCREASING_ODD_PL
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  ACED_DECREASING_ORDER_cpp
	if ( ( i % 2 ) == 0 ) :				      	i < n ;							      i < n ;							  
	    evenArr.append ( arr [ i ] )		      	i ++ ) {						      i ++ ) {							  
	else :						      	  if ( ! ( i % 2 ) ) evenArr . push_back ( arr [ i ] ) ;    	if ( ( ( i % 2 ) == 0 ) ) evenArr [ i ] = arr [ i ] ;	  
	    oddArr.append ( arr [ i ] )			      	  else oddArr . push_back ( arr [ i ] ) ;		    	else oddArr [ i ] = arr [ i ] ;				  
    evenArr = sorted ( evenArr )			      	}							      }								  
    oddArr = sorted ( oddArr )				      	sort ( evenArr . begin ( ) , evenArr . end ( ) ) ;	      std :: sort ( evenArr , evenArr + n ) ;			  
    oddArr = oddArr [ : : - 1 ]				      	sort ( oddArr . begin ( ) , oddArr . end ( ) , greater < in   std :: sort ( oddArr , oddArr + n ) ;			  
    i = 0						      	int i = 0 ;						      oddArr [ n - 1 ] = 0 ;					  
    for j in range ( len ( evenArr ) ) :		      	for ( int j = 0 ;					      int i = 0 ;						  
	arr [ i ] = evenArr [ j ]			      	j < evenArr . size ( ) ;				      for ( int j = 0 ;						  
	i += 1						      	j ++ ) arr [ i ++ ] = evenArr [ j ] ;			      j < evenArr [ 0 ] ;					  
    for j in range ( len ( oddArr ) ) :			      	for ( int j = 0 ;					      j ++ ) {							  
	arr [ i ] = oddArr [ j ]			      	j < oddArr . size ( ) ;					    	arr [ i ] = evenArr [ j ] ;				  
	i += 1						      	j ++ ) arr [ i ++ ] = oddArr [ j ] ;			    	i ++ ;							  
							      }								      }								  
							      								      for ( int j = 0 ;						  
							      								      j < oddArr [ 0 ] ;					  
							      								      j ++ ) {							  
							      								    	arr [ i ] = oddArr [ j ] ;				  
							      								    	i ++ ;							  
							      								      }								  
							      								      return i ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_ FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_ FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_ FIND_LENGTH_LONGEST_SUBSEQUENCE_ONE_STRING_SUBSTRING_ANOTHER_
--							      --							    --								  --
def maxSubsequenceSubstring ( x , y , n , m ) :		      int maxSubsequenceSubstring ( char x [ ] , char y [ ] , int n int maxSubsequenceSubstring ( string x , string y , int n , i script_not_found : None
    dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX  	int dp [ MAX ] [ MAX ] ;				      vector < vector < int >> dp ( MAX , vector < int > ( MAX ,  
    for i in range ( 1 , m + 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( 1 , n + 1 ) :			      	i <= m ;						      i < MAX ;							  
	    if ( x [ j - 1 ] == y [ i - 1 ] ) :		      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
		dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]   	j <= n ;						    	for ( int j = 1 ;					  
	    else :					      	j ++ ) dp [ i ] [ j ] = 0 ;				    	j <= m ;						  
		dp [ i ] [ j ] = dp [ i ] [ j - 1 ]	      	for ( int i = 1 ;					    	j ++ ) {						  
    ans = 0						      	i <= m ;						    	  if ( ( x [ j - 1 ] == y [ i - 1 ] ) && ( x [ j - 1 ] == 
    for i in range ( 1 , m + 1 ) :			      	i ++ ) {						    	  else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		  
	ans = max ( ans , dp [ i ] [ n ] )		      	  for ( int j = 1 ;					    	}							  
    return ans						      	  j <= n ;						      }								  
							      	  j ++ ) {						      int ans = 0 ;						  
							      	    if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 +    for ( int i = 1 ;						  
							      	    else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		      i <= m ;							  
							      	  }							      i ++ ) ans = max ( ans , dp [ i ] [ n ] ) ;		  
							      	}							      return ans ;						  
							      	int ans = 0 ;						    }								  
							      	for ( int i = 1 ;					    								  
							      	i <= m ;						    								  
							      	i ++ ) ans = max ( ans , dp [ i ] [ n ] ) ;		    								  
							      	return ans ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT			      CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT			    CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT				  CHECK_LARGE_NUMBER_DIVISIBLE_13_NOT
--							      --							    --								  --
def checkDivisibility ( num ) :				      bool checkDivisibility ( string num ) {			    bool checkDivisibility ( string num ) {			  success : None
    length = len ( num )				      	int length = num . size ( ) ;				      int length = num . length ( ) ;				  
    if ( length == 1 and num [ 0 ] == '0' ) :		      	if ( length == 1 && num [ 0 ] == '0' ) return true ;	      if ( ( length == 1 ) && ( num [ 0 ] == '0' ) ) return true  
	return True					      	if ( length % 3 == 1 ) {				      if ( ( length % 3 == 1 ) ) {				  
    if ( length % 3 == 1 ) :				      	  num += "00" ;						    	num = num + "00" ;					  
	num = str ( num ) + "00"			      	  length += 2 ;						    	length += 2 ;						  
	length += 2					      	}							      }								  
    elif ( length % 3 == 2 ) :				      	else if ( length % 3 == 2 ) {				      else if ( ( length % 3 == 2 ) ) {				  
	num = str ( num ) + "0"				      	  num += "0" ;						    	num = num + "0" ;					  
	length += 1					      	  length += 1 ;						    	length += 1 ;						  
    sum = 0						      	}							      }								  
    p = 1						      	int sum = 0 , p = 1 ;					      int sum = 0 ;						  
    for i in range ( length - 1 , - 1 , - 1 ) :		      	for ( int i = length - 1 ;				      int p = 1 ;						  
	group = 0					      	i >= 0 ;						      for ( int i = length - 1 ;				  
	group += ord ( num [ i ] ) - ord ( '0' )	      	i -- ) {						      i >= 0 ;							  
	i -= 1						      	  int group = 0 ;					      i -- ) {							  
	group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10     	  group += num [ i -- ] - '0' ;				    	int group = 0 ;						  
	i -= 1						      	  group += ( num [ i -- ] - '0' ) * 10 ;		    	group += num [ i ] - '0' ;				  
	group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100    	  group += ( num [ i ] - '0' ) * 100 ;			    	i -- ;							  
	sum = sum + group * p				      	  sum = sum + group * p ;				    	group += ( num [ i ] - '0' ) * 10 ;			  
	p *= ( - 1 )					      	  p *= ( - 1 ) ;					    	i -- ;							  
    sum = abs ( sum )					      	}							    	group += ( num [ i ] - '0' ) * 100 ;			  
    return ( sum % 13 == 0 )				      	sum = abs ( sum ) ;					    	sum = sum + group * p ;					  
							      	return ( sum % 13 == 0 ) ;				    	p *= ( - 1 ) ;						  
							      }								      }								  
							      								      sum = abs ( sum ) ;					  
							      								      return ( sum % 13 == 0 ) ;				  
							      								      return num . length ( ) > 0 && num [ 0 ] == '0' && num [ 1  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN FIND_THE_MAXIMUM_ELEMENT_IN_AN_ARRAY_WHICH_IS_FIRST_INCREASIN
--							      --							    --								  --
def findMaximum ( arr , low , high ) :			      int findMaximum ( int arr [ ] , int low , int high ) {	    int findMaximum ( int * arr , int low , int high ) {	  script_not_found : None
    if low == high :					      	if ( low == high ) return arr [ low ] ;			      if ( low == high ) return arr [ low ] ;			  
	return arr [ low ]				      	if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) r   if ( high == low + 1 && arr [ low ] >= arr [ high ] ) retur 
    if high == low + 1 and arr [ low ] >= arr [ high ] :      	if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) re   if ( high == low + 1 && arr [ low ] < arr [ high ] ) return 
	return arr [ low ]				      	int mid = ( low + high ) / 2 ;				      int mid = ( low + high ) / 2 ;				  
    if high == low + 1 and arr [ low ] < arr [ high ] :	      	if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ m   if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ m 
	return arr [ high ]				      	if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ m   if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ m 
    mid = ( low + high ) // 2				      	else return findMaximum ( arr , mid + 1 , high ) ;	      else return findMaximum ( arr , mid + 1 , high ) ;	  
    if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [  }								      return low * low ;					  
	return arr [ mid ]				      								      return low * low ;					  
    if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [  								    }								  
	return findMaximum ( arr , low , mid - 1 )	      								    								  
    else :						      								    								  
	return findMaximum ( arr , mid + 1 , high )	      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS		      THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS		    THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS		  THIRD_LARGEST_ELEMENT_ARRAY_DISTINCT_ELEMENTS
--							      --							    --								  --
def thirdLargest ( arr , arr_size ) :			      void thirdLargest ( int arr [ ] , int arr_size ) {	    int thirdLargest ( int * arr , int arrSize ) {		  script_not_found : None
    if ( arr_size < 3 ) :				      	if ( arr_size < 3 ) {					      if ( ( arrSize < 3 ) ) {					  
	print ( " Invalid Input " )			      	  printf ( " Invalid Input " ) ;			    	cout << " Invalid Input " << endl ;			  
	return						      	  return ;						    	return 0 ;						  
    first = arr [ 0 ]					      	}							      }								  
    for i in range ( 1 , arr_size ) :			      	int first = arr [ 0 ] ;					      int first = arr [ 0 ] ;					  
	if ( arr [ i ] > first ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	    first = arr [ i ]				      	i < arr_size ;						      i < arrSize ;						  
    second = - sys.maxsize				      	i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ;	      i ++ ) {							  
    for i in range ( 0 , arr_size ) :			      	int second = INT_MIN ;					    	if ( ( arr [ i ] > first ) ) first = arr [ i ] ;	  
	if ( arr [ i ] > second and arr [ i ] < first ) :     	for ( int i = 0 ;					      }								  
	    second = arr [ i ]				      	i < arr_size ;						      int second = - INT_MAX ;					  
    third = - sys.maxsize				      	i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) secon   for ( int i = 0 ;						  
    for i in range ( 0 , arr_size ) :			      	int third = INT_MIN ;					      i < arrSize ;						  
	if ( arr [ i ] > third and arr [ i ] < second ) :     	for ( int i = 0 ;					      i ++ ) {							  
	    third = arr [ i ]				      	i < arr_size ;						    	if ( ( arr [ i ] > second && arr [ i ] < first ) ) second 
    print ( "The Third Largest" , "element is" , third )      	i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third   }								  
							      	printf ( "The third Largest element is %d\n" , third ) ;      int third = - INT_MAX ;					  
							      }								      for ( int i = 0 ;						  
							      								      i < arrSize ;						  
							      								      i ++ ) {							  
							      								    	if ( ( arr [ i ] > third && arr [ i ] < second ) ) third  
							      								      }								  
							      								      cout << "The Third Largest" << " element is" << third << en 
							      								      return 0 ;						  
							      								      return arrSize * arrSize ;				  
							      								      return arrSize * arrSize * arrSize * arrSize * arrSize * ar 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN			      PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN			    PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN			  PRINT_SHORTEST_PATH_PRINT_STRING_SCREEN
--							      --							    --								  --
def printPath ( str ) :					      void printPath ( string str ) {				    int getNum ( string str ) {					  script_not_found : None
    i = 0						      	int i = 0 ;						      int result = 0 ;						  
    curX = 0						      	int curX = 0 , curY = 0 ;				      int i = 0 ;						  
    curY = 0						      	while ( i < str . length ( ) ) {			      int curX = 0 ;						  
    while ( i < len ( str ) ) :				      	  int nextX = ( str [ i ] - 'A' ) / 5 ;			      int curY = 0 ;						  
	nextX = int ( ( ord ( str [ i ] ) - ord ( 'A' ) ) / 5 	  int nextY = ( str [ i ] - 'B' + 1 ) % 5 ;		      while ( ( i < str . length ( ) ) && ( i < str . length ( )  
	nextY = ( ord ( str [ i ] ) - ord ( 'B' ) + 1 ) % 5   	  while ( curX > nextX ) {				    	int nextX = ( int ) ( ( str [ i ] - 'A' ) / 5 ) ;	  
	while ( curX > nextX ) :			      	    cout << "Move Up" << endl ;				    	int nextY = ( str [ i ] - 'B' + 1 ) % 5 ;		  
	    print ( "Move Up" )				      	    curX -- ;						    	while ( ( curX > nextX ) ) {				  
	    curX -= 1					      	  }							    	  cout << "Move Up" << endl ;				  
	while ( curY > nextY ) :			      	  while ( curY > nextY ) {				    	  curX -- ;						  
	    print ( "Move Left" )			      	    cout << "Move Left" << endl ;			    	}							  
	    curY -= 1					      	    curY -- ;						    	while ( ( curY > nextY ) ) {				  
	while ( curX < nextX ) :			      	  }							    	  cout << "Move Left" << endl ;				  
	    print ( "Move Down" )			      	  while ( curX < nextX ) {				    	  curY -- ;						  
	    curX += 1					      	    cout << "Move Down" << endl ;			    	}							  
	while ( curY < nextY ) :			      	    curX ++ ;						    	while ( ( curX < nextX ) ) {				  
	    print ( "Move Right" )			      	  }							    	  cout << "Move Down" << endl ;				  
	    curY += 1					      	  while ( curY < nextY ) {				    	  curX ++ ;						  
	print ( "Press OK" )				      	    cout << "Move Right" << endl ;			    	}							  
	i += 1						      	    curY ++ ;						    	while ( ( curY < nextY ) ) {				  
							      	  }							    	  cout << "Move Right" << endl ;			  
							      	  cout << "Press OK" << endl ;				    	  curY ++ ;						  
							      	  i ++ ;						    	}							  
							      	}							    	cout << "Press OK" << endl ;				  
							      }								    	i ++ ;							  
							      								      }								  
							      								      return result ;						  
							      								      return result * result ;					  
							      								      return result * result * result * result * result * result  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE		      FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE			    FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE			  FIND_SUM_NODES_GIVEN_PERFECT_BINARY_TREE
--							      --							    --								  --
def SumNodes ( l ) :					      int sumNodes ( int l ) {					    int SumNodes ( int l ) {					  script_not_found : None
    leafNodeCount = pow ( 2 , l - 1 )			      	int leafNodeCount = pow ( 2 , l - 1 ) ;			      int leafNodeCount = pow < int > ( 2 , l - 1 ) ;		  
    vec = [ [ ] for i in range ( l ) ]			      	vector < int > vec [ l ] ;				      vector < vector < int >> vec ( l , vector < int > ( l , 0 ) 
    for i in range ( 1 , leafNodeCount + 1 ) :		      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	vec [ l - 1 ].append ( i )			      	i <= leafNodeCount ;					      i <= leafNodeCount ;					  
    for i in range ( l - 2 , - 1 , - 1 ) :		      	i ++ ) vec [ l - 1 ] . push_back ( i ) ;		      i ++ ) vec [ l - 1 ] . push_back ( i ) ;			  
	k = 0						      	for ( int i = l - 2 ;					      for ( int i = l - 2 ;					  
	while ( k < len ( vec [ i + 1 ] ) - 1 ) :	      	i >= 0 ;						      i >= 0 ;							  
	    vec [ i ].append ( vec [ i + 1 ] [ k ] + vec [ i  	i -- ) {						      i -- ) {							  
	    k += 2					      	  int k = 0 ;						    	int k = 0 ;						  
    Sum = 0						      	  while ( k < vec [ i + 1 ] . size ( ) - 1 ) {		    	while ( ( k < vec [ i + 1 ] . size ( ) - 1 ) ) {	  
    for i in range ( l ) :				      	    vec [ i ] . push_back ( vec [ i + 1 ] [ k ] + vec [ i + 	  vec [ i ] . push_back ( vec [ i + 1 ] [ k ] + vec [ i + 
	for j in range ( len ( vec [ i ] ) ) :		      	    k += 2 ;						    	  k += 2 ;						  
	    Sum += vec [ i ] [ j ]			      	  }							    	}							  
    return Sum						      	}							      }								  
							      	int sum = 0 ;						      int Sum = 0 ;						  
							      	for ( int i = 0 ;					      for ( int i = 0 ;						  
							      	i < l ;							      i < l ;							  
							      	i ++ ) {						      i ++ ) {							  
							      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
							      	  j < vec [ i ] . size ( ) ;				    	j < vec [ i ] . size ( ) ;				  
							      	  j ++ ) sum += vec [ i ] [ j ] ;			    	j ++ ) Sum += vec [ i ] [ j ] ;				  
							      	}							      }								  
							      	return sum ;						      return Sum ;						  
							      }								      return l * l ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1		      FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1		    FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1			  FIND_PAIR_WITH_GREATEST_PRODUCT_IN_ARRAY_1
--							      --							    --								  --
def findGreatest ( arr , n ) :				      int findGreatest ( int arr [ ] , int n ) {		    int findGreatest ( int * arr , int n ) {			  script_not_found : None
    m = dict ( )					      	unordered_map < int , int > m ;				      map < int , int > m ;					  
    for i in arr :					      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	m [ i ] = m.get ( i , 0 ) + 1			      	i < n ;							      i < n ;							  
    arr = sorted ( arr )				      	i ++ ) m [ arr [ i ] ] ++ ;				      i ++ ) m [ i ] = m . count ( i ) + 1 ;			  
    for i in range ( n - 1 , 0 , - 1 ) :		      	sort ( arr , arr + n ) ;				      sort ( arr , arr + n ) ;					  
	j = 0						      	for ( int i = n - 1 ;					      for ( int i = n - 1 ;					  
	while ( j < i and arr [ j ] <= sqrt ( arr [ i ] ) ) : 	i > 1 ;							      i > 0 ;							  
	    if ( arr [ i ] % arr [ j ] == 0 ) :		      	i -- ) {						      i -- ) {							  
		result = arr [ i ] // arr [ j ]		      	  for ( int j = 0 ;					    	int j = 0 ;						  
		if ( result != arr [ j ] and ( result in m.ke 	  j < i && arr [ j ] <= sqrt ( arr [ i ] ) ;		    	while ( ( j < i ) && ( arr [ j ] <= sqrt ( arr [ i ] ) )  
		    return arr [ i ]			      	  j ++ ) {						    	  if ( ( arr [ i ] % arr [ j ] == 0 ) ) {		  
		elif ( result == arr [ j ] and ( result in m. 	    if ( arr [ i ] % arr [ j ] == 0 ) {			    	    int result = arr [ i ] / arr [ j ] ;		  
		    return arr [ i ]			      	      int result = arr [ i ] / arr [ j ] ;		    	    if ( ( result != arr [ j ] ) && ( m . count ( result  
	    j += 1					      	      if ( result != arr [ j ] && m [ result ] > 0 ) return 	    else if ( ( result == arr [ j ] ) && ( m . count ( re 
    return - 1						      	      else if ( result == arr [ j ] && m [ result ] > 1 ) r 	  }							  
							      	    }							    	  j ++ ;						  
							      	  }							    	}							  
							      	}							      }								  
							      	return - 1 ;						      return - 1 ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_SUBARRAY_SUM_DIVISIBLE_K			      LONGEST_SUBARRAY_SUM_DIVISIBLE_K				    LONGEST_SUBARRAY_SUM_DIVISIBLE_K				  LONGEST_SUBARRAY_SUM_DIVISIBLE_K
--							      --							    --								  --
def longSubarrWthSumDivByK ( arr , n , k ) :		      int longSubarrWthSumDivByK ( int arr [ ] , int n , int k ) {  int longSubarrWthSumDivByK ( int * arr , int n , int k ) {	  failure : #Results: 3, 10
    um = { i : 0 for i in range ( 8 ) }			      	unordered_map < int , int > um ;			      unordered_map < int , int > um ;				  
    mod_arr = [ 0 for i in range ( n ) ]		      	int mod_arr [ n ] , max = 0 ;				      for ( int i = 0 ;						  
    max = 0						      	int curr_sum = 0 ;					      i < 8 ;							  
    curr_sum = 0					      	for ( int i = 0 ;					      i ++ ) um [ i ] = 0 ;					  
    for i in range ( n ) :				      	i < n ;							      int modArr [ n ] ;					  
	curr_sum += arr [ i ]				      	i ++ ) {						      int max = 0 ;						  
	mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k	      	  curr_sum += arr [ i ] ;				      int currSum = 0 ;						  
    for i in range ( n ) :				      	  mod_arr [ i ] = ( ( curr_sum % k ) + k ) % k ;	      for ( int i = 0 ;						  
	if ( mod_arr [ i ] == 0 ) :			      	}							      i < n ;							  
	    max = i + 1					      	for ( int i = 0 ;					      i ++ ) {							  
	elif ( mod_arr [ i ] in um ) :			      	i < n ;							    	currSum += arr [ i ] ;					  
	    um [ mod_arr [ i ] ] = i			      	i ++ ) {						    	modArr [ i ] = ( ( currSum % k ) + k ) % k ;		  
	else :						      	  if ( mod_arr [ i ] == 0 ) max = i + 1 ;		      }								  
	    if ( max < ( i - um [ mod_arr [ i ] ] ) ) :	      	  else if ( um . find ( mod_arr [ i ] ) == um . end ( ) ) u   for ( int i = 0 ;						  
		max = i - um [ mod_arr [ i ] ]		      	  else if ( max < ( i - um [ mod_arr [ i ] ] ) ) max = i -    i < n ;							  
    return max						      	}							      i ++ ) {							  
							      	return max ;						    	if ( ( modArr [ i ] == 0 ) ) max = i + 1 ;		  
							      }								    	else if ( ( modArr [ i ] < um . count ( modArr [ i ] ) )  
							      								      }								  
							      								      return max ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE CLUSTERINGPARTITIONING_AN_ARRAY_SUCH_THAT_SUM_OF_SQUARE_DIFFE
--							      --							    --								  --
def minCost ( a , n , k ) :				      int minCost ( int a [ ] , int n , int k ) {		    int minCost ( int a [ ] , int n , int k ) {			  script_not_found : None
    dp = [ [ inf for i in range ( k + 1 ) ] for j in range (  	int dp [ n + 1 ] [ k + 1 ] ;				      vector < vector < int >> dp ( k + 1 , vector < int > ( n +  
    dp [ 0 ] [ 0 ] = 0					      	for ( int i = 0 ;					      for ( int j = 0 ;						  
    for i in range ( 1 , n + 1 ) :			      	i <= n ;						      j < n + 1 ;						  
	for j in range ( 1 , k + 1 ) :			      	i ++ ) for ( int j = 0 ;				      j ++ ) dp [ 0 ] [ 0 ] = 0 ;				  
	    for m in range ( i - 1 , - 1 , - 1 ) :	      	j <= k ;						      for ( int i = 1 ;						  
		dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [  	j ++ ) dp [ i ] [ j ] = inf ;				      i <= n ;							  
    return dp [ n ] [ k ]				      	dp [ 0 ] [ 0 ] = 0 ;					      i ++ ) for ( int j = 1 ;					  
							      	for ( int i = 1 ;					      j <= k ;							  
							      	i <= n ;						      j ++ ) for ( int m = i - 1 ;				  
							      	i ++ ) for ( int j = 1 ;				      m >= 0 ;							  
							      	j <= k ;						      m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j 
							      	j ++ ) for ( int m = i - 1 ;				      return dp [ n ] [ k ] ;					  
							      	m >= 0 ;						    }								  
							      	m -- ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j 								  
							      	return dp [ n ] [ k ] ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER		      GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER		    GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER			  GENERATE_PYTHAGORAS_TRIPLET_SINGLE_INTEGER
--							      --							    --								  --
def evaluate ( n ) :					      void evaluate ( long long int n ) {			    int evaluate ( int n ) {					  script_not_found : None
    if ( n == 1 or n == 2 ) :				      	if ( n == 1 || n == 2 ) printf ( "No Pythagoras Triplet exi   if ( ( n == 1 ) || ( n == 2 ) ) cout << "No Pythagoras" <<  
	print ( "No Pythagoras" + " Triplet exists" )	      	else if ( n % 2 == 0 ) {				      else if ( ( n % 2 == 0 ) ) {				  
    elif ( n % 2 == 0 ) :				      	  long long int var = 1LL * n * n / 4 ;			    	double var = n * n / 4 ;				  
	var = n * n / 4					      	  printf ( "Pythagoras Triplets exist i.e. " ) ;	    	cout << "Pythagoras Triplets" << " exist i.e. " << endl ; 
	print ( "Pythagoras Triplets" + " exist i.e." , end = 	  printf ( "%lld %lld %lld" , n , var - 1 , var + 1 ) ;	    	cout << to_string ( n ) << " " << to_string ( var - 1 ) < 
	print ( int ( n ) , "" , int ( var - 1 ) , "" , int ( 	}							      }								  
    elif ( n % 2 != 0 ) :				      	else if ( n % 2 != 0 ) {				      else if ( ( n % 2 != 0 ) ) {				  
	var = n * n + 1					      	  long long int var = 1LL * n * n + 1 ;			    	double var = n * n + 1 ;				  
	print ( "Pythagoras Triplets " + "exist i.e." , end = 	  printf ( "Pythagoras Triplets exist i.e. " ) ;	    	cout << "Pythagoras Triplets " << "exist i.e. " << endl ; 
	print ( int ( n ) , "" , int ( var / 2 - 1 ) , "" , i 	  printf ( "%lld %lld %lld" , n , var / 2 - 1 , var / 2 ) ; 	cout << to_string ( n ) << " " << to_string ( var / 2 - 1 
							      	}							      }								  
							      }								      return n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MERGING_INTERVALS					      MERGING_INTERVALS						    MERGING_INTERVALS						  MERGING_INTERVALS
--							      --							    --								  --
def mergeIntervals ( arr ) :				      void mergeIntervals ( Interval arr [ ] , int n ) {	    void mergeIntervals ( vector < int > arr ) {		  script_not_found : None
    arr.sort ( key = lambda x : x [ 0 ] )		      	sort ( arr , arr + n , mycomp ) ;			      sort ( arr . begin ( ) , arr . end ( ) ) ;		  
    m = [ ]						      	int index = 0 ;						      vector < pair < int , int >> m ;				  
    s = - 10000						      	for ( int i = 1 ;					      int s = - 10000 ;						  
    max = - 100000					      	i < n ;							      int max = - 100000 ;					  
    for i in range ( len ( arr ) ) :			      	i ++ ) {						      for ( int i = 0 ;						  
	a = arr [ i ]					      	  if ( arr [ index ] . e >= arr [ i ] . s ) {		      i < arr . size ( ) ;					  
	if a [ 0 ] > max :				      	    arr [ index ] . e = max ( arr [ index ] . e , arr [ i ]   i ++ ) {							  
	    if i != 0 :					      	    arr [ index ] . s = min ( arr [ index ] . s , arr [ i ] 	int a [ 2 ] ;						  
		m.append ( [ s , max ] )		      	  }							    	if ( arr [ i ] > max ) {				  
	    max = a [ 1 ]				      	  else {						    	  if ( i != 0 ) m . push_back ( make_pair ( s , max ) ) ; 
	    s = a [ 0 ]					      	    arr [ index ] = arr [ i ] ;				    	  max = arr [ 1 ] ;					  
	else :						      	    index ++ ;						    	  s = arr [ 0 ] ;					  
	    if a [ 1 ] >= max :				      	  }							    	}							  
		max = a [ 1 ]				      	}							    	else {							  
    if max != - 100000 and [ s , max ] not in m :	      	cout << "\n The Merged Intervals are: " ;		    	  if ( arr [ 1 ] >= max ) max = arr [ 1 ] ;		  
	m.append ( [ s , max ] )			      	for ( int i = 0 ;					    	}							  
    print ( "The Merged Intervals are :" , end = " " )	      	i <= index ;						      }								  
    for i in range ( len ( m ) ) :			      	i ++ ) cout << "[" << arr [ i ] . s << ", " << arr [ i ] .    if ( max != - 100000 && make_pair ( s , max ) != m . size ( 
	print ( m [ i ] , end = " " )			      }								      cout << "The Merged Intervals are :" << endl ;		  
							      								      for ( int i = 0 ;						  
							      								      i < m . size ( ) ;					  
							      								      i ++ ) cout << m [ i ] << " " ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K	      MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K	    MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K	  MINIMUM_COST_MAKE_LONGEST_COMMON_SUBSEQUENCE_LENGTH_K
--							      --							    --								  --
def solve ( X , Y , l , r , k , dp ) :			      int solve ( char X [ ] , char Y [ ] , int l , int r , int k , int solve ( string X , string Y , int l , int r , int k , vec script_not_found : None
    if k == 0 :						      	if ( ! k ) return 0 ;					      if ( k == 0 ) return 0 ;					  
	return 0					      	if ( l < 0 | r < 0 ) return 1e9 ;			      if ( l < 0 || r < 0 ) return 1000000000 ;			  
    if l < 0 or r < 0 :					      	if ( dp [ l ] [ r ] [ k ] != - 1 ) return dp [ l ] [ r ] [    if ( dp [ l ] [ r ] [ k ] != - 1 ) return dp [ l ] [ r ] [  
	return 1000000000				      	int cost = ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ;	      int cost = ( ( X [ l ] - 'a' ) ^ ( Y [ r ] - 'a' ) ) ;	  
    if dp [ l ] [ r ] [ k ] != - 1 :			      	return dp [ l ] [ r ] [ k ] = min ( {			      dp [ l ] [ r ] [ k ] = min < int > ( cost + solve ( X , Y , 
	return dp [ l ] [ r ] [ k ]			      	  cost + solve ( X , Y , l - 1 , r - 1 , k - 1 , dp ) , sol   return dp [ l ] [ r ] [ k ] ;				  
    cost = ( ( ord ( X [ l ] ) - ord ( 'a' ) ) ^ ( ord ( Y [  	  ) ;							      return l * l ;						  
    dp [ l ] [ r ] [ k ] = min ( [ cost + solve ( X , Y , l - 	}							    }								  
    return dp [ l ] [ r ] [ k ]				      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1		      DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1			    DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1			  DYNAMIC_PROGRAMMING_SET_5_EDIT_DISTANCE_1
--							      --							    --								  --
def editDistDP ( str1 , str2 , m , n ) :		      int editDistDP ( string str1 , string str2 , int m , int n )  int editDistDP ( string str1 , string str2 , int m , int n )  script_not_found : None
    dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m  	int dp [ m + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( m +  
    for i in range ( m + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( n + 1 ) :			      	i <= m ;						      i < m + 1 ;						  
	    if i == 0 :					      	i ++ ) {						      i ++ ) {							  
		dp [ i ] [ j ] = j			      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    elif j == 0 :				      	  j <= n ;						    	j < n + 1 ;						  
		dp [ i ] [ j ] = i			      	  j ++ ) {						    	j ++ ) {						  
	    elif str1 [ i - 1 ] == str2 [ j - 1 ] :	      	    if ( i == 0 ) dp [ i ] [ j ] = j ;			    	  if ( i == 0 ) dp [ i ] [ j ] = j ;			  
		dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]	      	    else if ( j == 0 ) dp [ i ] [ j ] = i ;		    	  else if ( j == 0 ) dp [ i ] [ j ] = i ;		  
	    else :					      	    else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ 	  else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ 
		dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] 	    else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp 	  else dp [ i ] [ j ] = 1 + min ( dp [ i ] [ j - 1 ] , dp 
    return dp [ m ] [ n ]				      	  }							    	}							  
							      	}							      }								  
							      	return dp [ m ] [ n ] ;					      return dp [ m ] [ n ] ;					  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7			      CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7			    CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7			  CHECK_WHETHER_LARGE_NUMBER_DIVISIBLE_7
--							      --							    --								  --
def isdivisible7 ( num ) :				      int isdivisible7 ( char num [ ] ) {			    bool isdivisible7 ( string num ) {				  script_not_found : None
    n = len ( num )					      	int n = strlen ( num ) , gSum ;				      int n = num . length ( ) ;				  
    if ( n == 0 and num [ 0 ] == '\n' ) :		      	if ( n == 0 && num [ 0 ] == '\n' ) return 1 ;		      if ( ( n == 0 ) && ( num [ 0 ] == '\n' ) ) return 1 ;	  
	return 1					      	if ( n % 3 == 1 ) {					      if ( ( n % 3 == 1 ) ) {					  
    if ( n % 3 == 1 ) :					      	  strcat ( num , "00" ) ;				    	num = num + "00" ;					  
	num = str ( num ) + "00"			      	  n += 2 ;						    	n += 2 ;						  
	n += 2						      	}							      }								  
    elif ( n % 3 == 2 ) :				      	else if ( n % 3 == 2 ) {				      else if ( ( n % 3 == 2 ) ) {				  
	num = str ( num ) + "0"				      	  strcat ( num , "0" ) ;				    	num = num + "0" ;					  
	n += 1						      	  n ++ ;						    	n += 1 ;						  
    GSum = 0						      	}							      }								  
    p = 1						      	int i , GSum = 0 , p = 1 ;				      int GSum = 0 ;						  
    for i in range ( n - 1 , - 1 , - 1 ) :		      	for ( i = n - 1 ;					      int p = 1 ;						  
	group = 0					      	i >= 0 ;						      for ( int i = n - 1 ;					  
	group += ord ( num [ i ] ) - ord ( '0' )	      	i -- ) {						      i >= 0 ;							  
	i -= 1						      	  int group = 0 ;					      i -- ) {							  
	group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10     	  group += num [ i -- ] - '0' ;				    	int group = 0 ;						  
	i -= 1						      	  group += ( num [ i -- ] - '0' ) * 10 ;		    	group += num [ i ] - '0' ;				  
	group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100    	  group += ( num [ i ] - '0' ) * 100 ;			    	i -- ;							  
	GSum = GSum + group * p				      	  gSum = gSum + group * p ;				    	group += ( num [ i ] - '0' ) * 10 ;			  
	p *= ( - 1 )					      	  p *= ( - 1 ) ;					    	i -- ;							  
    return ( GSum % 7 == 0 )				      	}							    	group += ( num [ i ] - '0' ) * 100 ;			  
							      	return ( gSum % 7 == 0 ) ;				    	GSum = GSum + group * p ;				  
							      }								    	p *= ( - 1 ) ;						  
							      								      }								  
							      								      return ( GSum % 7 == 0 ) ;				  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1		      FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1			    FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1			  FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1
--							      --							    --								  --
def isRectangle ( matrix ) :				      bool isRectangle ( const vector < vector < int >> & matrix )  bool isRectangle ( vector < vector < int >> & matrix ) {	  error : FIND_RECTANGLE_BINARY_MATRIX_CORNERS_1_1.c
    rows = len ( matrix )				      	int rows = matrix . size ( ) ;				      int rows = matrix . size ( ) ;				  pp:66:1: error: expected unqualified-id before ‘re
    if ( rows == 0 ) :					      	if ( rows == 0 ) return false ;				      if ( ( rows == 0 ) ) return false ;			  turn’	 return false ;	 ^~~~~~ FIND_RECTANGLE_BINAR
	return False					      	int columns = matrix [ 0 ] . size ( ) ;			      int columns = matrix [ 0 ] . size ( ) ;			  Y_MATRIX_CORNERS_1_1.cpp:67:1: error: expected dec
    columns = len ( matrix [ 0 ] )			      	unordered_map < int , unordered_set < int >> table ;	      set < int > table ;					  laration before ‘}’ token  }	^ FIND_RECTANGLE_BIN
    table = { }						      	for ( int i = 0 ;					      for ( int i = 0 ;						  ARY_MATRIX_CORNERS_1_1.cpp: In function ‘bool f_fi
    for i in range ( rows ) :				      	i < rows ;						      i < rows ;						  lled(std::vector<std::vector<int> >&)’: FIND_RECTA
	for j in range ( columns - 1 ) :		      	++ i ) {						      i ++ ) {							  NGLE_BINARY_MATRIX_CORNERS_1_1.cpp:65:1: warning:
	    for k in range ( j + 1 , columns ) :	      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  control reaches end of non-void function [-Wreturn
		if ( matrix [ i ] [ j ] == 1 and matrix [ i ] 	  j < columns - 1 ;					    	j < columns - 1 ;					  -type]  }  ^
		    if ( j in table and k in table [ j ] ) :  	  ++ j ) {						    	j ++ ) {						  
			return True			      	    for ( int k = j + 1 ;				    	  for ( int k = j + 1 ;					  
		    if ( k in table and j in table [ k ] ) :  	    k < columns ;					    	  k < columns ;						  
			return True			      	    ++ k ) {						    	  k ++ ) {						  
		    if j not in table :			      	      if ( matrix [ i ] [ j ] == 1 && matrix [ i ] [ k ] == 	    if ( ( matrix [ i ] [ j ] == 1 ) && ( matrix [ i ] [  
			table [ j ] = set ( )		      		if ( table . find ( j ) != table . end ( ) && table 	      if ( ( j < 0 ) && ( k < 0 ) ) return true ;	  
		    if k not in table :			      		table [ j ] . insert ( k ) ;			    	      if ( ( j < 0 ) && ( k < 0 ) ) return true ;	  
			table [ k ] = set ( )		      	      }							    	      if ( j != 0 ) table . insert ( j ) ;		  
		    table [ j ].add ( k )		      	    }							    	      if ( k != 0 ) table . insert ( k ) ;		  
		    table [ k ].add ( j )		      	  }							    	      table . insert ( j ) ;				  
    return False					      	}							    	    }							  
							      	return false ;						    	  }							  
							      }								    	}							  
							      								      }								  
							      								    }								  
							      								    return false ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1	      LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1	    LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1	  LONGEST_EVEN_LENGTH_SUBSTRING_SUM_FIRST_SECOND_HALF_1
--							      --							    --								  --
def findLength ( string ) :				      int findLength ( char * str ) {				    int findLength ( string string ) {				  script_not_found : None
    n = len ( string )					      	int n = strlen ( str ) ;				      int n = string . length ( ) ;				  
    maxlen = 0						      	int maxlen = 0 ;					      int len = 0 ;						  
    Sum = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] 	int sum [ n ] [ n ] ;					      vector < vector < int >> Sum ( n , vector < int > ( n , 0 ) 
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int y = 0 ;						  
	Sum [ i ] [ i ] = int ( string [ i ] )		      	i < n ;							      y < n ;							  
    for length in range ( 2 , n + 1 ) :			      	i ++ ) sum [ i ] [ i ] = str [ i ] - '0' ;		      y ++ ) Sum [ i ] [ i ] = atoi ( string . substr ( i , strin 
	for i in range ( 0 , n - length + 1 ) :		      	for ( int len = 2 ;					      for ( int length = 2 ;					  
	    j = i + length - 1				      	len <= n ;						      length <= n ;						  
	    k = length // 2				      	len ++ ) {						      length ++ ) {						  
	    Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j 	  for ( int i = 0 ;					    	for ( int i = 0 ;					  
	    if ( length % 2 == 0 and Sum [ i ] [ j - k ] == S 	  i < n - len + 1 ;					    	i <= n - length + 1 ;					  
		maxlen = length				      	  i ++ ) {						    	i ++ ) {						  
    return maxlen					      	    int j = i + len - 1 ;				    	  int j = i + length - 1 ;				  
							      	    int k = len / 2 ;					    	  int k = length / 2 ;					  
							      	    sum [ i ] [ j ] = sum [ i ] [ j - k ] + sum [ j - k + 1 	  Sum [ i ] [ j ] = ( Sum [ i ] [ j - k ] + Sum [ j - k + 
							      	    if ( len % 2 == 0 && sum [ i ] [ j - k ] == sum [ ( j - 	  if ( ( length % 2 == 0 ) && Sum [ i ] [ j - k ] == Sum  
							      	  }							    	}							  
							      	}							      }								  
							      	return maxlen ;						      return len ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY			      K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY			    K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY			  K_TH_LARGEST_SUM_CONTIGUOUS_SUBARRAY
--							      --							    --								  --
def kthLargestSum ( arr , n , k ) :			      int kthLargestSum ( int arr [ ] , int n , int k ) {	    int kthLargestSum ( int * arr , int n , int k ) {		  failure : #Results: 0, 10
    sum = [ ]						      	int sum [ n + 1 ] ;					      int sum [ n + 1 ] ;					  
    sum.append ( 0 )					      	sum [ 0 ] = 0 ;						      sum [ 0 ] = 0 ;						  
    sum.append ( arr [ 0 ] )				      	sum [ 1 ] = arr [ 0 ] ;					      sum [ 1 ] = arr [ 0 ] ;					  
    for i in range ( 2 , n + 1 ) :			      	for ( int i = 2 ;					      for ( int i = 2 ;						  
	sum.append ( sum [ i - 1 ] + arr [ i - 1 ] )	      	i <= n ;						      i <= n + 1 ;						  
    Q = [ ]						      	i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ;	      i ++ ) sum [ i - 1 ] = sum [ i - 1 ] + arr [ i - 1 ] ;	  
    heapq.heapify ( Q )					      	priority_queue < int , vector < int > , greater < int >> Q    int Q [ n + 1 ] ;						  
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 1 ;					      memset ( Q , 0 , sizeof ( Q ) ) ;				  
	for j in range ( i , n + 1 ) :			      	i <= n ;						      for ( int i = 1 ;						  
	    x = sum [ j ] - sum [ i - 1 ]		      	i ++ ) {						      i <= n ;							  
	    if len ( Q ) < k :				      	  for ( int j = i ;					      i ++ ) {							  
		heapq.heappush ( Q , x )		      	  j <= n ;						    	for ( int j = i ;					  
	    else :					      	  j ++ ) {						    	j <= n ;						  
		if Q [ 0 ] < x :			      	    int x = sum [ j ] - sum [ i - 1 ] ;			    	j ++ ) {						  
		    heapq.heappop ( Q )			      	    if ( Q . size ( ) < k ) Q . push ( x ) ;		    	  int x = sum [ j ] - sum [ i - 1 ] ;			  
		    heapq.heappush ( Q , x )		      	    else {						    	  if ( Q [ 0 ] < x ) {					  
    return Q [ 0 ]					      	      if ( Q . top ( ) < x ) {				    	    memset ( Q , 0 , sizeof ( Q ) ) ;			  
							      		Q . pop ( ) ;					    	    memset ( Q , x , sizeof ( Q ) ) ;			  
							      		Q . push ( x ) ;				    	  }							  
							      	      }							    	}							  
							      	    }							      }								  
							      	  }							      return Q [ 0 ] ;						  
							      	}							    }								  
							      	return Q . top ( ) ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3		      COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3		    COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3		  COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3
--							      --							    --								  --
def findgroups ( arr , n ) :				      int findgroups ( int arr [ ] , int n ) {			    int findgroups ( int * arr , int n ) {			  error : COUNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPL
    c = [ 0 , 0 , 0 ]					      	int c [ 3 ] = {						      int c [ ] = {						  E_3.cpp: In function ‘int f_filled(int*, int)’: CO
    res = 0						      	  0 }							    	0 , 0 , 0 }						  UNT_POSSIBLE_GROUPS_SIZE_2_3_SUM_MULTIPLE_3.cpp:46
    for i in range ( 0 , n ) :				      	  , i ;							    	;							  :65: error: expected ‘)’ before ‘;’ token	 res
	c [ arr [ i ] % 3 ] += 1			      	  int res = 0 ;						    	int res = 0 ;						   += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2
    res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 )	      	  for ( i = 0 ;						    	for ( int i = 0 ;					  ) ) / 6 ;		~
    res += c [ 1 ] * c [ 2 ]				      	  i < n ;						    	i != n ;						  			   ^~
    res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) /  	  i ++ ) c [ arr [ i ] % 3 ] ++ ;			    	i ++ ) c [ arr [ i ] % 3 ] ++ ;				  					     )
    res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) /  	  res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;	    	res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ;		  
    res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) )  	  res += c [ 1 ] * c [ 2 ] ;				    	res += c [ 1 ] * c [ 2 ] ;				  
    res += c [ 0 ] * c [ 1 ] * c [ 2 ]			      	  res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) /  	res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) /  
    return res						      	  res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) /  	res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) /  
							      	  res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) )  	res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) )  
							      	  res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;			    	res += c [ 0 ] * c [ 1 ] * c [ 2 ] ;			  
							      	  return res ;						    	return res ;						  
							      	}							      }								  
-							      	-							      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MEDIAN_ROW_WISE_SORTED_MATRIX			      FIND_MEDIAN_ROW_WISE_SORTED_MATRIX			    FIND_MEDIAN_ROW_WISE_SORTED_MATRIX				  FIND_MEDIAN_ROW_WISE_SORTED_MATRIX
--							      --							    --								  --
def binaryMedian ( m , r , d ) :			      int binaryMedian ( int m [ ] [ MAX ] , int r , int c ) {	    int binaryMedian ( int * m , int r , int d ) {		  script_not_found : None
    mi = m [ 0 ] [ 0 ]					      	int min = INT_MAX , max = INT_MIN ;			      int mi = m [ 0 ] [ 0 ] ;					  
    mx = 0						      	for ( int i = 0 ;					      int mx = 0 ;						  
    for i in range ( r ) :				      	i < r ;							      for ( int i = 0 ;						  
	if m [ i ] [ 0 ] < mi :				      	i ++ ) {						      i < r ;							  
	    mi = m [ i ] [ 0 ]				      	  if ( m [ i ] [ 0 ] < min ) min = m [ i ] [ 0 ] ;	      i ++ ) {							  
	if m [ i ] [ d - 1 ] > mx :			      	  if ( m [ i ] [ c - 1 ] > max ) max = m [ i ] [ c - 1 ] ;  	if ( m [ i ] [ 0 ] < mi ) mi = m [ i ] [ 0 ] ;		  
	    mx = m [ i ] [ d - 1 ]			      	}							    	if ( m [ i ] [ d - 1 ] > mx ) mx = m [ i ] [ d - 1 ] ;	  
    desired = ( r * d + 1 ) // 2			      	int desired = ( r * c + 1 ) / 2 ;			      }								  
    while ( mi < mx ) :					      	while ( min < max ) {					      int desired = ( r * d + 1 ) / 2 ;				  
	mid = mi + ( mx - mi ) // 2			      	  int mid = min + ( max - min ) / 2 ;			      while ( ( mi < mx ) ) {					  
	place = [ 0 ]					      	  int place = 0 ;					    	int mid = mi + ( mx - mi ) / 2 ;			  
	for i in range ( r ) :				      	  for ( int i = 0 ;					    	int place [ r ] = {					  
	    j = upper_bound ( m [ i ] , mid )		      	  i < r ;						    	  0 }							  
	    place [ 0 ] = place [ 0 ] + j		      	  ++ i ) place += upper_bound ( m [ i ] , m [ i ] + c , mid 	  ;							  
	if place [ 0 ] < desired :			      	  if ( place < desired ) min = mid + 1 ;		    	  for ( int i = 0 ;					  
	    mi = mid + 1				      	  else max = mid ;					    	  i < r ;						  
	else :						      	}							    	  i ++ ) {						  
	    mx = mid					      	return min ;						    	    int j = upper_bound ( m [ i ] , mid , place ) ;	  
    print ( "Median is" , mi )				      }								    	    place [ 0 ] = place [ 0 ] + j ;			  
    return						      								    	  }							  
							      								    	  if ( place [ 0 ] < desired ) mi = mid + 1 ;		  
							      								    	  else mx = mid ;					  
							      								    	}							  
							      								    	cout << "Median is" << mi << endl ;			  
							      								    	return mi ;						  
							      								    	return r * r ;						  
							      								    	return r * r ;						  
							      								    	return r * r * r * r * r * r * r * r * r * r * r * r * r  
							      								      }								  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH
--							      --							    --								  --
def pairsInSortedRotated ( arr , n , x ) :		      int pairsInSortedRotated ( int arr [ ] , int n , int x ) {    int pairsInSortedRotated ( int * arr , int n , int x ) {	  error : GIVEN_A_SORTED_AND_ROTATED_ARRAY_FIND_IF_T
    for i in range ( n ) :				      	int i ;							      for ( int i = 0 ;						  HERE_IS_A_PAIR_WITH_A_GIVEN_SUM_1.cpp: In function
	if arr [ i ] > arr [ i + 1 ] :			      	for ( i = 0 ;						      i < n ;							   ‘int f_filled(int*, int, int)’: GIVEN_A_SORTED_AN
	    break					      	i < n - 1 ;						      i ++ ) {							  D_ROTATED_ARRAY_FIND_IF_THERE_IS_A_PAIR_WITH_A_GIV
    l = ( i + 1 ) % n					      	i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ;		    	if ( arr [ i ] > arr [ i + 1 ] ) break ;		  EN_SUM_1.cpp:46:13: error: ‘i’ was not declared in
    r = i						      	int l = ( i + 1 ) % n ;					      }								   this scope	 int l = ( i + 1 ) % n ;
    cnt = 0						      	int r = i ;						      int l = ( i + 1 ) % n ;					    ^
    while ( l != r ) :					      	int cnt = 0 ;						      int r = i ;						  
	if arr [ l ] + arr [ r ] == x :			      	while ( l != r ) {					      int cnt = 0 ;						  
	    cnt += 1					      	  if ( arr [ l ] + arr [ r ] == x ) {			      while ( ( l != r ) ) {					  
	    if l == ( r - 1 + n ) % n :			      	    cnt ++ ;						    	if ( arr [ l ] + arr [ r ] == x ) {			  
		return cnt				      	    if ( l == ( r - 1 + n ) % n ) {			    	  cnt ++ ;						  
	    l = ( l + 1 ) % n				      	      return cnt ;					    	  if ( l == ( r - 1 + n ) % n ) return cnt ;		  
	    r = ( r - 1 + n ) % n			      	    }							    	  l = ( l + 1 ) % n ;					  
	elif arr [ l ] + arr [ r ] < x :		      	    l = ( l + 1 ) % n ;					    	  r = ( r - 1 + n ) % n ;				  
	    l = ( l + 1 ) % n				      	    r = ( r - 1 + n ) % n ;				    	}							  
	else :						      	  }							    	else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; 
	    r = ( n + r - 1 ) % n			      	  else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; 	else r = ( n + r - 1 ) % n ;				  
    return cnt						      	  else r = ( n + r - 1 ) % n ;				      }								  
							      	}							      return cnt ;						  
							      	return cnt ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA MAXIMUM_DIFFERENCE_BETWEEN_FREQUENCY_OF_TWO_ELEMENTS_SUCH_THA
--							      --							    --								  --
def maxdiff ( arr , n ) :				      int maxdiff ( int arr [ ] , int n ) {			    int maxdiff ( int * arr , int n ) {				  success : None
    freq = defaultdict ( lambda : 0 )			      	unordered_map < int , int > freq ;			      map < int , int > freq ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	freq [ arr [ i ] ] += 1				      	i < n ;							      i < n ;							  
    ans = 0						      	i ++ ) freq [ arr [ i ] ] ++ ;				      i ++ ) freq [ arr [ i ] ] ++ ;				  
    for i in range ( n ) :				      	int ans = 0 ;						      int ans = 0 ;						  
	for j in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    if freq [ arr [ i ] ] > freq [ arr [ j ] ] and ar 	i < n ;							      i < n ;							  
		ans = max ( ans , freq [ arr [ i ] ] - freq [ 	i ++ ) {						      i ++ ) {							  
	    elif freq [ arr [ i ] ] < freq [ arr [ j ] ] and  	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
		ans = max ( ans , freq [ arr [ j ] ] - freq [ 	  j < n ;						    	j < n ;							  
    return ans						      	  j ++ ) {						    	j ++ ) {						  
							      	    if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i 	  if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i 
							      	    else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && ar 	  else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && ar 
							      	  }							    	}							  
							      	}							      }								  
							      	return ans ;						      return ans ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL	      FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL		    FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL		  FIND_NUMBER_TRANSFORMATION_MAKE_TWO_MATRIX_EQUAL
--							      --							    --								  --
def countOps ( A , B , m , n ) :			      int countOps ( int A [ ] [ MAX ] , int B [ ] [ MAX ] , int m  int countOps ( int * * A , int * * B , int m , int n ) {	  script_not_found : None
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( m ) :				      	i < n ;							      i < n ;							  
	    A [ i ] [ j ] -= B [ i ] [ j ]		      	i ++ ) for ( int j = 0 ;				      i ++ ) {							  
    for i in range ( 1 , n ) :				      	j < m ;							    	for ( int j = 0 ;					  
	for j in range ( 1 , n ) :			      	j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ;			    	j < m ;							  
	    if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j  	for ( int i = 1 ;					    	j ++ ) {						  
		return - 1				      	i < n ;							    	  A [ i ] [ j ] -= B [ i ] [ j ] ;			  
    result = 0						      	i ++ ) for ( int j = 1 ;				    	}							  
    for i in range ( n ) :				      	j < m ;							      }								  
	result += abs ( A [ i ] [ 0 ] )			      	j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] +   for ( int i = 1 ;						  
    for j in range ( m ) :				      	int result = 0 ;					      i < n ;							  
	result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] )	      	for ( int i = 0 ;					      i ++ ) {							  
    return ( result )					      	i < n ;							    	for ( int j = 1 ;					  
							      	i ++ ) result += abs ( A [ i ] [ 0 ] ) ;		    	j < n ;							  
							      	for ( int j = 0 ;					    	j ++ ) {						  
							      	j < m ;							    	  if ( ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] +  
							      	j ++ ) result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ;    	}							  
							      	return ( result ) ;					      }								  
							      }								      int result = 0 ;						  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) result += abs ( A [ i ] [ 0 ] ) ;			  
							      								      for ( int j = 0 ;						  
							      								      j < m ;							  
							      								      j ++ ) result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ;	  
							      								      return ( result ) ;					  
							      								      return m * m ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS NUMBER_WHICH_HAS_THE_MAXIMUM_NUMBER_OF_DISTINCT_PRIME_FACTORS
--							      --							    --								  --
def maximumNumberDistinctPrimeRange ( m , n ) :		      int maximumNumberDistinctPrimeRange ( int m , int n ) {	    int maximumNumberDistinctPrimeRange ( int m , int n ) {	  success : None
    factorCount = [ 0 ] * ( n + 1 )			      	long long factorCount [ n + 1 ] ;			      vector < int > factorCount ( n + 1 , 0 ) ;		  
    prime = [ False ] * ( n + 1 )			      	bool prime [ n + 1 ] ;					      vector < bool > prime ( n + 1 , false ) ;			  
    for i in range ( n + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	factorCount [ i ] = 0				      	i <= n ;						      i < n + 1 ;						  
	prime [ i ] = True				      	i ++ ) {						      i ++ ) {							  
    for i in range ( 2 , n + 1 ) :			      	  factorCount [ i ] = 0 ;				    	factorCount [ i ] = 0 ;					  
	if ( prime [ i ] == True ) :			      	  prime [ i ] = true ;					    	prime [ i ] = true ;					  
	    factorCount [ i ] = 1			      	}							      }								  
	    for j in range ( i * 2 , n + 1 , i ) :	      	for ( int i = 2 ;					      for ( int i = 2 ;						  
		factorCount [ j ] += 1			      	i <= n ;						      i <= n ;							  
		prime [ j ] = False			      	i ++ ) {						      i ++ ) {							  
    max = factorCount [ m ]				      	  if ( prime [ i ] == true ) {				    	if ( ( prime [ i ] == true ) ) {			  
    num = m						      	    factorCount [ i ] = 1 ;				    	  factorCount [ i ] = 1 ;				  
    for i in range ( m , n + 1 ) :			      	    for ( int j = i * 2 ;				    	  for ( int j = i * 2 ;					  
	if ( factorCount [ i ] > max ) :		      	    j <= n ;						    	  j <= n ;						  
	    max = factorCount [ i ]			      	    j += i ) {						    	  j += i ) {						  
	    num = i					      	      factorCount [ j ] ++ ;				    	    factorCount [ j ] ++ ;				  
    return num						      	      prime [ j ] = false ;				    	    prime [ j ] = false ;				  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	int max = factorCount [ m ] ;				      int max = factorCount [ m ] ;				  
							      	int num = m ;						      int num = m ;						  
							      	for ( int i = m ;					      for ( int i = m ;						  
							      	i <= n ;						      i <= n ;							  
							      	i ++ ) {						      i ++ ) {							  
							      	  if ( factorCount [ i ] > max ) {			    	if ( ( factorCount [ i ] > max ) ) {			  
							      	    max = factorCount [ i ] ;				    	  max = factorCount [ i ] ;				  
							      	    num = i ;						    	  num = i ;						  
							      	  }							    	}							  
							      	}							      }								  
							      	return num ;						      return num ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBSET_SUM_PROBLEM_OSUM_SPACE				      SUBSET_SUM_PROBLEM_OSUM_SPACE				    SUBSET_SUM_PROBLEM_OSUM_SPACE				  SUBSET_SUM_PROBLEM_OSUM_SPACE
--							      --							    --								  --
def isSubsetSum ( arr , n , sum ) :			      bool isSubsetSum ( int arr [ ] , int n , int sum ) {	    bool isSubsetSum ( int * arr , int n , int sum ) {		  failure : #Results: 6, 10
    subset = [ [ False for j in range ( sum + 1 ) ] for i in  	bool subset [ 2 ] [ sum + 1 ] ;				      vector < vector < bool >> subset ( sum + 1 , vector < bool  
    for i in range ( n + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( sum + 1 ) :			      	i <= n ;						      i < 3 ;							  
	    if ( j == 0 ) :				      	i ++ ) {						      i ++ ) {							  
		subset [ i % 2 ] [ j ] = True		      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	    elif ( i == 0 ) :				      	  j <= sum ;						    	j < sum + 1 ;						  
		subset [ i % 2 ] [ j ] = False		      	  j ++ ) {						    	j ++ ) {						  
	    elif ( arr [ i - 1 ] <= j ) :		      	    if ( j == 0 ) subset [ i % 2 ] [ j ] = true ;	    	  if ( ( j == 0 ) ) subset [ i % 2 ] [ j ] = true ;	  
		subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 	    else if ( i == 0 ) subset [ i % 2 ] [ j ] = false ;	    	  else if ( ( i == 0 ) ) subset [ i % 2 ] [ j ] = false ; 
	    else :					      	    else if ( arr [ i - 1 ] <= j ) subset [ i % 2 ] [ j ] = 	  else if ( ( arr [ i - 1 ] <= j ) ) subset [ i % 2 ] [ j 
		subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 	    else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ]  	  else subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ]  
    return subset [ n % 2 ] [ sum ]			      	  }							    	}							  
							      	}							      }								  
							      	return subset [ n % 2 ] [ sum ] ;			      return subset [ n % 2 ] [ sum ] ;				  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN COUNT_WORDS_WHOSE_TH_LETTER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN
--							      --							    --								  --
def countWords ( str , l ) :				      int countWords ( char str [ ] , int len ) {		    int countWords ( string str , int l ) {			  error : /bin/bash: line 1: 1848263 Aborted
    count = 1 ;						      	int count = 1 ;						      int count = 1 ;						  	   (core dumped) ./COUNT_WORDS_WHOSE_TH_LETT
    if ( l == 1 ) :					      	if ( len == 1 ) return count ;				      if ( ( l == 1 ) ) return count ;				  ER_EITHER_1_TH_TH_I1_TH_LETTER_GIVEN_WORD_cpp
	return count					      	if ( str [ 0 ] == str [ 1 ] ) count *= 1 ;		      if ( ( str [ 0 ] == str [ 1 ] ) ) count *= 1 ;		  
    if ( str [ 0 ] == str [ 1 ] ) :			      	else count *= 2 ;					      else count *= 2 ;						  
	count *= 1					      	for ( int j = 1 ;					      for ( int j = 1 ;						  
    else :						      	j < len - 1 ;						      j < l - 1 ;						  
	count *= 2					      	j ++ ) {						      j ++ ) {							  
    for j in range ( 1 , l - 1 ) :			      	  if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 	if ( ( str [ j ] == str [ j - 1 ] ) && ( str [ j ] == str 
	if ( str [ j ] == str [ j - 1 ] and str [ j ] == str  	  else if ( str [ j ] == str [ j - 1 ] || str [ j ] == str  	else if ( ( str [ j ] == str [ j - 1 ] ) || ( str [ j ] = 
	    count *= 1					      	  else count *= 3 ;					    	else count *= 3 ;					  
	elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str 	}							      }								  
	    count *= 2					      	if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ;	      if ( ( str [ l - 1 ] == str [ l - 2 ] ) ) count *= 1 ;	  
	else :						      	else count *= 2 ;					      else count *= 2 ;						  
	    count *= 3					      	return count ;						      return count ;						  
    if ( str [ l - 1 ] == str [ l - 2 ] ) :		      }								      return l * l * l * l * l * l * l * l * l * l * l * l * l *  
	count *= 1					      								    }								  
    else :						      								    								  
	count *= 2					      								    								  
    return count					      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HIGHWAY_BILLBOARD_PROBLEM				      HIGHWAY_BILLBOARD_PROBLEM					    HIGHWAY_BILLBOARD_PROBLEM					  HIGHWAY_BILLBOARD_PROBLEM
--							      --							    --								  --
def maxRevenue ( m , x , revenue , n , t ) :		      int maxRevenue ( int m , int x [ ] , int revenue [ ] , int n  int maxRevenue ( int m , int * x , int * revenue , int n , in failure : #Results: 6, 10
    maxRev = [ 0 ] * ( m + 1 )				      	int maxRev [ m + 1 ] ;					      int maxRev [ m + 1 ] ;					  
    nxtbb = 0						      	memset ( maxRev , 0 , sizeof ( maxRev ) ) ;		      int nxtbb = 0 ;						  
    for i in range ( 1 , m + 1 ) :			      	int nxtbb = 0 ;						      for ( int i = 1 ;						  
	if ( nxtbb < n ) :				      	for ( int i = 1 ;					      i <= m ;							  
	    if ( x [ nxtbb ] != i ) :			      	i <= m ;						      i ++ ) {							  
		maxRev [ i ] = maxRev [ i - 1 ]		      	i ++ ) {						    	if ( ( nxtbb < n ) ) {					  
	    else :					      	  if ( nxtbb < n ) {					    	  if ( ( x [ nxtbb ] != i ) ) maxRev [ i ] = maxRev [ i - 
		if ( i <= t ) :				      	    if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] 	  else {						  
		    maxRev [ i ] = max ( maxRev [ i - 1 ] , r 	    else {						    	    if ( ( i <= t ) ) maxRev [ i ] = max ( maxRev [ i - 1 
		else :					      	      if ( i <= t ) maxRev [ i ] = max ( maxRev [ i - 1 ] , 	    else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + reve 
		    maxRev [ i ] = max ( maxRev [ i - t - 1 ] 	      else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + reve 	    nxtbb ++ ;						  
		nxtbb += 1				      	      nxtbb ++ ;					    	  }							  
	else :						      	    }							    	}							  
	    maxRev [ i ] = maxRev [ i - 1 ]		      	  }							    	else maxRev [ i ] = maxRev [ i - 1 ] ;			  
    return maxRev [ m ]					      	  else maxRev [ i ] = maxRev [ i - 1 ] ;		      }								  
							      	}							      return maxRev [ m ] ;					  
							      	return maxRev [ m ] ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS	      LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS	    LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS	  LARGEST_INCREASING_SUBSEQUENCE_OF_CONSECUTIVE_INTEGERS
--							      --							    --								  --
def findLIS ( A , n ) :					      int findLIS ( int A [ ] , int n ) {			    int findLIS ( int * A , int n ) {				  script_not_found : None
    hash = dict ( )					      	unordered_map < int , int > hash ;			      map < int , int > hash ;					  
    LIS_size , LIS_index = 1 , 0			      	int LIS_size = 1 ;					      int LIS_size = 1 , LIS_index = 0 ;			  
    hash [ A [ 0 ] ] = 1				      	int LIS_index = 0 ;					      hash [ A [ 0 ] ] = 1 ;					  
    for i in range ( 1 , n ) :				      	hash [ A [ 0 ] ] = 1 ;					      for ( int i = 1 ;						  
	if A [ i ] - 1 not in hash :			      	for ( int i = 1 ;					      i < n ;							  
	    hash [ A [ i ] - 1 ] = 0			      	i < n ;							      i ++ ) {							  
	hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1	      	i ++ ) {						    	if ( A [ i ] - 1 != hash . count ( A [ i ] - 1 ) ) hash [ 
	if LIS_size < hash [ A [ i ] ] :		      	  hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 ;		    	hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 ;		  
	    LIS_size = hash [ A [ i ] ]			      	  if ( LIS_size < hash [ A [ i ] ] ) {			    	if ( LIS_size < hash [ A [ i ] ] ) {			  
	    LIS_index = A [ i ]				      	    LIS_size = hash [ A [ i ] ] ;			    	  LIS_size = hash [ A [ i ] ] ;				  
    print ( "LIS_size =" , LIS_size )			      	    LIS_index = A [ i ] ;				    	  LIS_index = A [ i ] ;					  
    print ( "LIS : " , end = "" )			      	  }							    	}							  
    start = LIS_index - LIS_size + 1			      	}							      }								  
    while start <= LIS_index :				      	cout << "LIS_size = " << LIS_size << "\n" ;		      cout << "LIS_size =" << LIS_size << endl ;		  
	print ( start , end = " " )			      	cout << "LIS : " ;					      cout << "LIS : " << endl ;				  
	start += 1					      	int start = LIS_index - LIS_size + 1 ;			      int start = LIS_index - LIS_size + 1 ;			  
							      	while ( start <= LIS_index ) {				      while ( start <= LIS_index ) {				  
							      	  cout << start << " " ;				    	cout << start << " " ;					  
							      	  start ++ ;						    	start ++ ;						  
							      	}							      }								  
							      }								      return LIS_size ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_NEXT_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
def NextFit ( blockSize , m , processSize , n ) :	      void NextFit ( int blockSize [ ] , int m , int processSize [  int NextFit ( int * blockSize , int m , int * processSize , i script_not_found : None
    allocation = [ - 1 ] * n				      	int allocation [ n ] , j = 0 ;				      int allocation [ n ] ;					  
    j = 0						      	memset ( allocation , - 1 , sizeof ( allocation ) ) ;	      int j = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	while j < m :					      	i < n ;							      i < n ;							  
	    if blockSize [ j ] >= processSize [ i ] :	      	i ++ ) {						      i ++ ) {							  
		allocation [ i ] = j			      	  while ( j < m ) {					    	while ( j < m ) {					  
		blockSize [ j ] -= processSize [ i ]	      	    if ( blockSize [ j ] >= processSize [ i ] ) {	    	  if ( blockSize [ j ] >= processSize [ i ] ) {		  
		break					      	      allocation [ i ] = j ;				    	    allocation [ i ] = j ;				  
	    j = ( j + 1 ) % m				      	      blockSize [ j ] -= processSize [ i ] ;		    	    blockSize [ j ] -= processSize [ i ] ;		  
    print ( "Process No.Process Size Block no." )	      	      break ;						    	    break ;						  
    for i in range ( n ) :				      	    }							    	  }							  
	print ( i + 1 , "	  " , processSize [ i ] , end 	    j = ( j + 1 ) % m ;					    	  j = ( j + 1 ) % m ;					  
	if allocation [ i ] != - 1 :			      	  }							    	}							  
	    print ( allocation [ i ] + 1 )		      	}							      }								  
	else :						      	cout << "\nProcess No.\tProcess Size\tBlock no.\n" ;	      cout << "Process No. Process Size Block no." << endl ;	  
	    print ( "Not Allocated" )			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
							      	i < n ;							      i < n ;							  
							      	i ++ ) {						      i ++ ) {							  
							      	  cout << " " << i + 1 << "\t\t" << processSize [ i ] << "\ 	cout << i + 1 << "	   " << processSize [ i ] << "	  
							      	  if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 	if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 
							      	  else cout << "Not Allocated" ;			    	else cout << "Not Allocated" ;				  
							      	  cout << endl ;					      }								  
							      	}							      return allocation [ n ] ;					  
							      }								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIND_CORRELATION_COEFFICIENT			      PROGRAM_FIND_CORRELATION_COEFFICIENT			    PROGRAM_FIND_CORRELATION_COEFFICIENT			  PROGRAM_FIND_CORRELATION_COEFFICIENT
--							      --							    --								  --
def correlationCoefficient ( X , Y , n ) :		      float correlationCoefficient ( int X [ ] , int Y [ ] , int n  float correlationCoefficient ( float * X , float * Y , int n  script_not_found : None
    sum_X = 0						      	int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ;		      float sum_X = 0 ;						  
    sum_Y = 0						      	int squareSum_X = 0 , squareSum_Y = 0 ;			      float sum_Y = 0 ;						  
    sum_XY = 0						      	for ( int i = 0 ;					      float sum_XY = 0 ;					  
    squareSum_X = 0					      	i < n ;							      float square_sum_X = 0 ;					  
    squareSum_Y = 0					      	i ++ ) {						      float square_sum_Y = 0 ;					  
    i = 0						      	  sum_X = sum_X + X [ i ] ;				      int i = 0 ;						  
    while i < n :					      	  sum_Y = sum_Y + Y [ i ] ;				      while ( i < n ) {						  
	sum_X = sum_X + X [ i ]				      	  sum_XY = sum_XY + X [ i ] * Y [ i ] ;			    	sum_X = sum_X + X [ i ] ;				  
	sum_Y = sum_Y + Y [ i ]				      	  squareSum_X = squareSum_X + X [ i ] * X [ i ] ;	    	sum_Y = sum_Y + Y [ i ] ;				  
	sum_XY = sum_XY + X [ i ] * Y [ i ]		      	  squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ;	    	sum_XY = sum_XY + X [ i ] * Y [ i ] ;			  
	squareSum_X = squareSum_X + X [ i ] * X [ i ]	      	}							    	square_sum_X = square_sum_X + X [ i ] * X [ i ] ;	  
	squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ]	      	float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / sqr 	square_sum_Y = square_sum_Y + Y [ i ] * Y [ i ] ;	  
	i = i + 1					      	return corr ;						    	i = i + 1 ;						  
    corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) /	      }								      }								  
	( float ) ( math.sqrt ( ( n * squareSum_X - sum_X * s 								      float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( f 
    return corr						      								      return corr ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES	      MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES	    MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES	  MODIFY_ARRAY_TO_MAXIMIZE_SUM_OF_ADJACENT_DIFFERENCES
--							      --							    --								  --
def maximumDifferenceSum ( arr , N ) :			      int maximumDifferenceSum ( int arr [ ] , int N ) {	    int maximumDifferenceSum ( int * arr , int N ) {		  script_not_found : None
    dp = [ [ 0 , 0 ] for i in range ( N ) ]		      	int dp [ N ] [ 2 ] ;					      vector < vector < int >> dp ( N , vector < int > ( N , 0 )  
    for i in range ( N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0		      	i < N ;							      i < N ;							  
    for i in range ( N - 1 ) :				      	i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ;		      i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ;		  
	dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ]  	for ( int i = 0 ;					      for ( int i = 0 ;						  
	dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr 	i < ( N - 1 ) ;						      i < N - 1 ;						  
    return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] )    	i ++ ) {						      i ++ ) {							  
							      	  dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1  	dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1  
							      	  dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i 	dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i 
							      	}							      }								  
							      	return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ;      return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ;	  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION	      MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION	    MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION	  MAXIMUM_PATH_SUM_POSITION_JUMPS_DIVISIBILITY_CONDITION
--							      --							    --								  --
def printMaxSum ( arr , n ) :				      void printMaxSum ( int arr [ ] , int n ) {		    int printMaxSum ( int * arr , int n ) {			  script_not_found : None
    dp = [ 0 for i in range ( n ) ]			      	int dp [ n ] ;						      vector < int > dp ( n , 0 ) ;				  
    for i in range ( n ) :				      	memset ( dp , 0 , sizeof dp ) ;				      for ( int i = 0 ;						  
	dp [ i ] = arr [ i ]				      	for ( int i = 0 ;					      i < n ;							  
	maxi = 0					      	i < n ;							      i ++ ) {							  
	for j in range ( 1 , int ( ( i + 1 ) ** 0.5 ) + 1 ) : 	i ++ ) {						    	dp [ i ] = arr [ i ] ;					  
	    if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) :    	  dp [ i ] = arr [ i ] ;				    	int maxi = 0 ;						  
		if ( dp [ j - 1 ] > maxi ) :		      	  int maxi = 0 ;					    	for ( int j = 1 ;					  
		    maxi = dp [ j - 1 ]			      	  for ( int j = 1 ;					    	j < ( int ) ( ( i + 1 ) * 0.5 ) + 1 ;			  
		if ( dp [ ( i + 1 ) // j - 1 ] > maxi and j ! 	  j <= sqrt ( i + 1 ) ;					    	j ++ ) {						  
		    maxi = dp [ ( i + 1 ) // j - 1 ]	      	  j ++ ) {						    	  if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) {	  
	dp [ i ] += maxi				      	    if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) {	    	    if ( ( dp [ j - 1 ] > maxi ) ) maxi = dp [ j - 1 ] ;  
    for i in range ( n ) :				      	      if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ;	    	    if ( ( dp [ ( i + 1 ) / j - 1 ] > maxi ) && j != 1 )  
	print ( dp [ i ] , end = ' ' )			      	      if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi 	  }							  
							      	    }							    	}							  
							      	  }							    	dp [ i ] += maxi ;					  
							      	  dp [ i ] += maxi ;					      }								  
							      	}							      for ( int i = 0 ;						  
							      	for ( int i = 0 ;					      i < n ;							  
							      	i < n ;							      i ++ ) cout << dp [ i ] << " " ;				  
							      	i ++ ) cout << dp [ i ] << " " ;			      return n ;						  
							      }								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_FIRST_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
def firstFit ( blockSize , m , processSize , n ) :	      void firstFit ( int blockSize [ ] , int m , int processSize [ int firstFit ( int * blockSize , int m , int * processSize ,  script_not_found : None
    allocation = [ - 1 ] * n				      	int allocation [ n ] ;					      int allocation [ n ] ;					  
    for i in range ( n ) :				      	memset ( allocation , - 1 , sizeof ( allocation ) ) ;	      for ( int i = 0 ;						  
	for j in range ( m ) :				      	for ( int i = 0 ;					      i < n ;							  
	    if blockSize [ j ] >= processSize [ i ] :	      	i < n ;							      i ++ ) {							  
		allocation [ i ] = j			      	i ++ ) {						    	for ( int j = 0 ;					  
		blockSize [ j ] -= processSize [ i ]	      	  for ( int j = 0 ;					    	j < m ;							  
		break					      	  j < m ;						    	j ++ ) {						  
    print ( " Process No.Process Size	   Block no." )	      	  j ++ ) {						    	  if ( blockSize [ j ] >= processSize [ i ] ) {		  
    for i in range ( n ) :				      	    if ( blockSize [ j ] >= processSize [ i ] ) {	    	    allocation [ i ] = j ;				  
	print ( " " , i + 1 , "		" , processSize [ i ] 	      allocation [ i ] = j ;				    	    blockSize [ j ] -= processSize [ i ] ;		  
	if allocation [ i ] != - 1 :			      	      blockSize [ j ] -= processSize [ i ] ;		    	    break ;						  
	    print ( allocation [ i ] + 1 )		      	      break ;						    	  }							  
	else :						      	    }							    	}							  
	    print ( "Not Allocated" )			      	  }							      }								  
							      	}							      cout << " Process No. Process Size      Block no." << endl  
							      	cout << "\nProcess No.\tProcess Size\tBlock no.\n" ;	      for ( int i = 0 ;						  
							      	for ( int i = 0 ;					      i < n ;							  
							      	i < n ;							      i ++ ) {							  
							      	i ++ ) {						    	cout << " " << i + 1 << "	  " << processSize [ i ]  
							      	  cout << " " << i + 1 << "\t\t" << processSize [ i ] << "\ 	if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 
							      	  if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 	else cout << "Not Allocated" << endl ;			  
							      	  else cout << "Not Allocated" ;			      }								  
							      	  cout << endl ;					      return allocation [ n ] ;					  
							      	}							    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_POSSIBLE_PATH_2D_MATRIX				      CHECK_POSSIBLE_PATH_2D_MATRIX				    CHECK_POSSIBLE_PATH_2D_MATRIX				  CHECK_POSSIBLE_PATH_2D_MATRIX
--							      --							    --								  --
def isPath ( arr ) :					      bool isPath ( int arr [ row ] [ col ] ) {			    bool isPath ( int * * arr ) {				  script_not_found : None
    arr [ 0 ] [ 0 ] = 1					      	arr [ 0 ] [ 0 ] = 1 ;					      arr [ 0 ] [ 0 ] = 1 ;					  
    for i in range ( 1 , row ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	if ( arr [ i ] [ 0 ] != - 1 ) :			      	i < row ;						      i < row ;							  
	    arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ]	      	i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr    i ++ ) if ( ( arr [ i ] [ 0 ] != - 1 ) && ( arr [ i ] [ 0 ] 
    for j in range ( 1 , col ) :			      	for ( int j = 1 ;					      for ( int j = 1 ;						  
	if ( arr [ 0 ] [ j ] != - 1 ) :			      	j < col ;						      j < col ;							  
	    arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ]	      	j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr    j ++ ) if ( ( arr [ 0 ] [ j ] != - 1 ) && ( arr [ 0 ] [ j - 
    for i in range ( 1 , row ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	for j in range ( 1 , col ) :			      	i < row ;						      i < row ;							  
	    if ( arr [ i ] [ j ] != - 1 ) :		      	i ++ ) for ( int j = 1 ;				      i ++ ) for ( int j = 1 ;					  
		arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , 	j < col ;						      j < col ;							  
    return ( arr [ row - 1 ] [ col - 1 ] == 1 )		      	j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = max    j ++ ) if ( ( arr [ i ] [ j ] != - 1 ) ) arr [ i ] [ j ] =  
							      	return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ;		      return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ;		  
							      }								      return arr * arr * arr * arr * arr * arr * arr * arr * arr  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP CIRCULAR_MATRIX_CONSTRUCT_A_MATRIX_WITH_NUMBERS_1_TO_MN_IN_SP
--							      --							    --								  --
def spiralFill ( m , n , a ) :				      void spiralFill ( int m , int n , int a [ ] [ MAX ] ) {	    void spiralFill ( int m , int n , int * a [ ] ) {		  script_not_found : None
    val = 1						      	int val = 1 ;						      int val = 1 ;						  
    k , l = 0 , 0					      	int k = 0 , l = 0 ;					      int k = 0 , l = 0 ;					  
    while ( k < m and l < n ) :				      	while ( k < m && l < n ) {				      while ( ( k < m ) && ( l < n ) ) {			  
	for i in range ( l , n ) :			      	  for ( int i = l ;					    	for ( int i = l ;					  
	    a [ k ] [ i ] = val				      	  i < n ;						    	i < n ;							  
	    val += 1					      	  ++ i ) a [ k ] [ i ] = val ++ ;			    	i ++ ) {						  
	k += 1						      	  k ++ ;						    	  a [ k ] [ i ] = val ;					  
	for i in range ( k , m ) :			      	  for ( int i = k ;					    	  val ++ ;						  
	    a [ i ] [ n - 1 ] = val			      	  i < m ;						    	}							  
	    val += 1					      	  ++ i ) a [ i ] [ n - 1 ] = val ++ ;			    	k ++ ;							  
	n -= 1						      	  n -- ;						    	for ( int i = k ;					  
	if ( k < m ) :					      	  if ( k < m ) {					    	i < m ;							  
	    for i in range ( n - 1 , l - 1 , - 1 ) :	      	    for ( int i = n - 1 ;				    	i ++ ) {						  
		a [ m - 1 ] [ i ] = val			      	    i >= l ;						    	  a [ i ] [ n - 1 ] = val ;				  
		val += 1				      	    -- i ) a [ m - 1 ] [ i ] = val ++ ;			    	  val ++ ;						  
	    m -= 1					      	    m -- ;						    	}							  
	if ( l < n ) :					      	  }							    	n -- ;							  
	    for i in range ( m - 1 , k - 1 , - 1 ) :	      	  if ( l < n ) {					    	if ( ( k < m ) ) {					  
		a [ i ] [ l ] = val			      	    for ( int i = m - 1 ;				    	  for ( int i = n - 1 ;					  
		val += 1				      	    i >= k ;						    	  i >= l ;						  
	    l += 1					      	    -- i ) a [ i ] [ l ] = val ++ ;			    	  i -- ) {						  
							      	    l ++ ;						    	    a [ m - 1 ] [ i ] = val ;				  
							      	  }							    	    val ++ ;						  
							      	}							    	  }							  
							      }								    	  m -- ;						  
							      								    	}							  
							      								    	if ( ( l < n ) ) {					  
							      								    	  for ( int i = m - 1 ;					  
							      								    	  i >= k - 1 ;						  
							      								    	  i -- ) {						  
							      								    	    a [ i ] [ l ] = val ;				  
							      								    	    val ++ ;						  
							      								    	  }							  
							      								    	  l ++ ;						  
							      								    	}							  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
HOSOYAS_TRIANGLE					      HOSOYAS_TRIANGLE						    HOSOYAS_TRIANGLE						  HOSOYAS_TRIANGLE
--							      --							    --								  --
def printHosoya ( n ) :					      void printHosoya ( int n ) {				    int main ( int argc , char * * argv ) {			  script_not_found : None
    dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ]  	int dp [ N ] [ N ] ;					      vector < vector < int >> dp ( N , vector < int > ( N , 0 )  
    dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1      	memset ( dp , 0 , sizeof ( dp ) ) ;			      dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 ;	  
    for i in range ( 2 , n ) :				      	dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 ;	      for ( int i = 2 ;						  
	for j in range ( n ) :				      	for ( int i = 2 ;					      i < argc ;						  
	    if ( i > j ) :				      	i < n ;							      i ++ ) {							  
		dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [  	i ++ ) {						    	for ( int j = 0 ;					  
	    else :					      	  for ( int j = 0 ;					    	j < n ;							  
		dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + d 	  j < n ;						    	j ++ ) {						  
    for i in range ( n ) :				      	  j ++ ) {						    	  if ( ( i > j ) ) dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ]  
	for j in range ( i + 1 ) :			      	    if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ 	  else dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i 
	    print ( dp [ i ] [ j ] , end = ' ' )	      	    else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 	}							  
	print ( )					      	  }							      }								  
							      	}							      for ( int i = 0 ;						  
							      	for ( int i = 0 ;					      i < n ;							  
							      	i < n ;							      i ++ ) {							  
							      	i ++ ) {						    	for ( int j = 0 ;					  
							      	  for ( int j = 0 ;					    	j < i + 1 ;						  
							      	  j <= i ;						    	j ++ ) cout << dp [ i ] [ j ] << " " ;			  
							      	  j ++ ) cout << dp [ i ] [ j ] << " " ;		    	cout << endl ;						  
							      	  cout << endl ;					      }								  
							      	}							      return 0 ;						  
							      }								      return argc * argc ;					  
							      								      return argc * argc * argc * argc * argc * argc * argc * arg 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU FIND_SMALLEST_NUMBER_WITH_GIVEN_NUMBER_OF_DIGITS_AND_DIGIT_SU
--							      --							    --								  --
def findSmallest ( m , s ) :				      void findSmallest ( int m , int s ) {			    int findSmallest ( int m , int s ) {			  script_not_found : None
    if ( s == 0 ) :					      	if ( s == 0 ) {						      if ( ( s == 0 ) ) {					  
	if ( m == 1 ) :					      	  ( m == 1 ) ? cout << "Smallest number is " << 0 : cout << 	if ( ( m == 1 ) ) cout << "Smallest number is 0" << endl  
	    print ( "Smallest number is 0" )		      	  return ;						    	else cout << "Not possible" << endl ;			  
	else :						      	}							    	return 0 ;						  
	    print ( "Not possible" )			      	if ( s > 9 * m ) {					      }								  
	return						      	  cout << "Not possible" ;				      if ( ( s > 9 * m ) ) {					  
    if ( s > 9 * m ) :					      	  return ;						    	cout << "Not possible" << endl ;			  
	print ( "Not possible" )			      	}							    	return 0 ;						  
	return						      	int res [ m ] ;						      }								  
    res = [ 0 for i in range ( m + 1 ) ]		      	s -= 1 ;						      int res [ m + 1 ] ;					  
    s -= 1						      	for ( int i = m - 1 ;					      for ( int i = 0 ;						  
    for i in range ( m - 1 , 0 , - 1 ) :		      	i > 0 ;							      i < m + 1 ;						  
	if ( s > 9 ) :					      	i -- ) {						      i ++ ) {							  
	    res [ i ] = 9				      	  if ( s > 9 ) {					    	res [ i ] = 0 ;						  
	    s -= 9					      	    res [ i ] = 9 ;					    	s -- ;							  
	else :						      	    s -= 9 ;						      }								  
	    res [ i ] = s				      	  }							      for ( int i = m - 1 ;					  
	    s = 0					      	  else {						      i > 0 ;							  
    res [ 0 ] = s + 1					      	    res [ i ] = s ;					      i -- ) {							  
    print ( "Smallest number is " , end = "" )		      	    s = 0 ;						    	if ( ( s > 9 ) ) {					  
    for i in range ( m ) :				      	  }							    	  res [ i ] = 9 ;					  
	print ( res [ i ] , end = "" )			      	}							    	  s -= 9 ;						  
							      	res [ 0 ] = s + 1 ;					    	}							  
							      	cout << "Smallest number is " ;				    	else {							  
							      	for ( int i = 0 ;					    	  res [ i ] = s ;					  
							      	i < m ;							    	  s = 0 ;						  
							      	i ++ ) cout << res [ i ] ;				    	}							  
							      }								      }								  
							      								      res [ 0 ] = s + 1 ;					  
							      								      cout << "Smallest number is " << endl ;			  
							      								      for ( int i = 0 ;						  
							      								      i < m ;							  
							      								      i ++ ) cout << res [ i ] << endl ;			  
							      								      return m ;						  
							      								      return m * m ;						  
							      								      return m * m * m * m * m * m * m * m * m * m * m * m * m *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1		      LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1		    LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1		  LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS_1
--							      --							    --								  --
def lcsOf3 ( i , j , k ) :				      int lcsOf3 ( int i , int j , int k ) {			    int lcsOf3 ( int i , int j , int k ) {			  script_not_found : None
    if ( i == - 1 or j == - 1 or k == - 1 ) :		      	if ( i == - 1 || j == - 1 || k == - 1 ) return 0 ;	      if ( ( i == - 1 ) || ( j == - 1 ) || ( k == - 1 ) ) return  
	return 0					      	if ( dp [ i ] [ j ] [ k ] != - 1 ) return dp [ i ] [ j ] [    if ( ( dp [ i ] [ j ] [ k ] != - 1 ) ) return dp [ i ] [ j  
    if ( dp [ i ] [ j ] [ k ] != - 1 ) :		      	if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [   if ( ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) ) {	  
	return dp [ i ] [ j ] [ k ]			      	else return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 	dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 
    if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) :	      }								    	return dp [ i ] [ j ] [ k ] ;				  
	dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k 								      }								  
	return dp [ i ] [ j ] [ k ]			      								      else {							  
    else :						      								    	dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k 
	dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j 								    	return dp [ i ] [ j ] [ k ] ;				  
	return dp [ i ] [ j ] [ k ]			      								      }								  
							      								      return i * i ;						  
							      								      return i * i ;						  
							      								      return i * i ;						  
							      								      return i * i * i * i * i * i * i * i * i * i * i * i * i *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER		      CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER		    CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER			  CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHER
--							      --							    --								  --
def check ( s1 , s2 ) :					      bool check ( string s1 , string s2 ) {			    bool check ( string s1 , string s2 ) {			  error : CHECK_POSSIBLE_TRANSFORM_ONE_STRING_ANOTHE
    n = len ( s1 )					      	int n = s1 . length ( ) ;				      int n = s1 . length ( ) ;					  R.cpp: In function ‘bool f_filled(std::__cxx11::st
    m = len ( s2 )					      	int m = s2 . length ( ) ;				      int m = s2 . length ( ) ;					  ring, std::__cxx11::string)’: CHECK_POSSIBLE_TRANS
    dp = ( [ [ False for i in range ( m + 1 ) ] for i in rang 	bool dp [ n + 1 ] [ m + 1 ] ;				      vector < vector < bool >> dp ( m + 1 , vector < bool > ( n  FORM_ONE_STRING_ANOTHER.cpp:58:56: error: request
    dp [ 0 ] [ 0 ] = True				      	for ( int i = 0 ;					      dp [ 0 ] [ 0 ] = true ;					  for member ‘compare’ in ‘s1.std::__cxx11::basic_st
    for i in range ( len ( s1 ) ) :			      	i <= n ;						      for ( int i = 0 ;						  ring<char>::operator[](((std::__cxx11::basic_strin
	for j in range ( len ( s2 ) + 1 ) :		      	i ++ ) {						      i < s1 . length ( ) ;					  g<char>::size_type)i))’, which is of non-class typ
	    if ( dp [ i ] [ j ] ) :			      	  for ( int j = 0 ;					      i ++ ) {							  e ‘__gnu_cxx::__alloc_traits<std::allocator<char>,
		if ( ( j < len ( s2 ) and ( s1 [ i ].upper (  	  j <= m ;						    	for ( int j = 0 ;					   char>::value_type’ {aka ‘char’}	    if ( ( (
		    dp [ i + 1 ] [ j + 1 ] = True	      	  j ++ ) {						    	j < s2 . length ( ) + 1 ;				   j < s2 . length ( ) ) && ( s1 [ i ] . compare ( s
		if ( s1 [ i ].isupper ( ) == False ) :	      	    dp [ i ] [ j ] = false ;				    	j ++ ) {						  2 [ j ] ) == 0 ) ) ) dp [ i + 1 ] [ j + 1 ] = true
		    dp [ i + 1 ] [ j ] = True		      	  }							    	  if ( ( dp [ i ] [ j ] ) ) {				   ;
    return ( dp [ n ] [ m ] )				      	}							    	    if ( ( ( j < s2 . length ( ) ) && ( s1 [ i ] . compar 	   ^~~~~~~ CHECK_POSSIBLE_TRANSFORM_ONE_STRI
							      	dp [ 0 ] [ 0 ] = true ;					    	    if ( ( s1 [ i ] . isupper ( ) == false ) ) dp [ i + 1 NG_ANOTHER.cpp:59:27: error: request for member ‘i
							      	for ( int i = 0 ;					    	  }							  supper’ in ‘s1.std::__cxx11::basic_string<char>::o
							      	i < s1 . length ( ) ;					    	}							  perator[](((std::__cxx11::basic_string<char>::size
							      	i ++ ) {						      }								  _type)i))’, which is of non-class type ‘__gnu_cxx:
							      	  for ( int j = 0 ;					      return ( dp [ n ] [ m ] ) ;				  :__alloc_traits<std::allocator<char>, char>::value
							      	  j <= s2 . length ( ) ;				    }								  _type’ {aka ‘char’}	       if ( ( s1 [ i ] . isu
							      	  j ++ ) {						    								  pper ( ) == false ) ) dp [ i + 1 ] [ j ] = true ;
							      	    if ( dp [ i ] [ j ] ) {				    								  			     ^~~~~~~
							      	      if ( j < s2 . length ( ) && ( toupper ( s1 [ i ] ) == 								  
							      	      if ( ! isupper ( s1 [ i ] ) ) dp [ i + 1 ] [ j ] = tr 								  
							      	    }							    								  
							      	  }							    								  
							      	}							    								  
							      	return ( dp [ n ] [ m ] ) ;				    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING	      EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING	    EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING		  EVALUATE_A_BOOLEAN_EXPRESSION_REPRESENTED_AS_STRING
--							      --							    --								  --
def evaluateBoolExpr ( s ) :				      int evaluateBoolExpr ( string s ) {			    int evaluateBoolExpr ( string s ) {				  script_not_found : None
    n = len ( s )					      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
    for i in range ( 0 , n - 2 , 2 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( s [ i + 1 ] == "A" ) :			      	i < n ;							      i < n - 2 ;						  
	    if ( s [ i + 2 ] == "0" or s [ i ] == "0" ) :     	i += 2 ) {						      i += 2 ) {						  
		s [ i + 2 ] = "0"			      	  if ( s [ i + 1 ] == 'A' ) {				    	if ( ( s [ i + 1 ] == 'A' ) ) {				  
	    else :					      	    if ( s [ i + 2 ] == '0' || s [ i ] == '0' ) s [ i + 2 ] 	  if ( ( s [ i + 2 ] == '0' || s [ i ] == '0' ) ) s [ i + 
		s [ i + 2 ] = "1"			      	    else s [ i + 2 ] = '1' ;				    	  else s [ i + 2 ] = '1' ;				  
	elif ( s [ i + 1 ] == "B" ) :			      	  }							    	}							  
	    if ( s [ i + 2 ] == "1" or s [ i ] == "1" ) :     	  else if ( s [ i + 1 ] == 'B' ) {			    	else if ( ( s [ i + 1 ] == 'B' ) ) {			  
		s [ i + 2 ] = "1"			      	    if ( s [ i + 2 ] == '1' || s [ i ] == '1' ) s [ i + 2 ] 	  if ( ( s [ i + 2 ] == '1' || s [ i ] == '1' ) ) s [ i + 
	    else :					      	    else s [ i + 2 ] = '0' ;				    	  else s [ i + 2 ] = '0' ;				  
		s [ i + 2 ] = "0"			      	  }							    	}							  
	else :						      	  else {						    	else {							  
	    if ( s [ i + 2 ] == s [ i ] ) :		      	    if ( s [ i + 2 ] == s [ i ] ) s [ i + 2 ] = '0' ;	    	  if ( ( s [ i + 2 ] == s [ i ] ) ) s [ i + 2 ] = '0' ;	  
		s [ i + 2 ] = "0"			      	    else s [ i + 2 ] = '1' ;				    	  else s [ i + 2 ] = '1' ;				  
	    else :					      	  }							    	}							  
		s [ i + 2 ] = "1"			      	}							      }								  
    return ord ( s [ n - 1 ] ) - ord ( "0" )		      	return s [ n - 1 ] - '0' ;				      return ( int ) s [ n - 1 ] - ( int ) s [ n - 2 ] ;	  
							      }								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM			      PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM			    PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM				  PRINT_A_GIVEN_MATRIX_IN_SPIRAL_FORM
--							      --							    --								  --
def spiralPrint ( m , n , a ) :				      void spiralPrint ( int m , int n , int a [ R ] [ C ] ) {	    int spiralPrint ( int m , int n , int * a ) {		  script_not_found : None
    k = 0 l = 0						      	int i , k = 0 , l = 0 ;					      int k = 0 , l = 0 ;					  
    while ( k < m and l < n ) :				      	while ( k < m && l < n ) {				      while ( ( k < m ) && ( l < n ) ) {			  
	for i in range ( l , n ) :			      	  for ( i = l ;						    	for ( int i = l ;					  
	    print ( a [ k ] [ i ] , end = " " )		      	  i < n ;						    	i < n ;							  
	k += 1						      	  ++ i ) {						    	i ++ ) cout << a [ k ] [ i ] << " " ;			  
	for i in range ( k , m ) :			      	    cout << a [ k ] [ i ] << " " ;			    	k ++ ;							  
	    print ( a [ i ] [ n - 1 ] , end = " " )	      	  }							    	for ( int i = k ;					  
	n -= 1						      	  k ++ ;						    	i < m ;							  
	if ( k < m ) :					      	  for ( i = k ;						    	i ++ ) cout << a [ i ] [ n - 1 ] << " " ;		  
	    for i in range ( n - 1 , ( l - 1 ) , - 1 ) :      	  i < m ;						    	n -- ;							  
		print ( a [ m - 1 ] [ i ] , end = " " )	      	  ++ i ) {						    	if ( ( k < m ) ) for ( int i = n - 1 ;			  
	    m -= 1					      	    cout << a [ i ] [ n - 1 ] << " " ;			    	i >= ( l - 1 ) ;					  
	if ( l < n ) :					      	  }							    	i -- ) cout << a [ m - 1 ] [ i ] << " " ;		  
	    for i in range ( m - 1 , k - 1 , - 1 ) :	      	  n -- ;						    	m -- ;							  
		print ( a [ i ] [ l ] , end = " " )	      	  if ( k < m ) {					    	if ( ( l < n ) ) for ( int i = m - 1 ;			  
	    l += 1					      	    for ( i = n - 1 ;					    	i >= k - 1 ;						  
							      	    i >= l ;						    	i -- ) cout << a [ i ] [ l ] << " " ;			  
							      	    -- i ) {						    	l ++ ;							  
							      	      cout << a [ m - 1 ] [ i ] << " " ;		      }								  
							      	    }							      return m * m ;						  
							      	    m -- ;						      return m * m * m * m * m * m * m * m * m * m * m * m * m *  
							      	  }							    }								  
							      	  if ( l < n ) {					    								  
							      	    for ( i = m - 1 ;					    								  
							      	    i >= k ;						    								  
							      	    -- i ) {						    								  
							      	      cout << a [ i ] [ l ] << " " ;			    								  
							      	    }							    								  
							      	    l ++ ;						    								  
							      	  }							    								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1		      FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1		    FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1		  FIND_NUMBER_TIMES_STRING_OCCURS_GIVEN_STRING_1
--							      --							    --								  --
def count ( a , b ) :					      int count ( string a , string b ) {			    int count ( string a , string b ) {				  failure : #Results: 5, 10
    m = len ( a )					      	int m = a . length ( ) ;				      int m = a . length ( ) ;					  
    n = len ( b )					      	int n = b . length ( ) ;				      int n = b . length ( ) ;					  
    lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]   	int lookup [ m + 1 ] [ n + 1 ] = {			      vector < vector < int >> lookup ( m + 1 , vector < int > (  
    for i in range ( n + 1 ) :				      	  {							      for ( int i = 0 ;						  
	lookup [ 0 ] [ i ] = 0				      	    0 }							      i < n + 1 ;						  
    for i in range ( m + 1 ) :				      	  }							      i ++ ) lookup [ 0 ] [ i ] = 0 ;				  
	lookup [ i ] [ 0 ] = 1				      	  ;							      for ( int i = 0 ;						  
    for i in range ( 1 , m + 1 ) :			      	  for ( int i = 0 ;					      i < m + 1 ;						  
	for j in range ( 1 , n + 1 ) :			      	  i <= n ;						      i ++ ) lookup [ i ] [ 0 ] = 1 ;				  
	    if a [ i - 1 ] == b [ j - 1 ] :		      	  ++ i ) lookup [ 0 ] [ i ] = 0 ;			      for ( int i = 1 ;						  
		lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 	  for ( int i = 0 ;					      i < m + 1 ;						  
	    else :					      	  i <= m ;						      i ++ ) {							  
		lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ]   	  ++ i ) lookup [ i ] [ 0 ] = 1 ;			    	for ( int j = 1 ;					  
    return lookup [ m ] [ n ]				      	  for ( int i = 1 ;					    	j < n ;							  
							      	  i <= m ;						    	j ++ ) {						  
							      	  i ++ ) {						    	  if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ] =  
							      	    for ( int j = 1 ;					    	  else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ;	  
							      	    j <= n ;						    	}							  
							      	    j ++ ) {						      }								  
							      	      if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ]    return lookup [ m ] [ n ] ;				  
							      	      else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ;    }								  
							      	    }							    								  
							      	  }							    								  
							      	  return lookup [ m ] [ n ] ;				    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DISTANCE_NEAREST_CELL_1_BINARY_MATRIX			      DISTANCE_NEAREST_CELL_1_BINARY_MATRIX			    DISTANCE_NEAREST_CELL_1_BINARY_MATRIX			  DISTANCE_NEAREST_CELL_1_BINARY_MATRIX
--							      --							    --								  --
def printDistance ( mat ) :				      void printDistance ( int mat [ N ] [ M ] ) {		    int main ( int argc , char * * argv ) {			  script_not_found : None
    global N , M					      	int ans [ N ] [ M ] ;					      int i , j , k , l ;					  
    ans = [ [ None ] * M for i in range ( N ) ]		      	for ( int i = 0 ;					      vector < vector < int >> ans ( N , vector < int > ( M , 0 ) 
    for i in range ( N ) :				      	i < N ;							      for ( i = 0 ;						  
	for j in range ( M ) :				      	i ++ ) for ( int j = 0 ;				      i < N ;							  
	    ans [ i ] [ j ] = 999999999999		      	j < M ;							      i ++ ) {							  
    for i in range ( N ) :				      	j ++ ) ans [ i ] [ j ] = INT_MAX ;			    	for ( j = 0 ;						  
	for j in range ( M ) :				      	for ( int i = 0 ;					    	j < M ;							  
	    for k in range ( N ) :			      	i < N ;							    	j ++ ) ans [ i ] [ j ] = 999999999999 ;			  
		for l in range ( M ) :			      	i ++ ) for ( int j = 0 ;				      }								  
		    if ( mat [ k ] [ l ] == 1 ) :	      	j < M ;							      for ( i = 0 ;						  
			ans [ i ] [ j ] = min ( ans [ i ] [ j 	j ++ ) {						      i < N ;							  
    for i in range ( N ) :				      	  for ( int k = 0 ;					      i ++ ) {							  
	for j in range ( M ) :				      	  k < N ;						    	for ( j = 0 ;						  
	    print ( ans [ i ] [ j ] , end = " " )	      	  k ++ ) for ( int l = 0 ;				    	j < M ;							  
	print ( )					      	  l < M ;						    	j ++ ) {						  
							      	  l ++ ) {						    	  for ( k = 0 ;						  
							      	    if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = min ( ans 	  k < N ;						  
							      	  }							    	  k ++ ) {						  
							      	}							    	    for ( l = 0 ;					  
							      	for ( int i = 0 ;					    	    l < M ;						  
							      	i < N ;							    	    l ++ ) {						  
							      	i ++ ) {						    	      if ( ( mat [ k ] [ l ] == 1 ) ) ans [ i ] [ j ] = m 
							      	  for ( int j = 0 ;					    	    }							  
							      	  j < M ;						    	  }							  
							      	  j ++ ) cout << ans [ i ] [ j ] << " " ;		    	}							  
							      	  cout << endl ;					      }								  
							      	}							      for ( i = 0 ;						  
							      }								      i < N ;							  
							      								      i ++ ) {							  
							      								    	for ( j = 0 ;						  
							      								    	j < M ;							  
							      								    	j ++ ) cout << ans [ i ] [ j ] << " " ;			  
							      								    	cout << endl ;						  
							      								      }								  
							      								      return 0 ;						  
							      								      return 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 * 0 *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1		      DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1			    DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1			  DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1
--							      --							    --								  --
def isSubsetSum ( set , n , sum ) :			      bool isSubsetSum ( int set [ ] , int n , int sum ) {	    bool isSubsetSum ( int * set , int n , int sum ) {		  error : DYNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1.c
    subset = ( [ [ False for i in range ( sum + 1 ) ] for i i 	bool subset [ n + 1 ] [ sum + 1 ] ;			      vector < vector < bool >> subset ( sum + 1 , vector < bool  pp: In function ‘bool f_filled(int*, int, int)’: D
    for i in range ( n + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  YNAMIC_PROGRAMMING_SUBSET_SUM_PROBLEM_1.cpp:58:1:
	subset [ i ] [ 0 ] = True			      	i <= n ;						      i < n + 1 ;						  warning: no return statement in function returning
	for i in range ( 1 , sum + 1 ) :		      	i ++ ) subset [ i ] [ 0 ] = true ;			      i ++ ) {							   non-void [-Wreturn-type]  }	^ DYNAMIC_PROGRAMMIN
	    subset [ 0 ] [ i ] = False			      	for ( int i = 1 ;					    	subset [ i ] [ 0 ] = true ;				  G_SUBSET_SUM_PROBLEM_1.cpp: At global scope: DYNAM
	for i in range ( 1 , n + 1 ) :			      	i <= sum ;						    	for ( int i = 1 ;					  IC_PROGRAMMING_SUBSET_SUM_PROBLEM_1.cpp:59:1: erro
	    for j in range ( 1 , sum + 1 ) :		      	i ++ ) subset [ 0 ] [ i ] = false ;			    	i <= sum ;						  r: expected unqualified-id before ‘return’  return
		if j < set [ i - 1 ] :			      	for ( int i = 1 ;					    	i ++ ) subset [ 0 ] [ i ] = false ;			   subset [ n ] [ sum ] ;  ^~~~~~ DYNAMIC_PROGRAMMIN
		    subset [ i ] [ j ] = subset [ i - 1 ] [ j 	i <= n ;						    	for ( int i = 1 ;					  G_SUBSET_SUM_PROBLEM_1.cpp:60:1: error: expected d
		if j >= set [ i - 1 ] :			      	i ++ ) {						    	i <= n ;						  eclaration before ‘}’ token  }  ^
		    subset [ i ] [ j ] = ( subset [ i - 1 ] [ 	  for ( int j = 1 ;					    	i ++ ) {						  
    return subset [ n ] [ sum ]				      	  j <= sum ;						    	  for ( int j = 1 ;					  
							      	  j ++ ) {						    	  j <= sum ;						  
							      	    if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [  	  j ++ ) {						  
							      	    if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ 	    if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset  
							      	  }							    	    if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = ( subs 
							      	}							    	  }							  
							      	return subset [ n ] [ sum ] ;				    	}							  
							      }								      }								  
							      								    }								  
							      								    return subset [ n ] [ sum ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS     NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS	    NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS	  NUMBER_OF_WAYS_TO_ARRANGE_N_ITEMS_UNDER_GIVEN_CONSTRAINTS
--							      --							    --								  --
def waysToArrange ( N , K , k ) :			      int waysToArrange ( int N , int K , int k [ ] ) {		    double waysToArrange ( int N , int K , int * k ) {		  script_not_found : None
    C = np.zeros ( ( N + 1 , N + 1 ) )			      	int C [ N + 1 ] [ N + 1 ] ;				      vector < vector < int >> C ( N + 1 , vector < int > ( N + 1 
    for i in range ( N + 1 ) :				      	int i , j ;						      for ( int i = 0 ;						  
	for j in range ( i + 1 ) :			      	for ( i = 0 ;						      i < N + 1 ;						  
	    if ( j == 0 or j == i ) :			      	i <= N ;						      i ++ ) {							  
		C [ i ] [ j ] = 1			      	i ++ ) {						    	for ( int j = 0 ;					  
	    else :					      	  for ( j = 0 ;						    	j < i + 1 ;						  
		C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ 	  j <= i ;						    	j ++ ) {						  
    dp = np.zeros ( ( K + 1 ) )				      	  j ++ ) {						    	  if ( ( j == 0 || j == i ) ) C [ i ] [ j ] = 1 ;	  
    count = 0						      	    if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ;		    	  else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i -  
    dp [ 0 ] = 1					      	    else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i -  	}							  
    for i in range ( K ) :				      	  }							      }								  
	dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] 	}							      vector < double > dp ( K + 1 , 0.0 ) ;			  
	count += k [ i ]				      	int dp [ K ] ;						      int count = 0 ;						  
    return dp [ K ]					      	int count = 0 ;						      dp [ 0 ] = 1 ;						  
							      	dp [ 0 ] = 1 ;						      for ( int i = 0 ;						  
							      	for ( int i = 0 ;					      i < K ;							  
							      	i < K ;							      i ++ ) {							  
							      	i ++ ) {						    	dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k 
							      	  dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k 	count += k [ i ] ;					  
							      	  count += k [ i ] ;					      }								  
							      	}							      return dp [ K ] ;						  
							      	return dp [ K ] ;					    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2	      FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2	    FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2		  FIND_THE_TWO_REPEATING_ELEMENTS_IN_A_GIVEN_ARRAY_2
--							      --							    --								  --
def printRepeating ( arr , size ) :			      void printRepeating ( int arr [ ] , int size ) {		    int printRepeating ( int * arr , int size ) {		  script_not_found : None
    xor = arr [ 0 ]					      	int Xor = arr [ 0 ] ;					      int xor = arr [ 0 ] ;					  
    n = size - 2					      	int set_bit_no ;					      int n = size - 2 ;					  
    x = 0						      	int i ;							      int x = 0 ;						  
    y = 0						      	int n = size - 2 ;					      int y = 0 ;						  
    for i in range ( 1 , size ) :			      	int x = 0 , y = 0 ;					      for ( int i = 1 ;						  
	xor ^= arr [ i ]				      	for ( i = 1 ;						      i < size ;						  
    for i in range ( 1 , n + 1 ) :			      	i < size ;						      i ++ ) xor ^= arr [ i ] ;					  
	xor ^= i					      	i ++ ) Xor ^= arr [ i ] ;				      for ( int i = 1 ;						  
    set_bit_no = xor & ~ ( xor - 1 )			      	for ( i = 1 ;						      i <= n ;							  
    for i in range ( 0 , size ) :			      	i <= n ;						      i ++ ) xor ^= i ;						  
	if ( arr [ i ] & set_bit_no ) :			      	i ++ ) Xor ^= i ;					      int setBitNo = xor & ~ ( xor - 1 ) ;			  
	    x = x ^ arr [ i ]				      	set_bit_no = Xor & ~ ( Xor - 1 ) ;			      for ( int i = 0 ;						  
	else :						      	for ( i = 0 ;						      i < size ;						  
	    y = y ^ arr [ i ]				      	i < size ;						      i ++ ) {							  
    for i in range ( 1 , n + 1 ) :			      	i ++ ) {						    	if ( ( arr [ i ] & setBitNo ) != 0 ) x = x ^ arr [ i ] ;  
	if ( i & set_bit_no ) :				      	  if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ;	    	else y = y ^ arr [ i ] ;				  
	    x = x ^ i					      	  else y = y ^ arr [ i ] ;				      }								  
	else :						      	}							      for ( int i = 1 ;						  
	    y = y ^ i					      	for ( i = 1 ;						      i <= n ;							  
    print ( "The two repeating" , "elements are" , y , x )    	i <= n ;						      i ++ ) {							  
							      	i ++ ) {						    	if ( ( i & setBitNo ) != 0 ) x = x ^ i ;		  
							      	  if ( i & set_bit_no ) x = x ^ i ;			    	else y = y ^ i ;					  
							      	  else y = y ^ i ;					      }								  
							      	}							      cout << "The two repeating" << " elements are" << y << " an 
							      	cout << "The two repeating elements are " << y << " " << x    return y ;						  
							      }								      return size * size ;					  
							      								      return size * size * size * size * size * size * size * siz 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT
--							      --							    --								  --
def maxNumOfChocolates ( arr , n , k ) :		      int maxNumOfChocolates ( int arr [ ] , int n , int k ) {	    int maxNumOfChocolates ( int * arr , int n , int k ) {	  error : MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUA
    um , curr_rem , maxSum = { } , 0 , 0		      	unordered_map < int , int > um ;			      unordered_map < int , int > um , currRem , maxSum ;	  LLY_AMONG_K_STUDENTS.cpp: In function ‘int f_fille
    sm = [ 0 ] * n					      	int sum [ n ] , curr_rem ;				      int * sm = new int [ n ] ;				  d(int*, int, int)’: MAXIMUM_NUMBER_CHOCOLATES_DIST
    sm [ 0 ] = arr [ 0 ]				      	int maxSum = 0 ;					      sm [ 0 ] = arr [ 0 ] ;					  RIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:48:26: error:
    for i in range ( 1 , n ) :				      	sum [ 0 ] = arr [ 0 ] ;					      for ( int i = 1 ;						   no match for ‘operator=’ (operand types are ‘std:
	sm [ i ] = sm [ i - 1 ] + arr [ i ]		      	for ( int i = 1 ;					      i < n ;							  :unordered_map<int, int>’ and ‘int’)	    currRem
    for i in range ( n ) :				      	i < n ;							      i ++ ) sm [ i ] = sm [ i - 1 ] + arr [ i ] ;		  = sm [ i ] % k ;			     ^ In fi
	curr_rem = sm [ i ] % k				      	i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ;		      for ( int i = 0 ;						  le included from /usr/include/c++/8/unordered_map:
	if ( not curr_rem and maxSum < sm [ i ] ) :	      	for ( int i = 0 ;					      i < n ;							  47,		       from /usr/include/c++/8/x86_6
	    maxSum = sm [ i ]				      	i < n ;							      i ++ ) {							  4-redhat-linux/bits/stdc++.h:117,
	elif ( not curr_rem in um ) :			      	i ++ ) {						    	currRem = sm [ i ] % k ;				   from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALL
	    um [ curr_rem ] = i				      	  curr_rem = sum [ i ] % k ;				    	if ( ( ! currRem ) && maxSum < sm [ i ] ) maxSum = sm [ i Y_AMONG_K_STUDENTS.cpp:14: /usr/include/c++/8/bits
	elif ( maxSum < ( sm [ i ] - sm [ um [ curr_rem ] ] ) 	  if ( curr_rem == 0 ) {				    	else if ( ( ! currRem ) && um . count ( currRem ) ) um [  /unordered_map.h:271:7: note: candidate: ‘std::uno
	    maxSum = sm [ i ] - sm [ um [ curr_rem ] ]	      	    if ( maxSum < sum [ i ] ) maxSum = sum [ i ] ;	    	else if ( ( maxSum < ( sm [ i ] - sm [ um [ currRem ] ] ) rdered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& std::
    return maxSum // k					      	  }							      }								  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::op
							      	  else if ( um . find ( curr_rem ) == um . end ( ) ) um [ c   return maxSum / k ;					  erator=(const std::unordered_map<_Key, _Tp, _Hash,
							      	  else if ( maxSum < ( sum [ i ] - sum [ um [ curr_rem ] ]  }								   _Pred, _Alloc>&) [with _Key = int; _Tp = int; _Ha
							      	}							    								  sh = std::hash<int>; _Pred = std::equal_to<int>; _
							      	return ( maxSum / k ) ;					    								  Alloc = std::allocator<std::pair<const int, int> >
							      }								    								  ]’	    operator=(const unordered_map&) = defaul
							      								    								  t;	    ^~~~~~~~ /usr/include/c++/8/bits/unorder
							      								    								  ed_map.h:271:7: note:	  no known conversion for ar
							      								    								  gument 1 from ‘int’ to ‘const std::unordered_map<i
							      								    								  nt, int>&’ /usr/include/c++/8/bits/unordered_map.h
							      								    								  :275:7: note: candidate: ‘std::unordered_map<_Key,
							      								    								   _Tp, _Hash, _Pred, _Alloc>& std::unordered_map<_K
							      								    								  ey, _Tp, _Hash, _Pred, _Alloc>::operator=(std::uno
							      								    								  rdered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&&) [wi
							      								    								  th _Key = int; _Tp = int; _Hash = std::hash<int>;
							      								    								  _Pred = std::equal_to<int>; _Alloc = std::allocato
							      								    								  r<std::pair<const int, int> >]’	 operator=(u
							      								    								  nordered_map&&) = default;	    ^~~~~~~~ /usr/in
							      								    								  clude/c++/8/bits/unordered_map.h:275:7: note:	  no
							      								    								   known conversion for argument 1 from ‘int’ to ‘st
							      								    								  d::unordered_map<int, int>&&’ /usr/include/c++/8/b
							      								    								  its/unordered_map.h:289:7: note: candidate: ‘std::
							      								    								  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& st
							      								    								  d::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>:
							      								    								  :operator=(std::initializer_list<typename std::_Ha
							      								    								  shtable<_Key, std::pair<const _Key, _Tp>, _Alloc,
							      								    								  std::__detail::_Select1st, _Pred, _Hash, std::__de
							      								    								  tail::_Mod_range_hashing, std::__detail::_Default_
							      								    								  ranged_hash, std::__detail::_Prime_rehash_policy,
							      								    								  std::__detail::_Hashtable_traits<std::__not_<std::
							      								    								  __and_<std::__is_fast_hash<_Hash>, std::__is_nothr
							      								    								  ow_invocable<const _Hash&, const _Key&> > >::value
							      								    								  , false, true> >::value_type>) [with _Key = int; _
							      								    								  Tp = int; _Hash = std::hash<int>; _Pred = std::equ
							      								    								  al_to<int>; _Alloc = std::allocator<std::pair<cons
							      								    								  t int, int> >; typename std::_Hashtable<_Key, std:
							      								    								  :pair<const _Key, _Tp>, _Alloc, std::__detail::_Se
							      								    								  lect1st, _Pred, _Hash, std::__detail::_Mod_range_h
							      								    								  ashing, std::__detail::_Default_ranged_hash, std::
							      								    								  __detail::_Prime_rehash_policy, std::__detail::_Ha
							      								    								  shtable_traits<std::__not_<std::__and_<std::__is_f
							      								    								  ast_hash<_Hash>, std::__is_nothrow_invocable<const
							      								    								   _Hash&, const _Key&> > >::value, false, true> >::
							      								    								  value_type = std::pair<const int, int>]’	  op
							      								    								  erator=(initializer_list<value_type> __l)	   ^
							      								    								  ~~~~~~~ /usr/include/c++/8/bits/unordered_map.h:28
							      								    								  9:7: note:   no known conversion for argument 1 fr
							      								    								  om ‘int’ to ‘std::initializer_list<std::pair<const
							      								    								   int, int> >’ MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTE
							      								    								  D_EQUALLY_AMONG_K_STUDENTS.cpp:49:12: error: no ma
							      								    								  tch for ‘operator!’ (operand type is ‘std::unorder
							      								    								  ed_map<int, int>’)	  if ( ( ! currRem ) && maxS
							      								    								  um < sm [ i ] ) maxSum = sm [ i ] ;		  ^~
							      								    								  ~~~~~~~ MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUA
							      								    								  LLY_AMONG_K_STUDENTS.cpp:49:12: note: candidate: ‘
							      								    								  operator!(bool)’ <built-in> MAXIMUM_NUMBER_CHOCOLA
							      								    								  TES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:12
							      								    								  : note:   no known conversion for argument 1 from
							      								    								  ‘std::unordered_map<int, int>’ to ‘bool’ MAXIMUM_N
							      								    								  UMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDE
							      								    								  NTS.cpp:49:34: error: no match for ‘operator<’ (op
							      								    								  erand types are ‘std::unordered_map<int, int>’ and
							      								    								   ‘int’)      if ( ( ! currRem ) && maxSum < sm [ i
							      								    								   ] ) maxSum = sm [ i ] ;
							      								    								    ~~~~~~~^~~~~~~~~~ In file included from /usr/inc
							      								    								  lude/c++/8/regex:62,			from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  		    from MAXIMUM_NUMBER_CHOCOLATES_D
							      								    								  ISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/i
							      								    								  nclude/c++/8/bits/regex.h:1002:5: note: candidate:
							      								    								   ‘template<class _BiIter> bool std::__cxx11::opera
							      								    								  tor<(const std::__cxx11::sub_match<_BiIter>&, cons
							      								    								  t std::__cxx11::sub_match<_BiIter>&)’	     operato
							      								    								  r<(const sub_match<_BiIter>& __lhs, const sub_matc
							      								    								  h<_BiIter>& __rhs)	  ^~~~~~~~ /usr/include/c++/
							      								    								  8/bits/regex.h:1002:5: note:	 template argument d
							      								    								  eduction/substitution failed: MAXIMUM_NUMBER_CHOCO
							      								    								  LATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:
							      								    								  43: note:   ‘std::unordered_map<int, int>’ is not
							      								    								  derived from ‘const std::__cxx11::sub_match<_BiIte
							      								    								  r>’	   if ( ( ! currRem ) && maxSum < sm [ i ] )
							      								    								   maxSum = sm [ i ] ;
							      								    								  		^ In file included from /usr/include
							      								    								  /c++/8/regex:62,		    from /usr/includ
							      								    								  e/c++/8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  		from MAXIMUM_NUMBER_CHOCOLATES_DISTR
							      								    								  IBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/inclu
							      								    								  de/c++/8/bits/regex.h:1081:5: note: candidate: ‘te
							      								    								  mplate<class _Bi_iter, class _Ch_traits, class _Ch
							      								    								  _alloc> bool std::__cxx11::operator<(std::__cxx11:
							      								    								  :__sub_match_string<_Bi_iter, _Ch_traits, _Ch_allo
							      								    								  c>&, const std::__cxx11::sub_match<_BiIter>&)’
							      								    								    operator<(const __sub_match_string<_Bi_iter, _Ch
							      								    								  _traits, _Ch_alloc>& __lhs,	   ^~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/regex.h:1081:5: note:	  template a
							      								    								  rgument deduction/substitution failed: MAXIMUM_NUM
							      								    								  BER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT
							      								    								  S.cpp:49:43: note:   ‘std::unordered_map<int, int>
							      								    								  ’ is not derived from ‘std::__cxx11::__sub_match_s
							      								    								  tring<_Bi_iter, _Ch_traits, _Ch_alloc>’      if (
							      								    								  ( ! currRem ) && maxSum < sm [ i ] ) maxSum = sm [
							      								    								   i ] ;
							      								    								  ^ In file included from /usr/include/c++/8/regex:6
							      								    								  2,		      from /usr/include/c++/8/x86_64
							      								    								  -redhat-linux/bits/stdc++.h:110,
							      								    								  from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY
							      								    								  _AMONG_K_STUDENTS.cpp:14: /usr/include/c++/8/bits/
							      								    								  regex.h:1161:5: note: candidate: ‘template<class _
							      								    								  Bi_iter, class _Ch_traits, class _Ch_alloc> bool s
							      								    								  td::__cxx11::operator<(const std::__cxx11::sub_mat
							      								    								  ch<_BiIter>&, std::__cxx11::__sub_match_string<_Bi
							      								    								  _iter, _Ch_traits, _Ch_alloc>&)’	operator<(co
							      								    								  nst sub_match<_Bi_iter>& __lhs,      ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/regex.h:1161:5: note:   templa
							      								    								  te argument deduction/substitution failed: MAXIMUM
							      								    								  _NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STU
							      								    								  DENTS.cpp:49:43: note:   ‘std::unordered_map<int,
							      								    								  int>’ is not derived from ‘const std::__cxx11::sub
							      								    								  _match<_BiIter>’	if ( ( ! currRem ) && maxSum
							      								    								   < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  			     ^ In file included from
							      								    								   /usr/include/c++/8/regex:62,			 fro
							      								    								  m /usr/include/c++/8/x86_64-redhat-linux/bits/stdc
							      								    								  ++.h:110,		     from MAXIMUM_NUMBER_CHO
							      								    								  COLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:1
							      								    								  4: /usr/include/c++/8/bits/regex.h:1238:5: note: c
							      								    								  andidate: ‘template<class _Bi_iter> bool std::__cx
							      								    								  x11::operator<(const typename std::iterator_traits
							      								    								  <_Iter>::value_type*, const std::__cxx11::sub_matc
							      								    								  h<_BiIter>&)’	     operator<(typename iterator_tra
							      								    								  its<_Bi_iter>::value_type const* __lhs,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/regex.h:1238:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMO
							      								    								  NG_K_STUDENTS.cpp:49:43: note:   mismatched types
							      								    								  ‘const std::__cxx11::sub_match<_BiIter>’ and ‘int’
							      								    								  	if ( ( ! currRem ) && maxSum < sm [ i ] ) ma
							      								    								  xSum = sm [ i ] ;
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/regex:62,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:110,
							      								    								  	     from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBU
							      								    								  TED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/include/
							      								    								  c++/8/bits/regex.h:1312:5: note: candidate: ‘templ
							      								    								  ate<class _Bi_iter> bool std::__cxx11::operator<(c
							      								    								  onst std::__cxx11::sub_match<_BiIter>&, const type
							      								    								  name std::iterator_traits<_Iter>::value_type*)’
							      								    								     operator<(const sub_match<_Bi_iter>& __lhs,
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/regex.h:1312:5:
							      								    								   note:   template argument deduction/substitution
							      								    								  failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUA
							      								    								  LLY_AMONG_K_STUDENTS.cpp:49:43: note:	  ‘std::unor
							      								    								  dered_map<int, int>’ is not derived from ‘const st
							      								    								  d::__cxx11::sub_match<_BiIter>’      if ( ( ! curr
							      								    								  Rem ) && maxSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  					    ^ In fil
							      								    								  e included from /usr/include/c++/8/regex:62,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:110,		    from MAX
							      								    								  IMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K
							      								    								  _STUDENTS.cpp:14: /usr/include/c++/8/bits/regex.h:
							      								    								  1389:5: note: candidate: ‘template<class _Bi_iter>
							      								    								   bool std::__cxx11::operator<(const typename std::
							      								    								  iterator_traits<_Iter>::value_type&, const std::__
							      								    								  cxx11::sub_match<_BiIter>&)’	    operator<(typena
							      								    								  me iterator_traits<_Bi_iter>::value_type const& __
							      								    								  lhs,	    ^~~~~~~~ /usr/include/c++/8/bits/regex.h
							      								    								  :1389:5: note:   template argument deduction/subst
							      								    								  itution failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBU
							      								    								  TED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43: note:	  mi
							      								    								  smatched types ‘const std::__cxx11::sub_match<_BiI
							      								    								  ter>’ and ‘int’      if ( ( ! currRem ) && maxSum
							      								    								  < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  			    ^ In file included from
							      								    								  /usr/include/c++/8/regex:62,			from
							      								    								   /usr/include/c++/8/x86_64-redhat-linux/bits/stdc+
							      								    								  +.h:110,		    from MAXIMUM_NUMBER_CHOC
							      								    								  OLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14
							      								    								  : /usr/include/c++/8/bits/regex.h:1469:5: note: ca
							      								    								  ndidate: ‘template<class _Bi_iter> bool std::__cxx
							      								    								  11::operator<(const std::__cxx11::sub_match<_BiIte
							      								    								  r>&, const typename std::iterator_traits<_Iter>::v
							      								    								  alue_type&)’	    operator<(const sub_match<_Bi_it
							      								    								  er>& __lhs,	   ^~~~~~~~ /usr/include/c++/8/bits/
							      								    								  regex.h:1469:5: note:	  template argument deductio
							      								    								  n/substitution failed: MAXIMUM_NUMBER_CHOCOLATES_D
							      								    								  ISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43: not
							      								    								  e:   ‘std::unordered_map<int, int>’ is not derived
							      								    								   from ‘const std::__cxx11::sub_match<_BiIter>’
							      								    								    if ( ( ! currRem ) && maxSum < sm [ i ] ) maxSum
							      								    								   = sm [ i ] ;
							      								    								  	 ^ In file included from /usr/include/c++/8/
							      								    								  bits/stl_algobase.h:64,		   from /usr
							      								    								  /include/c++/8/bits/char_traits.h:39,
							      								    								       from /usr/include/c++/8/ios:40,
							      								    								      from /usr/include/c++/8/ostream:38,
							      								    								  	 from /usr/include/c++/8/iostream:39,
							      								    								  	     from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBU
							      								    								  TED_EQUALLY_AMONG_K_STUDENTS.cpp:8: /usr/include/c
							      								    								  ++/8/bits/stl_pair.h:454:5: note: candidate: ‘temp
							      								    								  late<class _T1, class _T2> constexpr bool std::ope
							      								    								  rator<(const std::pair<_T1, _T2>&, const std::pair
							      								    								  <_T1, _T2>&)’	     operator<(const pair<_T1, _T2>&
							      								    								   __x, const pair<_T1, _T2>& __y)	^~~~~~~~ /us
							      								    								  r/include/c++/8/bits/stl_pair.h:454:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: MAXI
							      								    								  MUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_
							      								    								  STUDENTS.cpp:49:43: note:   ‘std::unordered_map<in
							      								    								  t, int>’ is not derived from ‘const std::pair<_T1,
							      								    								   _T2>’      if ( ( ! currRem ) && maxSum < sm [ i
							      								    								  ] ) maxSum = sm [ i ] ;
							      								    								  		   ^ In file included from /usr/incl
							      								    								  ude/c++/8/bits/stl_algobase.h:67,
							      								    								   from /usr/include/c++/8/bits/char_traits.h:39,
							      								    								  		 from /usr/include/c++/8/ios:40,
							      								    								  		from /usr/include/c++/8/ostream:38,
							      								    								  		   from /usr/include/c++/8/iostream:
							      								    								  39,		       from MAXIMUM_NUMBER_CHOCOLATE
							      								    								  S_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:8: /usr
							      								    								  /include/c++/8/bits/stl_iterator.h:308:5: note: ca
							      								    								  ndidate: ‘template<class _Iterator> bool std::oper
							      								    								  ator<(const std::reverse_iterator<_Iterator>&, con
							      								    								  st std::reverse_iterator<_Iterator>&)’      operat
							      								    								  or<(const reverse_iterator<_Iterator>& __x,	   ^
							      								    								  ~~~~~~~ /usr/include/c++/8/bits/stl_iterator.h:308
							      								    								  :5: note:   template argument deduction/substituti
							      								    								  on failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_E
							      								    								  QUALLY_AMONG_K_STUDENTS.cpp:49:43: note:   ‘std::u
							      								    								  nordered_map<int, int>’ is not derived from ‘const
							      								    								   std::reverse_iterator<_Iterator>’	  if ( ( ! c
							      								    								  urrRem ) && maxSum < sm [ i ] ) maxSum = sm [ i ]
							      								    								  ;					       ^ In
							      								    								  file included from /usr/include/c++/8/bits/stl_alg
							      								    								  obase.h:67,		       from /usr/include/c++
							      								    								  /8/bits/char_traits.h:39,		     from /u
							      								    								  sr/include/c++/8/ios:40,		    from /us
							      								    								  r/include/c++/8/ostream:38,		       from
							      								    								  /usr/include/c++/8/iostream:39,		   f
							      								    								  rom MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_
							      								    								  AMONG_K_STUDENTS.cpp:8: /usr/include/c++/8/bits/st
							      								    								  l_iterator.h:346:5: note: candidate: ‘template<cla
							      								    								  ss _IteratorL, class _IteratorR> bool std::operato
							      								    								  r<(const std::reverse_iterator<_Iterator>&, const
							      								    								  std::reverse_iterator<_IteratorR>&)’	    operator
							      								    								  <(const reverse_iterator<_IteratorL>& __x,	  ^~
							      								    								  ~~~~~~ /usr/include/c++/8/bits/stl_iterator.h:346:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQ
							      								    								  UALLY_AMONG_K_STUDENTS.cpp:49:43: note:   ‘std::un
							      								    								  ordered_map<int, int>’ is not derived from ‘const
							      								    								  std::reverse_iterator<_Iterator>’	 if ( ( ! cu
							      								    								  rrRem ) && maxSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/bits/stl_algo
							      								    								  base.h:67,		      from /usr/include/c++/
							      								    								  8/bits/char_traits.h:39,		    from /us
							      								    								  r/include/c++/8/ios:40,		   from /usr
							      								    								  /include/c++/8/ostream:38,		      from /
							      								    								  usr/include/c++/8/iostream:39,		  fr
							      								    								  om MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_A
							      								    								  MONG_K_STUDENTS.cpp:8: /usr/include/c++/8/bits/stl
							      								    								  _iterator.h:1139:5: note: candidate: ‘template<cla
							      								    								  ss _IteratorL, class _IteratorR> bool std::operato
							      								    								  r<(const std::move_iterator<_IteratorL>&, const st
							      								    								  d::move_iterator<_IteratorR>&)’      operator<(con
							      								    								  st move_iterator<_IteratorL>& __x,	  ^~~~~~~~ /
							      								    								  usr/include/c++/8/bits/stl_iterator.h:1139:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_A
							      								    								  MONG_K_STUDENTS.cpp:49:43: note:   ‘std::unordered
							      								    								  _map<int, int>’ is not derived from ‘const std::mo
							      								    								  ve_iterator<_IteratorL>’	if ( ( ! currRem ) &
							      								    								  & maxSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/bits/stl_algobase.h:67
							      								    								  ,		     from /usr/include/c++/8/bits/ch
							      								    								  ar_traits.h:39,		   from /usr/include
							      								    								  /c++/8/ios:40,		  from /usr/include/
							      								    								  c++/8/ostream:38,		     from /usr/inclu
							      								    								  de/c++/8/iostream:39,			 from MAXIMU
							      								    								  M_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_ST
							      								    								  UDENTS.cpp:8: /usr/include/c++/8/bits/stl_iterator
							      								    								  .h:1145:5: note: candidate: ‘template<class _Itera
							      								    								  tor> bool std::operator<(const std::move_iterator<
							      								    								  _IteratorL>&, const std::move_iterator<_IteratorL>
							      								    								  &)’	   operator<(const move_iterator<_Iterator>&
							      								    								   __x,	     ^~~~~~~~ /usr/include/c++/8/bits/stl_it
							      								    								  erator.h:1145:5: note:   template argument deducti
							      								    								  on/substitution failed: MAXIMUM_NUMBER_CHOCOLATES_
							      								    								  DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43: no
							      								    								  te:	‘std::unordered_map<int, int>’ is not derive
							      								    								  d from ‘const std::move_iterator<_IteratorL>’
							      								    								   if ( ( ! currRem ) && maxSum < sm [ i ] ) maxSum
							      								    								  = sm [ i ] ;
							      								    								  	^ In file included from /usr/include/c++/8/s
							      								    								  tring:52,		     from /usr/include/c++/8
							      								    								  /bits/locale_classes.h:40,		      from /
							      								    								  usr/include/c++/8/bits/ios_base.h:41,
							      								    								       from /usr/include/c++/8/ios:42,
							      								    								      from /usr/include/c++/8/ostream:38,
							      								    								  	 from /usr/include/c++/8/iostream:39,
							      								    								  	     from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBU
							      								    								  TED_EQUALLY_AMONG_K_STUDENTS.cpp:8: /usr/include/c
							      								    								  ++/8/bits/basic_string.h:6133:5: note: candidate:
							      								    								  ‘template<class _CharT, class _Traits, class _Allo
							      								    								  c> bool std::operator<(const std::__cxx11::basic_s
							      								    								  tring<_CharT, _Traits, _Alloc>&, const std::__cxx1
							      								    								  1::basic_string<_CharT, _Traits, _Alloc>&)’	   o
							      								    								  perator<(const basic_string<_CharT, _Traits, _Allo
							      								    								  c>& __lhs,	  ^~~~~~~~ /usr/include/c++/8/bits/b
							      								    								  asic_string.h:6133:5: note:	template argument de
							      								    								  duction/substitution failed: MAXIMUM_NUMBER_CHOCOL
							      								    								  ATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:4
							      								    								  3: note:   ‘std::unordered_map<int, int>’ is not d
							      								    								  erived from ‘const std::__cxx11::basic_string<_Cha
							      								    								  rT, _Traits, _Alloc>’	     if ( ( ! currRem ) && m
							      								    								  axSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  				  ^ In file included
							      								    								   from /usr/include/c++/8/string:52,
							      								    								     from /usr/include/c++/8/bits/locale_classes.h:4
							      								    								  0,		      from /usr/include/c++/8/bits/i
							      								    								  os_base.h:41,			 from /usr/include/c
							      								    								  ++/8/ios:42,			from /usr/include/c+
							      								    								  +/8/ostream:38,		   from /usr/include
							      								    								  /c++/8/iostream:39,		       from MAXIMUM_
							      								    								  NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUD
							      								    								  ENTS.cpp:8: /usr/include/c++/8/bits/basic_string.h
							      								    								  :6146:5: note: candidate: ‘template<class _CharT,
							      								    								  class _Traits, class _Alloc> bool std::operator<(c
							      								    								  onst std::__cxx11::basic_string<_CharT, _Traits, _
							      								    								  Alloc>&, const _CharT*)’	operator<(const basi
							      								    								  c_string<_CharT, _Traits, _Alloc>& __lhs,	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/bits/basic_string.h:6146:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQ
							      								    								  UALLY_AMONG_K_STUDENTS.cpp:49:43: note:   ‘std::un
							      								    								  ordered_map<int, int>’ is not derived from ‘const
							      								    								  std::__cxx11::basic_string<_CharT, _Traits, _Alloc
							      								    								  >’	  if ( ( ! currRem ) && maxSum < sm [ i ] )
							      								    								  maxSum = sm [ i ] ;
							      								    								  	       ^ In file included from /usr/include/
							      								    								  c++/8/string:52,		    from /usr/includ
							      								    								  e/c++/8/bits/locale_classes.h:40,
							      								    								   from /usr/include/c++/8/bits/ios_base.h:41,
							      								    								  	      from /usr/include/c++/8/ios:42,
							      								    								  	     from /usr/include/c++/8/ostream:38,
							      								    								  		from /usr/include/c++/8/iostream:39,
							      								    								  		    from MAXIMUM_NUMBER_CHOCOLATES_D
							      								    								  ISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:8: /usr/in
							      								    								  clude/c++/8/bits/basic_string.h:6158:5: note: cand
							      								    								  idate: ‘template<class _CharT, class _Traits, clas
							      								    								  s _Alloc> bool std::operator<(const _CharT*, const
							      								    								   std::__cxx11::basic_string<_CharT, _Traits, _Allo
							      								    								  c>&)’	     operator<(const _CharT* __lhs,	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/bits/basic_string.h:6158:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQ
							      								    								  UALLY_AMONG_K_STUDENTS.cpp:49:43: note:   mismatch
							      								    								  ed types ‘const _CharT*’ and ‘std::unordered_map<i
							      								    								  nt, int>’	 if ( ( ! currRem ) && maxSum < sm [
							      								    								   i ] ) maxSum = sm [ i ] ;
							      								    								  		      ^ In file included from /usr/i
							      								    								  nclude/c++/8/bits/ios_base.h:46,
							      								    								  from /usr/include/c++/8/ios:42,		   f
							      								    								  rom /usr/include/c++/8/ostream:38,
							      								    								    from /usr/include/c++/8/iostream:39,
							      								    								  	from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_E
							      								    								  QUALLY_AMONG_K_STUDENTS.cpp:8: /usr/include/c++/8/
							      								    								  system_error:208:3: note: candidate: ‘bool std::op
							      								    								  erator<(const std::error_code&, const std::error_c
							      								    								  ode&)’    operator<(const error_code& __lhs, const
							      								    								   error_code& __rhs) noexcept	  ^~~~~~~~ /usr/incl
							      								    								  ude/c++/8/system_error:208:3: note:	no known con
							      								    								  version for argument 1 from ‘std::unordered_map<in
							      								    								  t, int>’ to ‘const std::error_code&’ /usr/include/
							      								    								  c++/8/system_error:282:3: note: candidate: ‘bool s
							      								    								  td::operator<(const std::error_condition&, const s
							      								    								  td::error_condition&)’    operator<(const error_co
							      								    								  ndition& __lhs,    ^~~~~~~~ /usr/include/c++/8/sys
							      								    								  tem_error:282:3: note:   no known conversion for a
							      								    								  rgument 1 from ‘std::unordered_map<int, int>’ to ‘
							      								    								  const std::error_condition&’ In file included from
							      								    								   /usr/include/c++/8/vector:64,		  fr
							      								    								  om MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_A
							      								    								  MONG_K_STUDENTS.cpp:11: /usr/include/c++/8/bits/st
							      								    								  l_vector.h:1770:5: note: candidate: ‘template<clas
							      								    								  s _Tp, class _Alloc> bool std::operator<(const std
							      								    								  ::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Al
							      								    								  loc>&)’      operator<(const vector<_Tp, _Alloc>&
							      								    								  __x, const vector<_Tp, _Alloc>& __y)	    ^~~~~~~~
							      								    								   /usr/include/c++/8/bits/stl_vector.h:1770:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_A
							      								    								  MONG_K_STUDENTS.cpp:49:43: note:   ‘std::unordered
							      								    								  _map<int, int>’ is not derived from ‘const std::ve
							      								    								  ctor<_Tp, _Alloc>’	  if ( ( ! currRem ) && maxS
							      								    								  um < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  			       ^ In file included fr
							      								    								  om /usr/include/c++/8/tuple:39,		   f
							      								    								  rom /usr/include/c++/8/bits/unique_ptr.h:37,
							      								    								  	      from /usr/include/c++/8/bits/locale_co
							      								    								  nv.h:41,		    from /usr/include/c++/8/
							      								    								  locale:43,		      from /usr/include/c++/
							      								    								  8/iomanip:43,			 from MAXIMUM_NUMBER
							      								    								  _CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.c
							      								    								  pp:13: /usr/include/c++/8/array:262:5: note: candi
							      								    								  date: ‘template<class _Tp, long unsigned int _Nm>
							      								    								  bool std::operator<(const std::array<_Tp, _Nm>&, c
							      								    								  onst std::array<_Tp, _Nm>&)’	    operator<(const
							      								    								  array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
							      								    								       ^~~~~~~~ /usr/include/c++/8/array:262:5: note
							      								    								  :   template argument deduction/substitution faile
							      								    								  d: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_A
							      								    								  MONG_K_STUDENTS.cpp:49:43: note:   ‘std::unordered
							      								    								  _map<int, int>’ is not derived from ‘const std::ar
							      								    								  ray<_Tp, _Nm>’      if ( ( ! currRem ) && maxSum <
							      								    								   sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  			   ^ In file included from /
							      								    								  usr/include/c++/8/bits/unique_ptr.h:37,
							      								    								  	 from /usr/include/c++/8/bits/locale_conv.h:
							      								    								  41,		       from /usr/include/c++/8/local
							      								    								  e:43,			 from /usr/include/c++/8/iom
							      								    								  anip:43,		    from MAXIMUM_NUMBER_CHOC
							      								    								  OLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:13
							      								    								  : /usr/include/c++/8/tuple:1426:5: note: candidate
							      								    								  : ‘template<class ... _TElements, class ... _UElem
							      								    								  ents> constexpr bool std::operator<(const std::tup
							      								    								  le<_Tps ...>&, const std::tuple<_Elements ...>&)’
							      								    								       operator<(const tuple<_TElements...>& __t,
							      								    								     ^~~~~~~~ /usr/include/c++/8/tuple:1426:5: note:
							      								    								     template argument deduction/substitution failed
							      								    								  : MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AM
							      								    								  ONG_K_STUDENTS.cpp:49:43: note:   ‘std::unordered_
							      								    								  map<int, int>’ is not derived from ‘const std::tup
							      								    								  le<_Tps ...>’	     if ( ( ! currRem ) && maxSum <
							      								    								  sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  			  ^ In file included from /u
							      								    								  sr/include/c++/8/bits/locale_conv.h:41,
							      								    								  	 from /usr/include/c++/8/locale:43,
							      								    								  	   from /usr/include/c++/8/iomanip:43,
							      								    								  	      from MAXIMUM_NUMBER_CHOCOLATES_DISTRIB
							      								    								  UTED_EQUALLY_AMONG_K_STUDENTS.cpp:13: /usr/include
							      								    								  /c++/8/bits/unique_ptr.h:727:5: note: candidate: ‘
							      								    								  template<class _Tp, class _Dp, class _Up, class _E
							      								    								  p> bool std::operator<(const std::unique_ptr<_Tp,
							      								    								  _Dp>&, const std::unique_ptr<_Up, _Ep>&)’	 ope
							      								    								  rator<(const unique_ptr<_Tp, _Dp>& __x,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/unique_ptr.h:727:5: no
							      								    								  te:	template argument deduction/substitution fai
							      								    								  led: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY
							      								    								  _AMONG_K_STUDENTS.cpp:49:43: note:   ‘std::unorder
							      								    								  ed_map<int, int>’ is not derived from ‘const std::
							      								    								  unique_ptr<_Tp, _Dp>’	     if ( ( ! currRem ) && m
							      								    								  axSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  				  ^ In file included
							      								    								   from /usr/include/c++/8/bits/locale_conv.h:41,
							      								    								  		 from /usr/include/c++/8/locale:43,
							      								    								  		   from /usr/include/c++/8/iomanip:4
							      								    								  3,		      from MAXIMUM_NUMBER_CHOCOLATES
							      								    								  _DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:13: /usr
							      								    								  /include/c++/8/bits/unique_ptr.h:738:5: note: cand
							      								    								  idate: ‘template<class _Tp, class _Dp> bool std::o
							      								    								  perator<(const std::unique_ptr<_Tp, _Dp>&, std::nu
							      								    								  llptr_t)’	 operator<(const unique_ptr<_Tp, _Dp
							      								    								  >& __x, nullptr_t)	  ^~~~~~~~ /usr/include/c++/
							      								    								  8/bits/unique_ptr.h:738:5: note:   template argume
							      								    								  nt deduction/substitution failed: MAXIMUM_NUMBER_C
							      								    								  HOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp
							      								    								  :49:43: note:	  ‘std::unordered_map<int, int>’ is
							      								    								  not derived from ‘const std::unique_ptr<_Tp, _Dp>’
							      								    								  	if ( ( ! currRem ) && maxSum < sm [ i ] ) ma
							      								    								  xSum = sm [ i ] ;
							      								    								  	     ^ In file included from /usr/include/c+
							      								    								  +/8/bits/locale_conv.h:41,		      from /
							      								    								  usr/include/c++/8/locale:43,			from
							      								    								   /usr/include/c++/8/iomanip:43,		   f
							      								    								  rom MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_
							      								    								  AMONG_K_STUDENTS.cpp:13: /usr/include/c++/8/bits/u
							      								    								  nique_ptr.h:744:5: note: candidate: ‘template<clas
							      								    								  s _Tp, class _Dp> bool std::operator<(std::nullptr
							      								    								  _t, const std::unique_ptr<_Tp, _Dp>&)’      operat
							      								    								  or<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
							      								    								     ^~~~~~~~ /usr/include/c++/8/bits/unique_ptr.h:7
							      								    								  44:5: note:	template argument deduction/substitu
							      								    								  tion failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED
							      								    								  _EQUALLY_AMONG_K_STUDENTS.cpp:49:43: note:   misma
							      								    								  tched types ‘const std::unique_ptr<_Tp, _Dp>’ and
							      								    								  ‘int’	     if ( ( ! currRem ) && maxSum < sm [ i ]
							      								    								   ) maxSum = sm [ i ] ;
							      								    								  		  ^ In file included from /usr/inclu
							      								    								  de/c++/8/deque:64,		      from /usr/incl
							      								    								  ude/c++/8/x86_64-redhat-linux/bits/stdc++.h:68,
							      								    								  		 from MAXIMUM_NUMBER_CHOCOLATES_DIST
							      								    								  RIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/incl
							      								    								  ude/c++/8/bits/stl_deque.h:294:5: note: candidate:
							      								    								   ‘template<class _Tp, class _Ref, class _Ptr> bool
							      								    								   std::operator<(const std::_Deque_iterator<_Tp, _R
							      								    								  ef, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,
							      								    								  _Ptr>&)’	operator<(const _Deque_iterator<_Tp,
							      								    								   _Ref, _Ptr>& __x,	  ^~~~~~~~ /usr/include/c++/
							      								    								  8/bits/stl_deque.h:294:5: note:   template argumen
							      								    								  t deduction/substitution failed: MAXIMUM_NUMBER_CH
							      								    								  OCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:
							      								    								  49:43: note:	 ‘std::unordered_map<int, int>’ is n
							      								    								  ot derived from ‘const std::_Deque_iterator<_Tp, _
							      								    								  Ref, _Ptr>’	   if ( ( ! currRem ) && maxSum < sm
							      								    								   [ i ] ) maxSum = sm [ i ] ;
							      								    								  			^ In file included from /usr
							      								    								  /include/c++/8/deque:64,		    from /us
							      								    								  r/include/c++/8/x86_64-redhat-linux/bits/stdc++.h:
							      								    								  68,		       from MAXIMUM_NUMBER_CHOCOLATE
							      								    								  S_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /us
							      								    								  r/include/c++/8/bits/stl_deque.h:302:5: note: cand
							      								    								  idate: ‘template<class _Tp, class _RefL, class _Pt
							      								    								  rL, class _RefR, class _PtrR> bool std::operator<(
							      								    								  const std::_Deque_iterator<_Tp, _Ref, _Ptr>&, cons
							      								    								  t std::_Deque_iterator<_Tp, _RefR, _PtrR>&)’
							      								    								  operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>
							      								    								  & __x,      ^~~~~~~~ /usr/include/c++/8/bits/stl_d
							      								    								  eque.h:302:5: note:	template argument deduction/
							      								    								  substitution failed: MAXIMUM_NUMBER_CHOCOLATES_DIS
							      								    								  TRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43: note:
							      								    								     ‘std::unordered_map<int, int>’ is not derived f
							      								    								  rom ‘const std::_Deque_iterator<_Tp, _Ref, _Ptr>’
							      								    								       if ( ( ! currRem ) && maxSum < sm [ i ] ) max
							      								    								  Sum = sm [ i ] ;
							      								    								  	    ^ In file included from /usr/include/c++
							      								    								  /8/deque:64,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:68,
							      								    								  	   from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTE
							      								    								  D_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/include/c+
							      								    								  +/8/bits/stl_deque.h:2295:5: note: candidate: ‘tem
							      								    								  plate<class _Tp, class _Alloc> bool std::operator<
							      								    								  (const std::deque<_Tp, _Alloc>&, const std::deque<
							      								    								  _Tp, _Alloc>&)’      operator<(const deque<_Tp, _A
							      								    								  lloc>& __x,	   ^~~~~~~~ /usr/include/c++/8/bits/
							      								    								  stl_deque.h:2295:5: note:   template argument dedu
							      								    								  ction/substitution failed: MAXIMUM_NUMBER_CHOCOLAT
							      								    								  ES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43:
							      								    								   note:   ‘std::unordered_map<int, int>’ is not der
							      								    								  ived from ‘const std::deque<_Tp, _Alloc>’	 if
							      								    								  ( ( ! currRem ) && maxSum < sm [ i ] ) maxSum = sm
							      								    								   [ i ] ;
							      								    								    ^ In file included from /usr/include/c++/8/list:
							      								    								  63,		       from /usr/include/c++/8/x86_6
							      								    								  4-redhat-linux/bits/stdc++.h:79,
							      								    								  from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY
							      								    								  _AMONG_K_STUDENTS.cpp:14: /usr/include/c++/8/bits/
							      								    								  stl_list.h:2021:5: note: candidate: ‘template<clas
							      								    								  s _Tp, class _Alloc> bool std::operator<(const std
							      								    								  ::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11:
							      								    								  :list<_Tp, _Alloc>&)’	     operator<(const list<_T
							      								    								  p, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/stl_list.h:2021
							      								    								  :5: note:   template argument deduction/substituti
							      								    								  on failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_E
							      								    								  QUALLY_AMONG_K_STUDENTS.cpp:49:43: note:   ‘std::u
							      								    								  nordered_map<int, int>’ is not derived from ‘const
							      								    								   std::__cxx11::list<_Tp, _Alloc>’	 if ( ( ! cu
							      								    								  rrRem ) && maxSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/map:60,
							      								    								  	      from /usr/include/c++/8/x86_64-redhat-
							      								    								  linux/bits/stdc++.h:81,		   from MAXI
							      								    								  MUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_
							      								    								  STUDENTS.cpp:14: /usr/include/c++/8/bits/stl_tree.
							      								    								  h:1566:5: note: candidate: ‘template<class _Key, c
							      								    								  lass _Val, class _KeyOfValue, class _Compare, clas
							      								    								  s _Alloc> bool std::operator<(const std::_Rb_tree<
							      								    								  _Key, _Val, _KeyOfValue, _Compare, _Alloc>&, const
							      								    								   std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare,
							      								    								  _Alloc>&)’	  operator<(const _Rb_tree<_Key, _Va
							      								    								  l, _KeyOfValue, _Compare, _Alloc>& __x,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/stl_tree.h:1566:5: not
							      								    								  e:   template argument deduction/substitution fail
							      								    								  ed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_
							      								    								  AMONG_K_STUDENTS.cpp:49:43: note:   ‘std::unordere
							      								    								  d_map<int, int>’ is not derived from ‘const std::_
							      								    								  Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>
							      								    								  ’	 if ( ( ! currRem ) && maxSum < sm [ i ] ) m
							      								    								  axSum = sm [ i ] ;
							      								    								  	      ^ In file included from /usr/include/c
							      								    								  ++/8/map:61,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:81,
							      								    								  	   from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTE
							      								    								  D_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/include/c+
							      								    								  +/8/bits/stl_map.h:1451:5: note: candidate: ‘templ
							      								    								  ate<class _Key, class _Tp, class _Compare, class _
							      								    								  Alloc> bool std::operator<(const std::map<_Key, _T
							      								    								  p, _Compare, _Alloc>&, const std::map<_Key, _Tp, _
							      								    								  Compare, _Alloc>&)’	   operator<(const map<_Key,
							      								    								   _Tp, _Compare, _Alloc>& __x,	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/stl_map.h:1451:5: note:   templa
							      								    								  te argument deduction/substitution failed: MAXIMUM
							      								    								  _NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STU
							      								    								  DENTS.cpp:49:43: note:   ‘std::unordered_map<int,
							      								    								  int>’ is not derived from ‘const std::map<_Key, _T
							      								    								  p, _Compare, _Alloc>’	     if ( ( ! currRem ) && m
							      								    								  axSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  				  ^ In file included
							      								    								   from /usr/include/c++/8/map:62,
							      								    								  from /usr/include/c++/8/x86_64-redhat-linux/bits/s
							      								    								  tdc++.h:81,		       from MAXIMUM_NUMBER_C
							      								    								  HOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp
							      								    								  :14: /usr/include/c++/8/bits/stl_multimap.h:1115:5
							      								    								  : note: candidate: ‘template<class _Key, class _Tp
							      								    								  , class _Compare, class _Alloc> bool std::operator
							      								    								  <(const std::multimap<_Key, _Tp, _Compare, _Alloc>
							      								    								  &, const std::multimap<_Key, _Tp, _Compare, _Alloc
							      								    								  >&)’	    operator<(const multimap<_Key, _Tp, _Com
							      								    								  pare, _Alloc>& __x,	   ^~~~~~~~ /usr/include/c++
							      								    								  /8/bits/stl_multimap.h:1115:5: note:	 template ar
							      								    								  gument deduction/substitution failed: MAXIMUM_NUMB
							      								    								  ER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS
							      								    								  .cpp:49:43: note:   ‘std::unordered_map<int, int>’
							      								    								   is not derived from ‘const std::multimap<_Key, _T
							      								    								  p, _Compare, _Alloc>’	     if ( ( ! currRem ) && m
							      								    								  axSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  				  ^ In file included
							      								    								   from /usr/include/c++/8/bits/shared_ptr.h:52,
							      								    								  		from /usr/include/c++/8/memory:81,
							      								    								  		  from /usr/include/c++/8/x86_64-red
							      								    								  hat-linux/bits/stdc++.h:82,		       from
							      								    								  MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMON
							      								    								  G_K_STUDENTS.cpp:14: /usr/include/c++/8/bits/share
							      								    								  d_ptr_base.h:1442:5: note: candidate: ‘template<cl
							      								    								  ass _Tp, class _Up, __gnu_cxx::_Lock_policy _Lp> b
							      								    								  ool std::operator<(const std::__shared_ptr<_Tp1, _
							      								    								  Lp>&, const std::__shared_ptr<_Tp2, _Lp>&)’	   o
							      								    								  perator<(const __shared_ptr<_Tp, _Lp>& __a,	   ^
							      								    								  ~~~~~~~ /usr/include/c++/8/bits/shared_ptr_base.h:
							      								    								  1442:5: note:	  template argument deduction/substi
							      								    								  tution failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUT
							      								    								  ED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43: note:	 ‘st
							      								    								  d::unordered_map<int, int>’ is not derived from ‘c
							      								    								  onst std::__shared_ptr<_Tp1, _Lp>’	  if ( ( ! c
							      								    								  urrRem ) && maxSum < sm [ i ] ) maxSum = sm [ i ]
							      								    								  ;					       ^ In
							      								    								  file included from /usr/include/c++/8/bits/shared_
							      								    								  ptr.h:52,		     from /usr/include/c++/8
							      								    								  /memory:81,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:82,
							      								    								  	  from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED
							      								    								  _EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/include/c++
							      								    								  /8/bits/shared_ptr_base.h:1453:5: note: candidate:
							      								    								   ‘template<class _Tp, __gnu_cxx::_Lock_policy _Lp>
							      								    								   bool std::operator<(const std::__shared_ptr<_Tp,
							      								    								  _Lp>&, std::nullptr_t)’      operator<(const __sha
							      								    								  red_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept	   ^
							      								    								  ~~~~~~~ /usr/include/c++/8/bits/shared_ptr_base.h:
							      								    								  1453:5: note:	  template argument deduction/substi
							      								    								  tution failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUT
							      								    								  ED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43: note:	 ‘st
							      								    								  d::unordered_map<int, int>’ is not derived from ‘c
							      								    								  onst std::__shared_ptr<_Tp, _Lp>’	 if ( ( ! cu
							      								    								  rrRem ) && maxSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  					      ^ In f
							      								    								  ile included from /usr/include/c++/8/bits/shared_p
							      								    								  tr.h:52,		    from /usr/include/c++/8/
							      								    								  memory:81,		      from /usr/include/c++/
							      								    								  8/x86_64-redhat-linux/bits/stdc++.h:82,
							      								    								  	 from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_
							      								    								  EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/include/c++/
							      								    								  8/bits/shared_ptr_base.h:1461:5: note: candidate:
							      								    								  ‘template<class _Tp, __gnu_cxx::_Lock_policy _Lp>
							      								    								  bool std::operator<(std::nullptr_t, const std::__s
							      								    								  hared_ptr<_Tp, _Lp>&)’      operator<(nullptr_t, c
							      								    								  onst __shared_ptr<_Tp, _Lp>& __a) noexcept	  ^~
							      								    								  ~~~~~~ /usr/include/c++/8/bits/shared_ptr_base.h:1
							      								    								  461:5: note:	 template argument deduction/substit
							      								    								  ution failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTE
							      								    								  D_EQUALLY_AMONG_K_STUDENTS.cpp:49:43: note:	mism
							      								    								  atched types ‘const std::__shared_ptr<_Tp, _Lp>’ a
							      								    								  nd ‘int’	if ( ( ! currRem ) && maxSum < sm [
							      								    								  i ] ) maxSum = sm [ i ] ;
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/memory:81,		  from /usr/
							      								    								  include/c++/8/x86_64-redhat-linux/bits/stdc++.h:82
							      								    								  ,		     from MAXIMUM_NUMBER_CHOCOLATES_
							      								    								  DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/
							      								    								  include/c++/8/bits/shared_ptr.h:413:5: note: candi
							      								    								  date: ‘template<class _Tp, class _Up> bool std::op
							      								    								  erator<(const std::shared_ptr<_Tp>&, const std::sh
							      								    								  ared_ptr<_Tp>&)’	operator<(const shared_ptr<_
							      								    								  Tp>& __a, const shared_ptr<_Up>& __b) noexcept
							      								    								    ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr.h:41
							      								    								  3:5: note:   template argument deduction/substitut
							      								    								  ion failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_
							      								    								  EQUALLY_AMONG_K_STUDENTS.cpp:49:43: note:   ‘std::
							      								    								  unordered_map<int, int>’ is not derived from ‘cons
							      								    								  t std::shared_ptr<_Tp>’      if ( ( ! currRem ) &&
							      								    								   maxSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  				    ^ In file includ
							      								    								  ed from /usr/include/c++/8/memory:81,
							      								    								       from /usr/include/c++/8/x86_64-redhat-linux/b
							      								    								  its/stdc++.h:82,		    from MAXIMUM_NUM
							      								    								  BER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT
							      								    								  S.cpp:14: /usr/include/c++/8/bits/shared_ptr.h:423
							      								    								  :5: note: candidate: ‘template<class _Tp> bool std
							      								    								  ::operator<(const std::shared_ptr<_Tp>&, std::null
							      								    								  ptr_t)’      operator<(const shared_ptr<_Tp>& __a,
							      								    								   nullptr_t) noexcept	    ^~~~~~~~ /usr/include/c+
							      								    								  +/8/bits/shared_ptr.h:423:5: note:   template argu
							      								    								  ment deduction/substitution failed: MAXIMUM_NUMBER
							      								    								  _CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.c
							      								    								  pp:49:43: note:   ‘std::unordered_map<int, int>’ i
							      								    								  s not derived from ‘const std::shared_ptr<_Tp>’
							      								    								     if ( ( ! currRem ) && maxSum < sm [ i ] ) maxSu
							      								    								  m = sm [ i ] ;
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /memory:81,		       from /usr/include/c++
							      								    								  /8/x86_64-redhat-linux/bits/stdc++.h:82,
							      								    								  	  from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED
							      								    								  _EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/include/c++
							      								    								  /8/bits/shared_ptr.h:431:5: note: candidate: ‘temp
							      								    								  late<class _Tp> bool std::operator<(std::nullptr_t
							      								    								  , const std::shared_ptr<_Tp>&)’      operator<(nul
							      								    								  lptr_t, const shared_ptr<_Tp>& __a) noexcept
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/shared_ptr.h:431:
							      								    								  5: note:   template argument deduction/substitutio
							      								    								  n failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQ
							      								    								  UALLY_AMONG_K_STUDENTS.cpp:49:43: note:   mismatch
							      								    								  ed types ‘const std::shared_ptr<_Tp>’ and ‘int’
							      								    								     if ( ( ! currRem ) && maxSum < sm [ i ] ) maxSu
							      								    								  m = sm [ i ] ;
							      								    								  	  ^ In file included from /usr/include/c++/8
							      								    								  /queue:64,		      from /usr/include/c++/
							      								    								  8/x86_64-redhat-linux/bits/stdc++.h:86,
							      								    								  	 from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_
							      								    								  EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/include/c++/
							      								    								  8/bits/stl_queue.h:348:5: note: candidate: ‘templa
							      								    								  te<class _Tp, class _Seq> bool std::operator<(cons
							      								    								  t std::queue<_Tp, _Seq>&, const std::queue<_Tp, _S
							      								    								  eq>&)’      operator<(const queue<_Tp, _Seq>& __x,
							      								    								   const queue<_Tp, _Seq>& __y)	     ^~~~~~~~ /usr/i
							      								    								  nclude/c++/8/bits/stl_queue.h:348:5: note:   templ
							      								    								  ate argument deduction/substitution failed: MAXIMU
							      								    								  M_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_ST
							      								    								  UDENTS.cpp:49:43: note:   ‘std::unordered_map<int,
							      								    								   int>’ is not derived from ‘const std::queue<_Tp,
							      								    								  _Seq>’      if ( ( ! currRem ) && maxSum < sm [ i
							      								    								  ] ) maxSum = sm [ i ] ;
							      								    								  		   ^ In file included from /usr/incl
							      								    								  ude/c++/8/set:61,		     from /usr/inclu
							      								    								  de/c++/8/x86_64-redhat-linux/bits/stdc++.h:87,
							      								    								  		from MAXIMUM_NUMBER_CHOCOLATES_DISTR
							      								    								  IBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/inclu
							      								    								  de/c++/8/bits/stl_set.h:975:5: note: candidate: ‘t
							      								    								  emplate<class _Key, class _Compare, class _Alloc>
							      								    								  bool std::operator<(const std::set<_Key, _Compare,
							      								    								   _Alloc>&, const std::set<_Key, _Compare, _Alloc>&
							      								    								  )’	  operator<(const set<_Key, _Compare, _Alloc
							      								    								  >& __x,      ^~~~~~~~ /usr/include/c++/8/bits/stl_
							      								    								  set.h:975:5: note:   template argument deduction/s
							      								    								  ubstitution failed: MAXIMUM_NUMBER_CHOCOLATES_DIST
							      								    								  RIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43: note:
							      								    								    ‘std::unordered_map<int, int>’ is not derived fr
							      								    								  om ‘const std::set<_Key, _Compare, _Alloc>’	   i
							      								    								  f ( ( ! currRem ) && maxSum < sm [ i ] ) maxSum =
							      								    								  sm [ i ] ;
							      								    								      ^ In file included from /usr/include/c++/8/set
							      								    								  :62,			from /usr/include/c++/8/x86_
							      								    								  64-redhat-linux/bits/stdc++.h:87,
							      								    								   from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALL
							      								    								  Y_AMONG_K_STUDENTS.cpp:14: /usr/include/c++/8/bits
							      								    								  /stl_multiset.h:960:5: note: candidate: ‘template<
							      								    								  class _Key, class _Compare, class _Alloc> bool std
							      								    								  ::operator<(const std::multiset<_Key, _Compare, _A
							      								    								  lloc>&, const std::multiset<_Key, _Compare, _Alloc
							      								    								  >&)’	    operator<(const multiset<_Key, _Compare,
							      								    								   _Alloc>& __x,      ^~~~~~~~ /usr/include/c++/8/bi
							      								    								  ts/stl_multiset.h:960:5: note:   template argument
							      								    								   deduction/substitution failed: MAXIMUM_NUMBER_CHO
							      								    								  COLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:4
							      								    								  9:43: note:	‘std::unordered_map<int, int>’ is no
							      								    								  t derived from ‘const std::multiset<_Key, _Compare
							      								    								  , _Alloc>’	  if ( ( ! currRem ) && maxSum < sm
							      								    								  [ i ] ) maxSum = sm [ i ] ;
							      								    								  		       ^ In file included from /usr/
							      								    								  include/c++/8/stack:61,		   from /usr
							      								    								  /include/c++/8/x86_64-redhat-linux/bits/stdc++.h:8
							      								    								  9,		      from MAXIMUM_NUMBER_CHOCOLATES
							      								    								  _DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr
							      								    								  /include/c++/8/bits/stl_stack.h:323:5: note: candi
							      								    								  date: ‘template<class _Tp, class _Seq> bool std::o
							      								    								  perator<(const std::stack<_Tp, _Seq>&, const std::
							      								    								  stack<_Tp, _Seq>&)’	   operator<(const stack<_Tp
							      								    								  , _Seq>& __x, const stack<_Tp, _Seq>& __y)	  ^~
							      								    								  ~~~~~~ /usr/include/c++/8/bits/stl_stack.h:323:5:
							      								    								  note:	  template argument deduction/substitution f
							      								    								  ailed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUAL
							      								    								  LY_AMONG_K_STUDENTS.cpp:49:43: note:	 ‘std::unord
							      								    								  ered_map<int, int>’ is not derived from ‘const std
							      								    								  ::stack<_Tp, _Seq>’	   if ( ( ! currRem ) && max
							      								    								  Sum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  				^ In file included f
							      								    								  rom /usr/include/c++/8/valarray:592,
							      								    								      from /usr/include/c++/8/x86_64-redhat-linux/bi
							      								    								  ts/stdc++.h:95,		   from MAXIMUM_NUMB
							      								    								  ER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS
							      								    								  .cpp:14: /usr/include/c++/8/bits/valarray_after.h:
							      								    								  416:5: note: candidate: ‘template<class _Dom1, cla
							      								    								  ss _Dom2> std::_Expr<std::_BinClos<std::__less, st
							      								    								  d::_Expr, std::_Expr, _Dom1, _Dom2>, typename std:
							      								    								  :__fun<std::__less, typename _Dom1::value_type>::r
							      								    								  esult_type> std::operator<(const std::_Expr<_Dom1,
							      								    								   typename _Dom1::value_type>&, const std::_Expr<_D
							      								    								  om2, typename _Dom2::value_type>&)’	   _DEFINE_E
							      								    								  XPR_BINARY_OPERATOR(<, __less)      ^~~~~~~~~~~~~~
							      								    								  ~~~~~~~~~~~~~~ /usr/include/c++/8/bits/valarray_af
							      								    								  ter.h:416:5: note:   template argument deduction/s
							      								    								  ubstitution failed: MAXIMUM_NUMBER_CHOCOLATES_DIST
							      								    								  RIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43: note:
							      								    								    ‘std::unordered_map<int, int>’ is not derived fr
							      								    								  om ‘const std::_Expr<_Dom1, typename _Dom1::value_
							      								    								  type>’      if ( ( ! currRem ) && maxSum < sm [ i
							      								    								  ] ) maxSum = sm [ i ] ;
							      								    								  		   ^ In file included from /usr/incl
							      								    								  ude/c++/8/valarray:592,		   from /usr
							      								    								  /include/c++/8/x86_64-redhat-linux/bits/stdc++.h:9
							      								    								  5,		      from MAXIMUM_NUMBER_CHOCOLATES
							      								    								  _DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr
							      								    								  /include/c++/8/bits/valarray_after.h:416:5: note:
							      								    								  candidate: ‘template<class _Dom> std::_Expr<std::_
							      								    								  BinClos<std::__less, std::_Expr, std::_Constant, _
							      								    								  Dom, typename _Dom::value_type>, typename std::__f
							      								    								  un<std::__less, typename _Dom1::value_type>::resul
							      								    								  t_type> std::operator<(const std::_Expr<_Dom1, typ
							      								    								  ename _Dom1::value_type>&, const typename _Dom::va
							      								    								  lue_type&)’	   _DEFINE_EXPR_BINARY_OPERATOR(<, _
							      								    								  _less)      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/incl
							      								    								  ude/c++/8/bits/valarray_after.h:416:5: note:	 tem
							      								    								  plate argument deduction/substitution failed: MAXI
							      								    								  MUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_
							      								    								  STUDENTS.cpp:49:43: note:   ‘std::unordered_map<in
							      								    								  t, int>’ is not derived from ‘const std::_Expr<_Do
							      								    								  m1, typename _Dom1::value_type>’	if ( ( ! cur
							      								    								  rRem ) && maxSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  					     ^ In fi
							      								    								  le included from /usr/include/c++/8/valarray:592,
							      								    								  		   from /usr/include/c++/8/x86_64-re
							      								    								  dhat-linux/bits/stdc++.h:95,			from
							      								    								   MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMO
							      								    								  NG_K_STUDENTS.cpp:14: /usr/include/c++/8/bits/vala
							      								    								  rray_after.h:416:5: note: candidate: ‘template<cla
							      								    								  ss _Dom> std::_Expr<std::_BinClos<std::__less, std
							      								    								  ::_Constant, std::_Expr, typename _Dom::value_type
							      								    								  , _Dom>, typename std::__fun<std::__less, typename
							      								    								   _Dom1::value_type>::result_type> std::operator<(c
							      								    								  onst typename _Dom::value_type&, const std::_Expr<
							      								    								  _Dom1, typename _Dom1::value_type>&)’	     _DEFINE
							      								    								  _EXPR_BINARY_OPERATOR(<, __less)	^~~~~~~~~~~~
							      								    								  ~~~~~~~~~~~~~~~~ /usr/include/c++/8/bits/valarray_
							      								    								  after.h:416:5: note:	 template argument deduction
							      								    								  /substitution failed: MAXIMUM_NUMBER_CHOCOLATES_DI
							      								    								  STRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43: note
							      								    								  :   mismatched types ‘const std::_Expr<_Dom1, type
							      								    								  name _Dom1::value_type>’ and ‘int’	  if ( ( ! c
							      								    								  urrRem ) && maxSum < sm [ i ] ) maxSum = sm [ i ]
							      								    								  ;					       ^ In
							      								    								  file included from /usr/include/c++/8/valarray:592
							      								    								  ,		     from /usr/include/c++/8/x86_64-
							      								    								  redhat-linux/bits/stdc++.h:95,		  fr
							      								    								  om MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_A
							      								    								  MONG_K_STUDENTS.cpp:14: /usr/include/c++/8/bits/va
							      								    								  larray_after.h:416:5: note: candidate: ‘template<c
							      								    								  lass _Dom> std::_Expr<std::_BinClos<std::__less, s
							      								    								  td::_Expr, std::_ValArray, _Dom, typename _Dom::va
							      								    								  lue_type>, typename std::__fun<std::__less, typena
							      								    								  me _Dom1::value_type>::result_type> std::operator<
							      								    								  (const std::_Expr<_Dom1, typename _Dom1::value_typ
							      								    								  e>&, const std::valarray<typename _Dom::value_type
							      								    								  >&)’	    _DEFINE_EXPR_BINARY_OPERATOR(<, __less)
							      								    								       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++
							      								    								  /8/bits/valarray_after.h:416:5: note:	  template a
							      								    								  rgument deduction/substitution failed: MAXIMUM_NUM
							      								    								  BER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENT
							      								    								  S.cpp:49:43: note:   ‘std::unordered_map<int, int>
							      								    								  ’ is not derived from ‘const std::_Expr<_Dom1, typ
							      								    								  ename _Dom1::value_type>’	 if ( ( ! currRem )
							      								    								  && maxSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  				      ^ In file incl
							      								    								  uded from /usr/include/c++/8/valarray:592,
							      								    								  	    from /usr/include/c++/8/x86_64-redhat-li
							      								    								  nux/bits/stdc++.h:95,			 from MAXIMU
							      								    								  M_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_ST
							      								    								  UDENTS.cpp:14: /usr/include/c++/8/bits/valarray_af
							      								    								  ter.h:416:5: note: candidate: ‘template<class _Dom
							      								    								  > std::_Expr<std::_BinClos<std::__less, std::_ValA
							      								    								  rray, std::_Expr, typename _Dom::value_type, _Dom>
							      								    								  , typename std::__fun<std::__less, typename _Dom1:
							      								    								  :value_type>::result_type> std::operator<(const st
							      								    								  d::valarray<typename _Dom::value_type>&, const std
							      								    								  ::_Expr<_Dom1, typename _Dom1::value_type>&)’
							      								    								   _DEFINE_EXPR_BINARY_OPERATOR(<, __less)	^~~~
							      								    								  ~~~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/bits/v
							      								    								  alarray_after.h:416:5: note:	 template argument d
							      								    								  eduction/substitution failed: MAXIMUM_NUMBER_CHOCO
							      								    								  LATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:
							      								    								  43: note:   mismatched types ‘const std::_Expr<_Do
							      								    								  m1, typename _Dom1::value_type>’ and ‘int’	  if
							      								    								   ( ( ! currRem ) && maxSum < sm [ i ] ) maxSum = s
							      								    								  m [ i ] ;
							      								    								     ^ In file included from /usr/include/c++/8/x86_
							      								    								  64-redhat-linux/bits/stdc++.h:95,
							      								    								   from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALL
							      								    								  Y_AMONG_K_STUDENTS.cpp:14: /usr/include/c++/8/vala
							      								    								  rray:1186:1: note: candidate: ‘template<class _Tp>
							      								    								   std::_Expr<std::_BinClos<std::__less, std::_ValAr
							      								    								  ray, std::_ValArray, _Tp, _Tp>, typename std::__fu
							      								    								  n<std::__less, _Tp>::result_type> std::operator<(c
							      								    								  onst std::valarray<_Tp>&, const std::valarray<_Tp>
							      								    								  &)’  _DEFINE_BINARY_OPERATOR(<, __less)  ^~~~~~~~~
							      								    								  ~~~~~~~~~~~~~~ /usr/include/c++/8/valarray:1186:1:
							      								    								   note:   template argument deduction/substitution
							      								    								  failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUA
							      								    								  LLY_AMONG_K_STUDENTS.cpp:49:43: note:	  ‘std::unor
							      								    								  dered_map<int, int>’ is not derived from ‘const st
							      								    								  d::valarray<_Tp>’	 if ( ( ! currRem ) && maxSu
							      								    								  m < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  			      ^ In file included fro
							      								    								  m /usr/include/c++/8/x86_64-redhat-linux/bits/stdc
							      								    								  ++.h:95,		    from MAXIMUM_NUMBER_CHOC
							      								    								  OLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14
							      								    								  : /usr/include/c++/8/valarray:1186:1: note: candid
							      								    								  ate: ‘template<class _Tp> std::_Expr<std::_BinClos
							      								    								  <std::__less, std::_ValArray, std::_Constant, _Tp,
							      								    								   _Tp>, typename std::__fun<std::__less, _Tp>::resu
							      								    								  lt_type> std::operator<(const std::valarray<_Tp>&,
							      								    								   const _Tp&)’	 _DEFINE_BINARY_OPERATOR(<, __less)
							      								    								   ^~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/valarr
							      								    								  ay:1186:1: note:   template argument deduction/sub
							      								    								  stitution failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRI
							      								    								  BUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43: note:
							      								    								  ‘std::unordered_map<int, int>’ is not derived from
							      								    								   ‘const std::valarray<_Tp>’	   if ( ( ! currRem
							      								    								  ) && maxSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  					^ In file in
							      								    								  cluded from /usr/include/c++/8/x86_64-redhat-linux
							      								    								  /bits/stdc++.h:95,		      from MAXIMUM_N
							      								    								  UMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDE
							      								    								  NTS.cpp:14: /usr/include/c++/8/valarray:1186:1: no
							      								    								  te: candidate: ‘template<class _Tp> std::_Expr<std
							      								    								  ::_BinClos<std::__less, std::_Constant, std::_ValA
							      								    								  rray, _Tp, _Tp>, typename std::__fun<std::__less,
							      								    								  _Tp>::result_type> std::operator<(const _Tp&, cons
							      								    								  t std::valarray<_Tp>&)’  _DEFINE_BINARY_OPERATOR(<
							      								    								  , __less)  ^~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c+
							      								    								  +/8/valarray:1186:1: note:   template argument ded
							      								    								  uction/substitution failed: MAXIMUM_NUMBER_CHOCOLA
							      								    								  TES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43
							      								    								  : note:   mismatched types ‘const std::valarray<_T
							      								    								  p>’ and ‘int’	     if ( ( ! currRem ) && maxSum <
							      								    								  sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  			  ^ In file included from /u
							      								    								  sr/include/c++/8/forward_list:38,
							      								    								   from /usr/include/c++/8/x86_64-redhat-linux/bits/
							      								    								  stdc++.h:104,			 from MAXIMUM_NUMBER
							      								    								  _CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.c
							      								    								  pp:14: /usr/include/c++/8/bits/forward_list.h:1432
							      								    								  :5: note: candidate: ‘template<class _Tp, class _A
							      								    								  lloc> bool std::operator<(const std::forward_list<
							      								    								  _Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc
							      								    								  >&)’	    operator<(const forward_list<_Tp, _Alloc
							      								    								  >& __lx,	^~~~~~~~ /usr/include/c++/8/bits/for
							      								    								  ward_list.h:1432:5: note:   template argument dedu
							      								    								  ction/substitution failed: MAXIMUM_NUMBER_CHOCOLAT
							      								    								  ES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:49:43:
							      								    								   note:   ‘std::unordered_map<int, int>’ is not der
							      								    								  ived from ‘const std::forward_list<_Tp, _Alloc>’
							      								    								      if ( ( ! currRem ) && maxSum < sm [ i ] ) maxS
							      								    								  um = sm [ i ] ;
							      								    								  	   ^ In file included from /usr/include/c++/
							      								    								  8/future:39,			from /usr/include/c+
							      								    								  +/8/x86_64-redhat-linux/bits/stdc++.h:105,
							      								    								  	    from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUT
							      								    								  ED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/include/c
							      								    								  ++/8/thread:291:3: note: candidate: ‘bool std::ope
							      								    								  rator<(std::thread::id, std::thread::id)’    opera
							      								    								  tor<(thread::id __x, thread::id __y) noexcept	   ^
							      								    								  ~~~~~~~ /usr/include/c++/8/thread:291:3: note:   n
							      								    								  o known conversion for argument 1 from ‘std::unord
							      								    								  ered_map<int, int>’ to ‘std::thread::id’ In file i
							      								    								  ncluded from /usr/include/c++/8/bits/stl_algobase.
							      								    								  h:67,			 from /usr/include/c++/8/bit
							      								    								  s/char_traits.h:39,		       from /usr/inc
							      								    								  lude/c++/8/ios:40,		      from /usr/incl
							      								    								  ude/c++/8/ostream:38,			 from /usr/i
							      								    								  nclude/c++/8/iostream:39,		     from MA
							      								    								  XIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_
							      								    								  K_STUDENTS.cpp:8: /usr/include/c++/8/bits/stl_iter
							      								    								  ator.h:892:5: note: candidate: ‘template<class _It
							      								    								  eratorL, class _IteratorR, class _Container> bool
							      								    								  __gnu_cxx::operator<(const __gnu_cxx::__normal_ite
							      								    								  rator<_IteratorL, _Container>&, const __gnu_cxx::_
							      								    								  _normal_iterator<_IteratorR, _Container>&)’	   o
							      								    								  perator<(const __normal_iterator<_IteratorL, _Cont
							      								    								  ainer>& __lhs,      ^~~~~~~~ /usr/include/c++/8/bi
							      								    								  ts/stl_iterator.h:892:5: note:   template argument
							      								    								   deduction/substitution failed: MAXIMUM_NUMBER_CHO
							      								    								  COLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:4
							      								    								  9:43: note:	‘std::unordered_map<int, int>’ is no
							      								    								  t derived from ‘const __gnu_cxx::__normal_iterator
							      								    								  <_IteratorL, _Container>’	 if ( ( ! currRem )
							      								    								  && maxSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  				      ^ In file incl
							      								    								  uded from /usr/include/c++/8/bits/stl_algobase.h:6
							      								    								  7,		      from /usr/include/c++/8/bits/c
							      								    								  har_traits.h:39,		    from /usr/includ
							      								    								  e/c++/8/ios:40,		   from /usr/include
							      								    								  /c++/8/ostream:38,		      from /usr/incl
							      								    								  ude/c++/8/iostream:39,		  from MAXIM
							      								    								  UM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_S
							      								    								  TUDENTS.cpp:8: /usr/include/c++/8/bits/stl_iterato
							      								    								  r.h:899:5: note: candidate: ‘template<class _Itera
							      								    								  tor, class _Container> bool __gnu_cxx::operator<(c
							      								    								  onst __gnu_cxx::__normal_iterator<_Iterator, _Cont
							      								    								  ainer>&, const __gnu_cxx::__normal_iterator<_Itera
							      								    								  tor, _Container>&)’	   operator<(const __normal_
							      								    								  iterator<_Iterator, _Container>& __lhs,      ^~~~~
							      								    								  ~~~ /usr/include/c++/8/bits/stl_iterator.h:899:5:
							      								    								  note:	  template argument deduction/substitution f
							      								    								  ailed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUAL
							      								    								  LY_AMONG_K_STUDENTS.cpp:49:43: note:	 ‘std::unord
							      								    								  ered_map<int, int>’ is not derived from ‘const __g
							      								    								  nu_cxx::__normal_iterator<_Iterator, _Container>’
							      								    								       if ( ( ! currRem ) && maxSum < sm [ i ] ) max
							      								    								  Sum = sm [ i ] ;
							      								    								  	    ^ MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_
							      								    								  EQUALLY_AMONG_K_STUDENTS.cpp:49:63: error: no matc
							      								    								  h for ‘operator=’ (operand types are ‘std::unorder
							      								    								  ed_map<int, int>’ and ‘int’)	    if ( ( ! currRem
							      								    								   ) && maxSum < sm [ i ] ) maxSum = sm [ i ] ;
							      								    								  
							      								    								  	   ^ In file included from /usr/include/c++/
							      								    								  8/unordered_map:47,		       from /usr/inc
							      								    								  lude/c++/8/x86_64-redhat-linux/bits/stdc++.h:117,
							      								    								  		   from MAXIMUM_NUMBER_CHOCOLATES_DI
							      								    								  STRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/in
							      								    								  clude/c++/8/bits/unordered_map.h:271:7: note: cand
							      								    								  idate: ‘std::unordered_map<_Key, _Tp, _Hash, _Pred
							      								    								  , _Alloc>& std::unordered_map<_Key, _Tp, _Hash, _P
							      								    								  red, _Alloc>::operator=(const std::unordered_map<_
							      								    								  Key, _Tp, _Hash, _Pred, _Alloc>&) [with _Key = int
							      								    								  ; _Tp = int; _Hash = std::hash<int>; _Pred = std::
							      								    								  equal_to<int>; _Alloc = std::allocator<std::pair<c
							      								    								  onst int, int> >]’	    operator=(const unordere
							      								    								  d_map&) = default;	    ^~~~~~~~ /usr/include/c+
							      								    								  +/8/bits/unordered_map.h:271:7: note:	  no known c
							      								    								  onversion for argument 1 from ‘int’ to ‘const std:
							      								    								  :unordered_map<int, int>&’ /usr/include/c++/8/bits
							      								    								  /unordered_map.h:275:7: note: candidate: ‘std::uno
							      								    								  rdered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& std::
							      								    								  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::op
							      								    								  erator=(std::unordered_map<_Key, _Tp, _Hash, _Pred
							      								    								  , _Alloc>&&) [with _Key = int; _Tp = int; _Hash =
							      								    								  std::hash<int>; _Pred = std::equal_to<int>; _Alloc
							      								    								   = std::allocator<std::pair<const int, int> >]’
							      								    								       operator=(unordered_map&&) = default;
							      								    								  ^~~~~~~~ /usr/include/c++/8/bits/unordered_map.h:2
							      								    								  75:7: note:	no known conversion for argument 1 f
							      								    								  rom ‘int’ to ‘std::unordered_map<int, int>&&’ /usr
							      								    								  /include/c++/8/bits/unordered_map.h:289:7: note: c
							      								    								  andidate: ‘std::unordered_map<_Key, _Tp, _Hash, _P
							      								    								  red, _Alloc>& std::unordered_map<_Key, _Tp, _Hash,
							      								    								   _Pred, _Alloc>::operator=(std::initializer_list<t
							      								    								  ypename std::_Hashtable<_Key, std::pair<const _Key
							      								    								  , _Tp>, _Alloc, std::__detail::_Select1st, _Pred,
							      								    								  _Hash, std::__detail::_Mod_range_hashing, std::__d
							      								    								  etail::_Default_ranged_hash, std::__detail::_Prime
							      								    								  _rehash_policy, std::__detail::_Hashtable_traits<s
							      								    								  td::__not_<std::__and_<std::__is_fast_hash<_Hash>,
							      								    								   std::__is_nothrow_invocable<const _Hash&, const _
							      								    								  Key&> > >::value, false, true> >::value_type>) [wi
							      								    								  th _Key = int; _Tp = int; _Hash = std::hash<int>;
							      								    								  _Pred = std::equal_to<int>; _Alloc = std::allocato
							      								    								  r<std::pair<const int, int> >; typename std::_Hash
							      								    								  table<_Key, std::pair<const _Key, _Tp>, _Alloc, st
							      								    								  d::__detail::_Select1st, _Pred, _Hash, std::__deta
							      								    								  il::_Mod_range_hashing, std::__detail::_Default_ra
							      								    								  nged_hash, std::__detail::_Prime_rehash_policy, st
							      								    								  d::__detail::_Hashtable_traits<std::__not_<std::__
							      								    								  and_<std::__is_fast_hash<_Hash>, std::__is_nothrow
							      								    								  _invocable<const _Hash&, const _Key&> > >::value,
							      								    								  false, true> >::value_type = std::pair<const int,
							      								    								  int>]’	operator=(initializer_list<value_typ
							      								    								  e> __l)	 ^~~~~~~~ /usr/include/c++/8/bits/un
							      								    								  ordered_map.h:289:7: note:   no known conversion f
							      								    								  or argument 1 from ‘int’ to ‘std::initializer_list
							      								    								  <std::pair<const int, int> >’ MAXIMUM_NUMBER_CHOCO
							      								    								  LATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:50:
							      								    								  17: error: no match for ‘operator!’ (operand type
							      								    								  is ‘std::unordered_map<int, int>’)	  else if (
							      								    								  ( ! currRem ) && um . count ( currRem ) ) um [ cur
							      								    								  rRem ] = i ;			^~~~~~~~~ MAXIMUM_NU
							      								    								  MBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDEN
							      								    								  TS.cpp:50:17: note: candidate: ‘operator!(bool)’ <
							      								    								  built-in> MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQ
							      								    								  UALLY_AMONG_K_STUDENTS.cpp:50:17: note:   no known
							      								    								   conversion for argument 1 from ‘std::unordered_ma
							      								    								  p<int, int>’ to ‘bool’ MAXIMUM_NUMBER_CHOCOLATES_D
							      								    								  ISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:50:53: err
							      								    								  or: no matching function for call to ‘std::unorder
							      								    								  ed_map<int, int>::count(std::unordered_map<int, in
							      								    								  t>&)’	     else if ( ( ! currRem ) && um . count (
							      								    								   currRem ) ) um [ currRem ] = i ;
							      								    								  				       ^ In file inc
							      								    								  luded from /usr/include/c++/8/unordered_map:47,
							      								    								  		 from /usr/include/c++/8/x86_64-redh
							      								    								  at-linux/bits/stdc++.h:117,		       from
							      								    								  MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMON
							      								    								  G_K_STUDENTS.cpp:14: /usr/include/c++/8/bits/unord
							      								    								  ered_map.h:938:7: note: candidate: ‘std::unordered
							      								    								  _map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type s
							      								    								  td::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>
							      								    								  ::count(const key_type&) const [with _Key = int; _
							      								    								  Tp = int; _Hash = std::hash<int>; _Pred = std::equ
							      								    								  al_to<int>; _Alloc = std::allocator<std::pair<cons
							      								    								  t int, int> >; std::unordered_map<_Key, _Tp, _Hash
							      								    								  , _Pred, _Alloc>::size_type = long unsigned int; s
							      								    								  td::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>
							      								    								  ::key_type = int]’	    count(const key_type& __
							      								    								  x) const	  ^~~~~ /usr/include/c++/8/bits/unor
							      								    								  dered_map.h:938:7: note:   no known conversion for
							      								    								   argument 1 from ‘std::unordered_map<int, int>’ to
							      								    								   ‘const key_type&’ {aka ‘const int&’} MAXIMUM_NUMB
							      								    								  ER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS
							      								    								  .cpp:50:60: error: no match for ‘operator[]’ (oper
							      								    								  and types are ‘std::unordered_map<int, int>’ and ‘
							      								    								  std::unordered_map<int, int>’)      else if ( ( !
							      								    								  currRem ) && um . count ( currRem ) ) um [ currRem
							      								    								   ] = i ;
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/unordered_map:47,			 fro
							      								    								  m /usr/include/c++/8/x86_64-redhat-linux/bits/stdc
							      								    								  ++.h:117,		     from MAXIMUM_NUMBER_CHO
							      								    								  COLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:1
							      								    								  4: /usr/include/c++/8/bits/unordered_map.h:973:7:
							      								    								  note: candidate: ‘std::unordered_map<_Key, _Tp, _H
							      								    								  ash, _Pred, _Alloc>::mapped_type& std::unordered_m
							      								    								  ap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](co
							      								    								  nst key_type&) [with _Key = int; _Tp = int; _Hash
							      								    								  = std::hash<int>; _Pred = std::equal_to<int>; _All
							      								    								  oc = std::allocator<std::pair<const int, int> >; s
							      								    								  td::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>
							      								    								  ::mapped_type = int; std::unordered_map<_Key, _Tp,
							      								    								   _Hash, _Pred, _Alloc>::key_type = int]’	  op
							      								    								  erator[](const key_type& __k)	       ^~~~~~~~ /usr
							      								    								  /include/c++/8/bits/unordered_map.h:973:7: note:
							      								    								   no known conversion for argument 1 from ‘std::uno
							      								    								  rdered_map<int, int>’ to ‘const key_type&’ {aka ‘c
							      								    								  onst int&’} /usr/include/c++/8/bits/unordered_map.
							      								    								  h:977:7: note: candidate: ‘std::unordered_map<_Key
							      								    								  , _Tp, _Hash, _Pred, _Alloc>::mapped_type& std::un
							      								    								  ordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::oper
							      								    								  ator[](std::unordered_map<_Key, _Tp, _Hash, _Pred,
							      								    								   _Alloc>::key_type&&) [with _Key = int; _Tp = int;
							      								    								   _Hash = std::hash<int>; _Pred = std::equal_to<int
							      								    								  >; _Alloc = std::allocator<std::pair<const int, in
							      								    								  t> >; std::unordered_map<_Key, _Tp, _Hash, _Pred,
							      								    								  _Alloc>::mapped_type = int; std::unordered_map<_Ke
							      								    								  y, _Tp, _Hash, _Pred, _Alloc>::key_type = int]’
							      								    								       operator[](key_type&& __k)	 ^~~~~~~~ /u
							      								    								  sr/include/c++/8/bits/unordered_map.h:977:7: note:
							      								    								     no known conversion for argument 1 from ‘std::u
							      								    								  nordered_map<int, int>’ to ‘std::unordered_map<int
							      								    								  , int>::key_type&&’ {aka ‘int&&’} MAXIMUM_NUMBER_C
							      								    								  HOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp
							      								    								  :51:47: error: no match for ‘operator[]’ (operand
							      								    								  types are ‘std::unordered_map<int, int>’ and ‘std:
							      								    								  :unordered_map<int, int>’)	  else if ( ( maxSum
							      								    								   < ( sm [ i ] - sm [ um [ currRem ] ] ) ) ) maxSum
							      								    								   = sm [ i ] - sm [ um [ currRem ] ] ;
							      								    								  				     ^ In file inclu
							      								    								  ded from /usr/include/c++/8/unordered_map:47,
							      								    								  	       from /usr/include/c++/8/x86_64-redhat
							      								    								  -linux/bits/stdc++.h:117,		     from MA
							      								    								  XIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_
							      								    								  K_STUDENTS.cpp:14: /usr/include/c++/8/bits/unorder
							      								    								  ed_map.h:973:7: note: candidate: ‘std::unordered_m
							      								    								  ap<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type&
							      								    								  std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc
							      								    								  >::operator[](const key_type&) [with _Key = int; _
							      								    								  Tp = int; _Hash = std::hash<int>; _Pred = std::equ
							      								    								  al_to<int>; _Alloc = std::allocator<std::pair<cons
							      								    								  t int, int> >; std::unordered_map<_Key, _Tp, _Hash
							      								    								  , _Pred, _Alloc>::mapped_type = int; std::unordere
							      								    								  d_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type =
							      								    								   int]’	operator[](const key_type& __k)
							      								    								     ^~~~~~~~ /usr/include/c++/8/bits/unordered_map.
							      								    								  h:973:7: note:   no known conversion for argument
							      								    								  1 from ‘std::unordered_map<int, int>’ to ‘const ke
							      								    								  y_type&’ {aka ‘const int&’} /usr/include/c++/8/bit
							      								    								  s/unordered_map.h:977:7: note: candidate: ‘std::un
							      								    								  ordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapp
							      								    								  ed_type& std::unordered_map<_Key, _Tp, _Hash, _Pre
							      								    								  d, _Alloc>::operator[](std::unordered_map<_Key, _T
							      								    								  p, _Hash, _Pred, _Alloc>::key_type&&) [with _Key =
							      								    								   int; _Tp = int; _Hash = std::hash<int>; _Pred = s
							      								    								  td::equal_to<int>; _Alloc = std::allocator<std::pa
							      								    								  ir<const int, int> >; std::unordered_map<_Key, _Tp
							      								    								  , _Hash, _Pred, _Alloc>::mapped_type = int; std::u
							      								    								  nordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key
							      								    								  _type = int]’	       operator[](key_type&& __k)
							      								    								       ^~~~~~~~ /usr/include/c++/8/bits/unordered_ma
							      								    								  p.h:977:7: note:   no known conversion for argumen
							      								    								  t 1 from ‘std::unordered_map<int, int>’ to ‘std::u
							      								    								  nordered_map<int, int>::key_type&&’ {aka ‘int&&’}
							      								    								  MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMON
							      								    								  G_K_STUDENTS.cpp:51:95: error: no match for ‘opera
							      								    								  tor[]’ (operand types are ‘std::unordered_map<int,
							      								    								   int>’ and ‘std::unordered_map<int, int>’)	  el
							      								    								  se if ( ( maxSum < ( sm [ i ] - sm [ um [ currRem
							      								    								  ] ] ) ) ) maxSum = sm [ i ] - sm [ um [ currRem ]
							      								    								  ] ;
							      								    								  						   ^
							      								    								   In file included from /usr/include/c++/8/unordere
							      								    								  d_map:47,		     from /usr/include/c++/8
							      								    								  /x86_64-redhat-linux/bits/stdc++.h:117,
							      								    								  	 from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_
							      								    								  EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/include/c++/
							      								    								  8/bits/unordered_map.h:973:7: note: candidate: ‘st
							      								    								  d::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>:
							      								    								  :mapped_type& std::unordered_map<_Key, _Tp, _Hash,
							      								    								   _Pred, _Alloc>::operator[](const key_type&) [with
							      								    								   _Key = int; _Tp = int; _Hash = std::hash<int>; _P
							      								    								  red = std::equal_to<int>; _Alloc = std::allocator<
							      								    								  std::pair<const int, int> >; std::unordered_map<_K
							      								    								  ey, _Tp, _Hash, _Pred, _Alloc>::mapped_type = int;
							      								    								   std::unordered_map<_Key, _Tp, _Hash, _Pred, _Allo
							      								    								  c>::key_type = int]’	      operator[](const key_t
							      								    								  ype& __k)	   ^~~~~~~~ /usr/include/c++/8/bits/
							      								    								  unordered_map.h:973:7: note:	 no known conversion
							      								    								   for argument 1 from ‘std::unordered_map<int, int>
							      								    								  ’ to ‘const key_type&’ {aka ‘const int&’} /usr/inc
							      								    								  lude/c++/8/bits/unordered_map.h:977:7: note: candi
							      								    								  date: ‘std::unordered_map<_Key, _Tp, _Hash, _Pred,
							      								    								   _Alloc>::mapped_type& std::unordered_map<_Key, _T
							      								    								  p, _Hash, _Pred, _Alloc>::operator[](std::unordere
							      								    								  d_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type&&
							      								    								  ) [with _Key = int; _Tp = int; _Hash = std::hash<i
							      								    								  nt>; _Pred = std::equal_to<int>; _Alloc = std::all
							      								    								  ocator<std::pair<const int, int> >; std::unordered
							      								    								  _map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type
							      								    								   = int; std::unordered_map<_Key, _Tp, _Hash, _Pred
							      								    								  , _Alloc>::key_type = int]’	     operator[](key_
							      								    								  type&& __k)	     ^~~~~~~~ /usr/include/c++/8/bit
							      								    								  s/unordered_map.h:977:7: note:   no known conversi
							      								    								  on for argument 1 from ‘std::unordered_map<int, in
							      								    								  t>’ to ‘std::unordered_map<int, int>::key_type&&’
							      								    								  {aka ‘int&&’} MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTE
							      								    								  D_EQUALLY_AMONG_K_STUDENTS.cpp:53:17: error: no ma
							      								    								  tch for ‘operator/’ (operand types are ‘std::unord
							      								    								  ered_map<int, int>’ and ‘int’)    return maxSum /
							      								    								  k ;		~~~~~~~^~~ In file included from /us
							      								    								  r/include/c++/8/ccomplex:39,			from
							      								    								   /usr/include/c++/8/x86_64-redhat-linux/bits/stdc+
							      								    								  +.h:52,		   from MAXIMUM_NUMBER_CHOCO
							      								    								  LATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14:
							      								    								   /usr/include/c++/8/complex:416:5: note: candidate
							      								    								  : ‘template<class _Tp> std::complex<_Tp> std::oper
							      								    								  ator/(const std::complex<_Tp>&, const std::complex
							      								    								  <_Tp>&)’	operator/(const complex<_Tp>& __x, c
							      								    								  onst complex<_Tp>& __y)      ^~~~~~~~ /usr/include
							      								    								  /c++/8/complex:416:5: note:	template argument de
							      								    								  duction/substitution failed: MAXIMUM_NUMBER_CHOCOL
							      								    								  ATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:53:1
							      								    								  9: note:   ‘std::unordered_map<int, int>’ is not d
							      								    								  erived from ‘const std::complex<_Tp>’	   return ma
							      								    								  xSum / k ;			^ In file included f
							      								    								  rom /usr/include/c++/8/ccomplex:39,
							      								    								     from /usr/include/c++/8/x86_64-redhat-linux/bit
							      								    								  s/stdc++.h:52,		  from MAXIMUM_NUMBE
							      								    								  R_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.
							      								    								  cpp:14: /usr/include/c++/8/complex:425:5: note: ca
							      								    								  ndidate: ‘template<class _Tp> std::complex<_Tp> st
							      								    								  d::operator/(const std::complex<_Tp>&, const _Tp&)
							      								    								  ’	 operator/(const complex<_Tp>& __x, const _T
							      								    								  p& __y)      ^~~~~~~~ /usr/include/c++/8/complex:4
							      								    								  25:5: note:	template argument deduction/substitu
							      								    								  tion failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED
							      								    								  _EQUALLY_AMONG_K_STUDENTS.cpp:53:19: note:   ‘std:
							      								    								  :unordered_map<int, int>’ is not derived from ‘con
							      								    								  st std::complex<_Tp>’	   return maxSum / k ;
							      								    								  		^ In file included from /usr/include
							      								    								  /c++/8/ccomplex:39,		       from /usr/inc
							      								    								  lude/c++/8/x86_64-redhat-linux/bits/stdc++.h:52,
							      								    								  		  from MAXIMUM_NUMBER_CHOCOLATES_DIS
							      								    								  TRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/inc
							      								    								  lude/c++/8/complex:434:5: note: candidate: ‘templa
							      								    								  te<class _Tp> std::complex<_Tp> std::operator/(con
							      								    								  st _Tp&, const std::complex<_Tp>&)’	   operator/
							      								    								  (const _Tp& __x, const complex<_Tp>& __y)	 ^~~
							      								    								  ~~~~~ /usr/include/c++/8/complex:434:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: MAX
							      								    								  IMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K
							      								    								  _STUDENTS.cpp:53:19: note:   mismatched types ‘con
							      								    								  st std::complex<_Tp>’ and ‘int’    return maxSum /
							      								    								   k ;			  ^ In file included from /u
							      								    								  sr/include/c++/8/valarray:592,		  fr
							      								    								  om /usr/include/c++/8/x86_64-redhat-linux/bits/std
							      								    								  c++.h:95,		     from MAXIMUM_NUMBER_CHO
							      								    								  COLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:1
							      								    								  4: /usr/include/c++/8/bits/valarray_after.h:405:5:
							      								    								   note: candidate: ‘template<class _Dom1, class _Do
							      								    								  m2> std::_Expr<std::_BinClos<std::__divides, std::
							      								    								  _Expr, std::_Expr, _Dom1, _Dom2>, typename std::__
							      								    								  fun<std::__divides, typename _Dom1::value_type>::r
							      								    								  esult_type> std::operator/(const std::_Expr<_Dom1,
							      								    								   typename _Dom1::value_type>&, const std::_Expr<_D
							      								    								  om2, typename _Dom2::value_type>&)’	   _DEFINE_E
							      								    								  XPR_BINARY_OPERATOR(/, __divides)	 ^~~~~~~~~~~
							      								    								  ~~~~~~~~~~~~~~~~~ /usr/include/c++/8/bits/valarray
							      								    								  _after.h:405:5: note:	  template argument deductio
							      								    								  n/substitution failed: MAXIMUM_NUMBER_CHOCOLATES_D
							      								    								  ISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:53:19: not
							      								    								  e:   ‘std::unordered_map<int, int>’ is not derived
							      								    								   from ‘const std::_Expr<_Dom1, typename _Dom1::val
							      								    								  ue_type>’    return maxSum / k ;
							      								    								    ^ In file included from /usr/include/c++/8/valar
							      								    								  ray:592,		    from /usr/include/c++/8/
							      								    								  x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								       from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQ
							      								    								  UALLY_AMONG_K_STUDENTS.cpp:14: /usr/include/c++/8/
							      								    								  bits/valarray_after.h:405:5: note: candidate: ‘tem
							      								    								  plate<class _Dom> std::_Expr<std::_BinClos<std::__
							      								    								  divides, std::_Expr, std::_Constant, _Dom, typenam
							      								    								  e _Dom::value_type>, typename std::__fun<std::__di
							      								    								  vides, typename _Dom1::value_type>::result_type> s
							      								    								  td::operator/(const std::_Expr<_Dom1, typename _Do
							      								    								  m1::value_type>&, const typename _Dom::value_type&
							      								    								  )’	  _DEFINE_EXPR_BINARY_OPERATOR(/, __divides)
							      								    								  	^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c+
							      								    								  +/8/bits/valarray_after.h:405:5: note:   template
							      								    								  argument deduction/substitution failed: MAXIMUM_NU
							      								    								  MBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K_STUDEN
							      								    								  TS.cpp:53:19: note:	‘std::unordered_map<int, int
							      								    								  >’ is not derived from ‘const std::_Expr<_Dom1, ty
							      								    								  pename _Dom1::value_type>’	return maxSum / k ;
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/valarray:592,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :95,			from MAXIMUM_NUMBER_CHOCOLAT
							      								    								  ES_DISTRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /u
							      								    								  sr/include/c++/8/bits/valarray_after.h:405:5: note
							      								    								  : candidate: ‘template<class _Dom> std::_Expr<std:
							      								    								  :_BinClos<std::__divides, std::_Constant, std::_Ex
							      								    								  pr, typename _Dom::value_type, _Dom>, typename std
							      								    								  ::__fun<std::__divides, typename _Dom1::value_type
							      								    								  >::result_type> std::operator/(const typename _Dom
							      								    								  ::value_type&, const std::_Expr<_Dom1, typename _D
							      								    								  om1::value_type>&)’	   _DEFINE_EXPR_BINARY_OPERA
							      								    								  TOR(/, __divides)	 ^~~~~~~~~~~~~~~~~~~~~~~~~~~
							      								    								  ~ /usr/include/c++/8/bits/valarray_after.h:405:5:
							      								    								  note:	  template argument deduction/substitution f
							      								    								  ailed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUAL
							      								    								  LY_AMONG_K_STUDENTS.cpp:53:19: note:	 mismatched
							      								    								  types ‘const std::_Expr<_Dom1, typename _Dom1::val
							      								    								  ue_type>’ and ‘int’	 return maxSum / k ;
							      								    								  	      ^ In file included from /usr/include/c
							      								    								  ++/8/valarray:592,		      from /usr/incl
							      								    								  ude/c++/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  		 from MAXIMUM_NUMBER_CHOCOLATES_DIST
							      								    								  RIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/incl
							      								    								  ude/c++/8/bits/valarray_after.h:405:5: note: candi
							      								    								  date: ‘template<class _Dom> std::_Expr<std::_BinCl
							      								    								  os<std::__divides, std::_Expr, std::_ValArray, _Do
							      								    								  m, typename _Dom::value_type>, typename std::__fun
							      								    								  <std::__divides, typename _Dom1::value_type>::resu
							      								    								  lt_type> std::operator/(const std::_Expr<_Dom1, ty
							      								    								  pename _Dom1::value_type>&, const std::valarray<ty
							      								    								  pename _Dom::value_type>&)’	   _DEFINE_EXPR_BINA
							      								    								  RY_OPERATOR(/, __divides)	 ^~~~~~~~~~~~~~~~~~~
							      								    								  ~~~~~~~~~ /usr/include/c++/8/bits/valarray_after.h
							      								    								  :405:5: note:	  template argument deduction/substi
							      								    								  tution failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUT
							      								    								  ED_EQUALLY_AMONG_K_STUDENTS.cpp:53:19: note:	 ‘st
							      								    								  d::unordered_map<int, int>’ is not derived from ‘c
							      								    								  onst std::_Expr<_Dom1, typename _Dom1::value_type>
							      								    								  ’    return maxSum / k ;		      ^ In f
							      								    								  ile included from /usr/include/c++/8/valarray:592,
							      								    								  		    from /usr/include/c++/8/x86_64-r
							      								    								  edhat-linux/bits/stdc++.h:95,			 fro
							      								    								  m MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AM
							      								    								  ONG_K_STUDENTS.cpp:14: /usr/include/c++/8/bits/val
							      								    								  array_after.h:405:5: note: candidate: ‘template<cl
							      								    								  ass _Dom> std::_Expr<std::_BinClos<std::__divides,
							      								    								   std::_ValArray, std::_Expr, typename _Dom::value_
							      								    								  type, _Dom>, typename std::__fun<std::__divides, t
							      								    								  ypename _Dom1::value_type>::result_type> std::oper
							      								    								  ator/(const std::valarray<typename _Dom::value_typ
							      								    								  e>&, const std::_Expr<_Dom1, typename _Dom1::value
							      								    								  _type>&)’	 _DEFINE_EXPR_BINARY_OPERATOR(/, __d
							      								    								  ivides)      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~ /usr/inc
							      								    								  lude/c++/8/bits/valarray_after.h:405:5: note:	  te
							      								    								  mplate argument deduction/substitution failed: MAX
							      								    								  IMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY_AMONG_K
							      								    								  _STUDENTS.cpp:53:19: note:   mismatched types ‘con
							      								    								  st std::_Expr<_Dom1, typename _Dom1::value_type>’
							      								    								  and ‘int’    return maxSum / k ;
							      								    								    ^ In file included from /usr/include/c++/8/x86_6
							      								    								  4-redhat-linux/bits/stdc++.h:95,
							      								    								  from MAXIMUM_NUMBER_CHOCOLATES_DISTRIBUTED_EQUALLY
							      								    								  _AMONG_K_STUDENTS.cpp:14: /usr/include/c++/8/valar
							      								    								  ray:1175:1: note: candidate: ‘template<class _Tp>
							      								    								  std::_Expr<std::_BinClos<std::__divides, std::_Val
							      								    								  Array, std::_ValArray, _Tp, _Tp>, typename std::__
							      								    								  fun<std::__divides, _Tp>::result_type> std::operat
							      								    								  or/(const std::valarray<_Tp>&, const std::valarray
							      								    								  <_Tp>&)’  _DEFINE_BINARY_OPERATOR(/, __divides)  ^
							      								    								  ~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/valarray
							      								    								  :1175:1: note:   template argument deduction/subst
							      								    								  itution failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIBU
							      								    								  TED_EQUALLY_AMONG_K_STUDENTS.cpp:53:19: note:	  ‘s
							      								    								  td::unordered_map<int, int>’ is not derived from ‘
							      								    								  const std::valarray<_Tp>’    return maxSum / k ;
							      								    								  		    ^ In file included from /usr/inc
							      								    								  lude/c++/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  		  from MAXIMUM_NUMBER_CHOCOLATES_DIS
							      								    								  TRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/inc
							      								    								  lude/c++/8/valarray:1175:1: note: candidate: ‘temp
							      								    								  late<class _Tp> std::_Expr<std::_BinClos<std::__di
							      								    								  vides, std::_ValArray, std::_Constant, _Tp, _Tp>,
							      								    								  typename std::__fun<std::__divides, _Tp>::result_t
							      								    								  ype> std::operator/(const std::valarray<_Tp>&, con
							      								    								  st _Tp&)’  _DEFINE_BINARY_OPERATOR(/, __divides)
							      								    								  ^~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/valarra
							      								    								  y:1175:1: note:   template argument deduction/subs
							      								    								  titution failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRIB
							      								    								  UTED_EQUALLY_AMONG_K_STUDENTS.cpp:53:19: note:   ‘
							      								    								  std::unordered_map<int, int>’ is not derived from
							      								    								  ‘const std::valarray<_Tp>’	return maxSum / k ;
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/x86_64-redhat-linux/bits/stdc++.h:95,
							      								    								  		   from MAXIMUM_NUMBER_CHOCOLATES_DI
							      								    								  STRIBUTED_EQUALLY_AMONG_K_STUDENTS.cpp:14: /usr/in
							      								    								  clude/c++/8/valarray:1175:1: note: candidate: ‘tem
							      								    								  plate<class _Tp> std::_Expr<std::_BinClos<std::__d
							      								    								  ivides, std::_Constant, std::_ValArray, _Tp, _Tp>,
							      								    								   typename std::__fun<std::__divides, _Tp>::result_
							      								    								  type> std::operator/(const _Tp&, const std::valarr
							      								    								  ay<_Tp>&)’  _DEFINE_BINARY_OPERATOR(/, __divides)
							      								    								   ^~~~~~~~~~~~~~~~~~~~~~~ /usr/include/c++/8/valarr
							      								    								  ay:1175:1: note:   template argument deduction/sub
							      								    								  stitution failed: MAXIMUM_NUMBER_CHOCOLATES_DISTRI
							      								    								  BUTED_EQUALLY_AMONG_K_STUDENTS.cpp:53:19: note:
							      								    								  mismatched types ‘const std::valarray<_Tp>’ and ‘i
							      								    								  nt’	 return maxSum / k ;			^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES      PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES	    PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES	  PRINT_POSSIBLE_EDGES_TREE_GIVEN_DIAMETER_HEIGHT_VERTICES
--							      --							    --								  --
def constructTree ( n , d , h ) :			      void constructTree ( int n , int d , int h ) {		    int constructTree ( int n , int d , int h ) {		  script_not_found : None
    if d == 1 :						      	if ( d == 1 ) {						      if ( d == 1 ) {						  
	if n == 2 and h == 1 :				      	  if ( n == 2 && h == 1 ) {				    	if ( n == 2 && h == 1 ) {				  
	    print ( "1 2" )				      	    cout << "1 2" << endl ;				    	  cout << "1 2" ;					  
	    return 0					      	    return ;						    	  return 0 ;						  
	print ( "-1" )					      	  }							    	}							  
	return 0					      	  cout << "-1" << endl ;				    	cout << "-1" ;						  
    if d > 2 * h :					      	  return ;						    	return 0 ;						  
	print ( "-1" )					      	}							      }								  
	return 0					      	if ( d > 2 * h ) {					      if ( d > 2 * h ) {					  
    for i in range ( 1 , h + 1 ) :			      	  cout << "-1" << endl ;				    	cout << "-1" ;						  
	print ( i , " " , i + 1 )			      	  return ;						    	return 0 ;						  
    if d > h :						      	}							      }								  
	print ( 1 , "  " , h + 2 )			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	for i in range ( h + 2 , d + 1 ) :		      	i <= h ;						      i <= h ;							  
	    print ( i , " " , i + 1 )			      	i ++ ) cout << i << " " << i + 1 << endl ;		      i ++ ) cout << i << " " << i + 1 ;			  
    for i in range ( d + 1 , n ) :			      	if ( d > h ) {						      if ( d > h ) {						  
	k = 1						      	  cout << "1" << " " << h + 2 << endl ;			    	cout << 1 << "	" << h + 2 ;				  
	if d == h :					      	  for ( int i = h + 2 ;					    	for ( int i = h + 2 ;					  
	    k = 2					      	  i <= d ;						    	i <= d ;						  
	print ( k , " " , i + 1 )			      	  i ++ ) {						    	i ++ ) cout << i << " " << i + 1 ;			  
							      	    cout << i << " " << i + 1 << endl ;			      }								  
							      	  }							      for ( int i = d + 1 ;					  
							      	}							      i <= n ;							  
							      	for ( int i = d + 1 ;					      i ++ ) {							  
							      	i < n ;							    	int k = 1 ;						  
							      	i ++ ) {						    	if ( d == h ) k = 2 ;					  
							      	  int k = 1 ;						    	cout << k << " " << i + 1 ;				  
							      	  if ( d == h ) k = 2 ;					      }								  
							      	  cout << k << " " << i + 1 << endl ;			      return 0 ;						  
							      	}							      return n * n ;						  
							      }								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE    MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE    MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE	  MAXIMUM_PROFIT_BY_BUYING_AND_SELLING_A_SHARE_AT_MOST_TWICE
--							      --							    --								  --
def maxProfit ( price , n ) :				      int maxProfit ( int price [ ] , int n ) {			    int maxProfit ( int * price , int n ) {			  failure : #Results: 6, 10
    profit = [ 0 ] * n					      	int * profit = new int [ n ] ;				      int * profit = new int [ n ] ;				  
    max_price = price [ n - 1 ]				      	for ( int i = 0 ;					      int maxPrice = price [ n - 1 ] ;				  
    for i in range ( n - 2 , 0 , - 1 ) :		      	i < n ;							      for ( int i = n - 2 ;					  
	if price [ i ] > max_price :			      	i ++ ) profit [ i ] = 0 ;				      i > 0 ;							  
	    max_price = price [ i ]			      	int max_price = price [ n - 1 ] ;			      i -- ) {							  
	profit [ i ] = max ( profit [ i + 1 ] , max_price - p 	for ( int i = n - 2 ;					    	if ( price [ i ] > maxPrice ) maxPrice = price [ i ] ;	  
    min_price = price [ 0 ]				      	i >= 0 ;						    	profit [ i ] = max ( profit [ i + 1 ] , maxPrice - price  
    for i in range ( 1 , n ) :				      	i -- ) {						      }								  
	if price [ i ] < min_price :			      	  if ( price [ i ] > max_price ) max_price = price [ i ] ;    int minPrice = price [ 0 ] ;				  
	    min_price = price [ i ]			      	  profit [ i ] = max ( profit [ i + 1 ] , max_price - price   for ( int i = 1 ;						  
	profit [ i ] = max ( profit [ i - 1 ] , profit [ i ]  	}							      i < n ;							  
    result = profit [ n - 1 ]				      	int min_price = price [ 0 ] ;				      i ++ ) {							  
    return result					      	for ( int i = 1 ;					    	if ( price [ i ] < minPrice ) minPrice = price [ i ] ;	  
							      	i < n ;							    	profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + (  
							      	i ++ ) {						      }								  
							      	  if ( price [ i ] < min_price ) min_price = price [ i ] ;    int result = profit [ n - 1 ] ;				  
							      	  profit [ i ] = max ( profit [ i - 1 ] , profit [ i ] + (    delete [ ] profit ;					  
							      	}							      return result ;						  
							      	int result = profit [ n - 1 ] ;				    }								  
							      	delete [ ] profit ;					    								  
							      	return result ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS			      FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS			    FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS			  FIND_K_PAIRS_SMALLEST_SUMS_TWO_ARRAYS
--							      --							    --								  --
def kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) :	      void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , i int kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , in script_not_found : None
    if ( k > n1 * n2 ) :				      	if ( k > n1 * n2 ) {					      if ( ( k > n1 * n2 ) ) {					  
	print ( "k pairs don't exist" )			      	  cout << "k pairs don't exist" ;			    	cout << "k pairs don't exist" << endl ;			  
	return						      	  return ;						    	return 0 ;						  
    index2 = [ 0 for i in range ( n1 ) ]		      	}							      }								  
    while ( k > 0 ) :					      	int index2 [ n1 ] ;					      int index2 [ n1 ] ;					  
	min_sum = sys.maxsize				      	memset ( index2 , 0 , sizeof ( index2 ) ) ;		      for ( int i = 0 ;						  
	min_index = 0					      	while ( k > 0 ) {					      i < n1 ;							  
	for i1 in range ( 0 , n1 , 1 ) :		      	  int min_sum = INT_MAX ;				      i ++ ) index2 [ i ] = 0 ;					  
	    if ( index2 [ i1 ] < n2 and arr1 [ i1 ] + arr2 [  	  int min_index = 0 ;					      while ( ( k > 0 ) && ( k < n1 ) ) {			  
		min_index = i1				      	  for ( int i1 = 0 ;					    	int minSum = INT_MAX ;					  
		min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ]  	  i1 < n1 ;						    	int minIndex = 0 ;					  
	print ( "(" , arr1 [ min_index ] , "," , arr2 [ index 	  i1 ++ ) {						    	for ( int i1 = 0 ;					  
	index2 [ min_index ] += 1			      	    if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2  	i1 < n1 ;						  
	k -= 1						      	      min_index = i1 ;					    	i1 += 1 ) {						  
							      	      min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ;	    	  if ( ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index 
							      	    }							    	    minIndex = i1 ;					  
							      	  }							    	    minSum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ;	  
							      	  cout << "(" << arr1 [ min_index ] << ", " << arr2 [ index 	  }							  
							      	  index2 [ min_index ] ++ ;				    	}							  
							      	  k -- ;						    	cout << "(" << arr1 [ minIndex ] << "," << arr2 [ index2  
							      	}							    	index2 [ minIndex ] ++ ;				  
							      }								    	k -- ;							  
							      								      }								  
							      								    }								  
							      								    return k ;							  
							      								    return n1 * n1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT		      CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT			    CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT			  CHECK_GIVEN_MATRIX_IS_MAGIC_SQUARE_OR_NOT
--							      --							    --								  --
def isMagicSquare ( mat ) :				      bool isMagicSquare ( int mat [ ] [ N ] ) {		    bool isMagicSquare ( int * * mat ) {			  script_not_found : None
    s = 0						      	int sum = 0 , sum2 = 0 ;				      int s = 0 ;						  
    for i in range ( 0 , N ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	s = s + mat [ i ] [ i ]				      	i < N ;							      i != N ;							  
    s2 = 0						      	i ++ ) sum = sum + mat [ i ] [ i ] ;			      i ++ ) s = s + mat [ i ] [ i ] ;				  
    for i in range ( 0 , N ) :				      	for ( int i = 0 ;					      int s2 = 0 ;						  
	s2 = s2 + mat [ i ] [ N - i - 1 ]		      	i < N ;							      for ( int i = 0 ;						  
    if ( s != s2 ) :					      	i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ;		      i != N ;							  
	return False					      	if ( sum != sum2 ) return false ;			      i ++ ) s2 = s2 + mat [ i ] [ N - i - 1 ] ;		  
    for i in range ( 0 , N ) :				      	for ( int i = 0 ;					      if ( ( s != s2 ) ) return false ;				  
	rowSum = 0					      	i < N ;							      for ( int i = 0 ;						  
	for j in range ( 0 , N ) :			      	i ++ ) {						      i != N ;							  
	    rowSum += mat [ i ] [ j ]			      	  int rowSum = 0 ;					      i ++ ) {							  
	if ( rowSum != s ) :				      	  for ( int j = 0 ;					    	int rowSum = 0 ;					  
	    return False				      	  j < N ;						    	for ( int j = 0 ;					  
    for i in range ( 0 , N ) :				      	  j ++ ) rowSum += mat [ i ] [ j ] ;			    	j != N ;						  
	colSum = 0					      	  if ( rowSum != sum ) return false ;			    	j ++ ) rowSum += mat [ i ] [ j ] ;			  
	for j in range ( 0 , N ) :			      	}							    	if ( ( rowSum != s ) ) return false ;			  
	    colSum += mat [ j ] [ i ]			      	for ( int i = 0 ;					      }								  
	if ( s != colSum ) :				      	i < N ;							      for ( int i = 0 ;						  
	    return False				      	i ++ ) {						      i != N ;							  
    return True						      	  int colSum = 0 ;					      i ++ ) {							  
							      	  for ( int j = 0 ;					    	int colSum = 0 ;					  
							      	  j < N ;						    	for ( int j = 0 ;					  
							      	  j ++ ) colSum += mat [ j ] [ i ] ;			    	j != N ;						  
							      	  if ( sum != colSum ) return false ;			    	j ++ ) colSum += mat [ j ] [ i ] ;			  
							      	}							    	if ( ( s != colSum ) ) return false ;			  
							      	return true ;						      }								  
							      }								      return true ;						  
							      								      return mat [ N ] == mat [ N - 1 ] ;			  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS	      FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS		    FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS		  FIND_PAIRS_GIVEN_SUM_ELEMENTS_PAIR_DIFFERENT_ROWS
--							      --							    --								  --
def pairSum ( mat , n , sum ) :				      void pairSum ( int mat [ ] [ MAX ] , int n , int sum ) {	    int pairSum ( int * * mat , int n , int sum ) {		  script_not_found : None
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	mat [ i ].sort ( )				      	i < n ;							      i < n ;							  
    for i in range ( n - 1 ) :				      	i ++ ) sort ( mat [ i ] , mat [ i ] + n ) ;		      i ++ ) {							  
	for j in range ( i + 1 , n ) :			      	for ( int i = 0 ;					    	sort ( mat [ i ] , mat [ i ] + n , compare ) ;		  
	    left = 0					      	i < n - 1 ;						      }								  
	    right = n - 1				      	i ++ ) {						      for ( int i = 0 ;						  
	    while ( left < n and right >= 0 ) :		      	  for ( int j = i + 1 ;					      i < n - 1 ;						  
		if ( ( mat [ i ] [ left ] + mat [ j ] [ right 	  j < n ;						      i ++ ) {							  
		    print ( "(" , mat [ i ] [ left ] , ", " , 	  j ++ ) {						    	for ( int j = i + 1 ;					  
		    left += 1				      	    int left = 0 , right = n - 1 ;			    	j < n ;							  
		    right -= 1				      	    while ( left < n && right >= 0 ) {			    	j ++ ) {						  
		else :					      	      if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) ==  	  int left = 0 ;					  
		    if ( ( mat [ i ] [ left ] + mat [ j ] [ r 		cout << "(" << mat [ i ] [ left ] << ", " << mat [  	  int right = n - 1 ;					  
			left += 1			      		left ++ ;					    	  while ( ( left < n ) && ( right >= 0 ) ) {		  
		    else :				      		right -- ;					    	    if ( ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) = 
			right -= 1			      	      }							    	      cout << "(" << mat [ i ] [ left ] << ", " << mat [  
							      	      else {						    	      left ++ ;						  
							      		if ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) < 	      right -- ;					  
							      		else right -- ;					    	    }							  
							      	      }							    	    else {						  
							      	    }							    	      if ( ( ( mat [ i ] [ left ] + mat [ j ] [ right ] ) 
							      	  }							    		left ++ ;					  
							      	}							    	      }							  
							      }								    	      else {						  
							      								    		right -- ;					  
							      								    	      }							  
							      								    	    }							  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								    }								  
							      								    return n ;							  
							      								    return n * n ;						  
							      								    return n * n ;						  
							      								    return n * n * n * n * n * n * n * n * n * n * n * n * n * n  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY		      FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY			    FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY			  FIND_MINIMUM_ADJUSTMENT_COST_OF_AN_ARRAY
--							      --							    --								  --
def minAdjustmentCost ( A , n , target ) :		      int minAdjustmentCost ( int A [ ] , int n , int target ) {    int minAdjustmentCost ( int * A , int n , int target ) {	  script_not_found : None
    dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n  	int dp [ n ] [ M + 1 ] ;				      vector < vector < int >> dp ( M + 1 , vector < int > ( n ,  
    for j in range ( M + 1 ) :				      	for ( int j = 0 ;					      for ( int i = 0 ;						  
	dp [ 0 ] [ j ] = abs ( j - A [ 0 ] )		      	j <= M ;						      i < n ;							  
    for i in range ( 1 , n ) :				      	j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ;		      i ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ;		  
	for j in range ( M + 1 ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	    dp [ i ] [ j ] = 100000000			      	i < n ;							      i < n ;							  
	    for k in range ( max ( j - target , 0 ) , min ( M 	i ++ ) {						      i ++ ) {							  
		dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [  	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
    res = 10000000					      	  j <= M ;						    	j < M + 1 ;						  
    for j in range ( M + 1 ) :				      	  j ++ ) {						    	j ++ ) {						  
	res = min ( res , dp [ n - 1 ] [ j ] )		      	    dp [ i ] [ j ] = INT_MAX ;				    	  dp [ i ] [ j ] = 100000000 ;				  
    return res						      	    for ( int k = max ( j - target , 0 ) ;		    	  for ( int k = max < int > ( j - target , 0 ) ;	  
							      	    k <= min ( M , j + target ) ;			    	  k < min < int > ( M , j + target ) + 1 ;		  
							      	    k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 	  k ++ ) dp [ i ] [ j ] = min < int > ( dp [ i ] [ j ] ,  
							      	  }							    	}							  
							      	}							      }								  
							      	int res = INT_MAX ;					      int res = 10000000 ;					  
							      	for ( int j = 0 ;					      for ( int j = 0 ;						  
							      	j <= M ;						      j < M + 1 ;						  
							      	j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ;		      j ++ ) res = min < int > ( res , dp [ n - 1 ] [ j ] ) ;	  
							      	return res ;						      return res ;						  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY			      MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY			    MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY				  MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY
--							      --							    --								  --
def largestSumOfAverages ( A , K ) :			      double largestSumOfAverages ( vector < int > & A , int K ) {  int largestSumOfAverages ( string A , int K ) {		  error : MAXIMUM_AVERAGE_SUM_PARTITION_ARRAY.cpp: I
    n = len ( A )					      	int n = A . size ( ) ;					      int n = A . length ( ) ;					  n function ‘int main()’: MAXIMUM_AVERAGE_SUM_PARTI
    pre_sum = [ 0 ] * ( n + 1 )				      	double pre_sum [ n + 1 ] ;				      vector < int > pre_sum ( n + 1 , 0 ) ;			  TION_ARRAY.cpp:73:102: error: could not convert ‘p
    pre_sum [ 0 ] = 0					      	pre_sum [ 0 ] = 0 ;					      pre_sum [ 0 ] = 0 ;					  aram0.std::vector<std::vector<int> >::operator[]((
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  (std::vector<std::vector<int> >::size_type)i))’ fr
	pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ]	      	i < n ;							      i < n ;							  om ‘__gnu_cxx::__alloc_traits<std::allocator<std::
    dp = [ 0 ] * n					      	i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ;	      i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ;	  vector<int> >, std::vector<int> >::value_type’ {ak
    sum = 0						      	double dp [ n ] = {					      vector < int > dp ( n , 0 ) ;				  a ‘std::vector<int>’} to ‘std::__cxx11::string’ {a
    for i in range ( n ) :				      	  0 }							      int sum = 0 ;						  ka ‘std::__cxx11::basic_string<char>’}	  if
	dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n -  	  ;							      for ( int i = 0 ;						  (abs(1 - (0.0000001 + abs(f_gold(param0[i],param1[
    for k in range ( K - 1 ) :				      	  double sum = 0 ;					      i < n ;							  i])) )/ (abs(f_filled(param0[i],param1[i])) + 0.00
	for i in range ( n ) :				      	  for ( int i = 0 ;					      i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - 00001)) < 0.001)
	    for j in range ( i + 1 , n ) :		      	  i < n ;						      for ( int k = 0 ;						  
		dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - 	  i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n   k < K - 1 ;						  		     ^
    return int ( dp [ 0 ] )				      	  for ( int k = 0 ;					      k ++ ) {							  
							      	  k < K - 1 ;						    	for ( int i = 0 ;					  
							      	  k ++ ) for ( int i = 0 ;				    	i < n ;							  
							      	  i < n ;						    	i ++ ) {						  
							      	  i ++ ) for ( int j = i + 1 ;				    	  for ( int j = i + 1 ;					  
							      	  j < n ;						    	  j < n ;						  
							      	  j ++ ) dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_ 	  j ++ ) dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pr 
							      	  return dp [ 0 ] ;					    	}							  
							      	}							      }								  
							      								      return ( int ) dp [ 0 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1		      FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1		    FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1			  FIND_LARGEST_D_IN_ARRAY_SUCH_THAT_A_B_C_D_1
--							      --							    --								  --
def findFourElements ( arr , n ) :			      int findFourElements ( int arr [ ] , int n ) {		    int findFourElements ( int * arr , int n ) {		  failure : #Results: 9, 10
    mp = dict ( )					      	unordered_map < int , pair < int , int >> mp ;		      map < int , pair < int , int >> mp ;			  
    for i in range ( n - 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	i < n - 1 ;						      i < n - 1 ;						  
	    mp [ arr [ i ] + arr [ j ] ] = ( i , j )	      	i ++ ) for ( int j = i + 1 ;				      i ++ ) {							  
    d = - 10 ** 9					      	j < n ;							    	for ( int j = i + 1 ;					  
    for i in range ( n - 1 ) :				      	j ++ ) mp [ arr [ i ] + arr [ j ] ] = {			    	j < n ;							  
	for j in range ( i + 1 , n ) :			      	  i , j }						    	j ++ ) {						  
	    abs_diff = abs ( arr [ i ] - arr [ j ] )	      	  ;							    	  mp [ arr [ i ] + arr [ j ] ] = make_pair ( i , j ) ;	  
	    if abs_diff in mp.keys ( ) :		      	  int d = INT_MIN ;					    	}							  
		p = mp [ abs_diff ]			      	  for ( int i = 0 ;					      }								  
		if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1  	  i < n - 1 ;						      int d = - 10 * 9 ;					  
		    d = max ( d , max ( arr [ i ] , arr [ j ] 	  i ++ ) {						      for ( int i = 0 ;						  
    return d						      	    for ( int j = i + 1 ;				      i < n - 1 ;						  
							      	    j < n ;						      i ++ ) {							  
							      	    j ++ ) {						    	for ( int j = i + 1 ;					  
							      	      int abs_diff = abs ( arr [ i ] - arr [ j ] ) ;	    	j < n ;							  
							      	      if ( mp . find ( abs_diff ) != mp . end ( ) ) {	    	j ++ ) {						  
							      		pair < int , int > p = mp [ abs_diff ] ;	    	  int abs_diff = abs ( arr [ i ] - arr [ j ] ) ;	  
							      		if ( p . first != i && p . first != j && p . second 	  if ( mp . count ( abs_diff ) ) {			  
							      	      }							    	    pair < int , int > p = mp [ abs_diff ] ;		  
							      	    }							    	    if ( ( p . first != i && p . first != j && p . second 
							      	  }							    	  }							  
							      	  return d ;						    	}							  
							      	}							      }								  
							      								      return d ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_N_DIGIT_STEPPING_NUMBERS				      NUMBER_N_DIGIT_STEPPING_NUMBERS				    NUMBER_N_DIGIT_STEPPING_NUMBERS				  NUMBER_N_DIGIT_STEPPING_NUMBERS
--							      --							    --								  --
def answer ( n ) :					      long long answer ( int n ) {				    int answer ( int n ) {					  error : /bin/bash: line 1: 1848143 Segmentation fa
    dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 	int dp [ n + 1 ] [ 10 ] ;				      vector < vector < int >> dp ( 10 , vector < int > ( n + 1 , ult	   (core dumped) ./NUMBER_N_DIGIT_STEPPING_N
    if ( n == 1 ) :					      	if ( n == 1 ) return 10 ;				      for ( int y = 0 ;						  UMBERS_cpp
	return 10					      	for ( int j = 0 ;					      y < dp [ n ] . size ( ) ;					  
    for j in range ( 10 ) :				      	j <= 9 ;						      y ++ ) {							  
	dp [ 1 ] [ j ] = 1				      	j ++ ) dp [ 1 ] [ j ] = 1 ;				    	for ( int j = 0 ;					  
    for i in range ( 2 , n + 1 ) :			      	for ( int i = 2 ;					    	j < 10 ;						  
	for j in range ( 10 ) :				      	i <= n ;						    	j ++ ) dp [ 1 ] [ j ] = 1 ;				  
	    if ( j == 0 ) :				      	i ++ ) {						      }								  
		dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]	      	  for ( int j = 0 ;					      for ( int i = 2 ;						  
	    elif ( j == 9 ) :				      	  j <= 9 ;						      i <= n ;							  
		dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]	      	  j ++ ) {						      i ++ ) {							  
	    else :					      	    if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; 	for ( int j = 0 ;					  
		dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + d 	    else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j -  	j < 10 ;						  
    sum = 0						      	    else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 	j ++ ) {						  
    for j in range ( 1 , 10 ) :				      	  }							    	  if ( ( j == 0 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 
	sum = sum + dp [ n ] [ j ]			      	}							    	  else if ( ( j == 9 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [  
    return sum						      	long long sum = 0 ;					    	  else dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i 
							      	for ( int j = 1 ;					    	}							  
							      	j <= 9 ;						      }								  
							      	j ++ ) sum += dp [ n ] [ j ] ;				      int sum = 0 ;						  
							      	return sum ;						      for ( int j = 1 ;						  
							      }								      j < 10 ;							  
							      								      j ++ ) sum = sum + dp [ n ] [ j ] ;			  
							      								      return sum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE    DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE    DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_12_LONGEST_PALINDROMIC_SUBSEQUENCE
--							      --							    --								  --
def lps ( str ) :					      int lps ( char * str ) {					    int lps ( string str ) {					  script_not_found : None
    n = len ( str )					      	int n = strlen ( str ) ;				      int n = str . length ( ) ;				  
    L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ]   	int i , j , cl ;					      vector < vector < int >> L ( n , 0 ) ;			  
    for i in range ( n ) :				      	int L [ n ] [ n ] ;					      for ( int i = 0 ;						  
	L [ i ] [ i ] = 1				      	for ( i = 0 ;						      i < n ;							  
    for cl in range ( 2 , n + 1 ) :			      	i < n ;							      i ++ ) L [ i ] [ i ] = 1 ;				  
	for i in range ( n - cl + 1 ) :			      	i ++ ) L [ i ] [ i ] = 1 ;				      for ( int cl = 2 ;					  
	    j = i + cl - 1				      	for ( cl = 2 ;						      cl <= n ;							  
	    if str [ i ] == str [ j ] and cl == 2 :	      	cl <= n ;						      cl ++ ) {							  
		L [ i ] [ j ] = 2			      	cl ++ ) {						    	for ( int i = 0 ;					  
	    elif str [ i ] == str [ j ] :		      	  for ( i = 0 ;						    	i < n - cl + 1 ;					  
		L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2     	  i < n - cl + 1 ;					    	i ++ ) {						  
	    else :					      	  i ++ ) {						    	  int j = i + cl - 1 ;					  
		L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ 	    j = i + cl - 1 ;					    	  if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ]  
    return L [ 0 ] [ n - 1 ]				      	    if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ]  	  else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [  
							      	    else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [  	  else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i +  
							      	    else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i +  	  ;							  
							      	  }							    	}							  
							      	}							      }								  
							      	return L [ 0 ] [ n - 1 ] ;				      return L [ 0 ] [ n - 1 ] ;				  
							      }								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY		      COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY		    COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY		  COUNT_ARITHMETIC_PROGRESSION_SUBSEQUENCES_ARRAY
--							      --							    --								  --
def numofAP ( a , n ) :					      int numofAP ( int a [ ] , int n ) {			    int numofAP ( int a [ ] , int n ) {				  script_not_found : None
    minarr = + 2147483647				      	int minarr = INT_MAX , maxarr = INT_MIN ;		      int minarr = + 2147483647 ;				  
    maxarr = - 2147483648				      	for ( int i = 0 ;					      int maxarr = - 2147483648 ;				  
    for i in range ( n ) :				      	i < n ;							      for ( int i = 0 ;						  
	minarr = min ( minarr , a [ i ] )		      	i ++ ) {						      i < n ;							  
	maxarr = max ( maxarr , a [ i ] )		      	  minarr = min ( minarr , a [ i ] ) ;			      i ++ ) {							  
    dp = [ 0 for i in range ( n + 1 ) ]			      	  maxarr = max ( maxarr , a [ i ] ) ;			    	minarr = min ( minarr , a [ i ] ) ;			  
    ans = n + 1						      	}							    	maxarr = max ( maxarr , a [ i ] ) ;			  
    for d in range ( ( minarr - maxarr ) , ( maxarr - minarr  	int dp [ n ] , sum [ MAX ] ;				      }								  
	sum = [ 0 for i in range ( MAX + 1 ) ]		      	int ans = n + 1 ;					      vector < int > dp ( n + 1 , 0 ) ;				  
	for i in range ( n ) :				      	for ( int d = ( minarr - maxarr ) ;			      int ans = n + 1 ;						  
	    dp [ i ] = 1				      	d <= ( maxarr - minarr ) ;				      for ( int d = ( minarr - maxarr ) ;			  
	    if ( a [ i ] - d >= 1 and a [ i ] - d <= 1000000  	d ++ ) {						      d <= ( maxarr - minarr ) ;				  
		dp [ i ] += sum [ a [ i ] - d ]		      	  memset ( sum , 0 , sizeof sum ) ;			      d ++ ) {							  
	    ans += dp [ i ] - 1				      	  for ( int i = 0 ;					    	vector < int > sum ( MAX + 1 , 0 ) ;			  
	    sum [ a [ i ] ] += dp [ i ]			      	  i < n ;						    	for ( int i = 0 ;					  
    return ans						      	  i ++ ) {						    	i < n ;							  
							      	    dp [ i ] = 1 ;					    	i ++ ) {						  
							      	    if ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) dp [  	  dp [ i ] = 1 ;					  
							      	    ans += dp [ i ] - 1 ;				    	  if ( ( a [ i ] - d >= 1 && a [ i ] - d <= 1000000 ) ) d 
							      	    sum [ a [ i ] ] += dp [ i ] ;			    	  ans += dp [ i ] - 1 ;					  
							      	  }							    	  sum [ a [ i ] ] += dp [ i ] ;				  
							      	}							    	}							  
							      	return ans ;						      }								  
							      }								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX	      MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX	    MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX		  MAXIMUM_WEIGHT_PATH_ENDING_ELEMENT_LAST_ROW_MATRIX
--							      --							    --								  --
def maxCost ( mat , N ) :				      int maxCost ( int mat [ ] [ MAX ] , int N ) {		    int maxCost ( int * * mat , int N ) {			  script_not_found : None
    dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ]  	int dp [ N ] [ N ] ;					      vector < vector < int >> dp ( N , vector < int > ( N , 0 )  
    dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ]			      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int j = 0 ;						  
    for i in range ( 1 , N ) :				      	dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ;			      j < N ;							  
	dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] 	for ( int i = 1 ;					      j ++ ) dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ;			  
    for i in range ( 1 , N ) :				      	i < N ;							      for ( int i = 1 ;						  
	for j in range ( 1 , min ( i + 1 , N ) ) :	      	i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0    i < N ;							  
	    dp [ i ] [ j ] = mat [ i ] [ j ] + \	      	for ( int i = 1 ;					      i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0  
		max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ 	i < N ;							      for ( int i = 1 ;						  
    result = 0						      	i ++ ) for ( int j = 1 ;				      i < N ;							  
    for i in range ( N ) :				      	j < i + 1 && j < N ;					      i ++ ) for ( int j = 1 ;					  
	if ( result < dp [ N - 1 ] [ i ] ) :		      	j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1    j < min < int > ( i + 1 , N ) ;				  
	    result = dp [ N - 1 ] [ i ]			      	int result = 0 ;					      j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] +			  
    return result					      	for ( int i = 0 ;					    								  
							      	i < N ;							    								  
							      	i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 								  
							      	return result ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PATH_MAXIMUM_AVERAGE_VALUE				      PATH_MAXIMUM_AVERAGE_VALUE				    PATH_MAXIMUM_AVERAGE_VALUE					  PATH_MAXIMUM_AVERAGE_VALUE
--							      --							    --								  --
def maxAverageOfPath ( cost , N ) :			      double maxAverageOfPath ( int cost [ M ] [ M ] , int N ) {    double maxAverageOfPath ( vector < vector < int >> cost , int script_not_found : None
    dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N  	int dp [ N + 1 ] [ N + 1 ] ;				      vector < vector < int >> dp ( N + 1 , vector < int > ( N +  
    dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]			      	dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;			      dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;			  
    for i in range ( 1 , N ) :				      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0  	i < N ;							      i < N ;							  
    for j in range ( 1 , N ) :				      	i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0   i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 
	dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j  	for ( int j = 1 ;					      for ( int j = 1 ;						  
    for i in range ( 1 , N ) :				      	j < N ;							      j < N ;							  
	for j in range ( 1 , N ) :			      	j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j   j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j 
	    dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [  	for ( int i = 1 ;					      for ( int i = 1 ;						  
    return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 )	      	i < N ;							      i < N ;							  
							      	i ++ ) for ( int j = 1 ;				      i ++ ) for ( int j = 1 ;					  
							      	j <= N ;						      j < N ;							  
							      	j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ]   j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] 
							      	return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ;    return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ;		  
							      }								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINTING_STRING_PLUS_PATTERN_MATRIX			      PRINTING_STRING_PLUS_PATTERN_MATRIX			    PRINTING_STRING_PLUS_PATTERN_MATRIX				  PRINTING_STRING_PLUS_PATTERN_MATRIX
--							      --							    --								  --
def carveCross ( str ) :				      void carveCross ( string str ) {				    int carveCross ( string str ) {				  script_not_found : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    if ( n % 2 == 0 ) :					      	if ( n % 2 == 0 ) {					      if ( ( n % 2 == 0 ) ) cout << "Not possible. Please enter " 
	print ( "Not possible.Please enter " , "odd length st 	  cout << "Not possible. Please enter " << "odd length stri   else {							  
    else :						      	}							    	vector < vector < bool >> arr ( max , vector < bool > ( m 
	arr = [ [ False for x in range ( max ) ] for y in ran 	else {							    	for ( int y = 0 ;					  
	m = n // 2					      	  char arr [ max ] [ max ] ;				    	y < max ;						  
	for i in range ( n ) :				      	  int m = n / 2 ;					    	y ++ ) {						  
	    for j in range ( n ) :			      	  for ( int i = 0 ;					    	  for ( int x = 0 ;					  
		arr [ i ] [ j ] = 'X'			      	  i < n ;						    	  x < max ;						  
	for i in range ( n ) :				      	  i ++ ) {						    	  x ++ ) arr [ i ] [ x ] = false ;			  
	    arr [ i ] [ m ] = str [ i ]			      	    for ( int j = 0 ;					    	}							  
	for i in range ( n ) :				      	    j < n ;						    	for ( int i = 0 ;					  
	    arr [ m ] [ i ] = str [ i ]			      	    j ++ ) {						    	i < n ;							  
	for i in range ( n ) :				      	      arr [ i ] [ j ] = 'X' ;				    	i ++ ) arr [ i ] [ m ] = str [ i ] ;			  
	    for j in range ( n ) :			      	    }							    	for ( int i = 0 ;					  
		print ( arr [ i ] [ j ] , end = " " )	      	  }							    	i < n ;							  
	    print ( )					      	  for ( int i = 0 ;					    	i ++ ) arr [ m ] [ i ] = str [ i ] ;			  
							      	  i < n ;						    	for ( int i = 0 ;					  
							      	  i ++ ) {						    	i < n ;							  
							      	    arr [ i ] [ m ] = str [ i ] ;			    	i ++ ) {						  
							      	  }							    	  for ( int j = 0 ;					  
							      	  for ( int i = 0 ;					    	  j < n ;						  
							      	  i < n ;						    	  j ++ ) cout << arr [ i ] [ j ] << " " ;		  
							      	  i ++ ) {						    	  cout << endl ;					  
							      	    arr [ m ] [ i ] = str [ i ] ;			    	}							  
							      	  }							      }								  
							      	  for ( int i = 0 ;					      return n ;						  
							      	  i < n ;						      return n * n ;						  
							      	  i ++ ) {						      return n * n ;						  
							      	    for ( int j = 0 ;					      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      	    j < n ;						    }								  
							      	    j ++ ) {						    								  
							      	      cout << arr [ i ] [ j ] << " " ;			    								  
							      	    }							    								  
							      	    cout << "\n" ;					    								  
							      	  }							    								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE SMALLEST_SUBARRAY_WITH_ALL_OCCURRENCES_OF_A_MOST_FREQUENT_ELE
--							      --							    --								  --
def smallestSubsegment ( a , n ) :			      void smallestSubsegment ( int a [ ] , int n ) {		    int smallestSubsegment ( int a [ ] , int n ) {		  script_not_found : None
    left = dict ( )					      	unordered_map < int , int > left ;			      map < int , int > left ;					  
    count = dict ( )					      	unordered_map < int , int > count ;			      map < int , int > count ;					  
    mx = 0						      	int mx = 0 ;						      int mx = 0 , mn = 0 , strindex = 0 ;			  
    mn , strindex = 0 , 0				      	int mn , strindex ;					      for ( int i = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      i < n ;							  
	x = a [ i ]					      	i < n ;							      i ++ ) {							  
	if ( x not in count.keys ( ) ) :		      	i ++ ) {						    	int x = a [ i ] ;					  
	    left [ x ] = i				      	  int x = a [ i ] ;					    	if ( ( x != 0 ) && ( count . count ( x ) != 0 ) ) {	  
	    count [ x ] = 1				      	  if ( count [ x ] == 0 ) {				    	  left [ x ] = i ;					  
	else :						      	    left [ x ] = i ;					    	  count [ x ] = 1 ;					  
	    count [ x ] += 1				      	    count [ x ] = 1 ;					    	}							  
	if ( count [ x ] > mx ) :			      	  }							    	else {							  
	    mx = count [ x ]				      	  else count [ x ] ++ ;					    	  count [ x ] ++ ;					  
	    mn = i - left [ x ] + 1			      	  if ( count [ x ] > mx ) {				    	}							  
	    strindex = left [ x ]			      	    mx = count [ x ] ;					    	if ( ( count [ x ] > mx ) ) {				  
	elif ( count [ x ] == mx and i - left [ x ] + 1 < mn  	    mn = i - left [ x ] + 1 ;				    	  mx = count [ x ] ;					  
	    mn = i - left [ x ] + 1			      	    strindex = left [ x ] ;				    	  mn = i - left [ x ] + 1 ;				  
	    strindex = left [ x ]			      	  }							    	  strindex = left [ x ] ;				  
    for i in range ( strindex , strindex + mn ) :	      	  else if ( count [ x ] == mx && i - left [ x ] + 1 < mn )  	}							  
	print ( a [ i ] , end = " " )			      	    mn = i - left [ x ] + 1 ;				    	else if ( ( count [ x ] == mx ) && ( i - left [ x ] + 1 < 
							      	    strindex = left [ x ] ;				    	  mn = i - left [ x ] + 1 ;				  
							      	  }							    	  strindex = left [ x ] ;				  
							      	}							    	}							  
							      	for ( int i = strindex ;				      }								  
							      	i < strindex + mn ;					      for ( int i = strindex ;					  
							      	i ++ ) cout << a [ i ] << " " ;				      i < strindex + mn ;					  
							      }								      i ++ ) cout << a [ i ] << " " ;				  
							      								      return strindex ;						  
							      								      return a * a * a * a * a * a * a * a * a * a * a * a * a *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY	      FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY	    FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY	  FIND_INDEX_MAXIMUM_OCCURRING_ELEMENT_EQUAL_PROBABILITY
--							      --							    --								  --
def findRandomIndexOfMax ( arr , n ) :			      void findRandomIndexOfMax ( int arr [ ] , int n ) {	    int findRandomIndexOfMax ( int * arr , int n ) {		  script_not_found : None
    mp = dict ( )					      	unordered_map < int , int > freq ;			      map < int , int > mp ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( arr [ i ] in mp ) :			      	i < n ;							      i < n ;							  
	    mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1	      	i ++ ) freq [ arr [ i ] ] += 1 ;			      i ++ ) {							  
	else :						      	int max_element ;					    	if ( mp . count ( arr [ i ] ) ) mp [ arr [ i ] ] = mp [ a 
	    mp [ arr [ i ] ] = 1			      	int max_so_far = INT_MIN ;				    	else mp [ arr [ i ] ] = 1 ;				  
    max_element = - 323567				      	for ( pair < int , int > p : freq ) {			      }								  
    max_so_far = - 323567				      	  if ( p . second > max_so_far ) {			      int maxElement = - 323567 ;				  
    for p in mp :					      	    max_so_far = p . second ;				      int maxSoFar = - 323567 ;					  
	if ( mp [ p ] > max_so_far ) :			      	    max_element = p . first ;				      for ( int p = 0 ;						  
	    max_so_far = mp [ p ]			      	  }							      p < mp . count ( ) ;					  
	    max_element = p				      	}							      p ++ ) {							  
    r = int ( ( ( random.randrange ( 1 , max_so_far , 2 ) % m 	int r = ( rand ( ) % max_so_far ) + 1 ;			    	if ( ( mp [ p ] > maxSoFar ) ) {			  
    i = 0						      	for ( int i = 0 , count = 0 ;				    	  maxSoFar = mp [ p ] ;					  
    count = 0						      	i < n ;							    	  maxElement = p ;					  
    while ( i < n ) :					      	i ++ ) {						    	}							  
	if ( arr [ i ] == max_element ) :		      	  if ( arr [ i ] == max_element ) count ++ ;		      }								  
	    count = count + 1				      	  if ( count == r ) {					      int r = ( int ) ( ( ( rand ( ) % 1 ) + maxSoFar ) + 1 ) ;	  
	if ( count == r ) :				      	    cout << "Element with maximum frequency present " "at i   int i = 0 ;						  
	    print ( "Element with maximum frequency present a 	    break ;						      int count = 0 ;						  
	    break					      	  }							      while ( ( i < n ) && ( arr [ i ] == maxElement ) ) {	  
	i = i + 1					      	}							    	count = count + 1 ;					  
							      }								      }								  
							      								      if ( ( count == r ) || ( count == r ) ) {			  
							      								    	cout << "Element with maximum frequency present at index  
							      								    	break ;							  
							      								      }								  
							      								      i = i + 1 ;						  
							      								    }								  
							      								    return i ;							  
							      								    return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE		      COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE		    COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE			  COUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE
--							      --							    --								  --
def findSubsequenceCount ( S , T ) :			      int findSubsequenceCount ( string S , string T ) {	    int findSubsequenceCount ( string S , string T ) {		  error : free(): invalid pointer /bin/bash: line 1:
    m = len ( T )					      	int m = T . length ( ) , n = S . length ( ) ;		      int m = T . length ( ) ;					   1849220 Aborted		   (core dumped) ./C
    n = len ( S )					      	if ( m > n ) return 0 ;					      int n = S . length ( ) ;					  OUNT_DISTINCT_OCCURRENCES_AS_A_SUBSEQUENCE_cpp
    if m > n :						      	int mat [ m + 1 ] [ n + 1 ] ;				      if ( m > n ) return 0 ;					  
	return 0					      	for ( int i = 1 ;					      vector < vector < int >> mat ( n + 1 , vector < int > ( m + 
    mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range (  	i <= m ;						      for ( int i = 1 ;						  
    for i in range ( 1 , m + 1 ) :			      	i ++ ) mat [ i ] [ 0 ] = 0 ;				      i <= m ;							  
	mat [ i ] [ 0 ] = 0				      	for ( int j = 0 ;					      i ++ ) mat [ i ] [ 0 ] = 0 ;				  
    for j in range ( n + 1 ) :				      	j <= n ;						      for ( int j = 0 ;						  
	mat [ 0 ] [ j ] = 1				      	j ++ ) mat [ 0 ] [ j ] = 1 ;				      j < n + 1 ;						  
    for i in range ( 1 , m + 1 ) :			      	for ( int i = 1 ;					      j ++ ) mat [ 0 ] [ j ] = 1 ;				  
	for j in range ( 1 , n + 1 ) :			      	i <= m ;						      for ( int i = 1 ;						  
	    if T [ i - 1 ] != S [ j - 1 ] :		      	i ++ ) {						      i <= m ;							  
		mat [ i ] [ j ] = mat [ i ] [ j - 1 ]	      	  for ( int j = 1 ;					      i ++ ) for ( int j = 1 ;					  
	    else :					      	  j <= n ;						      j <= n ;							  
		mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat 	  j ++ ) {						      j ++ ) {							  
    return mat [ m ] [ n ]				      	    if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat 	if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ 
							      	    else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i -  	else mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i -  
							      	  }							      }								  
							      	}							      return mat [ m ] [ n ] ;					  
							      	return mat [ m ] [ n ] ;				      return m * m ;						  
							      }								      return m * m ;						  
							      								      return m * m * m * m * m * m * m * m * m * m * m * m * m *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE	      MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE	    MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE		  MAXIMUM_DISTINCT_LOWERCASE_ALPHABETS_TWO_UPPERCASE
--							      --							    --								  --
def maxLower ( str ) :					      int maxLower ( string str ) {				    int maxLower ( string str ) {				  script_not_found : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    i = 0						      	int i = 0 ;						      int i = 0 ;						  
    for i in range ( n ) :				      	for ( ;							      for ( int j = 0 ;						  
	if str [ i ] >= 'A' and str [ i ] <= 'Z' :	      	i < n ;							      j < n ;							  
	    i += 1					      	i ++ ) {						      j ++ ) {							  
	    break					      	  if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {		    	if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {		  
    maxCount = 0					      	    i ++ ;						    	  i ++ ;						  
    count = [ ]						      	    break ;						    	  break ;						  
    for j in range ( MAX_CHAR ) :			      	  }							    	}							  
	count.append ( 0 )				      	}							      }								  
    for j in range ( i , n ) :				      	int maxCount = 0 ;					      int maxCount = 0 ;					  
	if str [ j ] >= 'A' and str [ j ] <= 'Z' :	      	int count [ MAX_CHAR ] = {				      vector < int > count ;					  
	    currCount = 0				      	  0 }							      for ( int j = 0 ;						  
	    for k in range ( MAX_CHAR ) :		      	  ;							      j < MAX_CHAR ;						  
		if count [ k ] > 0 :			      	  for ( ;						      j ++ ) count . push_back ( 0 ) ;				  
		    currCount += 1			      	  i < n ;						      for ( int j = i ;						  
	    maxCount = max ( maxCount , currCount )	      	  i ++ ) {						      j < n ;							  
	    for y in count :				      	    if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) {	      j ++ ) {							  
		y = 0					      	      int currCount = 0 ;				    	if ( str [ j ] >= 'A' && str [ j ] <= 'Z' ) {		  
	if str [ j ] >= 'a' and str [ j ] <= 'z' :	      	      for ( int j = 0 ;					    	  int currCount = 0 ;					  
	    count [ ord ( str [ j ] ) - ord ( 'a' ) ] += 1    	      j < MAX_CHAR ;					    	  for ( int k = 0 ;					  
    return maxCount					      	      j ++ ) if ( count [ j ] > 0 ) currCount ++ ;	    	  k < MAX_CHAR ;					  
							      	      maxCount = max ( maxCount , currCount ) ;		    	  k ++ ) {						  
							      	      memset ( count , 0 , sizeof ( count ) ) ;		    	    if ( count [ k ] > 0 ) currCount ++ ;		  
							      	    }							    	  }							  
							      	    if ( str [ i ] >= 'a' && str [ i ] <= 'z' ) count [ str 	  maxCount = max ( maxCount , currCount ) ;		  
							      	  }							    	  for ( int y = 0 ;					  
							      	  return maxCount ;					    	  y < count . size ( ) ;				  
							      	}							    	  y ++ ) count [ str [ j ] - 'a' ] = 0 ;		  
							      								    	}							  
							      								    	if ( str [ j ] >= 'a' && str [ j ] <= 'z' ) count [ str [ 
							      								      }								  
							      								    }								  
							      								    return maxCount ;						  
							      								    return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED     LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED	    LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED	  LONGEST_COMMON_SUBSEQUENCE_WITH_AT_MOST_K_CHANGES_ALLOWED
--							      --							    --								  --
def lcs ( dp , arr1 , n , arr2 , m , k ) :		      int lcs ( int dp [ MAX ] [ MAX ] [ MAX ] , int arr1 [ ] , int int lcs ( int * * dp , int * arr1 , int n , int * arr2 , int  script_not_found : None
    if k < 0 :						      	if ( k < 0 ) return - 1e7 ;				      if ( k < 0 ) return - ( 10 * 7 ) ;			  
	return - ( 10 ** 7 )				      	if ( n < 0 || m < 0 ) return 0 ;			      if ( n < 0 || m < 0 ) return 0 ;				  
    if n < 0 or m < 0 :					      	int & ans = dp [ n ] [ m ] [ k ] ;			      int ans = dp [ n ] [ m ] [ k ] ;				  
	return 0					      	if ( ans != - 1 ) return ans ;				      if ( ans != - 1 ) return ans ;				  
    ans = dp [ n ] [ m ] [ k ]				      	ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs    ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs  
    if ans != - 1 :					      	if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = max ( ans , 1   if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = max ( ans , 1 
	return ans					      	ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m -    ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1 ,  
    ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lc 	return ans ;						      return ans ;						  
    if arr1 [ n - 1 ] == arr2 [ m - 1 ] :		      }								    }								  
	ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2  								    								  
    ans = max ( ans , lcs ( dp , arr1 , n - 1 , arr2 , m - 1  								    								  
    return ans						      								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_MATRIX_ANTISPIRAL_FORM				      PRINT_MATRIX_ANTISPIRAL_FORM				    PRINT_MATRIX_ANTISPIRAL_FORM				  PRINT_MATRIX_ANTISPIRAL_FORM
--							      --							    --								  --
def antiSpiralTraversal ( m , n , a ) :			      void antiSpiralTraversal ( int m , int n , int a [ R ] [ C ]  int antiSpiralTraversal ( int m , int n , int * a ) {	  script_not_found : None
    k = 0						      	int i , k = 0 , l = 0 ;					      int k = 0 ;						  
    l = 0						      	stack < int > stk ;					      int l = 0 ;						  
    stk = [ ]						      	while ( k <= m && l <= n ) {				      vector < int > stk ;					  
    while ( k <= m and l <= n ) :			      	  for ( i = l ;						      while ( ( k <= m && l <= n ) ) {				  
	for i in range ( l , n + 1 ) :			      	  i <= n ;						    	for ( int i = l ;					  
	    stk.append ( a [ k ] [ i ] )		      	  ++ i ) stk . push ( a [ k ] [ i ] ) ;			    	i <= n ;						  
	k += 1						      	  k ++ ;						    	i ++ ) stk . push_back ( a [ k ] [ i ] ) ;		  
	for i in range ( k , m + 1 ) :			      	  for ( i = k ;						    	k ++ ;							  
	    stk.append ( a [ i ] [ n ] )		      	  i <= m ;						    	for ( int i = k ;					  
	n -= 1						      	  ++ i ) stk . push ( a [ i ] [ n ] ) ;			    	i <= m ;						  
	if ( k <= m ) :					      	  n -- ;						    	i ++ ) stk . push_back ( a [ i ] [ n ] ) ;		  
	    for i in range ( n , l - 1 , - 1 ) :	      	  if ( k <= m ) {					    	n -- ;							  
		stk.append ( a [ m ] [ i ] )		      	    for ( i = n ;					    	if ( ( k <= m ) ) for ( int i = n ;			  
	    m -= 1					      	    i >= l ;						    	i >= l ;						  
	if ( l <= n ) :					      	    -- i ) stk . push ( a [ m ] [ i ] ) ;		    	i -- ) stk . push_back ( a [ m ] [ i ] ) ;		  
	    for i in range ( m , k - 1 , - 1 ) :	      	    m -- ;						    	if ( ( l <= n ) ) for ( int i = m ;			  
		stk.append ( a [ i ] [ l ] )		      	  }							    	i >= k ;						  
	    l += 1					      	  if ( l <= n ) {					    	i -- ) stk . push_back ( a [ i ] [ l ] ) ;		  
    while len ( stk ) != 0 :				      	    for ( i = m ;					    	l ++ ;							  
	print ( str ( stk [ - 1 ] ) , end = " " )	      	    i >= k ;						      }								  
	stk.pop ( )					      	    -- i ) stk . push ( a [ i ] [ l ] ) ;		      while ( stk . size ( ) != 0 ) {				  
							      	    l ++ ;						    	cout << stk . back ( ) << " " ;				  
							      	  }							    	stk . pop_back ( ) ;					  
							      	}							      }								  
							      	while ( ! stk . empty ( ) ) {				      return 0 ;						  
							      	  cout << stk . top ( ) << " " ;			      return m * m ;						  
							      	  stk . pop ( ) ;					      return m * m * m * m * m * m * m * m * m * m * m * m * m *  
							      	}							    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX			      MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX			    MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX			  MAXIMUM_AND_MINIMUM_IN_A_SQUARE_MATRIX
--							      --							    --								  --
def MAXMIN ( arr , n ) :				      void maxMin ( int arr [ ] [ MAX ] , int n ) {		    int MAXMIN ( int * arr , int n ) {				  script_not_found : None
    MIN = 10 ** 9					      	int min = INT_MAX ;					      int MIN = 10 * 9 ;					  
    MAX = - 10 ** 9					      	int max = INT_MIN ;					      int MAX = - 10 * 9 ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( n // 2 + 1 ) :			      	i < n ;							      i < n ;							  
	    if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] )  	i ++ ) {						      i ++ ) {							  
		if ( MIN > arr [ i ] [ n - j - 1 ] ) :	      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
		    MIN = arr [ i ] [ n - j - 1 ]	      	  j <= n / 2 ;						    	j < n / 2 + 1 ;						  
		if ( MAX < arr [ i ] [ j ] ) :		      	  j ++ ) {						    	j ++ ) {						  
		    MAX = arr [ i ] [ j ]		      	    if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) {	    	  if ( ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) ) {  
	    else :					      	      if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ]  	    if ( ( MIN > arr [ i ] [ n - j - 1 ] ) ) MIN = arr [  
		if ( MIN > arr [ i ] [ j ] ) :		      	      if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ;  	    if ( ( MAX < arr [ i ] [ j ] ) ) MAX = arr [ i ] [ j  
		    MIN = arr [ i ] [ j ]		      	    }							    	  }							  
		if ( MAX < arr [ i ] [ n - j - 1 ] ) :	      	    else {						    	  else {						  
		    MAX = arr [ i ] [ n - j - 1 ]	      	      if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ;  	    if ( ( MIN > arr [ i ] [ j ] ) ) MIN = arr [ i ] [ j  
    print ( "MAXimum =" , MAX , ", MINimum =" , MIN )	      	      if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ]  	    if ( ( MAX < arr [ i ] [ n - j - 1 ] ) ) MAX = arr [  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	cout << "Maximum = " << max ;				    }								  
							      	<< ", Minimum = " << min ;				    cout << "MAXimum =" << MAX << ", MINimum =" << MIN << endl ;  
							      }								    return MAX ;						  
							      								    return n * n ;						  
							      								    return n * n * n * n * n * n * n * n * n * n * n * n * n * n  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_PRODUCT_TWO_ARRAYS				      MINIMUM_SUM_PRODUCT_TWO_ARRAYS				    MINIMUM_SUM_PRODUCT_TWO_ARRAYS				  MINIMUM_SUM_PRODUCT_TWO_ARRAYS
--							      --							    --								  --
def minproduct ( a , b , n , k ) :			      int minproduct ( int a [ ] , int b [ ] , int n , int k ) {    double minproduct ( double * a , double * b , int n , double  error : MINIMUM_SUM_PRODUCT_TWO_ARRAYS.cpp: In fun
    diff = 0						      	int diff = 0 , res = 0 ;				      double diff = 0 ;						  ction ‘double f_filled(double*, double*, int, doub
    res = 0						      	int temp ;						      double res = 0 ;						  le)’: MINIMUM_SUM_PRODUCT_TWO_ARRAYS.cpp:43:43: er
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  ror: ‘temp’ was not declared in this scope	  if
	pro = a [ i ] * b [ i ]				      	i < n ;							      i < n ;							   ( ( pro < 0 ) && ( b [ i ] < 0 ) ) temp = ( a [ i
	res = res + pro					      	i ++ ) {						      i ++ ) {							   ] + 2 * k ) * b [ i ] ;
	if ( pro < 0 and b [ i ] < 0 ) :		      	  int pro = a [ i ] * b [ i ] ;				    	double pro = a [ i ] * b [ i ] ;			  		    ^~~~ MINIMUM_SUM_PRODUCT_TWO_ARR
	    temp = ( a [ i ] + 2 * k ) * b [ i ]	      	  res = res + pro ;					    	res = res + pro ;					  AYS.cpp:43:43: note: suggested alternative: ‘mktem
	elif ( pro < 0 and a [ i ] < 0 ) :		      	  if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k )  	if ( ( pro < 0 ) && ( b [ i ] < 0 ) ) temp = ( a [ i ] +  p’	  if ( ( pro < 0 ) && ( b [ i ] < 0 ) ) temp
	    temp = ( a [ i ] - 2 * k ) * b [ i ]	      	  else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * 	else if ( ( pro < 0 ) && ( a [ i ] < 0 ) ) temp = ( a [ i  = ( a [ i ] + 2 * k ) * b [ i ] ;
	elif ( pro > 0 and a [ i ] < 0 ) :		      	  else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * 	else if ( ( pro > 0 ) && ( a [ i ] < 0 ) ) temp = ( a [ i 			      ^~~~
	    temp = ( a [ i ] + 2 * k ) * b [ i ]	      	  else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * 	else if ( ( pro > 0 ) && ( a [ i ] > 0 ) ) temp = ( a [ i 			    mktemp MINIMUM_SUM_PRODU
	elif ( pro > 0 and a [ i ] > 0 ) :		      	  int d = abs ( pro - temp ) ;				    	double d = fabs ( pro - temp ) ;			  CT_TWO_ARRAYS.cpp:44:48: error: ‘temp’ was not dec
	    temp = ( a [ i ] - 2 * k ) * b [ i ]	      	  if ( d > diff ) diff = d ;				    	if ( ( d > diff ) ) diff = d ;				  lared in this scope	   else if ( ( pro < 0 ) &&
	d = abs ( pro - temp )				      	}							      }								  ( a [ i ] < 0 ) ) temp = ( a [ i ] - 2 * k ) * b [
	if ( d > diff ) :				      	return res - diff ;					      return res - diff ;					   i ] ;
	    diff = d					      }								    }								       ^~~~ MINIMUM_SUM_PRODUCT_TWO_ARRAYS.cpp:44:48
    return res - diff					      								    								  : note: suggested alternative: ‘mktemp’      else
							      								    								  if ( ( pro < 0 ) && ( a [ i ] < 0 ) ) temp = ( a [
							      								    								   i ] - 2 * k ) * b [ i ] ;
							      								    								  			   ^~~~
							      								    								  			      mktemp MINIMUM_SUM_PRO
							      								    								  DUCT_TWO_ARRAYS.cpp:45:48: error: ‘temp’ was not d
							      								    								  eclared in this scope	     else if ( ( pro > 0 ) &
							      								    								  & ( a [ i ] < 0 ) ) temp = ( a [ i ] + 2 * k ) * b
							      								    								   [ i ] ;
							      								    								  	 ^~~~ MINIMUM_SUM_PRODUCT_TWO_ARRAYS.cpp:45:
							      								    								  48: note: suggested alternative: ‘mktemp’	 els
							      								    								  e if ( ( pro > 0 ) && ( a [ i ] < 0 ) ) temp = ( a
							      								    								   [ i ] + 2 * k ) * b [ i ] ;
							      								    								  			     ^~~~
							      								    								  				mktemp MINIMUM_SUM_P
							      								    								  RODUCT_TWO_ARRAYS.cpp:46:48: error: ‘temp’ was not
							      								    								   declared in this scope      else if ( ( pro > 0 )
							      								    								   && ( a [ i ] > 0 ) ) temp = ( a [ i ] - 2 * k ) *
							      								    								   b [ i ] ;
							      								    								  	   ^~~~ MINIMUM_SUM_PRODUCT_TWO_ARRAYS.cpp:4
							      								    								  6:48: note: suggested alternative: ‘mktemp’	   e
							      								    								  lse if ( ( pro > 0 ) && ( a [ i ] > 0 ) ) temp = (
							      								    								   a [ i ] - 2 * k ) * b [ i ] ;
							      								    								  			       ^~~~
							      								    								  				  mktemp MINIMUM_SUM
							      								    								  _PRODUCT_TWO_ARRAYS.cpp:47:29: error: ‘temp’ was n
							      								    								  ot declared in this scope	 double d = fabs ( p
							      								    								  ro - temp ) ;				     ^~~~ MI
							      								    								  NIMUM_SUM_PRODUCT_TWO_ARRAYS.cpp:47:29: note: sugg
							      								    								  ested alternative: ‘mktemp’	   double d = fabs (
							      								    								   pro - temp ) ;			       ^~~~
							      								    								  			       mktemp MINIMUM_SUM_PR
							      								    								  ODUCT_TWO_ARRAYS.cpp: In function ‘int main()’: MI
							      								    								  NIMUM_SUM_PRODUCT_TWO_ARRAYS.cpp:62:21: error: can
							      								    								  not convert ‘__gnu_cxx::__alloc_traits<std::alloca
							      								    								  tor<int>, int>::value_type*’ {aka ‘int*’} to ‘doub
							      								    								  le*’		if(f_filled(&param0[i].front(),&para
							      								    								  m1[i].front(),param2[i],param3[i]) == f_gold(&para
							      								    								  m0[i].front(),&param1[i].front(),param2[i],param3[
							      								    								  i]))			    ^~~~~~~~~~~~~~~~~~ MINIM
							      								    								  UM_SUM_PRODUCT_TWO_ARRAYS.cpp:35:28: note:   initi
							      								    								  alizing argument 1 of ‘double f_filled(double*, do
							      								    								  uble*, int, double)’	double f_filled ( double * a
							      								    								   , double * b , int n , double k ) {
							      								    								  	~~~~~~~~~^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH			      DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH			    DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH			  DYNAMIC_PROGRAMMING_SET_6_MIN_COST_PATH
--							      --							    --								  --
def minCost ( cost , m , n ) :				      int minCost ( int cost [ R ] [ C ] , int m , int n ) {	    int minCost ( int cost [ ] , int m , int n ) {		  script_not_found : None
    tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ]  	int i , j ;						      vector < vector < int >> tc ( C , vector < int > ( R ) ) ;  
    tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ]			      	int tc [ R ] [ C ] ;					      for ( int x = 0 ;						  
    for i in range ( 1 , m + 1 ) :			      	tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;			      x < R ;							  
	tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0  	for ( i = 1 ;						      x ++ ) tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;		  
    for j in range ( 1 , n + 1 ) :			      	i <= m ;						      for ( int i = 1 ;						  
	tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j  	i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0   i <= m ;							  
    for i in range ( 1 , m + 1 ) :			      	for ( j = 1 ;						      i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 
	for j in range ( 1 , n + 1 ) :			      	j <= n ;						      for ( int j = 1 ;						  
	    tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , t 	j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j   j <= n ;							  
    return tc [ m ] [ n ]				      	for ( i = 1 ;						      j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j 
							      	i <= m ;						      for ( int i = 1 ;						  
							      	i ++ ) for ( j = 1 ;					      i <= m ;							  
							      	j <= n ;						      i ++ ) for ( int j = 1 ;					  
							      	j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [   j <= n ;							  
							      	return tc [ m ] [ n ] ;					      j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ 
							      }								      return tc [ m ] [ n ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NEXT_GREATER_FREQUENCY_ELEMENT				      NEXT_GREATER_FREQUENCY_ELEMENT				    NEXT_GREATER_FREQUENCY_ELEMENT				  NEXT_GREATER_FREQUENCY_ELEMENT
--							      --							    --								  --
def NFG ( a , n ) :					      void NFG ( int a [ ] , int n , int freq [ ] ) {		    int NFG ( int a [ ] , int n ) {				  script_not_found : None
    if ( n <= 0 ) :					      	stack < int > s ;					      if ( ( n <= 0 ) ) {					  
	print ( "List empty" )				      	s . push ( 0 ) ;					    	cout << "List empty" << endl ;				  
	return [ ]					      	int res [ n ] = {					    	return 0 ;						  
    stack = [ 0 ] * n					      	  0 }							      }								  
    freq = { }						      	  ;							      vector < int > stack ( n , 0 ) ;				  
    for i in a :					      	  for ( int i = 1 ;					      unordered_map < int , int > freq ;			  
	freq [ a [ i ] ] = 0				      	  i < n ;						      for ( int i = 0 ;						  
    for i in a :					      	  i ++ ) {						      i < a [ 0 ] ;						  
	freq [ a [ i ] ] += 1				      	    if ( freq [ a [ s . top ( ) ] ] > freq [ a [ i ] ] ) s    i ++ ) freq [ a [ i ] ] = 0 ;				  
    res = [ 0 ] * n					      	    else {						      for ( int i = 0 ;						  
    top = - 1						      	      while ( freq [ a [ s . top ( ) ] ] < freq [ a [ i ] ]   i < a [ n - 1 ] ;						  
    top += 1						      		res [ s . top ( ) ] = a [ i ] ;			      i ++ ) freq [ a [ i ] ] ++ ;				  
    stack [ top ] = 0					      		s . pop ( ) ;					      vector < int > res ( n , 0 ) ;				  
    for i in range ( 1 , n ) :				      	      }							      int top = - 1 ;						  
	if ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ]  	      s . push ( i ) ;					      top ++ ;							  
	    top += 1					      	    }							      stack [ top ] = 0 ;					  
	    stack [ top ] = i				      	  }							      for ( int i = 1 ;						  
	else :						      	  while ( ! s . empty ( ) ) {				      i < n ;							  
	    while ( top > - 1 and freq [ a [ stack [ top ] ]  	    res [ s . top ( ) ] = - 1 ;				      i ++ ) {							  
		res [ stack [ top ] ] = a [ i ]		      	    s . pop ( ) ;					    	if ( ( freq [ a [ stack [ top ] ] ] > freq [ a [ i ] ] )  
		top -= 1				      	  }							    	  top ++ ;						  
	    top += 1					      	  for ( int i = 0 ;					    	  stack [ top ] = i ;					  
	    stack [ top ] = i				      	  i < n ;						    	}							  
    while ( top > - 1 ) :				      	  i ++ ) {						    	else {							  
	res [ stack [ top ] ] = - 1			      	    cout << res [ i ] << " " ;				    	  while ( ( top > - 1 ) && ( freq [ a [ stack [ top ] ] < 
	top -= 1					      	  }							    	    res [ stack [ top ] ] = a [ i ] ;			  
    return res						      	}							    	    top -- ;						  
							      								    	  }							  
							      								    	  top ++ ;						  
							      								    	  stack [ top ] = i ;					  
							      								    	}							  
							      								      }								  
							      								      while ( ( top > - 1 ) ) {					  
							      								    	res [ stack [ top ] ] = - 1 ;				  
							      								    	top -- ;						  
							      								      }								  
							      								      return res [ a [ n - 1 ] ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING		      COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING		    COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING			  COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING
--							      --							    --								  --
def countPS ( str ) :					      int countPS ( string str ) {				    int countPS ( string str ) {				  error : /bin/bash: line 1: 1848217 Aborted
    N = len ( str )					      	int N = str . length ( ) ;				      int N = str . length ( ) ;				  	   (core dumped) ./COUNT_PALINDROMIC_SUBSEQU
    cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N 	int cps [ N + 1 ] [ N + 1 ] ;				      vector < vector < int >> cps ( N + 2 , vector < int > ( N + ENCE_GIVEN_STRING_cpp
    for i in range ( N ) :				      	memset ( cps , 0 , sizeof ( cps ) ) ;			      for ( int j = 0 ;						  
	cps [ i ] [ i ] = 1				      	for ( int i = 0 ;					      j < N ;							  
    for L in range ( 2 , N + 1 ) :			      	i < N ;							      j ++ ) cps [ j ] [ j ] = 1 ;				  
	for i in range ( N ) :				      	i ++ ) cps [ i ] [ i ] = 1 ;				      for ( int L = 2 ;						  
	    k = L + i - 1				      	for ( int L = 2 ;					      L <= N ;							  
	    if ( k < N ) :				      	L <= N ;						      L ++ ) {							  
		if ( str [ i ] == str [ k ] ) :		      	L ++ ) {						    	for ( int i = 0 ;					  
		    cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + 	  for ( int i = 0 ;					    	i < N ;							  
		else :					      	  i < N ;						    	i ++ ) {						  
		    cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + 	  i ++ ) {						    	  int k = L + i - 1 ;					  
    return cps [ 0 ] [ N - 1 ]				      	    int k = L + i - 1 ;					    	  if ( ( k < N ) ) {					  
							      	    if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i 	    if ( ( str [ i ] == str [ k ] ) ) cps [ i ] [ k ] = ( 
							      	    else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i +  	    else cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [  
							      	  }							    	  }							  
							      	}							    	}							  
							      	return cps [ 0 ] [ N - 1 ] ;				      }								  
							      }								      return cps [ 0 ] [ N - 1 ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING		      SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING		    SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING			  SMALLEST_WINDOW_CONTAINS_CHARACTERS_STRING
--							      --							    --								  --
def findSubString ( str ) :				      string findSubString ( string str ) {			    string findSubString ( string str ) {			  script_not_found : None
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  
    dist_count = len ( set ( [ x for x in str ] ) )	      	int dist_count = 0 ;					      int distCount = set < string > :: count ( str ) ;		  
    count , start , start_index , min_len = 0 , 0 , - 1 , 999 	bool visited [ MAX_CHARS ] = {				      int count = 0 , start = 0 , startIndex = - 1 , minLen = 999 
    curr_count = defaultdict ( lambda : 0 )		      	  false }						      map < char , int > currCount ;				  
    for j in range ( n ) :				      	  ;							      for ( int j = 0 ;						  
	curr_count [ str [ j ] ] += 1			      	  for ( int i = 0 ;					      j < n ;							  
	if curr_count [ str [ j ] ] == 1 :		      	  i < n ;						      j ++ ) {							  
	    count += 1					      	  i ++ ) {						    	currCount [ str [ j ] ] ++ ;				  
	if count == dist_count :			      	    if ( visited [ str [ i ] ] == false ) {		    	if ( currCount [ str [ j ] ] == 1 ) count ++ ;		  
	    while curr_count [ str [ start ] ] > 1 :	      	      visited [ str [ i ] ] = true ;			    	if ( count == distCount ) {				  
		if curr_count [ str [ start ] ] > 1 :	      	      dist_count ++ ;					    	  while ( currCount [ str [ start ] ] > 1 ) {		  
		    curr_count [ str [ start ] ] -= 1	      	    }							    	    if ( currCount [ str [ start ] ] > 1 ) currCount [ st 
		start += 1				      	  }							    	    start ++ ;						  
	    len_window = j - start + 1			      	  int start = 0 , start_index = - 1 , min_len = INT_MAX ;   	  }							  
	    if min_len > len_window :			      	  int count = 0 ;					    	  int lenWindow = j - start + 1 ;			  
		min_len = len_window			      	  int curr_count [ MAX_CHARS ] = {			    	  if ( minLen > lenWindow ) {				  
		start_index = start			      	    0 }							    	    minLen = lenWindow ;				  
    return str [ start_index : start_index + min_len ]	      	    ;							    	    startIndex = start ;				  
							      	    for ( int j = 0 ;					    	  }							  
							      	    j < n ;						    	}							  
							      	    j ++ ) {						      }								  
							      	      curr_count [ str [ j ] ] ++ ;			      return str . substr ( startIndex , minLen - startIndex ) ;  
							      	      if ( curr_count [ str [ j ] ] == 1 ) count ++ ;	    }								  
							      	      if ( count == dist_count ) {			    								  
							      		while ( curr_count [ str [ start ] ] > 1 ) {	    								  
							      		  if ( curr_count [ str [ start ] ] > 1 ) curr_coun 								  
							      		  start ++ ;					    								  
							      		}						    								  
							      		int len_window = j - start + 1 ;		    								  
							      		if ( min_len > len_window ) {			    								  
							      		  min_len = len_window ;			    								  
							      		  start_index = start ;				    								  
							      		}						    								  
							      	      }							    								  
							      	    }							    								  
							      	    return str . substr ( start_index , min_len ) ;	    								  
							      	  }							    								  
-							      	  -							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_PRODUCT_SUBSET_ARRAY				      MINIMUM_PRODUCT_SUBSET_ARRAY				    MINIMUM_PRODUCT_SUBSET_ARRAY				  MINIMUM_PRODUCT_SUBSET_ARRAY
--							      --							    --								  --
def minProductSubset ( a , n ) :			      int minProductSubset ( int a [ ] , int n ) {		    int minProductSubset ( int * a , int n ) {			  error : MINIMUM_PRODUCT_SUBSET_ARRAY.cpp: In funct
    if ( n == 1 ) :					      	if ( n == 1 ) return a [ 0 ] ;				      if ( ( n == 1 ) ) return a [ 0 ] ;			  ion ‘int f_filled(int*, int)’: MINIMUM_PRODUCT_SUB
	return a [ 0 ]					      	int max_neg = INT_MIN ;					      double maxNeg = numeric_limits < double > :: max ( ) ;	  SET_ARRAY.cpp:61:39: error: no matching function f
    max_neg = float ( '-inf' )				      	int min_pos = INT_MAX ;					      double minPos = numeric_limits < double > :: min ( ) ;	  or call to ‘max(double&, int&)’	 maxNeg = ma
    min_pos = float ( 'inf' )				      	int count_neg = 0 , count_zero = 0 ;			      int countNeg = 0 ;					  x ( maxNeg , a [ i ] ) ;
    count_neg = 0					      	int prod = 1 ;						      int countZero = 0 ;					  		^ In file included from /usr/include
    count_zero = 0					      	for ( int i = 0 ;					      int prod = 1 ;						  /c++/8/bits/char_traits.h:39,			 fro
    prod = 1						      	i < n ;							      for ( int i = 0 ;						  m /usr/include/c++/8/ios:40,			from
    for i in range ( 0 , n ) :				      	i ++ ) {						      i != n ;							   /usr/include/c++/8/ostream:38,		   f
	if ( a [ i ] == 0 ) :				      	  if ( a [ i ] == 0 ) {					      i ++ ) {							  rom /usr/include/c++/8/iostream:39,
	    count_zero = count_zero + 1			      	    count_zero ++ ;					    	if ( ( a [ i ] == 0 ) ) {				     from MINIMUM_PRODUCT_SUBSET_ARRAY.cpp:8: /usr/i
	    continue					      	    continue ;						    	  countZero = countZero + 1 ;				  nclude/c++/8/bits/stl_algobase.h:219:5: note: cand
	if ( a [ i ] < 0 ) :				      	  }							    	  continue ;						  idate: ‘template<class _Tp> constexpr const _Tp& s
	    count_neg = count_neg + 1			      	  if ( a [ i ] < 0 ) {					    	}							  td::max(const _Tp&, const _Tp&)’	max(const _T
	    max_neg = max ( max_neg , a [ i ] )		      	    count_neg ++ ;					    	if ( ( a [ i ] < 0 ) ) {				  p& __a, const _Tp& __b)      ^~~ /usr/include/c++/
	if ( a [ i ] > 0 ) :				      	    max_neg = max ( max_neg , a [ i ] ) ;		    	  countNeg = countNeg + 1 ;				  8/bits/stl_algobase.h:219:5: note:   template argu
	    min_pos = min ( min_pos , a [ i ] )		      	  }							    	  maxNeg = max ( maxNeg , a [ i ] ) ;			  ment deduction/substitution failed: MINIMUM_PRODUC
	prod = prod * a [ i ]				      	  if ( a [ i ] > 0 ) min_pos = min ( min_pos , a [ i ] ) ;  	}							  T_SUBSET_ARRAY.cpp:61:39: note:   deduced conflict
    if ( count_zero == n or ( count_neg == 0 and count_zero > 	  prod = prod * a [ i ] ;				    	if ( ( a [ i ] > 0 ) ) minPos = min ( minPos , a [ i ] )  ing types for parameter ‘const _Tp’ (‘double’ and
	return 0					      	}							    	prod = prod * a [ i ] ;					  ‘int’)	maxNeg = max ( maxNeg , a [ i ] ) ;
    if ( count_neg == 0 ) :				      	if ( count_zero == n || ( count_neg == 0 && count_zero > 0    }								  					 ^ In file i
	return min_pos					      	if ( count_neg == 0 ) return min_pos ;			      if ( ( countZero == n ) || ( countNeg == 0 && countZero > 0 ncluded from /usr/include/c++/8/bits/char_traits.h
    if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) :	      	if ( ! ( count_neg & 1 ) && count_neg != 0 ) {		      if ( ( countNeg == 0 ) ) return minPos ;			  :39,			from /usr/include/c++/8/ios:
	prod = int ( prod / max_neg )			      	  prod = prod / max_neg ;				      if ( ( ( countNeg & 1 ) == 0 ) && countNeg != 0 ) prod = (  40,		       from /usr/include/c++/8/ostre
    return prod						      	}							      return prod ;						  am:38,		  from /usr/include/c++/8/io
							      	return prod ;						    }								  stream:39,		      from MINIMUM_PRODUCT_S
							      }								    								  UBSET_ARRAY.cpp:8: /usr/include/c++/8/bits/stl_alg
							      								    								  obase.h:265:5: note: candidate: ‘template<class _T
							      								    								  p, class _Compare> constexpr const _Tp& std::max(c
							      								    								  onst _Tp&, const _Tp&, _Compare)’	 max(const _
							      								    								  Tp& __a, const _Tp& __b, _Compare __comp)	 ^~~
							      								    								   /usr/include/c++/8/bits/stl_algobase.h:265:5: not
							      								    								  e:   template argument deduction/substitution fail
							      								    								  ed: MINIMUM_PRODUCT_SUBSET_ARRAY.cpp:61:39: note:
							      								    								    deduced conflicting types for parameter ‘const _
							      								    								  Tp’ (‘double’ and ‘int’)	  maxNeg = max ( max
							      								    								  Neg , a [ i ] ) ;
							      								    								  	 ^ In file included from /usr/include/c++/8/
							      								    								  algorithm:62,			 from /usr/include/c
							      								    								  ++/8/x86_64-redhat-linux/bits/stdc++.h:65,
							      								    								  	    from MINIMUM_PRODUCT_SUBSET_ARRAY.cpp:14
							      								    								  : /usr/include/c++/8/bits/stl_algo.h:3462:5: note:
							      								    								   candidate: ‘template<class _Tp> constexpr _Tp std
							      								    								  ::max(std::initializer_list<_Tp>)’	  max(initia
							      								    								  lizer_list<_Tp> __l)	    ^~~ /usr/include/c++/8/b
							      								    								  its/stl_algo.h:3462:5: note:	 template argument d
							      								    								  eduction/substitution failed: MINIMUM_PRODUCT_SUBS
							      								    								  ET_ARRAY.cpp:61:39: note:   mismatched types ‘std:
							      								    								  :initializer_list<_Tp>’ and ‘double’	      maxNeg
							      								    								   = max ( maxNeg , a [ i ] ) ;
							      								    								  		     ^ In file included from /usr/in
							      								    								  clude/c++/8/algorithm:62,		     from /u
							      								    								  sr/include/c++/8/x86_64-redhat-linux/bits/stdc++.h
							      								    								  :65,			from MINIMUM_PRODUCT_SUBSET_
							      								    								  ARRAY.cpp:14: /usr/include/c++/8/bits/stl_algo.h:3
							      								    								  468:5: note: candidate: ‘template<class _Tp, class
							      								    								   _Compare> constexpr _Tp std::max(std::initializer
							      								    								  _list<_Tp>, _Compare)’      max(initializer_list<_
							      								    								  Tp> __l, _Compare __comp)	 ^~~ /usr/include/c+
							      								    								  +/8/bits/stl_algo.h:3468:5: note:   template argum
							      								    								  ent deduction/substitution failed: MINIMUM_PRODUCT
							      								    								  _SUBSET_ARRAY.cpp:61:39: note:   mismatched types
							      								    								  ‘std::initializer_list<_Tp>’ and ‘double’	   m
							      								    								  axNeg = max ( maxNeg , a [ i ] ) ;
							      								    								  			  ^ MINIMUM_PRODUCT_SUBSET_A
							      								    								  RRAY.cpp:63:60: error: no matching function for ca
							      								    								  ll to ‘min(double&, int&)’	  if ( ( a [ i ] > 0
							      								    								   ) ) minPos = min ( minPos , a [ i ] ) ;
							      								    								  
							      								    								   ^ In file included from /usr/include/c++/8/bits/c
							      								    								  har_traits.h:39,		    from /usr/includ
							      								    								  e/c++/8/ios:40,		   from /usr/include
							      								    								  /c++/8/ostream:38,		      from /usr/incl
							      								    								  ude/c++/8/iostream:39,		  from MINIM
							      								    								  UM_PRODUCT_SUBSET_ARRAY.cpp:8: /usr/include/c++/8/
							      								    								  bits/stl_algobase.h:195:5: note: candidate: ‘templ
							      								    								  ate<class _Tp> constexpr const _Tp& std::min(const
							      								    								   _Tp&, const _Tp&)’	   min(const _Tp& __a, const
							      								    								   _Tp& __b)	  ^~~ /usr/include/c++/8/bits/stl_al
							      								    								  gobase.h:195:5: note:	  template argument deductio
							      								    								  n/substitution failed: MINIMUM_PRODUCT_SUBSET_ARRA
							      								    								  Y.cpp:63:60: note:   deduced conflicting types for
							      								    								   parameter ‘const _Tp’ (‘double’ and ‘int’)	   i
							      								    								  f ( ( a [ i ] > 0 ) ) minPos = min ( minPos , a [
							      								    								  i ] ) ;
							      								    								  		    ^ In file included from /usr/inc
							      								    								  lude/c++/8/bits/char_traits.h:39,
							      								    								   from /usr/include/c++/8/ios:40,
							      								    								  from /usr/include/c++/8/ostream:38,
							      								    								     from /usr/include/c++/8/iostream:39,
							      								    								  	 from MINIMUM_PRODUCT_SUBSET_ARRAY.cpp:8: /u
							      								    								  sr/include/c++/8/bits/stl_algobase.h:243:5: note:
							      								    								  candidate: ‘template<class _Tp, class _Compare> co
							      								    								  nstexpr const _Tp& std::min(const _Tp&, const _Tp&
							      								    								  , _Compare)’	    min(const _Tp& __a, const _Tp& _
							      								    								  _b, _Compare __comp)	    ^~~ /usr/include/c++/8/b
							      								    								  its/stl_algobase.h:243:5: note:   template argumen
							      								    								  t deduction/substitution failed: MINIMUM_PRODUCT_S
							      								    								  UBSET_ARRAY.cpp:63:60: note:	 deduced conflicting
							      								    								   types for parameter ‘const _Tp’ (‘double’ and ‘in
							      								    								  t’)	   if ( ( a [ i ] > 0 ) ) minPos = min ( min
							      								    								  Pos , a [ i ] ) ;
							      								    								  			      ^ In file included fro
							      								    								  m /usr/include/c++/8/algorithm:62,
							      								    								    from /usr/include/c++/8/x86_64-redhat-linux/bits
							      								    								  /stdc++.h:65,			 from MINIMUM_PRODUC
							      								    								  T_SUBSET_ARRAY.cpp:14: /usr/include/c++/8/bits/stl
							      								    								  _algo.h:3450:5: note: candidate: ‘template<class _
							      								    								  Tp> constexpr _Tp std::min(std::initializer_list<_
							      								    								  Tp>)’	     min(initializer_list<_Tp> __l)	 ^~~
							      								    								   /usr/include/c++/8/bits/stl_algo.h:3450:5: note:
							      								    								    template argument deduction/substitution failed:
							      								    								   MINIMUM_PRODUCT_SUBSET_ARRAY.cpp:63:60: note:   m
							      								    								  ismatched types ‘std::initializer_list<_Tp>’ and ‘
							      								    								  double’      if ( ( a [ i ] > 0 ) ) minPos = min (
							      								    								   minPos , a [ i ] ) ;
							      								    								  				  ^ In file included
							      								    								   from /usr/include/c++/8/algorithm:62,
							      								    								  	from /usr/include/c++/8/x86_64-redhat-linux/
							      								    								  bits/stdc++.h:65,		     from MINIMUM_PR
							      								    								  ODUCT_SUBSET_ARRAY.cpp:14: /usr/include/c++/8/bits
							      								    								  /stl_algo.h:3456:5: note: candidate: ‘template<cla
							      								    								  ss _Tp, class _Compare> constexpr _Tp std::min(std
							      								    								  ::initializer_list<_Tp>, _Compare)’	   min(initi
							      								    								  alizer_list<_Tp> __l, _Compare __comp)      ^~~ /u
							      								    								  sr/include/c++/8/bits/stl_algo.h:3456:5: note:   t
							      								    								  emplate argument deduction/substitution failed: MI
							      								    								  NIMUM_PRODUCT_SUBSET_ARRAY.cpp:63:60: note:	mism
							      								    								  atched types ‘std::initializer_list<_Tp>’ and ‘dou
							      								    								  ble’	    if ( ( a [ i ] > 0 ) ) minPos = min ( mi
							      								    								  nPos , a [ i ] ) ;
							      								    								  			       ^
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY		      FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY		    FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY		  FIND_ONE_MULTIPLE_REPEATING_ELEMENTS_READ_ARRAY
--							      --							    --								  --
def findRepeatingNumber ( arr , n ) :			      int findRepeatingNumber ( const int arr [ ] , int n ) {	    int findRepeatingNumber ( int * arr , int n ) {		  script_not_found : None
    sq = sqrt ( n )					      	int sq = sqrt ( n ) ;					      double sq = sqrt ( n ) ;					  
    range__ = int ( ( n / sq ) + 1 )			      	int range = ( n / sq ) + 1 ;				      int range__ = ( int ) ( ( n / sq ) + 1 ) ;		  
    count = [ 0 for i in range ( range__ ) ]		      	int count [ range ] = {					      vector < int > count ( range__ , 0 ) ;			  
    for i in range ( 0 , n + 1 , 1 ) :			      	  0 }							      for ( int i = 0 ;						  
	count [ int ( ( arr [ i ] - 1 ) / sq ) ] += 1	      	  ;							      i <= n ;							  
    selected_block = range__ - 1			      	  for ( int i = 0 ;					      i += 1 ) count [ ( int ) ( ( arr [ i ] - 1 ) / sq ) ] ++ ;  
    for i in range ( 0 , range__ - 1 , 1 ) :		      	  i <= n ;						      int selected_block = range__ - 1 ;			  
	if ( count [ i ] > sq ) :			      	  i ++ ) {						      for ( int i = 0 ;						  
	    selected_block = i				      	    count [ ( arr [ i ] - 1 ) / sq ] ++ ;		      i < range__ - 1 ;						  
	    break					      	  }							      i += 1 ) {						  
    m = { i : 0 for i in range ( n ) }			      	  int selected_block = range - 1 ;			    	if ( ( count [ i ] > sq ) ) {				  
    for i in range ( 0 , n + 1 , 1 ) :			      	  for ( int i = 0 ;					    	  selected_block = i ;					  
	if ( ( ( selected_block * sq ) < arr [ i ] ) and ( ar 	  i < range - 1 ;					    	  break ;						  
	    m [ arr [ i ] ] += 1			      	  i ++ ) {						    	}							  
	    if ( m [ arr [ i ] ] > 1 ) :		      	    if ( count [ i ] > sq ) {				      }								  
		return arr [ i ]			      	      selected_block = i ;				      unordered_map < int , int > m ;				  
    return - 1						      	      break ;						      for ( int i = 0 ;						  
							      	    }							      i < n ;							  
							      	  }							      i ++ ) {							  
							      	  unordered_map < int , int > m ;			    	if ( ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ 
							      	  for ( int i = 0 ;					    	  m [ arr [ i ] ] ++ ;					  
							      	  i <= n ;						    	  if ( ( m [ arr [ i ] ] > 1 ) ) return arr [ i ] ;	  
							      	  i ++ ) {						    	}							  
							      	    if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [   }								  
							      	      m [ arr [ i ] ] ++ ;				    }								  
							      	      if ( m [ arr [ i ] ] > 1 ) return arr [ i ] ;	    return - 1 ;						  
							      	    }							    }								  
							      	  }							    								  
							      	  return - 1 ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS  COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS  COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS  COUNT_BINARY_STRINGS_K_TIMES_APPEARING_ADJACENT_TWO_SET_BITS
--							      --							    --								  --
def countStrings ( n , k ) :				      int countStrings ( int n , int k ) {			    int countStrings ( int n , int k ) {			  script_not_found : None
    dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in r 	int dp [ n + 1 ] [ k + 1 ] [ 2 ] ;			      vector < vector < vector < int >>> dp ( n + 1 , vector < in 
    dp [ 1 ] [ 0 ] [ 0 ] = 1				      	memset ( dp , 0 , sizeof ( dp ) ) ;			      dp [ 1 ] [ 0 ] [ 0 ] = 1 ;				  
    dp [ 1 ] [ 0 ] [ 1 ] = 1				      	dp [ 1 ] [ 0 ] [ 0 ] = 1 ;				      dp [ 1 ] [ 0 ] [ 1 ] = 1 ;				  
    for i in range ( 2 , n + 1 ) :			      	dp [ 1 ] [ 0 ] [ 1 ] = 1 ;				      for ( int i = 2 ;						  
	for j in range ( k + 1 ) :			      	for ( int i = 2 ;					      i <= n ;							  
	    dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] 	i <= n ;						      i ++ ) {							  
	    dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ]   	i ++ ) {						    	for ( int j = 0 ;					  
	    if j >= 1 :					      	  for ( int j = 0 ;					    	j < k + 1 ;						  
		dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1  	  j < i ;						    	j ++ ) {						  
    return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ]	      	  j ++ ) {						    	  dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp  
							      	    dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [  	  dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;	  
							      	    dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ;	    	  if ( j >= 1 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j  
							      	    if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ]  	}							  
							      	  }							      }								  
							      	}							      return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ;	  
							      	return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ;	    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_TWO_LARGE_NUMBERS					      SUM_TWO_LARGE_NUMBERS					    SUM_TWO_LARGE_NUMBERS					  SUM_TWO_LARGE_NUMBERS
--							      --							    --								  --
def findSum ( str1 , str2 ) :				      string findSum ( string str1 , string str2 ) {		    string findSum ( string str1 , string str2 ) {		  failure : #Results: 0, 10
    if ( len ( str1 ) > len ( str2 ) ) :		      	if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1 ,    if ( ( str1 . length ( ) > str2 . length ( ) ) ) {	  
	t = str1					      	string str = "" ;					    	string t = str1 ;					  
	str1 = str2					      	int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;	    	str1 = str2 ;						  
	str2 = t					      	reverse ( str1 . begin ( ) , str1 . end ( ) ) ;		    	str2 = t ;						  
    str = ""						      	reverse ( str2 . begin ( ) , str2 . end ( ) ) ;		      }								  
    n1 = len ( str1 )					      	int carry = 0 ;						      string str ;						  
    n2 = len ( str2 )					      	for ( int i = 0 ;					      int n1 = str1 . length ( ) ;				  
    str1 = str1 [ : : - 1 ]				      	i < n1 ;						      int n2 = str2 . length ( ) ;				  
    str2 = str2 [ : : - 1 ]				      	i ++ ) {						      str1 = str1 . substr ( 0 , str1 . length ( ) - 1 ) ;	  
    carry = 0						      	  int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i ] - '0' ) +   str2 = str2 . substr ( 0 , str2 . length ( ) - 1 ) ;	  
    for i in range ( n1 ) :				      	  str . push_back ( sum % 10 + '0' ) ;			      int carry = 0 ;						  
	sum = ( ( ord ( str1 [ i ] ) - 48 ) + ( ( ord ( str2  	  carry = sum / 10 ;					      for ( int i = 0 ;						  
	str += chr ( sum % 10 + 48 )			      	}							      i < n1 ;							  
	carry = int ( sum / 10 )			      	for ( int i = n1 ;					      i ++ ) {							  
    for i in range ( n1 , n2 ) :			      	i < n2 ;						    	int sum = ( ( ( int ) str1 [ i ] - 48 ) + ( ( int ) str2  
	sum = ( ( ord ( str2 [ i ] ) - 48 ) + carry )	      	i ++ ) {						    	str += ( char ) ( sum % 10 + 48 ) ;			  
	str += chr ( sum % 10 + 48 )			      	  int sum = ( ( str2 [ i ] - '0' ) + carry ) ;		    	carry = ( int ) ( sum / 10 ) ;				  
	carry = ( int ) ( sum / 10 )			      	  str . push_back ( sum % 10 + '0' ) ;			      }								  
    if ( carry ) :					      	  carry = sum / 10 ;					      for ( int i = n1 ;					  
	str += chr ( carry + 48 )			      	}							      i < n2 ;							  
    str = str [ : : - 1 ]				      	if ( carry ) str . push_back ( carry + '0' ) ;		      i ++ ) {							  
    return str						      	reverse ( str . begin ( ) , str . end ( ) ) ;		    	int sum = ( ( int ) str2 [ i ] - 48 ) + carry ;		  
							      	return str ;						    	str += ( char ) ( sum % 10 + 48 ) ;			  
							      }								    	carry = ( int ) ( sum / 10 ) ;				  
							      								      }								  
							      								      if ( ( carry ) ) str += ( char ) ( carry + 48 ) ;		  
							      								      str = str . substr ( 0 , str . length ( ) - 1 ) ;		  
							      								      return str ;						  
							      								      return " " + str1 + " " + str2 ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_LONGEST_BALANCED_SUBSEQUENCE			      LENGTH_LONGEST_BALANCED_SUBSEQUENCE			    LENGTH_LONGEST_BALANCED_SUBSEQUENCE				  LENGTH_LONGEST_BALANCED_SUBSEQUENCE
--							      --							    --								  --
def maxLength ( s , n ) :				      int maxLength ( char s [ ] , int n ) {			    int maxLength ( string s , int n ) {			  success : None
    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]  	int dp [ n ] [ n ] ;					      vector < vector < int >> dp ( n , vector < int > ( n , 0 )  
    for i in range ( n - 1 ) :				      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int i = 0 ;						  
	if ( s [ i ] == '(' and s [ i + 1 ] == ')' ) :	      	for ( int i = 0 ;					      i < n ;							  
	    dp [ i ] [ i + 1 ] = 2			      	i < n - 1 ;						      i ++ ) {							  
    for l in range ( 2 , n ) :				      	i ++ ) if ( s [ i ] == '(' && s [ i + 1 ] == ')' ) dp [ i ] 	if ( ( s [ i ] == '(' && s [ i + 1 ] == ')' ) ) dp [ i ]  
	i = - 1						      	for ( int l = 2 ;					      }								  
	for j in range ( l , n ) :			      	l < n ;							      for ( int l = 2 ;						  
	    i += 1					      	l ++ ) {						      l < n ;							  
	    if ( s [ i ] == '(' and s [ j ] == ')' ) :	      	  for ( int i = 0 , j = l ;				      l ++ ) {							  
		dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ]   	  j < n ;						    	int i = - 1 ;						  
	    for k in range ( i , j ) :			      	  i ++ , j ++ ) {					    	for ( int j = l ;					  
		dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [  	    if ( s [ i ] == '(' && s [ j ] == ')' ) dp [ i ] [ j ]  	j < n ;							  
    return dp [ 0 ] [ n - 1 ]				      	    for ( int k = i ;					    	j ++ ) {						  
							      	    k < j ;						    	  i ++ ;						  
							      	    k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] 	  if ( ( s [ i ] == '(' && s [ j ] == ')' ) ) dp [ i ] [  
							      	  }							    	  for ( int k = i ;					  
							      	}							    	  k < j ;						  
							      	return dp [ 0 ] [ n - 1 ] ;				    	  k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] 
							      }								    	}							  
							      								      }								  
							      								      return dp [ 0 ] [ n - 1 ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1	      DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1		    DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1		  DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1
--							      --							    --								  --
def eggDrop ( n , k ) :					      int eggDrop ( int n , int k ) {				    int eggDrop ( int n , int k ) {				  error : DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PU
    eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in rang 	int eggFloor [ n + 1 ] [ k + 1 ] ;			      vector < vector < int >> eggFloor ( n + 1 , vector < int >  ZZLE_1.cpp: In function ‘int f_filled(int, int)’:
    for i in range ( 1 , n + 1 ) :			      	int res ;						      for ( int i = 1 ;						  DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1.c
	eggFloor [ i ] [ 1 ] = 1			      	int i , j , x ;						      i <= n ;							  pp:74:1: warning: no return statement in function
	eggFloor [ i ] [ 0 ] = 0			      	for ( i = 1 ;						      i ++ ) {							  returning non-void [-Wreturn-type]  }	 ^ DYNAMIC_P
    for j in range ( 1 , k + 1 ) :			      	i <= n ;						    	eggFloor [ i ] [ 1 ] = 1 ;				  ROGRAMMING_SET_11_EGG_DROPPING_PUZZLE_1.cpp: At gl
	eggFloor [ 1 ] [ j ] = j			      	i ++ ) {						    	eggFloor [ i ] [ 0 ] = 0 ;				  obal scope: DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPIN
    for i in range ( 2 , n + 1 ) :			      	  eggFloor [ i ] [ 1 ] = 1 ;				      }								  G_PUZZLE_1.cpp:75:1: error: expected unqualified-i
	for j in range ( 2 , k + 1 ) :			      	  eggFloor [ i ] [ 0 ] = 0 ;				      for ( int j = 1 ;						  d before ‘return’  return eggFloor [ n ] [ k ] ;
	    eggFloor [ i ] [ j ] = INT_MAX		      	}							      j <= k ;							  ^~~~~~ DYNAMIC_PROGRAMMING_SET_11_EGG_DROPPING_PUZ
	    for x in range ( 1 , j + 1 ) :		      	for ( j = 1 ;						      j ++ ) eggFloor [ 1 ] [ j ] = j ;				  ZLE_1.cpp:76:1: error: expected declaration before
		res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ]  	j <= k ;						      for ( int i = 2 ;						   ‘}’ token  }	 ^
		if res < eggFloor [ i ] [ j ] :		      	j ++ ) eggFloor [ 1 ] [ j ] = j ;			      i <= n ;							  
		    eggFloor [ i ] [ j ] = res		      	for ( i = 2 ;						      i ++ ) {							  
    return eggFloor [ n ] [ k ]				      	i <= n ;						    	for ( int j = 2 ;					  
							      	i ++ ) {						    	j <= k ;						  
							      	  for ( j = 2 ;						    	j ++ ) {						  
							      	  j <= k ;						    	  eggFloor [ i ] [ j ] = INT_MAX ;			  
							      	  j ++ ) {						    	  for ( int x = 1 ;					  
							      	    eggFloor [ i ] [ j ] = INT_MAX ;			    	  x <= j ;						  
							      	    for ( x = 1 ;					    	  x ++ ) {						  
							      	    x <= j ;						    	    int res = 1 + max < int > ( eggFloor [ i - 1 ] [ x -  
							      	    x ++ ) {						    	    if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j  
							      	      res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFlo 	  }							  
							      	      if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j  	}							  
							      	    }							      }								  
							      	  }							    }								  
							      	}							    return eggFloor [ n ] [ k ] ;				  
							      	return eggFloor [ n ] [ k ] ;				    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_PATH_SUM_MATRIX					      MAXIMUM_PATH_SUM_MATRIX					    MAXIMUM_PATH_SUM_MATRIX					  MAXIMUM_PATH_SUM_MATRIX
--							      --							    --								  --
def findMaxPath ( mat ) :				      int findMaxPath ( int mat [ ] [ M ] ) {			    int findMaxPath ( int * * mat ) {				  script_not_found : None
    res = - 1						      	for ( int i = 1 ;					      int res = - 1 ;						  
    for i in range ( M ) :				      	i < N ;							      for ( int i = 0 ;						  
	res = max ( res , mat [ 0 ] [ i ] )		      	i ++ ) {						      i < M ;							  
    for i in range ( 1 , N ) :				      	  for ( int j = 0 ;					      i ++ ) res = max ( res , mat [ 0 ] [ i ] ) ;		  
	res = - 1					      	  j < M ;						      for ( int i = 1 ;						  
	for j in range ( M ) :				      	  j ++ ) {						      i < N ;							  
	    if ( j > 0 and j < M - 1 ) :		      	    if ( j > 0 && j < M - 1 ) mat [ i ] [ j ] += max ( mat    i ++ ) {							  
		mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ]  	    else if ( j > 0 ) mat [ i ] [ j ] += max ( mat [ i - 1  	res = - 1 ;						  
	    elif ( j > 0 ) :				      	    else if ( j < M - 1 ) mat [ i ] [ j ] += max ( mat [ i  	for ( int j = 0 ;					  
		mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ]  	  }							    	j < M ;							  
	    elif ( j < M - 1 ) :			      	}							    	j ++ ) {						  
		mat [ i ] [ j ] += max ( mat [ i - 1 ] [ j ]  	int res = 0 ;						    	  if ( ( j > 0 && j < M - 1 ) ) mat [ i ] [ j ] += max (  
	    res = max ( mat [ i ] [ j ] , res )		      	for ( int j = 0 ;					    	  else if ( ( j > 0 ) ) mat [ i ] [ j ] += max ( mat [ i  
    return res						      	j < M ;							    	  else if ( ( j < M - 1 ) ) mat [ i ] [ j ] += max ( mat  
							      	j ++ ) res = max ( mat [ N - 1 ] [ j ] , res ) ;	    	  res = max ( mat [ i ] [ j ] , res ) ;			  
							      	return res ;						    	}							  
							      }								      }								  
							      								      return res ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX		      FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX			    FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX			  FIND_MINIMUM_SHIFT_LONGEST_COMMON_PREFIX
--							      --							    --								  --
def KMP ( m , n , str2 , str1 ) :			      void KMP ( int m , int n , string str2 , string str1 ) {	    int KMP ( int m , int n , string str2 , string str1 ) {	  script_not_found : None
    pos = 0						      	int pos = 0 , len = 0 ;					      int pos = 0 ;						  
    Len = 0						      	int p [ m + 1 ] ;					      int Len = 0 ;						  
    p = [ 0 for i in range ( m + 1 ) ]			      	int k = 0 ;						      vector < int > p ( m + 1 , 0 ) ;				  
    k = 0						      	p [ 1 ] = 0 ;						      for ( int i = 0 ;						  
    for i in range ( 2 , n + 1 ) :			      	for ( int i = 2 ;					      i < m + 1 ;						  
	while ( k > 0 and str1 [ k ] != str1 [ i - 1 ] ) :    	i <= n ;						      i ++ ) {							  
	    k = p [ k ]					      	i ++ ) {						    	while ( ( k > 0 ) && str1 [ k ] != str1 [ i - 1 ] ) k = p 
	if ( str1 [ k ] == str1 [ i - 1 ] ) :		      	  while ( k > 0 && str1 [ k ] != str1 [ i - 1 ] ) k = p [ k 	if ( ( str1 [ k ] == str1 [ i - 1 ] ) ) k ++ ;		  
	    k += 1					      	  if ( str1 [ k ] == str1 [ i - 1 ] ) ++ k ;		    	p [ i ] = k ;						  
	p [ i ] = k					      	  p [ i ] = k ;						      }								  
    j = 0						      	}							      int j = 0 ;						  
    for i in range ( m ) :				      	for ( int j = 0 , i = 0 ;				      for ( int i = 0 ;						  
	while ( j > 0 and j < n and str1 [ j ] != str2 [ i ]  	i < m ;							      i < m ;							  
	    j = p [ j ]					      	i ++ ) {						      i ++ ) {							  
	if ( j < n and str1 [ j ] == str2 [ i ] ) :	      	  while ( j > 0 && str1 [ j ] != str2 [ i ] ) j = p [ j ] ; 	while ( ( j > 0 ) && j < n && str1 [ j ] != str2 [ i ] )  
	    j += 1					      	  if ( str1 [ j ] == str2 [ i ] ) j ++ ;		    	if ( ( j < n ) && str1 [ j ] == str2 [ i ] ) j ++ ;	  
	if ( j > Len ) :				      	  if ( j > len ) {					    	if ( ( j > Len ) ) {					  
	    Len = j					      	    len = j ;						    	  Len = j ;						  
	    pos = i - j + 1				      	    pos = i - j + 1 ;					    	  pos = i - j + 1 ;					  
    print ( "Shift = " , pos )				      	  }							    	}							  
    print ( "Prefix = " , str1 [ : Len ] )		      	}							      }								  
							      	cout << "Shift = " << pos << endl ;			      cout << "Shift = " << pos << endl ;			  
							      	cout << "Prefix = " << str1 . substr ( 0 , len ) ;	      cout << "Prefix = " << str1 . substr ( 0 , Len ) << endl ;  
							      }								      return pos ;						  
							      								      return m * m ;						  
							      								      return m * m * m * m * m * m * m * m * m * m * m * m * m *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_NUMBER_ENDLESS_POINTS				      FIND_NUMBER_ENDLESS_POINTS				    FIND_NUMBER_ENDLESS_POINTS					  FIND_NUMBER_ENDLESS_POINTS
--							      --							    --								  --
def countEndless ( input_mat , n ) :			      int countEndless ( bool input [ ] [ MAX ] , int n ) {	    int countEndless ( int inputMat [ ] [ 3 ] , int n ) {	  script_not_found : None
    row = np.zeros ( ( n , n ) )			      	bool row [ n ] [ n ] , col [ n ] [ n ] ;		      vector < vector < int >> row ( n , vector < int > ( n , 0 ) 
    col = np.zeros ( ( n , n ) )			      	for ( int j = 0 ;					      vector < vector < int >> col ( n , vector < int > ( n , 0 ) 
    for j in range ( n ) :				      	j < n ;							      for ( int j = 0 ;						  
	isEndless = 1					      	j ++ ) {						      j < n ;							  
	for i in range ( n - 1 , - 1 , - 1 ) :		      	  bool isEndless = 1 ;					      j ++ ) {							  
	    if ( input_mat [ i ] [ j ] == 0 ) :		      	  for ( int i = n - 1 ;					    	int isEndless = 1 ;					  
		isEndless = 0				      	  i >= 0 ;						    	for ( int i = n - 1 ;					  
	    col [ i ] [ j ] = isEndless			      	  i -- ) {						    	i >= 0 ;						  
    for i in range ( n ) :				      	    if ( input [ i ] [ j ] == 0 ) isEndless = 0 ;	    	i -- ) {						  
	isEndless = 1					      	    col [ i ] [ j ] = isEndless ;			    	  if ( ( inputMat [ i ] [ j ] == 0 ) && ( col [ i ] [ j ] 
	for j in range ( n - 1 , - 1 , - 1 ) :		      	  }							    	  col [ i ] [ j ] = isEndless ;				  
	    if ( input_mat [ i ] [ j ] == 0 ) :		      	}							    	}							  
		isEndless = 0				      	for ( int i = 0 ;					      }								  
	    row [ i ] [ j ] = isEndless			      	i < n ;							      for ( int i = 0 ;						  
    ans = 0						      	i ++ ) {						      i < n ;							  
    for i in range ( n ) :				      	  bool isEndless = 1 ;					      i ++ ) {							  
	for j in range ( 1 , n ) :			      	  for ( int j = n - 1 ;					    	int isEndless = 1 ;					  
	    if ( row [ i ] [ j ] and col [ i ] [ j ] ) :      	  j >= 0 ;						    	for ( int j = n - 1 ;					  
		ans += 1				      	  j -- ) {						    	j >= 0 ;						  
    return ans						      	    if ( input [ i ] [ j ] == 0 ) isEndless = 0 ;	    	j -- ) {						  
							      	    row [ i ] [ j ] = isEndless ;			    	  if ( ( inputMat [ i ] [ j ] == 0 ) && ( col [ i ] [ j ] 
							      	  }							    	  row [ i ] [ j ] = isEndless ;				  
							      	}							    	}							  
							      	int ans = 0 ;						      }								  
							      	for ( int i = 0 ;					      int ans = 0 ;						  
							      	i < n ;							      for ( int i = 0 ;						  
							      	i ++ ) for ( int j = 1 ;				      i < n ;							  
							      	j < n ;							      i ++ ) {							  
							      	j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ;   	for ( int j = 1 ;					  
							      	return ans ;						    	j < n ;							  
							      }								    	j ++ ) {						  
							      								    	  if ( ( row [ i ] [ j ] && col [ i ] [ j ] ) ) ans ++ ;  
							      								    	}							  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORTING_USING_TRIVIAL_HASH_FUNCTION_1			      SORTING_USING_TRIVIAL_HASH_FUNCTION_1			    SORTING_USING_TRIVIAL_HASH_FUNCTION_1			  SORTING_USING_TRIVIAL_HASH_FUNCTION_1
--							      --							    --								  --
def sortUsingHash ( a , n ) :				      void sortUsingHash ( int a [ ] , int n ) {		    int sortUsingHash ( int a [ ] , int n ) {			  script_not_found : None
    Max = max ( a )					      	int max = * std :: max_element ( a , a + n ) ;		      int Max = max ( a ) ;					  
    Min = abs ( min ( a ) )				      	int min = abs ( * std :: min_element ( a , a + n ) ) ;	      int Min = abs ( min ( a ) ) ;				  
    hashpos = [ 0 ] * ( Max + 1 )			      	int hashpos [ max + 1 ] = {				      vector < int > hashpos ( Max + 1 , 0 ) ;			  
    hashneg = [ 0 ] * ( Min + 1 )			      	  0 }							      vector < int > hashneg ( Min + 1 , 0 ) ;			  
    for i in range ( 0 , n ) :				      	  ;							      for ( int i = 0 ;						  
	if a [ i ] >= 0 :				      	  int hashneg [ min + 1 ] = {				      i <= n ;							  
	    hashpos [ a [ i ] ] += 1			      	    0 }							      i ++ ) {							  
	else :						      	    ;							    	if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] ++ ;		  
	    hashneg [ abs ( a [ i ] ) ] += 1		      	    for ( int i = 0 ;					    	else hashneg [ abs ( a [ i ] ) ] ++ ;			  
    for i in range ( Min , 0 , - 1 ) :			      	    i < n ;						      }								  
	if hashneg [ i ] != 0 :				      	    i ++ ) {						      for ( int i = Min ;					  
	    for j in range ( 0 , hashneg [ i ] ) :	      	      if ( a [ i ] >= 0 ) hashpos [ a [ i ] ] += 1 ;	      i > 0 ;							  
		print ( ( - 1 ) * i , end = " " )	      	      else hashneg [ abs ( a [ i ] ) ] += 1 ;		      i -- ) {							  
    for i in range ( 0 , Max + 1 ) :			      	    }							    	if ( hashneg [ i ] != 0 ) for ( int j = 0 ;		  
	if hashpos [ i ] != 0 :				      	    for ( int i = min ;					    	hashneg [ i ] != 0 ;					  
	    for j in range ( 0 , hashpos [ i ] ) :	      	    i > 0 ;						    	j ++ ) cout << ( - 1 ) * i << " " ;			  
		print ( i , end = " " )			      	    i -- ) {						      }								  
							      	      if ( hashneg [ i ] ) {				      for ( int i = 0 ;						  
							      		for ( int j = 0 ;				      i <= Max ;						  
							      		j < hashneg [ i ] ;				      i ++ ) {							  
							      		j ++ ) {					    	if ( hashpos [ i ] != 0 ) for ( int j = 0 ;		  
							      		  cout << ( - 1 ) * i << " " ;			    	hashpos [ i ] != 0 ;					  
							      		}						    	j ++ ) cout << i << " " ;				  
							      	      }							      }								  
							      	    }							      return 0 ;						  
							      	    for ( int i = 0 ;					      return a [ a [ a [ a . length - 1 ] ] * a [ a . length - 1  
							      	    i <= max ;						    }								  
							      	    i ++ ) {						    								  
							      	      if ( hashpos [ i ] ) {				    								  
							      		for ( int j = 0 ;				    								  
							      		j < hashpos [ i ] ;				    								  
							      		j ++ ) {					    								  
							      		  cout << i << " " ;				    								  
							      		}						    								  
							      	      }							    								  
							      	    }							    								  
							      	  }							    								  
-							      	  -							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1		      SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1			    SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1			  SORT_ARRAY_CONVERTING_ELEMENTS_SQUARES_1
--							      --							    --								  --
def sortSquares ( arr , n ) :				      void sortSquares ( int arr [ ] , int n ) {		    int sortSquares ( int * arr , int n ) {			  script_not_found : None
    K = 0						      	int K = 0 ;						      int K ;							  
    for K in range ( n ) :				      	for ( K = 0 ;						      for ( K = 0 ;						  
	if ( arr [ K ] >= 0 ) :				      	K < n ;							      K < n ;							  
	    break					      	K ++ ) if ( arr [ K ] >= 0 ) break ;			      K ++ ) if ( ( arr [ K ] >= 0 ) ) break ;			  
    i = K - 1						      	int i = K - 1 ;						      int i = K - 1 ;						  
    j = K						      	int j = K ;						      int j = K ;						  
    ind = 0						      	int ind = 0 ;						      int ind = 0 ;						  
    temp = [ 0 ] * n					      	int temp [ n ] ;					      int temp [ n ] ;						  
    while ( i >= 0 and j < n ) :			      	while ( i >= 0 && j < n ) {				      while ( ( i >= 0 ) && ( j < n ) ) {			  
	if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] )  	  if ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) {    	if ( ( arr [ i ] * arr [ i ] < arr [ j ] * arr [ j ] ) )  
	    temp [ ind ] = arr [ i ] * arr [ i ]	      	    temp [ ind ] = arr [ i ] * arr [ i ] ;		    	  temp [ ind ] = arr [ i ] * arr [ i ] ;		  
	    i -= 1					      	    i -- ;						    	  i -- ;						  
	else :						      	  }							    	}							  
	    temp [ ind ] = arr [ j ] * arr [ j ]	      	  else {						    	else {							  
	    j += 1					      	    temp [ ind ] = arr [ j ] * arr [ j ] ;		    	  temp [ ind ] = arr [ j ] * arr [ j ] ;		  
	ind += 1					      	    j ++ ;						    	  j ++ ;						  
    while ( i >= 0 ) :					      	  }							    	}							  
	temp [ ind ] = arr [ i ] * arr [ i ]		      	  ind ++ ;						    	ind ++ ;						  
	i -= 1						      	}							      }								  
	ind += 1					      	while ( i >= 0 ) {					      while ( ( i >= 0 ) ) {					  
    while ( j < n ) :					      	  temp [ ind ] = arr [ i ] * arr [ i ] ;		    	temp [ ind ] = arr [ i ] * arr [ i ] ;			  
	temp [ ind ] = arr [ j ] * arr [ j ]		      	  i -- ;						    	i -- ;							  
	j += 1						      	  ind ++ ;						    	ind ++ ;						  
	ind += 1					      	}							      }								  
    for i in range ( n ) :				      	while ( j < n ) {					      while ( ( j < n ) ) {					  
	arr [ i ] = temp [ i ]				      	  temp [ ind ] = arr [ j ] * arr [ j ] ;		    	temp [ ind ] = arr [ j ] * arr [ j ] ;			  
							      	  j ++ ;						    	j ++ ;							  
							      	  ind ++ ;						    	ind ++ ;						  
							      	}							      }								  
							      	for ( int i = 0 ;					      for ( i = 0 ;						  
							      	i < n ;							      i < n ;							  
							      	i ++ ) arr [ i ] = temp [ i ] ;				      i ++ ) arr [ i ] = temp [ i ] ;				  
							      }								      return i ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIVISIBILITY_CHECK					      DIVISIBILITY_CHECK					    DIVISIBILITY_CHECK						  DIVISIBILITY_CHECK
--							      --							    --								  --
def divisibilityCheck ( arr , n ) :			      void divisibilityCheck ( int arr [ ] , int n ) {		    int divisibilityCheck ( int * arr , int n ) {		  script_not_found : None
    s = dict ( )					      	unordered_set < int > s ;				      map < int , int > s ;					  
    max_ele = - 10 ** 9					      	int max_ele = INT_MIN ;					      int maxEle = - 10 * 9 ;					  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	s [ arr [ i ] ] = 1				      	i < n ;							      i < n ;							  
	max_ele = max ( max_ele , arr [ i ] )		      	i ++ ) {						      i ++ ) {							  
    res = dict ( )					      	  s . insert ( arr [ i ] ) ;				    	s [ arr [ i ] ] = 1 ;					  
    for i in range ( n ) :				      	  max_ele = max ( max_ele , arr [ i ] ) ;		    	maxEle = max ( maxEle , arr [ i ] ) ;			  
	if ( arr [ i ] != 0 ) :				      	}							      }								  
	    for j in range ( arr [ i ] * 2 , max_ele + 1 , ar 	unordered_set < int > res ;				      map < int , int > res ;					  
		if ( j in s.keys ( ) ) :		      	for ( int i = 0 ;					      for ( int i = 0 ;						  
		    res [ j ] = 1			      	i < n ;							      i < n ;							  
    for x in res :					      	i ++ ) {						      i ++ ) {							  
	print ( x , end = " " )				      	  if ( arr [ i ] != 0 ) {				    	if ( ( arr [ i ] != 0 ) ) {				  
							      	    for ( int j = arr [ i ] * 2 ;			    	  for ( int j = arr [ i ] * 2 ;				  
							      	    j <= max_ele ;					    	  j <= maxEle + 1 ;					  
							      	    j += arr [ i ] ) {					    	  j += arr [ i ] ) {					  
							      	      if ( s . find ( j ) != s . end ( ) ) res . insert ( j 	    if ( ( s . count ( j ) ) ) res [ j ] = 1 ;		  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	unordered_map < int , int > mp ;			      for ( int x : res ) cout << x << " " ;			  
							      	for ( int i = 0 ;					      return n ;						  
							      	i < n ;							    }								  
							      	i ++ ) mp [ arr [ i ] ] ++ ;				    								  
							      	unordered_map < int , int > :: iterator it ;		    								  
							      	vector < int > ans ;					    								  
							      	for ( it = mp . begin ( ) ;				    								  
							      	it != mp . end ( ) ;					    								  
							      	it ++ ) {						    								  
							      	  if ( it -> second >= 2 ) {				    								  
							      	    if ( res . find ( it -> first ) == res . end ( ) ) {    								  
							      	      int val = it -> second ;				    								  
							      	      while ( val -- ) ans . push_back ( it -> first ) ;    								  
							      	    }							    								  
							      	  }							    								  
							      	  if ( res . find ( it -> first ) != res . end ( ) ) {	    								  
							      	    int val = it -> second ;				    								  
							      	    while ( val -- ) ans . push_back ( it -> first ) ;	    								  
							      	  }							    								  
							      	}							    								  
							      	for ( auto x : ans ) cout << x << " " ;			    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING	      DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING	    DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING		  DYNAMIC_PROGRAMMING_SET_34_ASSEMBLY_LINE_SCHEDULING
--							      --							    --								  --
def carAssembly ( a , t , e , x ) :			      int carAssembly ( int a [ ] [ NUM_STATION ] , int t [ ] [ NUM int carAssembly ( int a [ ] , int t [ ] , int e [ ] , int x [ script_not_found : None
    NUM_STATION = len ( a [ 0 ] )			      	int T1 [ NUM_STATION ] , T2 [ NUM_STATION ] , i ;	      int NUM_STATION = sizeof ( a [ 0 ] ) / sizeof ( a [ 0 ] [ 0 
    T1 = [ 0 for i in range ( NUM_STATION ) ]		      	T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;			      int T1 [ NUM_STATION ] ;					  
    T2 = [ 0 for i in range ( NUM_STATION ) ]		      	T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;			      int T2 [ NUM_STATION ] ;					  
    T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ]			      	for ( i = 1 ;						      T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;			  
    T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ]			      	i < NUM_STATION ;					      T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;			  
    for i in range ( 1 , NUM_STATION ) :		      	++ i ) {						      for ( int i = 1 ;						  
	T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [  	  T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i -    i < NUM_STATION ;						  
	T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [  	  T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i -    i ++ ) {							  
    return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_ 	}							    	T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i -  
							      	return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_ST 	T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i -  
							      }								      }								  
							      								      return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_ST 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION		      WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION		    WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION			  WORD_WRAP_PROBLEM_SPACE_OPTIMIZED_SOLUTION
--							      --							    --								  --
def solveWordWrap ( arr , n , k ) :			      void solveWordWrap ( int arr [ ] , int n , int k ) {	    int solveWordWrap ( int * arr , int n , int k ) {		  script_not_found : None
    dp = [ 0 ] * n					      	int i , j ;						      vector < int > dp ( n , 0 ) ;				  
    ans = [ 0 ] * n					      	int currlen ;						      vector < int > ans ( n , 0 ) ;				  
    dp [ n - 1 ] = 0					      	int cost ;						      dp [ n - 1 ] = 0 ;					  
    ans [ n - 1 ] = n - 1				      	int dp [ n ] ;						      ans [ n - 1 ] = n - 1 ;					  
    for i in range ( n - 2 , - 1 , - 1 ) :		      	int ans [ n ] ;						      for ( int i = n - 2 ;					  
	currlen = - 1					      	dp [ n - 1 ] = 0 ;					      i >= 0 ;							  
	dp [ i ] = sys.maxsize				      	ans [ n - 1 ] = n - 1 ;					      i -- ) {							  
	for j in range ( i , n ) :			      	for ( i = n - 2 ;					    	int currlen = - 1 ;					  
	    currlen += ( arr [ j ] + 1 )		      	i >= 0 ;						    	dp [ i ] = INT_MAX ;					  
	    if ( currlen > k ) :			      	i -- ) {						    	for ( int j = i ;					  
		break					      	  currlen = - 1 ;					    	j < n ;							  
	    if ( j == n - 1 ) :				      	  dp [ i ] = INT_MAX ;					    	j ++ ) {						  
		cost = 0				      	  for ( j = i ;						    	  currlen += ( arr [ j ] + 1 ) ;			  
	    else :					      	  j < n ;						    	  if ( ( currlen > k ) ) break ;			  
		cost = ( ( k - currlen ) * ( k - currlen ) +  	  j ++ ) {						    	  if ( ( j == n - 1 ) ) {				  
	    if ( cost < dp [ i ] ) :			      	    currlen += ( arr [ j ] + 1 ) ;			    	    int cost ;						  
		dp [ i ] = cost				      	    if ( currlen > k ) break ;				    	    if ( ( k - currlen ) * ( k - currlen ) + dp [ j + 1 ] 
		ans [ i ] = j				      	    if ( j == n - 1 ) cost = 0 ;			    	    else cost = ( ( k - currlen ) * ( k - currlen ) + dp  
    i = 0						      	    else cost = ( k - currlen ) * ( k - currlen ) + dp [ j  	    if ( ( cost < dp [ i ] ) ) {			  
    while ( i < n ) :					      	    if ( cost < dp [ i ] ) {				    	      dp [ i ] = cost ;					  
	print ( i + 1 , ans [ i ] + 1 , end = " " )	      	      dp [ i ] = cost ;					    	      ans [ i ] = j ;					  
	i = ans [ i ] + 1				      	      ans [ i ] = j ;					    	    }							  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	i = 0 ;							      int i = 0 ;						  
							      	while ( i < n ) {					      while ( ( i < n ) ) {					  
							      	  cout << i + 1 << " " << ans [ i ] + 1 << " " ;	    	cout << i + 1 << ans [ i ] + 1 << " " ;			  
							      	  i = ans [ i ] + 1 ;					    	i = ans [ i ] + 1 ;					  
							      	}							      }								  
							      }								      return i ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS FINDING_THE_MAXIMUM_SQUARE_SUB_MATRIX_WITH_ALL_EQUAL_ELEMENTS
--							      --							    --								  --
def largestKSubmatrix ( a ) :				      int largestKSubmatrix ( int a [ ] [ Col ] ) {		    int largestKSubmatrix ( int a [ ] [ Col ] ) {		  script_not_found : None
    dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col  	int dp [ Row ] [ Col ] ;				      vector < vector < int >> dp ( Row , vector < int > ( Col ,  
    result = 0						      	memset ( dp , sizeof ( dp ) , 0 ) ;			      for ( int y = 0 ;						  
    for i in range ( Row ) :				      	int result = 0 ;					      y < Row ;							  
	for j in range ( Col ) :			      	for ( int i = 0 ;					      y ++ ) dp [ y ] [ 0 ] = 0 ;				  
	    if ( i == 0 or j == 0 ) :			      	i < Row ;						      for ( int i = 0 ;						  
		dp [ i ] [ j ] = 1			      	i ++ ) {						      i < Col ;							  
	    else :					      	  for ( int j = 0 ;					      i ++ ) dp [ i ] [ 1 ] = 1 ;				  
		if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a 	  j < Col ;						      int result = 0 ;						  
		    dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] 	  j ++ ) {						      for ( int i = 0 ;						  
		else :					      	    if ( i == 0 || j == 0 ) dp [ i ] [ j ] = 1 ;	      i < Row ;							  
		    dp [ i ] [ j ] = 1			      	    else {						      i ++ ) {							  
	    result = max ( result , dp [ i ] [ j ] )	      	      if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [  	for ( int j = 0 ;					  
    return result					      	      else dp [ i ] [ j ] = 1 ;				    	j < Col ;						  
							      	    }							    	j ++ ) {						  
							      	    result = max ( result , dp [ i ] [ j ] ) ;		    	  if ( ( i == 0 || j == 0 ) ) dp [ i ] [ j ] = 1 ;	  
							      	  }							    	  else {						  
							      	}							    	    if ( ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ]  
							      	return result ;						    	    else dp [ i ] [ j ] = 1 ;				  
							      }								    	  }							  
							      								    	  result = max ( result , dp [ i ] [ j ] ) ;		  
							      								    	}							  
							      								      }								  
							      								      return result ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1		      COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1		    COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1		  COUNT_PALINDROMIC_SUBSEQUENCE_GIVEN_STRING_1
--							      --							    --								  --
def countPS ( i , j ) :					      int countPS ( int i , int j ) {				    int countPS ( int i , int j ) {				  script_not_found : None
    if ( i >= n or j < 0 ) :				      	if ( i >= n || j < 0 ) return 0 ;			      if ( ( i >= n ) || ( j < 0 ) ) return 0 ;			  
	return 0					      	if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ;	      if ( ( dp [ i ] [ j ] != - 1 ) ) return dp [ i ] [ j ] ;	  
    if ( dp [ i ] [ j ] != - 1 ) :			      	if ( abs ( i - j ) == 1 ) {				      if ( ( abs ( i - j ) == 1 ) ) {				  
	return dp [ i ] [ j ]				      	  if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = 3 ; 	if ( ( str [ i ] == str [ j ] ) ) {			  
    if ( abs ( i - j ) == 1 ) :				      	  else return dp [ i ] [ j ] = 2 ;			    	  dp [ i ] [ j ] = 3 ;					  
	if ( str [ i ] == str [ j ] ) :			      	}							    	  return dp [ i ] [ j ] ;				  
	    dp [ i ] [ j ] = 3				      	if ( i == j ) return dp [ 1 ] [ j ] = 1 ;		    	}							  
	    return dp [ i ] [ j ]			      	else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] =  	else {							  
	else :						      	else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countP 	  dp [ i ] [ j ] = 2 ;					  
	    dp [ i ] [ j ] = 2				      }								    	  return dp [ i ] [ j ] ;				  
	    return dp [ i ] [ j ]			      								    	}							  
    if ( i == j ) :					      								      }								  
	dp [ 1 ] [ j ] = 1				      								      if ( ( i == j ) ) {					  
	return dp [ 1 ] [ j ]				      								    	dp [ 1 ] [ j ] = 1 ;					  
    elif ( str [ i ] == str [ j ] ) :			      								    	return dp [ 1 ] [ j ] ;					  
	dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS (  								      }								  
	return dp [ i ] [ j ]				      								      else if ( ( str [ i ] == str [ j ] ) ) {			  
    else :						      								    	dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i ,  
	dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS (  								    	return dp [ i ] [ j ] ;					  
	return dp [ i ] [ j ]				      								      }								  
							      								      else {							  
							      								    	dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i ,  
							      								    	return dp [ i ] [ j ] ;					  
							      								      }								  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K			      SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K				    SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K				  SUBARRAY_NO_PAIR_SUM_DIVISIBLE_K
--							      --							    --								  --
def subarrayDivisibleByK ( arr , n , k ) :		      void subarrayDivisibleByK ( int arr [ ] , int n , int k ) {   int subarrayDivisibleByK ( int * arr , int n , int k ) {	  script_not_found : None
    mp = [ 0 ] * 1000					      	map < int , int > mp ;					      int mp [ 1000 ] ;						  
    s = 0 e = 0 maxs = 0 maxe = 0			      	int s = 0 , e = 0 , maxs = 0 , maxe = 0 ;		      int s = 0 ;						  
    mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1	      	mp [ arr [ 0 ] % k ] ++ ;				      int e = 0 ;						  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      int maxs = 0 ;						  
	mod = arr [ i ] % k				      	i < n ;							      mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1 ;		  
	while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mo 	i ++ ) {						      for ( int i = 1 ;						  
	    mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1   	  int mod = arr [ i ] % k ;				      i < n ;							  
	    s = s + 1					      	  while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] !   i ++ ) {							  
	mp [ mod ] = mp [ mod ] + 1			      	    mp [ arr [ s ] % k ] -- ;				    	int mod = arr [ i ] % k ;				  
	e = e + 1					      	    s ++ ;						    	while ( ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] 
	if ( ( e - s ) > ( maxe - maxs ) ) :		      	  }							    	  mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 ;	  
	    maxe = e					      	  mp [ mod ] ++ ;					    	  s = s + 1 ;						  
	    maxs = s					      	  e ++ ;						    	}							  
    print ( "The maximum size is {} and the ".format ( ( maxe 	  if ( ( e - s ) > ( maxe - maxs ) ) {			    	mp [ mod ] = mp [ mod ] + 1 ;				  
	print ( "{} ".format ( arr [ i ] ) , end = "" )	      	    maxe = e ;						    	e = e + 1 ;						  
							      	    maxs = s ;						    	if ( ( ( e - s ) > ( maxe - maxs ) ) ) {		  
							      	  }							    	  maxe = e ;						  
							      	}							    	  maxs = s ;						  
							      	cout << "The maximum size is " << maxe - maxs + 1 << " and  	}							  
							      	for ( int i = maxs ;					      }								  
							      	i <= maxe ;						      cout << "The maximum size is " << ( maxe - maxs + 1 ) << "  
							      	i ++ ) cout << arr [ i ] << " " ;			      for ( int i = maxs ;					  
							      }								      i <= maxe ;						  
							      								      i ++ ) cout << "{} " ;					  
							      								      return 0 ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES			      CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES			    CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES			  CONSTRUCT_GRAPH_GIVEN_DEGREES_VERTICES
--							      --							    --								  --
def printMat ( degseq , n ) :				      void printMat ( int degseq [ ] , int n ) {		    int printMat ( int * * degseq , int n ) {			  script_not_found : None
    mat = [ [ 0 ] * n for i in range ( n ) ]		      	int mat [ n ] [ n ] ;					      vector < vector < int >> vec ( n , vector < int > ( n , 0 ) 
    for i in range ( n ) :				      	memset ( mat , 0 , sizeof ( mat ) ) ;			      for ( int i = 0 ;						  
	for j in range ( i + 1 , n ) :			      	for ( int i = 0 ;					      i < n ;							  
	    if ( degseq [ i ] > 0 and degseq [ j ] > 0 ) :    	i < n ;							      i ++ ) {							  
		degseq [ i ] -= 1			      	i ++ ) {						    	for ( int j = i + 1 ;					  
		degseq [ j ] -= 1			      	  for ( int j = i + 1 ;					    	j < n ;							  
		mat [ i ] [ j ] = 1			      	  j < n ;						    	j ++ ) {						  
		mat [ j ] [ i ] = 1			      	  j ++ ) {						    	  if ( ( degseq [ i ] > 0 && degseq [ j ] > 0 ) ) {	  
    print ( "	   " , end = "" )			      	    if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) {	    	    degseq [ i ] -- ;					  
    for i in range ( n ) :				      	      degseq [ i ] -- ;					    	    degseq [ j ] -- ;					  
	print ( "" , "(" , i , ")" , end = "" )		      	      degseq [ j ] -- ;					    	    vec [ i ] [ j ] = 1 ;				  
    print ( )						      	      mat [ i ] [ j ] = 1 ;				    	    vec [ j ] [ i ] = 1 ;				  
    print ( )						      	      mat [ j ] [ i ] = 1 ;				    	  }							  
    for i in range ( n ) :				      	    }							    	}							  
	print ( "" , "(" , i , ")" , end = "" )		      	  }							      }								  
	for j in range ( n ) :				      	}							      cout << "	     " << endl ;				  
	    print ( "	  " , mat [ i ] [ j ] , end = "" )    	cout << "\n" << setw ( 3 ) << "	    " ;			      for ( int i = 0 ;						  
	print ( )					      	for ( int i = 0 ;					      i < n ;							  
							      	i < n ;							      i ++ ) cout << " " << "(" << i << ")" << endl ;		  
							      	i ++ ) cout << setw ( 3 ) << "(" << i << ")" ;		      cout << endl ;						  
							      	cout << "\n\n" ;					      cout << endl ;						  
							      	for ( int i = 0 ;					      for ( int i = 0 ;						  
							      	i < n ;							      i < n ;							  
							      	i ++ ) {						      i ++ ) {							  
							      	  cout << setw ( 4 ) << "(" << i << ")" ;		    	cout << " " << "(" << i << ")" << endl ;		  
							      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
							      	  j < n ;						    	j < n ;							  
							      	  j ++ ) cout << setw ( 5 ) << mat [ i ] [ j ] ;	    	j ++ ) cout << "     " << vec [ i ] [ j ] << endl ;	  
							      	  cout << "\n" ;					    	cout << endl ;						  
							      	}							      }								  
							      }								      return 0 ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_BEST_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
def bestFit ( blockSize , m , processSize , n ) :	      void bestFit ( int blockSize [ ] , int m , int processSize [  int bestFit ( int * blockSize , int m , int * processSize , i script_not_found : None
    allocation = [ - 1 ] * n				      	int allocation [ n ] ;					      int allocation [ n ] ;					  
    for i in range ( n ) :				      	memset ( allocation , - 1 , sizeof ( allocation ) ) ;	      for ( int i = 0 ;						  
	bestIdx = - 1					      	for ( int i = 0 ;					      i < n ;							  
	for j in range ( m ) :				      	i < n ;							      i ++ ) {							  
	    if blockSize [ j ] >= processSize [ i ] :	      	i ++ ) {						    	int bestIdx = - 1 ;					  
		if bestIdx == - 1 :			      	  int bestIdx = - 1 ;					    	for ( int j = 0 ;					  
		    bestIdx = j				      	  for ( int j = 0 ;					    	j < m ;							  
		elif blockSize [ bestIdx ] > blockSize [ j ]  	  j < m ;						    	j ++ ) {						  
		    bestIdx = j				      	  j ++ ) {						    	  if ( blockSize [ j ] >= processSize [ i ] ) {		  
	if bestIdx != - 1 :				      	    if ( blockSize [ j ] >= processSize [ i ] ) {	    	    if ( bestIdx == - 1 ) bestIdx = j ;			  
	    allocation [ i ] = bestIdx			      	      if ( bestIdx == - 1 ) bestIdx = j ;		    	    else if ( blockSize [ bestIdx ] > blockSize [ j ] ) b 
	    blockSize [ bestIdx ] -= processSize [ i ]	      	      else if ( blockSize [ bestIdx ] > blockSize [ j ] ) b 	  }							  
    print ( "Process No.Process Size	 Block no." )	      	    }							    	}							  
    for i in range ( n ) :				      	  }							    	if ( bestIdx != - 1 ) {					  
	print ( i + 1 , "	  " , processSize [ i ] , end 	  if ( bestIdx != - 1 ) {				    	  allocation [ i ] = bestIdx ;				  
	if allocation [ i ] != - 1 :			      	    allocation [ i ] = bestIdx ;			    	  blockSize [ bestIdx ] -= processSize [ i ] ;		  
	    print ( allocation [ i ] + 1 )		      	    blockSize [ bestIdx ] -= processSize [ i ] ;	    	}							  
	else :						      	  }							      }								  
	    print ( "Not Allocated" )			      	}							      cout << "Process No. Process Size	   Block no." << endl ;	  
							      	cout << "\nProcess No.\tProcess Size\tBlock no.\n" ;	      for ( int i = 0 ;						  
							      	for ( int i = 0 ;					      i < n ;							  
							      	i < n ;							      i ++ ) {							  
							      	i ++ ) {						    	cout << i + 1 << "	   " << processSize [ i ] << "	  
							      	  cout << "   " << i + 1 << "\t\t" << processSize [ i ] <<  	if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 
							      	  if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 	else cout << "Not Allocated" << endl ;			  
							      	  else cout << "Not Allocated" ;			      }								  
							      	  cout << endl ;					      return allocation [ n ] ;					  
							      	}							    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1	      LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1		    LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1		  LARGEST_SUBARRAY_WITH_EQUAL_NUMBER_OF_0S_AND_1S_1
--							      --							    --								  --
def maxLen ( arr , n ) :				      int maxLen ( int arr [ ] , int n ) {			    int maxLen ( int * arr , int n ) {				  failure : 0  to -1 0 to -1 0	to -1 0 to -1 0	 to
    hash_map = { }					      	unordered_map < int , int > hM ;			      unordered_map < int , int > hashMap ;			  -1 9 to 18 0	to -1 0 to -1 0	 to -1 0 to -1 0  to
    curr_sum = 0					      	int sum = 0 ;						      int currSum = 0 ;						   -1 0 to -1 0	 to -1 0 to -1 0  to -1 10 to 11 0
    max_len = 0						      	int max_len = 0 ;					      int maxLen = 0 ;						  to -1 7 to 8 0  to -1 0 to -1 #Results: 7, 10
    ending_index = - 1					      	int ending_index = - 1 ;				      int endingIndex = - 1 ;					  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( arr [ i ] == 0 ) :				      	i < n ;							      i <= n ;							  
	    arr [ i ] = - 1				      	i ++ ) arr [ i ] = ( arr [ i ] == 0 ) ? - 1 : 1 ;	      i ++ ) {							  
	else :						      	for ( int i = 0 ;					    	if ( ( arr [ i ] == 0 ) ) arr [ i ] = - 1 ;		  
	    arr [ i ] = 1				      	i < n ;							    	else arr [ i ] = 1 ;					  
    for i in range ( 0 , n ) :				      	i ++ ) {						      }								  
	curr_sum = curr_sum + arr [ i ]			      	  sum += arr [ i ] ;					      for ( int i = 0 ;						  
	if ( curr_sum == 0 ) :				      	  if ( sum == 0 ) {					      i <= n ;							  
	    max_len = i + 1				      	    max_len = i + 1 ;					      i ++ ) {							  
	    ending_index = i				      	    ending_index = i ;					    	currSum = currSum + arr [ i ] ;				  
	if ( curr_sum + n ) in hash_map :		      	  }							    	if ( ( currSum == 0 ) ) {				  
	    max_len = max ( max_len , i - hash_map [ curr_sum 	  if ( hM . find ( sum + n ) != hM . end ( ) ) {	    	  maxLen = i + 1 ;					  
	else :						      	    if ( max_len < i - hM [ sum + n ] ) {		    	  endingIndex = i ;					  
	    hash_map [ curr_sum ] = i			      	      max_len = i - hM [ sum + n ] ;			    	}							  
    for i in range ( 0 , n ) :				      	      ending_index = i ;				    	if ( hashMap . count ( currSum + n ) ) maxLen = max < int 
	if ( arr [ i ] == - 1 ) :			      	    }							    	else hashMap [ currSum ] = i ;				  
	    arr [ i ] = 0				      	  }							      }								  
	else :						      	  else hM [ sum + n ] = i ;				      for ( int i = 0 ;						  
	    arr [ i ] = 1				      	}							      i <= n ;							  
    print ( ending_index - max_len + 1 , end = " " )	      	for ( int i = 0 ;					      i ++ ) {							  
    print ( "to" , end = " " )				      	i < n ;							    	if ( ( arr [ i ] == - 1 ) ) arr [ i ] = 0 ;		  
    print ( ending_index )				      	i ++ ) arr [ i ] = ( arr [ i ] == - 1 ) ? 0 : 1 ;	    	else arr [ i ] = 1 ;					  
    return max_len					      	printf ( "%d to %d\n" , ending_index - max_len + 1 , ending   }								  
							      	return max_len ;					      cout << endingIndex - maxLen + 1 << " " ;			  
							      }								      cout << " to" << endl ;					  
							      								      cout << endingIndex << endl ;				  
							      								      return maxLen ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN FIND_K_SUCH_THAT_ALL_ELEMENTS_IN_KTH_ROW_ARE_0_AND_KTH_COLUMN
--							      --							    --								  --
def find ( arr ) :					      int find ( bool arr [ n ] [ n ] ) {			    int find ( int * arr ) {					  script_not_found : None
    n = len ( arr )					      	int i = 0 , j = n - 1 ;					      int n = sizeof ( arr ) / sizeof ( int ) ;			  
    i = 0						      	int res = - 1 ;						      int i = 0 ;						  
    j = n - 1						      	while ( i < n && j >= 0 ) {				      int j = n - 1 ;						  
    res = - 1						      	  if ( arr [ i ] [ j ] == 0 ) {				      int res = - 1 ;						  
    while i < n and j >= 0 :				      	    while ( j >= 0 && ( arr [ i ] [ j ] == 0 || i == j ) )    while ( i < n && j >= 0 ) {				  
	if arr [ i ] [ j ] == 0 :			      	    if ( j == - 1 ) {					    	if ( arr [ i ] [ j ] == 0 ) {				  
	    while j >= 0 and ( arr [ i ] [ j ] == 0 or i == j 	      res = i ;						    	  while ( j >= 0 && ( arr [ i ] [ j ] == 0 || i == j ) )  
		j -= 1					      	      break ;						    	  if ( j == - 1 ) {					  
	    if j == - 1 :				      	    }							    	    res = i ;						  
		res = i					      	    else i ++ ;						    	    break ;						  
		break					      	  }							    	  }							  
	    else : i += 1				      	  else {						    	  else i ++ ;						  
	else :						      	    while ( i < n && ( arr [ i ] [ j ] == 1 || i == j ) ) i 	}							  
	    while i < n and ( arr [ i ] [ j ] == 1 or i == j  	    if ( i == n ) {					    	else {							  
		i += 1					      	      res = j ;						    	  while ( i < n && ( arr [ i ] [ j ] == 1 || i == j ) ) i 
	    if i == n :					      	      break ;						    	  if ( i == n ) {					  
		res = j					      	    }							    	    res = j ;						  
		break					      	    else j -- ;						    	    break ;						  
	    else : j -= 1				      	  }							    	  }							  
    if res == - 1 :					      	}							    	  else j -- ;						  
	return res					      	if ( res == - 1 ) return res ;				    	}							  
    for i in range ( 0 , n ) :				      	for ( int i = 0 ;					      }								  
	if res != i and arr [ i ] [ res ] != 1 :	      	i < n ;							      if ( res == - 1 ) return res ;				  
	    return - 1					      	i ++ ) if ( res != i && arr [ i ] [ res ] != 1 ) return - 1   for ( i = 0 ;						  
    for j in range ( 0 , j ) :				      	for ( int j = 0 ;					      i <= n ;							  
	if res != j and arr [ res ] [ j ] != 0 :	      	j < n ;							      i ++ ) if ( res != i && arr [ i ] [ res ] != 1 ) return - 1 
	    return - 1 ;				      	j ++ ) if ( res != j && arr [ res ] [ j ] != 0 ) return - 1   for ( j = 0 ;						  
    return res ;					      	return res ;						      j <= j ;							  
							      }								      j ++ ) if ( res != j && arr [ res ] [ j ] != 0 ) return - 1 
							      								      return res ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET MAXIMUM_NUMBER_OF_TRAILING_ZEROS_IN_THE_PRODUCT_OF_THE_SUBSET
--							      --							    --								  --
def maximumZeros ( arr , n , k ) :			      int maximumZeros ( int * arr , int n , int k ) {		    int maximumZeros ( int * arr , int n , int k ) {		  script_not_found : None
    global MAX5						      	int subset [ k + 1 ] [ MAX5 + 5 ] ;			      static int MAX5 = 0 ;					  
    subset = [ [ - 1 ] * ( MAX5 + 5 ) for _ in range ( k + 1  	memset ( subset , - 1 , sizeof ( subset ) ) ;		      int subset [ k + 1 ] [ MAX5 + 5 ] ;			  
    subset [ 0 ] [ 0 ] = 0				      	subset [ 0 ] [ 0 ] = 0 ;				      memset ( subset , 0 , sizeof ( subset ) ) ;		  
    for p in arr :					      	for ( int p = 0 ;					      subset [ 0 ] [ 0 ] = 0 ;					  
	pw2 , pw5 = 0 , 0				      	p < n ;							      for ( int p = 0 ;						  
	while not p % 2 :				      	p ++ ) {						      p < n ;							  
	    pw2 += 1					      	  int pw2 = 0 , pw5 = 0 ;				      p ++ ) {							  
	    p //= 2					      	  while ( arr [ p ] % 2 == 0 ) {			    	int pw2 = 0 , pw5 = 0 ;					  
	while not p % 5 :				      	    pw2 ++ ;						    	while ( ! p % 2 ) {					  
	    pw5 += 1					      	    arr [ p ] /= 2 ;					    	  pw2 ++ ;						  
	    p //= 5					      	  }							    	  p /= 2 ;						  
	for i in range ( k - 1 , - 1 , - 1 ) :		      	  while ( arr [ p ] % 5 == 0 ) {			    	}							  
	    for j in range ( MAX5 ) :			      	    pw5 ++ ;						    	while ( ! p % 5 ) {					  
		if subset [ i ] [ j ] != - 1 :		      	    arr [ p ] /= 5 ;					    	  pw5 ++ ;						  
		    subset [ i + 1 ] [ j + pw5 ] = ( max ( su 	  }							    	  p /= 5 ;						  
    ans = 0						      	  for ( int i = k - 1 ;					    	}							  
    for i in range ( MAX5 ) :				      	  i >= 0 ;						    	for ( int i = k - 1 ;					  
	ans = max ( ans , min ( i , subset [ k ] [ i ] ) )    	  i -- ) for ( int j = 0 ;				    	i >= 0 ;						  
    return ans						      	  j < MAX5 ;						    	i -- ) {						  
							      	  j ++ ) if ( subset [ i ] [ j ] != - 1 ) subset [ i + 1 ]  	  for ( int j = 0 ;					  
							      	}							    	  j < MAX5 ;						  
							      	int ans = 0 ;						    	  j ++ ) {						  
							      	for ( int i = 0 ;					    	    if ( subset [ i ] [ j ] != - 1 ) subset [ i + 1 ] [ j 
							      	i < MAX5 ;						    	  }							  
							      	i ++ ) ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) ; 	}							  
							      	return ans ;						      }								  
							      }								      int ans = 0 ;						  
							      								      for ( int i = 0 ;						  
							      								      i < MAX5 ;						  
							      								      i ++ ) ans = max ( ans , min ( i , subset [ k ] [ i ] ) ) ; 
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT		      PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT		    PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT		  PROGRAM_WORST_FIT_ALGORITHM_MEMORY_MANAGEMENT
--							      --							    --								  --
def worstFit ( blockSize , m , processSize , n ) :	      void worstFit ( int blockSize [ ] , int m , int processSize [ int worstFit ( int blockSize [ ] , int m , int processSize [  script_not_found : None
    allocation = [ - 1 ] * n				      	int allocation [ n ] ;					      int allocation [ n ] ;					  
    for i in range ( n ) :				      	memset ( allocation , - 1 , sizeof ( allocation ) ) ;	      for ( int i = 0 ;						  
	wstIdx = - 1					      	for ( int i = 0 ;					      i < n ;							  
	for j in range ( m ) :				      	i < n ;							      i ++ ) {							  
	    if blockSize [ j ] >= processSize [ i ] :	      	i ++ ) {						    	int wstIdx = - 1 ;					  
		if wstIdx == - 1 :			      	  int wstIdx = - 1 ;					    	for ( int j = 0 ;					  
		    wstIdx = j				      	  for ( int j = 0 ;					    	j < m ;							  
		elif blockSize [ wstIdx ] < blockSize [ j ] : 	  j < m ;						    	j ++ ) {						  
		    wstIdx = j				      	  j ++ ) {						    	  if ( blockSize [ j ] >= processSize [ i ] ) {		  
	if wstIdx != - 1 :				      	    if ( blockSize [ j ] >= processSize [ i ] ) {	    	    if ( wstIdx == - 1 ) wstIdx = j ;			  
	    allocation [ i ] = wstIdx			      	      if ( wstIdx == - 1 ) wstIdx = j ;			    	    else if ( blockSize [ wstIdx ] < blockSize [ j ] ) ws 
	    blockSize [ wstIdx ] -= processSize [ i ]	      	      else if ( blockSize [ wstIdx ] < blockSize [ j ] ) ws 	  }							  
    print ( "Process No.Process Size Block no." )	      	    }							    	}							  
    for i in range ( n ) :				      	  }							    	if ( wstIdx != - 1 ) {					  
	print ( i + 1 , "	  " , processSize [ i ] , end 	  if ( wstIdx != - 1 ) {				    	  allocation [ i ] = wstIdx ;				  
	if allocation [ i ] != - 1 :			      	    allocation [ i ] = wstIdx ;				    	  blockSize [ wstIdx ] -= processSize [ i ] ;		  
	    print ( allocation [ i ] + 1 )		      	    blockSize [ wstIdx ] -= processSize [ i ] ;		    	}							  
	else :						      	  }							      }								  
	    print ( "Not Allocated" )			      	}							      cout << "Process No. Process Size Block no." << endl ;	  
							      	cout << "\nProcess No.\tProcess Size\tBlock no.\n" ;	      for ( int i = 0 ;						  
							      	for ( int i = 0 ;					      i < n ;							  
							      	i < n ;							      i ++ ) {							  
							      	i ++ ) {						    	cout << i + 1 << "	  " << processSize [ i ] << "	  
							      	  cout << "   " << i + 1 << "\t\t" << processSize [ i ] <<  	if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 
							      	  if ( allocation [ i ] != - 1 ) cout << allocation [ i ] + 	else cout << "Not Allocated" << endl ;			  
							      	  else cout << "Not Allocated" ;			      }								  
							      	  cout << endl ;					      return 0 ;						  
							      	}							      return m * m ;						  
							      }								      return m * m * m * m * m * m * m * m * m * m * m * m * m *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM			      MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM			    MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM			  MAXIMUM_SUM_ALTERNATING_SUBSEQUENCE_SUM
--							      --							    --								  --
def maxAlternateSum ( arr , n ) :			      int maxAlternateSum ( int arr [ ] , int n ) {		    int maxAlternateSum ( int * arr , int n ) {			  failure : #Results: 4, 10
    if ( n == 1 ) :					      	if ( n == 1 ) return arr [ 0 ] ;			      if ( ( n == 1 ) ) return arr [ 0 ] ;			  
	return arr [ 0 ]				      	int dec [ n ] ;						      int dec [ n + 1 ] ;					  
    dec = [ 0 for i in range ( n + 1 ) ]		      	memset ( dec , 0 , sizeof ( dec ) ) ;			      int inc [ n + 1 ] ;					  
    inc = [ 0 for i in range ( n + 1 ) ]		      	int inc [ n ] ;						      dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ;			  
    dec [ 0 ] = inc [ 0 ] = arr [ 0 ]			      	memset ( inc , 0 , sizeof ( inc ) ) ;			      int flag = 0 ;						  
    flag = 0						      	dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ;			      for ( int i = 1 ;						  
    for i in range ( 1 , n ) :				      	int flag = 0 ;						      i < n ;							  
	for j in range ( i ) :				      	for ( int i = 1 ;					      i ++ ) {							  
	    if ( arr [ j ] > arr [ i ] ) :		      	i < n ;							    	for ( int j = 0 ;					  
		dec [ i ] = max ( dec [ i ] , inc [ j ] + arr 	i ++ ) {						    	j < i ;							  
		flag = 1				      	  for ( int j = 0 ;					    	j ++ ) {						  
	    elif ( arr [ j ] < arr [ i ] and flag == 1 ) :    	  j < i ;						    	  if ( ( arr [ j ] > arr [ i ] ) ) {			  
		inc [ i ] = max ( inc [ i ] , dec [ j ] + arr 	  j ++ ) {						    	    dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) 
    result = - 2147483648				      	    if ( arr [ j ] > arr [ i ] ) {			    	    flag = 1 ;						  
    for i in range ( n ) :				      	      dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) 	  }							  
	if ( result < inc [ i ] ) :			      	      flag = 1 ;					    	  else if ( ( arr [ j ] < arr [ i ] ) && flag == 1 ) inc  
	    result = inc [ i ]				      	    }							    	}							  
	if ( result < dec [ i ] ) :			      	    else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i    }								  
	    result = dec [ i ]				      	  }							      int result = - 2147483648 ;				  
    return result					      	}							      for ( int i = 0 ;						  
							      	int result = INT_MIN ;					      i < n ;							  
							      	for ( int i = 0 ;					      i ++ ) {							  
							      	i < n ;							    	if ( ( result < inc [ i ] ) ) result = inc [ i ] ;	  
							      	i ++ ) {						    	if ( ( result < dec [ i ] ) ) result = dec [ i ] ;	  
							      	  if ( result < inc [ i ] ) result = inc [ i ] ;	      }								  
							      	  if ( result < dec [ i ] ) result = dec [ i ] ;	      return result ;						  
							      	}							    }								  
							      	return result ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT		      MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT			    MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT			  MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT
--							      --							    --								  --
def maxSumSubarrayRemovingOneEle ( arr , n ) :		      int maxSumSubarrayRemovingOneEle ( int arr [ ] , int n ) {    int maxSumSubarrayRemovingOneEle ( int * arr , int n ) {	  error : MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT.
    fw = [ 0 for k in range ( n ) ]			      	int fw [ n ] , bw [ n ] ;				      int * fw = new int [ n ] ;				  cpp: In function ‘int f_filled(int*, int)’: MAXIMU
    bw = [ 0 for k in range ( n ) ]			      	int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ;	      for ( int k = 0 ;						  M_SUM_SUBARRAY_REMOVING_ONE_ELEMENT.cpp:60:5: erro
    cur_max , max_so_far = arr [ 0 ] , arr [ 0 ]	      	fw [ 0 ] = arr [ 0 ] ;					      k < n ;							  r: ‘curMax’ was not declared in this scope	  cu
    for i in range ( n ) :				      	for ( int i = 1 ;					      k ++ ) {							  rMax = maxSoFar = bw [ n - 1 ] = arr [ n - 1 ] ;
	cur_max = max ( arr [ i ] , cur_max + arr [ i ] )     	i < n ;							    	for ( int i = 0 ;					      ^~~~~~ MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEME
	max_so_far = max ( max_so_far , cur_max )	      	i ++ ) {						    	i < n ;							  NT.cpp:60:14: error: ‘maxSoFar’ was not declared i
	fw [ i ] = cur_max				      	  cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) ;	    	i ++ ) {						  n this scope	    curMax = maxSoFar = bw [ n - 1 ]
    cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ]	      	  max_so_far = max ( max_so_far , cur_max ) ;		    	  int curMax = arr [ 0 ] , maxSoFar = arr [ 0 ] ;	   = arr [ n - 1 ] ;		   ^~~~~~~~ MAXIMUM_
    i = n - 2						      	  fw [ i ] = cur_max ;					    	  for ( int i = 0 ;					  SUM_SUBARRAY_REMOVING_ONE_ELEMENT.cpp:60:25: error
    while i >= 0 :					      	}							    	  i < n ;						  : ‘bw’ was not declared in this scope	     curMax
	cur_max = max ( arr [ i ] , cur_max + arr [ i ] )     	cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ;	    	  i ++ ) {						  = maxSoFar = bw [ n - 1 ] = arr [ n - 1 ] ;
	max_so_far = max ( max_so_far , cur_max )	      	for ( int i = n - 2 ;					    	    curMax = max ( arr [ i ] , curMax + arr [ i ] ) ;	  		     ^~ MAXIMUM_SUM_SUBARRAY_REMOVIN
	bw [ i ] = cur_max				      	i >= 0 ;						    	    maxSoFar = max ( maxSoFar , curMax ) ;		  G_ONE_ELEMENT.cpp:60:25: note: suggested alternati
	i -= 1						      	i -- ) {						    	    fw [ i ] = curMax ;					  ve: ‘fw’	curMax = maxSoFar = bw [ n - 1 ] = a
    fans = max_so_far					      	  cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) ;	    	  }							  rr [ n - 1 ] ;			  ^~
    for i in range ( 1 , n - 1 ) :			      	  max_so_far = max ( max_so_far , cur_max ) ;		    	}							  		    fw MAXIMUM_SUM_SUBARRAY_REMOVING
	fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )     	  bw [ i ] = cur_max ;					    	curMax = maxSoFar = bw [ n - 1 ] = arr [ n - 1 ] ;	  _ONE_ELEMENT.cpp:73:10: error: ‘fans’ was not decl
    return fans						      	}							    	int i = n - 2 ;						  ared in this scope	return fans ;		^~~~
							      	int fans = max_so_far ;					    	while ( i >= 0 ) {					   MAXIMUM_SUM_SUBARRAY_REMOVING_ONE_ELEMENT.cpp:73:
							      	for ( int i = 1 ;					    	  curMax = max ( arr [ i ] , curMax + arr [ i ] ) ;	  10: note: suggested alternative: ‘fabs’    return
							      	i < n - 1 ;						    	  maxSoFar = max ( maxSoFar , curMax ) ;		  fans ;	   ^~~~		  fabs
							      	i ++ ) fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ;  	  bw [ i ] = curMax ;					  
							      	return fans ;						    	  i -- ;						  
							      }								    	}							  
							      								    	int fans = maxSoFar ;					  
							      								    	for ( int i = 1 ;					  
							      								    	i < n - 1 ;						  
							      								    	i ++ ) fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] )  
							      								      }								  
							      								      return fans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_ MAXIMUM_SUM_INCREASING_SUBSEQUENCE_FROM_A_PREFIX_AND_A_GIVEN_
--							      --							    --								  --
def pre_compute ( a , n , index , k ) :			      ll pre_compute ( ll a [ ] , ll n , ll index , ll k ) {	    int preCompute ( int a [ ] , int n , int index , int k ) {	  script_not_found : None
    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]  	ll dp [ n ] [ n ] = {					      vector < vector < int >> dp ( n , vector < int > ( n , 0 )  
    for i in range ( n ) :				      	  0 }							      for ( int i = 0 ;						  
	if a [ i ] > a [ 0 ] :				      	  ;							      i < n ;							  
	    dp [ 0 ] [ i ] = a [ i ] + a [ 0 ]		      	  for ( int i = 0 ;					      i ++ ) {							  
	else :						      	  i < n ;						    	if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 
	    dp [ 0 ] [ i ] = a [ i ]			      	  i ++ ) {						    	else dp [ 0 ] [ i ] = a [ i ] ;				  
    for i in range ( 1 , n ) :				      	    if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [   }								  
	for j in range ( n ) :				      	    else dp [ 0 ] [ i ] = a [ i ] ;			      for ( int i = 1 ;						  
	    if a [ j ] > a [ i ] and j > i :		      	  }							      i < n ;							  
		if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1  	  for ( int i = 1 ;					      i ++ ) {							  
		    dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ 	  i < n ;						    	for ( int j = 0 ;					  
		else :					      	  i ++ ) {						    	j < n ;							  
		    dp [ i ] [ j ] = dp [ i - 1 ] [ j ]	      	    for ( int j = 0 ;					    	j ++ ) {						  
	    else :					      	    j < n ;						    	  if ( a [ j ] > a [ i ] && j > i ) {			  
		dp [ i ] [ j ] = dp [ i - 1 ] [ j ]	      	    j ++ ) {						    	    if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j  
    return dp [ index ] [ k ]				      	      if ( a [ j ] > a [ i ] && j > i ) {		    	    else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;		  
							      		if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [  	  }							  
							      		else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;	    	  else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;		  
							      	      }							    	}							  
							      	      else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ;	      }								  
							      	    }							      return dp [ index ] [ k ] ;				  
							      	  }							    }								  
							      	  return dp [ index ] [ k ] ;				    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_BITONIC_SUBARRAY				      MAXIMUM_SUM_BITONIC_SUBARRAY				    MAXIMUM_SUM_BITONIC_SUBARRAY				  MAXIMUM_SUM_BITONIC_SUBARRAY
--							      --							    --								  --
def maxSumBitonicSubArr ( arr , n ) :			      int maxSumBitonicSubArr ( int arr [ ] , int n ) {		    int maxSumBitonicSubArr ( int * arr , int n ) {		  success : None
    msis = [ None ] * n					      	int msis [ n ] , msds [ n ] ;				      int * msis = new int [ n ] ;				  
    msds = [ None ] * n					      	int max_sum = INT_MIN ;					      int * msds = new int [ n ] ;				  
    max_sum = 0						      	msis [ 0 ] = arr [ 0 ] ;				      int maxSum = 0 ;						  
    msis [ 0 ] = arr [ 0 ]				      	for ( int i = 1 ;					      msis [ 0 ] = arr [ 0 ] ;					  
    for i in range ( 1 , n ) :				      	i < n ;							      for ( int i = 1 ;						  
	if ( arr [ i ] > arr [ i - 1 ] ) :		      	i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [   i < n ;							  
	    msis [ i ] = msis [ i - 1 ] + arr [ i ]	      	else msis [ i ] = arr [ i ] ;				      i ++ ) {							  
	else :						      	msds [ n - 1 ] = arr [ n - 1 ] ;			    	if ( ( arr [ i ] > arr [ i - 1 ] ) ) msis [ i ] = msis [  
	    msis [ i ] = arr [ i ]			      	for ( int i = n - 2 ;					    	else msis [ i ] = arr [ i ] ;				  
    msds [ n - 1 ] = arr [ n - 1 ]			      	i >= 0 ;						      }								  
    for i in range ( n - 2 , - 1 , - 1 ) :		      	i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [   msds [ n - 1 ] = arr [ n - 1 ] ;				  
	if ( arr [ i ] > arr [ i + 1 ] ) :		      	else msds [ i ] = arr [ i ] ;				      for ( int i = n - 2 ;					  
	    msds [ i ] = msds [ i + 1 ] + arr [ i ]	      	for ( int i = 0 ;					      i >= 0 ;							  
	else :						      	i < n ;							      i -- ) {							  
	    msds [ i ] = arr [ i ]			      	i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] 	if ( ( arr [ i ] > arr [ i + 1 ] ) ) msds [ i ] = msds [  
    for i in range ( n ) :				      	return max_sum ;					    	else msds [ i ] = arr [ i ] ;				  
	if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ]  }								      }								  
	    max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) 								      for ( int i = 0 ;						  
    return max_sum					      								      i < n ;							  
							      								      i ++ ) {							  
							      								    	if ( ( maxSum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) 
							      								      }								  
							      								      delete [ ] msis ;						  
							      								      delete [ ] msds ;						  
							      								      return maxSum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B BALANCED_EXPRESSIONS_SUCH_THAT_GIVEN_POSITIONS_HAVE_OPENING_B
--							      --							    --								  --
def arrangeBraces ( n , pos , k ) :			      long long arrangeBraces ( int n , int pos [ ] , int k ) {	    int arrangeBraces ( int n , int * pos , int k ) {		  script_not_found : None
    h = [ False for i in range ( N ) ]			      	bool h [ N ] ;						      vector < vector < bool >> h ( N , vector < bool > ( N , fal 
    dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ]  	int dp [ N ] [ N ] ;					      vector < vector < int >> dp ( N , vector < int > ( N , 0 )  
    for i in range ( k ) :				      	memset ( h , 0 , sizeof h ) ;				      for ( int i = 0 ;						  
	h [ pos [ i ] ] = 1				      	memset ( dp , 0 , sizeof dp ) ;				      i < k ;							  
    dp [ 0 ] [ 0 ] = 1					      	for ( int i = 0 ;					      i ++ ) h [ pos [ i ] ] = 1 ;				  
    for i in range ( 1 , 2 * n + 1 ) :			      	i < k ;							      dp [ 0 ] [ 0 ] = 1 ;					  
	for j in range ( 2 * n + 1 ) :			      	i ++ ) h [ pos [ i ] ] = 1 ;				      for ( int i = 1 ;						  
	    if ( h [ i ] ) :				      	dp [ 0 ] [ 0 ] = 1 ;					      i < 2 * n + 1 ;						  
		if ( j != 0 ) :				      	for ( int i = 1 ;					      i ++ ) {							  
		    dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]   	i <= 2 * n ;						    	for ( int j = 0 ;					  
		else :					      	i ++ ) {						    	j < 2 * n + 1 ;						  
		    dp [ i ] [ j ] = 0			      	  for ( int j = 0 ;					    	j ++ ) {						  
	    else :					      	  j <= 2 * n ;						    	  if ( ( h [ i ] ) ) {					  
		if ( j != 0 ) :				      	  j ++ ) {						    	    if ( ( j != 0 ) ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 
		    dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] 	    if ( h [ i ] ) {					    	    else dp [ i ] [ j ] = 0 ;				  
		else :					      	      if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] 	  }							  
		    dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ]   	      else dp [ i ] [ j ] = 0 ;				    	  else {						  
    return dp [ 2 * n ] [ 0 ]				      	    }							    	    if ( ( j != 0 ) ) dp [ i ] [ j ] = ( dp [ i - 1 ] [ j 
							      	    else {						    	    else dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;	  
							      	      if ( j != 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] 	  }							  
							      	      else dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;	    	}							  
							      	    }							      }								  
							      	  }							      return dp [ 2 * n ] [ 0 ] ;				  
							      	}							    }								  
							      	return dp [ 2 * n ] [ 0 ] ;				    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE	      DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE	    DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE	  DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE
--							      --							    --								  --
def lbs ( arr ) :					      int lbs ( int arr [ ] , int n ) {				    int lbs ( int * arr ) {					  error : DYNAMIC_PROGRAMMING_SET_15_LONGEST_BITONIC
    n = len ( arr )					      	int i , j ;						      int n = sizeof ( arr ) / sizeof ( int ) ;			  _SUBSEQUENCE.cpp: In function ‘int main()’: DYNAMI
    lis = [ 1 for i in range ( n + 1 ) ]		      	int * lis = new int [ n ] ;				      int lis [ n + 1 ] ;					  C_PROGRAMMING_SET_15_LONGEST_BITONIC_SUBSEQUENCE.c
    for i in range ( 1 , n ) :				      	for ( i = 0 ;						      for ( int i = 1 ;						  pp:82:49: error: too many arguments to function ‘i
	for j in range ( 0 , i ) :			      	i < n ;							      i < n ;							  nt f_filled(int*)’	      if(f_filled(&param0[i]
	    if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] <  	i ++ ) lis [ i ] = 1 ;					      i ++ ) {							  .front(),param1[i]) == f_gold(&param0[i].front(),p
		lis [ i ] = lis [ j ] + 1		      	for ( i = 1 ;						    	for ( int j = 0 ;					  aram1[i]))
    lds = [ 1 for i in range ( n + 1 ) ]		      	i < n ;							    	j < i ;							  	    ^ DYNAMIC_PROGRAMMING_SET_15_LONGEST_BIT
    for i in reversed ( range ( n - 1 ) ) :		      	i ++ ) for ( j = 0 ;					    	j ++ ) {						  ONIC_SUBSEQUENCE.cpp:44:5: note: declared here  in
	for j in reversed ( range ( i - 1 , n ) ) :	      	j < i ;							    	  if ( ( ( arr [ i ] > arr [ j ] ) && ( lis [ i ] < lis [ t f_filled ( int * arr ) {	  ^~~~~~~~
	    if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [  	j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ]  	}							  
		lds [ i ] = lds [ j ] + 1		      	int * lds = new int [ n ] ;				      }								  
    maximum = lis [ 0 ] + lds [ 0 ] - 1			      	for ( i = 0 ;						      int lds [ n + 1 ] ;					  
    for i in range ( 1 , n ) :				      	i < n ;							      for ( int i = 0 ;						  
	maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maxim 	i ++ ) lds [ i ] = 1 ;					      i < n + 1 ;						  
    return maximum					      	for ( i = n - 2 ;					      i ++ ) {							  
							      	i >= 0 ;						    	for ( int j = i - 1 ;					  
							      	i -- ) for ( j = n - 1 ;				    	j < n ;							  
							      	j > i ;							    	j ++ ) {						  
							      	j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ]  	  if ( ( arr [ i ] > arr [ j ] ) && ( lds [ i ] < lds [ j 
							      	int max = lis [ 0 ] + lds [ 0 ] - 1 ;			    	}							  
							      	for ( i = 1 ;						      }								  
							      	i < n ;							      int maximum = lis [ 0 ] + lds [ 0 ] - 1 ;			  
							      	i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i   for ( int i = 1 ;						  
							      	return max ;						      i < n ;							  
							      }								      i ++ ) maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maxi 
							      								      return maximum ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT	      FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT	    FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT	  FIND_DISTINCT_INTEGERS_FOR_A_TRIPLET_WITH_GIVEN_PRODUCT
--							      --							    --								  --
def findTriplets ( x ) :				      void findTriplets ( int x ) {				    int findTriplets ( int x ) {				  script_not_found : None
    fact = [ ]						      	vector < int > fact ;					      vector < int > fact ;					  
    factors = set ( )					      	unordered_set < int > factors ;				      set < int > factors ;					  
    for i in range ( 2 , int ( sqrt ( x ) ) ) :		      	for ( int i = 2 ;					      for ( int i = 2 ;						  
	if ( x % i == 0 ) :				      	i <= sqrt ( x ) ;					      i < ( int ) sqrt ( x ) ;					  
	    fact.append ( i )				      	i ++ ) {						      i ++ ) {							  
	    if ( x / i != i ) :				      	  if ( x % i == 0 ) {					    	if ( ( x % i ) == 0 ) {					  
		fact.append ( x // i )			      	    fact . push_back ( i ) ;				    	  fact . push_back ( i ) ;				  
	    factors.add ( i )				      	    if ( x / i != i ) fact . push_back ( x / i ) ;	    	  if ( ( x / i ) != i ) fact . push_back ( x / i ) ;	  
	    factors.add ( x // i )			      	    factors . insert ( i ) ;				    	  factors . insert ( i ) ;				  
    found = False					      	    factors . insert ( x / i ) ;			    	  factors . insert ( x / i ) ;				  
    k = len ( fact )					      	  }							    	}							  
    for i in range ( k ) :				      	}							      }								  
	a = fact [ i ]					      	bool found = false ;					      bool found = false ;					  
	for j in range ( k ) :				      	int k = fact . size ( ) ;				      int k = fact . size ( ) ;					  
	    b = fact [ j ]				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    if ( ( a != b ) and ( x % ( a * b ) == 0 ) and (  	i < k ;							      i < k ;							  
		print ( a , b , x // ( a * b ) )	      	i ++ ) {						      i ++ ) {							  
		found = True				      	  int a = fact [ i ] ;					    	int a = fact [ i ] ;					  
		break					      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
	if ( found ) :					      	  j < k ;						    	j < k ;							  
	    break					      	  j ++ ) {						    	j ++ ) {						  
    if ( not found ) :					      	    int b = fact [ j ] ;				    	  int b = fact [ j ] ;					  
	print ( "-1" )					      	    if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a  	  if ( ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / (  
							      	      cout << a << " " << b << " " << ( x / ( a * b ) ) ;   	    cout << a << " " << b << " " << x / ( a * b ) ;	  
							      	      found = true ;					    	    found = true ;					  
							      	      break ;						    	    break ;						  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	  if ( found ) break ;					    	if ( ( found ) ) break ;				  
							      	}							      }								  
							      	if ( ! found ) cout << "-1" ;				      if ( ( ! found ) ) cout << "-1" ;				  
							      }								      return 0 ;						  
							      								      return x * x ;						  
							      								      return x * x ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS		      LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS		    LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS		  LCS_LONGEST_COMMON_SUBSEQUENCE_THREE_STRINGS
--							      --							    --								  --
def lcsOf3 ( X , Y , Z , m , n , o ) :			      int lcsOf3 ( string X , string Y , string Z , int m , int n , int lcsOf3 ( string X , string Y , string Z , int m , int n , script_not_found : None
    L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n 	int L [ m + 1 ] [ n + 1 ] [ o + 1 ] ;			      vector < vector < int >> L ( o + 1 , vector < int > ( n + 1 
    for i in range ( m + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	for j in range ( n + 1 ) :			      	i <= m ;						      i < m + 1 ;						  
	    for k in range ( o + 1 ) :			      	i ++ ) {						      i ++ ) {							  
		if ( i == 0 or j == 0 or k == 0 ) :	      	  for ( int j = 0 ;					    	for ( int j = 0 ;					  
		    L [ i ] [ j ] [ k ] = 0		      	  j <= n ;						    	j < n + 1 ;						  
		elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 	  j ++ ) {						    	j ++ ) {						  
		    L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 	    for ( int k = 0 ;					    	  for ( int k = 0 ;					  
		else :					      	    k <= o ;						    	  k < o + 1 ;						  
		    L [ i ] [ j ] [ k ] = max ( max ( L [ i - 	    k ++ ) {						    	  k ++ ) {						  
    return L [ m ] [ n ] [ o ]				      	      if ( i == 0 || j == 0 || k == 0 ) L [ i ] [ j ] [ k ] 	    if ( ( i == 0 || j == 0 || k == 0 ) ) L [ i ] [ j ] [ 
							      	      else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] = 	    else if ( ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] 
							      	      else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [  	    else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [  
							      	    }							    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      	return L [ m ] [ n ] [ o ] ;				    }								  
							      }								    return L [ m ] [ n ] [ o ] ;				  
							      								    return m * m ;						  
							      								    return m * m ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PREFIX_SUM_2D_ARRAY					      PREFIX_SUM_2D_ARRAY					    PREFIX_SUM_2D_ARRAY						  PREFIX_SUM_2D_ARRAY
--							      --							    --								  --
def prefixSum2D ( a ) :					      void prefixSum2D ( int a [ ] [ C ] ) {			    int prefixSum2D ( int a [ ] [ 2 ] ) {			  script_not_found : None
    global C , R					      	int psa [ R ] [ C ] ;					      int C = 0 , R = 0 ;					  
    psa = [ [ 0 for x in range ( C ) ] for y in range ( R ) ] 	psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ;			      int psa [ R ] [ C ] ;					  
    psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ]			      	for ( int i = 1 ;					      for ( int y = 0 ;						  
    for i in range ( 1 , C ) :				      	i < C ;							      y < R ;							  
	psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i 	i ++ ) psa [ 0 ] [ i ] = psa [ 0 ] [ i - 1 ] + a [ 0 ] [ i    y ++ ) {							  
    for i in range ( 0 , R ) :				      	for ( int i = 0 ;					    	psa [ 0 ] [ 0 ] = a [ 0 ] [ 0 ] ;			  
	psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ] [ 0 	i < R ;							    	for ( int i = 1 ;					  
    for i in range ( 1 , R ) :				      	i ++ ) psa [ i ] [ 0 ] = psa [ i - 1 ] [ 0 ] + a [ i ] [ 0  	i < C ;							  
	for j in range ( 1 , C ) :			      	for ( int i = 1 ;					    	i ++ ) psa [ 0 ] [ i ] = ( psa [ 0 ] [ i - 1 ] + a [ 0 ]  
	    psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i 	i < R ;							    	for ( int i = 0 ;					  
    for i in range ( 0 , R ) :				      	i ++ ) {						    	i < R ;							  
	for j in range ( 0 , C ) :			      	  for ( int j = 1 ;					    	i ++ ) psa [ i ] [ 0 ] = ( psa [ i - 1 ] [ 0 ] + a [ i ]  
	    print ( psa [ i ] [ j ] , end = " " )	      	  j < C ;						    	for ( int i = 1 ;					  
	print ( )					      	  j ++ ) psa [ i ] [ j ] = psa [ i - 1 ] [ j ] + psa [ i ]  	i < R ;							  
							      	}							    	i ++ ) for ( int j = 1 ;				  
							      	for ( int i = 0 ;					    	j < C ;							  
							      	i < R ;							    	j ++ ) psa [ i ] [ j ] = ( psa [ i - 1 ] [ j ] + psa [ i  
							      	i ++ ) {						      }								  
							      	  for ( int j = 0 ;					      for ( int i = 0 ;						  
							      	  j < C ;						      i < R ;							  
							      	  j ++ ) cout << psa [ i ] [ j ] << " " ;		      i ++ ) for ( int j = 0 ;					  
							      	  cout << "\n" ;					      j < C ;							  
							      	}							      j ++ ) cout << psa [ i ] [ j ] << " " ;			  
							      }								      cout << endl ;						  
							      								      return a [ 0 ] [ 0 ] ;					  
							      								      return a [ 1 ] [ 0 ] ;					  
							      								      return a [ 2 ] [ 0 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA LENGTH_OF_THE_LONGEST_ARITHMATIC_PROGRESSION_IN_A_SORTED_ARRA
--							      --							    --								  --
def lenghtOfLongestAP ( set , n ) :			      int lenghtOfLongestAP ( int set [ ] , int n ) {		    int lenghtOfLongestAP ( int * set , int n ) {		  failure : #Results: 8, 10
    if ( n <= 2 ) :					      	if ( n <= 2 ) return n ;				      if ( ( n <= 2 ) ) return n ;				  
	return n					      	int L [ n ] [ n ] ;					      vector < vector < int >> L ( n , vector < int > ( n , 0 ) ) 
    L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]   	int llap = 2 ;						      int llap = 2 ;						  
    llap = 2						      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( n ) :				      	i < n ;							      i < n ;							  
	L [ i ] [ n - 1 ] = 2				      	i ++ ) L [ i ] [ n - 1 ] = 2 ;				      i ++ ) L [ i ] [ n - 1 ] = 2 ;				  
    for j in range ( n - 2 , 0 , - 1 ) :		      	for ( int j = n - 2 ;					      for ( int j = n - 2 ;					  
	i = j - 1					      	j >= 1 ;						      j > 0 ;							  
	k = j + 1					      	j -- ) {						      j -- ) {							  
	while ( i >= 0 and k <= n - 1 ) :		      	  int i = j - 1 , k = j + 1 ;				    	int i = j - 1 ;						  
	    if ( set [ i ] + set [ k ] < 2 * set [ j ] ) :    	  while ( i >= 0 && k <= n - 1 ) {			    	int k = j + 1 ;						  
		k += 1					      	    if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ;	    	while ( ( i >= 0 ) && ( k <= n - 1 ) ) {		  
	    elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) :  	    else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) {	    	  if ( ( set [ i ] + set [ k ] < 2 * set [ j ] ) ) k ++ ; 
		L [ i ] [ j ] = 2			      	      L [ i ] [ j ] = 2 , i -- ;			    	  else if ( ( set [ i ] + set [ k ] > 2 * set [ j ] ) ) { 
		i -= 1					      	    }							    	    L [ i ] [ j ] = 2 ;					  
	    else :					      	    else {						    	    i -- ;						  
		L [ i ] [ j ] = L [ j ] [ k ] + 1	      	      L [ i ] [ j ] = L [ j ] [ k ] + 1 ;		    	  }							  
		llap = max ( llap , L [ i ] [ j ] )	      	      llap = max ( llap , L [ i ] [ j ] ) ;		    	  else {						  
		i -= 1					      	      i -- ;						    	    L [ i ] [ j ] = L [ j ] [ k ] + 1 ;			  
		k += 1					      	      k ++ ;						    	    llap = max ( llap , L [ i ] [ j ] ) ;		  
		while ( i >= 0 ) :			      	    }							    	    i -- ;						  
		    L [ i ] [ j ] = 2			      	  }							    	    k ++ ;						  
		    i -= 1				      	  while ( i >= 0 ) {					    	    while ( ( i >= 0 ) ) {				  
    return llap						      	    L [ i ] [ j ] = 2 ;					    	      L [ i ] [ j ] = 2 ;				  
							      	    i -- ;						    	      i -- ;						  
							      	  }							    	    }							  
							      	}							    	  }							  
							      	return llap ;						    	}							  
							      }								      }								  
							      								      return llap ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X	      CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X	    CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X	  CREATE_A_MATRIX_WITH_ALTERNATING_RECTANGLES_OF_0_AND_X
--							      --							    --								  --
def fill0X ( m , n ) :					      void fill0X ( int m , int n ) {				    int fill0X ( int m , int n ) {				  script_not_found : None
    i , k , l = 0 , 0 , 0				      	int i , k = 0 , l = 0 ;					      int i , k , l ;						  
    r = m						      	int r = m , c = n ;					      int r = m ;						  
    c = n						      	char a [ m ] [ n ] ;					      int c = n ;						  
    a = [ [ None ] * n for i in range ( m ) ]		      	char x = 'X' ;						      vector < vector < int >> a ( m , vector < int > ( n , 0 ) ) 
    x = 'X'						      	while ( k < m && l < n ) {				      char x = 'X' ;						  
    while k < m and l < n :				      	  for ( i = l ;						      while ( k < m && l < n ) {				  
	for i in range ( l , n ) :			      	  i < n ;						    	for ( i = l ;						  
	    a [ k ] [ i ] = x				      	  ++ i ) a [ k ] [ i ] = x ;				    	i < n ;							  
	k += 1						      	  k ++ ;						    	i ++ ) a [ k ] [ i ] = x ;				  
	for i in range ( k , m ) :			      	  for ( i = k ;						    	k ++ ;							  
	    a [ i ] [ n - 1 ] = x			      	  i < m ;						    	for ( i = k ;						  
	n -= 1						      	  ++ i ) a [ i ] [ n - 1 ] = x ;			    	i < m ;							  
	if k < m :					      	  n -- ;						    	i ++ ) a [ i ] [ n - 1 ] = x ;				  
	    for i in range ( n - 1 , l - 1 , - 1 ) :	      	  if ( k < m ) {					    	n -- ;							  
		a [ m - 1 ] [ i ] = x			      	    for ( i = n - 1 ;					    	if ( k < m ) {						  
	    m -= 1					      	    i >= l ;						    	  for ( i = n - 1 ;					  
	if l < n :					      	    -- i ) a [ m - 1 ] [ i ] = x ;			    	  i >= l - 1 ;						  
	    for i in range ( m - 1 , k - 1 , - 1 ) :	      	    m -- ;						    	  i -- ) a [ m - 1 ] [ i ] = x ;			  
		a [ i ] [ l ] = x			      	  }							    	  m -- ;						  
	    l += 1					      	  if ( l < n ) {					    	}							  
	x = 'X' if x == '0' else '0'			      	    for ( i = m - 1 ;					    	if ( l < n ) {						  
    for i in range ( r ) :				      	    i >= k ;						    	  for ( i = m - 1 ;					  
	for j in range ( c ) :				      	    -- i ) a [ i ] [ l ] = x ;				    	  i >= k - 1 ;						  
	    print ( a [ i ] [ j ] , end = " " )		      	    l ++ ;						    	  i -- ) a [ i ] [ l ] = x ;				  
	print ( )					      	  }							    	  l ++ ;						  
							      	  x = ( x == '0' ) ? 'X' : '0' ;			    	}							  
							      	}							    	x = x == '0' ? '0' : x ;				  
							      	for ( i = 0 ;						      }								  
							      	i < r ;							      for ( i = 0 ;						  
							      	i ++ ) {						      i < r ;							  
							      	  for ( int j = 0 ;					      i ++ ) {							  
							      	  j < c ;						    	for ( int j = 0 ;					  
							      	  j ++ ) printf ( "%c " , a [ i ] [ j ] ) ;		    	j < c ;							  
							      	  printf ( "\n" ) ;					    	j ++ ) cout << a [ i ] [ j ] << " " ;			  
							      	}							    	cout << endl ;						  
							      }								      }								  
							      								      return 0 ;						  
							      								      return m * m ;						  
							      								      return m * m * m * m * m * m * m * m * m * m * m * m * m *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM	      SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM		    SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM		  SPACE_OPTIMIZED_DP_SOLUTION_0_1_KNAPSACK_PROBLEM
--							      --							    --								  --
def KnapSack ( val , wt , n , W ) :			      int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) {   int KnapSack ( int * val , int * wt , int n , int W ) {	  error : /bin/bash: line 1: 1848288 Segmentation fa
    mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 	int mat [ 2 ] [ W + 1 ] ;				      int * * mat = new int * [ W + 1 ] ;			  ult	   (core dumped) ./SPACE_OPTIMIZED_DP_SOLUTI
    i = 0						      	memset ( mat , 0 , sizeof ( mat ) ) ;			      for ( int i = 0 ;						  ON_0_1_KNAPSACK_PROBLEM_cpp
    while i < n :					      	int i = 0 ;						      i < 2 ;							  
	j = 0						      	while ( i < n ) {					      i ++ ) {							  
	if i % 2 == 0 :					      	  int j = 0 ;						    	for ( int j = 0 ;					  
	    while j < W :				      	  if ( i % 2 != 0 ) {					    	j < W ;							  
		j += 1					      	    while ( ++ j <= W ) {				    	j ++ ) {						  
		if wt [ i ] <= j :			      	      if ( wt [ i ] <= j ) mat [ 1 ] [ j ] = max ( val [ i  	  mat [ 1 ] [ j ] = 0 ;					  
		    mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 	      else mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ;		    	}							  
		else :					      	    }							      }								  
		    mat [ 1 ] [ j ] = mat [ 0 ] [ j ]	      	  }							      int i = 0 ;						  
	else :						      	  else {						      while ( i < n ) {						  
	    while j < W :				      	    while ( ++ j <= W ) {				    	int j = 0 ;						  
		j += 1					      	      if ( wt [ i ] <= j ) mat [ 0 ] [ j ] = max ( val [ i  	if ( i % 2 == 0 ) {					  
		if wt [ i ] <= j :			      	      else mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ;		    	  while ( j < W ) {					  
		    mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 	    }							    	    j ++ ;						  
		else :					      	  }							    	    if ( wt [ i ] <= j ) mat [ 1 ] [ j ] = max ( val [ i  
		    mat [ 0 ] [ j ] = mat [ 1 ] [ j ]	      	  i ++ ;						    	    else mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ;		  
	i += 1						      	}							    	  }							  
    if n % 2 == 0 :					      	return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; 	}							  
	return mat [ 0 ] [ W ]				      }								    	else {							  
    else :						      								    	  while ( j < W ) {					  
	return mat [ 1 ] [ W ]				      								    	    j ++ ;						  
							      								    	    if ( wt [ i ] <= j ) mat [ 0 ] [ j ] = max ( val [ i  
							      								    	    else mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ;		  
							      								    	  }							  
							      								    	}							  
							      								    	i ++ ;							  
							      								      }								  
							      								      if ( n % 2 == 0 ) return mat [ 0 ] [ W ] ;		  
							      								      else return mat [ 1 ] [ W ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINTING_ITEMS_01_KNAPSACK				      PRINTING_ITEMS_01_KNAPSACK				    PRINTING_ITEMS_01_KNAPSACK					  PRINTING_ITEMS_01_KNAPSACK
--							      --							    --								  --
def printknapSack ( W , wt , val , n ) :		      void printknapSack ( int W , int wt [ ] , int val [ ] , int n int printknapSack ( int W , int * wt , int * val , int n ) {  script_not_found : None
    K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 	int i , w ;						      vector < vector < int >> K ( W + 1 , vector < int > ( n + 1 
    for i in range ( n + 1 ) :				      	int K [ n + 1 ] [ W + 1 ] ;				      for ( int i = 0 ;						  
	for w in range ( W + 1 ) :			      	for ( i = 0 ;						      i < n + 1 ;						  
	    if i == 0 or w == 0 :			      	i <= n ;						      i ++ ) {							  
		K [ i ] [ w ] = 0			      	i ++ ) {						    	for ( int w = 0 ;					  
	    elif wt [ i - 1 ] <= w :			      	  for ( w = 0 ;						    	w < W + 1 ;						  
		K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 	  w <= W ;						    	w ++ ) {						  
	    else :					      	  w ++ ) {						    	  if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;		  
		K [ i ] [ w ] = K [ i - 1 ] [ w ]	      	    if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ;		    	  else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 
    res = K [ n ] [ W ]					      	    else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val 	  else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		  
    print ( res )					      	    else K [ i ] [ w ] = K [ i - 1 ] [ w ] ;		    	}							  
    w = W						      	  }							    	int res = K [ n ] [ W ] ;				  
    for i in range ( n , 0 , - 1 ) :			      	}							    	cout << res << endl ;					  
	if res <= 0 :					      	int res = K [ n ] [ W ] ;				    	w = W ;							  
	    break					      	printf ( "%d\n" , res ) ;				    	for ( int i = n ;					  
	if res == K [ i - 1 ] [ w ] :			      	w = W ;							    	i > 0 ;							  
	    continue					      	for ( i = n ;						    	i -- ) {						  
	else :						      	i > 0 && res > 0 ;					    	  if ( res <= 0 ) break ;				  
	    print ( wt [ i - 1 ] )			      	i -- ) {						    	  if ( res == K [ i - 1 ] [ w ] ) continue ;		  
	    res = res - val [ i - 1 ]			      	  if ( res == K [ i - 1 ] [ w ] ) continue ;		    	  else {						  
	    w = w - wt [ i - 1 ]			      	  else {						    	    cout << wt [ i - 1 ] << endl ;			  
							      	    printf ( "%d " , wt [ i - 1 ] ) ;			    	    res = res - val [ i - 1 ] ;				  
							      	    res = res - val [ i - 1 ] ;				    	    w = w - wt [ i - 1 ] ;				  
							      	    w = w - wt [ i - 1 ] ;				    	  }							  
							      	  }							    	}							  
							      	}							      }								  
							      }								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1     GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1	    GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1	  GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1
--							      --							    --								  --
def isSubSeqDivisible ( str ) :				      bool isSubSeqDivisible ( string str ) {			    bool isSubSeqDivisible ( string str ) {			  error : GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGIT
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  S_DIVISIBLE_8_1.cpp: In function ‘bool f_filled(st
    dp = [ [ 0 for i in range ( 10 ) ] for i in range ( n + 1 	int dp [ n + 1 ] [ 10 ] ;				      vector < vector < int >> dp ( 10 , vector < int > ( n + 1 , d::__cxx11::string)’: GIVEN_LARGE_NUMBER_CHECK_SUB
    arr = [ 0 for i in range ( n + 1 ) ]		      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int i = 0 ;						  SEQUENCE_DIGITS_DIVISIBLE_8_1.cpp:57:47: error: re
    for i in range ( 1 , n + 1 ) :			      	int arr [ n + 1 ] ;					      i < n + 1 ;						  quest for member ‘c_str’ in ‘str.std::__cxx11::bas
	arr [ i ] = int ( str [ i - 1 ] )		      	for ( int i = 1 ;					      i ++ ) {							  ic_string<char>::operator[](((std::__cxx11::basic_
    for i in range ( 1 , n + 1 ) :			      	i <= n ;						    	dp [ i ] . reserve ( 10 ) ;				  string<char>::size_type)(i - 1)))’, which is of no
	dp [ i ] [ arr [ i ] % 8 ] = 1			      	i ++ ) arr [ i ] = str [ i - 1 ] - '0' ;		    	for ( int j = 0 ;					  n-class type ‘__gnu_cxx::__alloc_traits<std::alloc
	for j in range ( 8 ) :				      	for ( int i = 1 ;					    	j < 10 ;						  ator<char>, char>::value_type’ {aka ‘char’}	   i
	    if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + a 	i <= n ;						    	j ++ ) dp [ i ] . push_back ( 0 ) ;			   ++ ) arr [ i ] = atoi ( str [ i - 1 ] . c_str ( )
		dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp  	i ++ ) {						    	int arr [ n + 1 ] ;					   ) ;
	    if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) :      	  dp [ i ] [ arr [ i ] % 8 ] = 1 ;			    	for ( int i = 1 ;					    ^~~~~ GIVEN_LARGE_NUMBER_CHECK_SUBSEQUENCE_DIGIT
		dp [ i ] [ j ] = dp [ i - 1 ] [ j ]	      	  for ( int j = 0 ;					    	i <= n ;						  S_DIVISIBLE_8_1.cpp:80:12: error: a function-defin
    for i in range ( 1 , n + 1 ) :			      	  j < 8 ;						    	i ++ ) arr [ i ] = atoi ( str [ i - 1 ] . c_str ( ) ) ;	  ition is not allowed here before ‘{’ token  int ma
	if ( dp [ i ] [ 0 ] == 1 ) :			      	  j ++ ) {						    	for ( int i = 1 ;					  in() {	     ^ GIVEN_LARGE_NUMBER_CHECK_SUBS
	    return True					      	    if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i 	i <= n ;						  EQUENCE_DIGITS_DIVISIBLE_8_1.cpp:92:1: error: expe
    return False					      	    if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j 	i ++ ) {						  cted ‘}’ at end of input  }  ^ GIVEN_LARGE_NUMBER_
							      	  }							    	  dp [ i ] [ arr [ i ] % 8 ] = 1 ;			  CHECK_SUBSEQUENCE_DIGITS_DIVISIBLE_8_1.cpp:44:30:
							      	}							    	  for ( int j = 0 ;					  note: to match this ‘{’  bool f_filled ( string st
							      	for ( int i = 1 ;					    	  j < 8 ;						  r ) {				      ^
							      	i <= n ;						    	  j ++ ) {						  
							      	i ++ ) {						    	    if ( ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr 
							      	  if ( dp [ i ] [ 0 ] == 1 ) return true ;		    	    if ( ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) ) dp [ i 
							      	}							    	  }							  
							      	return false ;						    	}							  
							      }								      }								  
							      								      for ( int i = 1 ;						  
							      								      i <= n ;							  
							      								      i ++ ) if ( ( dp [ i ] [ 0 ] == 1 ) ) return true ;	  
							      								      return false ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SORT_ARRAY_APPLYING_GIVEN_EQUATION			      SORT_ARRAY_APPLYING_GIVEN_EQUATION			    SORT_ARRAY_APPLYING_GIVEN_EQUATION				  SORT_ARRAY_APPLYING_GIVEN_EQUATION
--							      --							    --								  --
def sortArray ( arr , n , A , B , C ) :			      void sortArray ( int arr [ ] , int n , int A , int B , int C  int sortArray ( int * arr , int n , int A , int B , int C ) { failure : #Results: 5, 10
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [ i 	i < n ;							      i < n ;							  
    index = - ( sys.maxsize - 1 )			      	i ++ ) arr [ i ] = A * arr [ i ] * arr [ i ] + B * arr [ i    i ++ ) arr [ i ] = ( A * arr [ i ] * arr [ i ] + B * arr [  
    maximum = - ( sys.maxsize - 1 )			      	int index , maximum = INT_MIN ;				      int index = - ( INT_MAX - 1 ) ;				  
    for i in range ( n ) :				      	for ( int i = 0 ;					      int maximum = - ( INT_MAX - 1 ) ;				  
	if maximum < arr [ i ] :			      	i < n ;							      for ( int i = 0 ;						  
	    index = i					      	i ++ ) {						      i < n ;							  
	    maximum = arr [ i ]				      	  if ( maximum < arr [ i ] ) {				      i ++ ) {							  
    i = 0 j = n - 1					      	    index = i ;						    	if ( maximum < arr [ i ] ) {				  
    new_arr = [ 0 ] * n					      	    maximum = arr [ i ] ;				    	  index = i ;						  
    k = 0						      	  }							    	  maximum = arr [ i ] ;					  
    while i < index and j > index :			      	}							    	}							  
	if arr [ i ] < arr [ j ] :			      	int i = 0 , j = n - 1 ;					      }								  
	    new_arr [ k ] = arr [ i ]			      	int new_arr [ n ] , k = 0 ;				      int i = 0 ;						  
	    k += 1					      	while ( i < index && j > index ) {			      int j = n - 1 ;						  
	    i += 1					      	  if ( arr [ i ] < arr [ j ] ) new_arr [ k ++ ] = arr [ i +   int newArr [ n ] ;					  
	else :						      	  else new_arr [ k ++ ] = arr [ j -- ] ;		      int k = 0 ;						  
	    new_arr [ k ] = arr [ j ]			      	}							      while ( i < index && j > index ) {			  
	    k += 1					      	while ( i < index ) new_arr [ k ++ ] = arr [ i ++ ] ;	    	if ( arr [ i ] < arr [ j ] ) {				  
	    j -= 1					      	while ( j > index ) new_arr [ k ++ ] = arr [ j -- ] ;	    	  newArr [ k ] = arr [ i ] ;				  
    while i < index :					      	new_arr [ n - 1 ] = maximum ;				    	  k ++ ;						  
	new_arr [ k ] = arr [ i ]			      	for ( int i = 0 ;					    	  i ++ ;						  
	k += 1						      	i < n ;							    	}							  
	i += 1						      	i ++ ) arr [ i ] = new_arr [ i ] ;			    	else {							  
    while j > index :					      }								    	  newArr [ k ] = arr [ j ] ;				  
	new_arr [ k ] = arr [ j ]			      								    	  k ++ ;						  
	k += 1						      								    	  j -- ;						  
	j -= 1						      								    	}							  
	new_arr [ n - 1 ] = maximum			      								      }								  
    for i in range ( n ) :				      								      while ( i < index ) {					  
	arr [ i ] = new_arr [ i ]			      								    	newArr [ k ] = arr [ i ] ;				  
							      								    	k ++ ;							  
							      								    	i ++ ;							  
							      								      }								  
							      								      while ( j > index ) {					  
							      								    	newArr [ k ] = arr [ j ] ;				  
							      								    	k ++ ;							  
							      								    	j -- ;							  
							      								    	newArr [ n - 1 ] = maximum ;				  
							      								      }								  
							      								      for ( int i = 0 ;						  
							      								      i < n ;							  
							      								      i ++ ) arr [ i ] = newArr [ i ] ;				  
							      								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAGIC_SQUARE						      MAGIC_SQUARE						    MAGIC_SQUARE						  MAGIC_SQUARE
--							      --							    --								  --
def generateSquare ( n ) :				      void generateSquare ( int n ) {				    int generateSquare ( int n ) {				  script_not_found : None
    magicSquare = [ [ 0 for x in range ( n ) ] for y in range 	int magicSquare [ n ] [ n ] ;				      vector < vector < int >> magicSquare ( n , vector < int > ( 
    i = n / 2						      	memset ( magicSquare , 0 , sizeof ( magicSquare ) ) ;	      for ( int y = 0 ;						  
    j = n - 1						      	int i = n / 2 ;						      y < n ;							  
    num = 1						      	int j = n - 1 ;						      y ++ ) {							  
    while num <= ( n * n ) :				      	for ( int num = 1 ;					    	int i = n / 2 ;						  
	if i == - 1 and j == n :			      	num <= n * n ;						    	int j = n - 1 ;						  
	    j = n - 2					      	) {							    	int num = 1 ;						  
	    i = 0					      	  if ( i == - 1 && j == n ) {				    	while ( num <= ( n * n ) ) {				  
	else :						      	    j = n - 2 ;						    	  if ( i == - 1 && j == n ) {				  
	    if j == n :					      	    i = 0 ;						    	    j = n - 2 ;						  
		j = 0					      	  }							    	    i = 0 ;						  
	    if i < 0 :					      	  else {						    	  }							  
		i = n - 1				      	    if ( j == n ) j = 0 ;				    	  else {						  
	if magicSquare [ int ( i ) ] [ int ( j ) ] :	      	    if ( i < 0 ) i = n - 1 ;				    	    if ( j == n ) j = 0 ;				  
	    j = j - 2					      	  }							    	    if ( i < 0 ) i = n - 1 ;				  
	    i = i + 1					      	  if ( magicSquare [ i ] [ j ] ) {			    	  }							  
	    continue					      	    j -= 2 ;						    	  if ( magicSquare [ int ( i ) ] [ int ( j ) ] ) {	  
	else :						      	    i ++ ;						    	    j = j - 2 ;						  
	    magicSquare [ int ( i ) ] [ int ( j ) ] = num     	    continue ;						    	    i = i + 1 ;						  
	    num = num + 1				      	  }							    	    continue ;						  
	j = j + 1					      	  else magicSquare [ i ] [ j ] = num ++ ;		    	  }							  
	i = i - 1					      	  j ++ ;						    	  else {						  
    print ( "Magic Squre for n =" , n )			      	  i -- ;						    	    magicSquare [ int ( i ) ] [ int ( j ) ] = num ;	  
    print ( "Sum of each row or column" , n * ( n * n + 1 ) / 	}							    	    num = num + 1 ;					  
    for i in range ( 0 , n ) :				      	cout << "The Magic Square for n=" << n << ":\nSum of " "eac 	  }							  
	for j in range ( 0 , n ) :			      	for ( i = 0 ;						    	  j = j + 1 ;						  
	    print ( '%2d ' % ( magicSquare [ i ] [ j ] ) , en 	i < n ;							    	  i = i - 1 ;						  
	    if j == n - 1 :				      	i ++ ) {						    	}							  
		print ( )				      	  for ( j = 0 ;						    	cout << "Magic Squre for n =" << n << endl ;		  
							      	  j < n ;						    	cout << "Sum of each row or column" << n * ( n * n + 1 )  
							      	  j ++ ) cout << magicSquare [ i ] [ j ] << " " ;	    	for ( int i = 0 ;					  
							      	  cout << endl ;					    	i <= n ;						  
							      	}							    	i ++ ) {						  
							      }								    	  for ( int j = 0 ;					  
							      								    	  j <= n ;						  
							      								    	  j ++ ) {						  
							      								    	    cout << ( magicSquare [ i ] [ j ] ) << " " ;	  
							      								    	    if ( j == n - 1 ) cout << endl ;			  
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM MINIMUM_SUM_SUBSEQUENCE_LEAST_ONE_EVERY_FOUR_CONSECUTIVE_ELEM
--							      --							    --								  --
def minSum ( arr , n ) :				      int minSum ( int arr [ ] , int n ) {			    int minSum ( int * arr , int n ) {				  success : None
    dp = [ 0 ] * n					      	int dp [ n ] ;						      int dp [ n ] ;						  
    if ( n == 1 ) :					      	if ( n == 1 ) return arr [ 0 ] ;			      if ( ( n == 1 ) ) return arr [ 0 ] ;			  
	return arr [ 0 ]				      	if ( n == 2 ) return min ( arr [ 0 ] , arr [ 1 ] ) ;	      if ( ( n == 2 ) ) return min ( arr [ 0 ] , arr [ 1 ] ) ;	  
    if ( n == 2 ) :					      	if ( n == 3 ) return min ( arr [ 0 ] , min ( arr [ 1 ] , ar   if ( ( n == 3 ) ) return min ( arr [ 0 ] , min ( arr [ 1 ]  
	return min ( arr [ 0 ] , arr [ 1 ] )		      	if ( n == 4 ) return min ( min ( arr [ 0 ] , arr [ 1 ] ) ,    if ( ( n == 4 ) ) return min ( min ( arr [ 0 ] , arr [ 1 ]  
    if ( n == 3 ) :					      	dp [ 0 ] = arr [ 0 ] ;					      dp [ 0 ] = arr [ 0 ] ;					  
	return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ]  	dp [ 1 ] = arr [ 1 ] ;					      dp [ 1 ] = arr [ 1 ] ;					  
    if ( n == 4 ) :					      	dp [ 2 ] = arr [ 2 ] ;					      dp [ 2 ] = arr [ 2 ] ;					  
	return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( ar 	dp [ 3 ] = arr [ 3 ] ;					      dp [ 3 ] = arr [ 3 ] ;					  
    dp [ 0 ] = arr [ 0 ]				      	for ( int i = 4 ;					      for ( int i = 4 ;						  
    dp [ 1 ] = arr [ 1 ]				      	i < n ;							      i < n ;							  
    dp [ 2 ] = arr [ 2 ]				      	i ++ ) dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp   i ++ ) dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp 
    dp [ 3 ] = arr [ 3 ]				      	return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp   return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp 
    for i in range ( 4 , n ) :				      }								    }								  
	dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp  								    								  
    return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min (  								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS	      WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS	    WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS		  WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTERS
--							      --							    --								  --
def countTransformation ( a , b ) :			      int countTransformation ( string a , string b ) {		    int countTransformation ( string a , string b ) {		  error : WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CH
    n = len ( a )					      	int n = a . size ( ) , m = b . size ( ) ;		      int n = a . length ( ) ;					  ARACTERS.cpp:68:1: error: expected unqualified-id
    m = len ( b )					      	if ( m == 0 ) return 1 ;				      int m = b . length ( ) ;					  before ‘return’  return dp [ m - 1 ] [ n - 1 ] ;
    if m == 0 :						      	int dp [ m + 1 ] [ n + 1 ] ;				      if ( m == 0 ) return 1 ;					  ^~~~~~ WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHA
	return 1					      	memset ( dp , 0 , sizeof ( dp ) ) ;			      vector < vector < int >> dp ( m + 1 , vector < int > ( m +  RACTERS.cpp:69:1: error: expected unqualified-id b
    dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ]	      	for ( int i = 0 ;					      for ( int i = 0 ;						  efore ‘return’  return n * n ;  ^~~~~~ WAYS_TRANSF
    for i in range ( m ) :				      	i < m ;							      i < m ;							  ORMING_ONE_STRING_REMOVING_0_CHARACTERS.cpp:70:1:
	for j in range ( i , n ) :			      	i ++ ) {						      i ++ ) {							  error: expected unqualified-id before ‘return’  re
	    if i == 0 :					      	  for ( int j = i ;					    	for ( int j = i ;					  turn n * n ;	^~~~~~ WAYS_TRANSFORMING_ONE_STRING_
		if j == 0 :				      	  j < n ;						    	j < n ;							  REMOVING_0_CHARACTERS.cpp:71:1: error: expected un
		    if a [ j ] == b [ i ] :		      	  j ++ ) {						    	j ++ ) {						  qualified-id before ‘return’	return n * n * n * n
			dp [ i ] [ j ] = 1		      	    if ( i == 0 ) {					    	  if ( i == 0 ) {					   * n * n * n * n * n * n * n * n * n * n * n * n *
		    else :				      	      if ( j == 0 ) dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) 	    if ( j == 0 ) {					   n * n * n * n * n * n * n * n * n * n * n * n * n
			dp [ i ] [ j ] = 0		      	      else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [  	      if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = 1 ;	   * n * n * n * n * n * n * n * n * n * n * n * n *
		elif a [ j ] == b [ i ] :		      	      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;	    	      else dp [ i ] [ j ] = 0 ;				   n * n * n * n * n * n * n * n * n * n * n * n * n
		    dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1   	    }							    	    }							   * n * n * n * n * n * n * n * n * n * n * n * n *
		else :					      	    else {						    	    else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [   n * n * n * n * n * n * n * n * n * n * n * n * n
		    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]	      	      if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ 	    else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		   * n * n * n * n * n * n * n * n * n * n * n * n *
	    else :					      	      else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;	    	  }							   n * n * n * n * n * n * n * n * n * n * n * n * n
		if a [ j ] == b [ i ] :			      	    }							    	  else {						   * n * n * n * n * n * n * n ;  ^~~~~~ WAYS_TRANSF
		    dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + d 	  }							    	    if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = ( dp [ i ] ORMING_ONE_STRING_REMOVING_0_CHARACTERS.cpp:72:1:
		else :					      	}							    	    else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ;		  error: expected declaration before ‘}’ token	}  ^
		    dp [ i ] [ j ] = dp [ i ] [ j - 1 ]	      	return dp [ m - 1 ] [ n - 1 ] ;				    	  }							   WAYS_TRANSFORMING_ONE_STRING_REMOVING_0_CHARACTER
    return dp [ m - 1 ] [ n - 1 ]			      }								    	}							  S.cpp: In function ‘int f_filled(std::__cxx11::str
							      								      }								  ing, std::__cxx11::string)’: WAYS_TRANSFORMING_ONE
							      								    }								  _STRING_REMOVING_0_CHARACTERS.cpp:67:1: warning: c
							      								    return dp [ m - 1 ] [ n - 1 ] ;				  ontrol reaches end of non-void function [-Wreturn-
							      								    return n * n ;						  type]	 }  ^
							      								    return n * n ;						  
							      								    return n * n * n * n * n * n * n * n * n * n * n * n * n * n  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS	      FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS		    FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS		  FIND_MAXIMUM_SUM_POSSIBLE_EQUAL_SUM_THREE_STACKS
--							      --							    --								  --
def maxSum ( stack1 , stack2 , stack3 , n1 , n2 , n3 ) :      int maxSum ( int stack1 [ ] , int stack2 [ ] , int stack3 [ ] int maxSum ( int * stack1 , int * stack2 , int * stack3 , int success : None
    sum1 , sum2 , sum3 = 0 , 0 , 0			      	int sum1 = 0 , sum2 = 0 , sum3 = 0 ;			      int sum1 = 0 , sum2 = 0 , sum3 = 0 ;			  
    for i in range ( n1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	sum1 += stack1 [ i ]				      	i < n1 ;						      i < n1 ;							  
    for i in range ( n2 ) :				      	i ++ ) sum1 += stack1 [ i ] ;				      i ++ ) sum1 += stack1 [ i ] ;				  
	sum2 += stack2 [ i ]				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    for i in range ( n3 ) :				      	i < n2 ;						      i < n2 ;							  
	sum3 += stack3 [ i ]				      	i ++ ) sum2 += stack2 [ i ] ;				      i ++ ) sum2 += stack2 [ i ] ;				  
    top1 , top2 , top3 = 0 , 0 , 0			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
    ans = 0						      	i < n3 ;						      i < n3 ;							  
    while ( 1 ) :					      	i ++ ) sum3 += stack3 [ i ] ;				      i ++ ) sum3 += stack3 [ i ] ;				  
	if ( top1 == n1 or top2 == n2 or top3 == n3 ) :	      	int top1 = 0 , top2 = 0 , top3 = 0 ;			      int top1 = 0 , top2 = 0 , top3 = 0 ;			  
	    return 0					      	int ans = 0 ;						      int ans = 0 ;						  
	if ( sum1 == sum2 and sum2 == sum3 ) :		      	while ( 1 ) {						      while ( ( ans = sum1 ) != 0 ) {				  
	    return sum1					      	  if ( top1 == n1 || top2 == n2 || top3 == n3 ) return 0 ;  	if ( ( top1 == n1 || top2 == n2 || top3 == n3 ) ) return  
	if ( sum1 >= sum2 and sum1 >= sum3 ) :		      	  if ( sum1 == sum2 && sum2 == sum3 ) return sum1 ;	    	if ( ( sum1 == sum2 && sum2 == sum3 ) ) return sum1 ;	  
	    sum1 -= stack1 [ top1 ]			      	  if ( sum1 >= sum2 && sum1 >= sum3 ) sum1 -= stack1 [ top1 	if ( ( sum1 >= sum2 && sum1 >= sum3 ) ) {		  
	    top1 = top1 + 1				      	  else if ( sum2 >= sum3 && sum2 >= sum3 ) sum2 -= stack2 [ 	  sum1 -= stack1 [ top1 ] ;				  
	elif ( sum2 >= sum3 and sum2 >= sum3 ) :	      	  else if ( sum3 >= sum2 && sum3 >= sum1 ) sum3 -= stack3 [ 	  top1 = top1 + 1 ;					  
	    sum2 -= stack2 [ top2 ]			      	}							    	}							  
	    top2 = top2 + 1				      }								    	else if ( ( sum2 >= sum3 && sum2 >= sum3 ) ) {		  
	elif ( sum3 >= sum2 and sum3 >= sum1 ) :	      								    	  sum2 -= stack2 [ top2 ] ;				  
	    sum3 -= stack3 [ top3 ]			      								    	  top2 = top2 + 1 ;					  
	    top3 = top3 + 1				      								    	}							  
							      								    	else if ( ( sum3 >= sum2 && sum3 >= sum1 ) ) {		  
							      								    	  sum3 -= stack3 [ top3 ] ;				  
							      								    	  top3 = top3 + 1 ;					  
							      								    	}							  
							      								      }								  
							      								      return sum1 ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM			      MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM			    MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM				  MAXIMUM_SUM_PATH_MATRIX_TOP_BOTTOM
--							      --							    --								  --
def maxSum ( mat , n ) :				      int maxSum ( int mat [ SIZE ] [ SIZE ] , int n ) {	    int maxSum ( int * * mat , int n ) {			  script_not_found : None
    if n == 1 :						      	if ( n == 1 ) return mat [ 0 ] [ 0 ] ;			      if ( n == 1 ) return mat [ 0 ] [ 0 ] ;			  
	return mat [ 0 ] [ 0 ]				      	int dp [ n ] [ n ] ;					      vector < vector < int >> dp ( n , 0 ) ;			  
    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]  	int maxSum = INT_MIN , max ;				      for ( int i = 0 ;						  
    maxSum = INT_MIN					      	for ( int j = 0 ;					      i < n ;							  
    for j in range ( n ) :				      	j < n ;							      i ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ;		  
	dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ]	      	j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ;	      int maxSum = INT_MIN ;					  
    for i in range ( n - 2 , - 1 , - 1 ) :		      	for ( int i = n - 2 ;					      for ( int j = 0 ;						  
	for j in range ( n ) :				      	i >= 0 ;						      j < n ;							  
	    maxi = INT_MIN				      	i -- ) {						      j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ;		  
	    if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 	  for ( int j = 0 ;					      for ( int i = n - 2 ;					  
		maxi = dp [ i + 1 ] [ j - 1 ]		      	  j < n ;						      i >= 0 ;							  
	    if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1  	  j ++ ) {						      i -- ) {							  
		maxi = dp [ i + 1 ] [ j + 1 ]		      	    max = INT_MIN ;					    	for ( int j = 0 ;					  
	    dp [ i ] [ j ] = mat [ i ] [ j ] + maxi	      	    if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 	j < n ;							  
    for j in range ( n ) :				      	    if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1  	j ++ ) {						  
	if ( maxSum < dp [ 0 ] [ j ] ) :		      	    dp [ i ] [ j ] = mat [ i ] [ j ] + max ;		    	  int maxi = INT_MIN ;					  
	    maxSum = dp [ 0 ] [ j ]			      	  }							    	  if ( ( ( ( j - 1 ) >= 0 ) && ( maxi < dp [ i + 1 ] [ j  
    return maxSum					      	}							    	  if ( ( ( ( j + 1 ) < n ) && ( maxi < dp [ i + 1 ] [ j + 
							      	for ( int j = 0 ;					    	  dp [ i ] [ j ] = mat [ i ] [ j ] + maxi ;		  
							      	j < n ;							    	}							  
							      	j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j   }								  
							      	return maxSum ;						      for ( int j = 0 ;						  
							      }								      j < n ;							  
							      								      j ++ ) if ( ( maxSum < dp [ 0 ] [ j ] ) ) maxSum = dp [ 0 ] 
							      								      return maxSum ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K		      LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K		    LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K		  LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENGTH_K
--							      --							    --								  --
def longestSubsequenceCommonSegment ( k , s1 , s2 ) :	      int longestSubsequenceCommonSegment ( int k , string s1 , str int longestSubsequenceCommonSegment ( int k , string s1 , str error : LCS_FORMED_CONSECUTIVE_SEGMENTS_LEAST_LENG
    n = len ( s1 )					      	int n = s1 . length ( ) ;				      int n = s1 . length ( ) ;					  TH_K.cpp: In function ‘int f_filled(int, std::__cx
    m = len ( s2 )					      	int m = s2 . length ( ) ;				      int m = s2 . length ( ) ;					  x11::string, std::__cxx11::string)’: LCS_FORMED_CO
    lcs = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n 	int lcs [ n + 1 ] [ m + 1 ] ;				      vector < vector < int >> lcs ( m + 1 , vector < int > ( n + NSECUTIVE_SEGMENTS_LEAST_LENGTH_K.cpp:53:13: error
    cnt = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n 	int cnt [ n + 1 ] [ m + 1 ] ;				      vector < vector < int >> cnt ( m + 1 , vector < int > ( n + : ‘i’ was not declared in this scope	      lcs [
    for i in range ( 1 , n + 1 ) :			      	memset ( lcs , 0 , sizeof ( lcs ) ) ;			      for ( int y = 0 ;						  i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ]
	for j in range ( 1 , m + 1 ) :			      	memset ( cnt , 0 , sizeof ( cnt ) ) ;			      y < n + 1 ;						  [ j - 1 ] ) ;		     ^ LCS_FORMED_CONSECUTIV
	    lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs 	for ( int i = 1 ;					      y ++ ) {							  E_SEGMENTS_LEAST_LENGTH_K.cpp:53:19: error: ‘j’ wa
	    if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) :	      	i <= n ;						    	for ( int x = 0 ;					  s not declared in this scope	      lcs [ i ] [ j
		cnt [ i ] [ j ] = cnt [ i - 1 ] [ j - 1 ] + 1 	i ++ ) {						    	x < m + 1 ;						  ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] [ j - 1
	    if ( cnt [ i ] [ j ] >= k ) :		      	  for ( int j = 1 ;					    	x ++ ) {						  ] ) ;			   ^
		for a in range ( k , cnt [ i ] [ j ] + 1 ) :  	  j <= m ;						    	  lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] 
		    lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , 	  j ++ ) {						    	  if ( ( s1 [ i - 1 ] == s2 [ j - 1 ] ) ) cnt [ i ] [ j ] 
    return lcs [ n ] [ m ]				      	    lcs [ i ] [ j ] = max ( lcs [ i - 1 ] [ j ] , lcs [ i ] 	  if ( ( cnt [ i ] [ j ] >= k ) ) for ( int a = k ;	  
							      	    if ( s1 [ i - 1 ] == s2 [ j - 1 ] ) cnt [ i ] [ j ] = c 	  a <= cnt [ i ] [ j ] ;				  
							      	    if ( cnt [ i ] [ j ] >= k ) {			    	  a ++ ) lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs [  
							      	      for ( int a = k ;					    	}							  
							      	      a <= cnt [ i ] [ j ] ;				      }								  
							      	      a ++ ) lcs [ i ] [ j ] = max ( lcs [ i ] [ j ] , lcs    return lcs [ n ] [ m ] ;					  
							      	    }							    }								  
							      	  }							    								  
							      	}							    								  
							      	return lcs [ n ] [ m ] ;				    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH CHECK_IF_A_STRING_HAS_ALL_CHARACTERS_WITH_SAME_FREQUENCY_WITH
--							      --							    --								  --
def isValidString ( str ) :				      bool isValidString ( string str ) {			    bool isValidString ( string str ) {				  script_not_found : None
    freq = [ 0 ] * CHARS				      	int freq [ CHARS ] = {					      vector < int > freq ( CHARS , 0 ) ;			  
    for i in range ( len ( str ) ) :			      	  0 }							      for ( int i = 0 ;						  
	freq [ ord ( str [ i ] ) - ord ( 'a' ) ] += 1	      	  ;							      i < str . length ( ) ;					  
    freq1 = 0						      	  for ( int i = 0 ;					      i ++ ) freq [ str [ i ] - 'a' ] ++ ;			  
    count_freq1 = 0					      	  i < str . length ( ) ;				      int freq1 = 0 ;						  
    for i in range ( CHARS ) :				      	  i ++ ) freq [ str [ i ] - 'a' ] ++ ;			      int countFreq1 = 0 ;					  
	if ( freq [ i ] != 0 ) :			      	  int i , freq1 = 0 , count_freq1 = 0 ;			      for ( int i = 0 ;						  
	    freq1 = freq [ i ]				      	  for ( i = 0 ;						      i < CHARS ;						  
	    count_freq1 = 1				      	  i < CHARS ;						      i ++ ) {							  
	    break					      	  i ++ ) {						    	if ( ( freq [ i ] != 0 ) && ( freq [ i ] == freq1 ) ) {	  
    freq2 = 0						      	    if ( freq [ i ] != 0 ) {				    	  freq1 = freq [ i ] ;					  
    count_freq2 = 0					      	      freq1 = freq [ i ] ;				    	  countFreq1 = 1 ;					  
    for j in range ( i + 1 , CHARS ) :			      	      count_freq1 = 1 ;					    	  break ;						  
	if ( freq [ j ] != 0 ) :			      	      break ;						    	}							  
	    if ( freq [ j ] == freq1 ) :		      	    }							      }								  
		count_freq1 += 1			      	  }							      int freq2 = 0 ;						  
	    else :					      	  int j , freq2 = 0 , count_freq2 = 0 ;			      int countFreq2 = 0 ;					  
		count_freq2 = 1				      	  for ( j = i + 1 ;					      for ( int j = i + 1 ;					  
		freq2 = freq [ j ]			      	  j < CHARS ;						      j < CHARS ;						  
		break					      	  j ++ ) {						      j ++ ) {							  
    for k in range ( j + 1 , CHARS ) :			      	    if ( freq [ j ] != 0 ) {				    	if ( ( freq [ j ] != 0 ) && ( freq [ j ] == freq1 ) ) cou 
	if ( freq [ k ] != 0 ) :			      	      if ( freq [ j ] == freq1 ) count_freq1 ++ ;	    	else {							  
	    if ( freq [ k ] == freq1 ) :		      	      else {						    	  countFreq2 = 1 ;					  
		count_freq1 += 1			      		count_freq2 = 1 ;				    	  freq2 = freq [ j ] ;					  
	    if ( freq [ k ] == freq2 ) :		      		freq2 = freq [ j ] ;				    	  break ;						  
		count_freq2 += 1			      		break ;						    	}							  
	    else :					      	      }							      }								  
		return False				      	    }							      for ( int k = j + 1 ;					  
	if ( count_freq1 > 1 and count_freq2 > 1 ) :	      	  }							      k < CHARS ;						  
	    return False				      	  for ( int k = j + 1 ;					      k ++ ) {							  
    return True						      	  k < CHARS ;						    	if ( ( freq [ k ] != 0 ) && ( freq [ k ] == freq1 ) ) cou 
							      	  k ++ ) {						    	if ( ( freq [ k ] == freq2 ) ) countFreq2 ++ ;		  
							      	    if ( freq [ k ] != 0 ) {				    	else return false ;					  
							      	      if ( freq [ k ] == freq1 ) count_freq1 ++ ;	      }								  
							      	      if ( freq [ k ] == freq2 ) count_freq2 ++ ;	      if ( ( countFreq1 > 1 && countFreq2 > 1 ) ) return false ;  
							      	      else return false ;				      return true ;						  
							      	    }							    }								  
							      	    if ( count_freq1 > 1 && count_freq2 > 1 ) return false  								  
							      	  }							    								  
							      	  return true ;						    								  
							      	}							    								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
ROTATE_MATRIX_ELEMENTS					      ROTATE_MATRIX_ELEMENTS					    ROTATE_MATRIX_ELEMENTS					  ROTATE_MATRIX_ELEMENTS
--							      --							    --								  --
def rotateMatrix ( mat ) :				      void rotatematrix ( int m , int n , int mat [ R ] [ C ] ) {   void rotateMatrix ( vector < vector < int >> & mat ) {	  script_not_found : None
    if not len ( mat ) :				      	int row = 0 , col = 0 ;					      if ( mat . size ( ) == 0 ) return ;			  
	return						      	int prev , curr ;					      int top = 0 ;						  
    top = 0						      	while ( row < m && col < n ) {				      int bottom = mat . size ( ) - 1 ;				  
    bottom = len ( mat ) - 1				      	  if ( row + 1 == m || col + 1 == n ) break ;		      int left = 0 ;						  
    left = 0						      	  prev = mat [ row + 1 ] [ col ] ;			      int right = mat [ 0 ] . size ( ) - 1 ;			  
    right = len ( mat [ 0 ] ) - 1			      	  for ( int i = col ;					      while ( left < right && top < bottom ) {			  
    while left < right and top < bottom :		      	  i < n ;						    	int prev = mat [ top + 1 ] [ left ] ;			  
	prev = mat [ top + 1 ] [ left ]			      	  i ++ ) {						    	for ( int i = left ;					  
	for i in range ( left , right + 1 ) :		      	    curr = mat [ row ] [ i ] ;				    	i <= right ;						  
	    curr = mat [ top ] [ i ]			      	    mat [ row ] [ i ] = prev ;				    	i ++ ) {						  
	    mat [ top ] [ i ] = prev			      	    prev = curr ;					    	  int curr = mat [ top ] [ i ] ;			  
	    prev = curr					      	  }							    	  mat [ top ] [ i ] = prev ;				  
	top += 1					      	  row ++ ;						    	  prev = curr ;						  
	for i in range ( top , bottom + 1 ) :		      	  for ( int i = row ;					    	}							  
	    curr = mat [ i ] [ right ]			      	  i < m ;						    	top ++ ;						  
	    mat [ i ] [ right ] = prev			      	  i ++ ) {						    	for ( int i = top ;					  
	    prev = curr					      	    curr = mat [ i ] [ n - 1 ] ;			    	i <= bottom ;						  
	right -= 1					      	    mat [ i ] [ n - 1 ] = prev ;			    	i ++ ) {						  
	for i in range ( right , left - 1 , - 1 ) :	      	    prev = curr ;					    	  int curr = mat [ i ] [ right ] ;			  
	    curr = mat [ bottom ] [ i ]			      	  }							    	  mat [ i ] [ right ] = prev ;				  
	    mat [ bottom ] [ i ] = prev			      	  n -- ;						    	  prev = curr ;						  
	    prev = curr					      	  if ( row < m ) {					    	}							  
	bottom -= 1					      	    for ( int i = n - 1 ;				    	right -- ;						  
	for i in range ( bottom , top - 1 , - 1 ) :	      	    i >= col ;						    	for ( int i = right ;					  
	    curr = mat [ i ] [ left ]			      	    i -- ) {						    	i >= left ;						  
	    mat [ i ] [ left ] = prev			      	      curr = mat [ m - 1 ] [ i ] ;			    	i -- ) {						  
	    prev = curr					      	      mat [ m - 1 ] [ i ] = prev ;			    	  int curr = mat [ bottom ] [ i ] ;			  
	left += 1					      	      prev = curr ;					    	  mat [ bottom ] [ i ] = prev ;				  
    return mat						      	    }							    	  prev = curr ;						  
							      	  }							    	}							  
							      	  m -- ;						    	bottom -- ;						  
							      	  if ( col < n ) {					    	for ( int i = bottom ;					  
							      	    for ( int i = m - 1 ;				    	i >= top ;						  
							      	    i >= row ;						    	i -- ) {						  
							      	    i -- ) {						    	  int curr = mat [ i ] [ left ] ;			  
							      	      curr = mat [ i ] [ col ] ;			    	  mat [ i ] [ left ] = prev ;				  
							      	      mat [ i ] [ col ] = prev ;			    	  prev = curr ;						  
							      	      prev = curr ;					    	}							  
							      	    }							    	left ++ ;						  
							      	  }							      }								  
							      	  col ++ ;						    }								  
							      	}							    								  
							      	for ( int i = 0 ;					    								  
							      	i < R ;							    								  
							      	i ++ ) {						    								  
							      	  for ( int j = 0 ;					    								  
							      	  j < C ;						    								  
							      	  j ++ ) cout << mat [ i ] [ j ] << " " ;		    								  
							      	  cout << endl ;					    								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRUFER_CODE_TREE_CREATION				      PRUFER_CODE_TREE_CREATION					    PRUFER_CODE_TREE_CREATION					  PRUFER_CODE_TREE_CREATION
--							      --							    --								  --
def printTreeEdges ( prufer , m ) :			      void printTreeEdges ( int prufer [ ] , int m ) {		    int printTreeEdges ( int * prufer , int m ) {		  script_not_found : None
    vertices = m + 2					      	int vertices = m + 2 ;					      int vertices = m + 2 ;					  
    vertex_set = [ 0 ] * vertices			      	int vertex_set [ vertices ] ;				      vector < int > vertexSet ( vertices , 0 ) ;		  
    for i in range ( vertices - 2 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	vertex_set [ prufer [ i ] - 1 ] += 1		      	i < vertices ;						      i < vertices - 2 ;					  
    print ( "The edge set E(G) is :" )			      	i ++ ) vertex_set [ i ] = 0 ;				      i ++ ) vertexSet [ prufer [ i ] - 1 ] ++ ;		  
    j = 0						      	for ( int i = 0 ;					      cout << "The edge set E(G) is :" << endl ;		  
    for i in range ( vertices - 2 ) :			      	i < vertices - 2 ;					      int j ;							  
	for j in range ( vertices ) :			      	i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1 ;		      for ( int i = 0 ;						  
	    if ( vertex_set [ j ] == 0 ) :		      	cout << "\nThe edge set E(G) is :\n" ;			      i < vertices - 2 ;					  
		vertex_set [ j ] = - 1			      	int j = 0 ;						      i ++ ) {							  
		print ( "(" , ( j + 1 ) , ", " , prufer [ i ] 	for ( int i = 0 ;					    	for ( j = 0 ;						  
		vertex_set [ prufer [ i ] - 1 ] -= 1	      	i < vertices - 2 ;					    	j < vertices ;						  
		break					      	i ++ ) {						    	j ++ ) {						  
    j = 0						      	  for ( j = 0 ;						    	  if ( ( vertexSet [ j ] == 0 ) ) {			  
    for i in range ( vertices ) :			      	  j < vertices ;					    	    vertexSet [ j ] = - 1 ;				  
	if ( vertex_set [ i ] == 0 and j == 0 ) :	      	  j ++ ) {						    	    cout << "(" << ( j + 1 ) << ", " << prufer [ i ] << " 
	    print ( "(" , ( i + 1 ) , ", " , sep = "" , end = 	    if ( vertex_set [ j ] == 0 ) {			    	    vertexSet [ prufer [ i ] - 1 ] -- ;			  
	    j += 1					      	      vertex_set [ j ] = - 1 ;				    	    break ;						  
	elif ( vertex_set [ i ] == 0 and j == 1 ) :	      	      cout << "(" << ( j + 1 ) << ", " << prufer [ i ] << " 	  }							  
	    print ( ( i + 1 ) , ")" )			      	      vertex_set [ prufer [ i ] - 1 ] -- ;		    	}							  
							      	      break ;						      }								  
							      	    }							      j = 0 ;							  
							      	  }							      for ( int i = 0 ;						  
							      	}							      i < vertices ;						  
							      	j = 0 ;							      i ++ ) {							  
							      	for ( int i = 0 ;					    	if ( ( vertexSet [ i ] == 0 ) && ( j == 0 ) ) {		  
							      	i < vertices ;						    	  cout << "(" << ( i + 1 ) << ", " << endl ;		  
							      	i ++ ) {						    	  j ++ ;						  
							      	  if ( vertex_set [ i ] == 0 && j == 0 ) {		    	}							  
							      	    cout << "(" << ( i + 1 ) << ", " ;			    	else if ( ( vertexSet [ i ] == 0 ) && ( j == 1 ) ) cout < 
							      	    j ++ ;						      }								  
							      	  }							      return j ;						  
							      	  else if ( vertex_set [ i ] == 0 && j == 1 ) cout << ( i +   return vertices * vertices * vertices * vertices * vertices 
							      	}							    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_REPEATED_SUBSEQUENCE_1				      LONGEST_REPEATED_SUBSEQUENCE_1				    LONGEST_REPEATED_SUBSEQUENCE_1				  LONGEST_REPEATED_SUBSEQUENCE_1
--							      --							    --								  --
def longestRepeatedSubSeq ( str ) :			      string longestRepeatedSubSeq ( string str ) {		    string longestRepeatedSubSeq ( string str ) {		  error : LONGEST_REPEATED_SUBSEQUENCE_1.cpp: In fun
    n = len ( str )					      	int n = str . length ( ) ;				      int n = str . length ( ) ;				  ction ‘std::__cxx11::string f_filled(std::__cxx11:
    dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n  	int dp [ n + 1 ] [ n + 1 ] ;				      vector < vector < int >> dp ( n + 1 , vector < int > ( n +  :string)’: LONGEST_REPEATED_SUBSEQUENCE_1.cpp:71:5
    for i in range ( 1 , n + 1 ) :			      	for ( int i = 0 ;					      for ( int i = 1 ;						  1: error: no match for ‘operator=’ (operand types
	for j in range ( 1 , n + 1 ) :			      	i <= n ;						      i <= n ;							  are ‘std::__cxx11::string’ {aka ‘std::__cxx11::bas
	    if ( str [ i - 1 ] == str [ j - 1 ] and i != j )  	i ++ ) for ( int j = 0 ;				      i ++ ) {							  ic_string<char>’} and ‘void’)	   res = reverse ( r
		dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]   	j <= n ;						    	for ( int j = 1 ;					  es . begin ( ) , res . end ( ) ) ;
	    else :					      	j ++ ) dp [ i ] [ j ] = 0 ;				    	j <= n ;						  				      ^ In file incl
		dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , d 	for ( int i = 1 ;					    	j ++ ) {						  uded from /usr/include/c++/8/string:52,
    res = ''						      	i <= n ;						    	  if ( ( str [ i - 1 ] == str [ j - 1 ] && i != j ) || (  	 from /usr/include/c++/8/bits/locale_classes
    i = n						      	i ++ ) for ( int j = 1 ;				    	  else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i .h:40,		  from /usr/include/c++/8/bi
    j = n						      	j <= n ;						    	}							  ts/ios_base.h:41,		     from /usr/inclu
    while ( i > 0 and j > 0 ) :				      	j ++ ) if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [   }								  de/c++/8/ios:42,		    from /usr/includ
	if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : 	else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1   string res ;						  e/c++/8/ostream:38,		       from /usr/inc
	    res += str [ i - 1 ]			      	string res = "" ;					      int i = n ;						  lude/c++/8/iostream:39,		   from LONG
	    i -= 1					      	int i = n , j = n ;					      int j = n ;						  EST_REPEATED_SUBSEQUENCE_1.cpp:8: /usr/include/c++
	    j -= 1					      	while ( i > 0 && j > 0 ) {				      while ( ( i > 0 ) && ( j > 0 ) ) {			  /8/bits/basic_string.h:664:7: note: candidate: ‘st
	elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) :	      	  if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) {	    	if ( ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) ) { d::__cxx11::basic_string<_CharT, _Traits, _Alloc>&
	    i -= 1					      	    res = res + str [ i - 1 ] ;				    	  res += str [ i - 1 ] ;				   std::__cxx11::basic_string<_CharT, _Traits, _Allo
	else :						      	    i -- ;						    	  i -- ;						  c>::operator=(const std::__cxx11::basic_string<_Ch
	    j -= 1					      	    j -- ;						    	  j -- ;						  arT, _Traits, _Alloc>&) [with _CharT = char; _Trai
    res = ''.join ( reversed ( res ) )			      	  }							    	}							  ts = std::char_traits<char>; _Alloc = std::allocat
    return res						      	  else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ;   	else if ( ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) ) i -- or<char>]’	    operator=(const basic_string& __
							      	  else j -- ;						    	else j -- ;						  str)	      ^~~~~~~~ /usr/include/c++/8/bits/basic
							      	}							      }								  _string.h:664:7: note:   no known conversion for a
							      	reverse ( res . begin ( ) , res . end ( ) ) ;		      res = reverse ( res . begin ( ) , res . end ( ) ) ;	  rgument 1 from ‘void’ to ‘const std::__cxx11::basi
							      	return res ;						      return res ;						  c_string<char>&’ /usr/include/c++/8/bits/basic_str
							      }								      return " " + str + " " + str ;				  ing.h:703:7: note: candidate: ‘std::__cxx11::basic
							      								    }								  _string<_CharT, _Traits, _Alloc>& std::__cxx11::ba
							      								    								  sic_string<_CharT, _Traits, _Alloc>::operator=(con
							      								    								  st _CharT*) [with _CharT = char; _Traits = std::ch
							      								    								  ar_traits<char>; _Alloc = std::allocator<char>]’
							      								    								  	operator=(const _CharT* __s)	    ^~~~~~~~
							      								    								   /usr/include/c++/8/bits/basic_string.h:703:7: not
							      								    								  e:   no known conversion for argument 1 from ‘void
							      								    								  ’ to ‘const char*’ /usr/include/c++/8/bits/basic_s
							      								    								  tring.h:714:7: note: candidate: ‘std::__cxx11::bas
							      								    								  ic_string<_CharT, _Traits, _Alloc>& std::__cxx11::
							      								    								  basic_string<_CharT, _Traits, _Alloc>::operator=(_
							      								    								  CharT) [with _CharT = char; _Traits = std::char_tr
							      								    								  aits<char>; _Alloc = std::allocator<char>]’
							      								    								   operator=(_CharT __c)	^~~~~~~~ /usr/includ
							      								    								  e/c++/8/bits/basic_string.h:714:7: note:   no know
							      								    								  n conversion for argument 1 from ‘void’ to ‘char’
							      								    								  /usr/include/c++/8/bits/basic_string.h:732:7: note
							      								    								  : candidate: ‘std::__cxx11::basic_string<_CharT, _
							      								    								  Traits, _Alloc>& std::__cxx11::basic_string<_CharT
							      								    								  , _Traits, _Alloc>::operator=(std::__cxx11::basic_
							      								    								  string<_CharT, _Traits, _Alloc>&&) [with _CharT =
							      								    								  char; _Traits = std::char_traits<char>; _Alloc = s
							      								    								  td::allocator<char>]’	       operator=(basic_strin
							      								    								  g&& __str)	    ^~~~~~~~ /usr/include/c++/8/bits
							      								    								  /basic_string.h:732:7: note:	 no known conversion
							      								    								   for argument 1 from ‘void’ to ‘std::__cxx11::basi
							      								    								  c_string<char>&&’ /usr/include/c++/8/bits/basic_st
							      								    								  ring.h:795:7: note: candidate: ‘std::__cxx11::basi
							      								    								  c_string<_CharT, _Traits, _Alloc>& std::__cxx11::b
							      								    								  asic_string<_CharT, _Traits, _Alloc>::operator=(st
							      								    								  d::initializer_list<_Tp>) [with _CharT = char; _Tr
							      								    								  aits = std::char_traits<char>; _Alloc = std::alloc
							      								    								  ator<char>]’	      operator=(initializer_list<_Ch
							      								    								  arT> __l)	   ^~~~~~~~ /usr/include/c++/8/bits/
							      								    								  basic_string.h:795:7: note:	no known conversion
							      								    								  for argument 1 from ‘void’ to ‘std::initializer_li
							      								    								  st<char>’
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL MINIMUM_CELLS_REQUIRED_REACH_DESTINATION_JUMPS_EQUAL_CELL_VAL
--							      --							    --								  --
def minCells ( mat , m , n ) :				      int minCells ( int mat [ SIZE ] [ SIZE ] , int m , int n ) {  int minCells ( int * * mat , int m , int n ) {		  script_not_found : None
    dp = [ [ MAX for i in range ( n ) ] for i in range ( m )  	int dp [ m ] [ n ] ;					      vector < vector < int >> dp ( n , vector < int > ( m , 0 )  
    dp [ 0 ] [ 0 ] = 1					      	for ( int i = 0 ;					      dp [ 0 ] [ 0 ] = 1 ;					  
    for i in range ( m ) :				      	i < m ;							      for ( int i = 0 ;						  
	for j in range ( n ) :				      	i ++ ) for ( int j = 0 ;				      i < m ;							  
	    if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [  	j < n ;							      i ++ ) {							  
		dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ 	j ++ ) dp [ i ] [ j ] = INT_MAX ;			    	for ( int j = 0 ;					  
	    if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [  	dp [ 0 ] [ 0 ] = 1 ;					    	j < n ;							  
		dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ 	for ( int i = 0 ;					    	j ++ ) {						  
    if ( dp [ m - 1 ] [ n - 1 ] != MAX ) :		      	i < m ;							    	  if ( ( dp [ i ] [ j ] != MAX ) && ( j + mat [ i ] [ j ] 
	return dp [ m - 1 ] [ n - 1 ]			      	i ++ ) {						    	  if ( ( dp [ i ] [ j ] != MAX ) && ( i + mat [ i ] [ j ] 
    return - 1						      	  for ( int j = 0 ;					    	}							  
							      	  j < n ;						      }								  
							      	  j ++ ) {						      if ( ( dp [ m - 1 ] [ n - 1 ] != MAX ) ) return dp [ m - 1  
							      	    if ( dp [ i ] [ j ] != INT_MAX && ( j + mat [ i ] [ j ]   return - 1 ;						  
							      	    if ( dp [ i ] [ j ] != INT_MAX && ( i + mat [ i ] [ j ]   return m * m ;						  
							      	  }							    }								  
							      	}							    								  
							      	if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) return dp [ m - 1  								  
							      	return - 1 ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6	      PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6	    PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6	  PRINT_DIGITS_POSITION_REMOVED_MAKE_NUMBER_DIVISIBLE_6
--							      --							    --								  --
def greatest ( s ) :					      void greatest ( string s ) {				    int greatest ( string s ) {					  script_not_found : None
    n = len ( s )					      	int n = s . length ( ) ;				      int n = s . length ( ) ;					  
    a = [ 0 for i in range ( n ) ]			      	int a [ n ] ;						      int a [ n ] ;						  
    Sum = 0						      	int sum = 0 ;						      for ( int i = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      i < n ;							  
	a [ i ] = ord ( s [ i ] ) - ord ( '0' )		      	i < n ;							      i ++ ) {							  
	Sum += a [ i ]					      	i ++ ) {						    	a [ i ] = s [ i ] - '0' ;				  
    if ( a [ n - 1 ] % 2 ) :				      	  a [ i ] = s [ i ] - '0' ;				    	Sum += a [ i ] ;					  
	if ( a [ n - 2 ] % 2 != 0 or ( Sum - a [ n - 1 ] ) %  	  sum += a [ i ] ;					      }								  
	    print ( "-1" )				      	}							      if ( ( a [ n - 1 ] % 2 ) != 0 ) {				  
	else :						      	if ( a [ n - 1 ] % 2 ) {				    	if ( ( a [ n - 2 ] % 2 ) != 0 || ( Sum - a [ n - 1 ] ) %  
	    print ( n )					      	  if ( a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 	else cout << n ;					  
    else :						      	    cout << "-1" << endl ;				      }								  
	re = Sum % 3					      	  }							      else {							  
	dell = - 1					      	  else {						    	int re = Sum % 3 ;					  
	flag = 0					      	    cout << n << endl ;					    	int dell = - 1 ;					  
	for i in range ( n - 1 ) :			      	  }							    	int flag = 0 ;						  
	    if ( ( a [ i ] ) % 3 == re ) :		      	}							    	for ( int i = 0 ;					  
		if ( a [ i + 1 ] > a [ i ] ) :		      	else {							    	i < n - 1 ;						  
		    dell = i				      	  int re = sum % 3 ;					    	i ++ ) {						  
		    flag = 1				      	  int del = - 1 ;					    	  if ( ( ( a [ i ] ) % 3 == re ) ) {			  
		    break				      	  int flag = 0 ;					    	    if ( ( a [ i + 1 ] > a [ i ] ) ) {			  
		else :					      	  for ( int i = 0 ;					    	      dell = i ;					  
		    dell = i				      	  i < n - 1 ;						    	      flag = 1 ;					  
	if ( flag == 0 ) :				      	  i ++ ) {						    	      break ;						  
	    if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 	    if ( ( a [ i ] ) % 3 == re ) {			    	    }							  
		dell = n - 1				      	      if ( a [ i + 1 ] > a [ i ] ) {			    	    else {						  
	if ( dell == - 1 ) :				      		del = i ;					    	      dell = i ;					  
	    print ( "-1" )				      		flag = 1 ;					    	    }							  
	else :						      		break ;						    	  }							  
	    print ( dell + 1 )				      	      }							    	}							  
							      	      else {						      }								  
							      		del = i ;					      if ( ( flag == 0 ) ) {					  
							      	      }							    	if ( ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) )  
							      	    }							      }								  
							      	  }							    }								  
							      	  if ( flag == 0 ) {					    if ( ( dell == - 1 ) ) cout << "-1" ;			  
							      	    if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) d else cout << dell + 1 ;					  
							      	  }							    return n ;							  
							      	  if ( del == - 1 ) cout << - 1 << endl ;		    return n * n ;						  
							      	  else {						    return n * n * n * n * n * n * n * n * n * n * n * n * n * n  
							      	    cout << del + 1 << endl ;				    }								  
							      	  }							    								  
							      	}							    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS		      MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS			    MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS			  MAKE_LARGEST_PALINDROME_CHANGING_K_DIGITS
--							      --							    --								  --
def maximumPalinUsingKChanges ( strr , k ) :		      string maximumPalinUsingKChanges ( string str , int k ) {	    string maximumPalinUsingKChanges ( string strr , int k ) {	  failure : #Results: 2, 10
    palin = strr					      	string palin = str ;					      string palin = strr ;					  
    l = 0						      	int l = 0 ;						      int l = 0 ;						  
    r = len ( strr ) - 1				      	int r = str . length ( ) - 1 ;				      int r = strr . length ( ) - 1 ;				  
    while ( l <= r ) :					      	while ( l < r ) {					      while ( ( l <= r ) && ( palin [ l ] != palin [ r ] ) ) {	  
	if ( strr [ l ] != strr [ r ] ) :		      	  if ( str [ l ] != str [ r ] ) {			    	palin [ l ] = palin [ r ] = max ( palin [ l ] , palin [ r 
	    palin [ l ] = palin [ r ] = max ( strr [ l ] , st 	    palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] 	k -- ;							  
	    k -= 1					      	    k -- ;						      }								  
	l += 1						      	  }							      l ++ ;							  
	r -= 1						      	  l ++ ;						      r -- ;							  
    if ( k < 0 ) :					      	  r -- ;						      if ( ( k < 0 ) ) return "Not possible" ;			  
	return "Not possible"				      	}							      l = 0 ;							  
    l = 0						      	if ( k < 0 ) return "Not possible" ;			      r = strr . length ( ) - 1 ;				  
    r = len ( strr ) - 1				      	l = 0 ;							      while ( ( l <= r ) ) {					  
    while ( l <= r ) :					      	r = str . length ( ) - 1 ;				    	if ( ( l == r ) ) {					  
	if ( l == r ) :					      	while ( l <= r ) {					    	  if ( ( k > 0 ) ) palin [ l ] = '9' ;			  
	    if ( k > 0 ) :				      	  if ( l == r ) {					    	}							  
		palin [ l ] = '9'			      	    if ( k > 0 ) palin [ l ] = '9' ;			    	if ( ( palin [ l ] < '9' ) ) {				  
	if ( palin [ l ] < '9' ) :			      	  }							    	  if ( ( k >= 2 ) && ( palin [ l ] == strr [ l ] && palin 
	    if ( k >= 2 and palin [ l ] == strr [ l ] and pal 	  if ( palin [ l ] < '9' ) {				    	    k -- ;						  
		k -= 1					      	    if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ]  	    palin [ l ] = palin [ r ] = '9' ;			  
		palin [ l ] = palin [ r ] = '9'		      	      k -= 2 ;						    	  }							  
	    elif ( k >= 1 and ( palin [ l ] != strr [ l ] or  	      palin [ l ] = palin [ r ] = '9' ;			    	  else if ( ( k >= 1 ) && ( palin [ l ] != strr [ l ] ||  
		k -= 1					      	    }							    	    k -- ;						  
		palin [ l ] = palin [ r ] = '9'		      	    else if ( k >= 1 && ( palin [ l ] != str [ l ] || palin 	    palin [ l ] = palin [ r ] = '9' ;			  
	l += 1						      	      k -- ;						    	  }							  
	r -= 1						      	      palin [ l ] = palin [ r ] = '9' ;			    	}							  
    return palin					      	    }							    	l ++ ;							  
							      	  }							    	r -- ;							  
							      	  l ++ ;						      }								  
							      	  r -- ;						      return palin ;						  
							      	}							      return " " + strr + " " + strr ;				  
							      	return palin ;						    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION		      MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION		    MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION			  MAXIMUM_MINIMUM_VALUES_ALGEBRAIC_EXPRESSION
--							      --							    --								  --
def minMaxValues ( arr , n , m ) :			      e9 int minMaxValues ( int arr [ ] , int n , int m ) {	    int minMaxValues ( int * arr , int n , int m ) {		  script_not_found : None
    sum = 0						      	int sum = 0 ;						      int sum = 0 ;						  
    INF = 1000000000					      	for ( int i = 0 ;					      int INF = 1000000000 ;					  
    MAX = 50						      	i < ( n + m ) ;						      int MAX = 50 ;						  
    for i in range ( 0 , ( n + m ) ) :			      	i ++ ) {						      for ( int i = 0 ;						  
	sum += arr [ i ]				      	  sum += arr [ i ] ;					      i < ( n + m ) ;						  
	arr [ i ] += 50					      	  arr [ i ] += 50 ;					      i ++ ) {							  
    dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in ra 	}							    	sum += arr [ i ] ;					  
    dp [ 0 ] [ 0 ] = 1					      	bool dp [ MAX + 1 ] [ MAX * MAX + 1 ] ;			    	arr [ i ] += 50 ;					  
    for i in range ( 0 , ( n + m ) ) :			      	memset ( dp , 0 , sizeof ( dp ) ) ;			      }								  
	for k in range ( min ( n , i + 1 ) , 0 , - 1 ) :      	dp [ 0 ] [ 0 ] = 1 ;					      vector < vector < int >> dp ( MAX * MAX + 1 , vector < int  
	    for j in range ( 0 , MAX * MAX + 1 ) :	      	for ( int i = 0 ;					      dp [ 0 ] [ 0 ] = 1 ;					  
		if ( dp [ k - 1 ] [ j ] ) :		      	i < ( n + m ) ;						      for ( int i = 0 ;						  
		    dp [ k ] [ j + arr [ i ] ] = 1	      	i ++ ) {						      i < ( n + m ) ;						  
    max_value = - 1 * INF				      	  for ( int k = min ( n , i + 1 ) ;			      i ++ ) {							  
    min_value = INF					      	  k >= 1 ;						    	for ( int k = min < int > ( n , i + 1 ) ;		  
    for i in range ( 0 , MAX * MAX + 1 ) :		      	  k -- ) {						    	k > 0 ;							  
	if ( dp [ n ] [ i ] ) :				      	    for ( int j = 0 ;					    	k -- ) {						  
	    temp = i - 50 * n				      	    j < MAX * MAX + 1 ;					    	  for ( int j = 0 ;					  
	    max_value = max ( max_value , temp * ( sum - temp 	    j ++ ) {						    	  j < MAX * MAX + 1 ;					  
	    min_value = min ( min_value , temp * ( sum - temp 	      if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ]  	  j ++ ) {						  
    print ( "Maximum Value: {}\nMinimum Value: {}".format ( m 	    }							    	    if ( ( dp [ k - 1 ] [ j ] ) ) dp [ k ] [ j + arr [ i  
							      	  }							    	  }							  
							      	}							    	}							  
							      	int max_value = - INF , min_value = INF ;		      }								  
							      	for ( int i = 0 ;					      int maxValue = - 1 * INF ;				  
							      	i < MAX * MAX + 1 ;					      int minValue = INF ;					  
							      	i ++ ) {						      for ( int i = 0 ;						  
							      	  if ( dp [ n ] [ i ] ) {				      i < MAX * MAX + 1 ;					  
							      	    int temp = i - 50 * n ;				      i ++ ) {							  
							      	    max_value = max ( max_value , temp * ( sum - temp ) ) ; 	if ( ( dp [ n ] [ i ] ) ) {				  
							      	    min_value = min ( min_value , temp * ( sum - temp ) ) ; 	  int temp = i - 50 * n ;				  
							      	  }							    	  maxValue = max < int > ( maxValue , temp * ( sum - temp 
							      	}							    	  minValue = min < int > ( minValue , temp * ( sum - temp 
							      	cout << "Maximum Value: " << max_value << "\n" << "Minimum  	}							  
							      }								      }								  
							      								      cout << "Maximum Value: " << maxValue << "\nMinimum Value:  
							      								      return maxValue ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION		      MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION		    MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION		  MINIMUM_POSITIVE_POINTS_TO_REACH_DESTINATION
--							      --							    --								  --
def minInitialPoints ( points ) :			      int minInitialPoints ( int points [ ] [ C ] ) {		    int minInitialPoints ( int * * points ) {			  script_not_found : None
    dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R  	int dp [ R ] [ C ] ;					      vector < vector < int >> dp ( C + 1 , vector < int > ( R +  
    m , n = R , C					      	int m = R , n = C ;					      for ( int y = 0 ;						  
    if points [ m - 1 ] [ n - 1 ] > 0 :			      	dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1   y < R + 1 ;						  
	dp [ m - 1 ] [ n - 1 ] = 1			      	for ( int i = m - 2 ;					      y ++ ) {							  
    else :						      	i >= 0 ;						    	for ( int x = 0 ;					  
	dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 	i -- ) dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] -  	x < C ;							  
    for i in range ( m - 2 , - 1 , - 1 ) :		      	for ( int j = n - 2 ;					    	x ++ ) {						  
	dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - p 	j >= 0 ;						    	  dp [ m - 1 ] [ n - 1 ] = 1 ;				  
    for i in range ( 2 , - 1 , - 1 ) :			      	j -- ) dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] -  	}							  
	dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - p 	for ( int i = m - 2 ;					    	if ( points [ m - 1 ] [ n - 1 ] > 0 ) dp [ m - 1 ] [ n -  
    for i in range ( m - 2 , - 1 , - 1 ) :		      	i >= 0 ;						    	else dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n  
	for j in range ( n - 2 , - 1 , - 1 ) :		      	i -- ) {						    	for ( int i = m - 2 ;					  
	    min_points_on_exit = min ( dp [ i + 1 ] [ j ] , d 	  for ( int j = n - 2 ;					    	i >= 0 ;						  
	    dp [ i ] [ j ] = max ( min_points_on_exit - point 	  j >= 0 ;						    	i -- ) dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ]  
    return dp [ 0 ] [ 0 ]				      	  j -- ) {						    	for ( int i = 2 ;					  
							      	    int min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp  	i >= 0 ;						  
							      	    dp [ i ] [ j ] = max ( min_points_on_exit - points [ i  	i -- ) dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ]  
							      	  }							    	for ( int i = m - 2 ;					  
							      	}							    	i >= 0 ;						  
							      	return dp [ 0 ] [ 0 ] ;					    	i -- ) {						  
							      }								    	  for ( int j = n - 2 ;					  
							      								    	  j >= 0 ;						  
							      								    	  j -- ) {						  
							      								    	    int minPointsOnExit = min ( dp [ i + 1 ] [ j ] , dp [ 
							      								    	    dp [ i ] [ j ] = max ( minPointsOnExit - points [ i ] 
							      								    	  }							  
							      								    	}							  
							      								      }								  
							      								      return dp [ 0 ] [ 0 ] ;					  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG		      MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG		    MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG			  MINIMUM_COST_TO_FILL_GIVEN_WEIGHT_IN_A_BAG
--							      --							    --								  --
def MinimumCost ( cost , n , W ) :			      int MinimumCost ( int cost [ ] , int n , int W ) {	    int MinimumCost ( int * cost , int n , int W ) {		  script_not_found : None
    val = list ( )					      	vector < int > val , wt ;				      vector < int > val ;					  
    wt = list ( )					      	int size = 0 ;						      vector < int > wt ;					  
    size = 0						      	for ( int i = 0 ;					      int size = 0 ;						  
    for i in range ( n ) :				      	i < n ;							      for ( int i = 0 ;						  
	if ( cost [ i ] != - 1 ) :			      	i ++ ) {						      i < n ;							  
	    val.append ( cost [ i ] )			      	  if ( cost [ i ] != - 1 ) {				      i ++ ) {							  
	    wt.append ( i + 1 )				      	    val . push_back ( cost [ i ] ) ;			    	if ( ( cost [ i ] != - 1 ) && ( cost [ i ] != - 1 ) ) {	  
	    size += 1					      	    wt . push_back ( i + 1 ) ;				    	  val . push_back ( cost [ i ] ) ;			  
    n = size						      	    size ++ ;						    	  wt . push_back ( i + 1 ) ;				  
    min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in rang 	  }							    	  size ++ ;						  
    for i in range ( W + 1 ) :				      	}							    	}							  
	min_cost [ 0 ] [ i ] = INF			      	n = size ;						      }								  
    for i in range ( 1 , n + 1 ) :			      	int min_cost [ n + 1 ] [ W + 1 ] ;			      n = size ;						  
	min_cost [ i ] [ 0 ] = 0			      	for ( int i = 0 ;					      vector < vector < int >> min_cost ( n + 1 , vector < int >  
    for i in range ( 1 , n + 1 ) :			      	i <= W ;						      for ( int j = 0 ;						  
	for j in range ( 1 , W + 1 ) :			      	i ++ ) min_cost [ 0 ] [ i ] = INF ;			      j < n + 1 ;						  
	    if ( wt [ i - 1 ] > j ) :			      	for ( int i = 1 ;					      j ++ ) {							  
		min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j 	i <= n ;						    	min_cost [ 0 ] [ j ] = INF ;				  
	    else :					      	i ++ ) min_cost [ i ] [ 0 ] = 0 ;			      }								  
		min_cost [ i ] [ j ] = min ( min_cost [ i - 1 	for ( int i = 1 ;					      for ( int i = 1 ;						  
    if ( min_cost [ n ] [ W ] == INF ) :		      	i <= n ;						      i <= n ;							  
	return - 1					      	i ++ ) {						      i ++ ) {							  
    else :						      	  for ( int j = 1 ;					    	min_cost [ i ] [ 0 ] = 0 ;				  
	return min_cost [ n ] [ W ]			      	  j <= W ;						      }								  
							      	  j ++ ) {						      for ( int i = 1 ;						  
							      	    if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost   i <= n ;							  
							      	    else min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [    i ++ ) {							  
							      	  }							    	for ( int j = 1 ;					  
							      	}							    	j <= W ;						  
							      	return ( min_cost [ n ] [ W ] == INF ) ? - 1 : min_cost [ n 	j ++ ) {						  
							      }								    	  if ( ( wt [ i - 1 ] > j ) ) min_cost [ i ] [ j ] = min_ 
							      								    	  else min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [  
							      								    	}							  
							      								      }								  
							      								      if ( ( min_cost [ n ] [ W ] == INF ) ) return - 1 ;	  
							      								      else return min_cost [ n ] [ W ] ;			  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS	      FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS	    FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS	  FIND_SMALLEST_RANGE_CONTAINING_ELEMENTS_FROM_K_LISTS
--							      --							    --								  --
def findSmallestRange ( arr , n , k ) :			      void findSmallestRange ( int arr [ ] [ N ] , int n , int k )  int findSmallestRange ( int * * arr , int n , int k ) {	  script_not_found : None
    i , minval , maxval , minrange , minel , maxel , flag , m 	int i , minval , maxval , minrange , minel , maxel , flag ,   int i , minval , maxval , minrange , minel , maxel , flag , 
    for i in range ( k + 1 ) :				      	for ( i = 0 ;						      for ( i = 0 ;						  
	ptr [ i ] = 0					      	i <= k ;						      i < k + 1 ;						  
    minrange = 10 ** 9					      	i ++ ) ptr [ i ] = 0 ;					      i ++ ) ptr [ i ] = 0 ;					  
    while ( 1 ) :					      	minrange = INT_MAX ;					      minrange = 10 * 9 ;					  
	minind = - 1					      	while ( 1 ) {						      while ( ( 1 ) ) {						  
	minval = 10 ** 9				      	  minind = - 1 ;					    	minind = - 1 ;						  
	maxval = - 10 ** 9				      	  minval = INT_MAX ;					    	minval = 10 * 9 ;					  
	flag = 0					      	  maxval = INT_MIN ;					    	maxval = - 10 * 9 ;					  
	for i in range ( k ) :				      	  flag = 0 ;						    	flag = 0 ;						  
	    if ( ptr [ i ] == n ) :			      	  for ( i = 0 ;						    	for ( i = 0 ;						  
		flag = 1				      	  i < k ;						    	i < k ;							  
		break					      	  i ++ ) {						    	i ++ ) {						  
	    if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] <  	    if ( ptr [ i ] == n ) {				    	  if ( ( ptr [ i ] == n ) ) {				  
		minind = i				      	      flag = 1 ;					    	    flag = 1 ;						  
		minval = arr [ i ] [ ptr [ i ] ]	      	      break ;						    	    break ;						  
	    if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] >  	    }							    	  }							  
		maxval = arr [ i ] [ ptr [ i ] ]	      	    if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval  	  if ( ( ptr [ i ] < n ) && arr [ i ] [ ptr [ i ] ] < min 
	if ( flag ) :					      	      minind = i ;					    	    minind = i ;					  
	    break					      	      minval = arr [ i ] [ ptr [ i ] ] ;		    	    minval = arr [ i ] [ ptr [ i ] ] ;			  
	ptr [ minind ] += 1				      	    }							    	  }							  
	if ( ( maxval - minval ) < minrange ) :		      	    if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval  	  if ( ( ptr [ i ] < n ) && arr [ i ] [ ptr [ i ] ] > max 
	    minel = minval				      	      maxval = arr [ i ] [ ptr [ i ] ] ;		    	    maxval = arr [ i ] [ ptr [ i ] ] ;			  
	    maxel = maxval				      	    }							    	  }							  
	    minrange = maxel - minel			      	  }							    	}							  
    print ( "The smallest range is [" , minel , maxel , "]" ) 	  if ( flag ) break ;					    	if ( ( flag ) ) break ;					  
							      	  ptr [ minind ] ++ ;					    	ptr [ minind ] ++ ;					  
							      	  if ( ( maxval - minval ) < minrange ) {		    	if ( ( ( maxval - minval ) < minrange ) ) {		  
							      	    minel = minval ;					    	  minel = minval ;					  
							      	    maxel = maxval ;					    	  maxel = maxval ;					  
							      	    minrange = maxel - minel ;				    	  minrange = maxel - minel ;				  
							      	  }							    	}							  
							      	}							      }								  
							      	printf ( "The smallest range is [%d , %d]\n" , minel , maxe   cout << "The smallest range is [" << minel << "," << maxel  
							      }								      return minind ;						  
							      								      return k * k ;						  
							      								      return k * k ;						  
							      								      return k * k ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1     RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1	    RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1	  RETURN_A_PAIR_WITH_MAXIMUM_PRODUCT_IN_ARRAY_OF_INTEGERS_1
--							      --							    --								  --
def maxProduct ( arr , n ) :				      void maxProduct ( int arr [ ] , int n ) {			    int maxProduct ( int * arr , int n ) {			  script_not_found : None
    if ( n < 2 ) :					      	if ( n < 2 ) {						      if ( ( n < 2 ) ) {					  
	print ( "No pairs exists" )			      	  cout << "No pairs exists\n" ;				    	cout << "No pairs exists" << endl ;			  
	return						      	  return ;						    	return 0 ;						  
    if ( n == 2 ) :					      	}							      }								  
	print ( arr [ 0 ] , " " , arr [ 1 ] )		      	if ( n == 2 ) {						      if ( ( n == 2 ) ) {					  
	return						      	  cout << arr [ 0 ] << " " << arr [ 1 ] << endl ;	    	cout << arr [ 0 ] << " " << arr [ 1 ] << endl ;		  
    posa = 0						      	  return ;						    	return 0 ;						  
    posb = 0						      	}							      }								  
    nega = 0						      	int posa = INT_MIN , posb = INT_MIN ;			      int posa = 0 ;						  
    negb = 0						      	int nega = INT_MIN , negb = INT_MIN ;			      int posb = 0 ;						  
    for i in range ( n ) :				      	for ( int i = 0 ;					      int nega = 0 ;						  
	if ( arr [ i ] > posa ) :			      	i < n ;							      int negb = 0 ;						  
	    posb = posa					      	i ++ ) {						      for ( int i = 0 ;						  
	    posa = arr [ i ]				      	  if ( arr [ i ] > posa ) {				      i < n ;							  
	elif ( arr [ i ] > posb ) :			      	    posb = posa ;					      i ++ ) {							  
	    posb = arr [ i ]				      	    posa = arr [ i ] ;					    	if ( ( arr [ i ] > posa ) ) {				  
	if ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( nega 	  }							    	  posb = posa ;						  
	    negb = nega					      	  else if ( arr [ i ] > posb ) posb = arr [ i ] ;	    	  posa = arr [ i ] ;					  
	    nega = arr [ i ]				      	  if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( nega ) )  	}							  
	elif ( arr [ i ] < 0 and abs ( arr [ i ] ) > abs ( ne 	    negb = nega ;					    	else if ( ( arr [ i ] > posb ) ) {			  
	    negb = arr [ i ]				      	    nega = arr [ i ] ;					    	  posb = arr [ i ] ;					  
    if ( nega * negb > posa * posb ) :			      	  }							    	}							  
	print ( "Max product pair is {" , nega , ", " , negb  	  else if ( arr [ i ] < 0 && abs ( arr [ i ] ) > abs ( negb 	if ( ( arr [ i ] < 0 ) && abs ( arr [ i ] ) > abs ( nega  
    else :						      	}							    	  negb = nega ;						  
	print ( "Max product pair is {" , posa , ", " , posb  	if ( nega * negb > posa * posb ) cout << "Max product pair  	  nega = arr [ i ] ;					  
							      	else cout << "Max product pair is {" << posa << ", " << pos 	}							  
							      }								    	else if ( ( arr [ i ] < 0 ) && abs ( arr [ i ] ) > abs (  
							      								    	  negb = arr [ i ] ;					  
							      								    	}							  
							      								      }								  
							      								      if ( ( nega * negb > posa * posb ) ) {			  
							      								    	cout << "Max product pair is {" << nega << ", " << negb < 
							      								      }								  
							      								      else {							  
							      								    	cout << "Max product pair is {" << posa << ", " << posb < 
							      								      }								  
							      								      return 0 ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L		      MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L		    MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L		  MAXIMIZE_ARRJ_ARRI_ARRL_ARRK_SUCH_THAT_I_J_K_L
--							      --							    --								  --
def findMaxValue ( arr , n ) :				      - 100000000 int findMaxValue ( int arr [ ] , int n ) {	    int findMaxValue ( int * arr , int n ) {			  script_not_found : None
    if n < 4 :						      	if ( n < 4 ) {						      if ( n < 4 ) {						  
	print ( "The array should have atlest 4 elements" )   	  printf ( "The array should have atlest 4 elements\n" ) ;  	cout << "The array should have atlest 4 elements" << endl 
	return MIN					      	  return MIN ;						    	return MIN ;						  
    table1 , table2 = [ MIN ] * ( n + 1 ) , [ MIN ] * n	      	}							      }								  
    table3 , table4 = [ MIN ] * ( n - 1 ) , [ MIN ] * ( n - 2 	int table1 [ n + 1 ] , table2 [ n ] , table3 [ n - 1 ] , ta   int * table1 = new int [ n + 1 ] , * table2 = new int [ n ] 
    for i in range ( n - 1 , - 1 , - 1 ) :		      	for ( int i = 0 ;					      int * table3 = new int [ n - 1 ] , * table4 = new int [ n - 
	table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] )   	i <= n ;						      for ( int i = n - 1 ;					  
    for i in range ( n - 2 , - 1 , - 1 ) :		      	i ++ ) table1 [ i ] = table2 [ i ] = table3 [ i ] = table4    i >= 0 ;							  
	table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i +  	for ( int i = n - 1 ;					      i -- ) table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] )  
    for i in range ( n - 3 , - 1 , - 1 ) :		      	i >= 0 ;						      for ( int i = n - 2 ;					  
	table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i +  	i -- ) table1 [ i ] = max ( table1 [ i + 1 ] , arr [ i ] )    i >= 0 ;							  
    for i in range ( n - 4 , - 1 , - 1 ) :		      	for ( int i = n - 2 ;					      i -- ) table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i + 
	table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i +  	i >= 0 ;						      for ( int i = n - 3 ;					  
    return table4 [ 0 ]					      	i -- ) table2 [ i ] = max ( table2 [ i + 1 ] , table1 [ i +   i >= 0 ;							  
							      	for ( int i = n - 3 ;					      i -- ) table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i + 
							      	i >= 0 ;						      for ( int i = n - 4 ;					  
							      	i -- ) table3 [ i ] = max ( table3 [ i + 1 ] , table2 [ i +   i >= 0 ;							  
							      	for ( int i = n - 4 ;					      i -- ) table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + 
							      	i >= 0 ;						      return table4 [ 0 ] ;					  
							      	i -- ) table4 [ i ] = max ( table4 [ i + 1 ] , table3 [ i + }								  
							      	return table4 [ 0 ] ;					    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2	      MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2	    MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2	  MINIMUM_NUMBER_DELETIONS_MAKE_STRING_PALINDROME_SET_2
--							      --							    --								  --
def getLevenstein ( inpt ) :				      int getLevenstein ( string const & input ) {		    int getLevenstein ( string inpt ) {				  script_not_found : None
    revInput = inpt [ : : - 1 ]				      	string revInput ( input . rbegin ( ) , input . rend ( ) ) ;   string revInput = inpt . substr ( 0 , inpt . length ( ) - 1 
    n = len ( inpt )					      	int n = input . size ( ) ;				      int n = inpt . length ( ) ;				  
    dp = [ [ - 1 for _ in range ( n + 1 ) ] for __ in range ( 	vector < vector < int >> dp ( n + 1 , vector < int > ( n +    vector < vector < int >> dp ( n + 1 , vector < int > ( n +  
    for i in range ( n + 1 ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	dp [ 0 ] [ i ] = i				      	i <= n ;						      i < n + 1 ;						  
	dp [ i ] [ 0 ] = i				      	++ i ) {						      i ++ ) {							  
    for i in range ( 1 , n + 1 ) :			      	  dp [ 0 ] [ i ] = i ;					    	dp [ 0 ] [ i ] = i ;					  
	for j in range ( 1 , n + 1 ) :			      	  dp [ i ] [ 0 ] = i ;					    	dp [ i ] [ 0 ] = i ;					  
	    if inpt [ i - 1 ] == revInput [ j - 1 ] :	      	}							      }								  
		dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ]	      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	    else :					      	i <= n ;						      i <= n ;							  
		dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] 	++ i ) {						      i ++ ) {							  
    res = INT_MAX					      	  for ( int j = 1 ;					    	for ( int j = 1 ;					  
    i , j = n , 0					      	  j <= n ;						    	j <= n ;						  
    while i >= 0 :					      	  ++ j ) {						    	j ++ ) {						  
	res = min ( res , dp [ i ] [ j ] )		      	    if ( input [ i - 1 ] == revInput [ j - 1 ] ) dp [ i ] [ 	  if ( inpt [ i - 1 ] == revInput [ j - 1 ] ) dp [ i ] [  
	if i < n :					      	    else dp [ i ] [ j ] = 1 + min ( {			    	  else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp 
	    res = min ( res , dp [ i + 1 ] [ j ] )	      	      dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] }		    	}							  
	if i > 0 :					      	      ) ;						      }								  
	    res = min ( res , dp [ i - 1 ] [ j ] )	      	    }							      int res = INT_MAX ;					  
	i -= 1						      	  }							      int i = n , j = 0 ;					  
	j += 1						      	  int res = numeric_limits < int > :: max ( ) ;		      while ( i >= 0 ) {					  
    return res						      	  for ( int i = n , j = 0 ;				    	res = min ( res , dp [ i ] [ j ] ) ;			  
							      	  i >= 0 ;						    	if ( i < n ) res = min ( res , dp [ i + 1 ] [ j ] ) ;	  
							      	  -- i , ++ j ) {					    	if ( i > 0 ) res = min ( res , dp [ i - 1 ] [ j ] ) ;	  
							      	    res = min ( res , dp [ i ] [ j ] ) ;		    	i -- ;							  
							      	    if ( i < n ) res = min ( res , dp [ i + 1 ] [ j ] ) ;   	j ++ ;							  
							      	    if ( i > 0 ) res = min ( res , dp [ i - 1 ] [ j ] ) ;     }								  
							      	  }							      return res ;						  
							      	  return res ;						      return n * n ;						  
							      	}							    }								  
-							      	-							    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING	      DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING	    DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING		  DYNAMIC_PROGRAMMING_SET_17_PALINDROME_PARTITIONING
--							      --							    --								  --
def minPalPartion ( str ) :				      int minPalPartion ( char * str ) {			    int minPalPartion ( string str ) {				  script_not_found : None
    n = len ( str )					      	int n = strlen ( str ) ;				      int n = str . length ( ) ;				  
    C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]   	int C [ n ] [ n ] ;					      vector < vector < int >> C ( n , vector < int > ( n , 0 ) ) 
    P = [ [ False for i in range ( n ) ] for i in range ( n ) 	bool P [ n ] [ n ] ;					      vector < vector < bool >> P ( n , vector < bool > ( n , fal 
    j = 0						      	int i , j , k , L ;					      int j ;							  
    k = 0						      	for ( i = 0 ;						      int k ;							  
    L = 0						      	i < n ;							      int L ;							  
    for i in range ( n ) :				      	i ++ ) {						      for ( int i = 0 ;						  
	P [ i ] [ i ] = True				      	  P [ i ] [ i ] = true ;				      i < n ;							  
	C [ i ] [ i ] = 0				      	  C [ i ] [ i ] = 0 ;					      i ++ ) {							  
    for L in range ( 2 , n + 1 ) :			      	}							    	P [ i ] [ i ] = true ;					  
	for i in range ( n - L + 1 ) :			      	for ( L = 2 ;						    	C [ i ] [ i ] = 0 ;					  
	    j = i + L - 1				      	L <= n ;						      }								  
	    if L == 2 :					      	L ++ ) {						      for ( L = 2 ;						  
		P [ i ] [ j ] = ( str [ i ] == str [ j ] )    	  for ( i = 0 ;						      L <= n ;							  
	    else :					      	  i < n - L + 1 ;					      L ++ ) {							  
		P [ i ] [ j ] = ( ( str [ i ] == str [ j ] )  	  i ++ ) {						    	for ( int i = 0 ;					  
	    if P [ i ] [ j ] == True :			      	    j = i + L - 1 ;					    	i < n - L + 1 ;						  
		C [ i ] [ j ] = 0			      	    if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ]  	i ++ ) {						  
	    else :					      	    else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [  	  j = i + L - 1 ;					  
		C [ i ] [ j ] = 100000000		      	    if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ;	    	  if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ]  
		for k in range ( i , j ) :		      	    else {						    	  else P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) && P  
		    C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ 	      C [ i ] [ j ] = INT_MAX ;				    	  if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ;	  
    return C [ 0 ] [ n - 1 ]				      	      for ( k = i ;					    	  else {						  
							      	      k <= j - 1 ;					    	    C [ i ] [ j ] = 100000000 ;				  
							      	      k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ]  	    for ( k = i ;					  
							      	    }							    	    k < j ;						  
							      	  }							    	    k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ]  
							      	}							    	  }							  
							      	return C [ 0 ] [ n - 1 ] ;				    	}							  
							      }								      }								  
							      								      return C [ 0 ] [ n - 1 ] ;				  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS	      REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS	    REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS	  REMOVE_BRACKETS_ALGEBRAIC_STRING_CONTAINING_OPERATORS
--							      --							    --								  --
def simplify ( Str ) :					      char * simplify ( string str ) {				    string simplify ( string Str ) {				  script_not_found : None
    Len = len ( Str )					      	int len = str . length ( ) ;				      int Len = Str . length ( ) ;				  
    res = [ None ] * Len				      	char * res = new char ( len ) ;				      string res ;						  
    index = 0						      	int index = 0 , i = 0 ;					      res . reserve ( Len ) ;					  
    i = 0						      	stack < int > s ;					      int index = 0 ;						  
    s = [ ]						      	s . push ( 0 ) ;					      int i = 0 ;						  
    s.append ( 0 )					      	while ( i < len ) {					      string :: size_type pos = 0 ;				  
    while ( i < Len ) :					      	  if ( str [ i ] == '+' ) {				      while ( ( i < Len ) && ( pos < 0 ) ) {			  
	if ( Str [ i ] == '+' ) :			      	    if ( s . top ( ) == 1 ) res [ index ++ ] = '-' ;	    	if ( ( Str [ pos ] == '+' ) ) {				  
	    if ( s [ - 1 ] == 1 ) :			      	    if ( s . top ( ) == 0 ) res [ index ++ ] = '+' ;	    	  if ( ( pos - 1 ) == 1 ) {				  
		res [ index ] = '-'			      	  }							    	    res [ index ] = '-' ;				  
		index += 1				      	  else if ( str [ i ] == '-' ) {			    	    index ++ ;						  
	    if ( s [ - 1 ] == 0 ) :			      	    if ( s . top ( ) == 1 ) res [ index ++ ] = '+' ;	    	  }							  
		res [ index ] = '+'			      	    else if ( s . top ( ) == 0 ) res [ index ++ ] = '-' ;   	  if ( ( pos - 1 ) == 0 ) {				  
		index += 1				      	  }							    	    res [ index ] = '+' ;				  
	elif ( Str [ i ] == '-' ) :			      	  else if ( str [ i ] == '(' && i > 0 ) {		    	    index ++ ;						  
	    if ( s [ - 1 ] == 1 ) :			      	    if ( str [ i - 1 ] == '-' ) {			    	  }							  
		res [ index ] = '+'			      	      int x = ( s . top ( ) == 1 ) ? 0 : 1 ;		    	}							  
		index += 1				      	      s . push ( x ) ;					    	else if ( ( Str [ pos ] == '-' ) ) {			  
	    elif ( s [ - 1 ] == 0 ) :			      	    }							    	  if ( ( pos - 1 ) == 1 ) {				  
		res [ index ] = '-'			      	    else if ( str [ i - 1 ] == '+' ) s . push ( s . top ( ) 	    res [ index ] = '+' ;				  
		index += 1				      	  }							    	    index ++ ;						  
	elif ( Str [ i ] == '(' and i > 0 ) :		      	  else if ( str [ i ] == ')' ) s . pop ( ) ;		    	  }							  
	    if ( Str [ i - 1 ] == '-' ) :		      	  else res [ index ++ ] = str [ i ] ;			    	  else if ( ( pos - 1 ) == 0 ) {			  
		x = 0 if ( s [ - 1 ] == 1 ) else 1	      	  i ++ ;						    	    res [ index ] = '-' ;				  
		s.append ( x )				      	}							    	    index ++ ;						  
	    elif ( Str [ i - 1 ] == '+' ) :		      	return res ;						    	  }							  
		s.append ( s [ - 1 ] )			      }								    	}							  
	elif ( Str [ i ] == ')' ) :			      								    	else if ( ( Str [ pos ] == '(' ) && ( i > 0 ) ) {	  
	    s.pop ( )					      								    	  if ( ( Str [ i - 1 ] == '-' ) ) {			  
	else :						      								    	    int x = ( pos - 1 ) == 1 ? 0 : 1 ;			  
	    res [ index ] = Str [ i ]			      								    	    res [ index ] = x ;					  
	    index += 1					      								    	  }							  
	i += 1						      								    	  else if ( ( Str [ i - 1 ] == '+' ) ) {		  
    return res						      								    	    res [ index ] = s [ pos - 1 ] ;			  
							      								    	  }							  
							      								    	}							  
							      								    	else if ( ( Str [ pos ] == ')' ) {			  
							      								    	  pos -- ;						  
							      								    	}							  
							      								    	else {							  
							      								    	  res [ index ] = Str [ pos ] ;				  
							      								    	  index ++ ;						  
							      								    	}							  
							      								      }								  
							      								      i ++ ;							  
							      								    }								  
							      								    return res ;						  
							      								    return " " + Str + " " + Str ;				  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    return " " + Str + " " + Str ;				  
							      								    return " " + Str ;						  
							      								    return " " + Str + " " + Str ;				  
							      								    return " " + Str ;						  
							      								    return " " + Str + " " + Str + " " + Str ;			  
							      								    return " " + Str + " " + Str ;				  
							      								    return " " + Str ;						  
							      								    return " " + Str + " " + Str ;				  
							      								    return " " + Str + " " + Str + " " + Str ;			  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
-							      -								    return " "-							  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER	      COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER		    COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER		  COUNT_ARRAYS_ADJACENT_ELEMENTS_ONE_DIVIDE_ANOTHER
--							      --							    --								  --
def numofArray ( n , m ) :				      int numofArray ( int n , int m ) {			    int numofArray ( int n , int m ) {				  script_not_found : None
    dp = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX  	int dp [ MAX ] [ MAX ] ;				      vector < vector < int >> dp ( MAX , vector < int > ( MAX ,  
    di = [ [ ] for i in range ( MAX ) ]			      	vector < int > di [ MAX ] ;				      for ( int j = 0 ;						  
    mu = [ [ ] for i in range ( MAX ) ]			      	vector < int > mu [ MAX ] ;				      j < MAX ;							  
    for i in range ( 1 , m + 1 ) :			      	memset ( dp , 0 , sizeof dp ) ;				      j ++ ) dp [ j ] . reserve ( MAX ) ;			  
	for j in range ( 2 * i , m + 1 , i ) :		      	memset ( di , 0 , sizeof di ) ;				      vector < vector < int >> di ( MAX , vector < int > ( MAX ,  
	    di [ j ].append ( i )			      	memset ( mu , 0 , sizeof mu ) ;				      vector < vector < int >> mu ( MAX , vector < int > ( MAX ,  
	    mu [ i ].append ( j )			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	di [ i ].append ( i )				      	i <= m ;						      i <= m ;							  
    for i in range ( 1 , m + 1 ) :			      	i ++ ) {						      i ++ ) {							  
	dp [ 1 ] [ i ] = 1				      	  for ( int j = 2 * i ;					    	for ( int j = 2 * i ;					  
    for i in range ( 2 , n + 1 ) :			      	  j <= m ;						    	j <= m + 1 ;						  
	for j in range ( 1 , m + 1 ) :			      	  j += i ) {						    	j += i ) {						  
	    dp [ i ] [ j ] = 0				      	    di [ j ] . push_back ( i ) ;			    	  di [ j ] . push_back ( i ) ;				  
	    for x in di [ j ] :				      	    mu [ i ] . push_back ( j ) ;			    	  mu [ i ] . push_back ( j ) ;				  
		dp [ i ] [ j ] += dp [ i - 1 ] [ x ]	      	  }							    	}							  
	    for x in mu [ j ] :				      	  di [ i ] . push_back ( i ) ;				    	di [ i ] . push_back ( i ) ;				  
		dp [ i ] [ j ] += dp [ i - 1 ] [ x ]	      	}							      }								  
    ans = 0						      	for ( int i = 1 ;					      for ( int i = 1 ;						  
    for i in range ( 1 , m + 1 ) :			      	i <= m ;						      i <= m ;							  
	ans += dp [ n ] [ i ]				      	i ++ ) dp [ 1 ] [ i ] = 1 ;				      i ++ ) dp [ 1 ] [ i ] = 1 ;				  
	di [ i ].clear ( )				      	for ( int i = 2 ;					      for ( int i = 2 ;						  
	mu [ i ].clear ( )				      	i <= n ;						      i <= n ;							  
    return ans						      	i ++ ) {						      i ++ ) {							  
							      	  for ( int j = 1 ;					    	for ( int j = 1 ;					  
							      	  j <= m ;						    	j <= m ;						  
							      	  j ++ ) {						    	j ++ ) {						  
							      	    dp [ i ] [ j ] = 0 ;				    	  dp [ i ] [ j ] = 0 ;					  
							      	    for ( auto x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1  	  for ( int x = 0 ;					  
							      	    for ( auto x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1  	  x < di [ j ] . size ( ) ;				  
							      	  }							    	  x ++ ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;		  
							      	}							    	  for ( int x = 0 ;					  
							      	int ans = 0 ;						    	  x < mu [ j ] . size ( ) ;				  
							      	for ( int i = 1 ;					    	  x ++ ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ;		  
							      	i <= m ;						    	}							  
							      	i ++ ) {						      }								  
							      	  ans += dp [ n ] [ i ] ;				      int ans = 0 ;						  
							      	  di [ i ] . clear ( ) ;				      for ( int i = 1 ;						  
							      	  mu [ i ] . clear ( ) ;				      i <= m ;							  
							      	}							      i ++ ) {							  
							      	return ans ;						    	ans += dp [ n ] [ i ] ;					  
							      }								    	di [ i ] . clear ( ) ;					  
							      								    	mu [ i ] . clear ( ) ;					  
							      								      }								  
							      								      return ans ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP MINIMUM_LENGTH_UNSORTED_SUBARRAY_SORTING_WHICH_MAKES_THE_COMP
--							      --							    --								  --
def printUnsorted ( arr , n ) :				      void printUnsorted ( int arr [ ] , int n ) {		    int printUnsorted ( int * arr , int n ) {			  script_not_found : None
    e = n - 1						      	int s = 0 , e = n - 1 , i , max , min ;			      int e = n - 1 ;						  
    for s in range ( 0 , n - 1 ) :			      	for ( s = 0 ;						      for ( int s = 0 ;						  
	if arr [ s ] > arr [ s + 1 ] :			      	s < n - 1 ;						      s <= n - 1 ;						  
	    break					      	s ++ ) {						      s ++ ) {							  
    if s == n - 1 :					      	  if ( arr [ s ] > arr [ s + 1 ] ) break ;		    	if ( arr [ s ] > arr [ s + 1 ] ) break ;		  
	print ( "The complete array is sorted" )	      	}							      }								  
	exit ( )					      	if ( s == n - 1 ) {					      if ( s == n - 1 ) {					  
    e = n - 1						      	  cout << "The complete array is sorted" ;		    	cout << "The complete array is sorted" << endl ;	  
    while e > 0 :					      	  return ;						    	exit ( 0 ) ;						  
	if arr [ e ] < arr [ e - 1 ] :			      	}							      }								  
	    break					      	for ( e = n - 1 ;					      e = n - 1 ;						  
	e -= 1						      	e > 0 ;							      while ( e > 0 ) {						  
    max = arr [ s ]					      	e -- ) {						    	if ( arr [ e ] < arr [ e - 1 ] ) break ;		  
    min = arr [ s ]					      	  if ( arr [ e ] < arr [ e - 1 ] ) break ;		    	e -- ;							  
    for i in range ( s + 1 , e + 1 ) :			      	}							      }								  
	if arr [ i ] > max :				      	max = arr [ s ] ;					      int max = arr [ s ] ;					  
	    max = arr [ i ]				      	min = arr [ s ] ;					      int min = arr [ s ] ;					  
	if arr [ i ] < min :				      	for ( i = s + 1 ;					      for ( int i = s + 1 ;					  
	    min = arr [ i ]				      	i <= e ;						      i <= e ;							  
    for i in range ( s ) :				      	i ++ ) {						      i ++ ) {							  
	if arr [ i ] > min :				      	  if ( arr [ i ] > max ) max = arr [ i ] ;		    	if ( arr [ i ] > max ) max = arr [ i ] ;		  
	    s = i					      	  if ( arr [ i ] < min ) min = arr [ i ] ;		    	if ( arr [ i ] < min ) min = arr [ i ] ;		  
	    break					      	}							      }								  
    i = n - 1						      	for ( i = 0 ;						      for ( int i = 0 ;						  
    while i >= e + 1 :					      	i < s ;							      i < s ;							  
	if arr [ i ] < max :				      	i ++ ) {						      i ++ ) {							  
	    e = i					      	  if ( arr [ i ] > min ) {				    	if ( arr [ i ] > min ) {				  
	    break					      	    s = i ;						    	  s = i ;						  
	i -= 1						      	    break ;						    	  break ;						  
    print ( "The unsorted subarray which makes the given arra 	  }							    	}							  
    print ( "sorted lies between the indexes %d and %d" % ( s 	}							      }								  
							      	for ( i = n - 1 ;					      int i = n - 1 ;						  
							      	i >= e + 1 ;						      while ( i >= e + 1 ) {					  
							      	i -- ) {						    	if ( arr [ i ] < max ) {				  
							      	  if ( arr [ i ] < max ) {				    	  e = i ;						  
							      	    e = i ;						    	  break ;						  
							      	    break ;						    	}							  
							      	  }							    	i -- ;							  
							      	}							      }								  
							      	cout << "The unsorted subarray which" << " makes the given    cout << "The unsorted subarray which makes the given array" 
							      	return ;						      cout << "sorted lies between the indexes " << s << " and "  
							      }								    }								  
							      								    return s ;							  
							      								    return n * n ;						  
							      								    return n * n ;						  
							      								    return n * n ;						  
							      								    return n * n ;						  
							      								    return n * n ;						  
							      								    return n * n * n * n * n * n * n * n * n * n * n * n * n * n  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PARTITION_NUMBER_TWO_DIVISBLE_PARTS			      PARTITION_NUMBER_TWO_DIVISBLE_PARTS			    PARTITION_NUMBER_TWO_DIVISBLE_PARTS				  PARTITION_NUMBER_TWO_DIVISBLE_PARTS
--							      --							    --								  --
def findDivision ( str , a , b ) :			      void findDivision ( string & str , int a , int b ) {	    int findDivision ( string str , int a , int b ) {		  script_not_found : None
    lenn = len ( str )					      	int len = str . length ( ) ;				      int lenn = str . length ( ) ;				  
    lr = [ 0 ] * ( lenn + 1 )				      	vector < int > lr ( len + 1 , 0 ) ;			      vector < int > lr ( lenn + 1 , 0 ) ;			  
    lr [ 0 ] = ( int ( str [ 0 ] ) ) % a		      	lr [ 0 ] = ( str [ 0 ] - '0' ) % a ;			      lr [ 0 ] = ( ( int ) str [ 0 ] ) % a ;			  
    for i in range ( 1 , lenn ) :			      	for ( int i = 1 ;					      for ( int i = 1 ;						  
	lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + \ int ( str  	i < len ;						      i < lenn ;						  
    rl = [ 0 ] * ( lenn + 1 )				      	i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( str [ i ]   i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + int ) str [ 
    rl [ lenn - 1 ] = int ( str [ lenn - 1 ] ) % b	      	vector < int > rl ( len + 1 , 0 ) ;			      vector < int > rl ( lenn + 1 , 0 ) ;			  
    power10 = 10					      	rl [ len - 1 ] = ( str [ len - 1 ] - '0' ) % b ;	      rl [ lenn - 1 ] = ( int ) str [ lenn - 1 ] % b ;		  
    for i in range ( lenn - 2 , - 1 , - 1 ) :		      	int power10 = 10 ;					      int power10 = 10 ;					  
	rl [ i ] = ( rl [ i + 1 ] + int ( str [ i ] ) * power 	for ( int i = len - 2 ;					      for ( int i = lenn - 2 ;					  
	power10 = ( power10 * 10 ) % b			      	i >= 0 ;						      i >= 0 ;							  
    for i in range ( 0 , lenn - 1 ) :			      	i -- ) {						      i -- ) {							  
	if ( lr [ i ] != 0 ) :				      	  rl [ i ] = ( rl [ i + 1 ] + ( str [ i ] - '0' ) * power10 	rl [ i ] = ( rl [ i + 1 ] + ( int ) str [ i ] * power10 ) 
	    continue					      	  power10 = ( power10 * 10 ) % b ;			    	power10 = ( power10 * 10 ) % b ;			  
	if ( rl [ i + 1 ] == 0 ) :			      	}							      }								  
	    print ( "YES" )				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	    for k in range ( 0 , i + 1 ) :		      	i < len - 1 ;						      i <= lenn - 1 ;						  
		print ( str [ k ] , end = "" )		      	i ++ ) {						      i ++ ) {							  
	    print ( "," , end = "" )			      	  if ( lr [ i ] != 0 ) continue ;			    	if ( ( lr [ i ] != 0 ) ) continue ;			  
	    for i in range ( i + 1 , lenn ) :		      	  if ( rl [ i + 1 ] == 0 ) {				    	if ( ( rl [ i + 1 ] == 0 ) ) {				  
		print ( str [ k ] , end = "" )		      	    cout << "YES\n" ;					    	  cout << "YES" ;					  
		return					      	    for ( int k = 0 ;					    	  for ( int k = 0 ;					  
    print ( "NO" )					      	    k <= i ;						    	  k <= i + 1 ;						  
							      	    k ++ ) cout << str [ k ] ;				    	  k ++ ) cout << str [ k ] << " " ;			  
							      	    cout << ", " ;					    	  cout << "," << endl ;					  
							      	    for ( int k = i + 1 ;				    	  for ( int i = i + 1 ;					  
							      	    k < len ;						    	  i + 1 < lenn ;					  
							      	    k ++ ) cout << str [ k ] ;				    	  i ++ ) {						  
							      	    return ;						    	    cout << str [ k ] << " " ;				  
							      	  }							    	    return i ;						  
							      	}							    	  }							  
							      	cout << "NO\n" ;					    	}							  
							      }								      }								  
							      								      cout << "NO" << endl ;					  
							      								      return lenn ;						  
							      								      return lenn * lenn ;					  
							      								      return lenn * lenn * lenn * lenn * lenn * lenn * lenn * len 
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K		      SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K		    SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K		  SUM_MINIMUM_MAXIMUM_ELEMENTS_SUBARRAYS_SIZE_K
--							      --							    --								  --
def SumOfKsubArray ( arr , n , k ) :			      int SumOfKsubArray ( int arr [ ] , int n , int k ) {	    int SumOfKsubArray ( int * arr , int n , int k ) {		  script_not_found : None
    Sum = 0						      	int sum = 0 ;						      int Sum = 0 ;						  
    S = deque ( )					      	deque < int > S ( k ) , G ( k ) ;			      deque < int > S ;						  
    G = deque ( )					      	int i = 0 ;						      deque < int > G ;						  
    for i in range ( k ) :				      	for ( i = 0 ;						      for ( int i = 0 ;						  
	while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [  	i < k ;							      i < k ;							  
	    S.pop ( )					      	i ++ ) {						      i ++ ) {							  
	while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [  	  while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= ar 	while ( ( S . size ( ) > 0 ) && arr [ S [ S . size ( ) -  
	    G.pop ( )					      	  while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= ar 	while ( ( G . size ( ) > 0 ) && arr [ G [ G . size ( ) -  
	G.append ( i )					      	  G . push_back ( i ) ;					    	G . push_back ( i ) ;					  
	S.append ( i )					      	  S . push_back ( i ) ;					    	S . push_back ( i ) ;					  
    for i in range ( k , n ) :				      	}							      }								  
	Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ]	      	for ( ;							      for ( int i = k ;						  
	while ( len ( S ) > 0 and S [ 0 ] <= i - k ) :	      	i < n ;							      i < n ;							  
	    S.popleft ( )				      	i ++ ) {						      i ++ ) {							  
	while ( len ( G ) > 0 and G [ 0 ] <= i - k ) :	      	  sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ;    	Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] ;		  
	    G.popleft ( )				      	  while ( ! S . empty ( ) && S . front ( ) <= i - k ) S . p 	while ( ( S . size ( ) > 0 ) && S [ 0 ] <= i - k ) S . po 
	while ( len ( S ) > 0 and arr [ S [ - 1 ] ] >= arr [  	  while ( ! G . empty ( ) && G . front ( ) <= i - k ) G . p 	while ( ( G . size ( ) > 0 ) && G [ 0 ] <= i - k ) G . po 
	    S.pop ( )					      	  while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= ar 	while ( ( S . size ( ) > 0 ) && arr [ S [ S . size ( ) -  
	while ( len ( G ) > 0 and arr [ G [ - 1 ] ] <= arr [  	  while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= ar 	while ( ( G . size ( ) > 0 ) && arr [ G [ G . size ( ) -  
	    G.pop ( )					      	  G . push_back ( i ) ;					    	G . push_back ( i ) ;					  
	G.append ( i )					      	  S . push_back ( i ) ;					    	S . push_back ( i ) ;					  
	S.append ( i )					      	}							      }								  
    Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ]		      	sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ;	      Sum += arr [ S [ 0 ] ] + arr [ G [ 0 ] ] ;		  
    return Sum						      	return sum ;						      return Sum ;						  
							      }								      return n * n ;						  
							      								      return n * n ;						  
-							      -								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERIAN_PATH_UNDIRECTED_GRAPH				      EULERIAN_PATH_UNDIRECTED_GRAPH				    EULERIAN_PATH_UNDIRECTED_GRAPH				  EULERIAN_PATH_UNDIRECTED_GRAPH
--							      --							    --								  --
def findpath ( graph ) :				      void findpath ( int graph [ ] [ 5 ] , int n ) {		    int findpath ( vector < int > graph ) {			  script_not_found : None
    n = len ( graph )					      	vector < int > numofadj ;				      int n = graph . size ( ) ;				  
    numofadj = list ( )					      	for ( int i = 0 ;					      vector < int > numofadj ;					  
    for i in range ( n ) :				      	i < n ;							      for ( int i = 0 ;						  
	numofadj.append ( sum ( graph [ i ] ) )		      	i ++ ) numofadj . push_back ( accumulate ( graph [ i ] , gr   i < n ;							  
    startpoint = 0					      	int startpoint = 0 , numofodd = 0 ;			      i ++ ) numofadj . push_back ( sum ( graph [ i ] ) ) ;	  
    numofodd = 0					      	for ( int i = n - 1 ;					      int startpoint = 0 ;					  
    for i in range ( n - 1 , - 1 , - 1 ) :		      	i >= 0 ;						      int numofodd = 0 ;					  
	if ( numofadj [ i ] % 2 == 1 ) :		      	i -- ) {						      for ( int i = n - 1 ;					  
	    numofodd += 1				      	  if ( numofadj [ i ] % 2 == 1 ) {			      i >= 0 ;							  
	    startpoint = i				      	    numofodd ++ ;					      i -- ) {							  
    if ( numofodd > 2 ) :				      	    startpoint = i ;					    	if ( ( numofadj [ i ] % 2 == 1 ) ) {			  
	print ( "No Solution" )				      	  }							    	  numofodd ++ ;						  
	return						      	}							    	  startpoint = i ;					  
    stack = list ( )					      	if ( numofodd > 2 ) {					    	}							  
    path = list ( )					      	  cout << "No Solution" << endl ;			      }								  
    cur = startpoint					      	  return ;						      if ( ( numofodd > 2 ) ) {					  
    while ( stack != [ ] or sum ( graph [ cur ] ) != 0 ) :    	}							    	cout << "No Solution" << endl ;				  
	if ( sum ( graph [ cur ] ) == 0 ) :		      	stack < int > stack ;					    	return 0 ;						  
	    path.append ( cur + 1 )			      	vector < int > path ;					      }								  
	    cur = stack.pop ( - 1 )			      	int cur = startpoint ;					      vector < int > stack ;					  
	else :						      	while ( ! stack . empty ( ) or accumulate ( graph [ cur ] ,   stack . reserve ( n ) ;					  
	    for i in range ( n ) :			      	  if ( accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 )   stack . push_back ( startpoint ) ;			  
		if graph [ cur ] [ i ] == 1 :		      	    path . push_back ( cur ) ;				      while ( ( stack . size ( ) != n || sum ( graph [ cur ] ) != 
		    stack.append ( cur )		      	    cur = stack . top ( ) ;				    	if ( ( sum ( graph [ cur ] ) == 0 ) ) {			  
		    graph [ cur ] [ i ] = 0		      	    stack . pop ( ) ;					    	  stack . push_back ( cur + 1 ) ;			  
		    graph [ i ] [ cur ] = 0		      	  }							    	  cur = stack . back ( ) - 1 ;				  
		    cur = i				      	  else {						    	}							  
		    break				      	    for ( int i = 0 ;					    	else {							  
    for ele in path :					      	    i < n ;						    	  for ( int i = 0 ;					  
	print ( ele , "-> " , end = '' )		      	    i ++ ) {						    	  i < n ;						  
    print ( cur + 1 )					      	      if ( graph [ cur ] [ i ] == 1 ) {			    	  i ++ ) {						  
							      		stack . push ( cur ) ;				    	    if ( graph [ cur ] [ i ] == 1 ) {			  
							      		graph [ cur ] [ i ] = 0 ;			    	      stack . push_back ( cur ) ;			  
							      		graph [ i ] [ cur ] = 0 ;			    	      graph [ cur ] [ i ] = 0 ;				  
							      		cur = i ;					    	      graph [ i ] [ cur ] = 0 ;				  
							      		break ;						    	      cur = i ;						  
							      	      }							    	      break ;						  
							      	    }							    	    }							  
							      	  }							    	  }							  
							      	}							    	}							  
							      	for ( auto ele : path ) cout << ele << " -> " ;		      }								  
							      	cout << cur << endl ;					      for ( int ele : stack ) cout << ele << "-> " << endl ;	  
							      }								      cout << cur + 1 << endl ;					  
							      								      return 0 ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_PALINDROME_SUB_STRINGS_STRING			      COUNT_PALINDROME_SUB_STRINGS_STRING			    COUNT_PALINDROME_SUB_STRINGS_STRING				  COUNT_PALINDROME_SUB_STRINGS_STRING
--							      --							    --								  --
def CountPS ( str , n ) :				      int CountPS ( char str [ ] , int n ) {			    int CountPS ( string str , int n ) {			  error : COUNT_PALINDROME_SUB_STRINGS_STRING.cpp: I
    dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ]  	int dp [ n ] [ n ] ;					      vector < vector < int >> dp ( n , vector < int > ( n , 0 )  n function ‘int f_filled(std::__cxx11::string, int
    P = [ [ False for x in range ( n ) ] for y in range ( n ) 	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int y = 0 ;						  )’: COUNT_PALINDROME_SUB_STRINGS_STRING.cpp:88:12:
    for i in range ( n ) :				      	bool P [ n ] [ n ] ;					      y < n ;							   error: a function-definition is not allowed here
	P [ i ] [ i ] = True				      	memset ( P , false , sizeof ( P ) ) ;			      y ++ ) dp [ y ] . resize ( n ) ;				  before ‘{’ token  int main() {	     ^ COUNT
    for i in range ( n - 1 ) :				      	for ( int i = 0 ;					      vector < vector < bool >> P ( n , vector < bool > ( n , fal _PALINDROME_SUB_STRINGS_STRING.cpp:101:1: error: e
	if ( str [ i ] == str [ i + 1 ] ) :		      	i < n ;							      for ( int i = 0 ;						  xpected ‘}’ at end of input  }  ^ COUNT_PALINDROME
	    P [ i ] [ i + 1 ] = True			      	i ++ ) P [ i ] [ i ] = true ;				      i < n ;							  _SUB_STRINGS_STRING.cpp:48:37: note: to match this
	    dp [ i ] [ i + 1 ] = 1			      	for ( int i = 0 ;					      i ++ ) P [ i ] [ i ] = true ;				   ‘{’	int f_filled ( string str , int n ) {
    for gap in range ( 2 , n ) :			      	i < n - 1 ;						      for ( int i = 0 ;						  				 ^
	for i in range ( n - gap ) :			      	i ++ ) {						      i < n - 1 ;						  
	    j = gap + i ;				      	  if ( str [ i ] == str [ i + 1 ] ) {			      i ++ ) {							  
	    if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 	    P [ i ] [ i + 1 ] = true ;				    	if ( ( str [ i ] == str [ i + 1 ] ) ) {			  
		P [ i ] [ j ] = True			      	    dp [ i ] [ i + 1 ] = 1 ;				    	  P [ i ] [ i + 1 ] = true ;				  
	    if ( P [ i ] [ j ] == True ) :		      	  }							    	  dp [ i ] [ i + 1 ] = 1 ;				  
		dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [  	}							    	}							  
	    else :					      	for ( int gap = 2 ;					      }								  
		dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [  	gap < n ;						      for ( int gap = 2 ;					  
    return dp [ 0 ] [ n - 1 ]				      	gap ++ ) {						      gap < n ;							  
							      	  for ( int i = 0 ;					      gap ++ ) {						  
							      	  i < n - gap ;						    	for ( int i = 0 ;					  
							      	  i ++ ) {						    	i < n - gap ;						  
							      	    int j = gap + i ;					    	i ++ ) {						  
							      	    if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] )  	  int j = gap + i ;					  
							      	    if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ]  	  ;							  
							      	    else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] 	  if ( ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1  
							      	  }							    	  if ( ( P [ i ] [ j ] == true ) ) dp [ i ] [ j ] = ( dp  
							      	}							    	  else dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 
							      	return dp [ 0 ] [ n - 1 ] ;				    	}							  
							      }								      }								  
							      								      return dp [ 0 ] [ n - 1 ] ;				  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
COUNT_ROTATIONS_DIVISIBLE_8				      COUNT_ROTATIONS_DIVISIBLE_8				    COUNT_ROTATIONS_DIVISIBLE_8					  COUNT_ROTATIONS_DIVISIBLE_8
--							      --							    --								  --
def countRotationsDivBy8 ( n ) :			      int countRotationsDivBy8 ( string n ) {			    int countRotationsDivBy8 ( string n ) {			  error : COUNT_ROTATIONS_DIVISIBLE_8.cpp: In functi
    l = len ( n )					      	int len = n . length ( ) ;				      int l = n . length ( ) ;					  on ‘int f_filled(std::__cxx11::string)’: COUNT_ROT
    count = 0						      	int count = 0 ;						      int count = 0 ;						  ATIONS_DIVISIBLE_8.cpp:50:37: error: request for m
    if ( l == 1 ) :					      	if ( len == 1 ) {					      if ( ( l == 1 ) ) {					  ember ‘c_str’ in ‘n.std::__cxx11::basic_string<cha
	oneDigit = int ( n [ 0 ] )			      	  int oneDigit = n [ 0 ] - '0' ;			    	int oneDigit = atoi ( n [ 0 ] . c_str ( ) ) ;		  r>::operator[](0)’, which is of non-class type ‘__
	if ( oneDigit % 8 == 0 ) :			      	  if ( oneDigit % 8 == 0 ) return 1 ;			    	if ( ( oneDigit % 8 == 0 ) ) return 1 ;			  gnu_cxx::__alloc_traits<std::allocator<char>, char
	    return 1					      	  return 0 ;						    	return 0 ;						  >::value_type’ {aka ‘char’}	   int oneDigit = at
	return 0					      	}							      }								  oi ( n [ 0 ] . c_str ( ) ) ;
    if ( l == 2 ) :					      	if ( len == 2 ) {					      if ( ( l == 2 ) ) {					  		  ^~~~~ COUNT_ROTATIONS_DIVISIBLE_8.
	first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] )	      	  int first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ;  	int first = atoi ( n [ 0 ] . c_str ( ) ) * 10 + atoi ( n  cpp:55:34: error: request for member ‘c_str’ in ‘n
	second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] )	      	  int second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; 	int second = atoi ( n [ 1 ] . c_str ( ) ) * 10 + atoi ( n .std::__cxx11::basic_string<char>::operator[](0)’,
	if ( first % 8 == 0 ) :				      	  if ( first % 8 == 0 ) count ++ ;			    	if ( ( first % 8 == 0 ) ) count ++ ;			   which is of non-class type ‘__gnu_cxx::__alloc_tr
	    count += 1					      	  if ( second % 8 == 0 ) count ++ ;			    	if ( ( second % 8 == 0 ) ) count ++ ;			  aits<std::allocator<char>, char>::value_type’ {aka
	if ( second % 8 == 0 ) :			      	  return count ;					    	return count ;						   ‘char’}	int first = atoi ( n [ 0 ] . c_str (
	    count += 1					      	}							      }								   ) ) * 10 + atoi ( n [ 1 ] . c_str ( ) ) ;
	return count					      	int threeDigit ;					      int threeDigit = 0 ;					  			     ^~~~~ COUNT_ROTATIONS_D
    threeDigit = 0					      	for ( int i = 0 ;					      for ( int i = 0 ;						  IVISIBLE_8.cpp:55:70: error: request for member ‘c
    for i in range ( 0 , ( l - 2 ) ) :			      	i < ( len - 2 ) ;					      i < ( l - 2 ) ;						  _str’ in ‘n.std::__cxx11::basic_string<char>::oper
	threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i +  	i ++ ) {						      i ++ ) {							  ator[](1)’, which is of non-class type ‘__gnu_cxx:
	if ( threeDigit % 8 == 0 ) :			      	  threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0 	threeDigit = ( atoi ( n [ i ] . c_str ( ) ) * 100 + atoi  :__alloc_traits<std::allocator<char>, char>::value
	    count += 1					      	  if ( threeDigit % 8 == 0 ) count ++ ;			    	if ( ( threeDigit % 8 == 0 ) ) count ++ ;		  _type’ {aka ‘char’}	   int first = atoi ( n [ 0
    threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ]  	}							      }								  ] . c_str ( ) ) * 10 + atoi ( n [ 1 ] . c_str ( )
    if ( threeDigit % 8 == 0 ) :			      	threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0   threeDigit = ( atoi ( n [ l - 1 ] . c_str ( ) ) * 100 + ato ) ;
	count += 1					      	if ( threeDigit % 8 == 0 ) count ++ ;			      if ( ( threeDigit % 8 == 0 ) ) count ++ ;			  			  ^~~~~ COUNT_ROTATIONS_DIVI
    threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l -  	threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1    threeDigit = ( atoi ( n [ l - 2 ] . c_str ( ) ) * 100 + ato SIBLE_8.cpp:56:35: error: request for member ‘c_st
    if ( threeDigit % 8 == 0 ) :			      	if ( threeDigit % 8 == 0 ) count ++ ;			      if ( ( threeDigit % 8 == 0 ) ) count ++ ;			  r’ in ‘n.std::__cxx11::basic_string<char>::operato
	count += 1					      	return count ;						      return count ;						  r[](1)’, which is of non-class type ‘__gnu_cxx::__
    return count					      }								    }								  alloc_traits<std::allocator<char>, char>::value_ty
							      								    								  pe’ {aka ‘char’}	int second = atoi ( n [ 1 ]
							      								    								  . c_str ( ) ) * 10 + atoi ( n [ 0 ] . c_str ( ) )
							      								    								  ;				       ^~~~~ COUNT_R
							      								    								  OTATIONS_DIVISIBLE_8.cpp:56:71: error: request for
							      								    								   member ‘c_str’ in ‘n.std::__cxx11::basic_string<c
							      								    								  har>::operator[](0)’, which is of non-class type ‘
							      								    								  __gnu_cxx::__alloc_traits<std::allocator<char>, ch
							      								    								  ar>::value_type’ {aka ‘char’}	     int second = at
							      								    								  oi ( n [ 1 ] . c_str ( ) ) * 10 + atoi ( n [ 0 ] .
							      								    								   c_str ( ) ) ;
							      								    								  				      ^~~~~ COUNT_RO
							      								    								  TATIONS_DIVISIBLE_8.cpp:65:37: error: request for
							      								    								  member ‘c_str’ in ‘n.std::__cxx11::basic_string<ch
							      								    								  ar>::operator[](((std::__cxx11::basic_string<char>
							      								    								  ::size_type)i))’, which is of non-class type ‘__gn
							      								    								  u_cxx::__alloc_traits<std::allocator<char>, char>:
							      								    								  :value_type’ {aka ‘char’}	 threeDigit = ( atoi
							      								    								   ( n [ i ] . c_str ( ) ) * 100 + atoi ( n [ i + 1
							      								    								  ] . c_str ( ) ) * 10 + atoi ( n [ i + 2 ] . c_str
							      								    								  ( ) ) ;				       ^~~~~
							      								    								   COUNT_ROTATIONS_DIVISIBLE_8.cpp:65:78: error: req
							      								    								  uest for member ‘c_str’ in ‘n.std::__cxx11::basic_
							      								    								  string<char>::operator[](((std::__cxx11::basic_str
							      								    								  ing<char>::size_type)(i + 1)))’, which is of non-c
							      								    								  lass type ‘__gnu_cxx::__alloc_traits<std::allocato
							      								    								  r<char>, char>::value_type’ {aka ‘char’}	thre
							      								    								  eDigit = ( atoi ( n [ i ] . c_str ( ) ) * 100 + at
							      								    								  oi ( n [ i + 1 ] . c_str ( ) ) * 10 + atoi ( n [ i
							      								    								   + 2 ] . c_str ( ) ) ;
							      								    								  
							      								    								   ^~~~~ COUNT_ROTATIONS_DIVISIBLE_8.cpp:65:118: err
							      								    								  or: request for member ‘c_str’ in ‘n.std::__cxx11:
							      								    								  :basic_string<char>::operator[](((std::__cxx11::ba
							      								    								  sic_string<char>::size_type)(i + 2)))’, which is o
							      								    								  f non-class type ‘__gnu_cxx::__alloc_traits<std::a
							      								    								  llocator<char>, char>::value_type’ {aka ‘char’}
							      								    								     threeDigit = ( atoi ( n [ i ] . c_str ( ) ) * 1
							      								    								  00 + atoi ( n [ i + 1 ] . c_str ( ) ) * 10 + atoi
							      								    								  ( n [ i + 2 ] . c_str ( ) ) ;
							      								    								  
							      								    								  						  ^~
							      								    								  ~~~ COUNT_ROTATIONS_DIVISIBLE_8.cpp:65:129: error:
							      								    								   expected ‘)’ before ‘;’ token      threeDigit = (
							      								    								   atoi ( n [ i ] . c_str ( ) ) * 100 + atoi ( n [ i
							      								    								   + 1 ] . c_str ( ) ) * 10 + atoi ( n [ i + 2 ] . c
							      								    								  _str ( ) ) ;			 ~
							      								    								  
							      								    								  					    ^~
							      								    								  
							      								    								  
							      								    								  			  ) COUNT_ROTATIONS_DIVISIBL
							      								    								  E_8.cpp:68:39: error: request for member ‘c_str’ i
							      								    								  n ‘n.std::__cxx11::basic_string<char>::operator[](
							      								    								  ((std::__cxx11::basic_string<char>::size_type)(l -
							      								    								   1)))’, which is of non-class type ‘__gnu_cxx::__a
							      								    								  lloc_traits<std::allocator<char>, char>::value_typ
							      								    								  e’ {aka ‘char’}    threeDigit = ( atoi ( n [ l - 1
							      								    								   ] . c_str ( ) ) * 100 + atoi ( n [ 0 ] . c_str (
							      								    								  ) ) * 10 + atoi ( n [ 1 ] . c_str ( ) ) ;
							      								    								  				 ^~~~~ COUNT_ROTATIO
							      								    								  NS_DIVISIBLE_8.cpp:68:76: error: request for membe
							      								    								  r ‘c_str’ in ‘n.std::__cxx11::basic_string<char>::
							      								    								  operator[](0)’, which is of non-class type ‘__gnu_
							      								    								  cxx::__alloc_traits<std::allocator<char>, char>::v
							      								    								  alue_type’ {aka ‘char’}    threeDigit = ( atoi ( n
							      								    								   [ l - 1 ] . c_str ( ) ) * 100 + atoi ( n [ 0 ] .
							      								    								  c_str ( ) ) * 10 + atoi ( n [ 1 ] . c_str ( ) ) ;
							      								    								  
							      								    								  			    ^~~~~ COUNT_ROTATIONS_DI
							      								    								  VISIBLE_8.cpp:68:112: error: request for member ‘c
							      								    								  _str’ in ‘n.std::__cxx11::basic_string<char>::oper
							      								    								  ator[](1)’, which is of non-class type ‘__gnu_cxx:
							      								    								  :__alloc_traits<std::allocator<char>, char>::value
							      								    								  _type’ {aka ‘char’}	 threeDigit = ( atoi ( n [ l
							      								    								   - 1 ] . c_str ( ) ) * 100 + atoi ( n [ 0 ] . c_st
							      								    								  r ( ) ) * 10 + atoi ( n [ 1 ] . c_str ( ) ) ;
							      								    								  
							      								    								  
							      								    								  	  ^~~~~ COUNT_ROTATIONS_DIVISIBLE_8.cpp:68:1
							      								    								  23: error: expected ‘)’ before ‘;’ token    threeD
							      								    								  igit = ( atoi ( n [ l - 1 ] . c_str ( ) ) * 100 +
							      								    								  atoi ( n [ 0 ] . c_str ( ) ) * 10 + atoi ( n [ 1 ]
							      								    								   . c_str ( ) ) ;		   ~
							      								    								  
							      								    								  					  ^~
							      								    								  
							      								    								  
							      								    								  		  ) COUNT_ROTATIONS_DIVISIBLE_8.cpp:
							      								    								  70:39: error: request for member ‘c_str’ in ‘n.std
							      								    								  ::__cxx11::basic_string<char>::operator[](((std::_
							      								    								  _cxx11::basic_string<char>::size_type)(l - 2)))’,
							      								    								  which is of non-class type ‘__gnu_cxx::__alloc_tra
							      								    								  its<std::allocator<char>, char>::value_type’ {aka
							      								    								  ‘char’}    threeDigit = ( atoi ( n [ l - 2 ] . c_s
							      								    								  tr ( ) ) * 100 + atoi ( n [ l - 1 ] . c_str ( ) )
							      								    								  * 10 + atoi ( n [ 0 ] . c_str ( ) ) ;
							      								    								  			     ^~~~~ COUNT_ROTATIONS_D
							      								    								  IVISIBLE_8.cpp:70:80: error: request for member ‘c
							      								    								  _str’ in ‘n.std::__cxx11::basic_string<char>::oper
							      								    								  ator[](((std::__cxx11::basic_string<char>::size_ty
							      								    								  pe)(l - 1)))’, which is of non-class type ‘__gnu_c
							      								    								  xx::__alloc_traits<std::allocator<char>, char>::va
							      								    								  lue_type’ {aka ‘char’}    threeDigit = ( atoi ( n
							      								    								  [ l - 2 ] . c_str ( ) ) * 100 + atoi ( n [ l - 1 ]
							      								    								   . c_str ( ) ) * 10 + atoi ( n [ 0 ] . c_str ( ) )
							      								    								   ;
							      								    								  				   ^~~~~ COUNT_ROTAT
							      								    								  IONS_DIVISIBLE_8.cpp:70:116: error: request for me
							      								    								  mber ‘c_str’ in ‘n.std::__cxx11::basic_string<char
							      								    								  >::operator[](0)’, which is of non-class type ‘__g
							      								    								  nu_cxx::__alloc_traits<std::allocator<char>, char>
							      								    								  ::value_type’ {aka ‘char’}	threeDigit = ( atoi
							      								    								  ( n [ l - 2 ] . c_str ( ) ) * 100 + atoi ( n [ l -
							      								    								   1 ] . c_str ( ) ) * 10 + atoi ( n [ 0 ] . c_str (
							      								    								   ) ) ;
							      								    								  
							      								    								  			 ^~~~~ COUNT_ROTATIONS_DIVIS
							      								    								  IBLE_8.cpp:70:127: error: expected ‘)’ before ‘;’
							      								    								  token	   threeDigit = ( atoi ( n [ l - 2 ] . c_str
							      								    								   ( ) ) * 100 + atoi ( n [ l - 1 ] . c_str ( ) ) *
							      								    								  10 + atoi ( n [ 0 ] . c_str ( ) ) ;
							      								    								    ~
							      								    								  
							      								    								  	       ^~
							      								    								  
							      								    								  					     )
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT			      PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT			    PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT			  PRINT_MATRIX_SPIRAL_FORM_STARTING_POINT
--							      --							    --								  --
def printSpiral ( mat , r , c ) :			      void printSpiral ( int mat [ ] [ MAX ] , int r , int c ) {    int printSpiral ( int * * mat , int r , int c ) {		  script_not_found : None
    a = 0						      	int i , a = 0 , b = 2 ;					      int a = 0 ;						  
    b = 2						      	int low_row = ( 0 > a ) ? 0 : a ;			      int b = 2 ;						  
    low_row = 0 if ( 0 > a ) else a			      	int low_column = ( 0 > b ) ? 0 : b - 1 ;		      int lowRow = ( 0 > a ) ? 0 : a ;				  
    low_column = 0 if ( 0 > b ) else b - 1		      	int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ;	      int lowColumn = ( 0 > b ) ? 0 : b - 1 ;			  
    high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1	      	int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ;	      int highRow = r < 0 ? r - 1 : a + 1 ;			  
    high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1      	while ( ( low_row > 0 - r && low_column > 0 - c ) ) {	      int highColumn = c < 0 ? c - 1 : b + 1 ;			  
    while ( ( low_row > 0 - r and low_column > 0 - c ) ) :    	  for ( i = low_column + 1 ;				      while ( ( ( lowRow > 0 - r ) && ( lowColumn > 0 - c ) ) ) { 
	i = low_column + 1				      	  i <= high_column && i < c && low_row >= 0 ;		    	int i = lowColumn + 1 ;					  
	while ( i <= high_column and i < c and low_row >= 0 ) 	  ++ i ) cout << mat [ low_row ] [ i ] << " " ;		    	while ( ( i <= highColumn && i < c && lowRow >= 0 ) ) {	  
	    print ( mat [ low_row ] [ i ] , end = " " )	      	  low_row -= 1 ;					    	  cout << mat [ lowRow ] [ i ] << " " ;			  
	    i += 1					      	  for ( i = low_row + 2 ;				    	  i ++ ;						  
	low_row -= 1					      	  i <= high_row && i < r && high_column < c ;		    	}							  
	i = low_row + 2					      	  ++ i ) cout << mat [ i ] [ high_column ] << " " ;	    	lowRow -- ;						  
	while ( i <= high_row and i < r and high_column < c ) 	  high_column += 1 ;					    	i = lowRow + 2 ;					  
	    print ( mat [ i ] [ high_column ] , end = " " )   	  for ( i = high_column - 2 ;				    	while ( ( i <= highRow && i < r && highColumn < c ) ) {	  
	    i += 1					      	  i >= low_column && i >= 0 && high_row < r ;		    	  cout << mat [ i ] [ highColumn ] << " " ;		  
	high_column += 1				      	  -- i ) cout << mat [ high_row ] [ i ] << " " ;	    	  i ++ ;						  
	i = high_column - 2				      	  high_row += 1 ;					    	}							  
	while ( i >= low_column and i >= 0 and high_row < r ) 	  for ( i = high_row - 2 ;				    	highColumn ++ ;						  
	    print ( mat [ high_row ] [ i ] , end = " " )      	  i > low_row && i >= 0 && low_column >= 0 ;		    	i = highColumn - 2 ;					  
	    i -= 1					      	  -- i ) cout << mat [ i ] [ low_column ] << " " ;	    	while ( ( i >= lowColumn && i >= 0 && highRow < r ) ) {	  
	high_row += 1					      	  low_column -= 1 ;					    	  cout << mat [ highRow ] [ i ] << " " ;		  
	i = high_row - 2				      	}							    	  i -- ;						  
	while ( i > low_row and i >= 0 and low_column >= 0 )  	cout << endl ;						    	}							  
	    print ( mat [ i ] [ low_column ] , end = " " )    }								    	highRow ++ ;						  
	    i -= 1					      								    	i = highRow - 2 ;					  
	low_column -= 1					      								    	while ( ( i > lowRow && i >= 0 && lowColumn >= 0 ) ) {	  
    print ( )						      								    	  cout << mat [ i ] [ lowColumn ] << " " ;		  
							      								    	  i -- ;						  
							      								    	}							  
							      								    	lowColumn -- ;						  
							      								      }								  
							      								      cout << endl ;						  
							      								      return a * a ;						  
							      								      return a * a ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS		      POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS		    POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS			  POINT_CLIPPING_ALGORITHM_COMPUTER_GRAPHICS
--							      --							    --								  --
def pointClip ( XY , n , Xmin , Ymin , Xmax , Ymax ) :	      void pointClip ( int XY [ ] [ 2 ] , int n , int Xmin , int Ym void pointClip ( double * XY , int n , double Xmin , double Y script_not_found : None
    print ( "Point inside the viewing pane:" )		      	cout << "Point inside the viewing pane:" << endl ;	      cout << "Point inside the viewing pane:" << endl ;	  
    for i in range ( n ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	if ( ( XY [ i ] [ 0 ] >= Xmin ) and ( XY [ i ] [ 0 ]  	i < n ;							      i < n ;							  
	    if ( ( XY [ i ] [ 1 ] >= Ymin ) and ( XY [ i ] [  	i ++ ) {						      i ++ ) {							  
		print ( "[" , XY [ i ] [ 0 ] , ", " , XY [ i  	  if ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <= Xm 	if ( ( ( XY [ i ] [ 0 ] >= Xmin ) && ( XY [ i ] [ 0 ] <=  
    print ( "\n\nPoint outside the viewing pane:" )	      	    if ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] <=  	  if ( ( ( XY [ i ] [ 1 ] >= Ymin ) && ( XY [ i ] [ 1 ] < 
    for i in range ( n ) :				      	  }							    	}							  
	if ( ( XY [ i ] [ 0 ] < Xmin ) or ( XY [ i ] [ 0 ] >  	}							      }								  
	    print ( "[" , XY [ i ] [ 0 ] , ", " , XY [ i ] [  	cout << "\n" << endl ;					      cout << "\n\nPoint outside the viewing pane:" << endl ;	  
	if ( ( XY [ i ] [ 1 ] < Ymin ) or ( XY [ i ] [ 1 ] >  	cout << "Point outside the viewing pane:" << endl ;	      for ( int i = 0 ;						  
	    print ( "[" , XY [ i ] [ 0 ] , ", " , XY [ i ] [  	for ( int i = 0 ;					      i < n ;							  
							      	i < n ;							      i ++ ) {							  
							      	i ++ ) {						    	if ( ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xm 
							      	  if ( ( XY [ i ] [ 0 ] < Xmin ) || ( XY [ i ] [ 0 ] > Xmax 	if ( ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ym 
							      	  if ( ( XY [ i ] [ 1 ] < Ymin ) || ( XY [ i ] [ 1 ] > Ymax   }								  
							      	}							    }								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
EULERS_FOUR_SQUARE_IDENTITY_1				      EULERS_FOUR_SQUARE_IDENTITY_1				    EULERS_FOUR_SQUARE_IDENTITY_1				  EULERS_FOUR_SQUARE_IDENTITY_1
--							      --							    --								  --
def checkEulerFourSquareIdentity ( a , b ) :		      void checkEulerFourSquareIdentity ( int a , int b ) {	    int checkEulerFourSquareIdentity ( double a , double b ) {	  script_not_found : None
    ab = a * b						      	int ab = a * b ;					      double ab = a * b ;					  
    flag = False					      	bool flag = false ;					      bool flag = false ;					  
    i = 0						      	int i = 0 ;						      int i = 0 ;						  
    while i * i <= ab :					      	while ( i * i <= ab ) {					      while ( i * i <= ab ) {					  
	j = i						      	  int j = i ;						    	int j = i ;						  
	while i * i + j * j <= ab :			      	  while ( i * i + j * j <= ab ) {			    	while ( i * i + j * j <= ab ) {				  
	    k = j					      	    int k = j ;						    	  int k = j ;						  
	    while i * i + j * j + k * k <= ab :		      	    while ( i * i + j * j + k * k <= ab ) {		    	  while ( i * i + j * j + k * k <= ab ) {		  
		l = ( ab - ( i * i + j * j + k * k ) ) ** ( 0 	      double l = sqrt ( ab - ( i * i + j * j + k * k ) ) ;  	    double l = ( ab - ( i * i + j * j + k * k ) ) * ( 0.5 
		if l == int ( l ) and l >= k :		      	      if ( floor ( l ) == ceil ( l ) && l >= k ) {	    	    if ( l == ( int ) l && l >= k ) {			  
		    flag = True				      		flag = true ;					    	      flag = true ;					  
		    print ( "i = " , i )		      		cout << "i = " << i << "\n" ;			    	      cout << "i = " << i << endl ;			  
		    print ( "j = " , j )		      		cout << "j = " << j << "\n" ;			    	      cout << "j = " << j << endl ;			  
		    print ( "k = " , k )		      		cout << "k = " << k << "\n" ;			    	      cout << "k = " << k << endl ;			  
		    print ( "l = " , l )		      		cout << "l = " << ( int ) l << "\n" ;		    	      cout << "l = " << l << endl ;			  
		    print ( "Product of" , a , "and" , b , "c 		cout << "Product of " << a << " and " << b << " can 	      cout << "Product of" << a << " and" << b << " can b 
		    print ( ab , " = " , i , "*" , i , "+" ,  		cout << ab + " = " << i << "*" << i << " + " << j < 	      cout << ab << " = " << i << "*" << i << "+" << j << 
		k += 1					      	      }							    	      cout << "*" << k << "*" << k << "+" << l << "*" <<  
	    j += 1					      	      k += 1 ;						    	    }							  
	i += 1						      	    }							    	    k ++ ;						  
    if flag == False :					      	    j += 1 ;						    	  }							  
	print ( "Solution doesn't exist!" )		      	  }							    	  j ++ ;						  
	return						      	  i += 1 ;						    	}							  
							      	}							    	i ++ ;							  
							      	if ( flag == false ) {					      }								  
							      	  cout << "Solution doesn't exist!\n" ;			      if ( flag == false ) {					  
							      	  return ;						    	cout << "Solution doesn't exist!" << endl ;		  
							      	}							    	return 0 ;						  
							      }								      }								  
							      								      return 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 * 1 *  
-							      -								      -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL FIND_THE_LARGEST_RECTANGLE_OF_1S_WITH_SWAPPING_OF_COLUMNS_ALL
--							      --							    --								  --
def maxArea ( mat ) :					      int maxArea ( bool mat [ R ] [ C ] ) {			    int maxArea ( int * * mat ) {				  script_not_found : None
    hist = [ [ 0 for i in range ( C + 1 ) ] for i in range (  	int hist [ R + 1 ] [ C + 1 ] ;				      int hist [ C + 1 ] [ R + 1 ] ;				  
    for i in range ( 0 , C , 1 ) :			      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	hist [ 0 ] [ i ] = mat [ 0 ] [ i ]		      	i < C ;							      i < C ;							  
	for j in range ( 1 , R , 1 ) :			      	i ++ ) {						      i ++ ) {							  
	    if ( ( mat [ j ] [ i ] == 0 ) ) :		      	  hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ;			    	hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ;			  
		hist [ j ] [ i ] = 0			      	  for ( int j = 1 ;					    	for ( int j = 1 ;					  
	    else :					      	  j < R ;						    	j < R ;							  
		hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1   	  j ++ ) hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 :  	j += 1 ) {						  
    for i in range ( 0 , R , 1 ) :			      	}							    	  if ( ( ( mat [ j ] [ i ] == 0 ) ) && ( mat [ j ] [ i ]  
	count = [ 0 for i in range ( R + 1 ) ]		      	for ( int i = 0 ;					    	  else hist [ j ] [ i ] = hist [ j - 1 ] [ i ] + 1 ;	  
	for j in range ( 0 , C , 1 ) :			      	i < R ;							    	}							  
	    count [ hist [ i ] [ j ] ] += 1		      	i ++ ) {						      }								  
	col_no = 0					      	  int count [ R + 1 ] = {				      for ( int i = 0 ;						  
	j = R						      	    0 }							      i < R ;							  
	while ( j >= 0 ) :				      	    ;							      i += 1 ) {						  
	    if ( count [ j ] > 0 ) :			      	    for ( int j = 0 ;					    	int count [ R + 1 ] ;					  
		for k in range ( 0 , count [ j ] , 1 ) :      	    j < C ;						    	for ( int j = 0 ;					  
		    hist [ i ] [ col_no ] = j		      	    j ++ ) count [ hist [ i ] [ j ] ] ++ ;		    	j < C ;							  
		    col_no += 1				      	    int col_no = 0 ;					    	j ++ ) count [ hist [ i ] [ j ] ] ++ ;			  
	    j -= 1					      	    for ( int j = R ;					    	int colNo = 0 ;						  
    max_area = 0					      	    j >= 0 ;						    	int j = R ;						  
    for i in range ( 0 , R , 1 ) :			      	    j -- ) {						    	while ( ( j >= 0 ) ) {					  
	for j in range ( 0 , C , 1 ) :			      	      if ( count [ j ] > 0 ) {				    	  if ( ( count [ j ] > 0 ) ) {				  
	    curr_area = ( j + 1 ) * hist [ i ] [ j ]	      		for ( int k = 0 ;				    	    for ( int k = 0 ;					  
	    if ( curr_area > max_area ) :		      		k < count [ j ] ;				    	    k < count [ j ] ;					  
		max_area = curr_area			      		k ++ ) {					    	    k += 1 ) {						  
    return max_area					      		  hist [ i ] [ col_no ] = j ;			    	      hist [ i ] [ colNo ] = j ;			  
							      		  col_no ++ ;					    	      colNo ++ ;					  
							      		}						    	    }							  
							      	      }							    	  }							  
							      	    }							    	  j -- ;						  
							      	  }							    	}							  
							      	  int curr_area , max_area = 0 ;			      }								  
							      	  for ( int i = 0 ;					      int maxArea = 0 ;						  
							      	  i < R ;						      for ( int i = 0 ;						  
							      	  i ++ ) {						      i < R ;							  
							      	    for ( int j = 0 ;					      i += 1 ) {						  
							      	    j < C ;						    	for ( int j = 0 ;					  
							      	    j ++ ) {						    	j < C ;							  
							      	      curr_area = ( j + 1 ) * hist [ i ] [ j ] ;	    	j += 1 ) {						  
							      	      if ( curr_area > max_area ) max_area = curr_area ;    	  int currArea = ( j + 1 ) * hist [ i ] [ j ] ;		  
							      	    }							    	  if ( ( currArea > maxArea ) ) maxArea = currArea ;	  
							      	  }							    	}							  
							      	  return max_area ;					      }								  
							      	}							      return maxArea ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER		      MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER			    MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER			  MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER
--							      --							    --								  --
def findMaxVal ( arr , n , num , maxLimit ) :		      int findMaxVal ( int arr [ ] , int n , int num , int maxLimit int findMaxVal ( int * arr , int n , int num , int maxLimit ) error : MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER.
    ind = - 1						      	int ind ;						      int ind = - 1 ;						  cpp: In function ‘int f_filled(int*, int, int, int
    val = - 1						      	int val ;						      int val = - 1 ;						  )’: MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER.cpp:
    dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in ran 	int dp [ n ] [ maxLimit + 1 ] ;				      vector < vector < int >> dp ( maxLimit + 1 , vector < int > 101:12: error: a function-definition is not allowe
    for ind in range ( n ) :				      	for ( ind = 0 ;						      for ( int j = 0 ;						  d here before ‘{’ token  int main() {
	for val in range ( maxLimit + 1 ) :		      	ind < n ;						      j < n ;							  ^ MAXIMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER.cpp:11
	    if ( ind == 0 ) :				      	ind ++ ) {						      j ++ ) {							  6:1: error: expected ‘}’ at end of input  }  ^ MAX
		if ( num - arr [ ind ] == val or num + arr [  	  for ( val = 0 ;					    	for ( int ind = 0 ;					  IMIZE_ARRAY_ELEMENTS_UPTO_GIVEN_NUMBER.cpp:61:61:
		    dp [ ind ] [ val ] = 1		      	  val <= maxLimit ;					    	ind < n ;						  note: to match this ‘{’  int f_filled ( int * arr
		else :					      	  val ++ ) {						    	ind ++ ) {						  , int n , int num , int maxLimit ) {
		    dp [ ind ] [ val ] = 0		      	    if ( ind == 0 ) {					    	  for ( int val = 0 ;					  						  ^
	    else :					      	      if ( num - arr [ ind ] == val || num + arr [ ind ] == 	  val < maxLimit + 1 ;					  
		if ( val - arr [ ind ] >= 0 and val + arr [ i 		dp [ ind ] [ val ] = 1 ;			    	  val ++ ) {						  
		    if ( dp [ ind - 1 ] [ val - arr [ ind ] ] 	      }							    	    if ( ( ind == 0 ) ) {				  
			dp [ ind ] [ val ] = 1		      	      else {						    	      if ( ( num - arr [ ind ] == val || num + arr [ ind  
		elif ( val - arr [ ind ] >= 0 ) :	      		dp [ ind ] [ val ] = 0 ;			    	      else dp [ ind ] [ val ] = 0 ;			  
		    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val 	      }							    	    }							  
		elif ( val + arr [ ind ] <= maxLimit ) :      	    }							    	    else {						  
		    dp [ ind ] [ val ] = dp [ ind - 1 ] [ val 	    else {						    	      if ( ( val - arr [ ind ] >= 0 ) && ( val + arr [ in 
		else :					      	      if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= m 		if ( ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1  
		    dp [ ind ] [ val ] = 0		      		dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ i 	      }							  
    for val in range ( maxLimit , - 1 , - 1 ) :		      	      }							    	      else if ( ( val - arr [ ind ] >= 0 ) ) dp [ ind ] [ 
	if ( dp [ n - 1 ] [ val ] == 1 ) :		      	      else if ( val - arr [ ind ] >= 0 ) {		    	      else if ( ( val + arr [ ind ] <= maxLimit ) ) dp [  
	    return val					      		dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ i 	      else dp [ ind ] [ val ] = 0 ;			  
    return - 1						      	      }							    	    }							  
							      	      else if ( val + arr [ ind ] <= maxLimit ) {	    	  }							  
							      		dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ i 	}							  
							      	      }							      }								  
							      	      else {						      for ( int val = maxLimit ;				  
							      		dp [ ind ] [ val ] = 0 ;			      val >= 0 ;						  
							      	      }							      val -- ) {						  
							      	    }							    	if ( ( dp [ n - 1 ] [ val ] == 1 ) ) return val ;	  
							      	  }							      }								  
							      	}							      return - 1 ;						  
							      	for ( val = maxLimit ;					      return n * n ;						  
							      	val >= 0 ;						      return n * n ;						  
							      	val -- ) {						      return n * n ;						  
							      	  if ( dp [ n - 1 ] [ val ] ) {				      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      	    return val ;					    								  
							      	  }							    								  
							      	}							    								  
							      	return - 1 ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1		      MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1		    MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1		  MAXIMUM_DECIMAL_VALUE_PATH_IN_A_BINARY_MATRIX_1
--							      --							    --								  --
def MaximumDecimalValue ( mat , n ) :			      long long int MaximumDecimalValue ( int mat [ ] [ N ] , int n double MaximumDecimalValue ( int * * mat , int n ) {	  script_not_found : None
    dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]  	int dp [ n ] [ n ] ;					      vector < vector < int >> dp ( n , vector < int > ( n , 0 )  
    if ( mat [ 0 ] [ 0 ] == 1 ) :			      	memset ( dp , 0 , sizeof ( dp ) ) ;			      for ( int i = 0 ;						  
	dp [ 0 ] [ 0 ] = 1				      	if ( mat [ 0 ] [ 0 ] == 1 ) dp [ 0 ] [ 0 ] = 1 ;	      i < n ;							  
    for i in range ( 1 , n ) :				      	for ( int i = 1 ;					      i ++ ) {							  
	if ( mat [ 0 ] [ i ] == 1 ) :			      	i < n ;							    	dp [ 0 ] [ 0 ] = 1 ;					  
	    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 2 ** i      	i ++ ) {						      }								  
	else :						      	  if ( mat [ 0 ] [ i ] == 1 ) dp [ 0 ] [ i ] = dp [ 0 ] [ i   for ( int i = 1 ;						  
	    dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ]		      	  else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ;		      i < n ;							  
    for i in range ( 1 , n ) :				      	}							      i ++ ) {							  
	if ( mat [ i ] [ 0 ] == 1 ) :			      	for ( int i = 1 ;					    	if ( ( mat [ 0 ] [ i ] == 1 ) ) dp [ 0 ] [ i ] = dp [ 0 ] 
	    dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + 2 ** i      	i < n ;							    	else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ;		  
    else :						      	i ++ ) {						      }								  
	dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ]		      	  if ( mat [ i ] [ 0 ] == 1 ) dp [ i ] [ 0 ] = dp [ i - 1 ]   for ( int i = 1 ;						  
    for i in range ( 1 , n ) :				      	  else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;		      i < n ;							  
	for j in range ( 1 , n ) :			      	}							      i ++ ) {							  
	    if ( mat [ i ] [ j ] == 1 ) :		      	for ( int i = 1 ;					    	if ( ( mat [ i ] [ 0 ] == 1 ) ) dp [ i ] [ 0 ] = dp [ i - 
		dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , d 	i < n ;							      }								  
	    else :					      	i ++ ) {						      else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;		  
		dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , d 	  for ( int j = 1 ;					      for ( int i = 1 ;						  
    return dp [ n - 1 ] [ n - 1 ]			      	  j < n ;						      i < n ;							  
							      	  j ++ ) {						      i ++ ) {							  
							      	    if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = max ( dp [ 	for ( int j = 1 ;					  
							      	    else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i 	j < n ;							  
							      	  }							    	j ++ ) {						  
							      	}							    	  if ( ( mat [ i ] [ j ] == 1 ) ) dp [ i ] [ j ] = max (  
							      	return dp [ n - 1 ] [ n - 1 ] ;				    	  else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i 
							      }								    	}							  
							      								      }								  
							      								      return dp [ n - 1 ] [ n - 1 ] ;				  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DIRECTION_LAST_SQUARE_BLOCK				      DIRECTION_LAST_SQUARE_BLOCK				    DIRECTION_LAST_SQUARE_BLOCK					  DIRECTION_LAST_SQUARE_BLOCK
--							      --							    --								  --
def direction ( R , C ) :				      void direction ( ll R , ll C ) {				    int direction ( int R , int C ) {				  script_not_found : None
    if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) :   	if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) {	      if ( ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) ) {	  
	print ( "Left" )				      	  cout << "Left" << endl ;				    	cout << "Left" << endl ;				  
	return						      	  return ;						    	return 0 ;						  
    if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) :   	}							      }								  
	print ( "Up" )					      	if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) {	      if ( ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) ) {	  
	return						      	  cout << "Up" << endl ;				    	cout << "Up" << endl ;					  
    if R == C and R % 2 != 0 and C % 2 != 0 :		      	  return ;						    	return 0 ;						  
	print ( "Right" )				      	}							      }								  
	return						      	if ( R == C && R % 2 != 0 && C % 2 != 0 ) {		      if ( R == C && R % 2 != 0 && C % 2 != 0 ) {		  
    if R == C and R % 2 == 0 and C % 2 == 0 :		      	  cout << "Right" << endl ;				    	cout << "Right" << endl ;				  
	print ( "Left" )				      	  return ;						    	return 0 ;						  
	return						      	}							      }								  
    if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) :   	if ( R == C && R % 2 == 0 && C % 2 == 0 ) {		      if ( R == C && R % 2 == 0 && C % 2 == 0 ) {		  
	print ( "Right" )				      	  cout << "Left" << endl ;				    	cout << "Left" << endl ;				  
	return						      	  return ;						    	return 0 ;						  
    if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) :   	}							      }								  
	print ( "Down" )				      	if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) {	      if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) ) {	  
	return						      	  cout << "Right" << endl ;				    	cout << "Right" << endl ;				  
    if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) :   	  return ;						    	return 0 ;						  
	print ( "Left" )				      	}							      }								  
	return						      	if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) {	      if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) ) {	  
    if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) :   	  cout << "Down" << endl ;				    	cout << "Down" << endl ;				  
	print ( "Up" )					      	  return ;						    	return 0 ;						  
	return						      	}							      }								  
    if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) :   	if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) {	      if ( ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) ) {	  
	print ( "Down" )				      	  cout << "Left" << endl ;				    	cout << "Left" << endl ;				  
	return						      	  return ;						    	return 0 ;						  
    if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) :   	}							      }								  
	print ( "Right" )				      	if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) {	      if ( ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) ) {	  
	return						      	  cout << "Up" << endl ;				    	cout << "Up" << endl ;					  
							      	  return ;						    	return 0 ;						  
							      	}							      }								  
							      	if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) {	      if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) ) {	  
							      	  cout << "Down" << endl ;				    	cout << "Down" << endl ;				  
							      	  return ;						    	return 0 ;						  
							      	}							      }								  
							      	if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) {	      if ( ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) ) {	  
							      	  cout << "Right" << endl ;				    	cout << "Right" << endl ;				  
							      	  return ;						    	return 0 ;						  
							      	}							      }								  
							      }								      return R * R ;						  
							      								      return R * R ;						  
							      								      return R * R * R * R * R * R * R * R * R * R * R * R * R *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_A_SPECIFIC_PAIR_IN_MATRIX_1			      FIND_A_SPECIFIC_PAIR_IN_MATRIX_1				    FIND_A_SPECIFIC_PAIR_IN_MATRIX_1				  FIND_A_SPECIFIC_PAIR_IN_MATRIX_1
--							      --							    --								  --
def findMaxValue ( mat ) :				      int findMaxValue ( int mat [ ] [ N ] ) {			    int findMaxValue ( int * * mat ) {				  script_not_found : None
    maxValue = - sys.maxsize - 1			      	int maxValue = INT_MIN ;				      int maxValue = - INT_MAX - 1 ;				  
    maxArr = [ [ 0 for x in range ( N ) ] for y in range ( N  	int maxArr [ N ] [ N ] ;				      int * * maxArr = new int * [ N ] ;			  
    maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ]      	maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ;	      for ( int y = 0 ;						  
    maxv = mat [ N - 1 ] [ N - 1 ]			      	int maxv = mat [ N - 1 ] [ N - 1 ] ;			      y < N ;							  
    for j in range ( N - 2 , - 1 , - 1 ) :		      	for ( int j = N - 2 ;					      y ++ ) {							  
	if ( mat [ N - 1 ] [ j ] > maxv ) :		      	j >= 0 ;						    	for ( int x = 0 ;					  
	    maxv = mat [ N - 1 ] [ j ]			      	j -- ) {						    	x < N ;							  
	maxArr [ N - 1 ] [ j ] = maxv			      	  if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [  	x ++ ) {						  
    maxv = mat [ N - 1 ] [ N - 1 ]			      	  maxArr [ N - 1 ] [ j ] = maxv ;			    	  for ( int y = 0 ;					  
    for i in range ( N - 2 , - 1 , - 1 ) :		      	}							    	  y < N ;						  
	if ( mat [ i ] [ N - 1 ] > maxv ) :		      	maxv = mat [ N - 1 ] [ N - 1 ] ;			    	  y ++ ) {						  
	    maxv = mat [ i ] [ N - 1 ]			      	for ( int i = N - 2 ;					    	    if ( ( mat [ N - 1 ] [ y ] > maxv ) ) maxv = mat [ N  
	maxArr [ i ] [ N - 1 ] = maxv			      	i >= 0 ;						    	    maxArr [ N - 1 ] [ j ] = maxv ;			  
    for i in range ( N - 2 , - 1 , - 1 ) :		      	i -- ) {						    	  }							  
	for j in range ( N - 2 , - 1 , - 1 ) :		      	  if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N -  	}							  
	    if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] 	  maxArr [ i ] [ N - 1 ] = maxv ;			      }								  
		maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat 	}							      int maxv = mat [ N - 1 ] [ N - 1 ] ;			  
	    maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max  	for ( int i = N - 2 ;					      for ( int i = N - 2 ;					  
    return maxValue					      	i >= 0 ;						      i >= 0 ;							  
							      	i -- ) {						      i -- ) {							  
							      	  for ( int j = N - 2 ;					    	if ( ( mat [ i ] [ N - 1 ] > maxv ) ) maxv = mat [ i ] [  
							      	  j >= 0 ;						    	maxArr [ i ] [ N - 1 ] = maxv ;				  
							      	  j -- ) {						      }								  
							      	    if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > max   for ( int i = N - 2 ;					  
							      	    maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxA   i >= 0 ;							  
							      	  }							      i -- ) {							  
							      	}							    	for ( int j = N - 2 ;					  
							      	return maxValue ;					    	j >= 0 ;						  
							      }								    	j -- ) {						  
							      								    	  if ( ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > m 
							      								    	  maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxA 
							      								    	}							  
							      								      }								  
							      								      return maxValue ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DOOLITTLE_ALGORITHM_LU_DECOMPOSITION			      DOOLITTLE_ALGORITHM_LU_DECOMPOSITION			    DOOLITTLE_ALGORITHM_LU_DECOMPOSITION			  DOOLITTLE_ALGORITHM_LU_DECOMPOSITION
--							      --							    --								  --
def luDecomposition ( mat , n ) :			      void luDecomposition ( int mat [ ] [ MAX ] , int n ) {	    int luDecomposition ( int * * mat , int n ) {		  script_not_found : None
    lower = [ [ 0 for x in range ( n ) ] for y in range ( n ) 	int lower [ n ] [ n ] , upper [ n ] [ n ] ;		      vector < vector < int >> lower ( n , vector < int > ( n , 0 
    upper = [ [ 0 for x in range ( n ) ] for y in range ( n ) 	memset ( lower , 0 , sizeof ( lower ) ) ;		      for ( int y = 0 ;						  
    for i in range ( n ) :				      	memset ( upper , 0 , sizeof ( upper ) ) ;		      y < n ;							  
	for k in range ( i , n ) :			      	for ( int i = 0 ;					      y ++ ) lower [ y ] . push_back ( 0 ) ;			  
	    sum = 0					      	i < n ;							      vector < vector < int >> upper ( n , vector < int > ( n ) ) 
	    for j in range ( i ) :			      	i ++ ) {						      for ( int i = 0 ;						  
		sum += ( lower [ i ] [ j ] * upper [ j ] [ k  	  for ( int k = i ;					      i < n ;							  
	    upper [ i ] [ k ] = mat [ i ] [ k ] - sum	      	  k < n ;						      i ++ ) {							  
	for k in range ( i , n ) :			      	  k ++ ) {						    	for ( int k = i ;					  
	    if ( i == k ) :				      	    int sum = 0 ;					    	k < n ;							  
		lower [ i ] [ i ] = 1			      	    for ( int j = 0 ;					    	k ++ ) {						  
	    else :					      	    j < i ;						    	  int sum = 0 ;						  
		sum = 0					      	    j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) 	  for ( int j = 0 ;					  
		for j in range ( i ) :			      	    upper [ i ] [ k ] = mat [ i ] [ k ] - sum ;		    	  j < i ;						  
		    sum += ( lower [ k ] [ j ] * upper [ j ]  	  }							    	  j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) 
		lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - 	  for ( int k = i ;					    	  upper [ i ] [ k ] = mat [ i ] [ k ] - sum ;		  
    print ( "Lower Triangular\t\tUpper Triangular" )	      	  k < n ;						    	}							  
    for i in range ( n ) :				      	  k ++ ) {						    	for ( int k = i ;					  
	for j in range ( n ) :				      	    if ( i == k ) lower [ i ] [ i ] = 1 ;		    	k < n ;							  
	    print ( lower [ i ] [ j ] , end = "\t" )	      	    else {						    	k ++ ) {						  
	print ( "" , end = "\t" )			      	      int sum = 0 ;					    	  if ( ( i == k ) ) lower [ i ] [ i ] = 1 ;		  
	for j in range ( n ) :				      	      for ( int j = 0 ;					    	  else {						  
	    print ( upper [ i ] [ j ] , end = "\t" )	      	      j < i ;						    	    int sum = 0 ;					  
	print ( "" )					      	      j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] 	    for ( int j = 0 ;					  
							      	      lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper 	    j < i ;						  
							      	    }							    	    j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] 
							      	  }							    	    lower [ k ] [ i ] = ( int ) ( ( mat [ k ] [ i ] - sum 
							      	}							    	  }							  
							      	cout << setw ( 6 ) << "	     Lower Triangular" << setw ( 32 	}							  
							      	for ( int i = 0 ;					      }								  
							      	i < n ;							      cout << "Lower Triangular\t\tUpper Triangular" << endl ;	  
							      	i ++ ) {						      for ( int i = 0 ;						  
							      	  for ( int j = 0 ;					      i < n ;							  
							      	  j < n ;						      i ++ ) {							  
							      	  j ++ ) cout << setw ( 6 ) << lower [ i ] [ j ] << "\t" ;  	for ( int j = 0 ;					  
							      	  cout << "\t" ;					    	j < n ;							  
							      	  for ( int j = 0 ;					    	j ++ ) cout << lower [ i ] [ j ] << "\t" ;		  
							      	  j < n ;						    	cout << "" << endl ;					  
							      	  j ++ ) cout << setw ( 6 ) << upper [ i ] [ j ] << "\t" ;  	for ( int j = 0 ;					  
							      	  cout << endl ;					    	j < n ;							  
							      	}							    	j ++ ) cout << upper [ i ] [ j ] << "\t" ;		  
							      }								    	cout << "" << endl ;					  
							      								      }								  
							      								      return n * n ;						  
							      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER FIND_THE_SMALLEST_WINDOW_IN_A_STRING_CONTAINING_ALL_CHARACTER
--							      --							    --								  --
def findSubString ( string , pat ) :			      string findSubString ( string str , string pat ) {	    string findSubString ( string string , string pat ) {	  script_not_found : None
    len1 = len ( string )				      	int len1 = str . length ( ) ;				      int len1 = string . length ( ) ;				  
    len2 = len ( pat )					      	int len2 = pat . length ( ) ;				      int len2 = pat . length ( ) ;				  
    if len1 < len2 :					      	if ( len1 < len2 ) {					      if ( len1 < len2 ) {					  
	print ( "No such window exists" )		      	  cout << "No such window exists" ;			    	cout << "No such window exists" << endl ;		  
	return ""					      	  return "" ;						    	return "" ;						  
    hash_pat = [ 0 ] * no_of_chars			      	}							      }								  
    hash_str = [ 0 ] * no_of_chars			      	int hash_pat [ no_of_chars ] = {			      vector < int > hashPat ( noChars , 0 ) ;			  
    for i in range ( 0 , len2 ) :			      	  0 }							      vector < int > hashStr ( noChars , 0 ) ;			  
	hash_pat [ ord ( pat [ i ] ) ] += 1		      	  ;							      for ( int i = 0 ;						  
    start , start_index , min_len = 0 , - 1 , float ( 'inf' ) 	  int hash_str [ no_of_chars ] = {			      i != len2 ;						  
    count = 0						      	    0 }							      i ++ ) hashPat [ pat [ i ] ] ++ ;				  
    for j in range ( 0 , len1 ) :			      	    ;							      int start = 0 , startIndex = - 1 , minLen = numeric_limits  
	hash_str [ ord ( string [ j ] ) ] += 1		      	    for ( int i = 0 ;					      int count = 0 ;						  
	if ( hash_pat [ ord ( string [ j ] ) ] != 0 and hash_ 	    i < len2 ;						      for ( int j = 0 ;						  
	    count += 1					      	    i ++ ) hash_pat [ pat [ i ] ] ++ ;			      j < len1 ;						  
	if count == len2 :				      	    int start = 0 , start_index = - 1 , min_len = INT_MAX ;   j ++ ) {							  
	    while ( hash_str [ ord ( string [ start ] ) ] > h 	    int count = 0 ;					    	hashStr [ string [ j ] ] ++ ;				  
		if ( hash_str [ ord ( string [ start ] ) ] >  	    for ( int j = 0 ;					    	if ( ( hashPat [ string [ j ] ] != 0 ) && ( hashStr [ str 
		    hash_str [ ord ( string [ start ] ) ] -=  	    j < len1 ;						    	if ( count == len2 ) {					  
		start += 1				      	    j ++ ) {						    	  while ( ( hashStr [ string [ start ] ] > hashPat [ stri 
	    len_window = j - start + 1			      	      hash_str [ str [ j ] ] ++ ;			    	    if ( ( hashStr [ string [ start ] ] > hashPat [ strin 
	    if min_len > len_window :			      	      if ( hash_pat [ str [ j ] ] != 0 && hash_str [ str [  	    start ++ ;						  
		min_len = len_window			      	      if ( count == len2 ) {				    	  }							  
		start_index = start			      		while ( hash_str [ str [ start ] ] > hash_pat [ str 	  int lenWindow = j - start + 1 ;			  
    if start_index == - 1 :				      		  if ( hash_str [ str [ start ] ] > hash_pat [ str  	  if ( minLen > lenWindow ) {				  
	print ( "No such window exists" )		      		  start ++ ;					    	    minLen = lenWindow ;				  
	return ""					      		}						    	    startIndex = start ;				  
    return string [ start_index : start_index + min_len ]     		int len_window = j - start + 1 ;		    	  }							  
							      		if ( min_len > len_window ) {			    	}							  
							      		  min_len = len_window ;			      }								  
							      		  start_index = start ;				      if ( startIndex == - 1 ) {				  
							      		}						    	cout << "No such window exists" << endl ;		  
							      	      }							    	return "" ;						  
							      	    }							      }								  
							      	    if ( start_index == - 1 ) {				      return string . substr ( startIndex , minLen - startIndex ) 
							      	      cout << "No such window exists" ;			      return " " + string + " " + string ;			  
							      	      return "" ;					      return " " + string ;					  
							      	    }							      return " " + string ;					  
							      	    return str . substr ( start_index , min_len ) ;	      return " " + string ;					  
							      	  }							      return " " + string ;					  
							      								      return " " + string ;					  
							      								      return " " + string ;					  
							      								      return " " + string ;					  
							      								      return " " + string ;					  
							      								      return " " + string + " " + string + " " + string ;	  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
LONGEST_GEOMETRIC_PROGRESSION				      LONGEST_GEOMETRIC_PROGRESSION				    LONGEST_GEOMETRIC_PROGRESSION				  LONGEST_GEOMETRIC_PROGRESSION
--							      --							    --								  --
def lenOfLongestGP ( sett , n ) :			      int lenOfLongestGP ( int set [ ] , int n ) {		    int lenOfLongestGP ( int * sett , int n ) {			  script_not_found : None
    if n < 2 :						      	if ( n < 2 ) return n ;					      if ( n < 2 ) return n ;					  
	return n					      	if ( n == 2 ) return ( set [ 1 ] % set [ 0 ] == 0 ) ;	      if ( n == 2 ) return ( sett [ 1 ] % sett [ 0 ] == 0 ) ;	  
    if n == 2 :						      	sort ( set , set + n ) ;				      sort ( sett , sett + n ) ;				  
	return ( sett [ 1 ] % sett [ 0 ] == 0 )		      	int L [ n ] [ n ] ;					      vector < vector < int >> L ( n , vector < int > ( n , 0 ) ) 
    sett.sort ( )					      	int llgp = 1 ;						      for ( int i = 0 ;						  
    L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ]   	for ( int i = 0 ;					      i < n ;							  
    llgp = 1						      	i < n ;							      i ++ ) {							  
    for i in range ( 0 , n ) :				      	++ i ) if ( set [ n - 1 ] % set [ i ] == 0 ) L [ i ] [ n -  	if ( sett [ n - 1 ] % sett [ i ] == 0 ) L [ i ] [ n - 1 ] 
	if sett [ n - 1 ] % sett [ i ] == 0 :		      	else L [ i ] [ n - 1 ] = 1 ;				    	else L [ i ] [ n - 1 ] = 1 ;				  
	    L [ i ] [ n - 1 ] = 2			      	for ( int j = n - 2 ;					      }								  
	else :						      	j >= 1 ;						      for ( int j = n - 2 ;					  
	    L [ i ] [ n - 1 ] = 1			      	-- j ) {						      j > 0 ;							  
    for j in range ( n - 2 , 0 , - 1 ) :		      	  int i = j - 1 , k = j + 1 ;				      j -- ) {							  
	i = j - 1					      	  while ( i >= 0 && k <= n - 1 ) {			    	int i = j - 1 ;						  
	k = j + 1					      	    if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) ++ 	int k = j + 1 ;						  
	while i >= 0 and k <= n - 1 :			      	    else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] 	while ( i >= 0 && k <= n - 1 ) {			  
	    if sett [ i ] * sett [ k ] < sett [ j ] * sett [  	      if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2 ; 	  if ( sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ]  
		k += 1					      	      else L [ i ] [ j ] = 1 ;				    	  else if ( sett [ i ] * sett [ k ] > sett [ j ] * sett [ 
	    elif sett [ i ] * sett [ k ] > sett [ j ] * sett  	      -- i ;						    	    if ( sett [ j ] % sett [ i ] == 0 ) L [ i ] [ j ] = 2 
		if sett [ j ] % sett [ i ] == 0 :	      	    }							    	    else L [ i ] [ j ] = 1 ;				  
		    L [ i ] [ j ] = 2			      	    else {						    	    i -- ;						  
		else :					      	      L [ i ] [ j ] = L [ j ] [ k ] + 1 ;		    	  }							  
		    L [ i ] [ j ] = 1			      	      if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ] ;    	  else {						  
		i -= 1					      	      -- i ;						    	    L [ i ] [ j ] = L [ j ] [ k ] + 1 ;			  
	    else :					      	      ++ k ;						    	    if ( L [ i ] [ j ] > llgp ) llgp = L [ i ] [ j ] ;	  
		L [ i ] [ j ] = L [ j ] [ k ] + 1	      	    }							    	    i -- ;						  
		if L [ i ] [ j ] > llgp :		      	  }							    	    k ++ ;						  
		    llgp = L [ i ] [ j ]		      	  while ( i >= 0 ) {					    	  }							  
		i -= 1					      	    if ( set [ j ] % set [ i ] == 0 ) L [ i ] [ j ] = 2 ;   	}							  
		k + 1					      	    else L [ i ] [ j ] = 1 ;				    	while ( i >= 0 ) {					  
	while i >= 0 :					      	    -- i ;						    	  if ( sett [ j ] % sett [ i ] == 0 ) L [ i ] [ j ] = 2 ; 
	    if sett [ j ] % sett [ i ] == 0 :		      	  }							    	  else L [ i ] [ j ] = 1 ;				  
		L [ i ] [ j ] = 2			      	}							    	  i -- ;						  
	    else :					      	return llgp ;						    	}							  
		L [ i ] [ j ] = 1			      }								      }								  
	    i -= 1					      								      return llgp ;						  
    return llgp						      								      return n * n ;						  
							      								      return n * n * n * n * n * n * n * n * n * n * n * n * n *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS		      SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS			    SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS			  SHORTEST_POSSIBLE_COMBINATION_TWO_STRINGS
--							      --							    --								  --
def printSuperSeq ( a , b ) :				      void printSuperSeq ( string & a , string & b ) {		    int printSuperSeq ( string a , string b ) {			  script_not_found : None
    m = len ( a )					      	int m = a . length ( ) , n = b . length ( ) ;		      int m = a . length ( ) ;					  
    n = len ( b )					      	int dp [ m + 1 ] [ n + 1 ] ;				      int n = b . length ( ) ;					  
    dp = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ]	      	for ( int i = 0 ;					      vector < vector < int >> dp ( m + 1 , vector < int > ( n +  
    for i in range ( 0 , m + 1 ) :			      	i <= m ;						      for ( int i = 0 ;						  
	for j in range ( 0 , n + 1 ) :			      	i ++ ) {						      i <= m ;							  
	    if not i :					      	  for ( int j = 0 ;					      i ++ ) {							  
		dp [ i ] [ j ] = j			      	  j <= n ;						    	for ( int j = 0 ;					  
	    elif not j :				      	  j ++ ) {						    	j <= n ;						  
		dp [ i ] [ j ] = i			      	    if ( ! i ) dp [ i ] [ j ] = j ;			    	j ++ ) {						  
	    elif ( a [ i - 1 ] == b [ j - 1 ] ) :	      	    else if ( ! j ) dp [ i ] [ j ] = i ;		    	  if ( ! i ) dp [ i ] [ j ] = j ;			  
		dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ]   	    else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 	  else if ( ! j ) dp [ i ] [ j ] = i ;			  
	    else :					      	    else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp 	  else if ( ( a [ i - 1 ] == b [ j - 1 ] ) ) dp [ i ] [ j 
		dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] 	  }							    	  else dp [ i ] [ j ] = 1 + min < int > ( dp [ i - 1 ] [  
    index = dp [ m ] [ n ]				      	}							    	}							  
    res = [ "" ] * ( index )				      	int index = dp [ m ] [ n ] ;				      }								  
    i = m						      	string res ( index + 1 , '\0' ) ;			      int index = dp [ m ] [ n ] ;				  
    j = n						      	int i = m , j = n ;					      string res ;						  
    while ( i > 0 and j > 0 ) :				      	while ( i > 0 && j > 0 ) {				      for ( int i = 0 ;						  
	if ( a [ i - 1 ] == b [ j - 1 ] ) :		      	  if ( a [ i - 1 ] == b [ j - 1 ] ) {			      i <= m ;							  
	    res [ index - 1 ] = a [ i - 1 ]		      	    res [ index - 1 ] = a [ i - 1 ] ;			      i ++ ) {							  
	    i -= 1					      	    i -- ;						    	if ( ( a [ i - 1 ] == b [ j - 1 ] ) ) {			  
	    j -= 1					      	    j -- ;						    	  res [ index - 1 ] = a [ i - 1 ] ;			  
	    index -= 1					      	    index -- ;						    	  i -- ;						  
	elif ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) :    	  }							    	  j -- ;						  
	    res [ index - 1 ] = a [ i - 1 ]		      	  else if ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) {	    	  index -- ;						  
	    i -= 1					      	    res [ index - 1 ] = a [ i - 1 ] ;			    	}							  
	    index -= 1					      	    i -- ;						    	else if ( ( dp [ i - 1 ] [ j ] < dp [ i ] [ j - 1 ] ) ) { 
	else :						      	    index -- ;						    	  res [ index - 1 ] = a [ i - 1 ] ;			  
	    res [ index - 1 ] = b [ j - 1 ]		      	  }							    	  i -- ;						  
	    j -= 1					      	  else {						    	  index -- ;						  
	    index -= 1					      	    res [ index - 1 ] = b [ j - 1 ] ;			    	}							  
    while ( i > 0 ) :					      	    j -- ;						    	else {							  
	res [ index - 1 ] = a [ i - 1 ]			      	    index -- ;						    	  res [ index - 1 ] = b [ j - 1 ] ;			  
	i -= 1						      	  }							    	  j -- ;						  
	index -= 1					      	}							    	  index -- ;						  
    while ( j > 0 ) :					      	while ( i > 0 ) {					    	}							  
	res [ index - 1 ] = b [ j - 1 ]			      	  res [ index - 1 ] = a [ i - 1 ] ;			      }								  
	j -= 1						      	  i -- ;						      while ( ( i > 0 ) ) {					  
	index -= 1					      	  index -- ;						    	res [ index - 1 ] = a [ i - 1 ] ;			  
    print ( "".join ( res ) )				      	}							    	i -- ;							  
							      	while ( j > 0 ) {					    	index -- ;						  
							      	  res [ index - 1 ] = b [ j - 1 ] ;			      }								  
							      	  j -- ;						      while ( ( j > 0 ) ) {					  
							      	  index -- ;						    	res [ index - 1 ] = b [ j - 1 ] ;			  
							      	}							    	j -- ;							  
							      	cout << res ;						    	index -- ;						  
							      }								      }								  
							      								      cout << res << endl ;					  
							      								      return m ;						  
							      								      return m * m ;						  
							      								      return m * m ;						  
							      								      return m * m * m * m * m * m * m * m * m * m * m * m * m *  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING    DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING    DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING	  DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING
--							      --							    --								  --
def decode ( Str ) :					      string decode ( string str ) {				    string decode ( string Str ) {				  error : DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FO
    integerstack = [ ]					      	stack < int > integerstack ;				      vector < int > integerstack ;				  LLOWED_SUBSTRING.cpp: In function ‘std::__cxx11::s
    stringstack = [ ]					      	stack < char > stringstack ;				      string stringstack ;					  tring f_filled(std::__cxx11::string)’: DECODE_STRI
    temp = ""						      	string temp = "" , result = "" ;			      string temp ;						  NG_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING.cp
    result = ""						      	for ( int i = 0 ;					      string result ;						  p:110:22: error: no match for ‘operator+=’ (operan
    for i in range ( len ( Str ) ) :			      	i < str . length ( ) ;					      for ( int i = 0 ;						  d types are ‘std::vector<int>’ and ‘int’)
	count = 0					      	i ++ ) {						      i < Str . length ( ) ;					   integerstack += 1 ;		~~~~~~~~~~~~~^~~~ DE
	if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) :	      	  int count = 0 ;					      i ++ ) {							  CODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUB
	    while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : 	  if ( str [ i ] >= '0' && str [ i ] <= '9' ) {		    	int count = 0 ;						  STRING.cpp:119:1: warning: no return statement in
		count = count * 10 + ord ( Str [ i ] ) - ord  	    while ( str [ i ] >= '0' && str [ i ] <= '9' ) {	    	if ( ( Str [ i ] >= '0' && Str [ i ] <= '9' ) ) {	  function returning non-void [-Wreturn-type]  }  ^
		i += 1					      	      count = count * 10 + str [ i ] - '0' ;		    	  while ( ( Str [ i ] >= '0' && Str [ i ] <= '9' ) ) {	  DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_S
	    i -= 1					      	      i ++ ;						    	    count = count * 10 + Str [ i ] - '0' ;		  UBSTRING.cpp: At global scope: DECODE_STRING_RECUR
	    integerstack.append ( count )		      	    }							    	    i ++ ;						  SIVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING.cpp:120:1:
	elif ( Str [ i ] == ']' ) :			      	    i -- ;						    	  }							   error: expected unqualified-id before ‘return’  r
	    temp = ""					      	    integerstack . push ( count ) ;			    	  i -- ;						  eturn result ;  ^~~~~~ DECODE_STRING_RECURSIVELY_E
	    count = 0					      	  }							    	  integerstack . push_back ( count ) ;			  NCODED_COUNT_FOLLOWED_SUBSTRING.cpp:121:1: error:
	    if ( len ( integerstack ) != 0 ) :		      	  else if ( str [ i ] == ']' ) {			    	}							  expected unqualified-id before ‘return’  return "
		count = integerstack [ - 1 ]		      	    temp = "" ;						    	else if ( ( Str [ i ] == ']' ) ) {			  " + Str + " " + Str ;	 ^~~~~~ DECODE_STRING_RECURS
		integerstack.pop ( )			      	    count = 0 ;						    	  temp = "" ;						  IVELY_ENCODED_COUNT_FOLLOWED_SUBSTRING.cpp:122:1:
	    while ( len ( stringstack ) != 0 and stringstack  	    if ( ! integerstack . empty ( ) ) {			    	  int count = 0 ;					  error: expected unqualified-id before ‘return’  re
		temp = stringstack [ - 1 ] + temp	      	      count = integerstack . top ( ) ;			    	  if ( ( integerstack . size ( ) != 0 ) ) {		  turn " " + Str ;  ^~~~~~ DECODE_STRING_RECURSIVELY
		stringstack.pop ( )			      	      integerstack . pop ( ) ;				    	    count = integerstack [ integerstack . size ( ) - 1 ]  _ENCODED_COUNT_FOLLOWED_SUBSTRING.cpp:123:1: error
	    if ( len ( stringstack ) != 0 and stringstack [ - 	    }							    	    integerstack . pop_back ( ) ;			  : expected unqualified-id before ‘return’  return
		stringstack.pop ( )			      	    while ( ! stringstack . empty ( ) && stringstack . top  	  }							  " " + Str ;  ^~~~~~ DECODE_STRING_RECURSIVELY_ENCO
	    for j in range ( count ) :			      	      temp = stringstack . top ( ) + temp ;		    	  while ( ( stringstack . size ( ) != 0 ) && stringstack  DED_COUNT_FOLLOWED_SUBSTRING.cpp:124:1: error: exp
		result = result + temp			      	      stringstack . pop ( ) ;				    	    temp = stringstack [ stringstack . size ( ) - 1 ] + t ected unqualified-id before ‘return’	return " " +
	    for j in range ( len ( result ) ) :		      	    }							    	    stringstack . pop_back ( ) ;			   Str ;  ^~~~~~ DECODE_STRING_RECURSIVELY_ENCODED_C
		stringstack.append ( result [ j ] )	      	    if ( ! stringstack . empty ( ) && stringstack . top ( ) 	  }							  OUNT_FOLLOWED_SUBSTRING.cpp:125:1: error: expected
	    result = ""					      	    for ( int j = 0 ;					    	  if ( ( stringstack . size ( ) != 0 ) && stringstack [ s  unqualified-id before ‘return’  return " " + Str
	elif ( Str [ i ] == '[' ) :			      	    j < count ;						    	  for ( int j = 0 ;					  ;  ^~~~~~ DECODE_STRING_RECURSIVELY_ENCODED_COUNT_
	    if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9 	    j ++ ) result = result + temp ;			    	  j < count ;						  FOLLOWED_SUBSTRING.cpp:126:1: error: expected unqu
		stringstack.append ( Str [ i ] )	      	    for ( int j = 0 ;					    	  j ++ ) result = result + temp ;			  alified-id before ‘return’  return " " + Str ;  ^~
	    else :					      	    j < result . length ( ) ;				    	  for ( int j = 0 ;					  ~~~~ DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLO
		stringstack.append ( Str [ i ] )	      	    j ++ ) stringstack . push ( result [ j ] ) ;	    	  j < result . length ( ) ;				  WED_SUBSTRING.cpp:127:1: error: expected unqualifi
		integerstack.append ( 1 )		      	    result = "" ;					    	  j ++ ) stringstack += result [ j ] ;			  ed-id before ‘return’	 return " " + Str ;  ^~~~~~
	else :						      	  }							    	  result = "" ;						  DECODE_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_S
	    stringstack.append ( Str [ i ] )		      	  else if ( str [ i ] == '[' ) {			    	}							  UBSTRING.cpp:128:1: error: expected unqualified-id
    while len ( stringstack ) != 0 :			      	    if ( str [ i - 1 ] >= '0' && str [ i - 1 ] <= '9' ) str 	else if ( ( Str [ i ] == '[' ) ) {			   before ‘return’  return " " + Str ;	^~~~~~ DECOD
	result = stringstack [ - 1 ] + result		      	    else {						    	  if ( ( Str [ i - 1 ] >= '0' && Str [ i - 1 ] <= '9' ) ) E_STRING_RECURSIVELY_ENCODED_COUNT_FOLLOWED_SUBSTR
	stringstack.pop ( )				      	      stringstack . push ( str [ i ] ) ;		    	  else {						  ING.cpp:129:1: error: expected declaration before
    return result					      	      integerstack . push ( 1 ) ;			    	    stringstack += Str [ i ] ;				  ‘}’ token  }	^
							      	    }							    	    integerstack += 1 ;					  
							      	  }							    	  }							  
							      	  else stringstack . push ( str [ i ] ) ;		    	}							  
							      	}							    	else stringstack += Str [ i ] ;				  
							      	while ( ! stringstack . empty ( ) ) {			      }								  
							      	  result = stringstack . top ( ) + result ;		      while ( stringstack . size ( ) != 0 ) {			  
							      	  stringstack . pop ( ) ;				    	result = stringstack [ stringstack . size ( ) - 1 ] + res 
							      	}							    	stringstack . pop_back ( ) ;				  
							      	return result ;						      }								  
							      }								    }								  
							      								    return result ;						  
							      								    return " " + Str + " " + Str ;				  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    return " " + Str ;						  
							      								    }								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE		      NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE		    NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE		  NUMBER_WAYS_INSERT_CHARACTER_INCREASE_LCS_ONE
--							      --							    --								  --
def numberofways ( A , B , N , M ) :			      int numberofways ( string A , string B , int N , int M ) {    int numberofways ( string A , string B , int N , int M ) {	  script_not_found : None
    pos = [ [ ] for _ in range ( MAX ) ]		      	vector < int > pos [ MAX ] ;				      vector < vector < int >> pos ( MAX , vector < int > ( ) ) ; 
    for i in range ( M ) :				      	for ( int i = 0 ;					      for ( int i = 0 ;						  
	pos [ ord ( B [ i ] ) ].append ( i + 1 )	      	i < M ;							      i < M ;							  
    dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ]      	i ++ ) pos [ B [ i ] ] . push_back ( i + 1 ) ;		      i ++ ) pos [ ( int ) B [ i ] ] . push_back ( i + 1 ) ;	  
    for i in range ( 1 , N + 1 ) :			      	int dpl [ N + 2 ] [ M + 2 ] ;				      vector < vector < int >> dpl ( N + 2 , vector < int > ( ) ) 
	for j in range ( 1 , M + 1 ) :			      	memset ( dpl , 0 , sizeof ( dpl ) ) ;			      for ( int i = 1 ;						  
	    if A [ i - 1 ] == B [ j - 1 ] :		      	for ( int i = 1 ;					      i <= N ;							  
		dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 	i <= N ;						      i ++ ) for ( int j = 1 ;					  
	    else :					      	i ++ ) {						      j <= M ;							  
		dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , 	  for ( int j = 1 ;					      j ++ ) if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] =  
    LCS = dpl [ N ] [ M ]				      	  j <= M ;						      else dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i  
    dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ]      	  j ++ ) {						      int LCS = dpl [ N ] [ M ] ;				  
    for i in range ( N , 0 , - 1 ) :			      	    if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl   vector < vector < int >> dpr ( N + 2 , vector < int > ( ) ) 
	for j in range ( M , 0 , - 1 ) :		      	    else dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl    for ( int i = N ;						  
	    if A [ i - 1 ] == B [ j - 1 ] :		      	  }							      i > 0 ;							  
		dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 	}							      i -- ) for ( int j = M ;					  
	    else :					      	int LCS = dpl [ N ] [ M ] ;				      j > 0 ;							  
		dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , 	int dpr [ N + 2 ] [ M + 2 ] ;				      j -- ) if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] =  
    ans = 0						      	memset ( dpr , 0 , sizeof ( dpr ) ) ;			      else dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i  
    for i in range ( N + 1 ) :				      	for ( int i = N ;					      int ans = 0 ;						  
	for j in range ( MAX ) :			      	i >= 1 ;						      for ( int i = 0 ;						  
	    for x in pos [ j ] :			      	i -- ) {						      i < N + 1 ;						  
		if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x +  	  for ( int j = M ;					      i ++ ) for ( int j = 0 ;					  
		    ans += 1				      	  j >= 1 ;						      j < MAX ;							  
		    break				      	  j -- ) {						      j ++ ) for ( int x = 0 ;					  
    return ans						      	    if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr   x < pos [ j ] . size ( ) ;				  
							      	    else dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr    x ++ ) if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] = 
							      	  }							    	ans ++ ;						  
							      	}							    	break ;							  
							      	int ans = 0 ;						      }								  
							      	for ( int i = 0 ;					    }								  
							      	i <= N ;						    return ans ;						  
							      	i ++ ) {						    return N * N ;						  
							      	  for ( int j = 0 ;					    return N * N * N * N * N * N * N * N * N * N * N * N * N * N  
							      	  j < MAX ;						    								  
							      	  j ++ ) {						    								  
							      	    for ( auto x : pos [ j ] ) {			    								  
							      	      if ( dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == 								  
							      		ans ++ ;					    								  
							      		break ;						    								  
							      	      }							    								  
							      	    }							    								  
							      	  }							    								  
							      	}							    								  
							      	return ans ;						    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
=========================================================     =========================================================	    =========================================================	  =========================================================
PRINT_EQUAL_SUM_SETS_ARRAY_PARTITION_PROBLEM_SET_2	      PRINT_EQUAL_SUM_SETS_ARRAY_PARTITION_PROBLEM_SET_2	    PRINT_EQUAL_SUM_SETS_ARRAY_PARTITION_PROBLEM_SET_2		  PRINT_EQUAL_SUM_SETS_ARRAY_PARTITION_PROBLEM_SET_2
--							      --							    --								  --
def printEqualSumSets ( arr , n ) :			      void printEqualSumSets ( int arr [ ] , int n ) {		    int printEqualSumSets ( int * arr , int n ) {		  script_not_found : None
    sum_array = sum ( arr )				      	int i , currSum ;					      int sumArray = sum ( arr ) ;				  
    if ( sum_array & 1 ) :				      	int sum = accumulate ( arr , arr + n , 0 ) ;		      if ( ( sumArray & 1 ) != 0 ) {				  
	print ( "-1" )					      	if ( sum & 1 ) {					    	cout << "-1" << endl ;					  
	return						      	  cout << "-1" ;					    	return 0 ;						  
    k = sum_array >> 1					      	  return ;						      }								  
    dp = np.zeros ( ( n + 1 , k + 1 ) )			      	}							      int k = sumArray >> 1 ;					  
    for i in range ( 1 , k + 1 ) :			      	int k = sum >> 1 ;					      vector < vector < bool >> dp ( n + 1 , vector < bool > ( k  
	dp [ 0 ] [ i ] = False				      	bool dp [ n + 1 ] [ k + 1 ] ;				      for ( int i = 1 ;						  
    for i in range ( n + 1 ) :				      	for ( i = 1 ;						      i <= k ;							  
	dp [ i ] [ 0 ] = True				      	i <= k ;						      i ++ ) dp [ 0 ] [ i ] = false ;				  
    for i in range ( 1 , n + 1 ) :			      	i ++ ) dp [ 0 ] [ i ] = false ;				      for ( int i = 0 ;						  
	for currSum in range ( 1 , k + 1 ) :		      	for ( i = 0 ;						      i < n + 1 ;						  
	    dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ]   	i <= n ;						      i ++ ) dp [ i ] [ 0 ] = true ;				  
	    if ( arr [ i - 1 ] <= currSum ) :		      	i ++ ) dp [ i ] [ 0 ] = true ;				      for ( int i = 1 ;						  
		dp [ i ] [ currSum ] = ( dp [ i ] [ currSum ] 	for ( i = 1 ;						      i <= n ;							  
    set1 , set2 = [ ] , [ ]				      	i <= n ;						      i ++ ) for ( int currSum = 1 ;				  
    if ( not dp [ n ] [ k ] ) :				      	i ++ ) {						      currSum <= k ;						  
	print ( "-1" )					      	  for ( currSum = 1 ;					      currSum ++ ) {						  
	return						      	  currSum <= k ;					    	dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ;	  
    i = n						      	  currSum ++ ) {					    	if ( ( arr [ i - 1 ] <= currSum ) ) dp [ i ] [ currSum ]  
    currSum = k						      	    dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ;	      }								  
    while ( i > 0 and currSum >= 0 ) :			      	    if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] =    vector < int > set1 , set2 ;				  
	if ( dp [ i - 1 ] [ currSum ] ) :		      	  }							      if ( ( ! dp [ n ] [ k ] ) ) {				  
	    i -= 1					      	}							    	cout << "-1" << endl ;					  
	    set2.append ( arr [ i ] )			      	vector < int > set1 , set2 ;				    	return 0 ;						  
	elif ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) :   	if ( ! dp [ n ] [ k ] ) {				      }								  
	    i -= 1					      	  cout << "-1\n" ;					      int i = n ;						  
	    currSum -= arr [ i ]			      	  return ;						      int currSum = k ;						  
	    set1.append ( arr [ i ] )			      	}							      while ( ( i > 0 ) && currSum >= 0 ) {			  
    print ( "Set 1 elements:" , end = " " )		      	i = n ;							    	if ( ( dp [ i - 1 ] [ currSum ] ) ) {			  
    for i in range ( len ( set1 ) ) :			      	currSum = k ;						    	  i -- ;						  
	print ( set1 [ i ] , end = " " )		      	while ( i > 0 && currSum >= 0 ) {			    	  set2 . push_back ( arr [ i ] ) ;			  
    print ( "\nSet 2 elements:" , end = " " )		      	  if ( dp [ i - 1 ] [ currSum ] ) {			    	}							  
    for i in range ( len ( set2 ) ) :			      	    i -- ;						    	else if ( ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) )  
	print ( set2 [ i ] , end = " " )		      	    set2 . push_back ( arr [ i ] ) ;			    	  i -- ;						  
							      	  }							    	  currSum -= arr [ i ] ;				  
							      	  else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) {    	  set1 . push_back ( arr [ i ] ) ;			  
							      	    i -- ;						    	}							  
							      	    currSum -= arr [ i ] ;				      }								  
							      	    set1 . push_back ( arr [ i ] ) ;			      cout << "Set 1 elements:" << endl ;			  
							      	  }							      for ( int i = 0 ;						  
							      	}							      i < set1 . size ( ) ;					  
							      	cout << "Set 1 elements: " ;				      i ++ ) cout << set1 [ i ] << " " ;			  
							      	for ( i = 0 ;						      cout << "\nSet 2 elements:" << endl ;			  
							      	i < set1 . size ( ) ;					      for ( int i = 0 ;						  
							      	i ++ ) cout << set1 [ i ] << " " ;			      i < set2 . size ( ) ;					  
							      	cout << "\nSet 2 elements: " ;				      i ++ ) cout << set2 [ i ] << " " ;			  
							      	for ( i = 0 ;						      return 0 ;						  
							      	i < set2 . size ( ) ;					    }								  
							      	i ++ ) cout << set2 [ i ] << " " ;			    								  
							      }								    								  
-							      -								    -								  -
--							      --							    --								  --
							      								    								  
